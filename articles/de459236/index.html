<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶ë üö≤ ü§æüèΩ SQL: Arbeitszeit-Task-L√∂sung üë©‚Äçüíª ü•õ üë©üèΩ‚Äç‚úàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo, Radio SQL ist wieder auf Sendung! Heute haben wir eine L√∂sung f√ºr das Problem , das wir in unserer vorherigen Sendung √ºbertragen haben, und hab...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SQL: Arbeitszeit-Task-L√∂sung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/459236/"><p>  Hallo, Radio SQL ist wieder auf Sendung!  Heute haben wir eine L√∂sung f√ºr das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Problem</a> , das wir in unserer vorherigen Sendung √ºbertragen haben, und haben versprochen, das n√§chste Mal auszumachen.  Und das n√§chste Mal ist gekommen. </p><br><p>  Die Aufgabe l√∂ste eine lebhafte Reaktion unter den Humanoiden der Milchstra√üe aus (und nicht √ºberraschend mit ihrer Arbeitssklaverei, die sie immer noch zum Wohle der Zivilisation respektieren).  Leider wurde auf dem dritten Planeten der Start des Spectrum-RG-Weltraumobservatoriums Ende Juli 2019, der RC (Local Chronology), verschoben, mit deren Hilfe die Ausstrahlung dieser Sendung geplant war.  Ich musste nach alternativen √úbertragungswegen suchen, was zu einer leichten Verz√∂gerung des Signals f√ºhrte.  Aber alles ist gut, das endet gut. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rc/a6/z4/rca6z4cduxlps2le_c4l_3rwnrg.png"></div><br><p>  Ich muss sofort sagen, dass es keine Magie in der Analyse der Aufgabe geben wird, es nicht notwendig ist, hier nach Enth√ºllungen zu suchen oder auf eine besonders effektive (oder besonders in einem anderen Sinne) Implementierung zu warten.  Dies ist nur eine Analyseaufgabe.  Darin k√∂nnen diejenigen, die nicht wissen, wie sie sich der L√∂sung solcher Probleme n√§hern sollen, sehen, wie sie gel√∂st werden k√∂nnen.  Au√üerdem gibt es hier nichts Schreckliches. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Lassen Sie mich Sie an den Zustand erinnern.</b> <div class="spoiler_text"><p>  Es gibt mehrere Zeitintervalle, die durch das Datum und die Uhrzeit des Beginns und Endes angegeben werden (ein Beispiel in der PostgreSQL-Syntax): </p><br><pre><code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> periods(id, start_time, stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-03-29 07:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-08 14:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-10 07:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-10 20:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-11 12:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-12 16:07:12'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>), (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'2018-12-28 12:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-01-16 16:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) )</code> </pre> <br><p>  In einer SQL-Abfrage (c) muss die Dauer jedes Intervalls in Arbeitsstunden berechnet werden.  Wir glauben, dass wir wochentags von Montag bis Freitag arbeiten, die Arbeitszeiten sind immer von 10:00 bis 19:00 Uhr.  Dar√ºber hinaus gibt es gem√§√ü dem Produktionskalender der Russischen F√∂deration eine Reihe von offiziellen Feiertagen, die keine Arbeitstage sind, und einige der freien Tage sind im Gegenteil Arbeitstage, da dieselben Feiertage verschoben werden.  Eine Verk√ºrzung der Vorferientage ist nicht erforderlich, wir halten sie f√ºr vollst√§ndig.  Da die Feiertage von Jahr zu Jahr variieren, dh durch explizite Auflistung festgelegt werden, beschr√§nken wir uns auf Daten nur von 2018 und 2019.  Ich bin sicher, dass die L√∂sung bei Bedarf leicht erg√§nzt werden kann. </p><br><p>  Es ist erforderlich, eine Spalte mit der Dauer in Arbeitsstunden zu den Anfangsperioden von <em>Perioden</em> hinzuzuf√ºgen.  Hier ist das Ergebnis: </p><br><pre> <code class="pgsql hljs"> id | start_time | stop_time | work_hrs <span class="hljs-comment"><span class="hljs-comment">----+---------------------+---------------------+---------- 1 | 2019-03-29 07:00:00 | 2019-04-08 14:00:00 | 58:00:00 2 | 2019-04-10 07:00:00 | 2019-04-10 20:00:00 | 09:00:00 3 | 2019-04-11 12:00:00 | 2019-04-12 16:07:12 | 13:07:12 4 | 2018-12-28 12:00:00 | 2019-01-16 16:00:00 | 67:00:00</span></span></code> </pre> <br><p>  Wir √ºberpr√ºfen die Anfangsdaten nicht auf Richtigkeit, sondern ber√ºcksichtigen immer <em>start_time &lt;= stop_time</em> . </p><br><p>  Das Ende der Bedingung, das Original ist hier: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://habr.com/en/company/postgrespro/blog/448368/</a> . </p></div></div><br><p>  Die Aufgabe verleiht der Tatsache, dass ich bewusst eine gute H√§lfte der Bedingung bewusst in beschreibender Form angegeben habe (wie dies im wirklichen Leben der Fall ist), eine leichte Pikantheit, wobei es im Ermessen der technischen Implementierung liegt, wie der Zeitplan festgelegt werden soll.  Dies erfordert zum einen einige architektonische Denkf√§higkeiten.  Andererseits h√§tte das vorgefertigte Format dieses Zeitplans zu einer Verwendung der Vorlage gef√ºhrt.  Und wenn Sie weglassen, werden Gedanken und Fantasien besser funktionieren.  Der Empfang hat sich voll ausgezahlt und mir erm√∂glicht, auch in den ver√∂ffentlichten L√∂sungen interessante Ans√§tze zu finden. </p><br><p>  Um das urspr√ºngliche Problem auf diese Weise zu l√∂sen, m√ºssen zwei Unteraufgaben gel√∂st werden: </p><br><ol><li>  Bestimmen Sie, wie Sie einen Arbeitsplan am kompaktesten festlegen k√∂nnen und ob dies f√ºr eine L√∂sung bequem ist. </li><li>  Berechnen Sie tats√§chlich die Dauer jeder Quellperiode in Arbeitsstunden gem√§√ü dem Arbeitsplan aus der vorherigen Unteraufgabe. </li></ol><br><p>  Und es ist besser, mit der zweiten zu beginnen, um zu verstehen, in welcher Form wir die erste l√∂sen m√ºssen.  L√∂sen Sie dann die erste und kehren Sie erneut zur zweiten zur√ºck, um das Endergebnis zu erhalten. <br>  Wir werden das Ergebnis schrittweise mithilfe der CTE-Syntax erfassen, mit der wir alle erforderlichen Datenbeispiele in separate benannte Unterabfragen einf√ºgen und dann alles miteinander verkn√ºpfen k√∂nnen. </p><br><p>  Nun, lass uns gehen. </p><br><h3 id="poschitat-dlitelnost-v-rabochih-chasah">  Berechnen Sie die Dauer in Arbeitsstunden </h3><br><p>  Um die Dauer jeder Arbeitszeit in der Stirn zu berechnen, m√ºssen Sie die Anfangszeit (gr√ºne Farbe im Diagramm) mit den Intervallen kreuzen, die die Arbeitszeit beschreiben (orange).  Die Arbeitszeitintervalle sind montags von 10:00 bis 19:00 Uhr, dienstags von 10:00 bis 19:00 Uhr und so weiter.  Das Ergebnis wird blau angezeigt: </p><br><p><img src="https://habrastorage.org/webt/o4/yh/6_/o4yh6_ca7loarlvtghe572p6zdo.png" alt="Bild"></p><br><p>  √úbrigens, um weniger verwirrt zu sein, werde ich die Anfangsperioden weiterhin als Anfangsperioden bezeichnen und Arbeitszeitintervalle aufrufen. </p><br><p>  Der Vorgang sollte f√ºr jede Anfangsperiode wiederholt werden.  Die Anfangsperioden f√ºr uns sind bereits auf der <em>Registerkarte Perioden (start_time, stop_time) festgelegt</em> . Wir werden die Arbeitszeiten in Form einer Tabelle darstellen, z. B. <em>Zeitplan (strat_time, stop_time)</em> , in der jeder Arbeitstag vorhanden ist.  Das Ergebnis ist ein vollst√§ndiges kartesisches Produkt aller anf√§nglichen Perioden und Intervalle der Arbeitszeit. </p><br><p>  Schnittpunkte k√∂nnen auf klassische Weise gez√§hlt werden, wobei alle m√∂glichen Optionen f√ºr Schnittintervalle ber√ºcksichtigt wurden - wir schneiden Gr√ºn mit Orange, das Ergebnis ist blau: </p><br><p><img src="https://habrastorage.org/webt/fx/aq/wo/fxaqwo7uud0kyzismeqn6cqeap0.png" alt="Bild"></p><br><p>  und jeweils den gew√ºnschten Wert f√ºr den Anfang und das Ende des Ergebnisses nehmen: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> s.start_time, s.stop_time <span class="hljs-comment"><span class="hljs-comment">-- case #1 from periods p, schedule s where p.start_time &lt;= s.start_time and p.stop_time &gt; s.stop_time union all select p.start_time, s.stop_time -- case #2 from periods p, schedule s where p.start_time &gt;= s.start_time and p.stop_time &gt; s.stop_time and p.start_time &lt; s.stop_time union all select s.start_time, p.stop_time -- case #3 from periods p, schedule s where p.start_time &lt;= s.start_time and p.stop_time &lt; s.stop_time and p.stop_time &gt; s.start_time union all select p.start_time, p.stop_time -- case #4 from periods p, schedule s where p.start_time &gt;= s.start_time and p.stop_time &lt; s.stop_time</span></span></code> </pre> <br><p>  Da wir f√ºr jede Kreuzung nur eine von vier Optionen haben k√∂nnen, werden alle mit <em>union all</em> zu einer Anfrage zusammengefasst. </p><br><p>  Sie k√∂nnen dies auch tun, indem Sie den in PostgreSQL verf√ºgbaren <em>tsrange-</em> Bereichstyp und die daf√ºr bereits verf√ºgbare Schnittmenge verwenden: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time) * <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods p, schedule s</code> </pre> <br><p>  Stimmen Sie zu, dass es ein bisschen einfacher ist.  Im Allgemeinen gibt es in PostgreSQL eine Menge solcher praktischen Kleinigkeiten, daher ist es sehr sch√∂n, Abfragen dar√ºber zu schreiben. </p><br><h3 id="sgenerirovat-kalendar">  Kalender generieren </h3><br><p>  Nun zur√ºck zur Unteraufgabe mit dem Arbeitszeitplan. </p><br><p>  Wir m√ºssen den Arbeitsplan in Form von Arbeitszeitintervallen von 10:00 bis 19:00 f√ºr jeden Arbeitstag erhalten, so etwas wie einen <em>Zeitplan (start_time, stop_time)</em> .  Wie wir verstanden haben, wird es zweckm√§√üig sein, unser Problem zu l√∂sen.  Im wirklichen Leben sollte ein solcher Zeitplan gedeckt werden, f√ºr zwei Jahre sind es nur etwa 500 Datens√§tze, aus praktischen Gr√ºnden m√ºssen sogar zehn Jahre festgelegt werden - dies sind ein paar anderthalbtausend Datens√§tze, ein echter M√ºll f√ºr moderne Datenbanken.  Wir haben jedoch ein Problem, das in einer Anfrage gel√∂st werden kann, und die Auflistung der gesamten Tabelle ist nicht sehr praktisch.  Versuchen wir es kompakter zu implementieren. </p><br><p>  In jedem Fall ben√∂tigen wir Feiertage, um sie aus dem Basisplan zu entfernen, und hier ist nur die Auflistung geeignet: </p><br><pre> <code class="pgsql hljs"> dates_exclude(d) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>(<span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>), <span class="hljs-comment"><span class="hljs-comment">-- 2018 ('2018-01-02'::date), ('2018-01-03'::date), ('2018-01-04'::date), ('2018-01-05'::date), ('2018-01-08'::date), ('2018-02-23'::date), ('2018-03-08'::date), ('2018-03-09'::date), ('2018-05-01'::date), ('2018-05-02'::date), ('2018-05-09'::date), ('2018-06-11'::date), ('2018-06-12'::date), ('2018-11-05'::date), ('2018-12-31'::date), ('2019-01-01'::date), -- 2019 ('2019-01-02'::date), ('2019-01-03'::date), ('2019-01-04'::date), ('2019-01-07'::date), ('2019-01-08'::date), ('2019-03-08'::date), ('2019-05-01'::date), ('2019-05-02'::date), ('2019-05-03'::date), ('2019-05-09'::date), ('2019-05-10'::date), ('2019-06-12'::date), ('2019-11-04'::date) )</span></span></code> </pre> <br><p>  und zus√§tzliche Werktage, die hinzugef√ºgt werden m√ºssen: </p><br><pre> <code class="pgsql hljs"> dates_include(d) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> <span class="hljs-comment"><span class="hljs-comment">--  2018,  2019  ('2018-04-28'::date), ('2018-06-09'::date), ('2018-12-29'::date) )</span></span></code> </pre> <br><p>  Die Reihenfolge der Arbeitstage f√ºr zwei Jahre kann durch eine spezielle und sehr geeignete Funktion <em>generate_series () generiert</em> werden, die sofort Samstage und Sonntage auf dem Weg wirft: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series( <span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span> , <span class="hljs-string"><span class="hljs-string">'2020-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span> , <span class="hljs-string"><span class="hljs-string">'1 day'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> extract(<span class="hljs-type"><span class="hljs-type">dow</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> d) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-comment"><span class="hljs-comment">--    </span></span></code> </pre> <br><p>  Wir erhalten die Arbeitstage, indem wir alles miteinander verbinden: Wir generieren eine Folge aller Arbeitstage in zwei Jahren, f√ºgen zus√§tzliche Arbeitstage aus <em>date_include hinzu</em> und entfernen alle zus√§tzlichen Tage aus <em>date_exclude</em> : </p><br><pre> <code class="pgsql hljs"> schedule_base <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series( <span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span> , <span class="hljs-string"><span class="hljs-string">'2020-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span> , <span class="hljs-string"><span class="hljs-string">'1 day'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> extract(<span class="hljs-type"><span class="hljs-type">dow</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> d) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-comment"><span class="hljs-comment">--     union select d from dates_include --     except select d from dates_exclude --     )</span></span></code> </pre> <br><p>  Und jetzt bekommen wir die Zeitintervalle, die wir brauchen: </p><br><pre> <code class="pgsql hljs"> schedule(start_time, stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d + <span class="hljs-string"><span class="hljs-string">'10:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span>, d + <span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> schedule_base )</code> </pre> <br><p>  Also haben wir den Zeitplan. </p><br><h3 id="sobiraem-vsyo-vmeste">  Alles zusammenf√ºgen </h3><br><p>  Jetzt bekommen wir die Kreuzungen: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* , <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(p.start_time, p.stop_time) * <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wrkh <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods p <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> schedule s <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(p.start_time, p.stop_time) &amp;&amp; <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time)</code> </pre> <br><p>  Beachten Sie die <em>ON-</em> Verkn√ºpfungsbedingung, sie stimmt nicht mit zwei entsprechenden Datens√§tzen aus den verkn√ºpften Tabellen √ºberein, es gibt keine solche Entsprechung, aber es wird eine Optimierung eingef√ºhrt, die die Arbeitszeitintervalle verk√ºrzt, mit denen sich unsere Anfangsperiode nicht √ºberschneidet.  Dies erfolgt mit dem Operator <em>&amp;&amp;</em> , der den Schnittpunkt der <em>Bereichsintervalle</em> √ºberpr√ºft.  Dadurch werden viele leere Kreuzungen entfernt, um den Augen nicht im Weg zu stehen. Auf der anderen Seite werden jedoch Informationen zu den Anfangsperioden entfernt, die vollst√§ndig au√üerhalb der Gesch√§ftszeiten liegen.  Wir bewundern also, dass unser Ansatz funktioniert, und schreiben die Anfrage wie folgt um: </p><br><pre> <code class="pgsql hljs"> periods_wrk <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* , <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(p.start_time, p.stop_time) * <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wrkh <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods p , schedule s ) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> id, start_time, stop_time , sum(upper(wrkh)-lower(wrkh)) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods_wrk <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> id, start_time, stop_time</code> </pre> <br><p>  In <em>period_wrk</em> zerlegen <em>wir</em> jede <em>Quellperiode</em> in Arbeitsintervalle und betrachten dann ihre Gesamtdauer.  Das Ergebnis war ein vollst√§ndiges kartesisches Produkt aller Zeitr√§ume und Intervalle, aber es ging kein einziger Zeitraum verloren. </p><br><p>  Alles, das Ergebnis wird empfangen.  Die <em>NULL-</em> Werte f√ºr leere Intervalle haben mir nicht gefallen. Lassen Sie die Abfrage ein Intervall mit der L√§nge Null besser anzeigen.  Wickeln Sie die Menge in <em>coalesce ()</em> : </p><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> id, start_time, stop_time , coalesce(sum(upper(wrkh)-lower(wrkh)), <span class="hljs-string"><span class="hljs-string">'0 sec'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods_wrk <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> id, start_time, stop_time</code> </pre> <br><p>  Alles zusammen ergibt das Endergebnis: </p><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> periods(id, start_time, stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-03-29 07:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-08 14:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) , (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-10 07:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-10 20:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) , (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-11 12:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-12 16:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) , (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'2018-12-28 12:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-01-16 16:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) ), dates_exclude(d) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>(<span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>), <span class="hljs-comment"><span class="hljs-comment">-- 2018 ('2018-01-02'::date), ('2018-01-03'::date), ('2018-01-04'::date), ('2018-01-05'::date), ('2018-01-08'::date), ('2018-02-23'::date), ('2018-03-08'::date), ('2018-03-09'::date), ('2018-05-01'::date), ('2018-05-02'::date), ('2018-05-09'::date), ('2018-06-11'::date), ('2018-06-12'::date), ('2018-11-05'::date), ('2018-12-31'::date), ('2019-01-01'::date), -- 2019 ('2019-01-02'::date), ('2019-01-03'::date), ('2019-01-04'::date), ('2019-01-07'::date), ('2019-01-08'::date), ('2019-03-08'::date), ('2019-05-01'::date), ('2019-05-02'::date), ('2019-05-03'::date), ('2019-05-09'::date), ('2019-05-10'::date), ('2019-06-12'::date), ('2019-11-04'::date) ), dates_include(start_time, stop_time) as ( values --  2018,  2019  ('2018-04-28 10:00:00'::timestamp, '2018-04-28 19:00:00'::timestamp), ('2018-06-09 10:00:00'::timestamp, '2018-06-09 19:00:00'::timestamp), ('2018-12-29 10:00:00'::timestamp, '2018-12-29 19:00:00'::timestamp) ) ), schedule_base(start_time, stop_time) as ( select d::timestamp + '10:00:00', d::timestamp + '19:00:00' from generate_series( (select min(start_time) from periods)::date::timestamp , (select max(stop_time) from periods)::date::timestamp , '1 day'::interval ) as days(d) where extract(dow from d) not in (0,6) ), schedule as ( select * from schedule_base where start_time::date not in (select d from dates_exclude) union select * from dates_include ), periods_wrk as ( select p.* , tsrange(p.start_time, p.stop_time) * tsrange(s.start_time, s.stop_time) as wrkh from periods p , schedule s ) select id, start_time, stop_time , sum(coalesce(upper(wrkh)-lower(wrkh), '0 sec'::interval)) from periods_wrk group by id, start_time, stop_time</span></span></code> </pre> <br><p>  Hurra! .. Dies k√∂nnte abgeschlossen sein, aber der Vollst√§ndigkeit halber werden wir einige verwandte Themen betrachten. </p><br><h3 id="dalneyshee-razvitie-temy">  Weiterentwicklung des Themas </h3><br><p>  Verk√ºrzte Vorferientage, Mittagspausen, unterschiedliche Zeitpl√§ne f√ºr verschiedene Wochentage ... Im Prinzip ist alles klar, Sie m√ºssen die Definition des <em>Zeitplans</em> festlegen, geben Sie nur ein paar Beispiele. </p><br><p>  So k√∂nnen Sie je nach Wochentag unterschiedliche Start- und Endzeiten eines Arbeitstages einstellen: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d + <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> extract(<span class="hljs-type"><span class="hljs-type">dow</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> d) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-string"><span class="hljs-string">'10:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-comment"><span class="hljs-comment">--  when 2 then '11:00:00'::time --  when 3 then '11:00:00'::time --  --        else '10:00:00'::time end , d + case extract(dow from d) --   19   when 5 then '14:00:00'::time --  else '19:00:00'::time end from schedule_base</span></span></code> </pre> <br><p>  Wenn Sie die Mittagspausen von 13:00 bis 14:00 Uhr ber√ºcksichtigen m√ºssen, f√ºhren Sie anstelle eines Intervalls pro Tag zwei Schritte aus: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d + <span class="hljs-string"><span class="hljs-string">'10:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> , d + <span class="hljs-string"><span class="hljs-string">'13:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> schedule_base <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d + <span class="hljs-string"><span class="hljs-string">'14:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> , d + <span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> schedule_base</code> </pre> <br><p>  Gut und so weiter. </p><br><h3 id="proizvoditelnost">  Leistung </h3><br><p>  Ich werde ein paar Worte zur Leistung sagen, da es immer Fragen dazu gibt.  Ich werde noch nicht viel kauen, dies ist ein Abschnitt mit einem Sternchen. </p><br><p>  Im Allgemeinen ist eine vorzeitige Optimierung b√∂se.  Nach meiner langj√§hrigen Beobachtung ist die Lesbarkeit des Codes der wichtigste Vorteil.  Wenn der Code gut gelesen ist, ist es einfacher zu warten und zu entwickeln.  Gut lesbarer Code erfordert implizit sowohl eine gute L√∂sungsarchitektur, korrekte Kommentare als auch gute Variablennamen, Kompaktheit ohne Beeintr√§chtigung der Lesbarkeit usw., dh alles, wof√ºr der Code als gut bezeichnet wird. </p><br><p>  Daher ist die Anfrage immer so lesbar wie m√∂glich geschrieben, und wir beginnen genau dann mit der Optimierung, wenn sich herausstellt, dass die Leistung nicht ausreicht.  Dar√ºber hinaus werden wir es genau dort optimieren, wo die Leistung nicht ausreicht und genau so weit, dass es ausreicht.  Wenn Sie Ihre eigene Zeit sch√§tzen und etwas zu tun haben. </p><br><p>  Es ist jedoch richtig, keine unn√∂tige Arbeit in der Anfrage zu leisten. Sie sollten immer versuchen, dies zu ber√ºcksichtigen. </p><br><p>  Auf dieser Grundlage werden wir sofort eine Optimierung in die Abfrage aufnehmen - lassen Sie jede Quellperiode nur mit den Arbeitszeitintervallen schneiden, mit denen sie gemeinsame Punkte hat (anstelle einer langen klassischen Bedingung an den Bereichsgrenzen ist es bequemer, den integrierten Operator <em>&amp;&amp;</em> f√ºr den Typ <em>tsrange zu</em> verwenden).  Diese Optimierung ist bereits in der Anfrage enthalten, hat jedoch dazu gef√ºhrt, dass die anf√§nglichen Zeitr√§ume, die vollst√§ndig au√üerhalb der Arbeitszeit lagen, aus den Ergebnissen verschwunden sind. </p><br><p>  Bringen Sie diese Optimierung zur√ºck.  Verwenden Sie dazu <em>LEFT JOIN</em> , um alle Datens√§tze aus der <em>Periodentabelle zu</em> speichern.  Jetzt <em>sieht</em> die <em>Unterabfrage</em> period_wrk folgenderma√üen aus: </p><br><pre> <code class="pgsql hljs">, periods_wrk <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* , <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(p.start_time, p.stop_time) * <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wrkh <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods p <span class="hljs-keyword"><span class="hljs-keyword">left join</span></span> schedule s <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(p.start_time, p.stop_time) &amp;&amp; <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time))</code> </pre> <br><p>  Die Analyse der Anfrage zeigt, dass sich die Zeit f√ºr die Testdaten um etwa die H√§lfte verringert hat.  Da die Laufzeit davon abh√§ngt, was der Server zur gleichen Zeit tat, nahm ich einige Messungen vor und gab ein ‚Äûtypisches‚Äú Ergebnis, nicht das gr√∂√üte, nicht das kleinste, aus der Mitte. </p><br><p>  Alte Abfrage: </p><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyse</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> periods(id, start_time, stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( ... QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------ HashAggregate (cost=334.42..338.39 rows=397 width=36) (actual time=10.724..10.731 rows=4 loops=1) ...</span></span></code> </pre> <br><p>  Neu: </p><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyse</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> periods(id, start_time, stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( ... QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------ HashAggregate (cost=186.37..186.57 rows=20 width=36) (actual time=5.431..5.440 rows=4 loops=1) ...</span></span></code> </pre> <br><p>  Das Wichtigste ist jedoch, dass eine solche Anforderung auch besser skaliert wird und weniger Serverressourcen erfordert, da das gesamte kartesische Produkt sehr schnell w√§chst. </p><br><p>  Und hier w√ºrde ich mit Optimierungen aufh√∂ren.  Als ich dieses Problem f√ºr mich selbst l√∂ste, hatte ich selbst in einer viel schrecklicheren Form dieser Anfrage genug Leistung, aber es bestand wirklich kein Grund zur Optimierung.  Um einmal im Quartal einen Bericht √ºber meine Daten zu erhalten, kann ich weitere zehn Sekunden warten.  Die zus√§tzliche Stunde, die f√ºr die Optimierung unter solchen Bedingungen aufgewendet wird, wird sich niemals auszahlen. </p><br><p>  Es stellt sich jedoch als uninteressant heraus. Lassen Sie uns noch dar√ºber nachdenken, wie sich Ereignisse entwickeln k√∂nnten, wenn eine Optimierung der Ausf√ºhrungszeit wirklich erforderlich w√§re.  Zum Beispiel m√∂chten wir diesen Parameter in Echtzeit f√ºr jeden unserer Datens√§tze in der Datenbank √ºberwachen, dh f√ºr jedes Niesen wird eine solche Anforderung aufgerufen.  Nun, oder √ºberlegen Sie sich Ihren eigenen Grund, warum Sie optimieren m√ºssen. </p><br><p>  Das erste, was mir in den Sinn kommt, ist, einmal zu z√§hlen und eine Tabelle mit Arbeitsintervallen in die Datenbank aufzunehmen.  Es kann Kontraindikationen geben: Wenn die Datenbank nicht ge√§ndert werden kann oder Schwierigkeiten bei der Unterst√ºtzung relevanter Daten in einer solchen Tabelle zu erwarten sind.  Dann m√ºssen Sie die Generierung der Arbeitszeit ‚Äûon the fly‚Äú in der Anfrage selbst belassen, da dies keine sehr schwere Unterabfrage ist. </p><br><p>  Der n√§chste und leistungsst√§rkste (aber nicht immer anwendbare) Ansatz ist die algorithmische Optimierung.  Einige dieser Ans√§tze wurden bereits in den Kommentaren zum Artikel mit dem Zustand des Problems vorgestellt. </p><br><p>  Ich mag dieses am meisten.  Wenn Sie eine Tabelle mit allen (nicht nur Arbeitstagen) des Kalenders erstellen und die kumulierte Summe der Arbeitsstunden pro Tag aus einer bestimmten ‚ÄûErschaffung der Welt‚Äú berechnen, k√∂nnen Sie die Anzahl der Arbeitsstunden zwischen zwei Daten mit einer Subtraktionsoperation ermitteln.  Es bleibt nur, die Arbeitszeiten f√ºr den ersten und letzten Tag korrekt zu ber√ºcksichtigen - und Sie sind fertig.  Folgendes habe ich bei diesem Ansatz erreicht: </p><br><pre> <code class="pgsql hljs"> schedule_base(d, is_working) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> extract(<span class="hljs-type"><span class="hljs-type">dow</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> d+<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> d+<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">all</span></span>(<span class="hljs-string"><span class="hljs-string">'{2019-01-01,2019-01-02,2019-01-03,2019-01-04,2019-01-07,2019-01-08,2019-03-08,2019-05-01,2019-05-02,2019-05-03,2019-05-09,2019-05-10,2019-06-12,2019-11-04,2018-01-01,2018-01-02,2018-01-03,2018-01-04,2018-01-05,2018-01-08,2018-02-23,2018-03-08,2018-03-09,2018-04-30,2018-05-01,2018-05-02,2018-05-09,2018-06-11,2018-06-12,2018-11-05,2018-12-31}'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> d+<span class="hljs-number"><span class="hljs-number">1</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>(<span class="hljs-string"><span class="hljs-string">'{2018-04-28,2018-06-09,2018-12-29}'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> schedule_base <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> d &lt; <span class="hljs-string"><span class="hljs-string">'2020-01-01'</span></span> ), schedule(d, is_working, work_hours) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d, is_working , sum(is_working*<span class="hljs-string"><span class="hljs-string">'9 hours'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">over</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unbounded</span></span> <span class="hljs-keyword"><span class="hljs-keyword">preceding</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> schedule_base ) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* , s2.work_hours - s1.work_hours + (<span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> - least(greatest(p.start_time::<span class="hljs-type"><span class="hljs-type">time</span></span>, <span class="hljs-string"><span class="hljs-string">'10:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span>), <span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span>)) * s1.is_working - (<span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> - least(greatest(p.stop_time::<span class="hljs-type"><span class="hljs-type">time</span></span>, <span class="hljs-string"><span class="hljs-string">'10:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span>), <span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span>)) * s2.is_working <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wrk <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods p, schedule s1, schedule s2 <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> s1.d = p.start_time::<span class="hljs-type"><span class="hljs-type">date</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> s2.d = p.stop_time::<span class="hljs-type"><span class="hljs-type">date</span></span></code> </pre> <br><p>  Ich werde kurz erkl√§ren, was hier passiert.  In der Unterabfrage <em>Schedule_base</em> generieren wir alle Tage des Kalenders f√ºr zwei Jahre und bestimmen an jedem Tag das Vorzeichen, ob der Arbeitstag (= 1) oder nicht (= 0).  Dar√ºber hinaus betrachten wir in der <em>Zeitplan-</em> Unterabfrage die Fensterfunktion als die kumulierte Gesamtzahl der Arbeitsstunden ab dem 01.01.2018.  Es w√§re m√∂glich, alles in einer Unterabfrage zu erledigen, aber es w√ºrde sich als umst√§ndlicher herausstellen, was die Lesbarkeit beeintr√§chtigen w√ºrde.  In der Hauptanfrage ber√ºcksichtigen wir dann die Differenz zwischen der Anzahl der Arbeitsstunden am Ende und am Anfang des Zeitraums und ber√ºcksichtigen, etwas blumig, die Arbeitszeit f√ºr den ersten und letzten Tag des Zeitraums.  Floridit√§t ist mit der Verschiebung der Zeit vor dem Beginn des Arbeitstages auf den Beginn und der Zeit nach dem Ende des Arbeitstages auf das Ende verbunden.  Wenn der Teil der Anforderung mit <em>Shedule_Base</em> und <em>Zeitplan</em> in eine separate vorberechnete Tabelle entfernt wird (wie zuvor vorgeschlagen), wird die Anforderung zu einer v√∂llig trivialen. </p><br><p>  Vergleichen wir die Ausf√ºhrung an einer gr√∂√üeren Stichprobe, um die durchgef√ºhrte Optimierung besser darzustellen. F√ºr vier Zeitr√§ume ab der Aufgabenbedingung wird mehr Zeit f√ºr die Erstellung eines Arbeitsplans aufgewendet. </p><br><p>  Ich habe ungef√§hr dreitausend Perioden gebraucht.  Ich werde nur die oberste zusammenfassende Zeile in EXPLAIN geben, typische Werte sind wie folgt. </p><br><p>  Urspr√ºngliche Option: </p><br><pre> <code class="pgsql hljs">GroupAggregate (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">265790.95</span></span>.<span class="hljs-number"><span class="hljs-number">.296098</span></span><span class="hljs-number"><span class="hljs-number">.23</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">144320</span></span> width=<span class="hljs-number"><span class="hljs-number">36</span></span>) (actual <span class="hljs-type"><span class="hljs-type">time</span></span>=<span class="hljs-number"><span class="hljs-number">656.654</span></span>.<span class="hljs-number"><span class="hljs-number">.894</span></span><span class="hljs-number"><span class="hljs-number">.383</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">2898</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) ...</code> </pre> <br><p>  Optimiert: </p><br><pre> <code class="pgsql hljs">Hash <span class="hljs-keyword"><span class="hljs-keyword">Join</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">45.01</span></span>.<span class="hljs-number"><span class="hljs-number">.127</span></span><span class="hljs-number"><span class="hljs-number">.52</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">70</span></span> width=<span class="hljs-number"><span class="hljs-number">36</span></span>) (actual <span class="hljs-type"><span class="hljs-type">time</span></span>=<span class="hljs-number"><span class="hljs-number">1.620</span></span>.<span class="hljs-number"><span class="hljs-number">.5</span></span><span class="hljs-number"><span class="hljs-number">.385</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">2898</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) ...</code> </pre> <br><p>  Der Zeitgewinn betrug einige Gr√∂√üenordnungen.  Mit der Zunahme der Anzahl der Perioden und ihrer L√§nge in Jahren wird sich der Abstand nur vergr√∂√üern. </p><br><p>  Alles schien in Ordnung zu sein, aber warum habe ich nach einer solchen Optimierung die erste Version der Anfrage f√ºr mich belassen, bis ihre Leistung ausreichte?  Ja, da die optimierte Version zweifellos schneller ist, aber viel mehr Zeit ben√∂tigt, um zu verstehen, wie sie funktioniert, dh die Lesbarkeit hat sich verschlechtert.  Das hei√üt, wenn ich die Anfrage das n√§chste Mal unter meinen ge√§nderten Bedingungen neu schreiben muss, muss ich (oder nicht ich) viel mehr Zeit damit verbringen, zu verstehen, wie die Anfrage funktioniert. </p><br><p>  Das ist alles f√ºr heute, halten Sie die Tentakel warm und ich verabschiede mich von Ihnen bis zur n√§chsten Ver√∂ffentlichung von Radio SQL. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459236/">https://habr.com/ru/post/de459236/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459224/index.html">Vom Makler zum Spieleentwickler 2. ‚ÄûOperation: Android‚Äú</a></li>
<li><a href="../de459226/index.html">"Fast-PoE und Perpetual-PoE - sind das neue Standards oder nicht?"</a></li>
<li><a href="../de459230/index.html">Eine Reise zum Call Center und Product Backlog mit den Augen des Entwicklers</a></li>
<li><a href="../de459232/index.html">Surround, Bite, Cut: Der neue Mini AI Cup # 4 Wettbewerb</a></li>
<li><a href="../de459234/index.html">Smem - Berichte zur Speicherzuordnung zwischen Prozessen und Benutzern unter Linux</a></li>
<li><a href="../de459238/index.html">Aus einer magischen mathematischen Funktion - eine L√∂sung, um sie alle zu regieren</a></li>
<li><a href="../de459240/index.html">10 Jahre in der IT mit Schizophrenie diagnostiziert, √úberlebenstipps</a></li>
<li><a href="../de459242/index.html">Im Anschluss an die T + Conf 2019 Konferenz</a></li>
<li><a href="../de459244/index.html">Hinweise Produktmanager: Benutzerverhalten auf Spieleseiten im App Store. Wie lange dauert das Herunterladen eines Spiels?</a></li>
<li><a href="../de459246/index.html">Warum nimmt die Site-Conversion ab? Beispiele f√ºr 60 Design- und Usability-Fehler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>