<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ¿â€ğŸŒ¾ ğŸ“£ ğŸ‘©ğŸ½â€âœˆï¸ Pengenalan Arsitektur Fiber â˜•ï¸ ğŸ§¦ ğŸ™ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Saya membawa perhatian Anda pada terjemahan dari artikel "React Fiber Architecture" oleh Andrew Clark . 
 Entri 


 React Fiber adalah imp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengenalan Arsitektur Fiber</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444276/"><p> Halo, Habr!  Saya membawa perhatian Anda pada terjemahan dari artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"React Fiber Architecture"</a> oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Andrew Clark</a> . </p><br><h2 id="vstuplenie">  Entri </h2><br><p>  React Fiber adalah implementasi progresif dari algoritma React kunci.  Ini adalah puncak dari studi dua tahun oleh tim pengembangan Bereaksi. </p><br><p>  Tujuan Fiber adalah untuk meningkatkan produktivitas ketika mengembangkan tugas-tugas seperti animasi, mengatur elemen pada halaman, dan elemen bergerak.  Fitur utamanya adalah rendering tambahan: kemampuan untuk membagi pekerjaan rendering menjadi unit dan mendistribusikannya di antara beberapa frame. </p><br><p>  Fitur utama lainnya termasuk kemampuan untuk menjeda, membatalkan, atau menggunakan kembali pembaruan yang masuk dari pohon DOM, kemampuan untuk memprioritaskan berbagai jenis pembaruan, dan juga koordinasi primitif. </p><a name="habracut"></a><br><p>  <em>Sebelum membaca artikel ini, kami sarankan Anda membiasakan diri dengan prinsip dasar Bereaksi:</em> </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bereaksi Komponen, Elemen, dan Mesin Virtual</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rekonsiliasi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">React - Konsep Teoritis Dasar</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Prinsip desain</a> </li></ul><br><h2 id="obzor">  Ulasan </h2><br><h4 id="chto-takoe-sverka-reconciliation">  Apa itu rekonsiliasi? </h4><br><p>  <strong>Rekonsiliasi</strong> adalah algoritma Bereaksi yang digunakan untuk membedakan satu elemen pohon dari yang lain untuk menentukan bagian-bagian yang perlu diganti. </p><br><p>  <strong>Pembaruan</strong> adalah perubahan data yang digunakan untuk membuat aplikasi Bereaksi.  Ini biasanya merupakan hasil dari memanggil metode setState;  Hasil akhir dari rendering komponen. </p><br><p>  Gagasan utama React API adalah memikirkan pembaruan seolah-olah dapat menyebabkan perenderan lengkap aplikasi.  Hal ini memungkinkan pengembang untuk bertindak secara deklaratif, dan tidak khawatir tentang seberapa rasional transisi aplikasi dari satu negara ke negara lain (dari A ke B, B ke C, C ke A, dll.). </p><br><p>  Secara umum, merender seluruh aplikasi untuk setiap perubahan hanya berfungsi di aplikasi yang paling tradisional.  Di dunia nyata, ini mempengaruhi kinerja.  Undang-undang tersebut mencakup pengoptimalan yang membuat tampilan render lengkap tanpa memengaruhi sebagian besar kinerja.  Sebagian besar optimasi ini melibatkan proses yang disebut rekonsiliasi. </p><br><p>  Rekonsiliasi adalah algoritma di balik apa yang biasa kita sebut â€œVirtual DOMâ€.  Definisi terdengar seperti ini: ketika Anda membuat aplikasi Bereaksi, elemen pohon yang menggambarkan aplikasi dihasilkan dalam memori yang dipesan.  Pohon ini kemudian dimasukkan dalam lingkungan render - menggunakan contoh aplikasi browser, diterjemahkan ke dalam serangkaian operasi DOM.  Ketika status aplikasi diperbarui (biasanya dengan memanggil setState), pohon baru dibuat.  Pohon baru dibandingkan dengan yang sebelumnya untuk menghitung dan mengaktifkan dengan tepat operasi yang diperlukan untuk menggambar ulang aplikasi yang diperbarui. </p><br><p>  Terlepas dari kenyataan bahwa Fiber adalah implementasi dekat dari rekonsiliator, algoritma tingkat tinggi yang dijelaskan dalam dokumentasi Bereaksi dalam kebanyakan kasus akan sama. </p><br><h4 id="klyuchevye-ponyatiya">  Konsep kunci: </h4><br><ul><li>  Berbagai jenis komponen menyarankan generasi pohon yang jauh berbeda.  Bereaksi tidak akan mencoba untuk membandingkan mereka, tetapi cukup ganti pohon tua sepenuhnya. </li><li>  Daftar dibedakan menggunakan kunci.  Kunci harus â€œgigih, dapat diprediksi, dan unik.â€ </li></ul><br><h2 id="sverka-protiv-renderinga">  Rekonsiliasi vs. Rendering </h2><br><p>  Pohon DOM adalah salah satu lingkungan yang dapat ditarik React, sisanya dapat dikaitkan dengan iOS asli dan Tampilan Android menggunakan React Native (Itulah sebabnya Virtual Dom adalah nama yang sedikit tidak pantas). </p><br><p>  Alasan mengapa React mendukung begitu banyak tujuan adalah karena React dibangun sehingga rekonsiliasi dan rendering adalah fase yang terpisah.  Rekonsiliator, yang bekerja, menghitung bagian mana dari pohon yang telah berubah, renderer kemudian menggunakan informasi ini untuk memperbarui pohon yang sebelumnya diberikan. </p><br><p>  Pemisahan ini berarti React DOM dan React Native dapat menggunakan mekanisme rendernya sendiri saat menggunakan alat caching yang sama, yang terletak di React Core. </p><br><p>  Fiber adalah implementasi yang dirancang ulang dari algoritma rekonsiliasi.  Ini memiliki hubungan tidak langsung dengan rendering, sementara mekanisme rendering (render) dapat diubah untuk mendukung semua keuntungan dari arsitektur baru. </p><br><p>  <strong>Perencanaan</strong> adalah proses yang menentukan kapan pekerjaan harus diselesaikan. </p><br><p>  <strong>Kerja</strong> - setiap perhitungan yang harus dilakukan.  Pekerjaan biasanya merupakan hasil dari pembaruan (misalnya, memanggil setState). </p><br><p>  Prinsip-prinsip arsitektur React sangat baik sehingga mereka hanya dapat dijelaskan dengan kutipan ini: </p><br><blockquote>  Dalam implementasi Bereaksi saat ini, itu melintasi pohon secara rekursif dan memanggil fungsi rendering pada seluruh pohon yang diperbarui selama satu centang (16 ms).  Namun, di masa depan, ia akan dapat membatalkan beberapa pembaruan untuk mencegah lompatan bingkai. <br>  Ini adalah topik yang sering dibahas tentang Desain Bereaksi.  Beberapa perpustakaan populer menerapkan pendekatan "push", di mana perhitungan dilakukan ketika data baru tersedia.  Namun, Bereaksi mematuhi pendekatan tarikan, di mana perhitungan dapat dibatalkan bila perlu. <br>  Bereaksi bukan perpustakaan untuk memproses data umum.  Ini adalah perpustakaan untuk membangun antarmuka pengguna.  Kami pikir itu harus memiliki posisi unik dalam aplikasi untuk menentukan perhitungan mana yang cocok dan mana yang tidak saat ini. <br>  Jika ada sesuatu di balik layar, maka kita dapat membatalkan semua logika yang terkait dengannya.  Jika data tiba lebih cepat dari kecepatan rendering bingkai, kami dapat menggabungkan pembaruan.  Kami dapat meningkatkan prioritas pekerjaan yang datang sebagai hasil dari interaksi pengguna (seperti penampilan animasi ketika tombol ditekan) terhadap pekerjaan yang kurang penting di latar belakang (menampilkan konten baru yang dimuat dari server) untuk mencegah unduhan bingkai. </blockquote><br><h4 id="klyuchevye-ponyatiya-1">  Konsep kunci: </h4><br><ul><li>  Dalam antarmuka pengguna, tidak penting setiap pembaruan diterapkan segera;  pada kenyataannya, perilaku ini akan berlebihan, itu akan berkontribusi pada jatuhnya bingkai dan kerusakan UX. </li><li>  Berbagai jenis pembaruan memiliki prioritas yang berbeda - pembaruan animasi harus berakhir lebih cepat daripada, katakanlah, memperbarui penyimpanan data. </li><li>  Pendekatan berbasis push mengharuskan aplikasi (Anda, pengembang) untuk memutuskan bagaimana merencanakan pekerjaan.  Pendekatan berbasis tarik memungkinkan kerangka kerja untuk membuat keputusan untuk Anda. </li></ul><br><p>  Bereaksi pada saat ini tidak memiliki keuntungan perencanaan sampai batas yang signifikan;  perbarui hasil untuk seluruh subtree akan ditarik segera.  Memilih elemen-elemen dalam algoritma kernel React dengan hati-hati untuk menerapkan penjadwalan adalah ide utama Fiber. </p><br><h2 id="chto-zhe-takoe-fiber">  Apa itu Fiber? </h2><br><p>  Kita akan membahas inti dari arsitektur React Fiber.  Serat adalah abstraksi tingkat rendah di atas aplikasi daripada yang digunakan pengembang untuk berpikir.  Jika Anda menganggap upaya Anda untuk memahaminya tanpa harapan, jangan merasa kecil hati (Anda tidak sendirian).  Teruslah mencari dan akhirnya akan membuahkan hasil. </p><br><p>  Dan begitu! </p><br><p>  Kami telah mencapai tujuan utama arsitektur Fiber - membiarkan React mengambil keuntungan dari perencanaan.  Secara khusus, kita harus dapat: </p><br><ul><li>  berhenti bekerja dan kembali lagi nanti. </li><li>  memprioritaskan berbagai jenis pekerjaan. </li><li>  menggunakan kembali pekerjaan yang dilakukan sebelumnya. </li><li>  batalkan pekerjaan jika tidak diperlukan lagi. </li></ul><br><p>  Untuk melakukan semua ini, pertama-tama kita perlu membagi pekerjaan menjadi beberapa unit.  Dalam arti tertentu, ini adalah serat.  Serat mewakili satu unit kerja. </p><br><p>  Untuk melangkah lebih jauh, mari kembali ke konsep dasar Bereaksi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"komponen sebagai data fungsi"</a> , yang sering dinyatakan sebagai: </p><br><pre><code class="javascript hljs">v = f(d)</code> </pre> <br><p>  Dengan ini maka rendering aplikasi Bereaksi seperti memanggil fungsi yang tubuhnya berisi panggilan ke fungsi lain, dan sebagainya.  Analogi ini berguna ketika memikirkan serat. </p><br><p>  Cara bahwa komputer pada dasarnya memeriksa urutan pelaksanaan suatu program disebut tumpukan panggilan.  Ketika fungsi selesai, wadah tumpukan baru ditambahkan ke tumpukan.  Wadah tumpukan ini mewakili pekerjaan yang dilakukan oleh suatu fungsi. </p><br><p>  Ketika bekerja dengan antarmuka pengguna, terlalu banyak pekerjaan yang dilakukan segera dan ini merupakan masalah, itu dapat menyebabkan lompatan dalam animasi dan akan terlihat sebentar-sebentar.  Selain itu, beberapa pekerjaan ini mungkin tidak diperlukan jika diganti oleh pembaruan terbaru.  Pada titik ini, perbandingan antara antarmuka pengguna dan fungsi divergen, karena komponen memiliki tanggung jawab yang lebih spesifik daripada fungsi pada umumnya. <br>  Browser terbaru dan React Native mengimplementasikan API yang membantu menyelesaikan masalah ini: <br>  requestIdleCallback mendistribusikan tugas sehingga fungsi dengan prioritas rendah dipanggil dalam periode sederhana, dan requestAnimationFrame mendistribusikan tugas sehingga fungsi yang sangat diprioritaskan dipanggil dalam bingkai berikutnya.  Masalahnya adalah bahwa untuk menggunakan API ini Anda harus membagi pekerjaan rendering menjadi unit tambahan.  Jika Anda hanya mengandalkan tumpukan panggilan, pekerjaan akan berlanjut sampai tumpukan kosong. </p><br><p>  Bukankah lebih baik jika kita dapat menyesuaikan perilaku tumpukan panggilan untuk mengoptimalkan tampilan bagian dari antarmuka pengguna?  Apakah lebih baik jika kita dapat memecahkan tumpukan panggilan untuk memanipulasi kontainer secara manual? </p><br><p>  Ini adalah panggilan React Fiber.  Serat adalah implementasi tumpukan baru yang dirancang untuk komponen Bereaksi.  Anda dapat menganggap serat tunggal sebagai wadah tumpukan virtual. </p><br><p>  Keuntungan dari implementasi tumpukan ini adalah Anda dapat menyimpan tumpukan kontainer di memori dan mengeksekusi kemudian (dan di mana) yang Anda inginkan.  Ini adalah definisi penting untuk mencapai tujuan perencanaan Anda. </p><br><p>  Selain perencanaan, tindakan manual dengan stack mengungkapkan potensi konsep seperti konsistensi (konkurensi) dan penanganan kesalahan (batas kesalahan). </p><br><p>  Pada bagian selanjutnya, kita melihat struktur serat. </p><br><h2 id="struktura-volokna">  Struktur serat </h2><br><p>  Secara khusus, "serat" adalah objek JavaScript yang berisi informasi tentang komponen, input dan outputnya. </p><br><p>  Serat konsisten dengan wadah tumpukan, tetapi juga konsisten dengan esensi komponen. </p><br><p>  Berikut adalah beberapa sifat penting dari "serat" (Daftar ini tidak lengkap): </p><br><p>  <strong>Jenis dan Kunci</strong> </p><br><p>  Jenis dan kunci melayani serat serta elemen Bereaksi.  Bahkan, ketika serat dibuat, kedua bidang ini disalin secara langsung. </p><br><p>  Jenis serat menggambarkan komponen yang bersesuaian.  Untuk komposisi komponen, tipe adalah fungsi atau kelas komponen.  Untuk komponen layanan (div, span), tipenya adalah string. </p><br><p>  Secara konseptual, tipe adalah fungsi yang eksekusinya dilacak oleh stack stack. </p><br><p>  Seiring dengan jenisnya, kuncinya digunakan ketika membandingkan pohon untuk menentukan apakah serat dapat digunakan kembali. </p><br><p>  <strong>Anak dan saudara kandung</strong> <strong><br></strong> <br>  Bidang-bidang ini menunjuk ke serat lain, menggambarkan struktur rekursif serat. </p><br><p>  Anak serat sesuai dengan nilai yang dikembalikan sebagai hasil memanggil metode render pada komponen.  Dalam contoh di bawah ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Child</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> }</span></span></code> </pre> <br><p>  Parent Fiber Child sesuai dengan Child. </p><br><p>  Bidang relatif (atau tetangga) digunakan jika render mengembalikan beberapa anak (fitur baru di Fibre): </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Child1</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">, </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Child2</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">] }</span></span></code> </pre> <br><p>  Serat anak adalah daftar yang terhubung secara tunggal di kepala yang merupakan anak pertama.  Jadi dalam contoh ini, Orang tua anak adalah Anak1, dan kerabat Anak1 adalah Anak2. </p><br><p>  Kembali ke analogi kami dengan fungsi, Anda dapat menganggap serat anak sebagai fungsi yang disebut di bagian akhir (fungsi yang disebut ekor). </p><br><p>  Contoh Wikipedia: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{ a(data); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b(data); }</code> </pre> <br><p>  Dalam contoh ini, fungsi yang disebut ekor adalah b. </p><br><p>  <strong>Nilai pengembalian (pengembalian)</strong> </p><br><p>  Serat pengembalian adalah serat yang harus dikembalikan ke program setelah memproses serat saat ini.  Ini sama dengan mengembalikan alamat wadah tumpukan. <br>  Ini juga dapat dianggap sebagai serat induk. </p><br><p>  Jika serat memiliki banyak serat anak, kembalinya setiap serat anak mengembalikan serat induk.  Dalam contoh di atas, serat pengembalian dari Child1 dan Child2 adalah Induk. </p><br><p>  <strong>Properti saat ini dan di-cache (pendingProps dan memorizedProps)</strong> </p><br><p>  Secara konseptual, properti adalah argumen fungsi.  Properti serat saat ini adalah satu set properti ini di awal eksekusi, yang di-cache adalah satu set di akhir eksekusi. </p><br><p>  Ketika properti menunggu input di-cache, ini berarti bahwa output serat sebelumnya dapat digunakan kembali tanpa perhitungan apa pun. </p><br><p>  <strong>Prioritas pekerjaan saat ini (pendingWorkPriority)</strong> </p><br><p>  Jumlah pekerjaan penentu prioritas ditampilkan oleh serat.  Modul tingkat prioritas dalam React <a href="">ReactPrioritylevel</a> mencakup berbagai tingkat prioritas dan apa yang mereka wakili. </p><br><p>  Dimulai dengan pengecualian tipe NoWork, yaitu 0, angka yang lebih tinggi menentukan prioritas terendah.  Misalnya, Anda dapat menggunakan fungsi berikut untuk memeriksa apakah prioritas serat lebih besar dari tingkat yang ditentukan: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matchesPriority</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fiber, priority</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fiber.pendingWorkPriority !== <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; fiber.pendingWorkPriority &lt;= priority }</code> </pre> <br><p>  <em>Fungsi ini hanya untuk tujuan ilustrasi;</em>  <em>itu bukan bagian dari database React Fiber.</em> </p><br><p>  Penjadwal menggunakan bidang prioritas untuk menemukan unit kerja berikutnya yang dapat dilakukan.  Kami akan membahas algoritma ini di bagian selanjutnya. </p><br><p>  <strong>Alternatif (atau pasangan)</strong> </p><br><p>  Memperbarui serat (flush) - ini berarti menampilkan outputnya di layar. </p><br><p>  Serat dalam pengembangan (work-in-progress) - serat yang belum dibangun;  dengan kata lain, itu adalah tumpukan kontainer yang belum dikembalikan. </p><br><p>  Kapan saja, esensi komponen tidak memiliki lebih dari dua keadaan untuk serat yang sesuai dengan: serat dalam keadaan saat ini, serat yang diperbarui atau serat dalam pengembangan. </p><br><p>  Serat saat ini diikuti oleh serat yang sedang dikembangkan, dan kemudian, pada gilirannya, serat diperbarui. </p><br><p>  Keadaan serat berikutnya dibuat dengan malas menggunakan fungsi cloneFiber.  Hampir selalu ketika membuat objek baru, cloneFiber akan berusaha untuk menggunakan kembali alternatif (pasangan) serat jika itu ada, sambil meminimalkan biaya sumber daya. </p><br><p>  Anda harus menganggap ladang uap (atau alternatif) sebagai detail implementasi, tetapi muncul begitu sering dalam dokumentasi sehingga tidak mungkin untuk tidak menyebutkannya. </p><br><p>  Kesimpulan adalah elemen layanan (atau serangkaian elemen layanan);  daun node Bereaksi aplikasi.  Mereka khusus untuk setiap lingkungan tampilan (misalnya, di browser adalah 'div', 'span', dll.).  Di JSX, mereka dilambangkan sebagai nama tag huruf kecil. </p><br><p>  Intinya: Saya sarankan mencoba fitur arsitektur React v16.0 baru </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444276/">https://habr.com/ru/post/id444276/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444264/index.html">Bagaimana menjadi pengendara dan apakah Anda benar-benar membutuhkannya</a></li>
<li><a href="../id444268/index.html">Minggu Keamanan 12: Serangan Keyboard</a></li>
<li><a href="../id444270/index.html">Group-IB Webinar "Pendekatan Grup-IB untuk Pendidikan Dunia Maya: Tinjauan Umum Program Saat Ini dan Kasus Praktis"</a></li>
<li><a href="../id444272/index.html">PyDERASN: ketika saya menulis perpustakaan ASN.1 dengan slot dan gumpalan</a></li>
<li><a href="../id444274/index.html">Sebuah jawaban terperinci untuk komentar tersebut, serta sedikit tentang kehidupan penyedia di Federasi Rusia</a></li>
<li><a href="../id444278/index.html">Cara membuat puluhan ribu orang membaca artikel berbahasa Inggris Anda untuk Habr: 3 tips sederhana</a></li>
<li><a href="../id444282/index.html">7 Ekstensi Chrome Untuk Belajar Bahasa Inggris</a></li>
<li><a href="../id444284/index.html">komposer dan penyelesaian baris perintah</a></li>
<li><a href="../id444286/index.html">Penguraian kamera PTZ: apa yang ada di dalamnya dan cara kerjanya</a></li>
<li><a href="../id444288/index.html">Aplikasi mobile baru LampTest.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>