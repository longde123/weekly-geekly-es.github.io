<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ”‘ ğŸ¤›ğŸ½ ğŸŒ… Fuzzing Z-machines ğŸ€ ğŸŒ˜ ğŸ§’</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fuzzing Z-machines 
 Jugar juegos de aventura de texto es puro placer, pero el placer consume bastante cerebro. Pero hoy tenemos todas estas capacidad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fuzzing Z-machines</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477374/"><h1>  <a href="https://8bitworkshop.com/blog/misc/fuzzing-the-z-machine.md.html">Fuzzing Z-machines</a> </h1><br>  Jugar juegos de aventura de texto es puro placer, pero el placer consume bastante cerebro.  Pero hoy tenemos todas estas capacidades de procesador inactivo. <br><br>  Â¿QuÃ© pasa si hacemos que la computadora pase por el juego por nuestra cuenta, y solo tenemos que recostarnos en la silla y mirar?  Ni siquiera necesitamos todas estas redes neuronales novedosas, una fuerza bruta bastante simple. <br><br>  Solo dejamos caer un montÃ³n de texto semi aleatorio en la entrada del juego de texto y vemos quÃ© sucede.  En el mundo de la seguridad de la informaciÃ³n, esto se llama fuzzing. <br><br>  El objetivo serÃ¡ la Z-Machine, un intÃ©rprete de mÃ¡quina virtual desarrollado por Joel Berez y Mark Blanck en 1979, el corazÃ³n de los juegos de Infocom.  Este es un objetivo ideal para aventuras fuzzing, ya que estÃ¡ bien documentado y tiene muchas herramientas y bibliotecas de soporte. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/883/408/615/883408615f5e4ed5964aef089ba74a5d.jpg" title="Zork se lanzÃ³ en el Atari 800XL (Sebastian Grunwald, CC 3.0)"><br><br>  <em>Zork se lanzÃ³ en el Atari 800XL (Sebastian Grunwald, CC 3.0)</em> <br><br><h1>  Mini Zork </h1><br>  El juego que vamos a <em>difuminar</em> : <em>MINI-ZORK-1: The Great Underground Empire</em> .  Esta es una versiÃ³n demo de Infokomovsky Zorka primero, diseÃ±ada para arrancar desde un cassette, no desde un disquete.  De hecho, fue un anuncio publicado en el suplemento de la dÃ©cada de 1990 para la revista Commodore's UK para usuarios. <br><br>  Para aquellos que no han jugado Zork, esto es lo que ves despuÃ©s de cargar el juego: <br><a name="habracut"></a><br><pre><code class="plaintext hljs">MINI-ZORK I: The Great Underground Empire Copyright (c) 1988 Infocom, Inc. All rights reserved. ZORK is a registered trademark of Infocom, Inc. Release 34 / Serial number 871124 West of House You are standing in an open field west of a white house, with a boarded front door. You could circle the house to the north or south. There is a small mailbox here. &gt;</code> </pre> <br>  Sugerencia&gt; invita al usuario a ingresar comandos como OPEN MAILBOX o GO NORTH para avanzar en el juego.  El objetivo es "encontrar los tesoros del Gran Imperio SubterrÃ¡neo y recogerlos en su caja de botÃ­n" en el camino resolviendo acertijos y hundiendo enemigos. <br><br><h1>  Juguemos a buscar verbos (y sustantivos) </h1><br>  El manual de usuario completo con Zork proporciona ejemplos de posibles comandos como ABRIR LA PUERTA DE MADERA y WARLOCK, TOMAR EL DESPLAZAMIENTO DEL HECHIZO Y SIGUIRME.  Sin embargo, los usuarios tenÃ­an que adivinar independientemente cÃ³mo resolver un acertijo particular. <br><br>  Los verbos como GET y DROP (GET / DROP) son bastante obvios, al igual que los ocho puntos cardinales estÃ¡ndar y arriba / abajo (UP / DOWN), y al mismo tiempo dentro y fuera (IN / OUT).  Pero los usuarios tambiÃ©n tuvieron que usar ATTACK, POOL y PRAY, asÃ­ como pronunciar palabras mÃ¡gicas que no estaban en el manual.  La situaciÃ³n cuando el juego no daba suficientes pistas a los jugadores, se burlaban de ellos como "cazar verbos". <br><br>  Para generar comandos, fuzzer necesitarÃ¡ una lista de palabras aceptadas por el juego, su vocabulario.  La mÃ¡quina Z selecciona esta lista como un diccionario de juego (se encuentra en un lugar estÃ¡ndar en el archivo de cada juego). <br><br>  (Â¡Esto es una especie de estafa, sÃ­! Pero realmente no hay otra manera de explicarle a la computadora quÃ© palabras usar, ya que algunos verbos no se mencionan en ninguna parte del texto). <br><br>  La forma mÃ¡s fÃ¡cil de generar comandos es tomar aleatoriamente una o mÃ¡s palabras, en nuestro caso, una o dos.  No sabemos quÃ© palabras son verbos y quÃ© sustantivos, por lo que generamos muchos comandos extraÃ±os como "VER OOPS" y "CONDUCTOR A CONTINUACIÃ“N". <br><br>  Obviamente, esto es bastante ineficiente, porque tenemos que clasificar las combinaciones N * N (donde N es el tamaÃ±o del vocabulario) para encontrar el comando como "KILL TROLL". <br><br>  Sin embargo, podemos hacer trampa un poco.  Escanearemos todas las palabras en la salida de texto del juego y elegiremos las que se encuentran en nuestro diccionario.  Y elija una palabra de esta lista (en lugar de un diccionario completo).  Por ejemplo, si vemos NORTE, OESTE, CASA y CAJA DE CORREO en el texto, es mÃ¡s probable que usemos estas palabras. <br><br><h1>  Buscar marcadores de historia </h1><br>  Solo dando comandos al azar, obtenemos muchas tonterÃ­as que el analizador jurarÃ¡: <br><br><pre> <code class="plaintext hljs">&gt;about painti [    !] &gt;leathe guideb [   "leathe" ,    .]</code> </pre> <br>  (Las palabras de vocabulario no tienen mÃ¡s de seis caracteres de longitud en la mÃ¡quina Z, por lo que generamos palabras como "cuero"). <br><br>  Sin embargo, tal pisada en el acto tomarÃ¡ una eternidad.  Â¿CÃ³mo podemos determinar quÃ© caminos son mÃ¡s prometedores que otros?  Buscaremos marcadores para promocionar la historia. <br><br>  La mÃ¡quina Z tiene una instrucciÃ³n PRINT que imprime texto en la consola.  A menudo, estos son fragmentos de descripciones, como "West of the House" y "botella destrozada".  Registraremos cada uno de ellos como un marcador. <br><br>  Cada vez que vemos un nuevo marcador, guardamos el pasaje actual, una lista de los equipos que realizamos en el juego actual. <br><br>  Asociamos esta lista con el marcador actual, por lo que podemos (con suerte) obtener el mismo texto en la salida despuÃ©s de reproducir los mismos comandos. <br><br>  Cada lanzamiento del juego selecciona un marcador de objetivo especÃ­fico y, por lo tanto, el pasaje asociado con Ã©l.  El algoritmo de bÃºsqueda selecciona nuevos marcadores con mÃ¡s frecuencia que los antiguos. <br><br>  No repetiremos los equipos textualmente en cada juego, pero agregaremos algunos equipos al azar y mezclaremos el orden.  Cuando vemos un nuevo marcador, aumentaremos el parÃ¡metro de "Ã©xito", cuyo crecimiento mostrarÃ¡ que es posible cambiar la lista de comandos con menos frecuencia.  Cuando este parÃ¡metro crece lo suficiente, marcamos este marcador como "estable", ya que tenemos un pasaje predecible que conduce a Ã©l. <br><br><h1>  Buscando un camino corto </h1><br>  Las formas en que pasamos por el juego a menudo son ineficaces.  AquÃ­ estÃ¡ la lista de comandos que se utilizaron para generar el marcador "Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡!!!)))") Esta es la lista de comandos que se usaron para generar el marcador "Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡!!!)))) - AquÃ­ estÃ¡ la lista de los comandos que se usaron para generar el marcador" Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡!!!)))): <br><br><pre> <code class="plaintext hljs">curse, art, body gate, incant count, the, the egg, repent, from the, the consum, what, leathe, trap- see, breath here, what intnum, about here, leathe guideb, about, about here, pot, here, see, here about, about, self, here about, mangle, see, rug, the, reply, elvish, say, stilet beetle, say toss, pray, gate about, what bolt, guideb, wooden, say knock, say sit, trail and, here, pray leathe, intnum, one, pray one, jump</code> </pre> <br>  Todo lo que realmente necesitamos hacer es ingresar el Ãºltimo comando: JUMP (o DIVE).  Pero el algoritmo de bÃºsqueda no sabe cuÃ¡l de los comandos anteriores son necesarios para mostrar "Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡Â¡ <br><br>  Necesitamos reducir el pasaje, para que sean lo mÃ¡s cortos posible.  Cuando vemos un marcador, reemplazamos el pasaje asociado con una lista mÃ¡s corta de comandos, si es posible.  Esto nos lleva al marcador de objetivo mÃ¡s rÃ¡pido, dÃ¡ndonos mÃ¡s movimientos para experimentar despuÃ©s de alcanzar la meta. <br><br>  Muchos marcadores, como "Wheeeeeeeeee !!!!!", no son interesantes, ya que podemos lograrlos en un turno al comienzo del juego.  Al reducir su lista de comandos, eventualmente podremos confirmar que este es el caso, y asÃ­ eliminarlos de la lista de posibles marcadores de destino. <br><br><h1>  Mas que palabras </h1><br>  Como tenemos acceso directo al estado interno de la mÃ¡quina Z, podemos usar algo mÃ¡s que la salida de texto para controlar nuestra bÃºsqueda.  Por ejemplo, podemos arreglar cuando un objeto se ha movido de una habitaciÃ³n a otra, o cuando otras propiedades y banderas han cambiado en el objeto.  LlÃ¡melo marcadores VM (marcadores de mÃ¡quina virtual) y fÃ­jelos en paralelo con marcadores de texto: <br><br><pre> <code class="plaintext hljs">@mv_30_15  (#30)      #15 @f_176_10_1    "" (10)   ""(#176)</code> </pre> <br>  Necesitamos esto porque la salida de texto no nos cuenta toda la historia.  Por ejemplo, al levantar una espada o lÃ¡mpara, llegaremos al mismo marcador "Tomado". Y el marcador VM le dirÃ¡ al algoritmo de bÃºsqueda cuando se alcanza un nuevo estado de la mÃ¡quina virtual, por ejemplo, cuando un jugador se mueve a una nueva habitaciÃ³n, o un objeto ha sido recogido o arrojado. <br><br><h1>  Romper una mÃ¡quina virtual </h1><br>  Investigar el estado del juego es un proceso bastante lento.  Una de las primeras tareas en el juego es matar al troll, lo que no te permite ir mÃ¡s allÃ¡.  Sin embargo, antes de eso, el jugador necesita encontrar una espada en la casa un poco mÃ¡s arriba. <br><br>  Para acelerar el proceso de bÃºsqueda, descifraremos la mÃ¡quina Z y llevaremos el estado del juego a lo que vimos anteriormente.  Por ejemplo, accidentalmente movimos una espada a la mano de un jugador, lo que hizo posible ejecutar con Ã©xito el comando "STAB" (puÃ±alada).  ("TROLL DE ATAQUE" no funcionarÃ¡ a menos que agreguemos "CON LA ESPADA", pero "PUNTA" (apuÃ±alar) ya implica la presencia de un objeto afilado y, por lo tanto, funciona). <br><br>  Romperemos solo marcadores estables, por lo que si podemos repetir el juego de manera confiable y las manos del jugador resultan ser una espada, permitiremos hackear este estado: "la espada estÃ¡ en las manos del jugador".  Luego podemos combinar los equipos utilizados para levantar la espada con los equipos utilizados para bajar a la mazmorra, descubriendo en el camino que debemos atacar al troll. <br><br>  El ejemplo del troll es especialmente jesuita, porque, por regla general, se requieren varios golpes para terminarlo, y cada ataque da un resultado aleatorio.  Dado que nuestro algoritmo prefiere pases mÃ¡s cortos, es preferible cumplir con un pronÃ³stico optimista sobre nuestras habilidades de combate. <br><br>  DespuÃ©s de 530,000 recorridos y 10,600,000 equipos (200 equipos por juego), finalmente descubrimos cÃ³mo atacar al troll: <br><br><pre> <code class="plaintext hljs">north, east, open window, into, west, light, lift trap, small hi, get, west, light, tug large, lift trap, down, north, stab</code> </pre> <br>  TodavÃ­a hay algunos comandos innecesarios, y todavÃ­a no entendemos que tenemos que golpearlo varias veces, pero podemos manejarlo. <br><br><h1>  Hobby fatal </h1><br>  El algoritmo de bÃºsqueda no conoce la diferencia entre recolectar objetos, lanzar objetos y mover a un jugador de una habitaciÃ³n a otra.  La Ãºnica forma en que define el progreso es viendo progresar los marcadores de la historia. <br><br>  Esto rÃ¡pidamente desarrolla en el algoritmo de bÃºsqueda un gusto por ... Â¡Asesinato!  Para matar a un jugador, en particular, porque es muy fÃ¡cil y simple: ingrese "ATTACK": <br><br><pre> <code class="plaintext hljs">&gt;attack [  ] ,  ! ****   **** , ,     .      ,       .          c-.  ,      .</code> </pre> <br>  En Mini Zorka, la primera muerte no es el final del juego, el jugador se teletransporta a otro lugar y tus cosas estÃ¡n dispersas.  Para un algoritmo de bÃºsqueda, la muerte es simplemente un objeto que se mueve de una habitaciÃ³n a otra, creando marcadores para mover la historia en el camino.  Este pasatiempo lleva a la exposiciÃ³n de otros errores divertidos en el juego, como la capacidad del jugador de arrojar sus manos al rÃ­o. <br><br>  El juego tiene una puntuaciÃ³n de 0 a 350 puntos, basado en resolver acertijos y recoger tesoros.  Cuando un jugador muere, se reduce en 10 puntos.  Podemos usar la cuenta como una heurÃ­stica, pero esto puede reducir excesivamente el comportamiento arriesgado: el amor por deambular por lugares oscuros o por luchar contra trolls. <br><br>  El algoritmo de bÃºsqueda tambiÃ©n estÃ¡ muy interesado en lo que el jugador no ve, como los NPC que se mueven de una habitaciÃ³n a otra.  Por ejemplo, el marcador @ mv_112_37 indica el movimiento de un ladrÃ³n a una habitaciÃ³n especÃ­fica.  El algoritmo de bÃºsqueda logra reproducir este marcador ejecutando repetidamente comandos Z o WAIT, esencialmente esperando que el ladrÃ³n llegue a la habitaciÃ³n objetivo. <br><br>  TambiÃ©n le gusta recoger y tirar objetos en diferentes lugares, porque cada movimiento del objeto es un nuevo marcador.  Quien sabe  Â¡QuizÃ¡s tirar esta hoja en un sendero del bosque conducirÃ¡ a la victoria en el juego!  (Narrador: no, no lo harÃ¡) <br><br>  Fuzzing identifica invariablemente errores en el programa, y â€‹â€‹este juego no es diferente, aunque persiste.  Ã‰l descubriÃ³ cÃ³mo generar la palabra "Clrthatrqdc" al comienzo del juego: <br><br><pre> <code class="plaintext hljs">&gt;tie up [  ] With a Clrthatrqdc!?!</code> </pre> <br>  Esto parece ser una variable no inicializada que indica datos no textuales.  La codificaciÃ³n del texto comprimido en la mÃ¡quina Z es principalmente alfabÃ©tica, porque no se ve tanta basura aleatoria como cuando intenta imprimir un archivo binario como ASCII.  (Actualmente, esta palabra <a href="https://www.google.com/search%3Fq%3DClrthatrqdc">solo estÃ¡ dos veces en Google</a> ( <em>ya cuatro veces, aprox. Transl.</em> )). <br><br><h1>  Tutorial </h1><br>  Para ganar el juego, tendremos que arrastrar nuestros productos saqueados de vuelta a la caja de botÃ­n y meter cada objeto en Ã©l.  Nuestro algoritmo de bÃºsqueda simple tardarÃ¡ mucho tiempo en tropezar con este comportamiento, especialmente dada su tendencia a desperdiciar energÃ­a y tiempo al mover objetos de una habitaciÃ³n a otra. <br><br>  Complicar un algoritmo de investigaciÃ³n aleatoria lleva tiempo, por lo que debemos ser selectivos al agregar nuevas funciones.  TambiÃ©n queremos evitar el conocimiento a priori en el juego; en otras palabras, solo queremos hacer un poco de trampa. <br><br>  Si desea experimentar, <a href="">consulte el cÃ³digo fuente en GitHub</a> , que utiliza <a href="https://github.com/DLehenbauer/jszm">JSZM</a> (el intÃ©rprete de Z-Machine Daniel Legenbauer). Muchos <a href="http://www.ifarchive.org/indexes/if-archiveXgamesXzcode.html">juegos estÃ¡n disponibles</a> (solo se admiten versiones de hasta 3). <br><br>  El documento Graham Nelson <a href="https://www.inform-fiction.org/zmachine/standards/z1point1/index.html">Z-Machine Standards</a> , que ha estado tratando con la mÃ¡quina Z durante un par de dÃ©cadas, tambiÃ©n estÃ¡ disponible. <br><br>  Â¿Y necesito agregar soporte para Z-Machine en <a href="https://8bitworkshop.com/">8bitworkshop</a> ?  AvÃ­same </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/477374/">https://habr.com/ru/post/477374/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../477362/index.html">MÃ¡s que antispam: cÃ³mo aprovechar al mÃ¡ximo su Security Email Gateway</a></li>
<li><a href="../477364/index.html">Â¿CÃ³mo convertirse en un desarrollador de Java? Â¿O tal vez elegir Python?</a></li>
<li><a href="../477366/index.html">Cinco preguntas sobre el diseÃ±o de lenguajes de programaciÃ³n</a></li>
<li><a href="../477370/index.html">PHP sin servidor</a></li>
<li><a href="../477372/index.html">Amazon pierde la guerra contra las falsificaciones</a></li>
<li><a href="../477378/index.html">Ãgil mixto: enfoque de cascada al implementar aplicaciones comerciales (tambiÃ©n conocido como Agile-like)</a></li>
<li><a href="../477382/index.html">Esports: obtener ganancias: Mercedes, megÃ¡fono, apuestas y branding para esports</a></li>
<li><a href="../477384/index.html">Conferencia â€œSeguridad de la informaciÃ³n. Amenazas del presente y del futuro â€</a></li>
<li><a href="../477386/index.html">Semana de la seguridad 48: fuga de datos gigantesca y vulnerabilidad de Whatsapp</a></li>
<li><a href="../477388/index.html">NILFS2 - sistema de archivos a prueba de balas para / home</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>