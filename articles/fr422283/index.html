<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍⚖️ 🤙🏼 📪 Test de boîte blanche 👩🏿‍🤝‍👨🏾 🚩 💆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le développement de programmes de haute qualité implique que le programme et ses composants soient testés. Les tests unitaires classiques consistent à...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Test de boîte blanche</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422283/"><p>  Le développement de programmes de haute qualité implique que le programme et ses composants soient testés.  Les tests unitaires classiques consistent à diviser un grand programme en petits blocs qui sont pratiques pour les tests.  Ou, si le développement de tests a lieu en parallèle avec le développement de code ou si des tests sont développés avant le programme (TDD - développement piloté par les tests), alors le programme est initialement développé en petits blocs adaptés aux exigences des tests. </p><br><p>  L'une des variétés de tests unitaires peut être considérée comme un test basé sur les propriétés (cette approche est implémentée, par exemple, dans les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bibliothèques</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">QuickCheck</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ScalaCheck</a> ).  Cette approche est basée sur la recherche de propriétés universelles qui devraient être valides pour toutes les données d'entrée.  Par exemple, la <em>sérialisation suivie de la désérialisation devrait produire le même objet</em> .  Ou, le <em>nouveau tri ne doit pas modifier l'ordre des éléments de la liste</em> .  Pour vérifier ces propriétés universelles, les bibliothèques ci-dessus prennent en charge un mécanisme pour générer des données d'entrée aléatoires.  Cette approche fonctionne particulièrement bien pour les programmes basés sur des lois mathématiques qui servent de propriétés universelles valables pour une large classe de programmes.  Il existe même une bibliothèque de propriétés mathématiques prêtes à l'emploi - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">discipline</a> - qui vous permet de vérifier les performances de ces propriétés dans de nouveaux programmes (un bon exemple de réutilisation de tests). </p><br><p>  Parfois, il s'avère qu'il est nécessaire de tester un programme complexe sans pouvoir l'analyser en parties vérifiables indépendamment.  Dans ce cas, le programme de test est <del>  noir </del>  boîte blanche (blanche - car nous avons la possibilité d'étudier la structure interne du programme). </p><br><p>  Sous la coupe, plusieurs approches pour tester des programmes complexes avec une entrée avec différents degrés de complexité (implication) et différents degrés de couverture sont décrites. </p><a name="habracut"></a><br><p>  * <em>Dans cet article, nous supposons que le programme testé peut être représenté comme une fonction pure sans état interne.</em>  <em>(Certaines des considérations ci-dessous peuvent être appliquées si l'état interne est présent, mais il est possible de réinitialiser cet état à une valeur fixe.)</em> </p><br><h3 id="testovyy-stend-test-bench">  Banc d'essai </h3><br><p> Tout d'abord, puisqu'une seule fonction est testée, dont le code appelant est toujours le même, nous n'avons pas besoin de créer des tests unitaires séparés.  Tous ces tests seraient les mêmes, précis à l'entrée et aux contrôles.  Il suffit de transmettre les données source ( <code>input</code> ) en boucle et de vérifier les résultats ( <code>input</code> <code>expectedOutput</code> ).  Afin d'identifier un ensemble problématique de données de test en cas de détection d'erreur, toutes les données de test doivent être étiquetées.  Ainsi, un ensemble de données de test peut être représenté comme un triple: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCase</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">label: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, input: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-class"><span class="hljs-params">, expectedOutput: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  Le résultat d'une exécution peut être représenté par <code>TestCaseResult</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCaseResult</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">testCase: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">TestCase</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-class"><span class="hljs-params">, </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span><span class="hljs-class"><span class="hljs-params">], actualOutput: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Try</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  (Nous présentons le résultat du lancement en utilisant <code>Try</code> to catch possible exceptions.) </p><br><p>  Pour simplifier l'exécution de toutes les données de test via le programme testé, vous pouvez utiliser une fonction d'assistance qui appellera le programme pour chaque valeur d'entrée: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runTestCases</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>](cases: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">TestCase</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>])(f: <span class="hljs-type"><span class="hljs-type">A</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">B</span></span>): <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">TestCaseResult</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>]] = cases .map{ testCase =&gt; <span class="hljs-type"><span class="hljs-type">TestCaseResult</span></span>(testCase, <span class="hljs-type"><span class="hljs-type">Try</span></span>{ f(testCase.input) } ) } .filter(r =&gt; r.actualOutput != <span class="hljs-type"><span class="hljs-type">Success</span></span>(r.testCase.expectedOutput))</code> </pre> <br><p>  Cette fonction d'assistance renvoie les données et les résultats problématiques qui sont différents de ceux attendus. </p><br><p>  Pour plus de commodité, vous pouvez formater les résultats du test. </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">report</span></span></span></span>(results: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">TestCaseResult</span></span>[_, _]]): <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">s"Failed </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${results.length}</span></span></span><span class="hljs-string">:\n"</span></span> + results .map(r =&gt; r.testCase.label + <span class="hljs-string"><span class="hljs-string">": expected "</span></span> + r.testCase.expectedOutput + <span class="hljs-string"><span class="hljs-string">", but got "</span></span> + r.actualOutput) .mkString(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>)</code> </pre> <br><p>  et n'afficher un rapport qu'en cas d'erreur: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCases = <span class="hljs-type"><span class="hljs-type">Seq</span></span>( <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) ) test(<span class="hljs-string"><span class="hljs-string">"all test cases"</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testBench = runTestCases(testCases) _ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> results = testBench(f) assert(results.isEmpty, report(results)) }</code> </pre> <br><h3 id="podgotovka-vhodnyh-dannyh">  Préparation des entrées </h3><br><p>  Dans le cas le plus simple, vous pouvez créer manuellement des données de test pour tester le programme, les écrire directement dans le code de test et les utiliser, comme indiqué ci-dessus.  Il s'avère souvent que des cas intéressants de données de test ont beaucoup en commun et peuvent être présentés comme une instance de base, avec des modifications mineures. </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> baseline = <span class="hljs-type"><span class="hljs-type">MyObject</span></span>(...) <span class="hljs-comment"><span class="hljs-comment">//        val testCases = Seq( TestCase("baseline", baseline, ???), TestCase("baseline + (field1 = 123)", baseline.copy(field1 = "123"), ???) )</span></span></code> </pre> <br><p>  Lorsque vous travaillez avec des structures de données immuables imbriquées, les lentilles sont très utiles, par exemple, à partir de la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Monocle</a> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> baseline = ??? <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testObject1 = (field1 composeLens field2).set(<span class="hljs-string"><span class="hljs-string">"123"</span></span>)(baseline) <span class="hljs-comment"><span class="hljs-comment">//    : val testObject1 = baseline.copy(field1 = baseline.field1.copy(field2 = "123"))</span></span></code> </pre> <br><p>  Les objectifs vous permettent de «modifier» avec élégance les parties profondément imbriquées des structures de données: chaque objectif est un getter et un setter pour une propriété.  Les lentilles peuvent être combinées pour produire des lentilles qui «se concentrent» sur le niveau suivant. </p><br><h3 id="ispolzovanie-dsl-dlya-predstavleniya-izmeneniy">  Utilisation de DSL pour présenter les modifications </h3><br><p>  Ensuite, nous considérerons la formation de données de test en apportant des modifications à un objet d'entrée initial.  Habituellement, pour obtenir l'objet de test dont nous avons besoin, nous devons apporter quelques modifications.  Dans le même temps, il est très utile d'inclure une liste de modifications dans la description textuelle de TestCase: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCases = <span class="hljs-type"><span class="hljs-type">Seq</span></span>( <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"baseline"</span></span>, baseline, ???), <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"baseline + "</span></span> + <span class="hljs-string"><span class="hljs-string">"(field1 = 123) + "</span></span> + <span class="hljs-comment"><span class="hljs-comment">//  1-  "(field2 = 456) + " + // 2- "(field3 = 789)", // 3- baseline .copy(field1 = "123") // 1-  .copy(field2 = "456") // 2-  .copy(field3 = "789"), // 3-  ???) )</span></span></code> </pre> <br><p>  Ensuite, nous saurons toujours pour quelles données de test le test est effectué. </p><br><p>  Pour que la liste textuelle des changements ne s'écarte pas des changements réels, vous devez suivre le principe d'une "version unique de la vérité".  (Si la même information est requise / utilisée à plusieurs points, il devrait y avoir une seule source principale d'informations uniques et les informations devraient être distribuées automatiquement à tous les autres points d'utilisation, avec les transformations nécessaires. Si ce principe est violé et que la copie manuelle des informations est inévitable . informations sur la version de divergence à différents points dans d' autres termes dans la description des données de test, nous voyons une, et des données de test -. autre exemple, la copie d' un changement <code>field2 = "456"</code> et le réglage dans le <code>field3 = "789"</code> nous Mauger  accidentellement oublier de corriger la description. Par conséquent, la description ne reflète deux changements de trois.) </p><br><p>  Dans notre cas, la principale source d'information est les modifications elles-mêmes, ou plutôt le code source du programme qui effectue les modifications.  Nous aimerions en déduire un texte décrivant les changements.  À l'inverse, comme première option, vous pouvez suggérer d'utiliser une macro qui capturera le code source des modifications et utilisera le code source comme documentation.  Il s'agit, apparemment, d'un moyen efficace et relativement simple de documenter les changements réels et il pourrait très bien être appliqué dans certains cas.  Malheureusement, si nous présentons les modifications en texte brut, nous perdons la possibilité de faire des transformations significatives de la liste des modifications.  Par exemple, détectez et éliminez les modifications en double ou qui se chevauchent, établissez une liste de modifications d'une manière pratique pour l'utilisateur final. </p><br><p>  Pour pouvoir gérer les modifications, vous devez en avoir un modèle structuré.  Le modèle doit être suffisamment expressif pour décrire tous les changements qui nous intéressent.  Une partie de ce modèle, par exemple, sera l'adressage des champs d'objet, des constantes, des opérations d'affectation. </p><br><p>  Le modèle de changement doit permettre de résoudre les tâches suivantes: </p><br><ol><li>  Générez des instances de modèle de changement.  (Autrement dit, créer une liste spécifique de modifications.) </li><li>  Formation d'une description textuelle des changements. </li><li>  Application des modifications aux objets de domaine. </li><li>  Effectuer des transformations d'optimisation sur le modèle. </li></ol><br><p>  Si un langage de programmation universel est utilisé pour apporter des modifications, il peut être difficile de représenter ces modifications dans le modèle.  Le code source du programme peut utiliser des constructions complexes qui ne sont pas prises en charge par le modèle.  Un tel programme peut utiliser des motifs secondaires, tels que des lentilles ou la méthode de <code>copy</code> , pour modifier les champs d'un objet, qui sont des abstractions de niveau inférieur par rapport au niveau du modèle de changement.  Par conséquent, une analyse supplémentaire de ces modèles peut être nécessaire pour générer des instances de modifications.  Ainsi, au départ, une bonne option en utilisant une macro n'est pas très pratique. </p><br><p>  Une autre façon de créer des instances du modèle de changement peut être un langage spécialisé (DSL), qui crée des objets de modèle de changement à l'aide d'un ensemble de méthodes d'extension et d'opérateurs auxiliaires.  Eh bien, dans les cas les plus simples, les instances du modèle de changement peuvent être créées directement via les constructeurs. </p><br><div class="spoiler">  <b class="spoiler_title">Modifier les détails de la langue</b> <div class="spoiler_text"><p>  Le langage de changement est une construction assez complexe qui comprend plusieurs composants, qui sont à leur tour non triviaux. </p><br><ol><li>  Modèle de structure de données. </li><li>  Changer de modèle. </li><li>  En fait Embedded (?) DSL - constructions auxiliaires, méthodes d'extension, pour une construction pratique des changements. </li><li>  Un interprète des changements qui vous permet de réellement "modifier" un objet (en fait, bien sûr, créer une copie modifiée). </li></ol><br><p>  Voici un exemple de programme écrit en DSL: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> target: <span class="hljs-type"><span class="hljs-type">Entity</span></span>[<span class="hljs-type"><span class="hljs-type">Target</span></span>] <span class="hljs-comment"><span class="hljs-comment">// ,     val updateField1 = target \ field1 := "123" val updateField2 = target \ subobject \ field2 := "456" // ,   DSL: val updateField1 = SetProperty(PropertyAccess(target, Property(field1, typeTag[String])), LiftedString("123")) val updateField2 = SetProperty(PropertyAccess(PropertyAccess(target, Property(subobject, typeTag[SubObject])), Property(field2, typeTag[String])), LiftedString("456"))</span></span></code> </pre> <br><p>  Autrement dit, à l'aide des méthodes d'extension <code>\</code> et <code>:=</code> , <code>PropertyAccess</code> , les objets <code>SetProperty</code> sont formés à partir des objets <code>target</code> , <code>field1</code> , <code>subobject</code> , <code>field2</code> précédemment créés.  De plus, en raison de conversions implicites (dangereuses), la chaîne "123" est compressée dans une <code>LiftedString</code> (vous pouvez vous passer de conversions implicites et appeler explicitement la méthode correspondante: <code>lift("123")</code> ). </p><br><p>  Une ontologie typée peut être utilisée comme modèle de données (voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://habr.com/post/229035/</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://habr.com/post/222553/</a> ).  (En bref: les objets de nom sont déclarés qui représentent les propriétés de tout type de domaine: <code>val field1: Property[Target, String]</code> .) Dans ce cas, les données réelles peuvent être stockées, par exemple, sous la forme de JSON.  La commodité d'une ontologie typée dans notre cas réside dans le fait que le modèle de changement fonctionne généralement avec les propriétés individuelles des objets, et l'ontologie fournit simplement un outil approprié pour adresser les propriétés. </p><br><p>  Pour représenter les modifications, vous avez besoin d'un ensemble de classes du même plan que la classe <code>SetProperty</code> ci-dessus: </p><br><ul><li>  <code>Modify</code> - application de la fonction, </li><li>  <code>Changes</code> - appliquer plusieurs modifications séquentiellement </li><li>  <code>ForEach</code> - appliquez des modifications à chaque élément de la collection, </li><li>  etc. </li></ul><br><p>  L'interpréteur de changement de langue est un évaluateur d'expressions récursives régulières basé sur PatternMatching.  Quelque chose comme: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eval</span></span></span></span>(expression: <span class="hljs-type"><span class="hljs-type">DslExpression</span></span>, gamma: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>]): <span class="hljs-type"><span class="hljs-type">Any</span></span> = expression <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">LiftedString</span></span>(str) =&gt; str <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">PropertyAccess</span></span>(obj, prop) =&gt; <span class="hljs-type"><span class="hljs-type">Getter</span></span>(prop)(gamma).get(obj) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">change</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>] (expression: <span class="hljs-type"><span class="hljs-type">DslChangeExpression</span></span>, gamma: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>], target: <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">T</span></span> = expression <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">SetProperty</span></span>(path, valueExpr) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> value = eval(valueExpr, gamma) <span class="hljs-type"><span class="hljs-type">Setter</span></span>(path)(gamma).set(value)(target) }</code> </pre> <br><p>  Pour opérer directement sur les propriétés des objets, vous devez spécifier getter et setter pour chaque propriété utilisée dans le modèle de modification.  Ceci peut être réalisé en remplissant la carte entre les propriétés ontologiques et leurs lentilles correspondantes. </p></div></div><br><p>  Cette approche dans son ensemble fonctionne et vous permet en effet de décrire les changements une fois, mais progressivement, il est nécessaire de représenter des changements de plus en plus complexes et le modèle des changements se développe quelque peu.  Par exemple, si vous devez modifier une propriété en utilisant la valeur d'une autre propriété du même objet (par exemple, <code>field1 = field2 + 1</code> ), vous devez prendre en charge les variables au niveau DSL.  Et si la modification d'une propriété n'est pas triviale, au niveau DSL, la prise en charge des expressions et des fonctions arithmétiques est requise. </p><br><h3 id="testirovanie-vetvey">  Test de branche </h3><br><p>  Le code de test peut être linéaire, puis, dans l'ensemble, un seul ensemble de données de test suffit pour comprendre s'il fonctionne.  S'il existe une branche ( <code>if-then-else</code> ), vous devez exécuter la boîte blanche au moins deux fois avec des données d'entrée différentes pour que les deux branches soient exécutées.  Le nombre d'ensembles de données d'entrée suffisant pour couvrir toutes les branches est apparemment numériquement égal à la complexité cyclomatique du code à branches. </p><br><p>  Comment former tous les ensembles de données d'entrée?  Comme nous avons affaire à une boîte blanche, nous pouvons isoler les conditions de branchement et modifier deux fois l'objet d'entrée afin que dans un cas une branche soit exécutée, dans l'autre cas une autre.  Prenons un exemple: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==</span></span></span><span class="hljs-class"> "123") </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">else</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span></span></code> </pre> <br><p>  Ayant une telle condition, nous pouvons former deux cas de test: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCase1 = <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"A"</span></span>, field1.set(<span class="hljs-string"><span class="hljs-string">"123"</span></span>)(baseline), <span class="hljs-comment"><span class="hljs-comment">/* result of A */</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCase2 = <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"B"</span></span>, field1.set(<span class="hljs-comment"><span class="hljs-comment">/*  "123", , , */</span></span><span class="hljs-string"><span class="hljs-string">"123"</span></span> + <span class="hljs-string"><span class="hljs-string">"1"</span></span>&gt;)(baseline), <span class="hljs-comment"><span class="hljs-comment">/*result of B*/</span></span>)</code> </pre> <br><p>  <em>(Si l'un des scénarios de test ne peut pas être créé, nous pouvons supposer que le code mort a été détecté et que la condition, ainsi que la branche correspondante, peuvent être supprimées en toute sécurité.)</em> </p><br><p>  Si les propriétés indépendantes d'un objet sont vérifiées dans plusieurs branches, il est assez simple de former un ensemble exhaustif d'objets de test modifiés qui couvre complètement toutes les combinaisons possibles. </p><br><div class="spoiler">  <b class="spoiler_title">DSL pour former toutes les combinaisons de changements</b> <div class="spoiler_text"><p>  Examinons plus en détail le mécanisme qui permet de former toutes les listes de changements possibles qui couvrent entièrement toutes les branches.  Afin d'utiliser la liste des modifications pendant les tests, nous devons combiner toutes les modifications en un seul objet, que nous soumettrons à l'entrée du code testé, c'est-à-dire que la prise en charge de la composition est requise.  Pour ce faire, vous pouvez soit utiliser la DSL ci-dessus pour modéliser les modifications, puis une simple liste de modifications suffit, ou vous pouvez présenter une modification comme une fonction de modification <code>T =&gt; T</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> change1: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> = field1.set(<span class="hljs-string"><span class="hljs-string">"123"</span></span>)(_) <span class="hljs-comment"><span class="hljs-comment">// val change1: T =&gt; T = _.copy(field1 = "123") val change2: T =&gt; T = field2.set("456")</span></span></code> </pre> <br><p>  alors la chaîne des changements sera simplement une composition de fonctions: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> changes = change1 compose change2</code> </pre> <br><p>  ou, pour une liste de modifications: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> rawChangesList: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>] = <span class="hljs-type"><span class="hljs-type">Seq</span></span>(change1, change2) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> allChanges: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> = rawChangesList.foldLeft(identity)(_ compose _)</code> </pre> <br><p>  Pour enregistrer de manière compacte toutes les modifications correspondant à toutes les branches possibles, vous pouvez utiliser la DSL du niveau d'abstraction suivant, qui simule la structure de la boîte blanche testée: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tests: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>)] = <span class="hljs-type"><span class="hljs-type">IF</span></span>(<span class="hljs-string"><span class="hljs-string">"field1 == '123'"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  ,    THEN( field1.set("123"))( //  target \ field1 := "123" IF("field2 == '456') THEN(field2.set("456"))(TERMINATE) ELSE(field2.set("456" + "1"))(TERMINATE) ) ELSE( field1.set("123" + "1") )(TERMINATE)</span></span></code> </pre> <br><p>  Ici, la collection de <code>tests</code> contient des modifications agrégées correspondant à toutes les combinaisons possibles de branches.  Un paramètre de type <code>String</code> contiendra tous les noms des conditions et toutes les descriptions des modifications à partir desquelles la fonction de modification globale est formée.  Et le deuxième élément d'une paire de type <code>T =&gt; T</code> n'est que la fonction agrégée des changements obtenus à la suite de la composition des changements individuels. </p><br><p>  Pour obtenir les objets modifiés, vous devez appliquer toutes les fonctions de modification agrégées à l'objet de base: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tests2: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>)] = tests.map(_.map_2(_(baseline)))</code> </pre> <br><p>  En conséquence, nous obtenons une collection de paires, et la ligne décrira les changements appliqués, et le deuxième élément de la paire sera l'objet dans lequel tous ces changements seront combinés. </p><br><p>  Sur la base de la structure du modèle du code testé sous forme d'arbre, les listes de modifications représenteront le chemin de la racine aux feuilles de cet arbre.  Ainsi, une partie importante des modifications sera dupliquée.  Vous pouvez vous débarrasser de cette duplication à l'aide de l'option DSL, dans laquelle les modifications sont directement appliquées à l'objet de ligne de base lorsque vous vous déplacez le long des branches.  Dans ce cas, moins de calculs inutiles seront effectués. </p></div></div><br><h3 id="avtomaticheskoe-formirovanie-testovyh-dannyh">  Génération automatique des données de test </h3><br><p>  Puisque nous avons affaire à une boîte blanche, nous pouvons voir toutes les branches.  Cela permet de construire un modèle de logique contenu dans une boîte blanche et d'utiliser le modèle pour générer des données de test.  Si le code de test est écrit en Scala, vous pouvez, par exemple, utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">scalameta</a> pour lire le code, avec conversion ultérieure en modèle logique.  Encore une fois, comme dans la question précédemment discutée de la modélisation de la logique des changements, il nous est difficile de modéliser toutes les possibilités d'un langage universel.  De plus, nous supposerons que le code testé est implémenté en utilisant un sous-ensemble limité de la langue, ou dans une autre langue ou DSL, qui est initialement limitée.  Cela nous permet de nous concentrer sur les aspects de la langue qui nous intéressent. </p><br><p>  Prenons un exemple de code contenant une seule branche: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==</span></span></span><span class="hljs-class"> "123") </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">else</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span></span></code> </pre> <br><p>  La condition divise l'ensemble des valeurs de <code>field1</code> en deux classes d'équivalence: <code>== "123"</code> et <code>!= "123"</code> .  Ainsi, l'ensemble complet des données d'entrée est également divisé en deux classes d'équivalence par rapport à cette condition - <code>ClassCondition1IsTrue</code> et <code>ClassCondition1IsFalse</code> .  Du point de vue de l'exhaustivité de la couverture, il nous suffit de prendre au moins un exemple de ces deux classes pour couvrir à la fois les branches <code>A</code> et <code>B</code>  Pour la première classe, nous pouvons construire un exemple, dans un sens, d'une manière unique: prendre un objet aléatoire, mais changer le <code>field1</code> en <code>"123"</code> .  De plus, l'objet apparaîtra certainement dans la classe d'équivalence <code>ClassCondition1IsTrue</code> et les calculs suivront la branche <code>A</code>  Il y a plus d'exemples pour la deuxième classe.  Une façon de générer un exemple de la deuxième classe consiste à générer des objets d'entrée arbitraires et à éliminer ceux avec <code>field1 == "123"</code> .  Une autre façon: pour prendre un objet aléatoire, mais changez le <code>field1</code> en <code>"123" + "*"</code> (pour la modification, vous pouvez utiliser n'importe quel changement dans la ligne de contrôle pour vous assurer que la nouvelle ligne n'est pas égale à la ligne de contrôle). </p><br><p>  <a href=""><code>  Arbitrary</code> et <code>Gen</code> de la bibliothèque ScalaCheck</a> conviennent parfaitement comme <a href=""><code>  Arbitrary</code></a> données <a href=""><code>  Arbitrary</code></a> . </p><br><p>  Essentiellement, nous <strong>appelons la</strong> fonction booléenne utilisée dans l' <code>if</code> .  Autrement dit, nous trouvons toutes les valeurs de l'objet d'entrée pour lesquelles cette fonction booléenne prend la valeur <code>true</code> - <code>ClassCondition1IsTrue</code> , et toutes les valeurs de l'objet d'entrée pour lesquelles elle prend la valeur <code>false</code> - <code>ClassCondition1IsFalse</code> . </p><br><p>  De manière similaire, il est possible de générer des données adaptées aux contraintes générées par de simples opérateurs conditionnels à constantes (plus / moins qu'une constante, incluse dans un ensemble, commence par une constante).  Ces conditions sont faciles à inverser.  Même si des fonctions simples sont appelées dans le code de test, nous pouvons remplacer leur appel par leur définition (en ligne) et toujours inverser les expressions conditionnelles. </p><br><h4 id="trudno-obratimye-funkcii">  Fonctions réversibles dures </h4><br><p>  La situation est différente lorsque la condition utilise une fonction difficile à inverser.  Par exemple, si une fonction de hachage est utilisée, il ne semble pas possible de générer automatiquement un exemple donnant la valeur souhaitée du code de hachage. </p><br><p>  Dans ce cas, vous pouvez ajouter un paramètre supplémentaire à l'objet d'entrée qui représente le résultat du calcul de fonction, remplacer l'appel de fonction par un appel à ce paramètre et mettre à jour ce paramètre, malgré la violation de la connexion fonctionnelle: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sha(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==</span></span></span><span class="hljs-class">"</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a9403</span></span></span><span class="hljs-class">...") ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==&gt;</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">if</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">object.sha_field1 == "a9403..."</span></span></span><span class="hljs-class">) ...</span></span></code> </pre> <br><p>  Un paramètre supplémentaire permet l'exécution de code à l'intérieur de la branche, mais, évidemment, cela peut conduire à des résultats réellement incorrects.  Autrement dit, le programme de test produira des résultats qui ne peuvent jamais être observés dans la réalité.  Néanmoins, la vérification d'une partie du code qui nous est autrement inaccessible est toujours utile et peut être considérée comme une forme de test unitaire.  Après tout, même pendant les tests unitaires, une sous-fonction est appelée avec des arguments qui ne peuvent jamais être utilisés dans le programme. </p><br><p>  Avec de telles manipulations, nous remplaçons (remplaçons) l'objet de test.  Cependant, dans un sens, le programme nouvellement construit inclut la logique de l'ancien programme.  En effet, si comme valeurs des nouveaux paramètres artificiels nous prenons les résultats du calcul des fonctions que nous avons remplacées par les paramètres, le programme produira les mêmes résultats.  Apparemment, tester le programme modifié peut encore être intéressant.  Vous devez juste vous rappeler dans quelles conditions le programme modifié se comportera de la même manière que le programme d'origine. </p><br><h4 id="zavisimye-usloviya">  Conditions dépendantes </h4><br><p>         ,      .        ,  ,   ,      .        ,     . (,  , <code>x &gt; 0</code> ,   — <code>x &lt;= 1</code> .         ,           — <code>(-∞, 0]</code> , <code>(0, 1]</code> , <code>(1, +∞)</code> , —      .) </p><br><p>       ,     ,   ,        <code>true</code>  <code>false</code>     .   ,    ,  " "         . </p><br><h4 id="svyazannye-parametry">   </h4><br><p>  ,        ,   : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(y &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y &gt; x)</code> </pre> <br><p> (     <code>&gt; 0</code> ,       — <code>y &gt; x</code> .) <br>    "", ,   ,      ,    ,     .             ,             "  "     . <br>  ,   "",  ( <code>y == x + 1</code> ),    ,        . <br>   "" ( <code>y &gt; x + 1 &amp;&amp; y &lt; x + 2</code> ),     ,        . </p><br><h4 id="simvolnoe-vypolnenie">   </h4><br><p>  ,    ,    -  ,   "c " ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Symbolic Execution</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a> ),     .        ( <code>field1 = field1_initial_value</code> ).       ,    .       : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = field1 + <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">//    a = field_initial_value + 10 val b = a * 3 //    b = 3 * field_initial_value + 30</span></span></code> </pre> <br><p>         — <code>true</code>  <code>false</code> .       .           .  Par exemple </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-type"><span class="hljs-type">A</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">B</span></span> <span class="hljs-comment"><span class="hljs-comment">//   A ,  field_initial_value + 10 &gt; 0 //   B ,  field_initial_value + 10 &lt;= 0</span></span></code> </pre> <br><p>           ,  ,   ,     ,    .        ,       (, ,   ). </p><br><h4 id="testirovanie-ciklov-i-rekursivnyh-funkciy">      </h4><br><p>        .    ,     ,       .        ,       .         ,         . </p><br><p> ,      .       . , ,        .  ,       ,      ,        .        ,   ,   ,  ,   ,      ? </p><br><p>     Y- ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"  "</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">stackoverflow:What is a Y-combinator? (2- )</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">habr:  Y-  7  </a> ).      ,       . (   ,      ,  .)    .            ,      .        ,    ""    . Y-   "  "     (     ). </p><br><p>        ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> ).   ,       .         ,     .       ,      . ,   ,       ,       <code>TestCase</code> '.  ,       ,     ( <code>throw</code>   <code>Nothing</code>  <code>bottom</code> ,    ).            . </p><br><p>        ,   .        .    ,  ,        .  ,       .        ,    ,     .          , ,    ,    ,      .      ,        .      ,    . </p><br><h3 id="smysl-testirovaniya-belogo-yaschika">     </h3><br><p>      ,  ,     ,      ,    100% .       ,     ,   .  Hm. .   , ,   ,   ?         ,    ,     -  . </p><br><p>           : </p><br><ol><li>                . </li><li>       (      ). </li><li>       ,          . </li><li>      ,    . </li></ol><br><p>       ,   ,       . -,       ,     ,   ,       . -,    ,   ,     ( ,  ),         ,  ,   ""  .   /    ,         . </p><br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>        "   "  "   ".  ,      ,     ,      ,     .         ,           . </p><br><p>      ,      ,  ,  ,  . -,          ,        ( ),      . -, -,      .      DSL,  ,    . -,          ,   . -,       ,        (   ,     ,   ).            . </p><br><p>  ,          ,      . ,      ,         -   . </p><br><h3 id="blagodarnosti">  Remerciements </h3><br><p>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@mneychev</a>        . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr422283/">https://habr.com/ru/post/fr422283/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr422269/index.html">Le livre "Périphérique interne Windows. 7e éd.</a></li>
<li><a href="../fr422273/index.html">Il n'y a pas de routes stupides dans une ville intelligente. Qu'est-ce que RWIS et comment réduira-t-il le coût des travaux routiers</a></li>
<li><a href="../fr422275/index.html">Un employé de Google a pu contrôler le système d'ouverture des portes dans les bureaux de l'entreprise en raison d'une vulnérabilité logicielle</a></li>
<li><a href="../fr422277/index.html">Architecture et programmation RCA Studio II</a></li>
<li><a href="../fr422281/index.html">A7 Data Server: gestion des données en ligne</a></li>
<li><a href="../fr422285/index.html">Pourquoi les achats en ligne fidélisent suffisamment 1% des clients</a></li>
<li><a href="../fr422291/index.html">Petite boîte noire (visualisation de tous les marchés monétaires et mondiaux)</a></li>
<li><a href="../fr422293/index.html">Obtenir la liste des alarmes depuis OSS via l'interface AlarmIRP</a></li>
<li><a href="../fr422297/index.html">La première expérience ou comment essayer de devenir une légende du code et de la magie</a></li>
<li><a href="../fr422299/index.html">TsNIImash: SpaceX implémenterait les développements soviétiques. Pourquoi Ilon Mask a tant d'ennemis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>