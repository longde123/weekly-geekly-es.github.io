<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äç‚öñÔ∏è ü§ôüèº üì™ Test de bo√Æte blanche üë©üèø‚Äçü§ù‚Äçüë®üèæ üö© üíÜ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le d√©veloppement de programmes de haute qualit√© implique que le programme et ses composants soient test√©s. Les tests unitaires classiques consistent √†...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Test de bo√Æte blanche</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422283/"><p>  Le d√©veloppement de programmes de haute qualit√© implique que le programme et ses composants soient test√©s.  Les tests unitaires classiques consistent √† diviser un grand programme en petits blocs qui sont pratiques pour les tests.  Ou, si le d√©veloppement de tests a lieu en parall√®le avec le d√©veloppement de code ou si des tests sont d√©velopp√©s avant le programme (TDD - d√©veloppement pilot√© par les tests), alors le programme est initialement d√©velopp√© en petits blocs adapt√©s aux exigences des tests. </p><br><p>  L'une des vari√©t√©s de tests unitaires peut √™tre consid√©r√©e comme un test bas√© sur les propri√©t√©s (cette approche est impl√©ment√©e, par exemple, dans les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">biblioth√®ques</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">QuickCheck</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ScalaCheck</a> ).  Cette approche est bas√©e sur la recherche de propri√©t√©s universelles qui devraient √™tre valides pour toutes les donn√©es d'entr√©e.  Par exemple, la <em>s√©rialisation suivie de la d√©s√©rialisation devrait produire le m√™me objet</em> .  Ou, le <em>nouveau tri ne doit pas modifier l'ordre des √©l√©ments de la liste</em> .  Pour v√©rifier ces propri√©t√©s universelles, les biblioth√®ques ci-dessus prennent en charge un m√©canisme pour g√©n√©rer des donn√©es d'entr√©e al√©atoires.  Cette approche fonctionne particuli√®rement bien pour les programmes bas√©s sur des lois math√©matiques qui servent de propri√©t√©s universelles valables pour une large classe de programmes.  Il existe m√™me une biblioth√®que de propri√©t√©s math√©matiques pr√™tes √† l'emploi - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">discipline</a> - qui vous permet de v√©rifier les performances de ces propri√©t√©s dans de nouveaux programmes (un bon exemple de r√©utilisation de tests). </p><br><p>  Parfois, il s'av√®re qu'il est n√©cessaire de tester un programme complexe sans pouvoir l'analyser en parties v√©rifiables ind√©pendamment.  Dans ce cas, le programme de test est <del>  noir </del>  bo√Æte blanche (blanche - car nous avons la possibilit√© d'√©tudier la structure interne du programme). </p><br><p>  Sous la coupe, plusieurs approches pour tester des programmes complexes avec une entr√©e avec diff√©rents degr√©s de complexit√© (implication) et diff√©rents degr√©s de couverture sont d√©crites. </p><a name="habracut"></a><br><p>  * <em>Dans cet article, nous supposons que le programme test√© peut √™tre repr√©sent√© comme une fonction pure sans √©tat interne.</em>  <em>(Certaines des consid√©rations ci-dessous peuvent √™tre appliqu√©es si l'√©tat interne est pr√©sent, mais il est possible de r√©initialiser cet √©tat √† une valeur fixe.)</em> </p><br><h3 id="testovyy-stend-test-bench">  Banc d'essai </h3><br><p> Tout d'abord, puisqu'une seule fonction est test√©e, dont le code appelant est toujours le m√™me, nous n'avons pas besoin de cr√©er des tests unitaires s√©par√©s.  Tous ces tests seraient les m√™mes, pr√©cis √† l'entr√©e et aux contr√¥les.  Il suffit de transmettre les donn√©es source ( <code>input</code> ) en boucle et de v√©rifier les r√©sultats ( <code>input</code> <code>expectedOutput</code> ).  Afin d'identifier un ensemble probl√©matique de donn√©es de test en cas de d√©tection d'erreur, toutes les donn√©es de test doivent √™tre √©tiquet√©es.  Ainsi, un ensemble de donn√©es de test peut √™tre repr√©sent√© comme un triple: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCase</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">label: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, input: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-class"><span class="hljs-params">, expectedOutput: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  Le r√©sultat d'une ex√©cution peut √™tre repr√©sent√© par <code>TestCaseResult</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCaseResult</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">testCase: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">TestCase</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-class"><span class="hljs-params">, </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span><span class="hljs-class"><span class="hljs-params">], actualOutput: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Try</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  (Nous pr√©sentons le r√©sultat du lancement en utilisant <code>Try</code> to catch possible exceptions.) </p><br><p>  Pour simplifier l'ex√©cution de toutes les donn√©es de test via le programme test√©, vous pouvez utiliser une fonction d'assistance qui appellera le programme pour chaque valeur d'entr√©e: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runTestCases</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>](cases: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">TestCase</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>])(f: <span class="hljs-type"><span class="hljs-type">A</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">B</span></span>): <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">TestCaseResult</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>]] = cases .map{ testCase =&gt; <span class="hljs-type"><span class="hljs-type">TestCaseResult</span></span>(testCase, <span class="hljs-type"><span class="hljs-type">Try</span></span>{ f(testCase.input) } ) } .filter(r =&gt; r.actualOutput != <span class="hljs-type"><span class="hljs-type">Success</span></span>(r.testCase.expectedOutput))</code> </pre> <br><p>  Cette fonction d'assistance renvoie les donn√©es et les r√©sultats probl√©matiques qui sont diff√©rents de ceux attendus. </p><br><p>  Pour plus de commodit√©, vous pouvez formater les r√©sultats du test. </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">report</span></span></span></span>(results: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">TestCaseResult</span></span>[_, _]]): <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">s"Failed </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${results.length}</span></span></span><span class="hljs-string">:\n"</span></span> + results .map(r =&gt; r.testCase.label + <span class="hljs-string"><span class="hljs-string">": expected "</span></span> + r.testCase.expectedOutput + <span class="hljs-string"><span class="hljs-string">", but got "</span></span> + r.actualOutput) .mkString(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>)</code> </pre> <br><p>  et n'afficher un rapport qu'en cas d'erreur: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCases = <span class="hljs-type"><span class="hljs-type">Seq</span></span>( <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) ) test(<span class="hljs-string"><span class="hljs-string">"all test cases"</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testBench = runTestCases(testCases) _ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> results = testBench(f) assert(results.isEmpty, report(results)) }</code> </pre> <br><h3 id="podgotovka-vhodnyh-dannyh">  Pr√©paration des entr√©es </h3><br><p>  Dans le cas le plus simple, vous pouvez cr√©er manuellement des donn√©es de test pour tester le programme, les √©crire directement dans le code de test et les utiliser, comme indiqu√© ci-dessus.  Il s'av√®re souvent que des cas int√©ressants de donn√©es de test ont beaucoup en commun et peuvent √™tre pr√©sent√©s comme une instance de base, avec des modifications mineures. </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> baseline = <span class="hljs-type"><span class="hljs-type">MyObject</span></span>(...) <span class="hljs-comment"><span class="hljs-comment">//        val testCases = Seq( TestCase("baseline", baseline, ???), TestCase("baseline + (field1 = 123)", baseline.copy(field1 = "123"), ???) )</span></span></code> </pre> <br><p>  Lorsque vous travaillez avec des structures de donn√©es immuables imbriqu√©es, les lentilles sont tr√®s utiles, par exemple, √† partir de la biblioth√®que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Monocle</a> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> baseline = ??? <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testObject1 = (field1 composeLens field2).set(<span class="hljs-string"><span class="hljs-string">"123"</span></span>)(baseline) <span class="hljs-comment"><span class="hljs-comment">//    : val testObject1 = baseline.copy(field1 = baseline.field1.copy(field2 = "123"))</span></span></code> </pre> <br><p>  Les objectifs vous permettent de ¬´modifier¬ª avec √©l√©gance les parties profond√©ment imbriqu√©es des structures de donn√©es: chaque objectif est un getter et un setter pour une propri√©t√©.  Les lentilles peuvent √™tre combin√©es pour produire des lentilles qui ¬´se concentrent¬ª sur le niveau suivant. </p><br><h3 id="ispolzovanie-dsl-dlya-predstavleniya-izmeneniy">  Utilisation de DSL pour pr√©senter les modifications </h3><br><p>  Ensuite, nous consid√©rerons la formation de donn√©es de test en apportant des modifications √† un objet d'entr√©e initial.  Habituellement, pour obtenir l'objet de test dont nous avons besoin, nous devons apporter quelques modifications.  Dans le m√™me temps, il est tr√®s utile d'inclure une liste de modifications dans la description textuelle de TestCase: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCases = <span class="hljs-type"><span class="hljs-type">Seq</span></span>( <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"baseline"</span></span>, baseline, ???), <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"baseline + "</span></span> + <span class="hljs-string"><span class="hljs-string">"(field1 = 123) + "</span></span> + <span class="hljs-comment"><span class="hljs-comment">//  1-  "(field2 = 456) + " + // 2- "(field3 = 789)", // 3- baseline .copy(field1 = "123") // 1-  .copy(field2 = "456") // 2-  .copy(field3 = "789"), // 3-  ???) )</span></span></code> </pre> <br><p>  Ensuite, nous saurons toujours pour quelles donn√©es de test le test est effectu√©. </p><br><p>  Pour que la liste textuelle des changements ne s'√©carte pas des changements r√©els, vous devez suivre le principe d'une "version unique de la v√©rit√©".  (Si la m√™me information est requise / utilis√©e √† plusieurs points, il devrait y avoir une seule source principale d'informations uniques et les informations devraient √™tre distribu√©es automatiquement √† tous les autres points d'utilisation, avec les transformations n√©cessaires. Si ce principe est viol√© et que la copie manuelle des informations est in√©vitable . informations sur la version de divergence √† diff√©rents points dans d' autres termes dans la description des donn√©es de test, nous voyons une, et des donn√©es de test -. autre exemple, la copie d' un changement <code>field2 = "456"</code> et le r√©glage dans le <code>field3 = "789"</code> nous Mauger  accidentellement oublier de corriger la description. Par cons√©quent, la description ne refl√®te deux changements de trois.) </p><br><p>  Dans notre cas, la principale source d'information est les modifications elles-m√™mes, ou plut√¥t le code source du programme qui effectue les modifications.  Nous aimerions en d√©duire un texte d√©crivant les changements.  √Ä l'inverse, comme premi√®re option, vous pouvez sugg√©rer d'utiliser une macro qui capturera le code source des modifications et utilisera le code source comme documentation.  Il s'agit, apparemment, d'un moyen efficace et relativement simple de documenter les changements r√©els et il pourrait tr√®s bien √™tre appliqu√© dans certains cas.  Malheureusement, si nous pr√©sentons les modifications en texte brut, nous perdons la possibilit√© de faire des transformations significatives de la liste des modifications.  Par exemple, d√©tectez et √©liminez les modifications en double ou qui se chevauchent, √©tablissez une liste de modifications d'une mani√®re pratique pour l'utilisateur final. </p><br><p>  Pour pouvoir g√©rer les modifications, vous devez en avoir un mod√®le structur√©.  Le mod√®le doit √™tre suffisamment expressif pour d√©crire tous les changements qui nous int√©ressent.  Une partie de ce mod√®le, par exemple, sera l'adressage des champs d'objet, des constantes, des op√©rations d'affectation. </p><br><p>  Le mod√®le de changement doit permettre de r√©soudre les t√¢ches suivantes: </p><br><ol><li>  G√©n√©rez des instances de mod√®le de changement.  (Autrement dit, cr√©er une liste sp√©cifique de modifications.) </li><li>  Formation d'une description textuelle des changements. </li><li>  Application des modifications aux objets de domaine. </li><li>  Effectuer des transformations d'optimisation sur le mod√®le. </li></ol><br><p>  Si un langage de programmation universel est utilis√© pour apporter des modifications, il peut √™tre difficile de repr√©senter ces modifications dans le mod√®le.  Le code source du programme peut utiliser des constructions complexes qui ne sont pas prises en charge par le mod√®le.  Un tel programme peut utiliser des motifs secondaires, tels que des lentilles ou la m√©thode de <code>copy</code> , pour modifier les champs d'un objet, qui sont des abstractions de niveau inf√©rieur par rapport au niveau du mod√®le de changement.  Par cons√©quent, une analyse suppl√©mentaire de ces mod√®les peut √™tre n√©cessaire pour g√©n√©rer des instances de modifications.  Ainsi, au d√©part, une bonne option en utilisant une macro n'est pas tr√®s pratique. </p><br><p>  Une autre fa√ßon de cr√©er des instances du mod√®le de changement peut √™tre un langage sp√©cialis√© (DSL), qui cr√©e des objets de mod√®le de changement √† l'aide d'un ensemble de m√©thodes d'extension et d'op√©rateurs auxiliaires.  Eh bien, dans les cas les plus simples, les instances du mod√®le de changement peuvent √™tre cr√©√©es directement via les constructeurs. </p><br><div class="spoiler">  <b class="spoiler_title">Modifier les d√©tails de la langue</b> <div class="spoiler_text"><p>  Le langage de changement est une construction assez complexe qui comprend plusieurs composants, qui sont √† leur tour non triviaux. </p><br><ol><li>  Mod√®le de structure de donn√©es. </li><li>  Changer de mod√®le. </li><li>  En fait Embedded (?) DSL - constructions auxiliaires, m√©thodes d'extension, pour une construction pratique des changements. </li><li>  Un interpr√®te des changements qui vous permet de r√©ellement "modifier" un objet (en fait, bien s√ªr, cr√©er une copie modifi√©e). </li></ol><br><p>  Voici un exemple de programme √©crit en DSL: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> target: <span class="hljs-type"><span class="hljs-type">Entity</span></span>[<span class="hljs-type"><span class="hljs-type">Target</span></span>] <span class="hljs-comment"><span class="hljs-comment">// ,     val updateField1 = target \ field1 := "123" val updateField2 = target \ subobject \ field2 := "456" // ,   DSL: val updateField1 = SetProperty(PropertyAccess(target, Property(field1, typeTag[String])), LiftedString("123")) val updateField2 = SetProperty(PropertyAccess(PropertyAccess(target, Property(subobject, typeTag[SubObject])), Property(field2, typeTag[String])), LiftedString("456"))</span></span></code> </pre> <br><p>  Autrement dit, √† l'aide des m√©thodes d'extension <code>\</code> et <code>:=</code> , <code>PropertyAccess</code> , les objets <code>SetProperty</code> sont form√©s √† partir des objets <code>target</code> , <code>field1</code> , <code>subobject</code> , <code>field2</code> pr√©c√©demment cr√©√©s.  De plus, en raison de conversions implicites (dangereuses), la cha√Æne "123" est compress√©e dans une <code>LiftedString</code> (vous pouvez vous passer de conversions implicites et appeler explicitement la m√©thode correspondante: <code>lift("123")</code> ). </p><br><p>  Une ontologie typ√©e peut √™tre utilis√©e comme mod√®le de donn√©es (voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://habr.com/post/229035/</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://habr.com/post/222553/</a> ).  (En bref: les objets de nom sont d√©clar√©s qui repr√©sentent les propri√©t√©s de tout type de domaine: <code>val field1: Property[Target, String]</code> .) Dans ce cas, les donn√©es r√©elles peuvent √™tre stock√©es, par exemple, sous la forme de JSON.  La commodit√© d'une ontologie typ√©e dans notre cas r√©side dans le fait que le mod√®le de changement fonctionne g√©n√©ralement avec les propri√©t√©s individuelles des objets, et l'ontologie fournit simplement un outil appropri√© pour adresser les propri√©t√©s. </p><br><p>  Pour repr√©senter les modifications, vous avez besoin d'un ensemble de classes du m√™me plan que la classe <code>SetProperty</code> ci-dessus: </p><br><ul><li>  <code>Modify</code> - application de la fonction, </li><li>  <code>Changes</code> - appliquer plusieurs modifications s√©quentiellement </li><li>  <code>ForEach</code> - appliquez des modifications √† chaque √©l√©ment de la collection, </li><li>  etc. </li></ul><br><p>  L'interpr√©teur de changement de langue est un √©valuateur d'expressions r√©cursives r√©guli√®res bas√© sur PatternMatching.  Quelque chose comme: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eval</span></span></span></span>(expression: <span class="hljs-type"><span class="hljs-type">DslExpression</span></span>, gamma: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>]): <span class="hljs-type"><span class="hljs-type">Any</span></span> = expression <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">LiftedString</span></span>(str) =&gt; str <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">PropertyAccess</span></span>(obj, prop) =&gt; <span class="hljs-type"><span class="hljs-type">Getter</span></span>(prop)(gamma).get(obj) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">change</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>] (expression: <span class="hljs-type"><span class="hljs-type">DslChangeExpression</span></span>, gamma: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>], target: <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">T</span></span> = expression <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">SetProperty</span></span>(path, valueExpr) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> value = eval(valueExpr, gamma) <span class="hljs-type"><span class="hljs-type">Setter</span></span>(path)(gamma).set(value)(target) }</code> </pre> <br><p>  Pour op√©rer directement sur les propri√©t√©s des objets, vous devez sp√©cifier getter et setter pour chaque propri√©t√© utilis√©e dans le mod√®le de modification.  Ceci peut √™tre r√©alis√© en remplissant la carte entre les propri√©t√©s ontologiques et leurs lentilles correspondantes. </p></div></div><br><p>  Cette approche dans son ensemble fonctionne et vous permet en effet de d√©crire les changements une fois, mais progressivement, il est n√©cessaire de repr√©senter des changements de plus en plus complexes et le mod√®le des changements se d√©veloppe quelque peu.  Par exemple, si vous devez modifier une propri√©t√© en utilisant la valeur d'une autre propri√©t√© du m√™me objet (par exemple, <code>field1 = field2 + 1</code> ), vous devez prendre en charge les variables au niveau DSL.  Et si la modification d'une propri√©t√© n'est pas triviale, au niveau DSL, la prise en charge des expressions et des fonctions arithm√©tiques est requise. </p><br><h3 id="testirovanie-vetvey">  Test de branche </h3><br><p>  Le code de test peut √™tre lin√©aire, puis, dans l'ensemble, un seul ensemble de donn√©es de test suffit pour comprendre s'il fonctionne.  S'il existe une branche ( <code>if-then-else</code> ), vous devez ex√©cuter la bo√Æte blanche au moins deux fois avec des donn√©es d'entr√©e diff√©rentes pour que les deux branches soient ex√©cut√©es.  Le nombre d'ensembles de donn√©es d'entr√©e suffisant pour couvrir toutes les branches est apparemment num√©riquement √©gal √† la complexit√© cyclomatique du code √† branches. </p><br><p>  Comment former tous les ensembles de donn√©es d'entr√©e?  Comme nous avons affaire √† une bo√Æte blanche, nous pouvons isoler les conditions de branchement et modifier deux fois l'objet d'entr√©e afin que dans un cas une branche soit ex√©cut√©e, dans l'autre cas une autre.  Prenons un exemple: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==</span></span></span><span class="hljs-class"> "123") </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">else</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span></span></code> </pre> <br><p>  Ayant une telle condition, nous pouvons former deux cas de test: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCase1 = <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"A"</span></span>, field1.set(<span class="hljs-string"><span class="hljs-string">"123"</span></span>)(baseline), <span class="hljs-comment"><span class="hljs-comment">/* result of A */</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCase2 = <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"B"</span></span>, field1.set(<span class="hljs-comment"><span class="hljs-comment">/*  "123", , , */</span></span><span class="hljs-string"><span class="hljs-string">"123"</span></span> + <span class="hljs-string"><span class="hljs-string">"1"</span></span>&gt;)(baseline), <span class="hljs-comment"><span class="hljs-comment">/*result of B*/</span></span>)</code> </pre> <br><p>  <em>(Si l'un des sc√©narios de test ne peut pas √™tre cr√©√©, nous pouvons supposer que le code mort a √©t√© d√©tect√© et que la condition, ainsi que la branche correspondante, peuvent √™tre supprim√©es en toute s√©curit√©.)</em> </p><br><p>  Si les propri√©t√©s ind√©pendantes d'un objet sont v√©rifi√©es dans plusieurs branches, il est assez simple de former un ensemble exhaustif d'objets de test modifi√©s qui couvre compl√®tement toutes les combinaisons possibles. </p><br><div class="spoiler">  <b class="spoiler_title">DSL pour former toutes les combinaisons de changements</b> <div class="spoiler_text"><p>  Examinons plus en d√©tail le m√©canisme qui permet de former toutes les listes de changements possibles qui couvrent enti√®rement toutes les branches.  Afin d'utiliser la liste des modifications pendant les tests, nous devons combiner toutes les modifications en un seul objet, que nous soumettrons √† l'entr√©e du code test√©, c'est-√†-dire que la prise en charge de la composition est requise.  Pour ce faire, vous pouvez soit utiliser la DSL ci-dessus pour mod√©liser les modifications, puis une simple liste de modifications suffit, ou vous pouvez pr√©senter une modification comme une fonction de modification <code>T =&gt; T</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> change1: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> = field1.set(<span class="hljs-string"><span class="hljs-string">"123"</span></span>)(_) <span class="hljs-comment"><span class="hljs-comment">// val change1: T =&gt; T = _.copy(field1 = "123") val change2: T =&gt; T = field2.set("456")</span></span></code> </pre> <br><p>  alors la cha√Æne des changements sera simplement une composition de fonctions: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> changes = change1 compose change2</code> </pre> <br><p>  ou, pour une liste de modifications: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> rawChangesList: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>] = <span class="hljs-type"><span class="hljs-type">Seq</span></span>(change1, change2) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> allChanges: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> = rawChangesList.foldLeft(identity)(_ compose _)</code> </pre> <br><p>  Pour enregistrer de mani√®re compacte toutes les modifications correspondant √† toutes les branches possibles, vous pouvez utiliser la DSL du niveau d'abstraction suivant, qui simule la structure de la bo√Æte blanche test√©e: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tests: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>)] = <span class="hljs-type"><span class="hljs-type">IF</span></span>(<span class="hljs-string"><span class="hljs-string">"field1 == '123'"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  ,    THEN( field1.set("123"))( //  target \ field1 := "123" IF("field2 == '456') THEN(field2.set("456"))(TERMINATE) ELSE(field2.set("456" + "1"))(TERMINATE) ) ELSE( field1.set("123" + "1") )(TERMINATE)</span></span></code> </pre> <br><p>  Ici, la collection de <code>tests</code> contient des modifications agr√©g√©es correspondant √† toutes les combinaisons possibles de branches.  Un param√®tre de type <code>String</code> contiendra tous les noms des conditions et toutes les descriptions des modifications √† partir desquelles la fonction de modification globale est form√©e.  Et le deuxi√®me √©l√©ment d'une paire de type <code>T =&gt; T</code> n'est que la fonction agr√©g√©e des changements obtenus √† la suite de la composition des changements individuels. </p><br><p>  Pour obtenir les objets modifi√©s, vous devez appliquer toutes les fonctions de modification agr√©g√©es √† l'objet de base: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tests2: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>)] = tests.map(_.map_2(_(baseline)))</code> </pre> <br><p>  En cons√©quence, nous obtenons une collection de paires, et la ligne d√©crira les changements appliqu√©s, et le deuxi√®me √©l√©ment de la paire sera l'objet dans lequel tous ces changements seront combin√©s. </p><br><p>  Sur la base de la structure du mod√®le du code test√© sous forme d'arbre, les listes de modifications repr√©senteront le chemin de la racine aux feuilles de cet arbre.  Ainsi, une partie importante des modifications sera dupliqu√©e.  Vous pouvez vous d√©barrasser de cette duplication √† l'aide de l'option DSL, dans laquelle les modifications sont directement appliqu√©es √† l'objet de ligne de base lorsque vous vous d√©placez le long des branches.  Dans ce cas, moins de calculs inutiles seront effectu√©s. </p></div></div><br><h3 id="avtomaticheskoe-formirovanie-testovyh-dannyh">  G√©n√©ration automatique des donn√©es de test </h3><br><p>  Puisque nous avons affaire √† une bo√Æte blanche, nous pouvons voir toutes les branches.  Cela permet de construire un mod√®le de logique contenu dans une bo√Æte blanche et d'utiliser le mod√®le pour g√©n√©rer des donn√©es de test.  Si le code de test est √©crit en Scala, vous pouvez, par exemple, utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">scalameta</a> pour lire le code, avec conversion ult√©rieure en mod√®le logique.  Encore une fois, comme dans la question pr√©c√©demment discut√©e de la mod√©lisation de la logique des changements, il nous est difficile de mod√©liser toutes les possibilit√©s d'un langage universel.  De plus, nous supposerons que le code test√© est impl√©ment√© en utilisant un sous-ensemble limit√© de la langue, ou dans une autre langue ou DSL, qui est initialement limit√©e.  Cela nous permet de nous concentrer sur les aspects de la langue qui nous int√©ressent. </p><br><p>  Prenons un exemple de code contenant une seule branche: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==</span></span></span><span class="hljs-class"> "123") </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">else</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span></span></code> </pre> <br><p>  La condition divise l'ensemble des valeurs de <code>field1</code> en deux classes d'√©quivalence: <code>== "123"</code> et <code>!= "123"</code> .  Ainsi, l'ensemble complet des donn√©es d'entr√©e est √©galement divis√© en deux classes d'√©quivalence par rapport √† cette condition - <code>ClassCondition1IsTrue</code> et <code>ClassCondition1IsFalse</code> .  Du point de vue de l'exhaustivit√© de la couverture, il nous suffit de prendre au moins un exemple de ces deux classes pour couvrir √† la fois les branches <code>A</code> et <code>B</code>  Pour la premi√®re classe, nous pouvons construire un exemple, dans un sens, d'une mani√®re unique: prendre un objet al√©atoire, mais changer le <code>field1</code> en <code>"123"</code> .  De plus, l'objet appara√Ætra certainement dans la classe d'√©quivalence <code>ClassCondition1IsTrue</code> et les calculs suivront la branche <code>A</code>  Il y a plus d'exemples pour la deuxi√®me classe.  Une fa√ßon de g√©n√©rer un exemple de la deuxi√®me classe consiste √† g√©n√©rer des objets d'entr√©e arbitraires et √† √©liminer ceux avec <code>field1 == "123"</code> .  Une autre fa√ßon: pour prendre un objet al√©atoire, mais changez le <code>field1</code> en <code>"123" + "*"</code> (pour la modification, vous pouvez utiliser n'importe quel changement dans la ligne de contr√¥le pour vous assurer que la nouvelle ligne n'est pas √©gale √† la ligne de contr√¥le). </p><br><p>  <a href=""><code>  Arbitrary</code> et <code>Gen</code> de la biblioth√®que ScalaCheck</a> conviennent parfaitement comme <a href=""><code>  Arbitrary</code></a> donn√©es <a href=""><code>  Arbitrary</code></a> . </p><br><p>  Essentiellement, nous <strong>appelons la</strong> fonction bool√©enne utilis√©e dans l' <code>if</code> .  Autrement dit, nous trouvons toutes les valeurs de l'objet d'entr√©e pour lesquelles cette fonction bool√©enne prend la valeur <code>true</code> - <code>ClassCondition1IsTrue</code> , et toutes les valeurs de l'objet d'entr√©e pour lesquelles elle prend la valeur <code>false</code> - <code>ClassCondition1IsFalse</code> . </p><br><p>  De mani√®re similaire, il est possible de g√©n√©rer des donn√©es adapt√©es aux contraintes g√©n√©r√©es par de simples op√©rateurs conditionnels √† constantes (plus / moins qu'une constante, incluse dans un ensemble, commence par une constante).  Ces conditions sont faciles √† inverser.  M√™me si des fonctions simples sont appel√©es dans le code de test, nous pouvons remplacer leur appel par leur d√©finition (en ligne) et toujours inverser les expressions conditionnelles. </p><br><h4 id="trudno-obratimye-funkcii">  Fonctions r√©versibles dures </h4><br><p>  La situation est diff√©rente lorsque la condition utilise une fonction difficile √† inverser.  Par exemple, si une fonction de hachage est utilis√©e, il ne semble pas possible de g√©n√©rer automatiquement un exemple donnant la valeur souhait√©e du code de hachage. </p><br><p>  Dans ce cas, vous pouvez ajouter un param√®tre suppl√©mentaire √† l'objet d'entr√©e qui repr√©sente le r√©sultat du calcul de fonction, remplacer l'appel de fonction par un appel √† ce param√®tre et mettre √† jour ce param√®tre, malgr√© la violation de la connexion fonctionnelle: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sha(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==</span></span></span><span class="hljs-class">"</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a9403</span></span></span><span class="hljs-class">...") ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==&gt;</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">if</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">object.sha_field1 == "a9403..."</span></span></span><span class="hljs-class">) ...</span></span></code> </pre> <br><p>  Un param√®tre suppl√©mentaire permet l'ex√©cution de code √† l'int√©rieur de la branche, mais, √©videmment, cela peut conduire √† des r√©sultats r√©ellement incorrects.  Autrement dit, le programme de test produira des r√©sultats qui ne peuvent jamais √™tre observ√©s dans la r√©alit√©.  N√©anmoins, la v√©rification d'une partie du code qui nous est autrement inaccessible est toujours utile et peut √™tre consid√©r√©e comme une forme de test unitaire.  Apr√®s tout, m√™me pendant les tests unitaires, une sous-fonction est appel√©e avec des arguments qui ne peuvent jamais √™tre utilis√©s dans le programme. </p><br><p>  Avec de telles manipulations, nous rempla√ßons (rempla√ßons) l'objet de test.  Cependant, dans un sens, le programme nouvellement construit inclut la logique de l'ancien programme.  En effet, si comme valeurs des nouveaux param√®tres artificiels nous prenons les r√©sultats du calcul des fonctions que nous avons remplac√©es par les param√®tres, le programme produira les m√™mes r√©sultats.  Apparemment, tester le programme modifi√© peut encore √™tre int√©ressant.  Vous devez juste vous rappeler dans quelles conditions le programme modifi√© se comportera de la m√™me mani√®re que le programme d'origine. </p><br><h4 id="zavisimye-usloviya">  Conditions d√©pendantes </h4><br><p>         ,      .        ,  ,   ,      .        ,     . (,  , <code>x &gt; 0</code> ,   ‚Äî <code>x &lt;= 1</code> .         ,           ‚Äî <code>(-‚àû, 0]</code> , <code>(0, 1]</code> , <code>(1, +‚àû)</code> , ‚Äî      .) </p><br><p>       ,     ,   ,        <code>true</code>  <code>false</code>     .   ,    ,  " "         . </p><br><h4 id="svyazannye-parametry">   </h4><br><p>  ,        ,   : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(y &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y &gt; x)</code> </pre> <br><p> (     <code>&gt; 0</code> ,       ‚Äî <code>y &gt; x</code> .) <br>    "", ,   ,      ,    ,     .             ,             "  "     . <br>  ,   "",  ( <code>y == x + 1</code> ),    ,        . <br>   "" ( <code>y &gt; x + 1 &amp;&amp; y &lt; x + 2</code> ),     ,        . </p><br><h4 id="simvolnoe-vypolnenie">   </h4><br><p>  ,    ,    -  ,   "c " ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Symbolic Execution</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a> ),     .        ( <code>field1 = field1_initial_value</code> ).       ,    .       : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = field1 + <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">//    a = field_initial_value + 10 val b = a * 3 //    b = 3 * field_initial_value + 30</span></span></code> </pre> <br><p>         ‚Äî <code>true</code>  <code>false</code> .       .           .  Par exemple </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-type"><span class="hljs-type">A</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">B</span></span> <span class="hljs-comment"><span class="hljs-comment">//   A ,  field_initial_value + 10 &gt; 0 //   B ,  field_initial_value + 10 &lt;= 0</span></span></code> </pre> <br><p>           ,  ,   ,     ,    .        ,       (, ,   ). </p><br><h4 id="testirovanie-ciklov-i-rekursivnyh-funkciy">      </h4><br><p>        .    ,     ,       .        ,       .         ,         . </p><br><p> ,      .       . , ,        .  ,       ,      ,        .        ,   ,   ,  ,   ,      ? </p><br><p>     Y- ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"  "</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">stackoverflow:What is a Y-combinator? (2- )</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">habr:  Y-  7  </a> ).      ,       . (   ,      ,  .)    .            ,      .        ,    ""    . Y-   "  "     (     ). </p><br><p>        ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> ).   ,       .         ,     .       ,      . ,   ,       ,       <code>TestCase</code> '.  ,       ,     ( <code>throw</code>   <code>Nothing</code>  <code>bottom</code> ,    ).            . </p><br><p>        ,   .        .    ,  ,        .  ,       .        ,    ,     .          , ,    ,    ,      .      ,        .      ,    . </p><br><h3 id="smysl-testirovaniya-belogo-yaschika">     </h3><br><p>      ,  ,     ,      ,    100% .       ,     ,   .  Hm. .   , ,   ,   ?         ,    ,     -  . </p><br><p>           : </p><br><ol><li>                . </li><li>       (      ). </li><li>       ,          . </li><li>      ,    . </li></ol><br><p>       ,   ,       . -,       ,     ,   ,       . -,    ,   ,     ( ,  ),         ,  ,   ""  .   /    ,         . </p><br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>        "   "  "   ".  ,      ,     ,      ,     .         ,           . </p><br><p>      ,      ,  ,  ,  . -,          ,        ( ),      . -, -,      .      DSL,  ,    . -,          ,   . -,       ,        (   ,     ,   ).            . </p><br><p>  ,          ,      . ,      ,         -   . </p><br><h3 id="blagodarnosti">  Remerciements </h3><br><p>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@mneychev</a>        . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr422283/">https://habr.com/ru/post/fr422283/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr422269/index.html">Le livre "P√©riph√©rique interne Windows. 7e √©d.</a></li>
<li><a href="../fr422273/index.html">Il n'y a pas de routes stupides dans une ville intelligente. Qu'est-ce que RWIS et comment r√©duira-t-il le co√ªt des travaux routiers</a></li>
<li><a href="../fr422275/index.html">Un employ√© de Google a pu contr√¥ler le syst√®me d'ouverture des portes dans les bureaux de l'entreprise en raison d'une vuln√©rabilit√© logicielle</a></li>
<li><a href="../fr422277/index.html">Architecture et programmation RCA Studio II</a></li>
<li><a href="../fr422281/index.html">A7 Data Server: gestion des donn√©es en ligne</a></li>
<li><a href="../fr422285/index.html">Pourquoi les achats en ligne fid√©lisent suffisamment 1% des clients</a></li>
<li><a href="../fr422291/index.html">Petite bo√Æte noire (visualisation de tous les march√©s mon√©taires et mondiaux)</a></li>
<li><a href="../fr422293/index.html">Obtenir la liste des alarmes depuis OSS via l'interface AlarmIRP</a></li>
<li><a href="../fr422297/index.html">La premi√®re exp√©rience ou comment essayer de devenir une l√©gende du code et de la magie</a></li>
<li><a href="../fr422299/index.html">TsNIImash: SpaceX impl√©menterait les d√©veloppements sovi√©tiques. Pourquoi Ilon Mask a tant d'ennemis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>