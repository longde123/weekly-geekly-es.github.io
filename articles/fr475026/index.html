<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛳️ 🖖🏿 🌺 3 histoires de crash de Kubernetes en production: anti-affinité, arrêt gracieux, webhook 🚨 🙎🏿 🕴🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Remarque perev. : Nous présentons une mini-sélection de post-mortem sur les problèmes mortels auxquels les ingénieurs de différentes entreprises ont é...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>3 histoires de crash de Kubernetes en production: anti-affinité, arrêt gracieux, webhook</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/475026/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/y7/_c/ra/y7_cracjhm0ke_mtazml1fhzprk.jpeg"></div><br>  <i><b>Remarque</b></i>  <i><b>perev.</b></i>  <i>: Nous présentons une mini-sélection de post-mortem sur les problèmes mortels auxquels les ingénieurs de différentes entreprises ont été confrontés lors de l'exploitation de l'infrastructure basée sur Kubernetes.</i>  <i>Chaque note parle du problème lui-même, de ses causes et de ses conséquences, et, bien sûr, d'une solution qui permet d'éviter des situations similaires à l'avenir.</i> <i><br><br></i>  <i>Comme vous le savez, apprendre de l'expérience de quelqu'un d'autre est moins cher, et donc - laissez ces histoires vous aider à vous préparer à d'éventuelles surprises.</i>  <i>Soit dit en passant, une large sélection de liens vers ces «histoires d'échecs» est régulièrement publiée sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce site</a> (selon les données de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce référentiel Git</a> ).</i> <a name="habracut"></a><br><br><h2>  N ° 1.  Comment la panique du noyau a bloqué un site </h2><br>  <i>Original: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">clair de lune</a> .</i> <br><br>  Entre le 18 et le 22 janvier, le site Web Moonlight et l'API ont connu des dysfonctionnements intermittents.  Tout a commencé avec des erreurs API aléatoires et s'est terminé par un arrêt complet.  Les problèmes ont été résolus et l'application est revenue à la normale. <br><br><h3>  Informations générales </h3><br>  Moonlight utilise un logiciel appelé Kubernetes.  Kubernetes exécute des applications sur des groupes de serveurs.  Ces serveurs sont appelés nœuds.  Les copies de l'application exécutée sur le nœud sont appelées pods.  Kubernetes a un planificateur qui détermine dynamiquement quels pods sur quels nœuds devraient fonctionner. <br><br><h3>  Chronologie </h3><br>  Vendredi, les premières erreurs étaient liées à des problèmes de connexion à la base de données Redis.  L'API Moonlight utilise Redis pour vérifier les sessions pour chaque demande authentifiée.  Notre outil de surveillance Kubernetes a signalé que certains nœuds et pods ne répondaient pas.  Dans le même temps, Google Cloud a signalé un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dysfonctionnement des services réseau</a> , et nous avons décidé qu'ils étaient à l'origine de nos problèmes. <br><br>  Comme le trafic du week-end a diminué, les erreurs ont semblé être résolues dans leur masse.  Cependant, mardi matin, le site de Moonlight est tombé et le trafic externe n'a pas du tout atteint le cluster.  Nous avons trouvé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une autre personne sur Twitter</a> avec des symptômes similaires et avons décidé que l'hébergement Google avait une panne de réseau.  Nous avons contacté l'assistance Google Cloud, qui a rapidement signalé le problème à l'équipe d'assistance technique. <br><br>  L'équipe d'assistance technique de Google a révélé une certaine tendance dans le comportement des nœuds de notre cluster Kubernetes.  La charge CPU des nœuds individuels a atteint 100%, après quoi la panique du noyau s'est produite dans la machine virtuelle et elle s'est bloquée. <br><br><h3>  Raisons </h3><br>  Le cycle à l'origine de l'échec était le suivant: <br><br><ul><li>  Le planificateur Kubernetes a hébergé plusieurs pods avec une consommation élevée de CPU sur le même nœud. </li><li>  Les pods ont consommé toutes les ressources CPU du nœud. </li><li>  Vint ensuite la panique du noyau, qui entraîna une période d'indisponibilité pendant laquelle le nœud ne répondit pas au planificateur. </li><li>  Le planificateur a déplacé tous les pods tombés vers un nouveau noeud, et le processus a été répété, exacerbant la situation générale. </li></ul><br>  Initialement, l'erreur s'est produite dans le pod Redis, mais au final tous les pods qui fonctionnent avec le trafic sont tombés, ce qui a conduit à un arrêt complet.  Des retards exponentiels pendant la replanification ont entraîné de plus longues périodes d'indisponibilité. <br><br><h3>  Solution </h3><br>  Nous avons pu restaurer le site en ajoutant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des règles anti-affinité</a> à tous les déploiements majeurs.  Ils distribuent automatiquement les modules sur les nœuds, augmentant la tolérance aux pannes et les performances. <br><br>  Kubernetes lui-même est conçu comme un système hôte tolérant aux pannes.  Moonlight utilise trois nœuds sur des serveurs différents pour plus de stabilité, et nous exécutons trois copies de chaque application qui dessert le trafic.  L'idée est d'avoir une copie sur chaque nœud.  Dans ce cas, même une défaillance de deux nœuds n'entraînera pas de temps d'arrêt.  Cependant, Kubernetes a parfois placé les trois modules avec le site sur le même nœud, créant ainsi un goulot d'étranglement dans le système.  Dans le même temps, d'autres applications exigeant de la puissance CPU (à savoir le rendu côté serveur) se sont retrouvées sur le même nœud, et non sur un autre. <br><br>  Un cluster Kubernetes correctement configuré et fonctionnant correctement est nécessaire pour faire face à de longues périodes de charge CPU élevée et placer les pods de manière à maximiser l'utilisation des ressources disponibles.  Nous continuons de travailler avec la prise en charge de Google Cloud pour identifier et résoudre la cause première de la panique du noyau sur les serveurs. <br><br><h3>  Conclusion </h3><br>  Les règles anti-affinité vous permettent de rendre les applications qui fonctionnent avec le trafic externe plus tolérantes aux pannes.  Si vous avez un service similaire chez Kubernetes, pensez à les ajouter. <br><br>  Nous continuons de travailler avec les gars de Google pour trouver et éliminer la cause des défaillances du noyau du système d'exploitation sur les nœuds. <br><br><h2>  N ° 2.  Le «sale» secret de Kubernetes et Ingress endpoint </h2><br>  <i>Original: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Phil Pearl de Ravelin</a> .</i> <br><br><h3>  L'élégance est surfaite </h3><br>  Chez Ravelin, nous avons migré vers Kubernetes (sur GKE).  Le processus a été couronné de succès.  Nos budgets de perturbation des pods sont aussi complets que jamais, les états sont vraiment majestueux <i>(un jeu de mots difficile à traduire: "nos ensembles avec état sont très majestueux" - environ la traduction)</i> , et le remplacement coulissant des nœuds fonctionne comme une horloge. <br><br>  La dernière pièce du puzzle consiste à déplacer la couche API des anciennes machines virtuelles vers le cluster Kubernetes.  Pour ce faire, nous devons configurer Ingress afin que l'API soit accessible depuis le monde extérieur. <br><br>  Au début, la tâche semblait simple.  Nous définissons simplement le contrôleur Ingress, modifions Terraform pour obtenir un certain nombre d'adresses IP, et Google s'occupe de presque tout le reste.  Et tout cela fonctionnera comme par magie.  Classe! <br><br>  Cependant, au fil du temps, ils ont commencé à remarquer que les tests d'intégration recevaient périodiquement des erreurs 502. De là, notre voyage a commencé.  Cependant, je vous ferai gagner du temps et irai directement aux conclusions. <br><br><h3>  Arrêt progressif </h3><br>  Tout le monde parle d'un arrêt progressif ("gracieux", arrêt progressif).  Mais vous ne devriez vraiment pas compter sur lui à Kubernetes.  Ou du moins, cela ne devrait pas être l'arrêt gracieux que vous avez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://golang.org/pkg/net/">absorbé avec le lait de votre mère</a> .  Dans le monde Kubernetes, ce niveau «d'élégance» est inutile et menace de graves problèmes. <br><br><h3>  Monde parfait </h3><br>  Voici comment, dans la vue majoritaire, le pod est supprimé du service ou de l'équilibreur de charge dans Kubernetes: <br><br><ol><li>  Le contrôleur de réplication décide de supprimer le pod. </li><li>  Le module de noeud final est supprimé du service ou de l'équilibreur de charge.  Le nouveau trafic vers le pod n'arrive plus. </li><li>  Un crochet de pré-arrêt est appelé ou le pod reçoit un signal SIGTERM. </li><li>  Le pod "gracieusement" est déconnecté.  Il cesse d'accepter les connexions entrantes. </li><li>  La déconnexion "gracieuse" est terminée et le pod est détruit une fois toutes ses connexions existantes arrêtées ou terminées. </li></ol><br>  Malheureusement, la réalité est complètement différente. <br><br><h3>  Monde réel </h3><br>  La plupart de la documentation laisse entendre que tout se passe un peu différemment, mais ils n'écrivent explicitement à ce sujet nulle part.  Le problème principal est que l'étape 3 ne suit pas l'étape 2. Elles se produisent simultanément.  Dans les services ordinaires, la suppression des points d'extrémité est si rapide que la probabilité de rencontrer des problèmes est extrêmement faible.  Cependant, avec Ingresss, tout est différent: ils réagissent généralement beaucoup plus lentement, donc le problème devient évident.  Le pod peut obtenir SIGTERM bien avant que les changements de points de terminaison n'entrent dans Ingress. <br><br>  En conséquence, un arrêt gracieux n'est pas du tout ce qui est requis d'un pod.  Il recevra de nouvelles connexions et devra continuer à les traiter, sinon les clients commenceront à recevoir les 500e erreurs et toute l'histoire merveilleuse des déploiements et de la mise à l'échelle simples commencera à s'effondrer. <br><br>  Voici ce qui se passe réellement: <br><br><ol><li>  Le contrôleur de réplication décide de supprimer le pod. </li><li>  Le module de noeud final est supprimé du service ou de l'équilibreur de charge.  Dans le cas d'Ingresss, cela peut prendre un certain temps et le nouveau trafic continuera de circuler dans le pod. </li><li>  Un crochet de pré-arrêt est appelé ou le pod reçoit un signal SIGTERM. </li><li>  Dans une large mesure, le pod doit ignorer cela, continuer à fonctionner et maintenir de nouvelles connexions.  Si possible, il devrait laisser entendre aux clients que ce serait bien de passer à un autre endroit.  Par exemple, dans le cas de HTTP, il peut envoyer <code>Connection: close</code> dans les en-têtes de réponse. </li><li>  Le pod ne sort que lorsque la période d'attente «élégante» expire et qu'il est tué par SIGKILL. </li><li>  Assurez-vous que cette période est plus longue que le temps nécessaire pour reprogrammer l'équilibreur de charge. </li></ol><br>  S'il s'agit d'un code tiers et que vous ne pouvez pas modifier son comportement, la meilleure chose à faire est d'ajouter un crochet de pré-arrêt qui dormira juste pendant une période «élégante», de sorte que le pod continuera de fonctionner comme si de rien arrivé. <br><br><h2>  Numéro 3.  Comment un simple webhook a provoqué une panne de cluster </h2><br>  <i>Original: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jetstack</a> .</i> <br><br>  Jetstack propose à ses clients des plateformes multi-locataires sur Kubernetes.  Parfois, il existe des exigences particulières que nous ne pouvons pas satisfaire avec la configuration standard de Kubernetes.  Pour les implémenter, nous avons récemment commencé à utiliser l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Open Policy Agent</a> <i>(nous avons écrit plus en détail sur le projet dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette revue</a> - environ Transl.)</i> En tant que contrôleur d'accès pour la mise en œuvre de politiques spéciales. <br><br>  Cet article décrit l'échec provoqué par une mauvaise configuration de cette intégration. <br><br><h3>  Incident </h3><br>  Nous étions engagés dans la mise à jour de l'assistant pour le cluster de développement, dans lequel diverses équipes ont testé leurs applications pendant la journée de travail.  Il s'agissait d'un cluster régional dans la zone europe-ouest1 sur le moteur Google Kubernetes (GKE). <br><br>  Les commandes ont été averties qu'une mise à jour était en cours, sans aucun temps d'arrêt prévu.  Plus tôt dans la journée, nous avons déjà effectué une mise à jour similaire vers un autre environnement de pré-production. <br><br>  Nous avons commencé la mise à niveau en utilisant notre pipeline GKE Terraform.  La mise à jour de l'assistant ne s'est pas terminée avant l'expiration du délai d'expiration Terraform, que nous avons défini pour 20 minutes.  Ce fut le premier réveil que quelque chose s'est mal passé, bien que dans la console GKE le cluster soit toujours répertorié comme «mise à niveau». <br><br>  Le redémarrage du pipeline a conduit à l'erreur suivante <br><br><pre> <code class="bash hljs">google_container_cluster.cluster: Error waiting <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> updating GKE master version: All cluster resources were brought up, but the cluster API is reporting that: component <span class="hljs-string"><span class="hljs-string">"kube-apiserver"</span></span> from endpoint <span class="hljs-string"><span class="hljs-string">"gke-..."</span></span> is unhealthy</code> </pre> <br>  Cette fois, la connexion avec le serveur API a commencé à être interrompue périodiquement et les équipes n'ont pas pu déployer leurs applications. <br><br>  Pendant que nous essayions de comprendre ce qui se passait, tous les nœuds ont commencé à être détruits et recréés dans un cycle sans fin.  Cela a conduit à un déni de service aveugle pour tous nos clients. <br><br><h3>  Nous établissons la cause profonde de l'échec </h3><br>  Avec l'assistance Google, nous avons pu déterminer la séquence des événements qui ont conduit à l'échec: <br><br><ol><li>  GKE a terminé la mise à niveau sur une instance de l'assistant et a commencé à accepter tout le trafic vers le serveur API sur celui-ci lors de la mise à jour des assistants suivants. </li><li>  Lors de la mise à niveau de la deuxième instance de l'assistant, le serveur API n'a pas pu exécuter <a href="">PostStartHook</a> pour <a href="">enregistrer l'autorité de certification.</a> </li><li>  Pendant l'exécution de ce hook, le serveur API a essayé de mettre à jour ConfigMap appelé <code>extension-apiserver-authentication</code> dans <code>kube-system</code> .  Cela n'a pas été possible car le backend pour le webhook de vérification de l'Open Policy Agent (OPA) que nous avons configuré n'a pas répondu. </li><li>  Pour que l'assistant réussisse un contrôle d'intégrité, cette opération doit aboutir.  Comme cela ne s'est pas produit, le deuxième maître est entré dans le cycle d'urgence et a arrêté la mise à jour. </li></ol><br>  Le résultat a été des plantages d'API périodiques, en raison desquels les kubelets n'ont pas pu signaler la santé du nœud.  À son tour, cela a conduit au fait que le mécanisme de restauration automatique des nœuds GKE <i>(réparation</i> automatique des nœuds <i>) a</i> commencé à redémarrer les nœuds.  Cette fonctionnalité est décrite en détail dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> : <br><br><blockquote>  <i>Un état malsain peut signifier: dans un délai donné (environ 10 minutes), le nœud ne donne aucun état.</i> </blockquote><br><h3>  Solution </h3><br>  Lorsque nous avons découvert que la ressource <code>ValidatingAdmissionWebhook</code> provoquait un accès intermittent au serveur API, nous l'avons supprimé et restauré le cluster pour fonctionner. <br><br>  Depuis lors, le <code>ValidatingAdmissionWebhook</code> pour OPA a été configuré pour surveiller uniquement les espaces de noms où la stratégie est applicable et auxquels les équipes de développement ont accès.  Nous avons également limité le webhook à <code>Ingress</code> and <code>Service</code> , les seuls avec lesquels notre politique fonctionne. <br><br>  Depuis le premier déploiement de l'OPA, la documentation a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">été mise</a> à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jour</a> pour refléter ce changement. <br><br>  Nous avons également ajouté un test de vivacité pour nous assurer que l'OPA redémarre en cas d'indisponibilité (et apporté <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les modifications appropriées</a> à la documentation). <br><br>  Nous avons également envisagé de désactiver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le mécanisme de</a> récupération automatique pour les nœuds GKE, mais nous avons tout de même décidé d'abandonner cette idée. <br><br><h3>  Résumé </h3><br>  Si nous activions les alertes de temps de réponse du serveur API, nous serions initialement en mesure de constater son augmentation globale pour toutes les demandes <code>CREATE</code> et <code>UPDATE</code> après le déploiement du webhook pour OPA. <br><br>  Cela souligne l'importance de mettre en place des tests pour toutes les charges de travail.  Avec le recul, nous pouvons dire que le déploiement de l'OPA était si trompeusement simple que nous ne nous sommes même pas impliqués dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">diagramme de Helm</a> (bien qu'il le devrait).  Le tableau fait un certain nombre d'ajustements au-delà des paramètres de base décrits dans le manuel, y compris le paramètre livenessProbe pour les conteneurs avec un contrôleur d'admission. <br><br>  Nous n'avons pas été les premiers à rencontrer ce problème: le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">problème en amont</a> reste ouvert.  La fonctionnalité dans ce domaine peut clairement être améliorée (et nous ferons un suivi à ce sujet). <br><br><h2>  PS du traducteur </h2><br>  Lisez aussi dans notre blog: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment les priorités des pods chez Kubernetes ont causé des temps d'arrêt chez Grafana Labs</a> ;" </li><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">De la vie avec Kubernetes: comment les Espagnols ne se sont pas plaints du serveur HTTP</a> »; </li><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">6 bugs système divertissants dans le fonctionnement de Kubernetes [et leur solution]</a> »; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">6 histoires pratiques de notre vie quotidienne SRE</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr475026/">https://habr.com/ru/post/fr475026/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr475016/index.html">QA mitap à Redmadrobot le 22 novembre</a></li>
<li><a href="../fr475018/index.html">Modification des colonnes Radiotehnika S-30</a></li>
<li><a href="../fr475020/index.html">Comment la technologie moderne remplace progressivement les tours d'incendie</a></li>
<li><a href="../fr475022/index.html">Schizophrénie architecturale Facebook Balance</a></li>
<li><a href="../fr475024/index.html">La course à pied est un sport idéal pour un travailleur à distance. Partie 1: le chemin vers la première course d'une centaine de kilomètres</a></li>
<li><a href="../fr475028/index.html">Observations sur l'application du ML en affaires sur les actions ŽijemeIT</a></li>
<li><a href="../fr475032/index.html">Gartner Hype Cycle 2019: débriefing</a></li>
<li><a href="../fr475034/index.html">Graphique dans le navigateur pour Arduino et STM32</a></li>
<li><a href="../fr475036/index.html">Migration de Cassandra vers Kubernetes: fonctionnalités et solutions</a></li>
<li><a href="../fr475038/index.html">La première série de "Mathématiques appliquées et informatique" au HSE de Saint-Pétersbourg: qui sont-ils et comment travailler avec eux?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>