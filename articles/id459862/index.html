<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤ŸğŸ½ ğŸ‘ğŸ½ ğŸ“® Antarmuka Berkeley DB STL â™£ï¸ ğŸ‰ ğŸ‘¶ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai, Habr. Belum lama ini, untuk salah satu proyek saya, saya membutuhkan database tertanam yang akan menyimpan elemen nilai kunci, memberikan dukunga...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Antarmuka Berkeley DB STL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459862/"><p>  Hai, Habr.  Belum lama ini, untuk salah satu proyek saya, saya membutuhkan database tertanam yang akan menyimpan elemen nilai kunci, memberikan dukungan transaksi, dan, opsional, data terenkripsi.  Setelah pencarian singkat, saya menemukan proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berkeley DB</a> .  Selain fitur yang saya butuhkan, database ini menyediakan antarmuka yang kompatibel dengan STL yang memungkinkan Anda untuk bekerja dengan database seperti dengan wadah STL biasa (hampir biasa).  Sebenarnya, antarmuka ini akan dibahas di bawah ini. </p><a name="habracut"></a><br><h2 id="berkeley-db">  Berkeley db </h2><br><p>  <strong>Berkeley DB</strong> adalah database open source yang tertanam, dapat diukur, berkinerja tinggi, dan tinggi.  Ini tersedia secara gratis untuk digunakan dalam proyek-proyek <strong>sumber terbuka</strong> , tetapi untuk proyek-proyek eksklusif ada batasan yang signifikan.  Fitur yang didukung: </p><br><ul><li>  transaksi </li><li>  log gagal-depan untuk failover </li><li>  <strong>Enkripsi</strong> data <strong>AES</strong> </li><li>  replikasi </li><li>  indeks </li><li>  alat sinkronisasi untuk aplikasi multithreaded </li><li>  kebijakan akses - satu penulis, banyak pembaca </li><li>  caching </li></ul><br><p>  Serta banyak lainnya. </p><br><p>  Ketika sistem diinisialisasi, pengguna dapat menentukan subsistem mana yang akan digunakan.  Ini menghilangkan pemborosan sumber daya pada operasi seperti transaksi, logging, mengunci ketika mereka tidak diperlukan. </p><br><p>  Pilihan struktur penyimpanan dan akses data tersedia: </p><br><ul><li>  <strong>Btree</strong> - implementasi pohon seimbang yang disortir </li><li>  Implementasi hash - linear hash </li><li>  <strong>Heap</strong> - menggunakan <em>file heap</em> paged secara logis untuk penyimpanan.  Setiap entri diidentifikasi oleh halaman dan offset di dalamnya.  Penyimpanan diatur sedemikian rupa sehingga menghapus catatan tidak membutuhkan pemadatan.  Ini memungkinkan Anda untuk menggunakannya dengan kekurangan ruang fisik. </li><li>  <strong>Antrian</strong> - antrian yang menyimpan catatan panjang tetap dengan nomor logis sebagai kunci.  Ini dirancang untuk penyisipan cepat di akhir, dan mendukung operasi khusus yang menghapus dan mengembalikan entri dari kepala antrian dalam satu panggilan. </li><li>  <strong>Recno</strong> - memungkinkan Anda untuk menyimpan catatan panjang tetap dan variabel dengan nomor logis sebagai kunci.  Menyediakan akses ke elemen dengan indeksnya. </li></ul><br><p>  Untuk menghindari ambiguitas, perlu untuk mendefinisikan beberapa konsep yang digunakan untuk menggambarkan karya <strong>Berkeley DB</strong> . </p><br><p>  <em>Basis data adalah</em> penyimpanan <em>data</em> nilai-kunci.  Analog database <strong>Berkeley DB</strong> di DBMS lain bisa berupa tabel. </p><br><p>  <em>Lingkungan basis data</em> adalah pembungkus untuk satu atau lebih <em>basis data</em> .  Menentukan pengaturan umum untuk semua <em>basis data</em> , seperti ukuran cache, jalur penyimpanan file, penggunaan dan konfigurasi pemblokiran, transaksi, pencatatan subsistem. </p><br><p>  Dalam kasus penggunaan umum, suatu <em>lingkungan</em> dibuat dan dikonfigurasikan, dan memiliki satu atau lebih <em>basis data</em> . </p><br><h2 id="stl-interfeys">  Antarmuka STL </h2><br><p>  <strong>Berkeley DB</strong> adalah perpustakaan yang ditulis dalam <strong>C.</strong>  Ini memiliki pengikat untuk bahasa seperti <strong>Perl</strong> , <strong>Java</strong> , <strong>PHP</strong> dan lainnya.  Antarmuka untuk <strong>C ++</strong> adalah pembungkus kode <strong>C</strong> dengan objek dan warisan.  Untuk memungkinkannya mengakses basis data yang mirip dengan operasi dengan wadah <strong>STL</strong> , ada antarmuka <strong>STL</strong> sebagai tambahan pada <strong>C ++</strong> .  Dalam bentuk grafis, lapisan antarmuka terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/webt/k9/0u/gw/k90ugwajcb5xsts9zxn7e6urjew.png"></p><br><p> Jadi, antarmuka <strong>STL</strong> memungkinkan Anda untuk mendapatkan elemen dari database dengan kunci (untuk <strong>Btree</strong> atau <strong>Hash</strong> ) atau dengan indeks (untuk <strong>Recno</strong> ) mirip dengan <code>std::map</code> atau <code>std::vector</code> wadah <code>std::vector</code> , temukan elemen dalam database melalui standar <code>std::find_if</code> , beralih ke seluruh database melalui <code>foreach</code> .  Semua kelas dan fungsi antarmuka <strong>Berkeley DB</strong> <strong>STL</strong> berada dalam ruang nama <strong>dbstl</strong> , singkatnya, <strong>dbstl</strong> juga berarti antarmuka <strong>STL</strong> . </p><br><h2 id="ustanovka">  Instalasi </h2><br><p>  Basis data mendukung sebagian besar <strong>platform</strong> <strong>Linux</strong> , <strong>Windows</strong> , <strong>Android</strong> , <strong>Apple iOS</strong> , dll. </p><br><p>  Untuk <strong>Ubuntu 18.04,</strong> cukup instal paket: </p><br><ul><li>  libdb5.3-stl-dev </li><li>  libdb5.3 ++ - dev </li></ul><br><p>  Untuk membangun dari sumber <strong>Linux</strong> , Anda perlu menginstal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">autoconf</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">libtool</a> .  Kode sumber terbaru dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p>  Misalnya, saya mengunduh arsip dengan versi <strong>18.1.32</strong> - db-18.1.32.zip.  Anda perlu membuka zip arsip dan pergi ke folder sumber: </p><br><pre> <code class="plaintext hljs">unzip db-18.1.32.zip cd db-18.1.32</code> </pre> <br><p>  Selanjutnya, kita pindah ke direktori <strong>build_unix</strong> dan menjalankan perakitan dan instalasi: </p><br><pre> <code class="plaintext hljs">cd build_unix ../dist/configure --enable-stl --prefix=/home/user/libraries/berkeley-db make make install</code> </pre> <br><h2 id="dobavlenie-v-cmake-proekt">  Menambahkan ke proyek cmake </h2><br><p>  Proyek <strong>BerkeleyDBSamples</strong> digunakan untuk menggambarkan contoh dengan <strong>Berkeley DB</strong> . </p><br><p>  Struktur proyek adalah sebagai berikut: </p><br><pre> <code class="plaintext hljs">+-- CMakeLists.txt +-- sample-usage | +-- CMakeLists.txt | +-- sample-map-usage.cpp | +-- submodules | +-- cmake | | +-- FindBerkeleyDB</code> </pre> <br><p>  Root <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CMakeLists.txt</a> menjelaskan parameter umum proyek.  File sumber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sampel</a> dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penggunaan sampel</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sample-usage / CMakeLists.txt</a> mencari pustaka, menentukan kumpulan contoh. </p><br><p>  Dalam contoh, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FindBerkeleyDB</a> digunakan untuk menghubungkan perpustakaan ke proyek <strong>cmake</strong> .  Itu ditambahkan sebagai <strong>git</strong> submodule di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">submodules / cmake</a> .  Selama perakitan, Anda mungkin perlu menentukan <code>BerkeleyDB_ROOT_DIR</code> .  Misalnya, untuk pustaka di atas yang diinstal dari sumber, Anda harus menentukan flag <strong>cmake</strong> <code>-DBerkeleyDB_ROOT_DIR=/home/user/libraries/berkeley-db</code> . </p><br><p>  Di file root <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CMakeLists.txt</a> , tambahkan path ke modul <strong>FindBerkeleyDB</strong> ke <strong>CMAKE_MODULE_PATH</strong> : </p><br><pre> <code class="plaintext hljs">list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/submodules/cmake/FindBerkeleyDB")</code> </pre> <br><p>  Setelah itu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sample-use / CMakeLists.txt</a> melakukan pencarian pustaka dengan cara standar: </p><br><pre> <code class="plaintext hljs">find_package(BerkeleyDB REQUIRED)</code> </pre> <br><p>  Selanjutnya, tambahkan file yang dapat dieksekusi dan tautkan ke perpustakaan <strong>Oracle :: BerkeleyDB</strong> : </p><br><pre> <code class="plaintext hljs">add_executable(sample-map-usage "sample-map-usage.cpp") target_link_libraries(sample-map-usage PRIVATE Oracle::BerkeleyDB ${CMAKE_THREAD_LIBS_INIT} stdc++fs)</code> </pre> <br><h2 id="prakticheskiy-primer">  Contoh praktis </h2><br><p>  Untuk menunjukkan penggunaan <strong>dbstl, mari kita</strong> periksa contoh sederhana dari file <a href="">sample-map-use.cpp</a> .  Aplikasi ini menunjukkan bekerja dengan <code>dbstl::db_map</code> dalam program berulir tunggal.  Wadah itu sendiri mirip dengan <code>std::map</code> dan menyimpan data sebagai pasangan kunci / nilai.  Struktur basis data yang mendasarinya bisa <strong>Btree</strong> atau <strong>Hash</strong> .  Tidak seperti <code>std::map</code> , untuk <code>dbstl::db_map&lt;std::string, TestElement&gt;</code> tipe nilai aktualnya adalah <code>dbstl::ElementRef&lt;TestElement&gt;</code> .  Jenis ini dikembalikan, misalnya, untuk <code>dbstl::db_map&lt;std::string, TestElement&gt;::operator[]</code> .  Ini mendefinisikan metode untuk menyimpan objek tipe <code>TestElement</code> dalam database.  Salah satu metode tersebut adalah <code>operator=</code> . </p><br><p>  Dalam contoh, bekerja dengan database adalah sebagai berikut: </p><br><ul><li>  aplikasi memanggil metode <strong>Berkeley DB</strong> untuk mengakses data </li><li>  metode ini mengakses cache untuk membaca atau menulis </li><li>  jika perlu, akses langsung ke file data </li></ul><br><p>  Secara grafis, proses ini ditunjukkan pada gambar: </p><br><p><img src="https://habrastorage.org/webt/xm/em/or/xmemorwh73yw9mnue-h1lp0gmbo.png"></p><br><p>  Untuk mengurangi kompleksitas contoh, itu tidak menggunakan penanganan pengecualian.  Beberapa <strong>metode</strong> wadah <strong>dbstl</strong> dapat melempar pengecualian ketika kesalahan terjadi. </p><br><h2 id="razbor-koda">  Penguraian kode </h2><br><p>  Untuk bekerja dengan <strong>Berkeley DB,</strong> Anda harus menghubungkan dua file header: </p><br><pre> <code class="plaintext hljs">#include &lt;db_cxx.h&gt; #include &lt;dbstl_map.h&gt;</code> </pre> <br><p>  Yang pertama menambahkan primitif antarmuka <strong>C ++</strong> , dan yang kedua mendefinisikan kelas dan fungsi untuk bekerja dengan database, seperti dengan wadah asosiatif, serta banyak metode utilitas.  Antarmuka <strong>STL</strong> terletak di namespace <strong>dbstl</strong> . </p><br><p>  Untuk penyimpanan, struktur <strong>Btree digunakan</strong> , <code>std::string</code> bertindak sebagai kunci, dan nilainya adalah struktur pengguna <code>TestElement</code> : </p><br><pre> <code class="plaintext hljs">struct TestElement{ std::string id; std::string name; };</code> </pre> <br><p>  Dalam fungsi <code>main</code> , inisialisasi pustaka dengan memanggil <code>dbstl::dbstl_startup()</code> .  Itu harus ditempatkan sebelum penggunaan pertama primitif dari antarmuka <strong>STL</strong> . </p><br><p>  Setelah itu, kami menginisialisasi dan membuka <em>lingkungan basis data</em> di direktori yang ditetapkan oleh variabel <code>ENV_FOLDER</code> : </p><br><pre> <code class="plaintext hljs">auto penv = dbstl::open_env(ENV_FOLDER, 0u, DB_INIT_MPOOL | DB_CREATE);</code> </pre> <br><p>  Bendera <code>DB_INIT_MPOOL</code> bertanggung jawab untuk menginisialisasi subsistem caching, <code>DB_CREATE</code> - untuk membuat semua file yang diperlukan untuk lingkungan.  Tim juga mendaftarkan objek ini di manajer sumber daya.  Ia bertanggung jawab untuk menutup semua objek terdaftar (objek database, kursor, transaksi, dll. Juga terdaftar di dalamnya) dan membersihkan memori dinamis.  Jika Anda sudah memiliki objek <em>lingkungan database</em> dan Anda hanya perlu mendaftarkannya dengan manajer sumber daya, Anda dapat menggunakan fungsi <code>dbstl::register_db_env</code> . </p><br><p>  Operasi serupa dilakukan dengan <em>database</em> : </p><br><pre> <code class="plaintext hljs">auto db = dbstl::open_db(penv, "sample-map-usage.db", DB_BTREE, DB_CREATE, 0u);</code> </pre> <br><p>  Data pada disk akan ditulis ke file <strong>sample-map-use.db</strong> , yang akan dibuat jika tidak ada (berkat flag <code>DB_CREATE</code> ) di direktori <code>ENV_FOLDER</code> .  Pohon digunakan untuk penyimpanan (parameter <code>DB_BTREE</code> ). </p><br><p>  Di <strong>Berkeley DB,</strong> kunci dan nilai disimpan sebagai array byte.  Untuk menggunakan jenis khusus (dalam <code>TestElement</code> kasus kami), Anda harus menetapkan fungsi untuk: </p><br><ul><li>  menerima jumlah byte untuk menyimpan objek; </li><li>  marshaling suatu objek menjadi array byte; </li><li>  unmarshaling. </li></ul><br><p>  Dalam contoh ini, fungsi ini dilakukan oleh metode statis dari kelas <code>TestMarshaller</code> .  Ini <code>TestElement</code> objek <code>TestElement</code> dalam memori sebagai berikut: </p><br><ul><li>  panjang bidang <code>id</code> disalin ke awal buffer </li><li>  byte berikutnya isi kolom <code>id</code> ditempatkan </li><li>  setelah itu, ukuran bidang <code>name</code> disalin </li><li>  maka konten itu sendiri ditempatkan dari bidang <code>name</code> </li></ul><br><p><img src="https://habrastorage.org/webt/ko/ad/ul/koaduleknjbnfvapxlo6wff4qvm.png"></p><br><p>  Kami menjelaskan fungsi <code>TestMarshaller</code> : </p><br><ul><li>  <code>TestMarshaller::restore</code> - mengisi objek <code>TestElement</code> dengan data dari buffer </li><li>  <code>TestMarshaller::size</code> - mengembalikan ukuran buffer yang diperlukan untuk menyimpan objek yang ditentukan. </li><li>  <code>TestMarshaller::store</code> - menyimpan objek di buffer. </li></ul><br><p>  Untuk mendaftarkan fungsi marshaling / <code>dbstl::DbstlElemTraits</code> , gunakan <code>dbstl::DbstlElemTraits</code> : </p><br><pre> <code class="plaintext hljs">dbstl::DbstlElemTraits&lt;TestElement&gt;::instance()-&gt;set_size_function(&amp;TestMarshaller::size); dbstl::DbstlElemTraits&lt;TestElement&gt;::instance()-&gt;set_copy_function(&amp;TestMarshaller::store); dbstl::DbstlElemTraits&lt;TestElement&gt;::instance()-&gt;set_restore_function( &amp;TestMarshaller::restore );</code> </pre> <br><p>  Inisialisasi wadah: </p><br><pre> <code class="plaintext hljs">dbstl::db_map&lt;std::string, TestElement&gt; elementsMap(db, penv);</code> </pre> <br><p>  Beginilah cara menyalin elemen dari <code>std::map</code> ke wadah yang dibuat terlihat seperti: </p><br><pre> <code class="plaintext hljs">std::copy( std::cbegin(inputValues), std::cend(inputValues), std::inserter(elementsMap, elementsMap.begin()) );</code> </pre> <br><p>  Tetapi dengan cara ini Anda dapat mencetak isi database ke output standar: </p><br><pre> <code class="plaintext hljs">std::transform( elementsMap.begin(dbstl::ReadModifyWriteOption::no_read_modify_write(), true), elementsMap.end(), std::ostream_iterator&lt;std::string&gt;(std::cout, "\n"), [](const auto data) -&gt; std::string { return data.first + "=&gt; { id: " + data.second.id + ", name: " + data.second.name + "}"; });</code> </pre> <br><p>  Memanggil metode <code>begin</code> pada contoh di atas terlihat sedikit tidak biasa: <code>elementsMap.begin(dbstl::ReadModifyWriteOption::no_read_modify_write(), true)</code> . <br>  Desain ini digunakan untuk mendapatkan iterator <em>read-only</em> .  <strong>dbstl</strong> tidak mendefinisikan metode <code>cbegin</code> , melainkan parameter <code>readonly</code> (yang kedua) dalam metode <code>begin</code> digunakan.  Anda juga dapat menggunakan <em>referensi konstan</em> ke wadah untuk mendapatkan iterator <em>read-only</em> .  Iterator semacam itu hanya memungkinkan operasi membaca, saat menulis, itu akan membuang pengecualian. </p><br><p>  Mengapa iterator <em>read-only</em> digunakan dalam kode di atas?  Pertama, ia <em>hanya</em> melakukan operasi baca melalui iterator.  Kedua, dokumentasi mengatakan bahwa ia memiliki kinerja yang <em>lebih</em> baik dibandingkan dengan versi reguler. </p><br><p>  Menambahkan pasangan kunci / nilai baru, atau, jika kunci sudah ada, memperbarui nilai sesederhana di <code>std::map</code> : </p><br><pre> <code class="plaintext hljs">elementsMap["added key 1"] = {"added id 1", "added name 1"};</code> </pre> <br><p>  Seperti disebutkan di atas, instruksi elementMap <code>elementsMap["added key 1"]</code> mengembalikan kelas pembungkus dengan <code>operator=</code> didefinisikan ulang, panggilan selanjutnya yang langsung menyimpan objek dalam database. </p><br><p>  Jika Anda perlu memasukkan item ke dalam wadah: </p><br><pre> <code class="plaintext hljs">auto [iter, res] = elementsMap.insert( std::make_pair(std::string("added key 2"), TestElement{"added id 2", "added name 2"}) );</code> </pre> <br><p>  Panggilan ke <code>elementsMap.insert</code> mengembalikan <code>std::pair&lt;,  &gt;</code> .  Jika objek tidak dapat dimasukkan, <em>bendera sukses</em> akan <strong>salah</strong> .  Jika tidak, <em>flag sukses</em> berisi <strong>true</strong> , dan <em>iterator</em> menunjuk ke objek yang dimasukkan. </p><br><p>  Cara lain untuk menemukan nilai dengan kunci adalah dengan menggunakan metode <code>dbstl::db_map::find</code> , mirip dengan <code>std::map::find</code> : </p><br><pre> <code class="plaintext hljs">auto findIter = elementsMap.find("test key 1");</code> </pre> <br><p>  Melalui iterator yang diperoleh, Anda dapat mengakses kunci - <code>findIter-&gt;first</code> , ke bidang elemen <code>findIter-&gt;second.id</code> - <code>findIter-&gt;second.id</code> dan <code>findIter-&gt;second.name</code> .  Untuk mengekstrak pasangan <em>kunci</em> / <em>nilai</em> , operator dereference digunakan - <code>auto iterPair = *findIter;</code>  . </p><br><p>  Ketika operator dereferencing ( <strong>*</strong> ) atau akses ke anggota kelas ( <strong>-&gt;</strong> ) diterapkan ke iterator, database diakses dan data diekstraksi darinya.  Selain itu, data yang diekstraksi sebelumnya, bahkan jika mereka diubah, dihapus.  Ini berarti bahwa dalam contoh di bawah ini, perubahan yang dilakukan pada iterator akan dibuang, dan nilai yang disimpan dalam database akan ditampilkan pada konsol. </p><br><pre> <code class="plaintext hljs">findIter-&gt;second.id = "skipped id"; findIter-&gt;second.name = "skipped name"; std::cout &lt;&lt; "Found elem for key " &lt;&lt; "test key 1" &lt;&lt; ": id: " &lt;&lt; findIter-&gt;second.id &lt;&lt; ", name: " &lt;&lt; findIter-&gt;second.name &lt;&lt; std::endl;</code> </pre> <br><p>  Untuk menghindari ini, Anda perlu mendapatkan pembungkus objek yang disimpan dari iterator dengan memanggil <code>findIter-&gt;second</code> dan menyimpannya dalam variabel.  Selanjutnya, buat semua perubahan pada pembungkus ini, dan tulis hasilnya ke database dengan memanggil metode pembungkus <code>_DB_STL_StoreElement</code> : </p><br><pre> <code class="plaintext hljs">auto ref = findIter-&gt;second; ref.id = "new test id 1"; ref.name = "new test name 1"; ref._DB_STL_StoreElement();</code> </pre> <br><p>  Memperbarui data bisa lebih mudah - dapatkan pembungkusnya dengan instruksi <code>findIter-&gt;second</code> dan tetapkan objek <code>TestElement</code> diinginkan, seperti dalam contoh: </p><br><pre> <code class="plaintext hljs">if(auto findIter = elementsMap.find("test key 2"); findIter != elementsMap.end()){ findIter-&gt;second = {"new test id 2", "new test name 2"}; }</code> </pre> <br><p>  Sebelum mengakhiri program, Anda harus memanggil <code>dbstl::dbstl_exit();</code>  untuk menutup dan menghapus semua objek yang terdaftar di manajer sumber daya. </p><br><h2 id="v-zaklyuchenii">  Kesimpulannya </h2><br><p>  Artikel ini memberikan ikhtisar singkat tentang fitur utama wadah <code>dbstl::db_map</code> <strong>menggunakan</strong> <code>dbstl::db_map</code> sebagai <code>dbstl::db_map</code> dalam program berulir tunggal sederhana.  Ini hanya perkenalan kecil dan belum mencakup fitur-fitur seperti transaksionalitas, penguncian, manajemen sumber daya, penanganan pengecualian, dan eksekusi multithread. </p><br><p>  Saya tidak bermaksud menjelaskan secara rinci metode dan parameternya, untuk ini lebih baik merujuk ke dokumentasi yang sesuai pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">antarmuka C ++</a> dan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">antarmuka STL</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459862/">https://habr.com/ru/post/id459862/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459844/index.html">Penguin di jendela: tentang potensi dan prospek WSL2</a></li>
<li><a href="../id459850/index.html">Teknologi radio amatir: bagaimana saya memesan pemasangan papan sirkuit tercetak di pabrik Cina</a></li>
<li><a href="../id459852/index.html">Praktek menggunakan perpustakaan lottie di aplikasi seluler bank</a></li>
<li><a href="../id459858/index.html">Menjelajahi Modern Malware Cerberus untuk Android</a></li>
<li><a href="../id459860/index.html">Mengkonfigurasi ClickHouse untuk pengujian integrasi di gitlab-ci</a></li>
<li><a href="../id459866/index.html">Pemecahan masalah dengan pwnable.kr 02 - collision. Tabrakan Hash</a></li>
<li><a href="../id459870/index.html">Contoh arsitektur Model-View-Update dalam F #</a></li>
<li><a href="../id459872/index.html">Patton Jeff. Cerita khusus. Seni pengembangan perangkat lunak tangkas</a></li>
<li><a href="../id459874/index.html">Anda memiliki sesuatu yang disembunyikan</a></li>
<li><a href="../id459878/index.html">7 tips pengoptimalan CSS untuk mempercepat pemuatan halaman</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>