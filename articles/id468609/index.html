<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘ƒğŸ» ğŸ¤š ğŸ© Performa penjadwalan berganda yang sulit dipahami ğŸ‰‘ ğŸ“ ğŸ™‡ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di bawah cutscene, dekripsi laporan oleh Stefan Karpinsky, salah satu pengembang utama bahasa Julia, diusulkan. Dalam laporan itu, ia membahas hasil t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Performa penjadwalan berganda yang sulit dipahami</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468609/"><p>  Di bawah cutscene, dekripsi laporan oleh Stefan Karpinsky, salah satu pengembang utama bahasa Julia, diusulkan.  Dalam laporan itu, ia membahas hasil tak terduga dari pengiriman ganda yang nyaman dan efisien, diambil sebagai paradigma utama Julia. </p><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/kc9HwsxE1OY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <em>Dari seorang penerjemah</em> : judul laporan merujuk pada sebuah artikel oleh Eugene Wigner, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Efektivitas Matematika yang Tidak Terbandingkan dalam Ilmu Pengetahuan Alam</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"</a> </p><br><p> Penjadwalan ganda adalah paradigma kunci dari bahasa Julia, dan selama keberadaannya, kami, para pengembang bahasa, memperhatikan sesuatu yang diharapkan, tetapi pada saat yang sama membingungkan.  Setidaknya kita tidak mengharapkan ini sejauh kita melihatnya.  Ini adalah sesuatu - tingkat penggunaan kembali kode yang mengejutkan di ekosistem Julia, yang jauh lebih tinggi daripada bahasa lain yang saya tahu. </p><br><p>  Kami terus-menerus melihat bahwa beberapa orang menulis kode umum, orang lain mendefinisikan tipe data baru, orang-orang ini tidak mengenal satu sama lain, dan kemudian seseorang menerapkan kode ini ke tipe data yang tidak biasa ini ... Dan semuanya hanya berfungsi.  Dan ini <em>sering</em> terjadi secara <em>mengejutkan</em> . <br>  Saya selalu berpikir bahwa perilaku tersebut harus diharapkan dari pemrograman berorientasi objek, tapi aku menikmati banyak bahasa berorientasi objek, dan ternyata mereka biasanya sangat sederhana tidak bekerja.  Karena itu, pada titik tertentu saya berpikir: mengapa Julia menjadi bahasa yang begitu efektif dalam hal ini?  Mengapa level penggunaan kembali kode begitu tinggi di sana?  Dan juga - pelajaran apa yang bisa dipetik dari ini yang bisa dipinjam oleh bahasa lain dari Julia agar menjadi lebih baik? </p><br><p>  Kadang-kadang, ketika saya mengatakan bahwa masyarakat tidak percaya, tapi Anda harus JuliaCon, sehingga Anda tahu apa yang terjadi, jadi saya akan fokus pada mengapa, dalam pandangan saya, hal ini terjadi. </p><br><p>  Tetapi sebagai permulaan - salah satu contoh favorit saya. </p><br><p><img src="https://habrastorage.org/webt/mv/o0/i8/mvo0i8xjflhnxxuurnshmsfolbi.png"></p><br><p> Pada slide adalah hasil karya Chris Rakaukas.  Dia menulis semua jenis paket yang <em>sangat umum</em> untuk menyelesaikan persamaan diferensial.  Anda dapat memberi makan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">nomor ganda</a> , atau BigFloat, apa pun yang Anda inginkan.  Dan entah bagaimana dia memutuskan bahwa dia ingin melihat kesalahan hasil integrasi.  Dan ada paket Pengukuran yang dapat melacak nilai kuantitas fisik dan propagasi kesalahan melalui urutan formula.  Paket ini juga mendukung sintaks elegan untuk nilai ketidakpastian menggunakan karakter Unicode <code>Â±</code> .  Di sini pada slide ditunjukkan bahwa percepatan gravitasi, panjang pendulum, kecepatan awal, sudut penyimpangan semua diketahui dengan beberapa jenis kesalahan.  Jadi, Anda mendefinisikan pendulum sederhana, lulus persamaan gerak melalui pemecah ODE dan - <strong>bam!</strong>  - <em>semuanya berfungsi</em> .  Dan Anda melihat grafik dengan ketidakakuratan kumis.  Dan saya masih tidak menunjukkan bahwa kode untuk menggambar grafik juga digeneralisasi, dan Anda hanya memasukkan nilai dengan kesalahan dari Measurements.jl dan mendapatkan grafik dengan kesalahan. </p><br><p>  Tingkat kompatibilitas paket-paket yang berbeda dan generalisasi dari kode itu hanya menyita pikiran.  <em>Bagaimana cara <strong>kerjanya</strong> ?</em>  Ternyata iya. </p><br><p>  Yah, bukannya kita tidak mengharapkan ini sama sekali.  Bagaimanapun, kami memasukkan konsep pengiriman ganda dalam bahasa <em>justru</em> karena itu memungkinkan kami untuk mengekspresikan algoritma umum.  Jadi semua hal di atas tidak terlalu gila.  Tetapi satu hal untuk mengetahui hal ini dalam teori, dan hal lain untuk dilihat dalam praktik bahwa pendekatan tersebut benar-benar berfungsi.  Setelah semua, pengiriman tunggal dan kelebihan operator di C ++ juga harus memberikan hasil yang serupa - tetapi pada kenyataannya mereka sering tidak bekerja seperti yang mereka inginkan. </p><br><p>  Selain itu, kami menyaksikan sesuatu yang lebih dari yang kami perkirakan saat mengembangkan bahasa: bukan hanya kode umum yang sedang ditulis.  Selanjutnya, saya akan mencoba mengatakan apa, menurut saya, ini lebih. </p><br><p>  Jadi, ada dua jenis penggunaan kembali kode, dan mereka sangat berbeda.  Salah satunya adalah algoritma umum, dan ini adalah hal pertama yang mereka ingat.  Aspek kedua, kurang jelas, tetapi tampaknya lebih penting adalah kesederhanaan yang digunakan Julia untuk tipe data yang sama dalam berbagai paket.  Untuk beberapa hal, ini terjadi karena metode tipe tidak menjadi penghambat untuk penggunaannya: Anda tidak perlu setuju dengan penulis tipe tentang antarmuka dan metode yang diwarisi;  Anda bisa mengatakan: "Oh, saya suka jenis RGB ini. Saya akan membuat sendiri operasi di atasnya, tapi saya suka strukturnya." </p><br><h3 id="predislovie-mnozhestvennaya-dispetcherizaciya-protiv-peregruzki-funkciy">  Kata Pengantar  Penjadwalan berganda versus fungsi yang berlebihan </h3><br><p>  Sekarang saya harus menyebutkan fungsi overloading di C ++ atau Java, karena saya terus bertanya tentang mereka.  Sepintas, tidak ada bedanya dengan penjadwalan berganda.  Apa perbedaannya dan mengapa kelebihan fungsi lebih buruk? </p><br><p>  Saya akan mulai dengan contoh pada Julia: </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract type</span></span> Pet <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Dog &lt;: Pet; name::<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Cat &lt;: Pet; name::<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> encounter(a::Pet, b::Pet) verb = meets(a, b) println(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$(a.name)</span></span></span><span class="hljs-string"> meets </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$(b.name)</span></span></span><span class="hljs-string"> and </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$verb</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> meets(a::Dog, b::Dog) = <span class="hljs-string"><span class="hljs-string">"sniffs"</span></span> meets(a::Dog, b::Cat) = <span class="hljs-string"><span class="hljs-string">"chases"</span></span> meets(a::Cat, b::Dog) = <span class="hljs-string"><span class="hljs-string">"hisses"</span></span> meets(a::Cat, b::Cat) = <span class="hljs-string"><span class="hljs-string">"slinks"</span></span></code> </pre> <br><p>  Kami mendefinisikan tipe abstrak <code>Pet</code> , mengenalkan subtipe <code>Dog</code> dan <code>Cat</code> untuknya, mereka memiliki bidang nama (kode sedikit berulang, tetapi dapat ditoleransi) dan mendefinisikan fungsi umum "pertemuan" yang mengambil dua objek bertipe <code>Pet</code> argumen.  Di dalamnya, pertama-tama kita menghitung "tindakan" yang ditentukan oleh hasil memanggil fungsi generalisasi <code>meet()</code> , dan kemudian mencetak kalimat yang menggambarkan pertemuan tersebut.  Dalam fungsi <code>meets()</code> , kami menggunakan beberapa pengiriman untuk menentukan tindakan yang dilakukan satu hewan ketika bertemu lainnya. </p><br><p>  Tambahkan beberapa anjing dan beberapa kucing dan lihat hasil pertemuan: </p><br><pre> <code class="julia hljs">fido = Dog(<span class="hljs-string"><span class="hljs-string">"Fido"</span></span>) rex = Dog(<span class="hljs-string"><span class="hljs-string">"Rex"</span></span>) whiskers = Cat(<span class="hljs-string"><span class="hljs-string">"Whiskers"</span></span>) spots = Cat(<span class="hljs-string"><span class="hljs-string">"Spots"</span></span>) encounter(fido, rex) encounter(rex, whiskers) encounter(spots, fido) encounter(whiskers, spots)</code> </pre> <br><p>  Sekarang kita akan "menerjemahkan" hal yang sama ke dalam C ++ sejelas mungkin.  Kami mendefinisikan kelas <code>Pet</code> dengan bidang <code>name</code> - dalam C ++ kita dapat melakukan ini (omong-omong, salah satu keuntungan dari C ++ adalah bahwa bidang data bahkan dapat ditambahkan ke tipe abstrak. Kemudian kita mendefinisikan basis <code>meets()</code> fungsi, menentukan fungsi <code>encounter()</code> fungsi untuk dua objek dari tipe <code>Pet</code> dan, akhirnya, tentukan kelas turunan <code>Dog</code> and <code>Cat</code> dan lakukan overload <code>meets()</code> untuk mereka: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pet</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name; }; <span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">meets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Pet a, Pet b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"FALLBACK"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encounter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Pet a, Pet b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> verb = meets(a, b); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; a.name &lt;&lt; <span class="hljs-string"><span class="hljs-string">" meets "</span></span> &lt;&lt; b. name &lt;&lt; <span class="hljs-string"><span class="hljs-string">" and "</span></span> &lt;&lt; verb &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Pet {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Pet {}; <span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">meets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Dog a, Dog b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"sniffs"</span></span>; } <span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">meets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Dog a, Cat b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"chases"</span></span>; } <span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">meets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cat a, Dog b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"hisses"</span></span>; } <span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">meets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cat a, Cat b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"slinks"</span></span>; }</code> </pre> <br><p>  Fungsi <code>main()</code> , seperti dalam kode Julia, membuat anjing dan kucing dan membuat mereka bertemu: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Dog fido; fido.name = <span class="hljs-string"><span class="hljs-string">"Fido"</span></span>; Dog rex; rex.name = <span class="hljs-string"><span class="hljs-string">"Rex"</span></span>; Cat whiskers; whiskers.name = <span class="hljs-string"><span class="hljs-string">"Whiskers"</span></span>; Cat spots; spots.name = <span class="hljs-string"><span class="hljs-string">"Spots"</span></span>; encounter(fido, rex); encounter(rex, whiskers); encounter(spots, fido); encounter(whiskers, spots); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  Jadi, banyak pengiriman terhadap fungsi kelebihan beban.  Gong! </p><br><p><img src="https://habrastorage.org/webt/sj/6u/ob/sj6uobzsl8adbgqxjlxuibpcnpc.png"></p><br><p>  Menurut Anda apa yang akan mengembalikan kode dengan beberapa pengiriman? </p><br><div class="spoiler">  <b class="spoiler_title">$ julia pets.jl</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">Fido meets Rex and sniffs Rex meets Whiskers and chases Spots meets Fido and hisses Whiskers meets Spots and slinks</code> </pre> <br><p>  Hewan-hewan bertemu, mengendus, mendesis dan bermain mengejar - seperti yang dimaksudkan. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">$ g ++ -o pet pets.cpp &amp;&amp; ./pets</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">Fido meets Rex and FALLBACK Rex meets Whiskers and FALLBACK Spots meets Fido and FALLBACK Whiskers meets Spots and FALLBACK</code> </pre> <br><p>  Dalam semua kasus, opsi "fallback" dikembalikan. </p><br><p>  Mengapa  Karena ini adalah cara kerja overloading fungsi.  Jika beberapa pengiriman berfungsi, maka <code>meets(a, b)</code> <code>encounter()</code> dalam <code>encounter()</code> akan dipanggil dengan tipe spesifik yang dimiliki <code>a</code> dan <code>b</code> pada saat panggilan berlangsung.  Tapi kelebihan beban diterapkan, oleh karena itu <code>meets()</code> dipanggil untuk tipe <em>statis</em> <code>a</code> dan <code>b</code> , yang keduanya dalam hal ini adalah <code>Pet</code> . </p></div></div><br><p>  Jadi, dalam pendekatan C ++, "terjemahan" langsung dari kode Julia yang digeneralisasi tidak memberikan perilaku yang diinginkan karena fakta bahwa kompiler menggunakan tipe yang diturunkan secara statis pada tahap kompilasi.  Dan intinya adalah bahwa kita ingin memanggil fungsi berdasarkan tipe beton nyata yang variabel miliki dalam runtime.  Fungsi templat, meskipun agak memperbaiki situasinya, masih membutuhkan pengetahuan tentang semua jenis yang termasuk dalam ekspresi secara statis pada waktu kompilasi, dan mudah untuk menghasilkan contoh di mana ini tidak mungkin. </p><br><p>  Bagi saya, contoh-contoh seperti itu menunjukkan bahwa pengiriman ganda melakukan hal yang benar, dan semua pendekatan lain bukanlah pendekatan yang sangat baik untuk hasil yang benar. </p><br><p>  Sekarang mari kita lihat tabel seperti itu.  Saya harap Anda menganggapnya bermakna: </p><br><div class="scrollable-table"><table><thead><tr><th>  Jenis penjadwalan </th><th>  Sintaks </th><th>  Argumen pengiriman </th><th>  Tingkat ekspresi </th><th>  Peluang ekspresif </th></tr></thead><tbody><tr><td>  tidak </td><td>  f (x <sub>1</sub> , x <sub>2</sub> , ...) </td><td>  {} </td><td>  O (1) </td><td>  konstan </td></tr><tr><td>  kesendirian </td><td>  x <sub>1</sub> .f (x <sub>2</sub> , ...) </td><td>  {x <sub>1</sub> } </td><td>  O (| X <sub>1</sub> |) </td><td>  linier </td></tr><tr><td>  berganda </td><td>  f (x <sub>1</sub> , x <sub>2</sub> , ...) </td><td>  {x <sub>1</sub> , x <sub>2</sub> , ...} </td><td>  O (| X <sub>1</sub> | | X <sub>2</sub> | ...) </td><td>  eksponensial </td></tr></tbody></table></div><br><p>  Dalam bahasa tanpa pengiriman, Anda cukup menulis <code>f(x, y, ...)</code> , jenis semua argumen sudah diperbaiki, mis.  panggilan ke <code>f()</code> adalah panggilan ke fungsi tunggal <code>f()</code> , yang mungkin ada dalam program.  Tingkat ekspresifnya konstan: memanggil <code>f()</code> selalu melakukan satu dan hanya satu hal.  Pengiriman tunggal adalah terobosan besar dalam transisi ke OOP pada 1990-an dan 2000-an.  Sintaks dot biasanya digunakan, yang sangat disukai orang.  Dan kesempatan ekspresif tambahan muncul: panggilan dikirim sesuai dengan jenis objek x <sub>1</sub> .  Peluang ekspresif ditandai oleh kekuatan set | X <sub>1</sub> |  tipe yang memiliki metode <code>f()</code> .  Namun, dalam pengiriman ganda, jumlah opsi potensial untuk fungsi <code>f()</code> sama dengan kekuatan produk Cartesian dari set tipe yang menjadi tempat argumen.  Pada kenyataannya, tentu saja, hampir tidak ada orang yang membutuhkan begitu banyak fungsi berbeda dalam satu program.  Tetapi poin kunci di sini adalah bahwa programmer diberikan cara yang sederhana dan alami untuk menggunakan elemen apa pun dari varietas ini, dan ini mengarah pada pertumbuhan peluang secara eksponensial. </p><br><h3 id="chast-1-obobschyonnoe-programmirovanie">  Bagian 1. Pemrograman umum </h3><br><p>  Mari kita bicara tentang kode umum - fitur utama pengiriman ganda. </p><br><p>  Berikut adalah contoh kode generik (sepenuhnya tiruan): </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> LinearAlgebra <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> inner_sum(A, vs) t = zero(eltype(A)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vs t += inner(v, A, v) <span class="hljs-comment"><span class="hljs-comment">#  ! end return t end inner(v, A, w) = dot(v, A * w) #   </span></span></code> </pre> <br><p>  Di sini <code>A</code> adalah sesuatu yang mirip matriks (walaupun saya tidak menunjukkan jenisnya, dan saya dapat menebak sesuatu berdasarkan nama), <code>vs</code> adalah vektor dari beberapa elemen yang mirip vektor, dan kemudian produk skalar dipertimbangkan melalui "matriks" ini, di mana definisi umum diberikan tanpa menentukan jenis apa pun.  Pemrograman umum di sini terdiri dari panggilan fungsi <code>inner()</code> dalam satu lingkaran (saran profesional: jika Anda ingin menulis kode umum - cukup hapus semua batasan jenis). </p><br><p>  Jadi, "lihat, bu, itu berhasil": </p><br><pre> <code class="julia hljs">julia&gt; A = rand(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-number"><span class="hljs-number">3</span></span>Ã—<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>}: <span class="hljs-number"><span class="hljs-number">0.934255</span></span> <span class="hljs-number"><span class="hljs-number">0.712883</span></span> <span class="hljs-number"><span class="hljs-number">0.734033</span></span> <span class="hljs-number"><span class="hljs-number">0.145575</span></span> <span class="hljs-number"><span class="hljs-number">0.148775</span></span> <span class="hljs-number"><span class="hljs-number">0.131786</span></span> <span class="hljs-number"><span class="hljs-number">0.631839</span></span> <span class="hljs-number"><span class="hljs-number">0.688701</span></span> <span class="hljs-number"><span class="hljs-number">0.632088</span></span> julia&gt; vs = [rand(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>] <span class="hljs-number"><span class="hljs-number">4</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>},<span class="hljs-number"><span class="hljs-number">1</span></span>}: [<span class="hljs-number"><span class="hljs-number">0.424535</span></span>, <span class="hljs-number"><span class="hljs-number">0.536761</span></span>, <span class="hljs-number"><span class="hljs-number">0.854301</span></span>] [<span class="hljs-number"><span class="hljs-number">0.715483</span></span>, <span class="hljs-number"><span class="hljs-number">0.986452</span></span>, <span class="hljs-number"><span class="hljs-number">0.82681</span></span>] [<span class="hljs-number"><span class="hljs-number">0.487955</span></span>, <span class="hljs-number"><span class="hljs-number">0.43354</span></span>, <span class="hljs-number"><span class="hljs-number">0.634452</span></span>] [<span class="hljs-number"><span class="hljs-number">0.100029</span></span>, <span class="hljs-number"><span class="hljs-number">0.448316</span></span>, <span class="hljs-number"><span class="hljs-number">0.603441</span></span>] julia&gt; inner_sum(A, vs) <span class="hljs-number"><span class="hljs-number">6.825340887556694</span></span></code> </pre> <br><p>  Tidak ada yang istimewa, itu menghitung beberapa nilai.  <em>Tapi</em> - kode ini ditulis dalam gaya umum dan akan bekerja untuk <code>A</code> dan <code>vs</code> , jika saja akan memungkinkan untuk melakukan operasi yang sesuai pada mereka. </p><br><p>  Adapun efisiensi pada tipe data tertentu - betapa beruntungnya.  Maksud saya untuk vektor dan matriks yang padat kode ini akan melakukannya "sebagaimana mestinya" - itu akan menghasilkan kode mesin dengan doa operasi BLAS, dll.  dll.  Jika Anda melewatkan array statis, maka kompiler akan mempertimbangkan ini, perluas siklusnya, terapkan vektorisasi - semuanya sudah sebagaimana mestinya. </p><br><p>  Tetapi yang lebih penting, kode ini akan bekerja untuk tipe baru, dan Anda dapat membuatnya tidak hanya sangat efisien, tetapi juga sangat efisien!  Mari kita tentukan tipe baru (ini adalah tipe data nyata yang digunakan dalam pembelajaran mesin), vektor kesatuan (vektor satu-panas).  Ini adalah vektor di mana salah satu komponennya adalah 1, dan yang lainnya nol.  Anda dapat membayangkannya dengan sangat ringkas: semua yang perlu disimpan adalah panjang vektor dan jumlah komponen bukan nol. </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Base: size, getindex, * <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> OneHotVector &lt;: <span class="hljs-built_in"><span class="hljs-built_in">AbstractVector</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>} len :: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> ind :: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> size(v::OneHotVector) = (v.len,) getindex(v::OneHotVector, i::<span class="hljs-built_in"><span class="hljs-built_in">Integer</span></span>) = <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>(i == v.ind)</code> </pre> <br><p>  Bahkan, ini benar-benar definisi tipe keseluruhan dari paket yang menambahkannya.  Dan dengan definisi ini, <code>inner_sum()</code> juga berfungsi: </p><br><pre> <code class="julia hljs">julia&gt; vs = [OneHotVector(<span class="hljs-number"><span class="hljs-number">3</span></span>, rand(<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>] <span class="hljs-number"><span class="hljs-number">4</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{OneHotVector,<span class="hljs-number"><span class="hljs-number">1</span></span>}: [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>] [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>] [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>] julia&gt; inner_sum(A, vs) <span class="hljs-number"><span class="hljs-number">2.6493739294755123</span></span></code> </pre> <br><p>  Tetapi untuk produk skalar, definisi umum digunakan di sini - untuk jenis data ini lambat, tidak keren! </p><br><p>  Jadi, definisi umum berfungsi, tetapi tidak selalu secara optimal, dan Anda kadang-kadang dapat menemukan ini ketika menggunakan Julia: "baiklah, definisi umum dipanggil, itu sebabnya kode GPU ini telah bekerja selama lima jam ..." </p><br><p>  Di <code>inner()</code> secara default, definisi umum dari produk matriks oleh vektor disebut, yang ketika dikalikan dengan vektor kesatuan mengembalikan salinan salah satu kolom dari tipe <code>Vector{Float64}</code> .  Kemudian definisi umum dari produk skalar <code>dot()</code> disebut dengan vektor kesatuan dan kolom ini, yang melakukan banyak pekerjaan yang tidak perlu.  Bahkan, untuk setiap komponen dicentang "apakah Anda sama dengan satu? Dan Anda?"  dll. </p><br><p>  Kami dapat sangat mengoptimalkan prosedur ini.  Misalnya, mengganti perkalian matriks dengan <code>OneHotVector</code> hanya dengan memilih kolom.  Baik, tentukan metode ini, dan hanya itu. </p><br><pre> <code class="julia hljs">*(A::<span class="hljs-built_in"><span class="hljs-built_in">AbstractMatrix</span></span>, v::OneHotVector) = A[:, v.ind]</code> </pre> <br><p>  Dan ini dia, <strong>kekuatan</strong> : kita mengatakan "kita ingin <em>membahas argumen kedua,</em> " tidak peduli apa yang ada di <em>argumen</em> pertama.  Definisi seperti itu hanya akan menarik baris keluar dari matriks dan akan jauh lebih cepat daripada metode umum - iterasi dan penjumlahan kolom dihapus. </p><br><p>  Tetapi Anda dapat melangkah lebih jauh dan langsung mengoptimalkan <code>inner()</code> , karena mengalikan dua vektor kesatuan melalui sebuah matriks cukup mengeluarkan elemen dari matriks ini: </p><br><pre> <code class="julia hljs">inner(v::OneHotVector, A, w::OneHotVector) = A[v.ind, w.ind]</code> </pre> <br><p>  Itulah efisiensi super-duper yang dijanjikan.  Dan semua yang diperlukan adalah mendefinisikan metode <code>inner()</code> ini. </p><br><p>  Contoh ini menunjukkan salah satu aplikasi penjadwalan berganda: ada definisi umum dari suatu fungsi, tetapi untuk beberapa tipe data tidak berfungsi secara optimal.  Dan kemudian kami secara bijaksana menambahkan metode yang mempertahankan <em>perilaku</em> fungsi untuk tipe ini, tetapi bekerja jauh <em>lebih efisien</em> . </p><br><p>  Tetapi ada area lain - ketika tidak ada definisi umum dari suatu fungsi, tapi saya ingin menambahkan fungsionalitas untuk beberapa jenis.  Maka Anda dapat menambahkannya dengan sedikit usaha. </p><br><p>  Dan opsi ketiga - Anda hanya ingin memiliki nama fungsi yang sama, tetapi dengan perilaku berbeda untuk tipe data yang berbeda - misalnya, agar fungsi berperilaku berbeda saat bekerja dengan kamus dan array. </p><br><p>  Bagaimana cara mendapatkan perilaku serupa dalam bahasa pengiriman tunggal?  Itu mungkin, tetapi sulit.  Masalah: ketika membebani fungsi <code>*</code> perlu mengirim argumen kedua, dan bukan yang pertama.  Anda dapat melakukan pengiriman ganda: pertama, kirim dengan argumen pertama dan panggil metode <code>AbstractMatrix.*(v)</code> .  Dan metode ini, pada gilirannya, memanggil sesuatu seperti <code>v.__rmul__(A)</code> , mis.  argumen kedua dalam panggilan asli kini telah menjadi objek yang metodenya sebenarnya dipanggil.  <code>__rmul__</code> sini diambil dari Python, di mana perilaku seperti itu adalah pola standar, tetapi tampaknya hanya berfungsi untuk penambahan dan perkalian.  Yaitu  masalah pengiriman ganda terpecahkan jika kita ingin memanggil fungsi yang disebut <code>+</code> atau <code>*</code> , jika tidak - sayangnya, bukan zaman kita.  Dalam C ++ dan bahasa lainnya - Anda perlu membuat sepeda Anda. </p><br><p>  OK, bagaimana dengan <code>inner()</code> ?  Sekarang ada tiga argumen, dan pengiriman berlanjut pada yang pertama dan ketiga.  Apa yang harus dilakukan dalam bahasa dengan pengiriman tunggal tidak jelas.  "Pengiriman tiga" Aku tidak pernah bertemu langsung.  Tidak ada solusi yang baik.  Biasanya, ketika kebutuhan yang sama muncul (dan dalam kode numerik tampaknya sangat sering), orang akhirnya menerapkan sistem pengiriman ganda mereka.  Jika Anda melihat proyek besar untuk perhitungan numerik dengan Python, Anda akan kagum berapa banyak dari mereka yang melakukannya dengan cara ini.  Secara alami, implementasi seperti itu bekerja secara situasional, tidak dirancang dengan baik, penuh dengan bug dan lambat ( <em>mengacu pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aturan kesepuluh Greenspan</a> - kira - kira. Terjemahan</em> ), Karena Jeff Besancon tidak bekerja pada proyek - proyek ini ( <em>penulis dan kepala pengembang sistem pengiriman jenis di Julia - sekitar terjemahan.</em> ). </p><br><h3 id="chast-2-obschie-tipy">  Bagian 2. Tipe umum </h3><br><p>  Saya akan beralih ke sisi sebaliknya dari paradigma Julia - tipe umum.  Ini, menurut pendapat saya, adalah "pekerja keras" utama bahasa, karena di area inilah saya mengamati penggunaan kembali kode tingkat tinggi. </p><br><p>  Misalnya, Anda memiliki jenis RGB, seperti yang dimiliki ColorTypes.jl.  Tidak ada yang rumit di dalamnya, hanya tiga nilai yang disatukan.  Demi kesederhanaan, kami menganggap bahwa jenisnya tidak parametrik (tetapi bisa saja), dan penulis mendefinisikan beberapa operasi dasar baginya yang menurutnya berguna.  Anda mengambil tipe ini dan berpikir: "Hmm, saya ingin menambahkan lebih banyak operasi pada tipe ini."  Misalnya, bayangkan RGB sebagai ruang vektor (yang, sebenarnya, tidak benar, tetapi akan turun ke perkiraan pertama).  Di Julia, Anda cukup mengambil dan menambahkan kode Anda semua operasi yang hilang. </p><br><p>  Muncul pertanyaan - <em>dan cho?</em>  Mengapa saya terlalu fokus pada hal ini?  Ternyata dalam bahasa berorientasi objek yang didasarkan pada kelas, pendekatan seperti itu sangat sulit diimplementasikan.  Karena definisi metode dalam bahasa ini ada di dalam definisi kelas, hanya ada dua cara untuk menambahkan metode: mengedit kode kelas untuk menambahkan perilaku yang diinginkan, atau membuat kelas pewaris dengan metode yang diperlukan. </p><br><p>  Opsi pertama mengembang definisi kelas dasar, dan juga memaksa pengembang kelas dasar untuk menjaga dukungan dari semua metode yang ditambahkan saat mengubah kode.  Apa yang suatu hari bisa membuat kelas seperti itu tidak didukung. </p><br><p>  Warisan adalah pilihan "direkomendasikan" klasik, tetapi juga bukan tanpa cacat.  Pertama, Anda perlu mengubah nama kelas - biarkan sekarang bukan <code>RGB</code> , tetapi <code>MyRGB</code> .  Selain itu, metode baru tidak lagi berfungsi untuk kelas <code>RGB</code> asli;  jika saya ingin menerapkan metode baru saya ke objek <code>RGB</code> dibuat dalam kode orang lain, saya perlu mengonversi atau membungkusnya dalam <code>MyRGB</code> .  Tapi ini bukan yang terburuk.  Jika saya membuat kelas <code>MyRGB</code> dengan beberapa fungsi tambahan, orang lain <code>OurRGB</code> , dll.  - maka jika seseorang menginginkan kelas yang memiliki semua fungsi baru, Anda perlu menggunakan banyak pewarisan (dan ini hanya jika bahasa pemrograman memungkinkannya sama sekali!). </p><br><p>  Jadi, kedua opsi ini biasa saja.  Namun, ada solusi lain: </p><br><ul><li>  Letakkan fungsional dalam fungsi eksternal daripada metode kelas - pergi ke <code>f(x, y)</code> bukan <code>xf(y)</code> .  Tapi kemudian perilaku umum hilang. </li><li>  Meludahi menggunakan kembali kode (dan, menurut saya, dalam banyak kasus ini terjadi).  Cukup salin diri Anda sendiri ke kelas <code>RGB</code> asing dan tambahkan yang hilang. </li></ul><br><p>  Fitur utama Julia dalam hal menggunakan kembali kode hampir sepenuhnya dikurangi menjadi fakta bahwa <em>metode ini didefinisikan di luar tipe</em> .  Itu saja.  Lakukan hal yang sama dalam bahasa pengiriman tunggal - dan jenis dapat digunakan kembali dengan mudah.  Seluruh cerita dengan "mari kita membuat metode menjadi bagian dari kelas" sebenarnya adalah ide yang begitu-begitu saja.  Benar, ada poin bagus - penggunaan kelas sebagai ruang nama.  Jika saya menulis <code>xf(y)</code> - <code>f()</code> tidak harus berada di namespace saat ini, itu harus dicari di namespace <code>x</code> .  Ya, ini adalah hal yang baik - tetapi apakah itu layak untuk semua masalah lainnya?  Saya tidak tahu.  Menurut pendapat saya, tidak (meskipun pendapat saya, seperti yang Anda duga, sedikit bias). </p><br><h3 id="epilog-problema-vyrazheniya">  Epilog.  Masalah ekspresi </h3><br><p>  Ada masalah pemrograman yang terlihat pada tahun 70-an.  Ini sebagian besar terkait dengan pemeriksaan tipe statis, karena muncul dalam bahasa tersebut.  Benar, saya pikir itu tidak ada hubungannya dengan pengecekan tipe statis.  Inti dari masalah adalah sebagai berikut: apakah mungkin untuk mengubah model data dan serangkaian operasi pada data pada saat yang sama, tanpa menggunakan teknik yang meragukan. </p><br><p>  Masalahnya dapat lebih atau kurang dikurangi menjadi sebagai berikut: </p><br><ol><li>  apakah mungkin untuk dengan mudah dan bebas kesalahan menambahkan <strong>tipe data baru</strong> yang mana <strong>metode yang berlaku</strong> dan </li><li>  Apakah mungkin untuk <strong>menambahkan operasi baru</strong> pada <strong>tipe yang ada</strong> . </li></ol><br><p>  (1) mudah dilakukan dalam bahasa berorientasi objek dan sulit secara fungsional, (2) - sebaliknya.  Dalam hal ini, kita bisa berbicara tentang dualisme pendekatan OOP dan FP. </p><br><p>  Dalam bahasa multi-pengiriman, kedua operasi mudah. (1)         , (2) â€”      . <em>   </em> ,    .         ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://en.wikipedia.org/wiki/Expression_problem</a> ),           .     ?  ,   ,     .   , "  ,     " â€”   "    "  .  "  ,     " ,       ,   . </p><br><p>            ,   .  ,  ,   â€”      . </p><br><p>  ,   Julia    (     ),      .    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id468609/">https://habr.com/ru/post/id468609/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468595/index.html">Bagaimana kami membangun Wi-Fi di Huawei</a></li>
<li><a href="../id468597/index.html">Segi enam Saturnus atau bagaimana di rumah mereproduksi eksperimen para ilmuwan dari Universitas Oxford</a></li>
<li><a href="../id468601/index.html">Perkiraan jangka waktu proyek. Mengapa hampir selalu sangat bersahaja dan apa yang harus dilakukan</a></li>
<li><a href="../id468603/index.html">Rutracker sudah memasukkan eSNI. Akhir era DPI dan akhir kunci</a></li>
<li><a href="../id468605/index.html">Pointer konstan ke pointer ke pointer ...</a></li>
<li><a href="../id468611/index.html">.NET multithreading: ketika kinerja kurang</a></li>
<li><a href="../id468615/index.html">10 Bahasa Teratas untuk Pelokalan Aplikasi</a></li>
<li><a href="../id468621/index.html">Kami menerjemahkan jaringan rumah ke DoH, atau klik lain pada hidung pemfilteran</a></li>
<li><a href="../id468623/index.html">Saya ingin ulasan tentang Habr</a></li>
<li><a href="../id468625/index.html">Tanpa server: 15% lebih lambat dan delapan kali lebih mahal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>