<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔦 👩🏿‍🤝‍👩🏼 🤽🏼 Pengujian integrasi untuk memeriksa kebocoran memori 💻 👆🏻 🤞🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami menulis banyak pengujian unit, mengembangkan aplikasi SoundCloud untuk iOS. Tes unit terlihat sangat cantik. Mereka pendek, (mudah-mudahan) dapat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengujian integrasi untuk memeriksa kebocoran memori</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459220/">  Kami menulis banyak pengujian unit, mengembangkan aplikasi <b>SoundCloud</b> untuk iOS.  Tes unit terlihat sangat cantik.  Mereka pendek, (mudah-mudahan) dapat dibaca, dan mereka memberi kita keyakinan bahwa kode yang kita tulis berfungsi seperti yang diharapkan.  Tetapi tes unit, seperti namanya, mencakup hanya satu blok kode, paling sering fungsi atau kelas.  Jadi, bagaimana Anda menangkap kesalahan yang ada dalam interaksi antar kelas - kesalahan seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kebocoran memori</a> ? <br><a name="habracut"></a><br><br><h3>  Kebocoran Memori </h3><br>  Terkadang cukup sulit untuk mendeteksi kesalahan kebocoran memori.  Ada kemungkinan referensi kuat untuk delegasi, tetapi ada juga kesalahan yang jauh lebih sulit untuk dideteksi.  Misalnya, apakah jelas bahwa kode berikut ini mungkin berisi kebocoran memori? <br><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UseCase</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> delegate: <span class="hljs-type"><span class="hljs-type">UseCaseDelegate?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> service: <span class="hljs-type"><span class="hljs-type">Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(service: <span class="hljs-type"><span class="hljs-type">Service</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.service = service } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { service.makeRequest(handleResponse) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response: ServiceResponse)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// some business logic and then... delegate.operationDidComplete() } }</span></span></code> </pre> <br><br>  Karena <i>Layanan</i> sudah dilaksanakan, tidak ada jaminan mengenai perilakunya.  Melewati fungsi <i>handleResponse</i> ke fungsi pribadi, yang menangkap <b>sendiri</b> , kami memberikan <i>Layanan dengan</i> referensi yang kuat untuk <i>UseCase</i> .  Jika <i>Layanan</i> memutuskan untuk menyimpan tautan ini - dan kami tidak memiliki jaminan bahwa ini tidak akan terjadi - maka terjadi kebocoran memori.  Tetapi dengan studi sepintas kode, tidak jelas bahwa ini benar-benar bisa terjadi. <br><br>  Ada juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting</a> indah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">oleh John Sandell</a> tentang menggunakan unit test untuk mendeteksi kebocoran memori untuk kelas.  Tetapi dengan contoh di atas, di mana sangat mudah untuk melewatkan kebocoran memori, tidak selalu jelas bagaimana menulis unit test seperti itu.  (Tentu saja, kami tidak berbicara di sini dalam hal pengalaman.) <br><br>  Seperti yang ditulis Guilherme dalam sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting</a> baru-baru ini, fitur-fitur baru dalam aplikasi SoundCloud untuk iOS ditulis menurut "pola arsitektur bersih" - paling sering ini adalah jenis <b>VIPER</b> .  Sebagian besar modul <b>VIPER</b> ini dibangun menggunakan apa yang kita sebut <b>ModuleFactory</b> .  <b>ModuleFactory</b> semacam itu membutuhkan input, dependensi, dan konfigurasi - dan membuat <b>UIViewController</b> yang sudah terhubung ke modul lainnya dan dapat <b>didorong ke</b> tumpukan navigasi. <br><br>  Modul <b>VIPER</b> ini dapat memiliki beberapa delegasi, pengamat, dan kesalahan pelarian, yang masing-masing dapat menyebabkan pengontrol tetap berada di memori setelah dihapus dari tumpukan navigasi.  Ketika ini terjadi, jumlah memori akan meningkat, dan sistem operasi mungkin memutuskan untuk menghentikan aplikasi. <br><br>  Jadi mungkinkah menutup kemungkinan banyak kebocoran dengan menulis sesedikit mungkin unit test?  Jika tidak, maka semua ini adalah buang-buang waktu. <br><br><h3>  Tes integrasi </h3><br>  Jawabannya, seperti yang sudah Anda tebak dari judul posting ini, adalah ya.  Dan kami melakukan ini melalui pengujian integrasi.  Tujuan dari tes integrasi adalah untuk menguji bagaimana benda berinteraksi satu sama lain.  Tentu saja, modul <b>VIPER</b> adalah kelompok objek, kebocoran memori adalah salah satu bentuk interaksi yang pasti ingin kita hindari. <br><br>  Rencana kami sederhana: Kami akan menggunakan <i>ModuleFactory</i> kami untuk instantiate modul <b>VIPER</b> .  Kemudian kita akan menghapus tautan ke <i>UIViewController</i> dan memastikan bahwa semua bagian penting dari modul dihancurkan bersama dengan itu. <br><br>  Masalah pertama yang kita hadapi adalah bahwa pada dasarnya kita tidak dapat dengan mudah mengakses bagian apa pun dari modul <b>VIPER</b> selain <i>UIViewController</i> .  Satu-satunya fungsi <i>publik</i> di <b>ModuleFactory</b> kami adalah <i>func make () -&gt; UIViewController</i> .  Tetapi bagaimana jika kita menambahkan titik masuk lain hanya untuk pengujian kita?  Metode baru ini akan dideklarasikan melalui <b>internal</b> , jadi kita hanya dapat mengaksesnya melalui <i>impor @testable</i> , framework <i>ModuleFactory</i> .  Ini akan mengembalikan tautan ke semua bagian terpenting dari modul, yang kemudian dapat kami tahan untuk tautan yang lemah untuk masuk dalam pengujian kami.  Ini akhirnya terlihat seperti ini: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModuleFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     ,   ... public func make() -&gt; UIViewController { makeAndExpose().view } typealias ModuleComponents = ( view: UIViewController, presenter: Presenter, Interactor: Interactor ) func makeAndExpose() -&gt; ModuleComponents { // Set up code, and then... return ( view: viewController, presenter: presenter, interactor: interactor ) } }</span></span></code> </pre><br><br>  Ini memecahkan masalah kurangnya akses langsung ke data objek.  Jelas, ini tidak ideal, tetapi memenuhi kebutuhan kita, jadi mari kita lanjutkan menulis tes.  Ini akan terlihat seperti ini: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModuleMemoryLeakTests</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XCTestCase</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      .     //    . private var view: UIViewController? //        //   ,    // UIKit,   UIViewController  . private weak var presenter: Presenter? private weak var interactor: Interactor? //   setUp    ModuleFactory  //   makeAndExpose.     ,   //     ModuleComponents // ,          . //     . func setUp() { super.setUp() let moduleFactory = ModuleFactory(/* mocked dependencies &amp; config */) let components = moduleFactory.makeAndExpose() view = components.view presenter = components.presenter interactor = components.interactor } //   ,   tearDown   , //        ,     ,   //     . func tearDown() { view = nil presenter = nil interactor = nil super.tearDown() } func test_module_doesNotLeakMemory() { //   ,      . //      ,  //          setUp. XCTAssertNotNil(presenter) XCTAssertNotNil(interactor) //        . //    ,   //     ,    //      . view = nil // ,  ,    //  Presenter  Interactor   . //  ,       //  ,    . XCTAssertNil(presenter) XCTAssertNil(interactor) } }</span></span></code> </pre><br><br>  Jadi, kami memiliki cara mudah untuk mendeteksi kebocoran memori dalam modul <b>VIPER</b> .  Ini sama sekali tidak ideal dan membutuhkan pekerjaan pengguna tertentu untuk setiap modul baru yang ingin kami uji, tetapi ini tentu saja jauh lebih sedikit daripada menulis unit test terpisah untuk setiap kemungkinan kebocoran memori.  Ini juga membantu mengidentifikasi kebocoran memori yang bahkan tidak kami duga.  Faktanya, setelah menulis beberapa tes ini, terungkap bahwa kami memiliki tes yang tidak lulus, dan setelah beberapa penelitian, kami menemukan kebocoran memori dalam modul.  Setelah koreksi, tes harus diulang. <br><br>  Ini juga memberi kita titik awal untuk menulis serangkaian tes integrasi yang lebih umum untuk modul.  Pada akhirnya, jika kita hanya menyimpan tautan yang kuat ke <b>Presenter</b> dan mengganti <b>UIViewController</b> dengan <b>tiruan</b> , kita dapat memalsukan input pengguna, lalu memanggil metode presenter dan memeriksa tampilan dummy data dalam <b>View</b> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459220/">https://habr.com/ru/post/id459220/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459206/index.html">9 tahun dalam monolit di Node.JS</a></li>
<li><a href="../id459208/index.html">Berjalan dengan prostesis: Simulasi Nekstgen tentang gerakan manusia menggunakan otot, tulang, dan jaringan saraf</a></li>
<li><a href="../id459212/index.html">Implementasi properti di C ++</a></li>
<li><a href="../id459214/index.html">Toleransi kesalahan dalam penyimpanan Qsan</a></li>
<li><a href="../id459216/index.html">Struktur data B-tree</a></li>
<li><a href="../id459224/index.html">Dari makelar ke pengembang game 2. "Operasi: Android"</a></li>
<li><a href="../id459226/index.html">"Fast-PoE dan Perpetual-PoE - apakah ini standar baru atau tidak?"</a></li>
<li><a href="../id459230/index.html">Perjalanan ke pusat panggilan dan Product Backlog melalui mata pengembang</a></li>
<li><a href="../id459232/index.html">Kelilingi, gigit, potong: kompetisi Mini AI Cup # 4 yang baru</a></li>
<li><a href="../id459234/index.html">Smem - Laporan alokasi memori antara proses dan pengguna di Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>