<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛲️ 👨🏼‍⚖️ 🐋 Peramalan Lagi, Bagian 1 🐞 🕡 🕠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pertimbangkan seri waktu perkiraan. Mari kita coba memprediksi grafik kutipan, atau hal lain yang berguna. 



 Mari kita ambil sebagai dasar peramala...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Peramalan Lagi, Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435590/"> Pertimbangkan seri waktu perkiraan.  Mari kita coba memprediksi grafik kutipan, atau hal lain yang berguna. <br><br><img src="https://habrastorage.org/webt/vu/9t/i1/vu9ti19agphjfufbbndeff5xjj4.jpeg"><br><a name="habracut"></a><br>  Mari kita ambil sebagai dasar peramalan yang disajikan dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Model Perkiraan Rangkaian Waktu untuk Contoh Kesamaan Maksimum: penjelasan dan contoh</a> (artikel ini bukan milik saya).  Poin singkatnya adalah bahwa segmen grafik yang paling mirip di sebelah kiri perkiraan di antara riwayat masa lalu dicari, dan kemudian nilai di sebelah kanan grafik kemudian diambil dari yang terbaik yang lama ini dan digunakan sebagai perkiraan. <br><br>  Saya akan melangkah lebih jauh.  Saat menghitung perkiraan, saya tidak akan mengambil satu kasus pun yang terbaik dalam korelasi, tetapi satu pak yang terbaik.  Dan perkiraan akan menjadi hasil rata-rata untuk paket ini.  Ini akan memungkinkan untuk memahami bahwa nilai yang ditemukan adalah keteraturan, dan bukan kebetulan kebetulan dengan perkiraan yang diinginkan, atau penyimpangan acak jika ramalan menyimpang dari yang sebenarnya. <br><br>  Menggunakan opsi tunggal terbaik seperti dalam artikel itu tidak benar, serta menentukan distribusi probabilitas dengan satu nilai dari distribusi ini.  Jika Anda menghasilkan grafik yang sangat besar dari data acak dan memulai pencarian pada mereka, maka pasti akan ada segmen yang berkorelasi di dalamnya, dan bahkan mungkin dengan koefisien 0,9999, tetapi sama sekali tidak perlu bahwa segmen yang sama akan terus mengikuti segmen ini - masih semuanya acak.  Dan Anda hanya perlu mengambil paket segmen tersebut dan menghitung bahwa varians dari data selanjutnya lebih rendah dari varians yang terbentuk dari sampel acak dari data ini.  Dan jika dispersi paket lebih rendah - maka ini adalah perkiraan.  Meskipun ini juga bukan representasi akurat dari kemungkinan kesalahan, ini sudah cukup untuk saat ini. <br><br>  Yaitu  <b>peramalan</b> bukanlah prinsip pengambilan sampel dan korelasi dari segmen yang dibandingkan yang kami gunakan, hal utama adalah bahwa sebagai hasil dari penerapan sampel ini, varians dari nilai yang diinginkan akan lebih kecil daripada sebagai hasil dari pengambilan sampel acak. <br><br>  Juga, varian dari paket ini akan memungkinkan untuk mengevaluasi mana yang lebih baik untuk menggunakan opsi pemilihan dari kasus-kasus sebelumnya.  Bagaimanapun, adalah mungkin untuk memilih tidak selalu satu segmen data yang berkorelasi, dan tidak selalu menggunakan korelasi Pearson.  Dan pilihan seperti itu dapat dibuat untuk setiap titik yang diperkirakan secara terpisah.  Untuk jenis sampel varians lebih sedikit, opsi itu lebih baik untuk titik saat ini. <br><br>  Paket ukuran apa yang seharusnya?  Ini bertumpu pada masalah interval kepercayaan.  Agar tidak memuat terlalu banyak, ada disebutkan bahwa lebih baik mengambil setidaknya 30 contoh untuk menentukan nilai rata-rata.  Jika ada kelebihan data uji, saya akan mengambil setidaknya 100. <br><br>  Rasio dari standar deviasi sampel sesuai dengan algoritma dan yang acak dapat disebut koefisien teoritis keberhasilan algoritma peramalan untuk titik saat ini untuk tujuan perbandingan dengan algoritma pengambilan sampel lainnya, atau untuk menentukan kegunaan perkiraan ini secara umum, sedangkan nilai aktual belum tersedia. <br><br><img src="https://habrastorage.org/webt/5c/5z/1m/5c5z1mvlg8betcdjgytvaxqcopc.png" alt="koef_forecast = 1 - std_dev_forecast / std_dev_random"><br><br>  Koefisien ini dalam beberapa kasus dapat mengambil nilai negatif.  Poin-poin di mana hal ini terjadi adalah sedikit menarik, seperti poin-poin dengan koefisien nol.  Dalam hal prediktabilitas 100%, itu akan sama dengan satu. <br><br>  Mari kita beralih ke contoh praktis, lagi dari artikel itu.  Setelah memperbaiki kesalahan kecil di sana, kami mendapatkan hasil berikut, konsisten dengan artikel itu dan algoritma itu: <br><br>  <b>perhitungan perkiraan pada saat 9/1/2012 23:00 posisi 52631</b> <b><br></b>  <b>nilai total diperiksa untuk kemiripan 2184</b> <b><br></b>  <b>korelasi terbaik posisi 0,958174 52295</b> <b><br></b>  <b>koefisien transfer alpha (1/2) 1.03117 -11.1992</b> <b><br></b>  <b>perkiraan kesalahan dari fakta mape 5.210%</b> <br><br>  mape - istilah dari artikel asli Mean Persentase Absolute Error, dihitung dengan rumus <br>  <b>Abs (Prakiraan - Fakta) / Fakta</b> <br><br>  Dan sekarang mari kita membuat pilihan bukan satu kesamaan terbaik, tetapi paket yang terbaik dan segalanya untuk memprediksi satu saat dalam waktu dan melihat apa yang terjadi: <br><br>  <b>0 koreksi 0,958174 pos 52295 mape 5,210%</b> <b><br></b>  <b>1 kor 0,953571 pos 52151 mape 6,566%</b> <b><br></b>  <b>2 kor 0,953532 pos 45599 mape 11,642%</b> <b><br></b>  <b>3 kor 0,951462 pos 45743 mape 7,033%</b> <b><br></b>  <b>4 kor 0,950921 pos 45575 cetakan 3,300%</b> <b><br></b>  <b>5 kor 0,950789 pos 38687 mape 3,538%</b> <b><br></b> <br>  Nilai korelasi di sini berubah dari nilai ke nilai yang dapat diabaikan.  Pada saat yang sama, nilai hasil perkiraan bervariasi dari 3% hingga 11%.  Yaitu  bahwa 5% awal tidak lebih dari kebetulan, bisa jadi 11% dan 3%. <br><br>  Di bawah kondisi kesamaan yang ditentukan dalam artikel itu, nilai 2184 dapat dibandingkan secara total.  Dari jumlah tersebut, saya mengambil paket yang terbaik dalam 1500 buah, diurutkan dalam urutan penurunan korelasi, dan ditampilkan dalam grafik.  Korelasi dalam paket ini dari 0,958 terbaik turun menjadi 0,715 dari kiri ke kanan.  Tetapi fluktuasi hasil praktis tidak berubah: <br><br><img src="https://habrastorage.org/webt/o6/jz/wl/o6jzwlcdck1ynbs8oss9um0aios.png"><br><br>  Dapat dilihat bahwa ketergantungan hasil pada korelasi sangat rendah, tetapi tampaknya tetap ada.  Secara umum, kami mengambil paket dari 100 nilai teratas dan menghitung perkiraan, seperti yang saya sebutkan, dengan rata-rata untuk paket ini.  Hasilnya adalah sebagai berikut: <b>mape 5,824%, stddev mape 7,035%</b> .  Tapi 5,8% ini bukan lagi kebetulan, tetapi rata-rata distribusi - perkiraan yang paling mungkin.  Deviasi standar mape lebih besar daripada mape itu sendiri, tetapi ini karena mape memiliki distribusi non-simetris. <br><br>  Saya juga menghitung perkiraan yang sama tetapi menggunakan sampel acak bersyarat, lebih tepatnya, hanya dirata-rata dari semua opsi yang mungkin, hasil <b>mape adalah 8,246%</b> .  Dengan pengambilan sampel acak, kesalahannya sedikit lebih besar, tetapi nilai ini masih dalam kisaran sebaran yang dihitung dari sampel terbaik.  Untuk titik yang dihitung, koefisien peramalan teoritis yang ditunjukkan oleh saya mendekati nol, lebih tepatnya <b>koef_forecast = -0.041</b> .  Saya tidak menghitungnya dari stddev mape (ini termasuk perkiraan sebenarnya), tetapi dari nilai absolut dari perkiraan tersebut, jika Anda melihat program maka angka awal untuk itu diberikan di sana. <br><br>  Tapi ini kalau menyangkut cap waktu, yang disebutkan dalam artikel asli.  Tetapi jika kita mengatakan “9/4/2012 23:00” (bulan / hari / tahun), maka koefisien efisiensi <b>teorinya</b> adalah <b>koef_forecast = 0,21</b> , dan <b>mape = 3,126%, mape_rand = 7,147%</b> .  Yaitu  koef_forecast menunjukkan sebelumnya bahwa titik saat ini akan dihitung lebih akurat daripada yang sebelumnya.  Inti dari kegunaan koefisien ini adalah bahwa Anda setidaknya dapat mengevaluasi hasilnya bahkan sebelum mendapatkan data aktual, karena  data aktual tidak berpartisipasi di dalamnya.  Semakin tinggi, semakin baik.  Saya sudah menyebutkan bahwa titik yang diprediksi mutlak akan memiliki koefisien satu. <br><br>  Anda sendiri dapat melihat bagaimana semua angka ini berubah dalam program demo saya di Qt C ++, di sana Anda dapat memilih tanggal dan ukuran paket: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sumber di github</a> <br><br>  Nilai terbaik dipilih berdasarkan algoritma berikut: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OrdPack::add_value(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> koef, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i_pos) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::isfinite(koef)==<span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (koef &lt;= <span class="hljs-number"><span class="hljs-number">0.0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mmap_ord.size() &lt; ma_count_for_pack) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mmap_ord.size()==<span class="hljs-number"><span class="hljs-number">0</span></span>) mi_koef = koef; mi_koef = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::min(mi_koef, koef); mmap_ord.insert({-koef,i_pos}); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (koef &gt; mi_koef) { mmap_ord.insert({-koef,i_pos}); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (mmap_ord.size() &gt; ma_count_for_pack) mmap_ord.erase(--mmap_ord.end()); mi_koef = -(--mmap_ord.end())-&gt;first; } }</code> </pre> <br>  Tidak ada gunanya memposting seluruh sumber di sini, tidak rumit di sana, dan dengan komentar.  Dasar dalam prosedur MainWindow :: to_do_test () dalam file <a href="">mainwindow.cpp</a> . <br><br>  Untuk saat ini, saya akan terus mencoba memprediksi sesuatu di bagian selanjutnya. <br><br>  PS.  Silakan tinggalkan komentar Anda tentang apakah semuanya jelas tentang apa yang hilang.  Saya sudah menyusun rencana perkiraan untuk apa yang akan ditulis selanjutnya, tetapi dengan komentar Anda, saya akan melakukannya dengan lebih baik. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435590/">https://habr.com/ru/post/id435590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435580/index.html">Layanan Java, Spring, Kurento dan Media</a></li>
<li><a href="../id435582/index.html">Bagaimana cara menambahkan indeks pada sistem yang dimuat 24/7 tanpa downtime?</a></li>
<li><a href="../id435584/index.html">Slush 2018. Hari Pertama, Hari Kedua</a></li>
<li><a href="../id435586/index.html">Seni perdukunan atau firmware khusus untuk Olinuxino. Kernel dan Ubuntu Bagian 3</a></li>
<li><a href="../id435588/index.html">Promosi aplikasi seluler dengan pengalaman nyata dalam jumlah</a></li>
<li><a href="../id435592/index.html">Azores: cadangan flora terakhir di tengah Samudra Atlantik</a></li>
<li><a href="../id435594/index.html">Grafik Rute untuk Apache Camel</a></li>
<li><a href="../id435600/index.html">Cara bermigrasi ke operator seluler lain dan tidak bangkrut (untuk pemilik iOS)</a></li>
<li><a href="../id435602/index.html">Persiapan Ujian Azure</a></li>
<li><a href="../id435604/index.html">BlaBlaCar menjadi apa yang tidak dimaksudkan untuk itu</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>