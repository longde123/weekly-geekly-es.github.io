<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💘 👩🏻‍🤝‍👨🏼 🐗 Normes de conception de base de données ⛴️ 🐀 👨‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De projet en projet, nous sommes malheureusement confrontés au manque de normes uniformes pour la conception de bases de données, malgré le fait que S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Normes de conception de base de données</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/484188/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/pa/zj/ej/pazjejv8zvpor7tzaggxr54csd4.jpeg"></div><br>  De projet en projet, nous sommes malheureusement confrontés au manque de normes uniformes pour la conception de bases de données, malgré le fait que SQL existe depuis plusieurs décennies.  Je soupçonne que la raison est en partie due au fait que la plupart des développeurs ne comprennent pas l'architecture de la base de données.  Au cours des années de mon travail dans l'embauche de développeurs, je n'ai rencontré que plusieurs fois qui pouvaient correctement normaliser la base de données.  Honnêtement, cela peut être une tâche difficile, mais bon nombre des développeurs que j'ai interviewés, même parlant couramment SQL, n'avaient pas de compétences en conception de bases de données. <br><br>  Cet article ne traite pas de la normalisation des bases de données.  Si vous voulez apprendre cela, <a href="https://youtu.be/y1tcbhWLiUM">ici</a> je vous ai brièvement expliqué les bases. <br><br>  Si vous disposez d'une base de données fonctionnelle, vous devez répondre à la question: «quelles normes peut-on appliquer pour faciliter l' <i>utilisation de</i> cette base de données?».  Si ces normes sont largement utilisées, il vous sera alors facile d'utiliser la base de données, car vous n'avez pas à étudier et à mémoriser de nouveaux ensembles de normes chaque fois que vous commencez à travailler avec une nouvelle base de données. <br><a name="habracut"></a><br><h1>  Nommer ou souligner CamelCase? </h1><br>  Je rencontre constamment des bases de données dans lesquelles les tables sont nommées dans le style de <code>CustomerOrders</code> ou <code>customer_orders</code> .  Quel est le meilleur à utiliser?  Vous souhaitez peut-être appliquer une norme déjà établie, mais si vous créez une nouvelle base de données, je recommande d'utiliser des traits de soulignement pour augmenter l'accessibilité.  L'expression «sous-valeur» a une signification différente par rapport à «sous-évaluation», mais avec un trait de soulignement, le premier sera toujours <code>under_value</code> et le second sera <code>undervalue</code> .  Et lorsque nous utilisons CamelCase, nous obtenons <code>UnderValue</code> et <code>UnderValue</code> , qui sont identiques en termes de SQL insensible à la casse.  De plus, si vous avez des problèmes de vision et que vous expérimentez constamment des casques et des épingles pour souligner les mots, le soulignement est <i>beaucoup</i> plus facile à lire. <br><br>  Enfin, CamelCase est difficile à lire pour ceux pour qui l'anglais n'est pas natif. <br>  Pour résumer, ce n'est pas une recommandation stricte, mais une préférence personnelle. <br><br><h1>  Pluriel ou singulier dans les noms de table? </h1><br>  Les experts en théorie des bases de données se demandent depuis longtemps si les tables doivent être singulières (client) ou plurielles (clients).  Permettez-moi de couper ce nœud gordien sans aller plus loin dans la théorie, simplement avec l'aide du pragmatisme: les noms de table pluriels sont moins susceptibles d'entrer en conflit avec des mots clés réservés. <br><br>  Avez-vous des utilisateurs - des <code>users</code> ?  SQL a le mot-clé <code>user</code> .  Avez-vous besoin d'une table de contraintes?  <code>constraint</code> est un mot réservé.  Le mot <code>audit</code> <br>  réservé, mais avez-vous besoin d'une table d' <code>audit</code> ?  Utilisez simplement la forme <i>plurielle</i> des noms, et la plupart des mots réservés ne vous dérangeront pas en SQL.  Même PostgreSQL, qui possède un excellent analyseur SQL, est tombé sur la table des <code>user</code> . <br><br>  Utilisez simplement le pluriel et la probabilité de conflit sera beaucoup plus faible. <br><br><h1>  Ne nommez pas la colonne avec l'ID comme "id" </h1><br>  J'ai moi-même péché au fil des ans.  Une fois que j'ai travaillé avec un client à Paris, le DBA s'est plaint de moi quand j'ai donné le nom <code>id</code> la colonne <code>id</code> .  Je pensais qu'il n'était qu'un pédant.  En effet, le nom de colonne <code>customers.id</code> est unique, et <code>customers.customer_id</code> est une répétition d'informations. <br><br>  Et plus tard, j'ai dû déboguer ceci: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> thread.* <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> email <span class="hljs-keyword"><span class="hljs-keyword">thread</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> email selected <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> selected.id = thread.id <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> <span class="hljs-built_in"><span class="hljs-built_in">character</span></span> recipient <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> recipient.id = thread.recipient_id <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> station_area sa <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> sa.id = recipient.id <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> station st <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> st.id = sa.id <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> star origin <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> origin.id = thread.id <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> star destination <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> destination.id = st.id <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> route <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> ( route.from_id = origin.id <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> route.to_id = destination.id ) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> selected.id = ? <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ( thread.sender_id = ? <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> ( thread.recipient_id = ? <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ( origin.id = destination.id <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> ( route.distance <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>() &gt;= thread.datesent + ( route.distance * <span class="hljs-built_in"><span class="hljs-built_in">interval</span></span> <span class="hljs-string"><span class="hljs-string">'30 seconds'</span></span> ) )))) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> datesent <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span>, thread.parent_id <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span></code> </pre> <br>  Vous remarquez le problème?  Si SQL utilisait des noms d'ID complets, tels que <code>email_id</code> , <code>star_id</code> ou <code>station_id</code> , les bugs se <code>email_id</code> <code>star_id</code> <code>station_id</code> <i>ce code</i> , et pas plus tard, lorsque j'essaierai de comprendre ce que j'ai fait de mal. <br><br>  Rendez-vous service et utilisez les noms complets pour l'ID.  Merci plus tard. <br><br><h1>  Noms des colonnes </h1><br>  Donnez aux colonnes des noms aussi descriptifs que possible.  Disons que la colonne de <code>temperature</code> n'a rien à voir avec cela: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, <span class="hljs-string"><span class="hljs-string">'too cold'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> areas <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> temperature &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>;</code> </pre> <br>  J'habite en France, et pour nous une température de 32 degrés sera «trop froide».  Par conséquent, il est préférable de nommer la colonne <code>fahrenheit</code> . <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, <span class="hljs-string"><span class="hljs-string">'too cold'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> areas <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> fahrenheit &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>;</code> </pre> <br>  Maintenant, tout est complètement clair. <br><br>  Si vous avez des restrictions de clé étrangère, donnez le même nom aux colonnes des deux côtés de la restriction autant que possible.  Voici un SQL parfaitement pensé et raisonnable: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> some_table s <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> some_other_table o <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> o.owner = s.person_id;</code> </pre> <br>  Ce code est vraiment bien.  Mais lorsque vous regardez la définition de la table, vous verrez que <code>some_other_table.owner</code> a une contrainte de clé étrangère avec <code>companies.company_id</code> .  Donc, essentiellement, ce SQL est faux.  Il fallait utiliser des noms identiques: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> some_table s <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> some_other_table o <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> o.company_id = s.person_id;</code> </pre> <br>  Maintenant, il est immédiatement clair que nous avons un bogue, il vous suffit de vérifier une ligne de code et de ne pas vous référer à la définition de la table. <br><br>  Cependant, je tiens à noter que cela ne peut pas toujours être fait.  Si vous avez une table avec un entrepôt source et une destination, vous souhaiterez peut-être comparer <code>source_id</code> avec <code>destination_id</code> avec <code>warehouse_id</code> .  Dans ce cas, il vaut mieux donner les noms <code>source_warehouse_id</code> et <code>destination_warehouse_id</code> . <br><br>  Notez également que dans l'exemple ci-dessus, le <code>owner</code> décrira mieux le but que <code>company_id</code> .  Si cela vous semble déroutant, vous pouvez nommer la colonne <code>owning_company_id</code> .  Ensuite, le nom vous dira le but de la colonne. <br><br><h1>  Évitez les valeurs NULL </h1><br>  Ce conseil est connu de nombreux développeurs de bases de données expérimentés, mais, malheureusement, ils n'en parlent pas assez souvent: sans raison valable, n'autorisez pas les valeurs NULL dans la base de données. <br>  C'est un sujet important mais plutôt compliqué.  Tout d'abord, nous discutons de la théorie, puis de son effet sur l'architecture de la base de données, et en conclusion, nous analyserons un exemple pratique de problèmes graves causés par la présence de valeurs NULL. <br><br><h2>  Types de bases de données </h2><br>  La base de données peut contenir des données de différents <i>types</i> : INTEGER, JSON, DATETIME, etc. Le type est associé à la colonne et toute valeur ajoutée doit correspondre à ce type. <br><br>  Mais qu'est-ce qu'un type?  Il s'agit d'un nom, d'un ensemble de valeurs valides et d'un ensemble d'opérations valides.  Ils nous aident à éviter les comportements indésirables.  Par exemple, que se passe-t-il en Java si vous essayez de comparer une chaîne et un nombre? <br><br><pre> <code class="sql hljs">CustomerAccount.java:5: error: bad operand types for binary operator '&gt;' if ( current &gt; threshold ) { ^ first type: String second type: int</code> </pre> <br>  Même si vous ne remarquez pas que <code>current &gt; threshold</code> compare les types incomparables, le compilateur le détectera pour vous. <br><br>  Ironiquement, les bases de données qui stockent vos données - et sont votre dernière ligne de défense contre la corruption de données - fonctionnent terriblement avec les types!  Tout simplement dégoûtant.  Par exemple, si votre table <code>customers</code> a une clé de substitution, vous pouvez le faire: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, birthdate <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> customers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> customer_id &gt; weight;</code> </pre> <br>  Bien sûr, cela n'a aucun sens et en réalité, vous obtiendrez une erreur de compilation.  De nombreux langages de programmation facilitent la détection de telles erreurs de type, mais avec les bases de données, l'inverse est vrai. <br><br>  Il s'agit d'une situation normale dans le monde des bases de données, probablement parce que la <a href="https://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt">première norme SQL a été publiée en 1992</a> .  Les ordinateurs étaient lents pendant ces années, et tout ce qui compliquait la mise en œuvre ralentissait sans aucun doute les bases de données. <br><br>  Et puis les valeurs NULL apparaissent sur la scène.  Le standard SQL les a correctement implémentés en un seul endroit, dans les <code>IS NOT NULL</code> <code>IS NULL</code> et <code>IS NOT NULL</code> .  Étant donné que la valeur NULL est inconnue par définition, vous ne pouvez pas avoir d'opérateurs conçus pour elle.  Et donc il y a <code>IS NULL</code> et <code>IS NOT NULL</code> au lieu de <code>= NULL</code> et <code>!= NULL</code> .  Et toute comparaison de valeurs NULL conduit à l'apparition d'une nouvelle valeur NULL. <br><br>  Si cela vous semble étrange, ce sera beaucoup plus facile si vous écrivez «inconnu» au lieu de NULL: <br><br><blockquote>  La comparaison de valeurs inconnues <s>NULL donne</s> des valeurs inconnues <s>NULL</s> . </blockquote><br>  Ouais, maintenant je vois! <br><br><h2>  Que signifie une valeur nulle? </h2><br>  Armés des miettes de la théorie, nous considérons ses conséquences pratiques. <br><br>  Vous devez verser une prime de 500 $ à tous les employés dont le salaire pour l'année s'élève à plus de 50 000 $. Vous écrivez ce code: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> employee_number, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> employees <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> salary &gt; <span class="hljs-number"><span class="hljs-number">50000</span></span>;</code> </pre> <br>  Et vous venez d'être licencié, parce que votre patron a gagné plus de 50000 $, mais son salaire n'est pas dans la base de données (dans la colonne des salaires.NULL), et l'opérateur de comparaison ne peut pas comparer NULL avec 50000. <br><br>  Pourquoi y a-t-il NULL dans cette colonne?  Peut-être que le salaire est confidentiel.  Peut-être que les informations ne sont pas encore arrivées.  C'est peut-être un consultant qui n'est pas payé.  Peut-être qu'il a un salaire horaire, pas un salaire.  Il existe de <i>nombreuses</i> raisons pour lesquelles des données peuvent être manquantes. <br><br>  La présence ou l'absence d'informations dans la colonne suggère que cela dépend d' <i>autre</i> chose, et non de la dénormalisation de la clé primaire et de la base de données.  Ainsi, les colonnes dans lesquelles il peut y avoir des valeurs NULL sont de bons candidats pour créer de nouvelles tables.  Dans ce cas, vous pouvez avoir <code></code> tables de <code></code> , <code>_</code> <code></code> <code>_</code> , un <code>__</code> , etc. Vous êtes toujours renvoyé pour avoir combiné aveuglément les salaires et votre patron n'en ayant pas.  Mais votre base commence alors à vous fournir suffisamment d'informations pour suggérer que le problème est plus qu'un problème de salaire. <br><br>  Et oui, c'était un exemple stupide, mais c'était la dernière goutte. <br><br><h2>  Les valeurs NULL conduisent à des situations logiquement impossibles </h2><br>  Il peut vous sembler que je suis pédant par rapport aux valeurs NULL.  Cependant, regardons un autre exemple beaucoup plus proche de la réalité. <br><br>  Il y a quelques années, j'ai travaillé à Londres pour un registraire de domaine et j'ai essayé de comprendre pourquoi une requête SQL de 80 lignes renvoie des données incorrectes.  Dans cette situation, des informations auraient certainement dû être rendues, mais cela ne s'est pas produit.  J'ai honte d'admettre, mais il m'a fallu un jour pour comprendre que la raison en était une telle combinaison de conditions: <br><br><ul><li>  J'ai utilisé OUTER JOIN. <br></li><li>  Ils pourraient facilement générer des valeurs NULL. <br></li><li>  Les valeurs NULL peuvent entraîner une réponse incorrecte de SQL. <br></li></ul><br>  De nombreux développeurs ne connaissent pas ce dernier aspect, alors examinons un exemple du livre <a href="https://www.amazon.com/Database-Depth-Relational-Theory-Practitioners/dp/0596100124/">Database In Depth</a> .  Un schéma simple de deux tableaux: <br><br> <code>suppliers</code> <br> <div class="scrollable-table"><table><tbody><tr><td>  fournisseur_id <br></td><td>  ville <br></td></tr><tr><td>  s1 <br></td><td>  Londres <br></td></tr></tbody></table></div><br> <code>parts</code> <br> <br><div class="scrollable-table"><table><tbody><tr><td>  part_id <br></td><td>  ville <br></td></tr><tr><td>  p1 <br></td><td>  Null <br></td></tr></tbody></table></div><br>  Il est difficile de trouver un exemple plus simple. <br><br>  Ce code renvoie <code>p1</code> . <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> part_id <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> parts;</code> </pre> <br>  Que fera ce code? <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> part_id <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> parts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> city = city;</code> </pre> <br>  Il ne renverra rien, car vous ne pouvez pas comparer une valeur NULL, même avec un autre NULL ou le même NULL.  Cela a l'air bizarre parce que la ville sur chaque ligne devrait être la même, même si nous ne la connaissons pas, non?  Alors qu'est-ce qui retournera le code suivant?  Essayez de comprendre cela avant de continuer à lire. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> s.supplier_id, p.part_id <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> suppliers s, parts p <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> p.city &lt;&gt; s.city <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> p.city &lt;&gt; <span class="hljs-string"><span class="hljs-string">'Paris'</span></span>;</code> </pre> <br>  Nous n'avons pas reçu de chaîne en réponse, car nous ne pouvons pas comparer la ville <code>NULL</code> ( <code>p.city</code> ), et donc aucune des branches de la <code>WHERE</code> ne conduira à <code>true</code> . <br><br>  Cependant, nous savons que la ville inconnue est Paris ou non Paris.  Si c'est Paris, alors la première condition sera vraie ( <code>&lt;&gt; 'London'</code> ).  Si ce n'est pas Paris, alors la deuxième condition sera vraie ( <code>&lt;&gt; 'Paris'</code> ).  Ainsi, la <code>WHERE</code> doit être <code>true</code> , mais elle ne l'est pas et, par conséquent, SQL génère un résultat logiquement impossible. <br><br>  C'est un bug que j'ai rencontré à Londres.  Chaque fois que vous écrivez du SQL qui peut générer ou contenir des valeurs NULL, vous courez le risque d'obtenir un faux résultat.  Cela se produit rarement, mais il est très difficile à identifier. <br><br><h1>  Résumé </h1><br><ul><li>  Utilisez <code>__</code> au lieu de <code>CamelCase</code> . <br></li><li>  Les noms de table doivent être au pluriel. <br></li><li>  Donnez des noms étendus aux champs avec des identifiants ( <code>item_id</code> au lieu de <code>id</code> ). <br></li><li>  Évitez les noms de colonne ambigus. <br></li><li>  Si possible, nommez les colonnes avec des clés étrangères de la même manière que les colonnes auxquelles elles se réfèrent. <br></li><li>  Dans la mesure du possible, ajoutez NOT NULL à toutes les définitions de colonne. <br></li><li>  Dans la mesure du possible, évitez d'écrire du SQL qui peut générer des valeurs NULL. <br></li></ul><br>  Bien qu'il ne soit pas parfait, ce guide de conception de base de données vous facilitera la vie. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr484188/">https://habr.com/ru/post/fr484188/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr484176/index.html">Implémentation du modèle de statut dans Unity</a></li>
<li><a href="../fr484178/index.html">Commutateur Ethernet intelligent pour la planète Terre</a></li>
<li><a href="../fr484180/index.html">PBX virtuel Rostelecom: quoi et comment faire via l'API</a></li>
<li><a href="../fr484182/index.html">Xenobots: des nanorobots vivants issus de cellules de grenouilles</a></li>
<li><a href="../fr484186/index.html">LDAP - "l'authentification" est un contre-modèle</a></li>
<li><a href="../fr484192/index.html">Applications faciles et faciles à déployer sur la cartouche Tarantool (partie 2)</a></li>
<li><a href="../fr484194/index.html">Kubernetes traduit en enfants</a></li>
<li><a href="../fr484196/index.html">Enregistrement du son JS à partir d'un microphone ou des commentaires vocaux</a></li>
<li><a href="../fr484198/index.html">Revers de la médaille: qui a gagné et perdu sur la croissance des actions Tesla</a></li>
<li><a href="../fr484200/index.html">Comment fixer des objectifs pour les atteindre</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>