<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🤝‍👩🏼 🏽 👩‍💻 bear_hug: jeux en art ASCII en Python3.6 + 👩‍🔬 🥝 👲🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pour mes jeux en art ASCII, j'ai écrit la bibliothèque bear_hug avec une file d'attente d'événements, une collection de widgets, le support ECS et d'a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>bear_hug: jeux en art ASCII en Python3.6 +</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470950/"><img src="https://habrastorage.org/webt/b0/zu/vj/b0zuvjk4xdzcznbys9oslxl_veo.png"><br><br>  Pour mes jeux en art ASCII, j'ai écrit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la bibliothèque bear_hug</a> avec une file d'attente d'événements, une collection de widgets, le support ECS et d'autres petites choses utiles.  Dans cet article, nous verrons comment l'utiliser pour créer un jeu minimal. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Avertissements</b> <div class="spoiler_text"><ul><li>  Je suis le seul développeur de la bibliothèque, donc je peux être partial. </li><li>  bear_hug est essentiellement un wrapper autour de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bearlibterminal</a> , il n'y aura donc pas d'opérations de niveau relativement bas avec les glyphes. </li><li>  Il existe une fonctionnalité similaire dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">clubsandwich</a> , mais je ne l'ai pas utilisée et je ne peux pas la comparer. </li></ul></div></div><br>  Sous le capot de bear_hug se trouve <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bearlibterminal</a> , une bibliothèque SDL pour créer une fenêtre pseudo-console.  Autrement dit, en ATS pur, comme certains ncurses, cela ne fonctionnera pas.  Mais alors l'image est la même sous Linux, sous Windows et ne dépend pas des paramètres du terminal utilisateur.  Ceci est important, en particulier pour les jeux, car lorsque vous changez la police ASCII-art, Dieu peut bien se transformer en: <br><br><img src="https://habrastorage.org/webt/ys/rh/6f/ysrh6fhay5u9slnpwvqn53is1ek.png"><br>  <i>Le même dessin dans sa forme originale et après copier-coller dans différents programmes</i> <br><br>  Bien sûr, la bibliothèque a été écrite pour des projets de relativement grande envergure.  Mais afin de ne pas être distrait par la conception et l'architecture du jeu, dans cet article, nous allons créer quelque chose de simple.  Un projet d'une nuit, dans lequel il y a quelque chose pour montrer les fonctions de base de la bibliothèque.  A savoir - un clone simplifié de ces mêmes chars avec Dandy (ils sont également Battle City).  Il y aura un char de joueur, des chars ennemis, des murs destructibles, du son et des scores.  Mais le menu principal, les niveaux et les bonus sélectionnés ne le seront pas.  Non pas parce qu'il serait impossible de les ajouter, mais parce que ce projet n'est rien d'autre qu'un Halloworld. <br><br><img src="https://habrastorage.org/webt/8k/e7/my/8ke7mymnrejpei7isjbxtbwvyjs.png"><br>  <i>Il y aura une partie, mais il n'y aura pas de victoire.</i>  <i>Parce que la vie est douleur.</i> <br><br>  Tout le matériel utilisé dans l'article est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur le github</a> ;  la bibliothèque elle-même est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">également</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur PyPI</a> (sous licence MIT). <br><br>  Tout d'abord, nous avons besoin d'actifs.  Pour dessiner de l'art ASCII, j'utilise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">REXpaint</a> de Josh Ge (alias Kyzrati), le développeur du bagel de science-fiction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cogmind</a> .  L'éditeur est gratuit, mais pas open source;  la version officielle est uniquement pour Windows, mais tout fonctionne bien sous wine.  L'interface est assez claire et pratique: <br><br><img src="https://habrastorage.org/webt/jf/x-/bi/jfx-bigu3sedblmkuspxh_pd4d4.png"><br><br>  Nous enregistrons au format binaire local .xp et copions de <code>/path/to/rexpaint/images</code> dans le dossier avec le futur jeu.  En principe, le chargement d'images à partir de fichiers .txt est également pris en charge, mais il est évidemment impossible d'enregistrer les couleurs des caractères individuels dans un fichier texte.  Oui, et l'édition d'art ASCII dans un cahier ne me convient pas personnellement.  Afin de ne pas coder en dur les coordonnées et la taille de chaque élément, ces données sont stockées dans un fichier JSON distinct: <br><br><div class="spoiler">  <b class="spoiler_title">battlecity.json</b> <div class="spoiler_text"><pre> <code class="json hljs">[ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"player_r"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"x"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"y"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"xsize"</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ysize"</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"player_l"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"x"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"y"</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-attr"><span class="hljs-attr">"xsize"</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ysize"</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span> }, ... ]</code> </pre> <br></div></div><br>  Sons sous licences gratuites téléchargeables sur Internet.  Jusqu'à présent, seul .wav est pris en charge.  C'est tout avec des actifs, vous pouvez commencer à coder.  Tout d'abord, vous devez initialiser le terminal et la file d'attente des événements. <br><br><div class="spoiler">  <b class="spoiler_title">game.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#  terminal = BearTerminal(font_path='cp437_12x12.png', size='91x60', title='AsciiCity', filter=['keyboard', 'mouse']) #   dispatcher = BearEventDispatcher() # ,         loop = BearLoop(terminal, dispatcher)</span></span></code> </pre> <br></div></div><br>  Le terminal est la fenêtre réelle du jeu.  Vous pouvez placer des widgets dessus, et il lance <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des événements d'entrée</a> si nécessaire.  En tant que clés lors de la création d'un terminal, vous pouvez utiliser toutes les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">options</a> du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">terminal bearlibterminal</a> ;  dans ce cas, nous définissons la police, la taille de la fenêtre (en caractères), le titre de la fenêtre et les méthodes de saisie qui nous intéressent. <br><br>  Quant à la file d'attente d'événements, elle a une interface très simple: dispatcher.add_event (événement) ajoute l'événement à la file d'attente, et dispatcher.register_listener (écouteur, event_types) vous permet de vous y abonner.  Un signataire (par exemple, un widget ou un composant) doit avoir un rappel on_event, qui prend un événement comme argument unique et ne renvoie rien ou renvoie un autre événement ou un ensemble d'événements.  L'événement lui-même se compose de type et de valeur;  le type ici n'est pas dans le sens de str ou int, mais dans le sens de «variété», par exemple, «key_down» ou «tick».  La file d'attente accepte uniquement les événements de types qui lui sont connus (intégrés ou créés par l'utilisateur) et les envoie à on_event tous ceux qui souscrivent à ce type.  Il ne vérifie en aucune façon les valeurs, mais il existe des conventions au sein de la bibliothèque sur ce qui est une valeur valide pour chaque type d'événement. <br><br>  Tout d'abord, nous mettons en file d'attente quelques auditeurs.  Il s'agit de la classe de base pour les objets qui peuvent s'abonner à des événements, mais qui ne sont pas des widgets ou des composants.  En principe, il n'est pas nécessaire de l'utiliser, tant que le signataire dispose de la méthode on_event. <br><br><div class="spoiler">  <b class="spoiler_title">Auditeurs</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#       dispatcher.register_listener(ClosingListener(), ['misc_input', 'tick']) #       dispatcher.register_listener(EntityTracker(), ['ecs_create', 'ecs_destroy']) #   jukebox = SoundListener({'shot': 'shot.wav', 'explosion': 'explosion.wav'}) # https://freesound.org/people/EMSIarma/sounds/108852/ # https://freesound.org/people/FlashTrauma/sounds/398283/ dispatcher.register_listener(jukebox, 'play_sound')</span></span></code> </pre> <br></div></div><br>  Une liste complète des types d'événements intégrés se trouve <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans la documentation</a> .  Il est facile de voir qu'il y a des événements pour la création et la destruction d'entités, mais pas pour les dommages.  Puisque nous aurons des objets qui ne se séparent pas d'un seul coup (les murs et le réservoir du joueur), nous allons le créer: <br><br><div class="spoiler">  <b class="spoiler_title">Inscription au type d'événement</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      ,    #   dispatcher.register_event_type('ac_damage') #       logger = LoggingListener(sys.stderr) dispatcher.register_listener(logger, ['ac_damage', 'play_sound'])</span></span></code> </pre> <br></div></div><br>  Nous convenons que, en tant que valeur, cet événement aura un tuple à partir de l'ID de l'entité qui a subi le dommage et de la valeur du dommage.  LoggingListener est juste un outil de débogage qui imprime tous les événements reçus où qu'ils disent, dans ce cas dans stderr.  Dans ce cas, je voulais m'assurer que les dégâts passent correctement, et que le son est toujours demandé quand il le devrait. <br><br>  Avec Listeners pour l'instant, vous pouvez ajouter le premier widget.  Nous avons ce terrain de jeu de classe ECSLayout.  Il s'agit d'une telle disposition, qui peut placer des widgets sur des entités et les déplacer en réponse à des événements ecs_move, tout en tenant compte des collisions.  Comme la plupart des widgets, il a deux arguments requis: une liste imbriquée de caractères (éventuellement vide - espace ou Aucun) et une liste imbriquée de couleurs pour chaque caractère.  Les couleurs nommées sont acceptées en tant que couleurs, RVB au format `0xAARRGGBB` (ou` 0xARGB`, `0xRGB`,` 0xRRGGBB`) et au format '#fff'.  Les tailles des deux listes doivent correspondre;  sinon, une exception est levée. <br><br><div class="spoiler">  <b class="spoiler_title">Premier widget</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#   .  8460,   9160. # 7         chars = [[' ' for x in range(84)] for y in range(60)] colors = copy_shape(chars, 'gray') layout = ECSLayout(chars, colors) # 'all' -  ,      dispatcher.register_listener(layout, 'all')</span></span></code> </pre> <br></div></div><br>  Puisque nous avons maintenant sur quoi placer les objets dans le jeu, nous pouvons commencer à créer des entités.  Tout le code des entités et des composants est déplacé vers un fichier distinct.  Le plus simple d'entre eux est un mur de briques destructible.  Elle sait se trouver à un certain endroit, afficher son widget, servir d'objet de collision et subir des dégâts.  Après suffisamment de dégâts, le mur disparaît. <br><br><div class="spoiler">  <b class="spoiler_title">entity.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_wall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dispatcher, atlas, entity_id, x, y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#   wall = Entity(entity_id) #  wall.add_component(PositionComponent(dispatcher, x, y)) wall.add_component(CollisionComponent(dispatcher)) wall.add_component(PassingComponent(dispatcher)) wall.add_component(DestructorComponent(dispatcher)) #     ,      #    -  /   images_dict = {'wall_3': atlas.get_element('wall_3'), 'wall_2': atlas.get_element('wall_2'), 'wall_1': atlas.get_element('wall_1')} wall.add_component(SwitchWidgetComponent(dispatcher, SwitchingWidget(images_dict=images_dict, initial_image='wall_3'))) wall.add_component(VisualDamageHealthComponent(dispatcher, hitpoints=3, widgets_dict={3: 'wall_3', 2: 'wall_2', 1: 'wall_1'})) #     dispatcher.add_event(BearEvent('ecs_create', wall)) dispatcher.add_event(BearEvent('ecs_add', (wall.id, wall.position.x, wall.position.y)))</span></span></code> </pre> <br></div></div><br>  Tout d'abord, l'objet entité lui-même est créé.  Il ne contient qu'un nom (qui doit être unique) et un ensemble de composants.  Ils peuvent être transférés en une seule fois lors de la création ou, comme ici, ajoutés un par un.  Ensuite, tous les composants nécessaires sont créés.  En tant que widget, SwitchWidget est utilisé, qui contient plusieurs dessins de la même taille et peut les changer par commande.  Soit dit en passant, les dessins sont chargés à partir de l'atlas lors de la création d'un widget.  Et, enfin, l'annonce de la création de l'entité et l'ordre de la dessiner sur les coordonnées nécessaires vont dans la file d'attente. <br><br>  Parmi les composants non intégrés ici, uniquement la santé.  J'ai créé la classe de base «Composant de santé» et en ai hérité le «widget de changement de composant de santé» (pour montrer le mur intact et à plusieurs stades de destruction). <br><br><div class="spoiler">  <b class="spoiler_title">class HealthComponent</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HealthComponent</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Component)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, hitpoints=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super().__init__(*args, name=<span class="hljs-string"><span class="hljs-string">'health'</span></span>, **kwargs) self.dispatcher.register_listener(self, <span class="hljs-string"><span class="hljs-string">'ac_damage'</span></span>) self._hitpoints = hitpoints <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, event)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> event.event_type == <span class="hljs-string"><span class="hljs-string">'ac_damage'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> event.event_value[<span class="hljs-number"><span class="hljs-number">0</span></span>] == self.owner.id: self.hitpoints -= event.event_value[<span class="hljs-number"><span class="hljs-number">1</span></span>] @property <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hitpoints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._hitpoints @hitpoints.setter <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hitpoints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, value)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> isinstance(value, int): <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> BearECSException( <span class="hljs-string"><span class="hljs-string">f'Attempting to set hitpoints of </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{self.owner.id}</span></span></span><span class="hljs-string"> to non-integer </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{value}</span></span></span><span class="hljs-string">'</span></span>) self._hitpoints = value <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self._hitpoints &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>: self._hitpoints = <span class="hljs-number"><span class="hljs-number">0</span></span> self.process_hitpoint_update() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_hitpoint_update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Should be overridden by child classes. """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> NotImplementedError(<span class="hljs-string"><span class="hljs-string">'HP update processing should be overridden'</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#           return dumps({'class': self.__class__.__name__, 'hitpoints': self.hitpoints})</span></span></code> </pre> <br></div></div><br>  Lors de la création d'un composant, la clé 'nom' est passée à super () .__ init__.  Lorsqu'un composant est ajouté à une entité, sous le nom de cette clé, il sera ajouté au __dict__ de l'entité et il est accessible via entity_object.health.  En plus de la commodité de l'interface, cette approche est bonne car elle interdit l'émission d'entités de plusieurs composants homogènes.  Et le fait qu'il soit codé en dur à l'intérieur du composant ne vous permet pas d'insérer par erreur, par exemple, WidgetComponent dans l'emplacement du composant de santé.  Immédiatement après sa création, le composant souscrit aux classes d'événements qui l'intéressent, dans ce cas ac_damage.  Après avoir reçu un tel événement, la méthode on_event vérifiera s'il s'agit de son propriétaire pendant une heure.  Si c'est le cas, il soustraira la valeur souhaitée des points de vie et tirera le rappel pour changer la santé, la classe de base est abstraite.  Il existe également la méthode __repr__, qui est utilisée pour la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sérialisation en JSON</a> (par exemple, pour l'enregistrement).  Il n'est pas nécessaire de l'ajouter, mais tous les composants intégrés et la plupart des widgets intégrés l'ont. <br><br>  L'héritage du composant d'intégrité sous-jacent de VisualDamageHealthComponent remplace le rappel sur le changement d'intégrité: <br><br><div class="spoiler">  <b class="spoiler_title">classe VisualDamageHealthComponent</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VisualDamageHealthComponent</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(HealthComponent)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">"""       .    HP=0 """</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, widgets_dict={}, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super().__init__(*args, **kwargs) self.widgets_dict = OrderedDict() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sorted(widgets_dict.keys()): self.widgets_dict[int(x)] = widgets_dict[x] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_hitpoint_update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.hitpoints == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hasattr(self.owner, <span class="hljs-string"><span class="hljs-string">'destructor'</span></span>): self.owner.destructor.destroy() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.widgets_dict: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.hitpoints &gt;= x: self.owner.widget.switch_to_image(self.widgets_dict[x])</code> </pre> <br></div></div><br>  Alors que la santé est supérieure à 0, il demande au composant responsable du widget de dessiner le mur dans l'état souhaité.  Ici, l'appel décrit ci-dessus est utilisé via l'attribut de l'objet entité.  Une fois les repères terminés, le composant responsable de la destruction correcte de l'entité et tous les composants seront appelés de la même manière. <br><br>  Pour les autres entités, tout est similaire, seul l'ensemble des composants est différent.  Des chars sont ajoutés avec des contrôleurs (entrée pour le joueur, IA pour les adversaires) et des widgets rotatifs, pour les obus - un composant de collision qui endommage ceux qu'ils touchent.  Je n'analyserai pas chacun d'eux, car il est volumineux et plutôt trivial;  regardez seulement le collisionneur de projectiles.  Il a une méthode collided_into, appelée lorsque l'entité hôte s'est écrasée sur quelque chose: <br><br><div class="spoiler">  <b class="spoiler_title">collisionneur de composants de balle</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collided_into</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, entity)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> entity: self.owner.destructor.destroy() <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> hasattr(EntityTracker().entities[entity], <span class="hljs-string"><span class="hljs-string">'collision'</span></span>): self.dispatcher.add_event(BearEvent(event_type=<span class="hljs-string"><span class="hljs-string">'ac_damage'</span></span>, event_value=( entity, self.damage))) self.owner.destructor.destroy()</code> </pre> <br></div></div><br>  Pour s'assurer qu'il est vraiment possible d'obtenir une victime (ce qui peut être faux pour, par exemple, des éléments d'arrière-plan), le projectile utilise EntityTracker ().  Il s'agit d'un singleton qui suit toutes les entités créées et détruites;  à travers lui, vous pouvez obtenir un objet entité par son nom et faire quelque chose avec ses composants.  Dans ce cas, il est vérifié que entity.collision (le gestionnaire de collision des victimes) existe. <br><br>  Maintenant dans le fichier principal du jeu, nous appelons simplement toutes les fonctions nécessaires à la création d'entités: <br><br><div class="spoiler">  <b class="spoiler_title">Retour à game.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#  , -     atlas = Atlas(XpLoader('battlecity.xp'), 'battlecity.json') #   create_player_tank(dispatcher, atlas, 30, 50) #    wall_array = [[0 for _ in range(14)], [0 for _ in range(14)], [1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0], [1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1], [1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0], [1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0], [0 for _ in range(14)], [0 for _ in range(14)], [0 for _ in range(14)] ] for y in range(10): for x in range(14): if wall_array[y][x] == 1: create_wall(dispatcher, atlas, f'wall{x}{y}', x*6, y*6) #   -  .     . create_spawner_house(dispatcher, atlas, 35, 0)</span></span></code> </pre> <br></div></div><br>  Les marqueurs de points et de points de vie ne sont pas des entités et ne sont pas sur le champ de bataille.  Par conséquent, ils ne sont pas ajoutés à ECSLayout, mais directement au terminal à droite de la carte.  Les widgets pertinents héritent de Label (widget de sortie de texte) et disposent d'une méthode on_event pour découvrir ce qui les intéresse.  Contrairement à Layout, le terminal ne met pas automatiquement à jour les widgets à chaque tick, donc après avoir changé le texte, les widgets lui disent de faire ceci: <br><br><div class="spoiler">  <b class="spoiler_title">listeners.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScoreLabel</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Label)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">"""   """</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super().__init__(text=<span class="hljs-string"><span class="hljs-string">'Score:\n0'</span></span>) self.score = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, event)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> event.event_type == <span class="hljs-string"><span class="hljs-string">'ecs_destroy'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">'enemy'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> event.event_value <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">'bullet'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> event.event_value: <span class="hljs-comment"><span class="hljs-comment">#    self.score += 10 self.text = f'Score:\n{self.score}' self.terminal.update_widget(self) class HPLabel(Label): """   """ def __init__(self, *args, **kwargs): super().__init__(text='HP:\n5') self.hp = 5 def on_event(self, event): if event.event_type == 'ac_damage' and event.event_value[0] == 'player': self.hp -= event.event_value[1] self.text = f'HP:\n{self.hp}' self.terminal.update_widget(self)</span></span></code> </pre> <br></div></div><br>  Le générateur ennemi et l'objet responsable de la sortie de "GAME OVER" ne sont pas affichés du tout, ils héritent donc de Listener.  Le principe est le même: les objets écoutent la file d'attente, attendent le bon moment, puis créent une entité ou un widget. <br><br><div class="spoiler">  <b class="spoiler_title">gameover</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    - . . . class GameOverListener(Listener): """       """ def __init__(self, *args, widget=None, **kwargs): print (args) super().__init__(*args, *kwargs) self.widget = widget def on_event(self, event): if event.event_type == 'ecs_destroy' and event.event_value == 'player': self.terminal.add_widget(self.widget, pos=(20, 20), layer=5)</span></span></code> </pre><br></div></div><br>  Maintenant, nous avons créé tout ce dont nous avons besoin et nous pouvons commencer le jeu. <br><br><div class="spoiler">  <b class="spoiler_title">Nous lançons</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      ,   Listeners    terminal.start() terminal.add_widget(layout) terminal.add_widget(score, pos=(85, 10)) terminal.add_widget(hp, pos=(85, 15))</span></span></code> </pre> <br></div></div><br>  Les widgets sont ajoutés à l'écran uniquement après son démarrage.  Les entités pourraient être ajoutées à la carte avant - les événements de création (dans lesquels l'entité entière est stockée, y compris le widget) sont simplement accumulés dans la file d'attente et résolus au premier tick.  Mais le terminal ne peut ajouter des widgets qu'une fois qu'une fenêtre a été créée avec succès pour lui. <br><br>  À ce stade, nous avons un prototype fonctionnel, que vous pouvez <s>publier dans Early Access pour vingt dollars,</s> ajouter des fonctionnalités et peaufiner le gameplay.  Mais cela dépasse déjà le cadre de halloworld, et donc de l'article.  J'ajouterai seulement que la construction indépendante du système python peut être construite en utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pyinstaller</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr470950/">https://habr.com/ru/post/fr470950/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr470930/index.html">Gamification du produit. Historique Ratatype</a></li>
<li><a href="../fr470934/index.html">Guérit avant le mariage: prolifération cellulaire et capacités régénératrices des méduses</a></li>
<li><a href="../fr470938/index.html">Comment ouvrir un lien en Python. Travailler avec WebBrowser et résoudre un problème avec Internet Explorer</a></li>
<li><a href="../fr470940/index.html">Meetup MSK VUE.JS # 3 au groupe Mail.ru: matériaux de mitap</a></li>
<li><a href="../fr470942/index.html">Du débutant aux icônes de style: comment nous avons remporté des prix dans 2GIS</a></li>
<li><a href="../fr470952/index.html">Trucs et astuces de Digital Forensics: Forensics de l'application «Votre téléphone»</a></li>
<li><a href="../fr470954/index.html">Installez Zimbra OSE 8.8.15 et Zextras Suite Pro sur Ubuntu 18.04 LTS</a></li>
<li><a href="../fr470958/index.html">Les sondes de vitalité à Kubernetes peuvent être dangereuses</a></li>
<li><a href="../fr470962/index.html">JSConf Budapest 2019</a></li>
<li><a href="../fr470964/index.html">Jouets en bois - inscriptions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>