<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤛🏻 🦎 💧 Fitur JavaScript yang kurang dikenal 🤲🏻 💸 🤘🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="JavaScript sering disebut bahasa paling sederhana untuk pemula, dalam pemrograman yang merupakan yang paling sulit untuk dicapai penguasaannya. Penuli...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fitur JavaScript yang kurang dikenal</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/431878/">  JavaScript sering disebut bahasa paling sederhana untuk pemula, dalam pemrograman yang merupakan yang paling sulit untuk dicapai penguasaannya.  Penulis materi, terjemahan yang kami terbitkan, mengatakan bahwa ia tidak bisa tidak setuju dengan pernyataan ini.  Masalahnya adalah bahwa JS adalah bahasa yang sangat tua dan sangat fleksibel.  Ini penuh dengan konstruksi sintaksis misterius dan fitur usang yang masih didukungnya. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/bdc/ddf/340/bdcddf340ecf674873a62e6e8c38b38b.jpg" alt="gambar"></a> <br><br>  Hari ini kita akan berbicara tentang fitur dan opsi JavaScript yang kurang dikenal untuk aplikasi praktisnya. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">JavaScript selalu merupakan sesuatu yang baru</font> </h2><br>  Saya telah bekerja dengan JavaScript selama bertahun-tahun dan saya terus-menerus menemukan sesuatu yang tidak pernah saya duga ada.  Di sini saya mencoba untuk membuat daftar fitur-fitur bahasa yang kurang dikenal yang serupa.  Dalam mode ketat, beberapa dari mereka tidak akan bekerja, tetapi dalam mode normal mereka benar-benar contoh kode JS.  Perlu dicatat bahwa saya tidak menyarankan untuk menyarankan pembaca untuk mengambil semua ini ke dalam layanan.  Meskipun apa yang akan saya bicarakan tampaknya sangat menarik bagi Anda, Anda dapat mulai menggunakan semua ini jika Anda bekerja dalam tim dan, secara sederhana, mengejutkan rekan kerja Anda. <br><br>  → Kode yang akan kita bahas di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini.</a> <br><br>  Harap dicatat bahwa saya tidak memasukkan hal-hal seperti meningkatkan variabel, penutupan, objek proxy, pewarisan prototipe, async / menunggu, generator, dan sejenisnya.  Meskipun fitur-fitur bahasa ini dapat dikaitkan dengan sulit untuk dipahami, mereka tidak dikenal. <br><br><h2>  <font color="#3AC1EF">Operator batal</font> </h2><br>  JavaScript memiliki operator <code>void</code> unary.  Anda mungkin menemukan itu dalam bentuk <code>void(0)</code> atau <code>void 0</code> .  Satu-satunya tujuan adalah untuk menghitung ekspresi ke kanan dan mengembalikan yang <code>undefined</code> .  <code>0</code> sini digunakan hanya karena itu adalah kebiasaan, meskipun ini tidak perlu, dan di sini Anda dapat menggunakan ekspresi yang valid.  Benar, operator ini bagaimanapun akan kembali <code>undefined</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  void void 0                  // undefined void (0)                // undefined void 'abc'              // undefined void {}                 // undefined void (1 === 1)          // undefined void (1 !== 1)          // undefined void anyfunction()      // undefined</span></span></code> </pre> <br>  Mengapa menambahkan kata kunci khusus ke bahasa yang berfungsi mengembalikan <code>undefined</code> , jika Anda bisa menggunakan nilai standar <code>undefined</code> ?  Bukan, ada redundansi? <br><br>  Ternyata, sebelum munculnya standar ES5 di sebagian besar browser, nilai standar <code>undefined</code> dapat diberi nilai baru.  Katakanlah Anda berhasil menjalankan perintah ini: <code>undefined = "abc"</code> .  Akibatnya, nilai yang <code>undefined</code> mungkin tidak seperti yang seharusnya.  Pada masa itu, penggunaan <code>void</code> memungkinkan kami untuk memastikan kepercayaan dalam penggunaan yang sebenarnya <code>undefined</code> . <br><br><h2>  <font color="#3AC1EF">Kurung saat memanggil konstruktor adalah opsional</font> </h2><br>  Tanda kurung yang ditambahkan setelah nama kelas, memanggil konstruktor, sepenuhnya opsional (kecuali konstruktor perlu memberikan argumen). <br><br>  Dalam contoh berikut, ada atau tidaknya tanda kurung tidak memengaruhi operasi program yang benar. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     const date = new Date() const month = new Date().getMonth() const myInstance = new MyClass() //     const date = new Date const month = (new Date).getMonth() const myInstance = new MyClass</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Kurung tidak dapat digunakan dengan IIFE</font> </h2><br>  Sintaks IIFE selalu tampak aneh bagi saya.  Mengapa ada semua tanda kurung ini? <br><br>  Ternyata, tanda kurung hanya diperlukan untuk memberi tahu parser JavaScript bahwa beberapa kode adalah ekspresi fungsional, dan bukan upaya yang salah untuk mendeklarasikan fungsi.  Mengetahui fakta ini memungkinkan kita untuk memahami bahwa ada banyak cara untuk menyingkirkan tanda kurung di mana IIFE terlampir, dan pada saat yang sama menulis kode kerja. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// IIFE (function () { console.log('Normal IIFE called') })() // Normal IIFE called void function () { console.log('Cool IIFE called') }() // Cool IIFE called</span></span></code> </pre> <br>  Di sini, operator <code>void</code> memberi tahu parser bahwa kode yang mengikutinya adalah ekspresi fungsional.  Ini memungkinkan untuk menyingkirkan tanda kurung di sekitar deklarasi fungsi.  Dan omong-omong, di sini Anda dapat menggunakan operator unary ( <code>void</code> , <code>+</code> , <code>!</code> , <code>-</code> , dan sebagainya), dan kodenya akan tetap berfungsi.  Bukankah itu luar biasa? <br><br>  Namun, jika Anda seorang pembaca yang penuh perhatian, maka Anda mungkin bertanya-tanya bahwa operator yang tidak waspada mempengaruhi hasil yang dikembalikan dari IIFE.  Padahal, apa adanya.  Tetapi hal baiknya adalah jika Anda membutuhkan hasil IIFE, yang Anda, misalnya, simpan dalam variabel, maka Anda tidak perlu tanda kurung di sekitar IIFE.  Berikut ini sebuah contoh. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// IIFE,    let result = (function () { // ... -  return 'Victor Sully' })() console.log(result) // Victor Sully let result1 = function () { // ... -  return 'Nathan Drake' }() console.log(result1) // Nathan Drake</span></span></code> </pre> <br>  Kawat gigi di sekitar IIFE pertama hanya meningkatkan keterbacaan kode tanpa mempengaruhi operasinya. <br><br>  Jika Anda ingin lebih memahami IIFE, lihat materi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> . <br><br><h2>  <font color="#3AC1EF">Konstruksi dengan</font> </h2><br>  Tahukah Anda bahwa JavaScript memiliki konstruk yang mendukung blok ekspresi?  Ini terlihat seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (object)  statement <span class="hljs-comment"><span class="hljs-comment">//       with (object) {  statement  statement  ... }</span></span></code> </pre> <br>  Konstruk <code>with</code> menambahkan semua properti objek yang diteruskan ke dalamnya dalam rantai lingkup yang digunakan saat menjalankan perintah. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    with const person = { firstname: 'Nathan', lastname: 'Drake', age: 29 } with (person) { console.log(`${firstname} ${lastname} is ${age} years old`) } // Nathan Drake is 29 years old</span></span></code> </pre> <br>  <code>with</code> mungkin tampak seperti alat yang hebat.  Sepertinya ini bahkan lebih baik daripada fitur baru JS untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penghancuran objek</a> , tetapi kenyataannya tidak. <br><br>  Konstruksi <code>with</code> sudah usang dan tidak direkomendasikan untuk digunakan.  Dalam mode ketat, penggunaannya dilarang.  Ternyata <code>with</code> blok menyebabkan masalah kinerja dan keamanan. <br><br><h2>  <font color="#3AC1EF">Konstruktor fungsi</font> </h2><br>  Menggunakan kata kunci <code>function</code> bukan satu-satunya cara untuk mendefinisikan fungsi baru.  Anda dapat menetapkan fungsi secara dinamis menggunakan <code>Function</code> constructor dan operator <code>new</code> .  Ini tampilannya. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Function const multiply = new Function('x', 'y', 'return x*y') multiply(2,3) // 6</span></span></code> </pre> <br>  Argumen terakhir yang diteruskan ke konstruktor adalah string dengan kode fungsi.  Dua argumen lain adalah parameter fungsi. <br><br>  Sangat menarik untuk dicatat bahwa <code>Function</code> constructor adalah "induk" dari semua konstruktor dalam JavaScript.  Bahkan konstruktor <code>Object</code> adalah Konstruktor <code>Function</code> .  Dan konstruktor <code>Function</code> asli juga <code>Function</code> .  Akibatnya, panggilan dari objek <code>object.constructor.constructor...</code> dibuat untuk objek JS apa pun dalam jumlah yang cukup akan mengembalikan <code>Function</code> constructor sebagai hasilnya. <br><br><h2>  <font color="#3AC1EF">Properti Fitur</font> </h2><br>  Kita semua tahu bahwa fungsi dalam JavaScript adalah objek kelas satu.  Karena itu, tidak ada yang menghentikan kita dari menambahkan properti baru ke fungsi.  Ini sangat normal, tetapi ini jarang digunakan. <br><br>  Kapan ini dibutuhkan? <br><br>  Bahkan, ada beberapa situasi di mana kemampuan fitur ini mungkin berguna.  Pertimbangkan mereka. <br><br><h3>  <font color="#3AC1EF">▍ Fitur Kustom</font> </h3><br>  Misalkan kita memiliki fungsi <code>greet()</code> .  Kami membutuhkannya untuk menampilkan pesan sambutan yang berbeda tergantung pada pengaturan regional yang digunakan.  Pengaturan ini dapat disimpan dalam variabel eksternal ke fungsi.  Selain itu, fungsi tersebut mungkin memiliki properti yang mendefinisikan pengaturan ini, khususnya, pengaturan bahasa pengguna.  Kami akan menggunakan pendekatan kedua. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,   function greet () { if (greet.locale === 'fr') {   console.log('Bonjour!') } else if (greet.locale === 'es') {   console.log('Hola!') } else {   console.log('Hello!') } } greet() // Hello! greet.locale = 'fr' greet() // Bonjour!</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍Fungsi dengan variabel statis</font> </h3><br>  Berikut adalah contoh serupa lainnya.  Misalkan kita perlu mengimplementasikan generator tertentu yang menghasilkan urutan nomor yang dipesan.  Biasanya dalam situasi seperti itu, untuk menyimpan informasi tentang nomor yang dihasilkan terakhir, variabel penghitung statis di kelas atau IIFE digunakan.  Dengan pendekatan ini, kami membatasi akses ke konter dan mencegah polusi ruang lingkup global dengan variabel tambahan. <br><br>  Tetapi bagaimana jika kita membutuhkan fleksibilitas, jika kita perlu membaca atau bahkan memodifikasi nilai penghitung seperti itu dan tidak menyumbat ruang lingkup global? <br><br>  Tentu saja, Anda bisa membuat kelas dengan variabel yang sesuai dan dengan metode yang memungkinkan Anda untuk bekerja dengannya.  Atau Anda tidak dapat repot-repot dengan hal-hal seperti itu dan hanya menggunakan properti fungsi. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,   function generateNumber () { if (!generateNumber.counter) {   generateNumber.counter = 0 } return ++generateNumber.counter } console.log(generateNumber()) // 1 console.log(generateNumber()) // 2 console.log('current counter value: ', generateNumber.counter) // current counter value: 2 generateNumber.counter = 10 console.log('current counter value: ', generateNumber.counter) // current counter value: 10 console.log(generateNumber()) // 11</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Properti objek argumen</font> </h2><br>  Saya yakin sebagian besar dari Anda tahu bahwa fungsi memiliki objek <code>arguments</code> .  Ini adalah objek mirip array yang dapat diakses dalam semua fungsi (dengan pengecualian fungsi panah, yang tidak memiliki objek <code>arguments</code> sendiri).  Ini berisi daftar argumen yang diteruskan ke fungsi saat dipanggil.  Selain itu, ia memiliki beberapa properti menarik: <br><br><ul><li>  <code>arguments.callee</code> berisi tautan ke fungsi saat ini. </li><li>  <code>arguments.caller</code> berisi referensi ke fungsi yang disebut fungsi saat ini. </li></ul><br>  Pertimbangkan sebuah contoh. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  callee  caller  arguments const myFunction = function () { console.log('Current function: ', arguments.callee.name) console.log('Invoked by function: ', arguments.callee.caller.name) } void function main () { myFunction() } () // Current function: myFunction // Invoked by function: main</span></span></code> </pre> <br>  Standar ES5 melarang penggunaan properti <code>callee</code> dan <code>caller</code> dalam mode ketat, tetapi mereka masih banyak ditemukan di banyak teks program yang dikompilasi JavaScript, misalnya, di perpustakaan.  Karena itu, berguna untuk mengetahui tentang mereka. <br><br><h2>  <font color="#3AC1EF">Literal Templat Tagged</font> </h2><br>  Tentunya Anda, jika Anda ada hubungannya dengan pemrograman JavaScript, telah mendengar tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">templat literal</a> .  Templat literal adalah salah satu dari banyak inovasi hebat dari standar ES6.  Namun, apakah Anda tahu tentang literal templat yang ditandai? <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    `Hello ${username}!` //    myTag`Hello ${username}!`</span></span></code> </pre> <br>  Literal templat yang ditandai memungkinkan pengembang untuk mengontrol bagaimana literal templat berubah menjadi string.  Ini dilakukan dengan menggunakan tag khusus.  Tag hanyalah nama fungsi pengurai yang menerima larik string dan nilai yang ditafsirkan oleh pola string.  Saat menggunakan fungsi tag, diharapkan akan mengembalikan string yang sudah selesai. <br><br>  Dalam contoh berikut, tag kami, <code>highlight</code> , menginterpretasikan data dari templat literal dan menyematkan data ini dalam baris yang sudah jadi, menempatkannya dalam tag <code>&lt;mark&gt;</code> HTML untuk memilihnya ketika teks tersebut ditampilkan pada halaman web. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    function highlight(strings, ...values) { //  i -      let result = '' strings.forEach((str, i) =&gt; {   result += str   if (values[i]) {     result += `&lt;mark&gt;${values[i]}&lt;/mark&gt;`   } }) return result } const author = 'Henry Avery' const statement = `I am a man of fortune &amp; I must seek my fortune` const quote = highlight`${author} once said, ${statement}` // &lt;mark&gt;Henry Avery&lt;/mark&gt; once said, &lt;mark&gt;I am a man of fortune // &amp; I must seek my fortune&lt;/mark&gt;</span></span></code> </pre> <br>  Cara menarik untuk menggunakan fitur ini dapat ditemukan di banyak perpustakaan.  Berikut ini beberapa contohnya: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komponen gaya</a> - untuk digunakan dalam aplikasi Bereaksi. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">es2015-i18n-tag</a> - untuk terjemahan dan internasionalisasi proyek. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">chalk</a> - untuk menampilkan pesan multi-warna ke konsol. </li></ul><br><h2>  <font color="#3AC1EF">Getters and Setters di ES5</font> </h2><br>  Objek JavaScript, sebagian besar, cukup sederhana.  Misalkan kita memiliki objek <code>user</code> , dan kami mencoba mengakses properti <code>age</code> menggunakan konstruk <code>user.age</code> .  Dengan pendekatan ini, jika properti ini didefinisikan, kami akan mendapatkan nilainya, dan jika tidak didefinisikan, kami akan <code>undefined</code> .  Semuanya sangat sederhana. <br><br>  Tetapi bekerja dengan properti tidak harus begitu primitif sama sekali.  Objek JS menerapkan konsep getter dan setter.  Alih-alih langsung mengembalikan nilai beberapa properti objek, kita dapat menulis fungsi pengambil kita sendiri, yang mengembalikan apa yang kita anggap perlu.  Hal yang sama berlaku untuk menulis nilai baru ke properti menggunakan fungsi setter. <br><br>  Getters dan setter memungkinkan Anda untuk menerapkan skema canggih untuk bekerja dengan properti.  Saat membaca atau menulis properti, Anda dapat menggunakan konsep bidang virtual, Anda dapat memeriksa nilai-nilai bidang, dan ketika menulis atau membaca, beberapa efek samping yang bermanfaat dapat terjadi. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    const user = { firstName: 'Nathan', lastName: 'Drake', // fullname -    get fullName() {   return this.firstName + ' ' + this.lastName }, //      set age(value) {   if (isNaN(value)) throw Error('Age has to be a number')   this._age = Number(value) }, get age() {   return this._age } } console.log(user.fullName) // Nathan Drake user.firstName = 'Francis' console.log(user.fullName) // Francis Drake user.age = '29' console.log(user.age) // 29 // user.age = 'invalid text' // Error: Age has to be a number</span></span></code> </pre> <br>  Getters dan setter bukan inovasi standar ES5.  Mereka selalu hadir dalam bahasa tersebut.  Dalam ES5, hanya alat sintaks yang nyaman telah ditambahkan untuk bekerja dengannya.  Detail tentang getter dan setter dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Contoh penggunaan getter termasuk pustaka Node.js <a href="">Colors yang</a> populer. <br><br>  Pustaka ini <a href="">memperluas kelas String</a> dan menambahkan banyak metode pengambil untuk itu.  Ini memungkinkan Anda untuk mengkonversi string ke versi “berwarna” sehingga string ini kemudian dapat digunakan untuk logging.  Ini dilakukan dengan bekerja dengan <a href="">properti</a> string. <br><br><h2>  <font color="#3AC1EF">Operator koma</font> </h2><br>  JS memiliki operator koma.  Ini memungkinkan Anda untuk menulis beberapa ekspresi dalam satu baris, dipisahkan oleh koma, dan mengembalikan hasil evaluasi dari ekspresi terakhir.  Seperti apa desainnya. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = expression1, expression2,... expressionN</code> </pre> <br>  Di sini, nilai semua ekspresi akan dihitung, setelah itu nilai ekspresiN akan masuk ke dalam variabel <code>result</code> . <br><br>  Ada kemungkinan bahwa Anda telah menggunakan operator koma <code>for</code> loop. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">0</span></span>, b = <span class="hljs-number"><span class="hljs-number">10</span></span>; a &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span>; a++, b--)</code> </pre> <br>  Terkadang operator ini sangat berguna ketika Anda perlu menulis banyak ekspresi pada baris yang sama. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNextValue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counter++, <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(counter), counter }</code> </pre> <br>  Ini bisa berguna saat mendesain fungsi panah kecil. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getSquare = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log (x), x * x)</code> </pre> <br><h2>  <font color="#3AC1EF">Operator plus</font> </h2><br>  Jika Anda perlu dengan cepat mengubah string menjadi angka, operator plus berguna bagi Anda.  Dia mampu bekerja dengan berbagai angka, dan tidak hanya, sepertinya, dengan yang positif.  Kita berbicara tentang angka negatif, oktal, heksadesimal, dan angka dalam notasi eksponensial.  Selain itu, ia dapat mengubah objek <code>Date</code> dan objek perpustakaan Moment.js menjadi cap waktu. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  "" +'9.11'          // 9.11 +'-4'            // -4 +'0xFF'          // 255 +true            // 1 +'123e-5'        // 0.00123 +false           // 0 +null            // 0 +'Infinity'      // Infinity +'1,234'         // NaN +new Date      // 1542975502981 ( ) +momentObject    // 1542975502981 ( )</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Tanda seru ganda</font> </h2><br>  Perlu dicatat bahwa apa yang kadang-kadang disebut "operator tanda seru ganda" (Bang Bang atau Double Bang) sebenarnya bukan operator.  Ini adalah operator NOT logis, atau operator negasi logis yang terlihat seperti tanda seru diulang dua kali.  Titik seru ganda baik karena memungkinkan Anda untuk mengubah ekspresi apa pun menjadi nilai boolean.  Jika ekspresi, dari sudut pandang JS, benar - setelah memprosesnya dengan tanda seru ganda, <code>true</code> akan dikembalikan.  Jika tidak, <code>false</code> akan dikembalikan. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     !!null            // false !!undefined       // false !!false           // false !!true            // true !!""              // false !!"string"        // true !!0               // false !!1               // true !!{}              // true !![]              // true</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Operator negasi bitwise</font> </h2><br>  Mari kita hadapi itu: tidak ada yang peduli dengan operator bitwise.  Saya tidak berbicara tentang menggunakannya.  Namun, operator negasi bitwise dapat digunakan dalam banyak situasi. <br><br>  Ketika operator ini diterapkan ke angka, itu mengubahnya sebagai berikut: dari nomor <code>N</code> ternyata <code>-(N+1)</code> .  Ungkapan seperti itu memberi <code>0</code> jika <code>N</code> adalah <code>-1</code> . <br><br>  Fitur ini dapat digunakan dengan metode <code>indexOf()</code> ketika digunakan untuk memeriksa keberadaan elemen dalam array atau string, karena metode ini, tidak menemukan elemen, mengembalikan <code>-1</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      indexOf let username = "Nathan Drake" if (~username.indexOf("Drake")) { console.log('Access denied') } else { console.log('Access granted') }</span></span></code> </pre> <br>  Perlu dicatat bahwa dalam standar ES6 dan ES7, masing-masing, untuk string dan array, metode <code>includes()</code> telah muncul.  Jelas jauh lebih nyaman untuk menentukan keberadaan elemen daripada menggunakan operator negasi bitwise dan <code>indexOf()</code> . <br><br><h2>  <font color="#3AC1EF">Blok bernama</font> </h2><br>  JavaScript memiliki konsep label, yang dengannya Anda dapat menetapkan nama (label) ke loop.  Anda kemudian dapat menggunakan label ini untuk merujuk ke loop yang sesuai saat menerapkan pernyataan <code>break</code> atau <code>continue</code> .  Label juga dapat ditugaskan untuk blok kode biasa. <br><br>  Loop berlabel berguna saat bekerja dengan loop bersarang.  Tetapi mereka juga dapat digunakan untuk mengatur kode dengan mudah di blok atau saat membuat blok di mana kode dapat terputus. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    declarationBlock: { //       //     var i, j } forLoop1: //     - "forLoop1" for (i = 0; i &lt; 3; i++) {       forLoop2: //     -  "forLoop2"  for (j = 0; j &lt; 3; j++) {       if (i === 1 &amp;&amp; j === 1) {        continue forLoop1     }     console.log('i = ' + i + ', j = ' + j)  } } /* i = 0, j = 0 i = 0, j = 1 i = 0, j = 2 i = 1, j = 0 i = 2, j = 0 i = 2, j = 1 i = 2, j = 2 */ //      loopBlock4: { console.log('I will print') break loopBlock4 console.log('I will not print') } // I will print</span></span></code> </pre> <br>  Perhatikan bahwa, tidak seperti beberapa bahasa lain, tidak ada <code>goto</code> di JS.  Akibatnya, label hanya digunakan dengan pernyataan <code>break</code> dan <code>continue</code> . <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Pada artikel ini, kita berbicara tentang fitur JavaScript yang kurang dikenal, pengetahuan yang berguna bagi setiap programmer JS, setidaknya untuk siap untuk memenuhi sesuatu yang tidak biasa dalam kode orang lain.  Jika topik "JS tidak dikenal" menarik bagi Anda, Anda dapat melihat publikasi kami ini. <br><br>  <b>Pembaca yang budiman!</b>  Jika Anda tahu tentang beberapa fitur JS yang tidak banyak diketahui dan melihat opsi untuk aplikasi praktisnya, silakan beri tahu kami. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id431878/">https://habr.com/ru/post/id431878/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id431868/index.html">Jam pada lampu pelepasan gas (GRI), mereka adalah jam Nixie</a></li>
<li><a href="../id431870/index.html">Pengembang buku interaktif dengan LED mengeluh tentang pencurian ide oleh karyawan Google</a></li>
<li><a href="../id431872/index.html">Panduan JavaScript Bagian 9: Tinjauan Umum tentang Standar ES7, ES8, dan ES9</a></li>
<li><a href="../id431874/index.html">Imba: Bahasa yang kompatibel dengan JavaScript untuk kerja cepat dengan DOM</a></li>
<li><a href="../id431876/index.html">Optimalisasi aplikasi Angular</a></li>
<li><a href="../id431880/index.html">Doom of SceneKit. Pengalaman Yandex dengan grafik 3D di iOS</a></li>
<li><a href="../id431884/index.html">Microsoft melampaui Apple dalam kapitalisasi pasar: bagaimana ini terjadi?</a></li>
<li><a href="../id431886/index.html">Al Lowy mengunggah koleksi kode sumbernya untuk produk Sierra di eBay</a></li>
<li><a href="../id431888/index.html">“Saya pikir ide tim adalah yang paling penting ketika mengembangkan suatu produk.”</a></li>
<li><a href="../id431890/index.html">Cara melakukan pemesanan di bursa lepas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>