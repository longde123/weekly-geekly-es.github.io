<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎂 😇 👩🏾‍🔬 OOP sudah mati, umur panjang OOP 💦 👩🏿‍🤝‍👩🏾 🏂🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sumber inspirasi 
 Posting ini muncul berkat publikasi terbaru oleh Aras Prantskevichus tentang laporan yang ditujukan untuk programmer junior. Ini be...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OOP sudah mati, umur panjang OOP</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441174/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d22/8c2/d99/d228c2d99b9b17da94979d7fc5f728ee.png" alt="gambar"></div><br><h1>  Sumber inspirasi </h1><br>  Posting ini muncul berkat publikasi terbaru oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">Aras Prantskevichus</a> tentang laporan yang ditujukan untuk programmer junior.  Ini berbicara tentang bagaimana beradaptasi dengan arsitektur ECS baru.  Aras mengikuti pola yang biasa ( <em>penjelasan di bawah</em> ): menunjukkan contoh kode OOP yang mengerikan, dan kemudian menunjukkan bahwa model relasional ( <em>tetapi menyebutnya "ECS" daripada relasional</em> ) adalah alternatif yang bagus.  Tidak berarti saya mengkritik Aras - Saya penggemar berat karyanya dan memuji dia untuk presentasinya yang luar biasa!  Saya memilih presentasinya daripada ratusan posting lain tentang ECS ​​dari Internet karena dia melakukan upaya ekstra dan menerbitkan repositori git untuk belajar secara paralel dengan presentasi.  Ini berisi "permainan" kecil sederhana, digunakan sebagai contoh pemilihan solusi arsitektur yang berbeda.  Proyek kecil ini memungkinkan saya untuk menunjukkan komentar saya pada materi tertentu, jadi terima kasih, Aras! <br><br>  Slide Aras tersedia di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">http://aras-p.info/texts/files/2018Academy - ECS-DoD.pdf</a> , dan kode ini ada di github: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">https://github.com/aras-p/dod-playground</a> . <br><br>  Saya tidak akan (belum?) Menganalisis arsitektur ECS yang dihasilkan dari laporan ini, tetapi fokus pada kode "OOP buruk" (mirip dengan trik boneka) dari awal.  Saya akan menunjukkan bagaimana itu akan terlihat jika semua pelanggaran prinsip OOD (desain berorientasi objek, desain berorientasi objek) diperbaiki dengan benar. <br><br>  <strong>Spoiler: menghilangkan semua pelanggaran OOD mengarah pada peningkatan kinerja yang mirip dengan konversi Aras ke ECS, ini juga menggunakan lebih sedikit RAM dan membutuhkan lebih sedikit baris kode daripada versi ECS!</strong> <br><br>  <em>TL; DR: Sebelum menyimpulkan bahwa OOP menyebalkan dan drive ECS, berhenti sebentar dan periksa OOD (untuk mengetahui cara menggunakan OOP dengan benar), dan juga memahami model relasional (untuk mengetahui cara menerapkan ECS dengan benar).</em> <br><a name="habracut"></a><br>  Saya telah mengambil bagian dalam banyak diskusi tentang ECS ​​di forum untuk waktu yang lama, sebagian karena saya tidak berpikir model ini layak ada sebagai istilah terpisah ( <em>spoiler: ini hanya versi ad-hoc dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">model relasional</a></em> ), tetapi juga karena hampir <em>setiap</em> posting, presentasi, atau artikel yang mempromosikan pola ECS mengikuti struktur berikut: <br><br><ol><li>  Tunjukkan contoh kode OOP yang mengerikan, implementasi yang memiliki kekurangan yang mengerikan karena penggunaan warisan yang berlebihan (yang berarti bahwa implementasi ini melanggar banyak prinsip OOD). <br></li><li>  Untuk menunjukkan bahwa komposisi adalah solusi yang lebih baik daripada warisan (dan tidak menyebutkan bahwa OOD sebenarnya memberi kita pelajaran yang sama). <br></li><li>  Tunjukkan bahwa model relasional sangat bagus untuk game (tetapi sebut saja "ECS"). </li></ol><br>  Struktur seperti itu membuat saya marah karena: <strong>(A)</strong> ini adalah trik "diisi" ... membandingkan lembut ke hangat (kode buruk dan kode baik) ... dan ini tidak adil, bahkan jika dilakukan secara tidak sengaja dan tidak diharuskan untuk menunjukkan bahwa arsitektur baru itu baik;  dan, yang lebih penting: <strong>(B)</strong> ia memiliki efek samping - pendekatan semacam itu menekan pengetahuan dan secara tidak sengaja mendemotivasi pembaca dari kenalan dengan studi yang dilakukan selama setengah abad.  Mereka mulai menulis tentang model relasional pada 1960-an.  Sepanjang 70-an dan 80-an, model ini telah meningkat secara signifikan.  Pemula sering memiliki pertanyaan seperti " <em>kelas apa yang Anda inginkan untuk memasukkan data ini?</em> ", Dan sebagai tanggapan mereka sering mengatakan sesuatu yang kabur, seperti " <em>Anda hanya perlu mendapatkan pengalaman dan kemudian Anda hanya belajar untuk memahami ke dalam</em> " ... tetapi di tahun 70-an pertanyaan ini aktif dipelajari dan dalam kasus umum jawaban formal disimpulkan;  ini disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">normalisasi basis data</a> .  Membuang penelitian yang ada dan menyebut ECS solusi yang benar-benar baru dan modern, Anda menyembunyikan pengetahuan ini dari pemula. <br><br>  Dasar-dasar pemrograman berorientasi objek diletakkan seperti dulu, jika tidak sebelumnya ( <em>gaya ini mulai dieksplorasi dalam karya tahun 1950-an</em> )!  Namun, pada 1990-an orientasi objek menjadi modis, viral, dan sangat cepat berubah menjadi paradigma pemrograman yang dominan.  Ledakan popularitas banyak bahasa OO baru, termasuk Java dan ( <em>versi standar</em> ) C ++, telah terjadi.  Namun, karena ini adalah hype, semua orang <em>perlu</em> mengetahui konsep profil tinggi ini untuk menulis di resume mereka, tetapi hanya sedikit yang benar-benar memahaminya.  Bahasa-bahasa baru ini menciptakan kata kunci - <em>kelas</em> , <em>virtual</em> , <em>perluasan</em> , <em>implementasi</em> - dari banyak fitur OO, dan saya percaya itulah sebabnya pada saat itu OO dibagi menjadi dua entitas terpisah yang menjalani kehidupan mereka sendiri. <br><br>  Saya akan merujuk pada penggunaan fitur bahasa yang terinspirasi OO ini sebagai " <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">OOP</a></strong> " dan penggunaan teknik desain / arsitektur yang terinspirasi OO " <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">OOD</a></strong> ".  Semua dengan sangat cepat mengambil OOP.  Lembaga pendidikan memiliki kursus OO yang memanggang programmer OOP baru ... namun, pengetahuan tentang OOD masih tertinggal. <br><br>  Saya percaya bahwa kode yang menggunakan fitur bahasa OOP, tetapi tidak mengikuti prinsip-prinsip desain OOD, <strong>bukan kode OO</strong> .  Kebanyakan kritik terhadap penggunaan OOP misalnya kode gutted, yang sebenarnya bukan kode OO. <br><br>  Kode OOP memiliki reputasi yang sangat buruk, dan khususnya karena sebagian besar kode OOP tidak mengikuti prinsip-prinsip OOD, dan karenanya bukan kode OO yang “benar”. <br><br><h1>  Latar belakang </h1><br>  Seperti yang dinyatakan di atas, tahun 1990-an menjadi puncak "mode OO," dan pada saat itulah "OOP buruk" mungkin yang terburuk.  Jika Anda mempelajari OOP pada saat itu, maka kemungkinan besar Anda mempelajari tentang "empat pilar OOP": <br><br><ul><li>  Abstraksi </li><li>  Enkapsulasi </li><li>  Polimorfisme </li><li>  Warisan </li></ul><br>  Saya lebih suka menyebut mereka bukan empat pilar, tetapi "empat alat OOP".  Ini adalah alat yang <em><strong>dapat Anda</strong></em> gunakan untuk menyelesaikan masalah.  Namun, itu tidak cukup hanya untuk mengetahui bagaimana alat ini bekerja, Anda perlu tahu kapan <strong><em>harus</em></strong> menggunakannya ... Pada bagian guru, tidak bertanggung jawab untuk mengajarkan orang-orang alat baru, tidak memberi tahu mereka kapan masing-masing dari mereka layak digunakan.  Pada awal 2000-an, ada resistensi terhadap penyalahgunaan aktif alat ini, semacam "gelombang kedua" pemikiran OOD.  Hasilnya adalah munculnya mnemonik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">SOLID</a> , yang menyediakan cara cepat untuk mengevaluasi kekuatan arsitektur.  Perlu dicatat bahwa kebijaksanaan ini sebenarnya tersebar luas di tahun 90-an, tetapi belum menerima akronim keren, yang memungkinkan mereka untuk diperbaiki sebagai lima prinsip dasar ... <br><br><ul><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">Prinsip tanggung jawab tunggal</a></strong> ( <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">prinsip tanggung jawab tunggal</a></strong> ).  Setiap kelas seharusnya hanya memiliki satu alasan untuk perubahan.  Jika kelas "A" memiliki dua tanggung jawab, maka Anda perlu membuat kelas "B" dan "C" untuk memproses masing-masing secara individual, dan kemudian membuat "A" dari "B" dan "C". </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">Prinsip keterbukaan / penutupan</a></strong> ( <b>O</b> pen / prinsip tertutup).  Perangkat lunak berubah seiring waktu ( <em>mis. Dukungannya penting</em> ).  Cobalah untuk menempatkan bagian-bagian yang paling mungkin berubah dalam <em>implementasi (</em> <em>mis., Di kelas-kelas tertentu</em> ) dan membuat <em>antarmuka</em> berdasarkan bagian-bagian yang tidak mungkin berubah ( <em>misalnya, kelas dasar abstrak</em> ). <br></li><li>  Prinsip substitusi <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">Barbara Liskov</a></strong> .  Setiap implementasi antarmuka harus 100% memenuhi persyaratan antarmuka ini, mis.  algoritma apa pun yang bekerja dengan antarmuka harus bekerja dengan implementasi apa pun. </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">Prinsip pemisahan antarmuka</a></strong> ( <b>I</b> nterface segregation principle).  Buat antarmuka sekecil mungkin sehingga setiap bagian dari kode "tahu" tentang jumlah basis kode terkecil, misalnya, menghindari ketergantungan yang tidak perlu.  Tip ini juga bagus untuk C ++, di mana waktu kompilasi menjadi besar jika Anda tidak mengikutinya. </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">Prinsip inversi dependensi</a></strong> (prinsip inversi <b>D</b> dependensi).  Alih-alih dua implementasi spesifik yang berkomunikasi langsung (dan saling bergantung), mereka biasanya dapat dipisahkan dengan memformalkan antarmuka komunikasi mereka sebagai kelas ketiga, yang digunakan sebagai antarmuka di antara mereka.  Ini bisa menjadi kelas dasar abstrak yang mendefinisikan panggilan metode yang digunakan di antara mereka, atau bahkan hanya struktur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">POD</a> yang mendefinisikan data yang ditransfer di antara mereka. </li><li>  Prinsip lain tidak termasuk dalam akronim SOLID, tetapi saya yakin itu sangat penting: <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">"Lebih suka komposisi daripada warisan"</a></strong> (Prinsip penggunaan kembali komposit).  Komposisi <em>adalah pilihan yang tepat secara default</em> .  Warisan harus diserahkan untuk kasus-kasus ketika itu benar-benar diperlukan. </li></ul><br>  Jadi kami mendapatkan SOLID-C (++) <img alt=":)" height="20" src="https://habrastorage.org/getpro/habr/post_images/e8d/c8c/1e8/e8dc8c1e846d52073e8f2a944b2006fa.png" width="20"><br><br>  Di bawah ini saya akan merujuk pada prinsip-prinsip ini, menyebutnya akronim - SRP, OCP, LSP, ISP, DIP, CRP ... <br><br>  Beberapa catatan lagi: <br><br><ul><li>  Dalam OOD, konsep <em>antarmuka</em> dan <em>implementasi</em> tidak dapat dikaitkan dengan kata kunci OOP tertentu.  Di C ++, kita sering membuat antarmuka dengan <em>kelas dasar abstrak</em> dan <em>fungsi virtual</em> , dan kemudian <em>implementasi yang</em> diwarisi dari kelas dasar ini ... tapi ini hanya satu cara khusus untuk menerapkan prinsip antarmuka.  Dalam C ++, kita juga dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">PIMPL</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">pointer buram</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">mengetik bebek</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">mengetik</a> , dll ... Anda dapat membuat struktur OOD dan kemudian menerapkannya dalam C, di mana tidak ada kata kunci bahasa OOP sama sekali!  Jadi ketika saya berbicara tentang <em>antarmuka</em> , saya tidak harus berarti fungsi <em>virtual</em> - saya berbicara tentang prinsip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">menyembunyikan implementasi</a> .  Antarmuka <em>bisa</em> bersifat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">polimorfik</a> , tetapi lebih sering daripada tidak!  Polimorfisme sangat jarang digunakan dengan benar, tetapi antarmuka adalah konsep dasar untuk semua perangkat lunak. <br><ul><li>  Seperti yang saya jelaskan di atas, jika Anda membuat struktur POD yang hanya menyimpan beberapa data untuk transmisi dari satu kelas ke kelas lain, maka struktur ini digunakan sebagai <em>antarmuka</em> - ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">deskripsi</a> formal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">data</a> . <br></li><li>  Bahkan jika Anda hanya membuat satu kelas terpisah dengan bagian <em>publik</em> dan <em>pribadi</em> , maka semua yang ada di bagian umum adalah <em>antarmuka</em> , dan segala sesuatu di bagian pribadi adalah <em>implementasi</em> . </li></ul></li><li>  Warisan sebenarnya memiliki (setidaknya) dua jenis - warisan antarmuka dan warisan implementasi. <br><ul><li>  Dalam C ++, warisan antarmuka termasuk kelas dasar abstrak dengan fungsi virtual murni, PIMPL, typedef bersyarat.  Di Jawa, pewarisan antarmuka diekspresikan melalui kata kunci <em>implement</em> . </li><li>  Dalam C ++, warisan implementasi terjadi setiap kali kelas dasar berisi sesuatu selain fungsi virtual murni.  Di Jawa, warisan implementasi dinyatakan menggunakan <em>kata kunci extends</em> . </li><li>  OOD memiliki banyak aturan untuk mewarisi antarmuka, tetapi warisan implementasi biasanya layak dipertimbangkan sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">"kode dengan gigitan"</a> ! </li></ul></li></ul><br>  Dan akhirnya, saya harus menunjukkan beberapa contoh pelatihan OOP yang mengerikan dan bagaimana hal itu mengarah pada kode buruk dalam kehidupan nyata (dan reputasi OOP yang buruk). <br><br><ol><li>  Ketika Anda diajarkan hierarki / warisan, Anda mungkin telah diberi tugas yang sama: <strong><em>Misalkan Anda memiliki aplikasi universitas yang berisi direktori siswa dan staf.</em></strong>  <strong><em>Anda bisa membuat kelas dasar Person, dan kemudian kelas Student dan kelas Staff, diwarisi dari Person.</em></strong> <br><br>  Tidak, tidak, tidak.  Di sini saya akan menghentikan Anda.  Implikasi tak terucapkan dari prinsip LSP adalah bahwa <em>hierarki kelas</em> dan <em>algoritma yang memprosesnya</em> adalah simbiosis.  Ini adalah dua bagian dari keseluruhan program.  OOP adalah perpanjangan dari pemrograman prosedural, dan itu terutama terkait dengan prosedur ini.  Jika kita tidak tahu jenis algoritma apa yang akan bekerja dengan <i>Siswa</i> dan <em>Staf</em> ( <em>dan algoritma mana yang akan disederhanakan karena polimorfisme</em> ), maka akan sepenuhnya tidak bertanggung jawab untuk mulai membuat struktur hierarki kelas.  Pertama, Anda perlu mengetahui algoritma <em>dan</em> data. </li><li>  Ketika Anda diajarkan hierarki / warisan, Anda mungkin diberikan tugas yang sama: <b><i>Misalkan Anda memiliki kelas bentuk.</i></b>  <b><i>Kami juga memiliki kotak dan persegi panjang sebagai subclass.</i></b>  <b><i>Haruskah persegi menjadi persegi panjang, atau persegi panjang persegi?</i></b> <br><br>  Ini sebenarnya adalah contoh yang baik untuk menunjukkan perbedaan antara warisan implementasi dan warisan antarmuka. <br><ul><li>  Jika Anda menggunakan pendekatan warisan implementasi, maka Anda sepenuhnya mengabaikan LSP dan, dari sudut pandang praktis, pikirkan tentang kemungkinan menggunakan kembali kode menggunakan warisan sebagai alat. <br><br>  Dari sudut pandang ini, berikut ini sangat logis: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Square</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rectangle</span></span></span><span class="hljs-class"> :</span></span> Square { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height; };</code> </pre> <br>  Persegi hanya memiliki lebar, dan persegi panjang memiliki lebar + tinggi, yaitu, memperluas persegi dengan komponen tinggi, kita mendapatkan persegi panjang! <br><ul><li>  Seperti yang mungkin sudah Anda duga, OOD mengatakan bahwa melakukan ini ( <em>mungkin</em> ) salah.  Saya mengatakan <em>"mungkin"</em> karena di sini Anda dapat berdebat tentang karakteristik antarmuka yang tersirat ... oh well. <br><br>  Kotak selalu memiliki tinggi dan lebar yang sama, jadi dari antarmuka kotak itu benar untuk mengasumsikan bahwa area tersebut “lebar * lebar”. <br><br>  Mewarisi dari persegi, kelas persegi panjang (menurut LSP) <strong>harus</strong> mematuhi aturan antarmuka persegi.  Algoritma apa pun yang bekerja dengan benar untuk persegi juga harus bekerja dengan benar untuk persegi panjang. </li><li>  Ambil algoritma lain: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Square*&gt; shapes; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> area = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> s : shapes) area += s-&gt;width * s-&gt;width;</code> </pre> <br>  Ini akan bekerja dengan benar untuk kotak (menghitung jumlah area mereka), tetapi tidak akan bekerja untuk persegi panjang. <br><br>  Oleh karena itu, persegi panjang melanggar prinsip LSP. </li></ul></li><li>  Jika Anda menggunakan pendekatan pewarisan antarmuka, baik Persegi maupun Persegi Panjang tidak akan saling mewarisi.  Antarmuka untuk persegi dan persegi panjang sebenarnya berbeda, dan satu bukan superset dari yang lain. <br></li><li>  Oleh karena itu, OOD mencegah penggunaan warisan implementasi.  Seperti yang dinyatakan di atas, jika Anda ingin menggunakan kembali kode, maka OOD mengatakan bahwa komposisi adalah pilihan yang tepat! <br><ul><li>  Jadi versi yang <i>benar</i> dari kode (buruk) di atas untuk hierarki warisan implementasi C ++ terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shape</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Square</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Shape { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> width * width; }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rectangle</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Square, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Shape { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> width * height; }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height; };</code> </pre> <br><ul><li>  "Publik virtual" di Jawa berarti "mengimplementasikan".  Digunakan saat mengimplementasikan antarmuka. <br></li><li>  "Privat" memungkinkan Anda untuk memperluas kelas dasar tanpa mewarisi antarmuka - dalam hal ini, persegi panjang <b>bukan</b> persegi, meskipun mewarisi darinya. <br></li></ul></li><li>  Saya tidak merekomendasikan penulisan kode seperti itu, tetapi jika Anda ingin menggunakan warisan implementasi, maka Anda perlu melakukan hal itu! </li></ul></li></ul></li></ol><br>  TL; DR - kelas OOP Anda memberi tahu Anda seperti apa warisan itu.  Kelas OOD Anda yang hilang seharusnya memberi tahu Anda untuk tidak menggunakannya 99% dari waktu! <br><br><h1>  Konsep Entitas / Komponen </h1><br>  Setelah berurusan dengan prasyarat, mari kita beralih ke tempat Aras mulai - ke titik awal yang disebut "khas OOP". <br><br>  Tetapi sebagai permulaan, satu tambahan lagi - Aras menyebut kode ini "OOP tradisional", dan saya ingin menolaknya.  Kode ini mungkin tipikal untuk OOP di dunia nyata, tetapi, seperti contoh di atas, itu melanggar semua jenis prinsip dasar OO, jadi tidak boleh dianggap sebagai tradisional sama sekali. <br><br>  Saya akan mulai dengan komit pertama sebelum dia mulai membuat ulang struktur menuju ECS: <a href="" rel="external nofollow">"Jadikan itu berfungsi pada Windows lagi" 3529f232510c95f53112bbfff87df6bbc6aa1fae</a> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ------------------------------------------------------------------------------------------------- // super simple "component system" class GameObject; class Component; typedef std::vector&lt;Component*&gt; ComponentVector; typedef std::vector&lt;GameObject*&gt; GameObjectVector; // Component base class. Knows about the parent game object, and has some virtual methods. class Component { public: Component() : m_GameObject(nullptr) {} virtual ~Component() {} virtual void Start() {} virtual void Update(double time, float deltaTime) {} const GameObject&amp; GetGameObject() const { return *m_GameObject; } GameObject&amp; GetGameObject() { return *m_GameObject; } void SetGameObject(GameObject&amp; go) { m_GameObject = &amp;go; } bool HasGameObject() const { return m_GameObject != nullptr; } private: GameObject* m_GameObject; }; // Game object class. Has an array of components. class GameObject { public: GameObject(const std::string&amp;&amp; name) : m_Name(name) { } ~GameObject() { // game object owns the components; destroy them when deleting the game object for (auto c : m_Components) delete c; } // get a component of type T, or null if it does not exist on this game object template&lt;typename T&gt; T* GetComponent() { for (auto i : m_Components) { T* c = dynamic_cast&lt;T*&gt;(i); if (c != nullptr) return c; } return nullptr; } // add a new component to this game object void AddComponent(Component* c) { assert(!c-&gt;HasGameObject()); c-&gt;SetGameObject(*this); m_Components.emplace_back(c); } void Start() { for (auto c : m_Components) c-&gt;Start(); } void Update(double time, float deltaTime) { for (auto c : m_Components) c-&gt;Update(time, deltaTime); } private: std::string m_Name; ComponentVector m_Components; }; // The "scene": array of game objects. static GameObjectVector s_Objects; // Finds all components of given type in the whole scene template&lt;typename T&gt; static ComponentVector FindAllComponentsOfType() { ComponentVector res; for (auto go : s_Objects) { T* c = go-&gt;GetComponent&lt;T&gt;(); if (c != nullptr) res.emplace_back(c); } return res; } // Find one component of given type in the scene (returns first found one) template&lt;typename T&gt; static T* FindOfType() { for (auto go : s_Objects) { T* c = go-&gt;GetComponent&lt;T&gt;(); if (c != nullptr) return c; } return nullptr; }</span></span></code> </pre> <br>  Ya, sulit untuk mengetahui ratusan baris kode segera, jadi mari kita mulai secara bertahap ... Kita perlu satu aspek lagi dari prasyarat - dalam permainan tahun 90-an itu populer untuk menggunakan warisan untuk menyelesaikan semua masalah penggunaan kembali kode.  Anda memiliki Entitas, Karakter yang dapat diperluas, Pemain yang dapat diperluas, dan Monster, dan seterusnya ... Ini adalah warisan implementasi, seperti yang kami jelaskan sebelumnya ( <em>"kode dengan choke"</em> ), dan sepertinya itu adalah hak untuk memulai dengan itu, tetapi sebagai hasilnya itu mengarah ke sangat basis kode tidak fleksibel.  Karena OOD memiliki prinsip "komposisi lebih dari warisan" yang dijelaskan di atas.  Jadi, pada tahun 2000-an, prinsip "komposisi lebih dari warisan" menjadi populer, dan pengembang game mulai menulis kode yang sama. <br><br>  Apa yang dilakukan kode ini?  Yah tidak bagus <img alt=": D" height="20" src="https://habrastorage.org/getpro/habr/post_images/4c3/d02/890/4c3d028909133f97a7a351651c98c08b.png" title=": D" width="20"><br><br>  Singkatnya, <strong>kode ini mengimplementasikan kembali fitur bahasa yang ada - komposisi</strong> sebagai pustaka runtime, dan bukan sebagai fitur bahasa.  Anda dapat membayangkan ini seolah-olah kode tersebut benar-benar menciptakan bahasa logam baru di atas C ++ dan mesin virtual (VM) untuk mengeksekusi bahasa logam ini.  Dalam game demo Aras, kode ini tidak diperlukan ( <em>kami akan segera menghapusnya!</em> ) Dan hanya berfungsi untuk mengurangi kinerja game sekitar 10 kali. <br><br>  Tapi apa yang sebenarnya dia lakukan?  Ini adalah konsep " <strong>E</strong> ntity / <strong>C</strong> omponent system" ( <em>kadang-kadang karena beberapa alasan disebut " <strong>E</strong> ntity / <strong>C</strong> omponent system"</em> ), tetapi sama sekali berbeda dari konsep " <strong>E</strong> ntity <strong>C</strong> omponent <strong>S</strong> ystem "(" entitas-komponen-sistem ") ( <em>yang karena alasan yang jelas tidak pernah disebut" <strong>E</strong> ntity <strong>C</strong> omponent <strong>S</strong> sistem ystem</em> ). Ini memformalkan beberapa prinsip "EC": <br><br><ul><li>  gim akan dibangun dari tidak memiliki fitur "Entitas" ("Entity") ( <em>dalam contoh ini disebut</em> GameObjects), yang terdiri dari "komponen" ("Komponen"). </li><li>  GameObjects menerapkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">pola “service locator”</a> - komponen anak mereka akan ditanyakan berdasarkan tipe. </li><li>  Komponen tahu GameObject mana mereka milik - mereka dapat menemukan komponen yang berada pada tingkat yang sama dengan mereka dengan meminta GameObject induk. <br></li><li>  Komposisi dapat hanya satu tingkat dalam ( <em>komponen tidak dapat memiliki komponen turunannya sendiri, GameObjects tidak dapat memiliki turiran GameObjects anak</em> ). <br></li><li>  GameObject hanya dapat memiliki satu komponen dari setiap jenis ( <em>dalam beberapa kerangka kerja ini merupakan persyaratan wajib, di lain tidak</em> ). <br></li><li>  Setiap komponen (mungkin) berubah dari waktu ke waktu dalam beberapa cara yang tidak ditentukan, sehingga antarmuka berisi "Pembaruan void virtual". <br></li><li>  GameObjects milik adegan yang dapat mengeksekusi permintaan pada semua GameObjects (dan karenanya semua komponen). </li></ul><br>  Konsep serupa sangat populer di tahun 2000-an, dan meskipun memiliki keterbatasan, ternyata cukup fleksibel untuk membuat game yang tak terhitung jumlahnya baik dulu maupun sekarang. <br><br>  Namun, ini tidak wajib.  Bahasa pemrograman Anda sudah memiliki dukungan untuk komposisi sebagai fitur bahasa - tidak perlu konsep kembung untuk mengaksesnya ... Mengapa, kemudian, apakah konsep-konsep ini ada?  Yah, jujur ​​saja, mereka memungkinkan Anda untuk melakukan <em>komposisi dinamis saat runtime</em> .  Alih-alih mendefinisikan jenis GameObject dalam kode, Anda dapat memuatnya dari file data.  Dan ini sangat nyaman, karena memungkinkan desainer game / level untuk membuat jenis objek mereka sendiri ... Namun, di sebagian besar proyek game ada sangat sedikit desainer dan secara harfiah sepasukan programmer, jadi saya berpendapat bahwa ini adalah peluang penting.  Lebih buruk lagi, ini bukan satu-satunya cara Anda dapat menerapkan komposisi pada saat run time!  Sebagai contoh, Unity menggunakan C # sebagai “bahasa scripting” -nya, dan banyak game lain menggunakan alternatifnya, misalnya Lua - alat yang nyaman bagi para desainer dapat menghasilkan kode C # / Lua untuk mendefinisikan objek game baru tanpa perlu konsep kembung seperti itu!  Kami akan menambahkan kembali "fitur" ini di posting berikutnya, dan membuatnya sehingga tidak ada biaya sepuluh kali lipat dalam penurunan kinerja ... <br><br>  Mari kita evaluasi kode ini sesuai dengan OOD: <br><br><ul><li>  GameObject :: GetComponent menggunakan dynamic_cast.  Kebanyakan orang akan memberi tahu Anda bahwa dynamic_cast adalah "kode dengan choke," petunjuk besar bahwa Anda memiliki bug di suatu tempat.  Saya akan mengatakan ini - ini adalah bukti bahwa Anda melanggar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">LSP</a> - Anda memiliki beberapa jenis algoritma yang bekerja dengan antarmuka dasar, tetapi perlu mengetahui detail implementasi yang berbeda.  Untuk alasan khusus ini, kode ini berbau busuk. <br></li><li>  GameObject, pada prinsipnya, tidak buruk, jika Anda membayangkan bahwa ia mengimplementasikan templat “service locator” ... tetapi jika Anda melangkah lebih jauh daripada kritik dari sudut pandang OOD, templat ini menciptakan koneksi implisit antara bagian-bagian dari proyek, dan saya pikir ( <em>tanpa tautan ke Wikipedia yang dapat mendukung saya dengan pengetahuan dari ilmu komputer</em> ) bahwa saluran komunikasi implisit adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">antipattern</a> , dan mereka harus lebih memilih saluran komunikasi eksplisit.  Argumen yang sama berlaku untuk "konsep acara" yang terkadang digunakan dalam game ... <br></li><li>  Saya ingin menyatakan bahwa komponen merupakan pelanggaran terhadap <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">SRP</a> karena antarmuka ( <em>virtual void Update (time)</em> ) terlalu lebar.  Penggunaan "virtual void Update" dalam pengembangan game ada di mana-mana, tetapi saya juga akan mengatakan bahwa itu adalah antipattern.  Perangkat lunak yang baik harus memungkinkan Anda untuk dengan mudah memikirkan aliran kontrol dan aliran data.  Menempatkan <em>setiap elemen kode gameplay di</em> belakang panggilan "virtual void Update" sepenuhnya dan sepenuhnya mengaburkan aliran kontrol dan aliran data.  IMHO, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">efek samping</a> tak terlihat, juga disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">efek</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">jarak jauh</a> , adalah beberapa sumber bug yang paling umum, dan "Pembaruan batal virtual" memastikan bahwa hampir semuanya akan menjadi efek samping yang tak terlihat. <br></li><li>  Meskipun tujuan dari kelas Komponen adalah untuk memungkinkan komposisi, ia melakukannya melalui warisan, yang merupakan pelanggaran <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">CRP</a> . </li><li>  Satu-satunya sisi baik dari contoh ini adalah bahwa kode permainan berlebihan untuk mematuhi prinsip-prinsip SRP dan ISP - itu dibagi menjadi banyak komponen sederhana dengan tanggung jawab yang sangat sedikit, yang bagus untuk menggunakan kembali kode. <br><br>  Namun, ia tidak begitu baik dalam memelihara DIP - banyak komponen memiliki pengetahuan langsung satu sama lain. </li></ul><br>  Jadi, semua kode yang ditunjukkan di atas sebenarnya bisa dihapus.  Seluruh struktur ini.  Hapus GameObject (juga disebut Entity dalam kerangka kerja lain), hapus Komponen, hapus FindOfType.  Ini adalah bagian dari VM yang tidak berguna yang melanggar prinsip OOD dan sangat memperlambat permainan kami. <br><br><h1>  Komposisi tanpa kerangka kerja (mis. Menggunakan fitur dari bahasa pemrograman itu sendiri) </h1><br>  Jika kami menghapus kerangka kerja komposisi dan kami tidak memiliki kelas dasar Komponen, bagaimana GameObject kami akan menggunakan komposisi dan terdiri dari komponen?  Seperti judulnya, alih-alih menulis VM kembung ini dan membuat GameObjects dalam bahasa logam yang aneh di atasnya, mari kita menulisnya dalam C ++ karena kita adalah programmer game dan ini benar-benar tugas kita. <br><br>  Berikut adalah komit yang menghapus kerangka Entity / Component: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">https://github.com/hodgman/dod-playground/commit/f42290d0217d700dea2ed002f2f3b1dc45e8c27c</a> <br><br>  Berikut ini adalah versi asli kode sumber: <a href="" rel="external nofollow">https://github.com/hodgman/dod-playground/blob/3529f232510c95f53112bbfff87df6bbc6aa1fae/source/game.cpp</a> <br><br>  Berikut ini adalah versi kode sumber yang dimodifikasi: <a href="" rel="external nofollow">https://github.com/hodgman/dod-playground/blob/f42290d0217d700dea2ed002f2f3b1dc45e8c27c/source/game.cpp</a> <br><br>  Secara singkat tentang perubahan: <br><br><ul><li>  Dihapus ": Komponen publik" dari setiap jenis komponen. <br></li><li>  Menambahkan konstruktor ke setiap jenis komponen. <br><ul><li>  OOD terutama tentang merangkum keadaan kelas, tetapi karena kelas-kelas ini sangat kecil / sederhana, tidak ada yang istimewa untuk disembunyikan: antarmuka adalah deskripsi data.  Namun, salah satu alasan utama bahwa enkapsulasi adalah pilar utama adalah bahwa enkapsulasi memungkinkan kami untuk menjamin kebenaran konstan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">dari invarian kelas</a> ... atau jika invarian rusak, maka Anda hanya perlu memeriksa kode implementasi enkapsulasi untuk menemukan kesalahan.  Dalam contoh kode ini, ada baiknya menambahkan konstruktor untuk mengimplementasikan invarian sederhana - semua nilai harus diinisialisasi. </li></ul></li><li>  Saya mengganti nama metode "Pembaruan" yang terlalu umum untuk membuat nama mereka mencerminkan apa yang sebenarnya mereka lakukan - UpdatePosition untuk MoveComponent dan ResolveCollisions untuk AvoidComponent. <br></li><li>  Saya menghapus tiga blok kode yang menyerupai kode templat / cetakan - kode yang membuat GameObject berisi jenis Komponen tertentu, dan menggantinya dengan tiga kelas C ++. <br></li><li>  Dihilangkan antipattern "Pembaruan virtual void". <br></li><li>  Alih-alih komponen mencari satu sama lain melalui templat "pencari lokasi", game secara eksplisit mengikatnya bersama selama konstruksi. </li></ul><br><h2>  Benda-benda </h2><br>  Karenanya, alih-alih kode "mesin virtual" ini: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// create regular objects that move for (auto i = 0; i &lt; kObjectCount; ++i) { GameObject* go = new GameObject("object"); // position it within world bounds PositionComponent* pos = new PositionComponent(); pos-&gt;x = RandomFloat(bounds-&gt;xMin, bounds-&gt;xMax); pos-&gt;y = RandomFloat(bounds-&gt;yMin, bounds-&gt;yMax); go-&gt;AddComponent(pos); // setup a sprite for it (random sprite index from first 5), and initial white color SpriteComponent* sprite = new SpriteComponent(); sprite-&gt;colorR = 1.0f; sprite-&gt;colorG = 1.0f; sprite-&gt;colorB = 1.0f; sprite-&gt;spriteIndex = rand() % 5; sprite-&gt;scale = 1.0f; go-&gt;AddComponent(sprite); // make it move MoveComponent* move = new MoveComponent(0.5f, 0.7f); go-&gt;AddComponent(move); // make it avoid the bubble things AvoidComponent* avoid = new AvoidComponent(); go-&gt;AddComponent(avoid); s_Objects.emplace_back(go); }</span></span></code> </pre> <br>  Kami sekarang memiliki kode C ++ reguler: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegularObject</span></span></span><span class="hljs-class"> {</span></span> PositionComponent pos; SpriteComponent sprite; MoveComponent move; AvoidComponent avoid; RegularObject(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> WorldBoundsComponent&amp; bounds) : move(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.7f</span></span>) <span class="hljs-comment"><span class="hljs-comment">// position it within world bounds , pos(RandomFloat(bounds.xMin, bounds.xMax), RandomFloat(bounds.yMin, bounds.yMax)) // setup a sprite for it (random sprite index from first 5), and initial white color , sprite(1.0f, 1.0f, 1.0f, rand() % 5, 1.0f) { } }; ... // create regular objects that move regularObject.reserve(kObjectCount); for (auto i = 0; i &lt; kObjectCount; ++i) regularObject.emplace_back(bounds);</span></span></code> </pre> <br><h2>  Algoritma </h2><br>  Perubahan besar lainnya telah dibuat untuk algoritma.  Ingat, pada awalnya saya mengatakan bahwa antarmuka dan algoritma bekerja dalam simbiosis, dan haruskah memengaruhi struktur masing-masing?  Jadi, " <em>Pembaruan void</em> " antipattern telah menjadi musuh di sini juga.  Kode awal berisi algoritma loop utama, yang hanya terdiri dari ini: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// go through all objects for (auto go : s_Objects) { // Update all their components go-&gt;Update(time, deltaTime);</span></span></code> </pre> <br>  Anda dapat berpendapat bahwa itu indah dan sederhana, tetapi IMHO itu sangat, sangat buruk.  Ini benar-benar mengaburkan baik <em>aliran</em> <em>kontrol</em> maupun <em>aliran data</em> dalam game.  Jika kita ingin dapat memahami perangkat lunak kita, jika kita ingin mendukungnya, jika kita ingin menambahkan hal-hal baru ke dalamnya, mengoptimalkannya, menjalankannya secara efisien pada beberapa inti prosesor, maka kita perlu memahami aliran kontrol dan aliran data.  Oleh karena itu, "Pembaruan void virtual" harus dibakar. <br><br>  Sebagai gantinya, kami membuat loop utama yang lebih eksplisit, yang sangat menyederhanakan pemahaman tentang aliran kontrol ( <em>aliran data di dalamnya masih dikaburkan, tetapi kami akan memperbaikinya dalam komitmen berikut</em> ). <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Update all positions for (auto&amp; go : s_game-&gt;regularObject) { UpdatePosition(deltaTime, go, s_game-&gt;bounds.wb); } for (auto&amp; go : s_game-&gt;avoidThis) { UpdatePosition(deltaTime, go, s_game-&gt;bounds.wb); } // Resolve all collisions for (auto&amp; go : s_game-&gt;regularObject) { ResolveCollisions(deltaTime, go, s_game-&gt;avoidThis); }</span></span></code> </pre> <br>  Kerugian dari gaya ini adalah bahwa untuk <em>setiap jenis objek baru yang</em> ditambahkan ke permainan, kita harus menambahkan beberapa baris ke loop utama.  Saya akan kembali ke ini dalam posting selanjutnya dari seri ini. <br><br><h1>  Performa </h1><br>  Ada banyak pelanggaran OOD besar, beberapa keputusan buruk dibuat ketika memilih struktur, dan ada banyak peluang untuk optimisasi, tetapi saya akan membahasnya pada posting berikutnya dari seri ini.  Namun, sudah pada tahap ini jelas bahwa versi dengan "OOD tetap" hampir sepenuhnya cocok atau memenangkan kode "ECS" terakhir dari akhir presentasi ... Dan yang kami lakukan hanyalah mengambil kode pseudo-OOP yang buruk dan membuatnya mematuhi prinsip-prinsip OOP (dan juga menghapus seratus baris kode)! <br><br><div style="text-align:center;"><img alt="img" src="https://habrastorage.org/getpro/habr/post_images/d22/8c2/d99/d228c2d99b9b17da94979d7fc5f728ee.png"></div><br><h1>  Langkah selanjutnya </h1><br>  Di sini saya ingin mempertimbangkan berbagai masalah yang lebih luas, termasuk menyelesaikan masalah OOD yang tersisa, objek yang tidak dapat diubah ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">pemrograman dengan gaya fungsional</a> ) dan keuntungan yang dapat mereka bawa dalam diskusi tentang aliran data, pengiriman pesan, penerapan logika DOD ke kode OOD kami, menerapkan kebijaksanaan yang relevan dalam kode OOD, menghapus kelas-kelas "entitas" yang akhirnya kita dapatkan, dan hanya menggunakan komponen murni, menggunakan gaya yang berbeda untuk menghubungkan komponen (membandingkan pointer dan  tanggung jawab membawa) komponen kontainer dari dunia nyata, versi ECS-revisi untuk optimasi yang lebih baik, serta optimasi lebih lanjut, tidak disebutkan dalam laporan Aras <em>(seperti multi-threading / SIMD).</em>  Urutan belum tentu seperti ini, dan mungkin saya tidak akan mempertimbangkan semua hal di atas ... <br><br><h1>  Selain itu </h1><br>  Tautan ke artikel telah menyebar ke luar lingkaran pengembang game, jadi saya akan menambahkan: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">ECS</a> " ( <em>artikel Wikipedia ini buruk, omong-omong, ia menggabungkan konsep EC dan ECS, dan ini tidak sama ...</em> ) - ini adalah template palsu yang beredar di dalam komunitas pengembang game.  Pada kenyataannya, ini adalah versi dari model relasional di mana "entitas" hanya ID yang menunjuk objek tak berbentuk, "komponen" adalah baris dalam tabel tertentu yang merujuk ID, dan "sistem" adalah kode prosedural yang dapat memodifikasi komponen .  "Templat" ini selalu diposisikan sebagai solusi untuk masalah penggunaan warisan yang berlebihan, tetapi tidak disebutkan bahwa penggunaan warisan yang berlebihan justru melanggar rekomendasi OOP.  Karena itu saya marah.  Ini bukan "satu-satunya cara yang benar" untuk menulis perangkat lunak.  Pos dirancang untuk memastikan bahwa orang benar-benar belajar tentang prinsip-prinsip desain yang ada. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id441174/">https://habr.com/ru/post/id441174/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id441158/index.html">Bagaimana etika menjadi masalah Lembah Silikon termahal, dan filsafat menjadi solusi paling praktis</a></li>
<li><a href="../id441160/index.html">Cara belajar menentukan kapan mengatakan tidak</a></li>
<li><a href="../id441166/index.html">Kami mendapatkan kata sandi utama dari pengelola kata sandi yang terkunci 1 Kata sandi 4</a></li>
<li><a href="../id441168/index.html">Saluran Data QUIC: Langkah Pertama</a></li>
<li><a href="../id441172/index.html">Bagaimana pasar pencetakan 3D tumbuh pada tahun 2018 dan apa artinya untuk bisnis</a></li>
<li><a href="../id441180/index.html">Berawan dengan Peluang Periklanan Non-Nonaktif di Langit Berbintang</a></li>
<li><a href="../id441182/index.html">Pendekatan mesin-sinestetik untuk mendeteksi serangan jaringan DDoS. Bagian 2</a></li>
<li><a href="../id441184/index.html">Konferensi game pertama Grup Mail.ru</a></li>
<li><a href="../id441186/index.html">ASH Viewer: Reboot</a></li>
<li><a href="../id441192/index.html">Menggunakan kekuatan komputasi R untuk menguji hipotesis persamaan cara</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>