<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüíº üåÑ üçº Principes de base des champs de distance sign√©s en 2D üìº üßò üë©üèº‚Äçü§ù‚Äçüë®üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bien que les maillages soient le moyen le plus simple et le plus polyvalent de rendre, il existe d'autres options pour repr√©senter les formes en 2D et...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Principes de base des champs de distance sign√©s en 2D</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438316/">  Bien que les maillages soient le moyen le plus simple et le plus polyvalent de rendre, il existe d'autres options pour repr√©senter les formes en 2D et 3D.  Une m√©thode couramment utilis√©e est les champs de distance sign√©e (SDF).  Les champs de distance sign√©s offrent un trac√© de rayons moins co√ªteux, permettent √† diff√©rentes formes de se couler facilement les unes dans les autres et d'√©conomiser sur des textures basse r√©solution pour des images de haute qualit√©. <br><br>  Nous commencerons par g√©n√©rer le signe des champs de distance en utilisant des fonctions en deux dimensions, mais plus tard nous continuerons √† les g√©n√©rer en 3D.  J'utiliserai les coordonn√©es de l'espace mondial pour que nous ayons le moins possible la d√©pendance √† l'√©chelle et aux coordonn√©es UV, donc si vous ne comprenez pas comment cela fonctionne, alors √©tudiez ce <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tutoriel sur une superposition plate</a> , qui explique ce qui se passe. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/eb/w-/sj/ebw-sjziw5loorrc2yj1wsl1vyu.gif"></div><a name="habracut"></a><br><h2>  Pr√©paration de la fondation </h2><br>  Nous allons temporairement jeter les propri√©t√©s du shader de superposition plat de base, car pour l'instant nous nous occupons de la base technique.  Ensuite, nous √©crivons la position du sommet dans le monde directement dans la structure du fragment, et nous ne la convertirons pas d'abord en UV.  Au dernier stade de pr√©paration, nous √©crirons une nouvelle fonction qui calcule la sc√®ne et renvoie la distance √† la surface la plus proche.  Ensuite, nous appelons les fonctions et utilisons le r√©sultat comme une couleur. <br><br><pre><code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/034_2D_SDF_Basics"</span></span>{ SubShader{ <span class="hljs-comment"><span class="hljs-comment">//           Tags{ "RenderType"="Opaque" "Queue"="Geometry"} Pass{ CGPROGRAM #include "UnityCG.cginc" #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; struct v2f{ float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; v2f vert(appdata v){ v2f o; //         o.position = UnityObjectToClipPos(v.vertex); //     o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { //      return 0; } fixed4 frag(v2f i) : SV_TARGET{ float dist = scene(i.worldPos.xz); fixed4 col = fixed4(dist, dist, dist, 1); return col; } ENDCG } } FallBack "Standard" //fallback   ,       }</span></span></code> </pre> <br>  J'√©crirai toutes les fonctions pour les champs de distance sign√©s dans un fichier s√©par√© afin que nous puissions les utiliser √† plusieurs reprises.  Pour ce faire, je vais cr√©er un nouveau fichier.  Nous n'y ajouterons aucun mal, puis nous le d√©finissons et compl√©tons la protection d'inclusion conditionnelle, v√©rifiant d'abord si la variable du pr√©processeur est d√©finie.  S'il n'est pas encore d√©fini, nous le d√©finissons et compl√©tons la construction conditionnelle if apr√®s les fonctions que nous voulons inclure.  L'avantage de cela est que si nous ajoutons le fichier deux fois (par exemple, si nous ajoutons deux fichiers diff√©rents, chacun ayant les fonctions dont nous avons besoin, et qu'ils ajoutent tous les deux le m√™me fichier), cela cassera le shader.  Si vous √™tes s√ªr que cela ne se produira jamais, vous ne pouvez pas effectuer cette v√©rification. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// in include file // include guards that keep the functions from being included more than once #ifndef SDF_2D #define SDF_2D // functions #endif</span></span></code> </pre> <br>  Si le fichier include se trouve dans le m√™me dossier que le shader principal, nous pouvons simplement l'inclure en utilisant la construction pragma. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// in main shader #include "2D_SDF.cginc"</span></span></code> </pre> <br>  Nous ne verrons donc qu'une surface noire sur la surface rendue, pr√™te √† afficher la distance avec un signe dessus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/25b/a3a/188/25ba3a188962c645fc6a12cfb5aed751.png"></div><br><h2>  Cercle </h2><br>  La fonction la plus simple du champ de distance sign√© est la fonction cercle.  La fonction ne recevra que la position de l'√©chantillon et le rayon du cercle.  Nous commen√ßons par obtenir la longueur du vecteur de position de l'√©chantillon.  Nous obtenons donc un point √† la position (0, 0), qui est similaire √† un cercle avec un rayon de 0. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">circle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 samplePosition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length(samplePosition); }</code> </pre> <br>  Ensuite, vous pouvez appeler la fonction cercle dans la fonction sc√®ne et renvoyer la distance qu'elle renvoie. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDistance = circle(position, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sceneDistance; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/839/6a8/f87/8396a8f8780b6b30deb88d1009f6f5c7.png"></div><br>  Ensuite, nous ajoutons le rayon aux calculs.  Un aspect important des fonctions de distance sign√©e est que lorsque nous sommes √† l'int√©rieur de l'objet, nous obtenons une distance n√©gative √† la surface (c'est ce que le mot sign√© signifie dans le champ d'expression de distance sign√©e).  Pour augmenter le cercle √† un rayon, nous soustrayons simplement le rayon de la longueur.  Ainsi, la surface, qui est partout o√π la fonction renvoie 0, se d√©place vers l'ext√©rieur.  Ce qui est √† deux unit√©s de la distance de la surface pour un cercle de taille 0, c'est seulement une unit√© d'un cercle avec un rayon de 1, et une unit√© √† l'int√©rieur du cercle (la valeur est -1) pour un cercle avec un rayon de 3; <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">circle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 samplePosition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length(samplePosition) - radius; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7a/b83/57f/e7ab8357f4c844bc7bc58dfda6406d9d.png"></div><br>  Maintenant, la seule chose que nous ne pouvons pas faire est de d√©placer le cercle du centre.  Pour r√©soudre ce probl√®me, vous pouvez ajouter un nouvel argument √† la fonction cercle pour calculer la distance entre la position de l'√©chantillon et le centre du cercle, et soustraire le rayon de cette valeur pour d√©finir un cercle.  Ou, vous pouvez red√©finir l'origine en d√©pla√ßant l'espace du point d'√©chantillonnage, puis obtenir un cercle dans cet espace.  La deuxi√®me option semble beaucoup plus compliqu√©e, mais comme le d√©placement d'objets est une op√©ration que nous voulons utiliser pour toutes les figures, elle est beaucoup plus universelle, et donc je vais l'expliquer. <br><br><h2>  D√©m√©nagement </h2><br>  "Transformation de l'espace d'un point" - sonne bien pire qu'il ne l'est r√©ellement.  Cela signifie que nous transmettons le point √† la fonction et que la fonction le modifie pour que nous puissions toujours l'utiliser √† l'avenir.  Dans le cas d'un transfert, nous soustrayons simplement le d√©calage du point.  La position est soustraite lorsque nous voulons d√©placer les formes dans le sens positif, car les formes que nous rendons dans l'espace se d√©placent dans la direction oppos√©e au d√©placement de l'espace. <br><br>  Par exemple, si nous voulons dessiner une sph√®re en position <code>(3, 4)</code> , nous devons changer l'espace de sorte que <code>(3, 4)</code> transforme en <code>(0, 0)</code> , et pour cela, nous devons soustraire <code>(3, 4)</code> .  Maintenant, si nous dessinons une sph√®re autour d'un <i>nouveau</i> point d'origine, ce sera un <i>ancien</i> point <code>(3, 4)</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// in sdf functions include file float2 translate(float2 samplePosition, float2 offset){ return samplePosition - offset; }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position)</span></span></span><span class="hljs-function"> </span></span>{ float2 circlePosition = translate(position, float2(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDistance = circle(circlePosition, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sceneDistance; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e5/7ca/6cc/7e57ca6cc1b5953b03811fd2d48ac3f1.png"></div><br><h2>  Rectangle </h2><br>  Une autre forme simple est un rectangle.  Pour commencer, nous consid√©rons les composants s√©par√©ment.  Nous obtenons d'abord la distance du centre, en prenant la valeur absolue.  Ensuite, de la m√™me mani√®re qu'un cercle, nous soustrayons la moiti√© de la taille (qui ressemble essentiellement au rayon d'un rectangle).  Pour montrer √† quoi ressembleront les r√©sultats, nous ne retournerons qu'un seul composant pour l'instant. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rectangle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 samplePosition, float2 halfSize)</span></span></span></span>{ float2 componentWiseEdgeDistance = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(samplePosition) - halfSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> componentWiseEdgeDistance.x; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/14d/d5f/62a/14dd5f62af057366f38cdfaa2bc19315.png"></div><br>  Maintenant, nous pouvons obtenir une version bon march√© du rectangle en renvoyant simplement le plus grand composant 2. Cela fonctionne dans de nombreux cas, mais pas correctement, car il n'affiche pas la bonne distance autour des coins. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9c/b19/e06/a9cb19e061cb980c3fe8a2d533b2fbfb.png"></div><br>  Les valeurs correctes pour le rectangle √† l'ext√©rieur de la figure peuvent √™tre obtenues en prenant d'abord le maximum entre les distances aux bords et 0, puis en prenant sa longueur. <br><br>  Si nous ne limitons pas la distance de dessous √† 0, nous calculons simplement la distance aux coins (o√π les EdgeDistances sont <code>(0, 0)</code> ), mais les coordonn√©es entre les coins ne tomberont pas en dessous de 0, donc tout le bord sera utilis√©.  L'inconv√©nient de ceci est que 0 est utilis√© comme distance du bord pour tout l'int√©rieur de la figure. <br><br>  Pour corriger la distance 0 pour toute la partie int√©rieure, vous devez g√©n√©rer la distance interne, en utilisant simplement la formule du rectangle bon march√© (en prenant la valeur maximale des composants x et y), puis en garantissant qu'elle ne d√©passera jamais 0, en prenant la valeur minimale de celle-ci √† 0. Ensuite, nous ajoutons la distance externe, qui n'est jamais inf√©rieure √† 0, et la distance interne, qui ne d√©passe jamais 0, et nous obtenons la fonction de distance finie. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rectangle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 samplePosition, float2 halfSize)</span></span></span></span>{ float2 componentWiseEdgeDistance = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(samplePosition) - halfSize; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> outsideDistance = length(max(componentWiseEdgeDistance, <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> insideDistance = min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> outsideDistance + insideDistance; }</code> </pre> <br>  Comme nous avions pr√©c√©demment enregistr√© la fonction de transfert sous une forme universelle, nous pouvons maintenant √©galement l'utiliser pour d√©placer son centre √† n'importe quel endroit. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position)</span></span></span><span class="hljs-function"> </span></span>{ float2 circlePosition = translate(position, float2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDistance = rectangle(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sceneDistance; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc0/8eb/671/cc08eb671ae5314ae32d3a20cd685b4b.png"></div><br><h2>  Tourner </h2><br>  La rotation des formes est similaire au d√©placement.  Avant de calculer la distance √† la figure, nous faisons pivoter les coordonn√©es dans la direction oppos√©e.  Pour simplifier au maximum la compr√©hension des rotations, nous multiplions la rotation par 2 * pi pour obtenir l'angle en radians.  Ainsi, nous passons une rotation √† la fonction, o√π 0,25 est un quart de tour, 0,5 est un demi-tour et 1 est un tour complet (vous pouvez effectuer des transformations diff√©remment si cela vous semble plus naturel).  Nous inversons √©galement la rotation, car nous devons faire pivoter la position dans le sens oppos√© √† la rotation de la figure pour la m√™me raison que lors du d√©placement. <br><br>  Pour calculer les coordonn√©es pivot√©es, nous calculons d'abord le sinus et le cosinus en fonction de l'angle.  Hlsl a une fonction sincos qui calcule ces deux valeurs plus rapidement que lorsqu'elle est calcul√©e s√©par√©ment. <br><br>  Lors de la construction d'un nouveau vecteur pour la composante x, nous prenons la composante d'origine x multipli√©e par le cosinus et la composante y multipli√©e par le sinus.  Cela peut √™tre facilement m√©moris√© si vous vous souvenez que le cosinus de 0 est 1, et lorsqu'il est tourn√© de 0, nous voulons que la composante x du nouveau vecteur soit exactement la m√™me qu'avant (c'est-√†-dire, multiplie par 1).  La composante y, qui pointait auparavant vers le haut, n'a pas contribu√© √† la composante x, tourne vers la droite et ses valeurs commencent √† 0, devenant d'abord plus grandes, c'est-√†-dire que son mouvement est compl√®tement d√©crit par un sinus. <br><br>  Pour la composante y du nouveau vecteur, nous multiplions le cosinus par la composante y de l'ancien vecteur et soustrayons le sinus multipli√© par l'ancienne composante x.  Pour comprendre pourquoi nous soustrayons, plut√¥t que d'ajouter le sinus, multipli√© par la composante x, il est pr√©f√©rable d'imaginer comment le vecteur <code>(1, 0)</code> change lorsqu'il est tourn√© dans le sens des aiguilles d'une montre.  La composante y du r√©sultat commence √† 0 puis devient inf√©rieure √† 0. C'est l'oppos√© de la fa√ßon dont le sinus se comporte, nous changeons donc de signe. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rotate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 samplePosition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rotation)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> PI = <span class="hljs-number"><span class="hljs-number">3.14159</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> angle = rotation * PI * <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sine, cosine; sincos(angle, sine, cosine); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float2(cosine * samplePosition.x + sine * samplePosition.y, cosine * samplePosition.y - sine * samplePosition.x); }</code> </pre> <br>  Maintenant que nous avons √©crit la m√©thode de rotation, nous pouvons l'utiliser en combinaison avec le transfert pour d√©placer et faire pivoter la figure. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position)</span></span></span><span class="hljs-function"> </span></span>{ float2 circlePosition = position; circlePosition = rotate(circlePosition, _Time.y); circlePosition = translate(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDistance = rectangle(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sceneDistance; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d46/99b/da0/d4699bda0f35c10163998bd22fac5eab.gif"></div><br>  Dans ce cas, nous faisons d'abord pivoter l'objet autour du centre de la sc√®ne enti√®re, de sorte que la rotation affecte √©galement le transfert.  Pour faire pivoter une figure par rapport √† son propre centre, vous devez d'abord la d√©placer, puis la faire pivoter.  En raison de cet ordre modifi√© au moment de la rotation, le centre de la figure deviendra le centre du syst√®me de coordonn√©es. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position)</span></span></span><span class="hljs-function"> </span></span>{ float2 circlePosition = position; circlePosition = translate(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); circlePosition = rotate(circlePosition, _Time.y); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDistance = rectangle(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sceneDistance; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e5/3f3/12d/8e53f312d343fcbe95d000703001da3c.gif"></div><br><h2>  Mise √† l'√©chelle </h2><br>  La mise √† l'√©chelle fonctionne de mani√®re similaire √† d'autres fa√ßons de transformer des formes.  Nous divisons les coordonn√©es par √©chelle, ce qui rend la figure dans l'espace avec une √©chelle r√©duite, et dans le syst√®me de coordonn√©es de base, elles deviennent plus grandes. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scale</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 samplePosition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> samplePosition / scale; }</code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position)</span></span></span><span class="hljs-function"> </span></span>{ float2 circlePosition = position; circlePosition = translate(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); circlePosition = rotate(circlePosition, <span class="hljs-number"><span class="hljs-number">.125</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> pulseScale = <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(_Time.y * <span class="hljs-number"><span class="hljs-number">3.14</span></span>); circlePosition = scale(circlePosition, pulseScale); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDistance = rectangle(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sceneDistance; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e66/043/a58/e66043a5877fbdcbcc38629d70334481.gif"></div><br>  Bien que cela effectue correctement la mise √† l'√©chelle, la distance est √©galement mise √† l'√©chelle.  Le principal avantage du champ de distance sign√© est que nous connaissons toujours la distance √† la surface la plus proche, mais un zoom arri√®re d√©truit compl√®tement cette propri√©t√©.  Cela peut √™tre facilement corrig√© en multipliant le champ de distance obtenu √† partir de la fonction de distance de signe (dans notre cas, le <code>rectangle</code> ) par l'√©chelle.  Pour la m√™me raison, nous ne pouvons pas facilement mettre √† l'√©chelle de mani√®re in√©gale (avec des √©chelles diff√©rentes pour les axes x et y). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position)</span></span></span><span class="hljs-function"> </span></span>{ float2 circlePosition = position; circlePosition = translate(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); circlePosition = rotate(circlePosition, <span class="hljs-number"><span class="hljs-number">.125</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> pulseScale = <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(_Time.y * <span class="hljs-number"><span class="hljs-number">3.14</span></span>); circlePosition = scale(circlePosition, pulseScale); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDistance = rectangle(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) * pulseScale; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sceneDistance; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/802/1bd/da1/8021bdda196f8300516f04cdf965c8af.gif"></div><br><h2>  Visualisation </h2><br>  Les champs de distance sign√©s peuvent √™tre utilis√©s pour une vari√©t√© de choses, telles que la cr√©ation d'ombres, le rendu de sc√®nes 3D, la physique et le rendu de texte.  Mais nous ne voulons pas encore approfondir la complexit√©, donc je vais expliquer seulement deux techniques de leur visualisation.  Le premier est une forme claire avec anticr√©nelage, le second est le rendu des lignes en fonction de la distance. <br><br><h3>  Forme claire </h3><br>  Cette m√©thode est similaire √† celle qui est souvent utilis√©e lors du rendu de texte, elle cr√©e un formulaire clair.  Si nous voulons g√©n√©rer un champ de distance non pas √† partir d'une fonction, mais le lire √† partir d'une texture, cela nous permet d'utiliser des textures avec une r√©solution beaucoup plus faible que d'habitude et d'obtenir de bons r√©sultats.  TextMesh Pro utilise cette technique pour rendre le texte. <br><br>  Pour appliquer cette technique, nous profitons du fait que les donn√©es dans les champs de distance sont sign√©es, et nous connaissons le point de coupure.  Nous commen√ßons par calculer dans quelle mesure le champ de distance change au pixel suivant.  Cela devrait √™tre la m√™me valeur que la longueur du changement de coordonn√©es, mais il est plus facile et plus fiable de calculer la distance avec un signe. <br><br>  Apr√®s avoir re√ßu le changement de distance, nous pouvons faire un pas en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">douceur</a> de la moiti√© du changement de distance √† moins / plus la moiti√© du changement de distance.  Cela effectuera un √©cr√™tage simple autour de 0, mais avec un lissage.  Ensuite, vous pouvez utiliser cette valeur liss√©e pour toute valeur binaire dont nous avons besoin.  Dans cet exemple, je vais changer le shader en un shader de transparence et l'utiliser pour le canal alpha.  Je fais un passage progressif d'une valeur positive √† une valeur n√©gative parce que nous voulons que la valeur n√©gative du champ de distance soit visible.  Si vous ne comprenez pas bien comment fonctionne le rendu de transparence ici, je vous recommande de lire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mon didacticiel sur le</a> rendu de transparence. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//properties Properties{ _Color("Color", Color) = (1,1,1,1) }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in subshader outside of pass Tags{ "RenderType"="Transparent" "Queue"="Transparent"} Blend SrcAlpha OneMinusSrcAlpha ZWrite Off</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">fixed4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v2f i)</span></span></span><span class="hljs-function"> : SV_TARGET</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist = scene(i.worldPos.xz); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distanceChange = fwidth(dist) * <span class="hljs-number"><span class="hljs-number">0.5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> antialiasedCutoff = smoothstep(distanceChange, -distanceChange, dist); fixed4 col = fixed4(_Color, antialiasedCutoff); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> col; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/86d/a08/e1c/86da08e1cfcb25212c6bf3c22dfa1dc8.gif"></div><br><h3>  Lignes d'√©l√©vation </h3><br>  Une autre technique courante pour visualiser les champs de distance consiste √† afficher les distances sous forme de lignes.  Dans notre impl√©mentation, j'ajouterai quelques lignes √©paisses et quelques lignes fines entre elles.  Je vais √©galement peindre l'int√©rieur et l'ext√©rieur de la figure de diff√©rentes couleurs afin que vous puissiez voir o√π se trouve l'objet. <br><br>  Nous commencerons par afficher la diff√©rence entre l'int√©rieur et l'ext√©rieur de la figure.  Les couleurs peuvent √™tre personnalis√©es dans le mat√©riau, nous ajouterons donc de nouvelles propri√©t√©s, ainsi que des variables de shader pour les couleurs internes et externes de la figure. <br><br><pre> <code class="cpp hljs">Properties{ _InsideColor(<span class="hljs-string"><span class="hljs-string">"Inside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _OutsideColor(<span class="hljs-string"><span class="hljs-string">"Outside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) }</code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//global shader variables float4 _InsideColor; float4 _OutsideColor;</span></span></code> </pre> <br>  Ensuite, dans le fragment shader, nous v√©rifions o√π se trouve le pixel, que nous rendons en comparant la distance avec le signe √† 0 en utilisant la fonction <code>step</code> .  Nous utilisons cette variable pour interpoler de la couleur int√©rieure vers la couleur ext√©rieure et la rendre √† l'√©cran. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">fixed4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v2f i)</span></span></span><span class="hljs-function"> : SV_TARGET</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist = scene(i.worldPos.xz); fixed4 col = lerp(_InsideColor, _OutsideColor, step(<span class="hljs-number"><span class="hljs-number">0</span></span>, dist)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> col; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/989/13c/15b/98913c15b68cb3fcca4b6d1e4a3f70c0.gif"></div><br>  Pour rendre les lignes, nous devons d'abord sp√©cifier la fr√©quence de rendu des lignes et leur √©paisseur, en d√©finissant les propri√©t√©s et les variables de shader correspondantes. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Properties _LineDistance("Mayor Line Distance", Range(0, 2)) = 1 _LineThickness("Mayor Line Thickness", Range(0, 0.1)) = 0.05</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//shader variables float _LineDistance; float _LineThickness;</span></span></code> </pre> <br>  Ensuite, pour rendre les lignes, nous commencerons par calculer le changement de distance afin de pouvoir l'utiliser plus tard pour le lissage.  Nous l'avons √©galement d√©j√† divis√© par 2, car plus tard, nous en ajoutons la moiti√© et en soustrayons la moiti√© pour couvrir la distance de changement de 1 pixel. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distanceChange = fwidth(dist) * <span class="hljs-number"><span class="hljs-number">0.5</span></span>;</code> </pre> <br>  Ensuite, nous prenons la distance et la transformons pour qu'elle ait le m√™me comportement aux points de r√©p√©tition.  Pour ce faire, nous le divisons d'abord par la distance entre les lignes, alors que nous n'obtiendrons pas des nombres complets √† chaque premi√®re √©tape, mais des nombres complets uniquement sur la base de la distance que nous avons d√©finie. <br><br>  Ensuite, nous ajoutons 0,5 au nombre, prenons la partie fractionnaire et soustrayons √† nouveau 0,5.  La partie fractionnaire et la soustraction sont n√©cessaires ici pour que la ligne passe par z√©ro dans le motif r√©p√©titif.  Nous ajoutons 0,5 pour obtenir la partie fractionnaire afin de neutraliser une soustraction suppl√©mentaire de 0,5 - le d√©calage entra√Ænera le fait que les valeurs auxquelles le graphique est 0 sont √† 0, 1, 2, etc., et non √† 0,5, 1,5, etc. <br><br>  Les derni√®res √©tapes pour convertir la valeur - nous prenons la valeur absolue et la multiplions √† nouveau par la distance entre les lignes.  La valeur absolue fait que les zones avant et apr√®s les points de la ligne restent les m√™mes, ce qui facilite la cr√©ation d'√©cr√™tage pour les lignes.  La derni√®re op√©ration, dans laquelle nous multiplions √† nouveau la valeur par la distance entre les lignes, est n√©cessaire pour neutraliser la division au d√©but de l'√©quation, gr√¢ce √† elle, la variation de la valeur est √† nouveau la m√™me qu'au d√©but, et la variation pr√©c√©demment calcul√©e de la distance est toujours correcte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a89/db3/de9/a89db3de916eaf871c4525348272a635.png"></div><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> majorLineDistance = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(frac(dist / _LineDistance + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) - <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _LineDistance;</code> </pre> <br>  Maintenant que nous avons calcul√© la distance aux lignes en fonction de la distance √† la figure, nous pouvons tracer les lignes.  Nous faisons un pas en douceur de l'√©paisseur de ligne moins la moiti√© du changement de distance √† l'√©paisseur de ligne plus la moiti√© du changement de distance et utilisons la distance de ligne juste calcul√©e comme valeur de comparaison.  Apr√®s avoir calcul√© cette valeur, nous la multiplions par couleur pour cr√©er des lignes noires (vous pouvez √©galement utiliser une couleur diff√©rente si vous avez besoin de lignes multicolores). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">fixed4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v2f i)</span></span></span><span class="hljs-function"> : SV_TARGET</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist = scene(i.worldPos.xz); fixed4 col = lerp(_InsideColor, _OutsideColor, step(<span class="hljs-number"><span class="hljs-number">0</span></span>, dist)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distanceChange = fwidth(dist) * <span class="hljs-number"><span class="hljs-number">0.5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> majorLineDistance = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(frac(dist / _LineDistance + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) - <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _LineDistance; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> majorLines = smoothstep(_LineThickness - distanceChange, _LineThickness + distanceChange, majorLineDistance); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> col * majorLines; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/890/6b1/452/8906b1452c9d7a05f39b5c3070f2c547.gif"></div><br>  Nous impl√©mentons les lignes fines entre les lignes √©paisses de la m√™me mani√®re - nous ajoutons une propri√©t√© qui d√©termine le nombre de lignes fines entre les lignes √©paisses, puis nous faisons ce que nous avons fait avec les lignes √©paisses, mais en raison de la distance entre les lignes fines, nous divisons la distance entre les lignes √©paisses par le nombre de lignes fines entre eux.  Nous allons √©galement faire le nombre de lignes fines <code>IntRange</code> , gr√¢ce √† cela, nous ne pouvons affecter que des valeurs enti√®res et ne pas obtenir de lignes fines qui ne <code>IntRange</code> pas <code>IntRange</code> √©paisses.  Apr√®s avoir calcul√© les lignes fines, nous les multiplions par couleur de la m√™me mani√®re que les lignes √©paisses. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//properties [IntRange]_SubLines("Lines between major lines", Range(1, 10)) = 4 _SubLineThickness("Thickness of inbetween lines", Range(0, 0.05)) = 0.01</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//shader variables float _SubLines; float _SubLineThickness;</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">fixed4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v2f i)</span></span></span><span class="hljs-function"> : SV_TARGET</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist = scene(i.worldPos.xz); fixed4 col = lerp(_InsideColor, _OutsideColor, step(<span class="hljs-number"><span class="hljs-number">0</span></span>, dist)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distanceChange = fwidth(dist) * <span class="hljs-number"><span class="hljs-number">0.5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> majorLineDistance = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(frac(dist / _LineDistance + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) - <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _LineDistance; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> majorLines = smoothstep(_LineThickness - distanceChange, _LineThickness + distanceChange, majorLineDistance); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distanceBetweenSubLines = _LineDistance / _SubLines; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> subLineDistance = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(frac(dist / distanceBetweenSubLines + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) - <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * distanceBetweenSubLines; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> subLines = smoothstep(_SubLineThickness - distanceChange, _SubLineThickness + distanceChange, subLineDistance); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> col * majorLines * subLines; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e8c/664/bf0/e8c664bf0fb16337f77f242c4f3f5c01.gif"></div><br><h2>  Code source </h2><br><h3>  Fonctionnalit√©s SDF 2D </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/034_2D_SDF/2D_SDF.cginc</a> </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SDF_2D #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SDF_2D float2 rotate(float2 samplePosition, float rotation){ const float PI = 3.14159; float angle = rotation * PI * 2 * -1; float sine, cosine; sincos(angle, sine, cosine); return float2(cosine * samplePosition.x + sine * samplePosition.y, cosine * samplePosition.y - sine * samplePosition.x); } float2 translate(float2 samplePosition, float2 offset){ </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//move samplepoint in the opposite direction that we want to move shapes in return samplePosition - offset; } float2 scale(float2 samplePosition, float scale){ return samplePosition / scale; } float circle(float2 samplePosition, float radius){ //get distance from center and grow it according to radius return length(samplePosition) - radius; } float rectangle(float2 samplePosition, float2 halfSize){ float2 componentWiseEdgeDistance = abs(samplePosition) - halfSize; float outsideDistance = length(max(componentWiseEdgeDistance, 0)); float insideDistance = min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), 0); return outsideDistance + insideDistance; } #endif</span></span></span></span></code> </pre> <br><h3>  Exemple de cercle </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/034_2D_SDF/Circle.shader</a> </li></ul><br><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/034_2D_SDF_Basics/Rectangle"</span></span>{ SubShader{ <span class="hljs-comment"><span class="hljs-comment">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry Tags{ "RenderType"="Opaque" "Queue"="Geometry"} Pass{ CGPROGRAM #include "UnityCG.cginc" #include "2D_SDF.cginc" #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; struct v2f{ float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; v2f vert(appdata v){ v2f o; //calculate the position in clip space to render the object o.position = UnityObjectToClipPos(v.vertex); //calculate world position of vertex o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { float2 circlePosition = position; circlePosition = rotate(circlePosition, _Time.y * 0.5); circlePosition = translate(circlePosition, float2(2, 0)); float sceneDistance = rectangle(circlePosition, float2(1, 2)); return sceneDistance; } fixed4 frag(v2f i) : SV_TARGET{ float dist = scene(i.worldPos.xz); fixed4 col = fixed4(dist, dist, dist, 1); return col; } ENDCG } } FallBack "Standard" //fallback adds a shadow pass so we get shadows on other objects }</span></span></code> </pre> <br><h3>  Exemple de rectangle </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/034_2D_SDF/Rectangle.shader</a> </li></ul><br><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/034_2D_SDF_Basics/Rectangle"</span></span>{ SubShader{ <span class="hljs-comment"><span class="hljs-comment">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry Tags{ "RenderType"="Opaque" "Queue"="Geometry"} Pass{ CGPROGRAM #include "UnityCG.cginc" #include "2D_SDF.cginc" #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; struct v2f{ float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; v2f vert(appdata v){ v2f o; //calculate the position in clip space to render the object o.position = UnityObjectToClipPos(v.vertex); //calculate world position of vertex o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { float2 circlePosition = position; circlePosition = rotate(circlePosition, _Time.y * 0.5); circlePosition = translate(circlePosition, float2(2, 0)); float sceneDistance = rectangle(circlePosition, float2(1, 2)); return sceneDistance; } fixed4 frag(v2f i) : SV_TARGET{ float dist = scene(i.worldPos.xz); fixed4 col = fixed4(dist, dist, dist, 1); return col; } ENDCG } } FallBack "Standard" //fallback adds a shadow pass so we get shadows on other objects }</span></span></code> </pre> <br><h3>  Coupure </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/034_2D_SDF/Cutoff.shader</a> </li></ul><br><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/034_2D_SDF_Basics/Cutoff"</span></span>{ Properties{ _Color(<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) } SubShader{ Tags{ <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span>} Blend SrcAlpha OneMinusSrcAlpha ZWrite Off Pass{ CGPROGRAM #include <span class="hljs-string"><span class="hljs-string">"UnityCG.cginc"</span></span> #include <span class="hljs-string"><span class="hljs-string">"2D_SDF.cginc"</span></span> #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v2f</span></span></span><span class="hljs-class">{</span></span> float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; fixed3 _Color; <span class="hljs-function"><span class="hljs-function">v2f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(appdata v)</span></span></span></span>{ v2f o; <span class="hljs-comment"><span class="hljs-comment">//calculate the position in clip space to render the object o.position = UnityObjectToClipPos(v.vertex); //calculate world position of vertex o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { float2 circlePosition = position; circlePosition = rotate(circlePosition, _Time.y * 0.5); circlePosition = translate(circlePosition, float2(2, 0)); float sceneDistance = rectangle(circlePosition, float2(1, 2)); return sceneDistance; } fixed4 frag(v2f i) : SV_TARGET{ float dist = scene(i.worldPos.xz); float distanceChange = fwidth(dist) * 0.5; float antialiasedCutoff = smoothstep(distanceChange, -distanceChange, dist); fixed4 col = fixed4(_Color, antialiasedCutoff); return col; } ENDCG } } FallBack "Standard" //fallback adds a shadow pass so we get shadows on other objects }</span></span></code> </pre> <br><h3>  Lignes de distance </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/034_2D_SDF/DistanceLines.shader</a> </li></ul><br><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/034_2D_SDF_Basics/DistanceLines"</span></span>{ Properties{ _InsideColor(<span class="hljs-string"><span class="hljs-string">"Inside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _OutsideColor(<span class="hljs-string"><span class="hljs-string">"Outside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _LineDistance(<span class="hljs-string"><span class="hljs-string">"Mayor Line Distance"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) = <span class="hljs-number"><span class="hljs-number">1</span></span> _LineThickness(<span class="hljs-string"><span class="hljs-string">"Mayor Line Thickness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.05</span></span> [IntRange]_SubLines(<span class="hljs-string"><span class="hljs-string">"Lines between major lines"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)) = <span class="hljs-number"><span class="hljs-number">4</span></span> _SubLineThickness(<span class="hljs-string"><span class="hljs-string">"Thickness of inbetween lines"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.05</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.01</span></span> } SubShader{ <span class="hljs-comment"><span class="hljs-comment">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry Tags{ "RenderType"="Opaque" "Queue"="Geometry"} Pass{ CGPROGRAM #include "UnityCG.cginc" #include "2D_SDF.cginc" #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; struct v2f{ float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; v2f vert(appdata v){ v2f o; //calculate the position in clip space to render the object o.position = UnityObjectToClipPos(v.vertex); //calculate world position of vertex o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { float2 circlePosition = position; circlePosition = rotate(circlePosition, _Time.y * 0.2); circlePosition = translate(circlePosition, float2(2, 0)); float sceneDistance = rectangle(circlePosition, float2(1, 2)); return sceneDistance; } float4 _InsideColor; float4 _OutsideColor; float _LineDistance; float _LineThickness; float _SubLines; float _SubLineThickness; fixed4 frag(v2f i) : SV_TARGET{ float dist = scene(i.worldPos.xz); fixed4 col = lerp(_InsideColor, _OutsideColor, step(0, dist)); float distanceChange = fwidth(dist) * 0.5; float majorLineDistance = abs(frac(dist / _LineDistance + 0.5) - 0.5) * _LineDistance; float majorLines = smoothstep(_LineThickness - distanceChange, _LineThickness + distanceChange, majorLineDistance); float distanceBetweenSubLines = _LineDistance / _SubLines; float subLineDistance = abs(frac(dist / distanceBetweenSubLines + 0.5) - 0.5) * distanceBetweenSubLines; float subLines = smoothstep(_SubLineThickness - distanceChange, _SubLineThickness + distanceChange, subLineDistance); return col * majorLines * subLines; } ENDCG } } FallBack "Standard" //fallback adds a shadow pass so we get shadows on other objects }</span></span></code> </pre> <br>  J'esp√®re avoir r√©ussi √† expliquer les bases des champs de signe de distance, et vous attendez d√©j√† quelques nouveaux tutoriels dans lesquels je parlerai d'autres fa√ßons de les utiliser. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr438316/">https://habr.com/ru/post/fr438316/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr438304/index.html">Sous-traitance? Cool tu frappes</a></li>
<li><a href="../fr438306/index.html">Rayonnement: Laboratoire radiochimique en semaine</a></li>
<li><a href="../fr438310/index.html">Instagram utilise l'apprentissage automatique pour supprimer les faux abonn√©s</a></li>
<li><a href="../fr438312/index.html">Automatisation r√©seau avec Ansible: module de commande</a></li>
<li><a href="../fr438314/index.html">1. Check Point Maestro Hyperscale Network Security - une nouvelle plate-forme de s√©curit√© √©volutive</a></li>
<li><a href="../fr438318/index.html">Comment ma√Ætriser la syntaxe asynchrone / wait: un exemple r√©el</a></li>
<li><a href="../fr438320/index.html">Apprendre aux enfants √† programmer</a></li>
<li><a href="../fr438322/index.html">VSaaS 2025: la technologie CCTV du futur</a></li>
<li><a href="../fr438326/index.html">La 5G en Russie: pourquoi est-elle n√©cessaire, combien co√ªte-t-elle et quand appara√Ætra-t-elle? En bref sur l'essentiel</a></li>
<li><a href="../fr438328/index.html">Comment gonfl√© la bulle salariale des programmeurs?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>