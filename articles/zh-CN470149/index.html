<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍⚕️ 🙋🏻 📱 Java中将不会有不可变的集合-现在或现在都不会 🧝🏼 🈂️ 🥫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家好！ 

 今天，请您注意一篇关于Java的基本问题之一-可变性，以及它如何影响数据结构的结构以及如何使用它们的精心撰写的文章的翻译。 资料取材于Nicolai Parlog的博客，我们真正尝试保留其辉煌的文学风格。 尼古拉斯本人的特点是摘自哈布雷（Habé）JUG.ru公司博客的摘录 。 让我...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Java中将不会有不可变的集合-现在或现在都不会</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/470149/"> 大家好！ <br><br> 今天，请您注意一篇关于Java的基本问题之一-可变性，以及它如何影响数据结构的结构以及如何使用它们的精心撰写的文章的翻译。 资料取材于Nicolai Parlog的博客，我们真正尝试保留其辉煌的文学风格。 尼古拉斯本人的特点是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">摘自</a>哈布雷（Habé）JUG.ru公司<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">博客</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">摘录</a> 。 让我们完整地引用这段话： <br><br><img src="https://habrastorage.org/webt/7l/mh/iy/7lmhiypudt5z093eme-wrlhzygq.jpeg"><br><blockquote> 尼古拉·帕洛格（Nikolay Parlog）就是这样的媒体佬，他对Java功能进行评论。 但是他不是同时来自Oracle，因此这些评论出奇的坦率和易于理解。 有时在他们被解雇之后，却很少。  Nikolay将讨论Java的未来，以及新版本中的内容。 他擅长于谈论趋势以及关于大世界的信息。 他是一个很好的阅读和博学的同伴。 每当您学习新内容时，即使简单的报告也很令人愉快。 而且，尼古拉斯无所不知。 也就是说，即使根本不是您的话题，您也可以访问任何报告并享受它。 他在教书。 他为曼宁出版社（Manning Publishing House）撰写了“ Java模块系统”，在codefx.org上维护有关软件开发的博客，并且长期参与多个开源项目。 他是自由职业者，可以在会议上立即聘用。 是的，一个非常昂贵的自由职业者。 这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">报告</a> 。 </blockquote><br> 我们阅读并投票。 谁特别喜欢该帖子-我们还建议您查看读者对原始帖子的评论。 <br><a name="habracut"></a><br> 波动性不好，对吗？ 因此， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不变性是良好的</a> 。 不变性特别有用的主要数据结构是集合：在Java中，它是一个列表（ <code>List</code> ），一个集合（ <code>Set</code> ）和一个字典（ <code>Map</code> ）。 但是，尽管JDK带有不可变（或不可修改？）集合，但是类型系统对此一无所知。  JDK中没有<code>ImmutableList</code> ，而Guava的这种类型对我来说似乎完全没有用。 但是为什么呢？ 为什么不只是将<code>Immutable...</code>添加到此混合中，而不是说应该混合呢？ <br><br><h4> 什么是不可变集合？ </h4><br> 在JDK术语中，“ <i>不可变</i> ”和“ <i>不可修改</i> ”一词的含义在过去几年中发生了变化。 最初，“不可修改的”被称为不允许可变性（mutability）的实例：为了响应不断变化的方法，他抛出了<code>UnsupportedOperationException</code> 。 但是，可以用另一种方式更改它-可能是因为它只是可变集合的包装。 这些视图反映在<code>Collections::unmodifiableList</code> ， <code>unmodifiableSet</code>和<code>unmodifiableMap</code>方法<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">及其JavaDoc中</a> 。 <br><br> 最初，术语“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不可变</a> ”是指<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Java 9集合</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">工厂方法</a>返回的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">集合</a> 。 集合本身无法进行任何更改（是的，存在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">反射</a> ，但是不算在内），因此，似乎它们可以证明其名称合理。  las，因此经常会造成混乱。 假设有一种方法可以在屏幕上显示不可变集合中的所有元素-它会始终提供相同的结果吗？  ?？ 还是不行 <br><br> 如果您没有立即回答“ <i>否”</i> ，则意味着您只是对这里可能出现的混乱情况有所了解。  “ <i>秘密代理的不可变集合</i> ”-听起来与“ <i>不可变的秘密代理的不可变集合</i> ”非常相似<i>，</i>但是这两个实体可能并不相同。 一个不可变的收藏集不能使用插入/删除/清除操作等进行编辑，但是，如果秘密特工是可变的（尽管间谍电影中的角色发展非常糟糕，以至于您根本不相信它），那并不意味着它整个秘密特工的收藏是不变的。 因此，现在有一种趋势是将此类集合命名为<i>不可修改的</i>而不是<i>不可变的</i> ，这已在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">新版JavaDoc中得到了体现</a> 。 <br><br> 本文讨论的不可变集合可能包含可变元素。 <br><br> 我个人不喜欢这样的术语修订。 我认为，“不变的收藏”一词仅意味着收藏本身不宜更改，而不能描述其中包含的要素。 在这种情况下，还有一个更积极的观点：Java生态系统中的“不变性”一词并没有完全变成废话。 <br><br> 一种或另一种方式，在本文中，我们将讨论<i>不可变集合</i> ，其中... <br><br><ul><li> 集合中包含的实例在设计阶段确定 </li><li> 这些副本-数量均匀，既不减少也不增加 </li><li> 没有关于这些元素的可变性的陈述。 </li></ul><br> 让我们详细谈谈现在我们将练习添加不可变集合的事实。 准确地说-不可变的列表。 关于列表的所有说明都同样适用于其他类型的集合。 <br><br> 开始添加不可变的集合！ <br><br> 让我们创建<code>ImmutableList</code>接口，并使其相对于<code>List</code> ，呃……是什么？ 是超型还是亚型？ 让我们来谈谈第一个选项。 <br><br><img src="https://habrastorage.org/webt/sc/uv/yl/scuvyloeubhj5-wq36b7nzuzdu8.png"><br><br> 精美地讲， <code>ImmutableList</code>没有<code>ImmutableList</code>方法，因此使用它总是安全的，对吗？ 那么？！ 不，长官 <br><br><pre> <code class="java hljs">List&lt;Agent&gt; agents = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-comment"><span class="hljs-comment">// ,  `List`  `ImmutableList` ImmutableList&lt;Agent&gt; section4 = agents; //    section4.forEach(System.out::println); //    `section4` agents.add(new Agent("Motoko"); //  "Motoko" – ,      ?! section4.forEach(System.out::println);</span></span></code> </pre> <br> 此示例表明，可以将这样一个不完全不变的列表传输到API，该列表的操作可以建立在不变性之上，因此，使该类型名称可能暗示的所有保证都无效。 这是给您的食谱，可能会导致灾难。 <br><br> 好的，然后<code>ImmutableList</code>扩展<code>List</code> 。 也许吧 <br><br><img src="https://habrastorage.org/webt/fr/sq/_r/frsq_rgj7rt0mp3u0f--zn8jlrs.png"><br><br> 现在，如果API期望一个不可变的列表，那么它将收到这样的列表，但是有两个缺点： <br><br><ul><li> 不可变列表仍应提供修改方法（因为它们是在超类型中定义的），并且唯一可能的实现将引发异常 </li><li>  <code>ImmutableList</code>实例也是<code>List</code>实例，并且当分配给这样的变量，作为这样的参数传递或以这种类型返回时，逻辑上是假定允许可变性。 </li></ul><br> 因此，事实证明，您只能在本地使用<code>ImmutableList</code> ，因为它通过API边界作为<code>List</code>传递，这需要您采取超人的预防措施，否则会在运行时爆炸。 它不像扩展<code>ImmutableList</code>的<code>List</code>那样糟糕，但是这样的解决方案仍然远非理想。 <br><br> 当我说Guava的<code>ImmutableList</code>类型实际上是无用的时，这正是我想到的。 这是一个很棒的代码示例，在处理本地不可变列表时非常可靠（这就是我积极使用它的原因），但是，依靠它，很容易超越不可渗透的，有保证的已编译城堡，城堡的墙壁由不可变类型组成，并且仅在此范围内不变类型可以充分发挥其潜力。 这总比没有好，但作为JDK解决方案效率低下。 <br><br> 如果<code>ImmutableList</code>无法扩展<code>List</code> ，并且解决方法仍然不起作用，那么应该如何使其全部起作用？ <br><br><h4> 不变性是一个特征 </h4><br> 我们在前两次尝试添加不可变类型时遇到的问题是我们的误解，认为不可变性只是缺少某种东西：我们获取一个<code>List</code> ，从其中删除更改的代码，得到一个<code>ImmutableList</code> 。 但是，实际上，所有这一切都不是那样。 <br><br> 如果仅从<code>List</code>删除修改方法，则会得到一个只读列表。 或者，遵循上述公式，可以将其称为<code>UnmodifiableList</code>它仍然可以更改，只是您不会更改。 <br><br> 现在，我们可以在此图片中添加另外两件事： <br><br><ul><li> 我们可以通过添加适当的方法使其变得可变 </li><li> 我们可以通过添加适当的保证使其不可变。 </li></ul><br> 不变性不是没有可变性，而是保证不会有任何变化 <br> 在这种情况下，重要的是要了解在两种情况下我们都在谈论完整功能-不变性不是没有更改，而是保证不会有更改。 现有功能可能不一定是有用的东西，它还可以保证代码中不会发生不好的事情-在这种情况下，例如，考虑线程安全性。 <br><br> 显然，可变性和不变性相互冲突，因此我们不能同时使用上述两个继承层次结构。 类型从其他类型继承功能，因此，无论您如何削减它们，如果其中一个类型从其他类型继承，它将包含两个功能。 <br><br> 很好， <code>List</code>和<code>ImmutableList</code>不能互相扩展。 但是我们是通过使用<code>UnmodifiableList</code>来到这里的，实际上这两种类型都具有相同的API（只读），这意味着它们应该扩展它。 <br><br><img src="https://habrastorage.org/webt/bd/dp/7b/bddp7bjb5e9m6sddvp4slse0yfi.png"><br><br> 虽然，我不会确切地称呼这些名称，但这种层次结构是合理的。 例如，在Scala中， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">实际上是这样做的</a> 。 区别在于，共享超类型（我们称为<code>UnmodifiableList</code> ）定义了可变方法，这些方法返回修改后的集合并保持原始状态不变。 因此，一个不可变的列表证明是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">持久的，</a>并为可变变体提供了两组修改方法-继承来接收修改后的副本，以及为更改而拥有的副本。 <br><br>  Java呢？ 通过向其添加新的超类型和同级结构，是否有可能使这种层次结构现代化？ <br><br> 是否可以改善不可修改且不可更改的收藏？ <br> 当然，添加<code>UnmodifiableList</code>和<code>ImmutableList</code>并创建上述继承层次结构没有问题。 问题是，从短期和中期来看，它将几乎无用。 让我解释一下。 <br><br>  <code>ImmutableList</code>将<code>UnmodifiableList</code> ， <code>ImmutableList</code>和<code>List</code>作为类型-在这种情况下，API将能够清楚地表达它们的需求和提供的内容。 <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">payAgents</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UnmodifiableList&lt;Agent&gt; agents)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      , //         } public void sendOnMission(ImmutableList&lt;Agent&gt; agents) { //   ( ), //  ,     } public void downtime(List&lt;Agent&gt; agents) { //       , //        ,      } public UnmodifiableList&lt;Agent&gt; teamRoster() { //   ,     , //      ,     -  } public ImmutableList&lt;Agent&gt; teamOnMission() { //    ,      } public List&lt;Agent&gt; team() { //    ,    , //        }</span></span></code> </pre> <br> 但是，除非您从头开始该项目，否则您可能会具有这样的功能，并且它将看起来像这样： <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,  `Iterable&lt;Agent&gt;` //  ,   ,        public void payAgents(List&lt;Agent&gt; agents) { } public void sendOnMission(List&lt;Agent&gt; agents) { } public void downtime(List&lt;Agent&gt; agents) { } //      , //    ,  `List`     public List&lt;Agent&gt; teamRoster() { } // ,     `Stream&lt;Agent&gt;` public List&lt;Agent&gt; teamOnMission() { } public List&lt;Agent&gt; team() { }</span></span></code> </pre> <br> 这不好，因为为了使我们刚刚介绍的新系列有用，我们需要与他们合作！  （phe） 上面的代码让人想起应用程序代码，因此，重构会<code>ImmutableList</code> <code>UnmodifiableList</code>和<code>ImmutableList</code> ，您可以实现它，如上面的清单所示。 这可能是很大的工作量，并且在您需要组织旧代码与更新代码的交互时会造成混乱，但至少看来是可行的。 <br><br> 框架，库和JDK本身呢？ 这里的一切看起来都黯淡无光。 尝试将参数或返回类型从<code>List</code>更改为<code>ImmutableList</code>会导致<i>与源代码不兼容</i> ，即 现有的源代码将无法与新版本一起编译，因为这些类型彼此无关。 同样，将返回类型从<code>List</code>更改为新的超类型<code>UnmodifiableList</code>会导致编译错误。 <br><br> 随着新类型的引入，有必要在整个生态系统中进行更改和重新编译。 <br><br> 但是，即使将参数类型从<code>List</code>扩展到<code>UnmodifiableList</code> ，也会遇到问题，因为这样的更改会导致<i>字节码级别的不兼容</i> 。 当源代码调用方法时，编译器将通过以下方式将此调用转换为引用目标方法的字节码： <br><br><ul><li> 声明目标实例的类的名称 </li><li> 方法名称 </li><li> 方法参数类型 </li><li> 方法返回类型 </li></ul><br> 方法的参数或返回类型的任何更改都将导致字节码在引用该方法时指示错误的签名。 结果，在执行期间将发生<code>NoSuchMethodError</code>错误。 如果您所做的更改与源代码兼容（例如，如果您正在谈论缩小返回类型或扩展参数的类型），那么重新编译就足够了。 但是，随着影响深远的变化，例如引入新的集合，一切都不那么简单：为了整合这些变化，您需要重新编译整个Java生态系统。 这是丢失的业务。 <br><br> 在不破坏兼容性的情况下利用此类新集合的唯一可能方法是使用新名称复制每个现有方法，更改API，然后将旧版本标记为不受欢迎。 您能想象这样一项任务多么艰巨和几乎无限大吗？ <br><br><h4> 倒影 </h4><br> 当然，不可变的集合类型是我很想拥有的一件好事，但是我们不太可能在JDK中看到类似的东西。  <code>List</code>和<code>ImmutableList</code>永远不能相互扩展（实际上，它们都扩展了相同的列表类型<code>UnmodifiableList</code> ，这是只读的），这使得很难将此类类型集成到现有的API中。 <br><br> 在类型之间任何特定关系的上下文之外，更改现有方法签名总是充满问题，因为此类更改与字节码不兼容。 引入它们时，至少需要重新编译，这是一个灾难性的变化，将影响整个Java生态系统。 <br><br> 因此，我相信这样的事情将不会发生-永远不会。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN470149/">https://habr.com/ru/post/zh-CN470149/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN470127/index.html">作曲家有很长的短期记忆</a></li>
<li><a href="../zh-CN470129/index.html">声明式内存管理</a></li>
<li><a href="../zh-CN470135/index.html">无需编程的交互式Web应用程序？ 容易！ Mavo在你的怀里</a></li>
<li><a href="../zh-CN470139/index.html">2个生活技巧：Microsoft SQL Server中传统搜索的替代方法</a></li>
<li><a href="../zh-CN470145/index.html">“当心，FAS！”：为什么军用票在广告中很危险，为什么重要的是要知道数学，是否总是需要真实的事实</a></li>
<li><a href="../zh-CN470153/index.html">数据模型字典</a></li>
<li><a href="../zh-CN470155/index.html">国家模式识别的特点</a></li>
<li><a href="../zh-CN470159/index.html">黄金一代</a></li>
<li><a href="../zh-CN470167/index.html">在科学成为主流之前针对那些对科学感兴趣的人召开的会议</a></li>
<li><a href="../zh-CN470169/index.html">如何防止这个想法消亡并组建一支不会杀死她的团队</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>