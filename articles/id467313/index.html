<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛃 🎺 👩🏾‍🚀 Replikasi Lintas Antara PostgreSQL dan MySQL 🏡 🀄️ 👩🏾‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya akan menguraikan replikasi silang antara PostgreSQL dan MySQL, serta metode untuk mengatur replikasi silang antara dua server database ini. Biasa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Replikasi Lintas Antara PostgreSQL dan MySQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/467313/"><p><img src="https://habrastorage.org/webt/ze/m9/h6/zem9h6cpvow7junwu4saxpddvpa.jpeg"></p><br><p>  Saya akan menguraikan replikasi silang antara PostgreSQL dan MySQL, serta metode untuk mengatur replikasi silang antara dua server database ini.  Biasanya, database replikasi silang disebut homogen, dan ini adalah metode yang nyaman untuk berpindah dari satu server basis data relasional ke yang lain. </p><br><p>  Database PostgreSQL dan MySQL dianggap relasional, tetapi dengan ekstensi tambahan mereka menawarkan fitur NoSQL.  Di sini kita akan membahas replikasi antara PostgreSQL dan MySQL, dalam hal DBMS relasional. </p><br><p>  Kami tidak akan menjelaskan seluruh dapur dalam, hanya prinsip-prinsip dasar, sehingga Anda mendapatkan ide tentang cara mengkonfigurasi replikasi antara server database, kelebihan, batasan, dan skenario penggunaan. </p><a name="habracut"></a><br><p>  Biasanya, replikasi antara dua server database identik dilakukan dalam mode biner atau melalui permintaan antara master node (itu adalah penerbit, master atau aktif) dan budak (pelanggan, tertunda atau pasif).  Tujuan replikasi adalah untuk menyediakan salinan real-time dari database master di sisi slave.  Dalam hal ini, data ditransfer dari master ke slave, yaitu dari aktif ke pasif, karena replikasi dilakukan hanya dalam satu arah.  Tetapi Anda dapat mengkonfigurasi replikasi antara dua database di kedua arah, sehingga data ditransfer dari slave ke master dalam konfigurasi aktif-aktif.  Semua ini, termasuk replikasi bertingkat, mungkin antara dua atau lebih server database yang identik. Konfigurasi aktif-aktif atau aktif-pasif tergantung pada kebutuhan, ketersediaan fitur-fitur tersebut dalam konfigurasi awal, atau penggunaan solusi konfigurasi eksternal dan pertukaran yang ada. . </p><br><p> Konfigurasi yang dijelaskan dimungkinkan antara server database yang berbeda.  Server dapat dikonfigurasi untuk menerima data yang direplikasi dari server basis data lain dan masih menyimpan snapshot real-time dari data yang direplikasi.  MySQL dan PostgreSQL menawarkan sebagian besar konfigurasi ini sendiri atau dengan ekstensi pihak ketiga, termasuk metode log biner, kunci disk, dan metode berbasis pernyataan dan string. </p><br><p>  Replikasi silang antara MySQL dan PostgreSQL diperlukan untuk migrasi tunggal dari satu server basis data ke yang lain.  Database ini menggunakan protokol yang berbeda, sehingga tidak dapat terhubung secara langsung.  Untuk membangun pertukaran data, Anda dapat menggunakan alat open source eksternal, misalnya pg_chameleon. </p><br><h3 id="chto-takoe-pg_chameleon">  Apa itu pg_chameleon </h3><br><p>  pg_chameleon adalah sistem replikasi dari MySQL ke PostgreSQL dengan Python 3. Menggunakan pustaka sumber terbuka mysql-replikasi, juga dalam Python.  Gambar string diekstraksi dari tabel MySQL dan disimpan sebagai objek JSONB dalam database PostgreSQL, dan kemudian didekripsi oleh fungsi pl / pgsql dan diputar ulang dalam database PostgreSQL. </p><br><h3 id="vozmozhnosti-pg_chameleon">  Fitur Pg_chameleon </h3><br><p>  Beberapa skema MySQL dari cluster yang sama dapat direplikasi ke database target PostgreSQL yang sama dengan konfigurasi satu-ke-banyak <br>  Nama-nama skema sumber dan target tidak dapat cocok. <br>  Data replikasi dapat diambil dari replika MySQL bertingkat. <br>  Tabel yang tidak dapat mereplikasi atau menghasilkan kesalahan dikecualikan. <br>  Setiap fungsi replikasi dikendalikan oleh daemon. <br>  Kontrol menggunakan parameter dan file konfigurasi berdasarkan YAML. </p><br><h3 id="primer">  Contoh </h3><br><div class="scrollable-table"><table><thead><tr><th>  Tuan rumah </th><th>  vm1 </th><th>  vm2 </th></tr></thead><tbody><tr><td>  <strong>Versi OS</strong> </td><td>  CentOS Linux 7.6 x86_64 </td><td>  CentOS Linux 7.5 x86_64 </td></tr><tr><td>  <strong>Versi server DB</strong> </td><td>  MySQL 5.7.26 </td><td>  PostgreSQL 10.5 </td></tr><tr><td>  <strong>Port DB</strong> </td><td>  3306 </td><td>  5433 </td></tr><tr><td>  <strong>Alamat IP</strong> </td><td>  192.168.56.102 </td><td>  192.168.56.106 </td></tr></tbody></table></div><br><p>  Untuk memulai, siapkan semua komponen yang diperlukan untuk menginstal pg_chameleon.  Dalam contoh ini, Python 3.6.8 diinstal, yang menciptakan lingkungan virtual dan mengaktifkannya. </p><br><pre><code class="plaintext hljs">$&gt; wget https://www.python.org/ftp/python/3.6.8/Python-3.6.8.tar.xz $&gt; tar -xJf Python-3.6.8.tar.xz $&gt; cd Python-3.6.8 $&gt; ./configure --enable-optimizations $&gt; make altinstall</code> </pre> <br><p>  Setelah berhasil menginstal Python3.6, Anda harus memenuhi persyaratan lain, misalnya, membuat dan mengaktifkan lingkungan virtual.  Selain itu, modul pip diperbarui ke versi terbaru dan digunakan untuk menginstal pg_chameleon.  Dalam perintah di bawah ini, pg_chameleon 2.0.9 sengaja diinstal, meskipun versi terbaru adalah 2.0.10.  Ini diperlukan untuk menghindari bug baru di versi yang diperbarui. </p><br><pre> <code class="plaintext hljs">$&gt; python3.6 -m venv venv $&gt; source venv/bin/activate (venv) $&gt; pip install pip --upgrade (venv) $&gt; pip install pg_chameleon==2.0.9</code> </pre> <br><p>  Kemudian kita memanggil pg_chameleon (bunglon adalah perintah) dengan argumen set_configuration_files untuk mengaktifkan pg_chameleon dan membuat direktori default dan file konfigurasi. </p><br><pre> <code class="plaintext hljs">(venv) $&gt; chameleon set_configuration_files creating directory /root/.pg_chameleon creating directory /root/.pg_chameleon/configuration/ creating directory /root/.pg_chameleon/logs/ creating directory /root/.pg_chameleon/pid/ copying configuration example in /root/.pg_chameleon/configuration//config-example.yml</code> </pre> <br><p>  Sekarang kita membuat salinan config-example.yml sebagai default.yml sehingga menjadi file konfigurasi default.  Contoh file konfigurasi untuk contoh ini ditunjukkan di bawah ini. </p><br><pre> <code class="plaintext hljs">$&gt; cat default.yml --- #global settings pid_dir: '~/.pg_chameleon/pid/' log_dir: '~/.pg_chameleon/logs/' log_dest: file log_level: info log_days_keep: 10 rollbar_key: '' rollbar_env: '' # type_override allows the user to override the default type conversion into a different one. type_override: "tinyint(1)": override_to: boolean override_tables: - "*" #postgres destination connection pg_conn: host: "192.168.56.106" port: "5433" user: "usr_replica" password: "pass123" database: "db_replica" charset: "utf8" sources: mysql: db_conn: host: "192.168.56.102" port: "3306" user: "usr_replica" password: "pass123" charset: 'utf8' connect_timeout: 10 schema_mappings: world_x: pgworld_x limit_tables: # - delphis_mediterranea.foo skip_tables: # - delphis_mediterranea.bar grant_select_to: - usr_readonly lock_timeout: "120s" my_server_id: 100 replica_batch_size: 10000 replay_max_rows: 10000 batch_retention: '1 day' copy_max_memory: "300M" copy_mode: 'file' out_dir: /tmp sleep_loop: 1 on_error_replay: continue on_error_read: continue auto_maintenance: "disabled" gtid_enable: No type: mysql skip_events: insert: - delphis_mediterranea.foo #skips inserts on the table delphis_mediterranea.foo delete: - delphis_mediterranea #skips deletes on schema delphis_mediterranea update:</code> </pre> <br><p>  File konfigurasi dalam contoh ini adalah file sampel dengan pg_chameleon dengan perubahan kecil sesuai dengan lingkungan sumber dan target, dan berikut ini adalah ikhtisar dari berbagai bagian file konfigurasi. </p><br><p>  Di file konfigurasi default.yml, ada bagian pengaturan global di mana Anda dapat mengontrol pengaturan seperti lokasi file kunci, lokasi log, periode penyimpanan log, dll. Bagian selanjutnya adalah bagian override jenis, di mana set ditentukan aturan untuk mengganti jenis selama replikasi.  Contoh default menggunakan aturan redefinisi tipe yang mengubah tinyint (1) menjadi nilai boolean.  Di bagian selanjutnya, kami menunjukkan detail koneksi ke database target.  Dalam kasus kami, ini adalah database PostgreSQL yang ditunjuk sebagai pg_conn.  Pada bagian terakhir, kami menunjukkan data sumber, yaitu parameter koneksi dari database sumber, skema pemetaan sumber dan database target, tabel yang akan dilewati, batas waktu, memori, dan ukuran paket.  Perhatikan bahwa "sumber" ditunjukkan dalam bentuk jamak, yaitu, kita dapat menambahkan beberapa basis data sumber untuk target yang sama untuk mengonfigurasi konfigurasi banyak-ke-satu. </p><br><p>  Database world_x dalam contoh berisi 4 tabel dengan baris yang ditawarkan oleh komunitas MySQL sebagai contoh.  Itu bisa diunduh di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Database sampel datang dalam bentuk tar dan arsip terkompresi dengan instruksi untuk membuat dan mengimpor string. </p><br><p>  Pengguna khusus dibuat di database MySQL dan PostgreSQL dengan nama yang sama usr_replica.  Di MySQL, ia diberikan hak tambahan untuk membaca semua tabel yang direplikasi. </p><br><pre> <code class="plaintext hljs">mysql&gt; CREATE USER usr_replica ; mysql&gt; SET PASSWORD FOR usr_replica='pass123'; mysql&gt; GRANT ALL ON world_x.* TO 'usr_replica'; mysql&gt; GRANT RELOAD ON *.* to 'usr_replica'; mysql&gt; GRANT REPLICATION CLIENT ON *.* to 'usr_replica'; mysql&gt; GRANT REPLICATION SLAVE ON *.* to 'usr_replica'; mysql&gt; FLUSH PRIVILEGES;</code> </pre> <br><p>  Di sisi PostgreSQL, database db_replica dibuat, yang akan menerima perubahan dari database MySQL.  Pengguna usr_replica PostgreSQL secara otomatis dikonfigurasikan sebagai pemilik dua skema pgworld_x dan sch_chameleon yang masing-masing berisi tabel dan tabel yang direplikasi dengan direktori replikasi.  Argumen create_replica_schema bertanggung jawab untuk konfigurasi otomatis, seperti yang akan Anda lihat di bawah. </p><br><pre> <code class="plaintext hljs">postgres=# CREATE USER usr_replica WITH PASSWORD 'pass123'; CREATE ROLE postgres=# CREATE DATABASE db_replica WITH OWNER usr_replica; CREATE DATABASE</code> </pre> <br><p>  Database MySQL dikonfigurasikan dengan beberapa perubahan untuk mempersiapkannya untuk replikasi, seperti yang ditunjukkan di bawah ini.  Anda perlu me-restart server database agar perubahan diterapkan. </p><br><pre> <code class="plaintext hljs">$&gt; vi /etc/my.cnf binlog_format= ROW binlog_row_image=FULL log-bin = mysql-bin server-id = 1</code> </pre> <br><p>  Sekarang penting untuk memeriksa koneksi ke kedua server basis data sehingga tidak ada masalah ketika menjalankan perintah pg_chameleon. </p><br><p>  Pada simpul PostgreSQL: </p><br><pre> <code class="plaintext hljs">$&gt; mysql -u usr_replica -Ap'admin123' -h 192.168.56.102 -D world_x</code> </pre> <br><p>  Pada simpul MySQL: </p><br><pre> <code class="plaintext hljs">$&gt; psql -p 5433 -U usr_replica -h 192.168.56.106 db_replica</code> </pre> <br><p>  Tiga perintah pg_chameleon (bunglon) berikut mempersiapkan lingkungan, menambahkan sumber, dan menginisialisasi replika.  Argumen create_replica_schema di pg_chameleon membuat skema default (sch_chameleon) dan skema replikasi (pgworld_x) dalam database PostgreSQL, seperti yang sudah kami katakan.  Argumen add_source menambahkan database asli ke konfigurasi dengan membaca file konfigurasi (default.yml), dan dalam kasus kami ini adalah mysql, dan init_replica menginisialisasi konfigurasi berdasarkan parameter pada file konfigurasi. </p><br><pre> <code class="plaintext hljs">$&gt; chameleon create_replica_schema --debug $&gt; chameleon add_source --config default --source mysql --debug $&gt; chameleon init_replica --config default --source mysql --debug</code> </pre> <br><p>  Output dari ketiga perintah ini jelas menunjukkan eksekusi yang sukses.  Semua kesalahan crash atau sintaks ditunjukkan dalam pesan sederhana dan jelas dengan tips pemecahan masalah. </p><br><p>  Terakhir, mulailah replikasi dengan start_replica dan dapatkan pesan sukses. </p><br><pre> <code class="plaintext hljs">$&gt; chameleon start_replica --config default --source mysql output: Starting the replica process for source mysql</code> </pre> <br><p>  Status replikasi dapat diminta menggunakan argumen show_status, dan kesalahan dapat dilihat menggunakan argumen show_errors. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hasil.</a> </p><br><p>  Seperti yang kami katakan sebelumnya, setiap fungsi replikasi dikendalikan oleh daemon.  Untuk melihatnya, kami meminta tabel proses dengan perintah Linux ps, seperti yang ditunjukkan di bawah ini. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hasil.</a> </p><br><p>  Replikasi tidak dianggap dikonfigurasi sampai kami mengujinya secara langsung, seperti yang ditunjukkan di bawah ini.  Kami membuat tabel, menyisipkan beberapa catatan dalam database MySQL, dan memanggil argumen sync_tables di pg_chameleon untuk memperbarui daemon dan mereplikasi tabel dengan catatan dalam database PostgreSQL. </p><br><pre> <code class="plaintext hljs">mysql&gt; create table t1 (n1 int primary key, n2 varchar(10)); Query OK, 0 rows affected (0.01 sec) mysql&gt; insert into t1 values (1,'one'); Query OK, 1 row affected (0.00 sec) mysql&gt; insert into t1 values (2,'two'); Query OK, 1 row affected (0.00 sec)</code> </pre> <br><pre> <code class="plaintext hljs">$&gt; chameleon sync_tables --tables world_x.t1 --config default --source mysql Sync tables process for source mysql started.</code> </pre> <br><p>  Untuk mengkonfirmasi hasil pengujian, kami meminta tabel dari database PostgreSQL dan menampilkan baris. </p><br><pre> <code class="plaintext hljs">$&gt; psql -p 5433 -U usr_replica -d db_replica -c "select * from pgworld_x.t1"; n1 | n2 ----+------- 1 | one 2 | two</code> </pre> <br><p>  Jika kami melakukan migrasi, perintah pg_chameleon berikut ini akan menjadi akhirnya.  Perintah perlu dieksekusi setelah kami memastikan bahwa baris semua tabel target telah direplikasi, dan hasilnya akan menjadi database PostgreSQL yang dimigrasi dengan rapi tanpa referensi ke sumber database atau skema replikasi (sch_chameleon). </p><br><pre> <code class="plaintext hljs">$&gt; chameleon stop_replica --config default --source mysql $&gt; chameleon detach_replica --config default --source mysql --debug</code> </pre> <br><p>  Jika diinginkan, perintah berikut dapat menghapus konfigurasi asli dan skema replikasi. </p><br><pre> <code class="plaintext hljs">$&gt; chameleon drop_source --config default --source mysql --debug $&gt; chameleon drop_replica_schema --config default --source mysql --debug</code> </pre> <br><h3 id="preimuschestva-pg_chameleon">  Manfaat pg_chameleon </h3><br><p>  Pengaturan dan konfigurasi yang mudah. <br>  Pemecahan masalah yang mudah dan deteksi anomali dengan pesan kesalahan yang jelas. <br>  Anda dapat menambahkan tabel khusus tambahan untuk replikasi setelah inisialisasi tanpa mengubah sisa konfigurasi. <br>  Anda dapat mengonfigurasi beberapa basis data sumber untuk satu target, dan ini sangat nyaman jika Anda menggabungkan data dari satu atau beberapa basis data MySQL menjadi satu basis data PostgreSQL. <br>  Anda tidak dapat meniru tabel yang dipilih. </p><br><h3 id="nedostatki-pg_chameleon">  Kekurangan pg_chameleon </h3><br><p>  Hanya didukung dengan MySQL 5.5 dan di atasnya sebagai sumber dan PostgreSQL 9.5 dan di atas sebagai basis data target. <br>  Setiap tabel harus memiliki kunci primer atau unik, jika tidak, tabel tersebut diinisialisasi dalam proses init_replica, tetapi tidak direplikasi. <br>  Replikasi satu arah - hanya dari MySQL ke PostgreSQL.  Oleh karena itu, hanya cocok untuk skema aktif-pasif. <br>  Hanya database MySQL yang dapat menjadi sumber, dan dukungan untuk database PostgreSQL sebagai sumbernya hanya bersifat eksperimental dan dengan keterbatasan (pelajari lebih lanjut di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ) </p><br><h3 id="itogi-po-pg_chameleon">  Hasil Pg_chameleon </h3><br><p>  Metode replikasi di pg_chameleon sangat bagus untuk memigrasi database dari MySQL ke PostgreSQL.  Sebuah kekurangan yang signifikan adalah bahwa replikasi hanya satu arah, sehingga para pakar basis data tidak mungkin ingin menggunakannya untuk apa pun selain migrasi.  Tetapi masalah replikasi satu arah dapat diselesaikan dengan alat sumber terbuka lain - SymmetricDS. </p><br><p>  Baca lebih lanjut di dokumentasi resmi di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Bantuan di baris perintah dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://pgchameleon.org/documents/usage.html&amp;usg=ALkJrhi7rO5pkbQ9Uooa5qI78f2fVeNWXw#">sini</a> . </p><br><h3 id="obzor-symmetricds">  Gambaran Umum SymmetricDS </h3><br><p>  SymmetricDS adalah alat sumber terbuka yang mereplikasi basis data apa pun ke basis data umum lainnya: Oracle, MongoDB, PostgreSQL, MySQL, SQL Server, MariaDB, DB2, Sybase, Greenplum, Informix, H2, Firebird dan contoh basis data cloud lainnya, misalnya Redshift, dan Azure, dll. Fungsi yang tersedia: sinkronisasi database dan file, replikasi beberapa database terkemuka, sinkronisasi yang difilter, konversi, dan lainnya.  Ini adalah alat Java dan membutuhkan rilis standar JRE atau JDK (versi 8.0 atau lebih tinggi).  Di sini Anda dapat merekam perubahan data pada pemicu dalam basis data sumber dan mengirimkannya ke basis data target terkait dalam bentuk paket. </p><br><h3 id="vozmozhnosti-symmetricds">  Fitur SymmetricDS </h3><br><p>  Alat ini independen terhadap platform, yaitu dua atau lebih basis data yang berbeda dapat bertukar data. <br>  Database relasional disinkronkan dengan menulis perubahan data, dan basis data berbasis sistem file menggunakan sinkronisasi file. <br>  Replikasi dua arah menggunakan metode Push and Pull berdasarkan seperangkat aturan. <br>  Transmisi data dimungkinkan melalui jaringan aman dan jaringan dengan bandwidth rendah. <br>  Pemulihan otomatis ketika node melanjutkan setelah kegagalan dan resolusi konflik otomatis. <br>  API ekstensi yang kompatibel dan kuat cloud. </p><br><h3 id="primer-1">  Contoh </h3><br><p>  SymmetricDS dapat dikonfigurasi dalam salah satu dari dua cara: <br>  Node master (parent) yang secara terpusat mengoordinasi replikasi data antara dua slave (child) node, dan pertukaran data antara child node hanya dilakukan melalui parent. <br>  Node aktif (node ​​1) dapat bertukar data untuk replikasi dengan node aktif lainnya (node ​​2) tanpa perantara. </p><br><p>  Dalam kedua kasus, data dipertukarkan menggunakan Push dan Pull.  Dalam contoh ini, kita akan melihat konfigurasi aktif-aktif.  Jelaskan seluruh arsitektur terlalu lama, jadi lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">panduan ini</a> untuk mempelajari lebih lanjut tentang SymmetricDS. </p><br><p>  Menginstal SymmetricDS sangat sederhana: unduh versi open source dari file zip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari sini</a> dan ekstrak di mana pun Anda inginkan.  Tabel di bawah ini memberikan informasi tentang lokasi instalasi dan versi SymmetricDS dalam contoh ini, serta versi database, versi Linux, alamat IP dan port untuk kedua node. </p><br><div class="scrollable-table"><table><thead><tr><th>  Tuan rumah </th><th>  vm1 </th><th>  vm2 </th></tr></thead><tbody><tr><td>  <strong>Versi OS</strong> </td><td>  CentOS Linux 7.6 x86_64 </td><td>  CentOS Linux 7.6 x86_64 </td></tr><tr><td>  <strong>Versi server DB</strong> </td><td>  MySQL 5.7.26 </td><td>  PostgreSQL 10.5 </td></tr><tr><td>  <strong>Port DB</strong> </td><td>  3306 </td><td>  5832 </td></tr><tr><td>  <strong>Alamat IP</strong> </td><td>  192.168.1.107 </td><td>  192.168.1.112 </td></tr><tr><td>  <strong>Versi SymmetricDS</strong> </td><td>  SymmetricDS 3.9 </td><td>  SymmetricDS 3.9 </td></tr><tr><td>  <strong>SymmetricDS Path Instalasi</strong> </td><td>  /usr/local/symmetric-server-3.9.20 </td><td>  /usr/local/symmetric-server-3.9.20 </td></tr><tr><td>  <strong>SymmetricDS Node Name</strong> </td><td>  corp-000 </td><td>  store-001 </td></tr></tbody></table></div><br><p>  Di sini kita menginstal SymmetricDS di /usr/local/symmetric-server-3.9.20, dan berbagai subdirektori dan file akan disimpan di sana.  Kami tertarik pada sampel direktori bersarang dan mesin.  Direktori sampel berisi sampel file konfigurasi dengan properti host, serta sampel skrip SQL untuk memulai demonstrasi dengan cepat. </p><br><p>  Dalam direktori sampel, kita melihat tiga file konfigurasi dengan properti simpul - namanya menunjukkan sifat simpul dalam skema tertentu. </p><br><pre> <code class="plaintext hljs">corp-000.properties store-001.properties store-002.properties</code> </pre> <br><p>  SymmetricDS memiliki semua file konfigurasi yang diperlukan untuk skema dasar 3-simpul (opsi 1), dan file yang sama dapat digunakan untuk skema 2-simpul (opsi 2).  Salin file konfigurasi yang diinginkan dari direktori sampel ke mesin pada host vm1.  Ternyata seperti ini: </p><br><pre> <code class="plaintext hljs">$&gt; cat engines/corp-000.properties engine.name=corp-000 db.driver=com.mysql.jdbc.Driver db.url=jdbc:mysql://192.168.1.107:3306/replica_db?autoReconnect=true&amp;useSSL=false db.user=root db.password=admin123 registration.url= sync.url=http://192.168.1.107:31415/sync/corp-000 group.id=corp external.id=000</code> </pre> <br><p>  Node ini dalam konfigurasi SymmetricDS disebut corp-000, dan koneksi database diproses oleh driver jsb mysql, yang menggunakan string koneksi yang ditentukan di atas dan kredensial login.  Kami terhubung ke basis data replica_db, dan tabel akan dibuat selama pembuatan skema.  sync.url menunjukkan situs komunikasi dengan node untuk sinkronisasi. </p><br><p>  Node 2 pada host vm2 dikonfigurasi sebagai store-001, dan sisanya ditentukan dalam file node.properties di bawah ini.  Node store-001 menjalankan database PostgreSQL, dan pgdb_replica adalah database untuk replikasi.  registrasi.url memungkinkan host vm2 untuk menghubungi host vm1 dan mendapatkan detail konfigurasi darinya. </p><br><pre> <code class="plaintext hljs">$&gt; cat engines/store-001.properties engine.name=store-001 db.driver=org.postgresql.Driver db.url=jdbc:postgresql://192.168.1.112:5832/pgdb_replica db.user=postgres db.password=admin123 registration.url=http://192.168.1.107:31415/sync/corp-000 group.id=store external.id=001</code> </pre> <br><p>  Contoh pre-built SymmetricDS berisi opsi untuk mengatur replikasi dua arah antara dua server database (dua node).  Langkah-langkah di bawah ini dilakukan pada host vm1 (corp-000), yang akan membuat skema contoh dengan 4 tabel.  Kemudian menjalankan create-sym-tables dengan perintah symadmin membuat tabel direktori di mana aturan dan arah replikasi antar node akan disimpan.  Akhirnya, data sampel dimuat ke dalam tabel. </p><br><pre> <code class="plaintext hljs">vm1$&gt; cd /usr/local/symmetric-server-3.9.20/bin vm1$&gt; ./dbimport --engine corp-000 --format XML create_sample.xml vm1$&gt; ./symadmin --engine corp-000 create-sym-tables vm1$&gt; ./dbimport --engine corp-000 insert_sample.sql</code> </pre> <br><p>  Dalam contoh, tabel item dan item_selling_price secara otomatis dikonfigurasi untuk mereplikasi dari corp-000 ke store-001, dan tabel penjualan (sale_transaction dan sale_return_line_item) secara otomatis dikonfigurasi untuk mereplikasi dari store-001 ke corp-000.  Sekarang buat skema di database PostgreSQL pada host vm2 (store-001) untuk mempersiapkannya untuk menerima data dari corp-000. </p><br><pre> <code class="plaintext hljs">vm2$&gt; cd /usr/local/symmetric-server-3.9.20/bin vm2$&gt; ./dbimport --engine store-001 --format XML create_sample.xml</code> </pre> <br><p>  Pastikan untuk memeriksa bahwa database MySQL pada vm1 memiliki tabel sampel dan tabel direktori SymmetricDS.  Perhatikan bahwa tabel sistem SymmetricDS (dengan awalan sym_) sekarang hanya tersedia pada host corp-000, karena di sana kami menjalankan perintah create-sym-tables dan akan mengelola replikasi.  Dan dalam database pada node store-001 hanya akan ada 4 contoh tabel tanpa data. </p><br><p>  Itu saja.  Lingkungan siap untuk menjalankan proses server sym pada kedua node, seperti yang ditunjukkan di bawah ini. </p><br><pre> <code class="plaintext hljs">vm1$&gt; cd /usr/local/symmetric-server-3.9.20/bin vm1$&gt; sym 2&gt;&amp;1 &amp;</code> </pre> <br><p>  Entri log dikirim ke file log latar belakang (symmetric.log) di folder log di direktori tempat SymmetricDS diinstal, serta ke output standar.  Server sym sekarang dapat dimulai pada node store-001. </p><br><pre> <code class="plaintext hljs">vm2$&gt; cd /usr/local/symmetric-server-3.9.20/bin vm2$&gt; sym 2&gt;&amp;1 &amp;</code> </pre> <br><p>  Jika Anda menjalankan proses server sym pada host vm2, itu akan membuat tabel katalog SymmetricDS di database PostgreSQL juga.  Jika Anda menjalankan proses server sym pada kedua node, mereka berkoordinasi satu sama lain untuk mereplikasi data dari corp-000 ke store-001.  Jika setelah beberapa detik kami meminta semua 4 tabel di kedua sisi, kami akan melihat bahwa replikasi berhasil.  Atau Anda dapat mengirim bootstrap ke store-001 dari corp-000 dengan perintah berikut. </p><br><pre> <code class="plaintext hljs">vm1$&gt; ./symadmin --engine corp-000 reload-node 001</code> </pre> <br><p>  Pada titik ini, catatan baru dimasukkan ke tabel item dalam database MySQL pada host corp-000 (host: vm1), dan Anda dapat memverifikasi replikasinya ke database PostgreSQL di host store-001 (host: vm2).  Kami melihat operasi Tarik untuk memindahkan data dari corp-000 ke store-001. </p><br><pre> <code class="plaintext hljs">mysql&gt; insert into item values ('22000002','Jelly Bean'); Query OK, 1 row affected (0.00 sec)</code> </pre> <br><pre> <code class="plaintext hljs">vm2$&gt; psql -p 5832 -U postgres pgdb_replica -c "select * from item" item_id | name ----------+----------- 11000001 | Yummy Gum 22000002 | Jelly Bean (2 rows)</code> </pre> <br><p>  Untuk melakukan operasi Push untuk memindahkan data dari store-001 ke corp-000, masukkan catatan di tabel sale_transaksi dan verifikasi bahwa replikasi sudah selesai. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hasil.</a> </p><br><p>  Kami melihat setup sukses replikasi dua arah tabel sampel antara database MySQL dan PostgreSQL.  Untuk mengkonfigurasi replikasi untuk tabel pengguna baru, lakukan hal berikut:  Kami membuat tabel t1 sebagai contoh dan mengonfigurasi aturan untuk replikasinya sebagai berikut.  Jadi kami hanya mengkonfigurasi replikasi dari corp-000 ke store-001. </p><br><pre> <code class="plaintext hljs">mysql&gt; create table t1 (no integer); Query OK, 0 rows affected (0.01 sec)</code> </pre> <br><pre> <code class="plaintext hljs">mysql&gt; insert into sym_channel (channel_id,create_time,last_update_time) values ('t1',current_timestamp,current_timestamp); Query OK, 1 row affected (0.01 sec)</code> </pre> <br><pre> <code class="plaintext hljs">mysql&gt; insert into sym_trigger (trigger_id, source_table_name,channel_id, last_update_time, create_time) values ('t1', 't1', 't1', current_timestamp, current_timestamp); Query OK, 1 row affected (0.01 sec)</code> </pre> <br><pre> <code class="plaintext hljs">mysql&gt; insert into sym_trigger_router (trigger_id, router_id, Initial_load_order, create_time,last_update_time) values ('t1', 'corp-2-store-1', 1, current_timestamp,current_timestamp); Query OK, 1 row affected (0.01 sec)</code> </pre> <br><p>  Konfigurasi kemudian diberitahu tentang perubahan skema, yaitu, penambahan tabel baru, menggunakan perintah symadmin dengan argumen pemicu sinkronisasi, yang menciptakan pemicu agar sesuai dengan definisi tabel.  Skema kirim dijalankan untuk mengirim perubahan skema ke store-001, dan replikasi tabel t1 dikonfigurasi. </p><br><pre> <code class="plaintext hljs">vm1$&gt; ./symadmin -e corp-000 --node=001 sync-triggers vm1$&gt; ./symadmin send-schema -e corp-000 --node=001 t1</code> </pre> <br><h3 id="preimuschestva-symmetricds">  Manfaat dari SymmetricDS </h3><br><p>  Instalasi dan konfigurasi yang mudah, termasuk satu set file yang siap pakai dengan parameter untuk membuat sirkuit dengan tiga atau dua node. <br>  Basis data lintas platform dan independensi platform, termasuk server, laptop, dan perangkat seluler. <br>  Gandakan basis data apa pun ke basis data lain mana pun secara lokal, dalam WAN atau di cloud. <br>  Kemampuan untuk bekerja secara optimal dengan beberapa database atau beberapa ribu untuk replikasi mudah. <br>  Versi berbayar dengan antarmuka grafis dan dukungan luar biasa. </p><br><h3 id="nedostatki-symmetricds">  SymmetricDS Kerugian </h3><br><p>  Hal ini diperlukan untuk secara manual menentukan aturan dan arah replikasi melalui pernyataan SQL pada baris perintah untuk memuat tabel direktori, yang tidak nyaman. <br>  Menyiapkan banyak tabel untuk replikasi bisa membosankan jika Anda tidak menggunakan skrip untuk membuat pernyataan SQL yang menentukan aturan dan arah replikasi. <br>  Terlalu banyak informasi dimasukkan ke dalam log, dan kadang-kadang Anda perlu membersihkan file log sehingga tidak memakan terlalu banyak ruang. </p><br><h3 id="itogi-po-symmetricds">  Ringkasan SymmetricDS </h3><br><p>  SymmetricDS memungkinkan Anda untuk mengkonfigurasi replikasi dua arah antara dua, tiga, atau bahkan beberapa ribu node untuk mereplikasi dan menyinkronkan file.  Ini adalah alat unik yang secara mandiri melakukan banyak tugas, misalnya, pemulihan data otomatis setelah downtime lama pada sebuah node, pertukaran data yang aman dan efisien antar node melalui HTTPS, manajemen konflik otomatis berdasarkan seperangkat aturan, dll. SymmetricDS mereplikasi antara database apa pun, oleh karena itu, dapat digunakan untuk berbagai skenario, termasuk migrasi, peningkatan, distribusi, penyaringan, dan konversi data lintas platform. </p><br><p>  Sampel didasarkan pada Panduan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mulai</a> Cepat SymmetricDS resmi.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan pengguna</a> merinci berbagai konsep yang berkaitan dengan mengonfigurasi replikasi menggunakan SymmetricDS. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467313/">https://habr.com/ru/post/id467313/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467295/index.html">View Binding yang sudah lama dinanti di Android</a></li>
<li><a href="../id467299/index.html">Konsep: menyederhanakan implementasi kelas STD Utility</a></li>
<li><a href="../id467301/index.html">Bagaimana AI bekerja di Hitman (2016)</a></li>
<li><a href="../id467303/index.html">Kisah programmer PSB termuda: hackathon menjadi pintu ke bank</a></li>
<li><a href="../id467305/index.html">Ketika kota pintar: pengalaman kota-kota besar</a></li>
<li><a href="../id467317/index.html">Bagaimana SoftBank menelan dunia</a></li>
<li><a href="../id467323/index.html">Gambaran Umum Fitur Qt Creator 4.10 dan QBS 1.14 Microcontroller Programming</a></li>
<li><a href="../id467327/index.html">Bagaimana saya menjadi seorang programmer pada usia 35</a></li>
<li><a href="../id467329/index.html">Produk terbaik mulai dari masalah nyata: Interkom tentang Pekerjaan yang akan Dilakukan. Bagian 1</a></li>
<li><a href="../id467331/index.html">Menjual + toko online cantik di WordPress seharga $ 269 "dari awal" - pengalaman kami</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>