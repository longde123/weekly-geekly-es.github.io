<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤟🏽 🙏 🏌️ Was hat uns der PDP-11 beigebracht? 🐟 👱 ✌🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="CG Bell, WD Strecker, „Computer, was haben wir aus dem PDP-11 gelernt?“, Das 3. jährliche Symposium über Konferenzbeiträge zur Computerarchitektur, pp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Was hat uns der PDP-11 beigebracht?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435292/"><img src="https://habrastorage.org/webt/bt/ex/g2/btexg2j_gmcvjxnfpjn4x3jbxs4.png"><br>  <i>CG Bell, WD Strecker, „Computer, was haben wir aus dem PDP-11 gelernt?“, Das 3. jährliche Symposium über Konferenzbeiträge zur Computerarchitektur, pp.</i>  <i>l-14, 1976.</i> <br><br>  Dieser Artikel, den ich heute ausgewählt habe, ist eine Retrospektive des Computerdesigns.  Dies ist einer von mehreren Artikeln von Gordon Bell mit verschiedenen Co-Autoren, die die Entwicklung, das Wachstum und den plötzlichen Ersatz der Kultproduktlinie PDP-11 Minicomputer des Unternehmens beschreiben. <br><a name="habracut"></a><br><ul><li>  CG Bell, R. Cady, H. McFarland, B. Delagi, J. O'Laughlin, R. Noonan und W. Wulf, „Eine neue Architektur für Minicomputer - Der DEC PDP-11“, Proceedings of the Sprint Joint Computerkonferenz, pp.  657-675, AFIPS Press, 1970. </li><li>  CG Bell, WD Strecker, „Computer, was haben wir aus dem PDP-11 gelernt?“, Das 3. jährliche Symposium über Konferenzbeiträge zur Computerarchitektur, pp.  l-14, 1976. </li><li>  WD Strecker, "VAX-11/780: Eine virtuelle Adresserweiterung für die DEC PDP-11-Familie", Proceedings of the National Computer Conference, pp.  967-980, AFIPS Press, 1978. </li><li>  CG Bell, WD Strecker, „Retrospektive: Was haben wir aus dem PDP-11 gelernt - was haben wir aus VAX und Alpha gelernt?“, Proceedings of the 25th Annual International Symposium on Computer Architecture, pp.  6-10, 1998. </li></ul><br>  In diesem Jahr feiern wir den 60. Jahrestag der Gründung des Unternehmens, das den PDP-11 hergestellt hat.  40 Jahre sind vergangen, seit dieser Artikel geschrieben wurde, und ich dachte, es wäre interessant, Bell's Artikel aus unserer modernen Sicht zu betrachten. <br><br><img src="https://habrastorage.org/webt/ef/p_/vy/efp_vyyz1an5rfis3axmot-vf5i.jpeg"><br><br><h3>  Was war die Digital Equipment Corporation? </h3><br>  Um uns vorzustellen, wann der Artikel geschrieben wurde, müssen wir zunächst ein wenig über das Unternehmen sprechen, das die PDP-11, Digital Equipment Corporation aus Maynard, Massachusetts, auf den Markt gebracht hat.  Besser bekannt als DEC. <br><br><img src="https://habrastorage.org/webt/vw/er/6w/vwer6wfpzv4-ppq7-xfxqjcnoqc.jpeg"><br><br>  DEC wurde 1957 von Ken Olsen und Harlan Anderson gegründet.  Olsen und Anderson arbeiteten im Lincoln Laboratory des Massachusetts Institute of Technology zusammen, wo sie bemerkten, dass die Schüler stundenlang Schlange standen, um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TX-0</a> , einen experimentellen interaktiven Computer, der von Wes Clark entwickelt wurde, zu verwenden <br><br><div class="spoiler">  <b class="spoiler_title">1</b> <div class="spoiler_text">  Clark entwickelte TX-0 in TX-2 weiter und wechselte später als Leiter von LINC zu DEC <br></div></div><br><img src="https://habrastorage.org/webt/u-/p_/lm/u-p_lmwp4ly-4rjqdbq6bvjayuc.jpeg"><br><br>  Dies ist TX-0. <br><br><img src="https://habrastorage.org/webt/so/de/vr/sodevrwmacb_y7v65biysm1xxom.jpeg"><br><br>  Vergleichen wir es mit etwas wie dem IBM 704, einem Computer der Zeit, den die Schüler meistens ignorierten. <br><br><div class="spoiler">  <b class="spoiler_title">2</b> <div class="spoiler_text">  Nach der Präsentation schlug jemand vor, dass die Abneigung der Schüler gegenüber IBM auf einem Mangel an Budget für die Computerzeit dieses Systems beruhen könnte. <br></div></div><br>  Olsen und Anderson stellten fest, dass der Wunsch, einen interaktiven Computer zu verwenden, so groß war, dass es einen Markt für „kleine“ Computer gab, die für diese Rolle entwickelt wurden. <br><br><img src="https://habrastorage.org/webt/nc/eo/ab/nceoabpycn2zpif7o01ykcgjj5k.jpeg"><br><br>  DEC führte zunächst den PDP-1 ein, eine effiziente kommerzielle Version des TX-0. <br><br>  <i><b>Änderungsantrag</b> : Michael Cheponis, Leiter des PDP-1-Wiederherstellungsprojekts, hat mir freundlicherweise Folgendes geschrieben:</i> <i><br><br></i>  <i>Wirbelwind und PDP-1 haben einen 5-Bit-Operationscode, TX-0 begann mit einem 2- oder 3-Bit-Operationscode, aber dieser Wert nahm mit zunehmender Speichergröße von TX-2 zu.</i>  <i>Ein Vergleich der Reihenfolge der PDP-1- und Whirlwind-Codes zeigt, dass PDP-1 eine billigere und etwas verbesserte Version der Whirlwind-Architektur ist.</i> <i><br><br></i> <ul><li>  Verbesserung: Indirekte Adressierung hinzugefügt. </li><li>  Kostenreduzierung: Das "Live-Register" wird entfernt und die Unterprogrammaufrufanweisung wird hinzugefügt, und der Verschiebungszähler wird entfernt, da die Anweisungen der ganzzahligen Multiplikation und Division durch die Anweisungen des Multiplikations- und Divisionsschritts ersetzt werden, die eine Verschiebung um eine Ziffer bewirken.  Der größte Preisverfall des PDP-1 im Vergleich zu Whirlwind war auf eine Änderung des Designs der Logik und des Designs zurückzuführen. </li></ul><br>  Der Kontrast zwischen dem PDP-1 und dem IBM 704 war groß, aber einige Jahre zuvor waren bereits kleine und langsame interaktive Computer wie der Librascope LGP-30 und der Bendix G-15 aufgetreten, die in ähnlichen Mengen verkauft wurden. <br><br>  Es sollte auch beachtet werden, dass der Name PDP eine Abkürzung für "Programmed Data Processor" ist, da Computer zu dieser Zeit große, komplexe und teure Maschinen bedeuteten und Risikokapitalgeber DEC möglicherweise nicht unterstützen, wenn sie "Computer" produzieren. <br><br><div class="spoiler">  <b class="spoiler_title">3</b> <div class="spoiler_text">  Eines der ersten Computerspiele, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spacewar</a> " von Steve Russell, wurde für den PDP-1 geschrieben <br></div></div><br>  Nach dem Erfolg des PDP-1 bot DEC mehrere Computerfamilien an, von denen viele zumindest teilweise von Gordon Bell entworfen wurden. <br><br><h3>  Einführung </h3><br>  <i>Ein Computer wird nicht vollständig von der Architektur bestimmt.</i>  <i>Es spiegelt die technologischen, wirtschaftlichen und humanitären Aspekte der Zeit und des Ortes wider, an dem es entworfen und gebaut wurde.</i>  <i>Ein fertiger Computer ist ein Produkt seiner Zeit.</i> <br><br>  Bell teilt uns von Anfang an mit, dass Sie für den Erfolg eines Computerprojekts keinen abstrakten besten Computer der Welt erstellen müssen, sondern den richtigen Computer unter Berücksichtigung des Kontexts. <br><br>  <i>In diesem Kapitel werden wir uns mit dem PDP-11 befassen: den Zielen der Erstellung, der Architektur, verschiedenen Implementierungen und den Personen, die es erstellt haben.</i>  <i>Wir werden das Design untersuchen, beginnend mit den Spezifikationen der Architektur, und untersuchen, wie sie durch Technologie, Organisation der Entwicklung, Vertrieb, Anwendung, Organisation der Produktion und die Art der Endbenutzer beeinflusst wurden.</i> <br><br>  Zu dieser Zeit, 1976, war Bell fast vier Jahre lang Leiter der DEC-Entwicklung.  Es ist klar, dass er den Erfolg des PDP-11 in einem breiteren Marktkontext betrachtet, dessen Bedürfnisse sie befriedigen sollten und der die Entwicklung der gesamten PDP-11-Familie weiter beeinflusste. <br><br>  Im Geiste von Bells Worten konzentriert sich diese Präsentation auf zwei Aspekte des Artikels: Technologie und Menschen. <br><br><h3>  Grundlagen: die Gedanken hinter Design </h3><br>  Bell beginnt mit einer solchen Beobachtung. Die <i>Computertechnik orientiert sich naturgemäß am Ziel, das Endprodukt zu schaffen.</i>  <i>Daher ist es schwierig, darin langfristige Pläne zu erstellen.</i> <br><br>  Dies sind agile Prinzipien.  Zu dieser Zeit.  25 Jahre vor Snowbird und Schreiben des Manifests agil.  Als es geschrieben wurde, war DEC kein Startup mehr, das um seine Existenz kämpfte. Es war ein ausgereiftes Unternehmen mit mehreren erfolgreichen Produktlinien auf dem Markt, und Bell sagte, dass die Notwendigkeit, ein Produkt mit minimalem Bedarf (Produkt mit minimaler Lebensfähigkeit) herauszubringen, wichtiger ist als alle anderen langfristigen Produkte Pläne. <br><br>  Wie IBM / 360 wurde der PDP-11 nicht als einzelnes Computermodell entwickelt, sondern als eine Reihe von Modellen, während die für den kleinen PDP-11 geschriebene Software mit dem großen kompatibel sein wird. <br><br>  <i>"Der Begriff" Architektur "wird hier verwendet, um die Attribute des Systems zu beschreiben, wie der Programmierer es sieht, d.h.</i>  <i>"eine konzeptionelle Struktur und ein funktionales Verhalten, und nicht die Organisation von Datenflüssen und -verwaltung, das logische Design und die physische Implementierung zu beschreiben."</i>  <i>- GM Amdahl GA Blaauw und FP Brooks Jr.</i>  <i>Architektur des IBM System / 360, 1964</i> <br><br>  Aufgrund der Offenheit von PDP-11 ist PDP-11 alles, was Anweisungen gemäß den Spezifikationen des Prozessors interpretiert, und DEC, sobald sich der PDP-11-Markt erwärmt hat, begann mit der Erstellung von Implementierungen dieser Architektur, sie hatten mehrere Gruppen, eine von denen sie schnelle und teure Computer bauten, während andere langsamere für einen niedrigeren Preis entwarfen. <br><br>  <i>Trotz seines evolutionären Planungsstils war der PDP-11 auf dem Markt erfolgreich: In den sechs Jahren, in denen er auf dem Markt war (1970-1975), wurden über 20.000 Einheiten verkauft.</i>  <i>Design ist in diesem Fall nicht so wichtig: Eine große und aggressive Marketingorganisation, die mit Software ausgestattet ist, um Architekturfehler und -auslassungen zu korrigieren, kann fast jedes Design speichern.</i> <br><br>  Hier stellt Bell in seinem Artikel die Frage: Hatte der PDP-11 ein gutes Design oder hat er sich nur durch hyperaktives Marketing einen Vorteil verschafft?  Um seine eigene Frage zu beantworten, betrachtet Bell das Produkt anhand der Designkriterien, die er und seine Co-Autoren sechs Jahre zuvor identifiziert haben. <br><br><h3>  Adressraum </h3><br>  Die erste Schwäche von Mikrocomputern war der begrenzte Adressraum.  Der größte und häufigste Fehler bestand darin, einen Computer zu entwerfen, der nicht über genügend Adressraum zum Adressieren und Verwalten des Speichers verfügt. <br><br>  Die Minicomputer dieser Zeit hatten einen 12-Bit-Adressraum, in dem nur 4096 Adressen adressiert werden konnten, von denen jede ein 12-Bit-Wort speicherte. <br><br>  Es ist erwähnenswert, dass das Wort "Minicomputer", das später die physische Größe erhielt, ursprünglich aus dem Ausdruck "Minimalcomputer" gebildet wurde.  Das kanonische Beispiel war PDP-8, das vorherige DEC-Modell, das nur acht Anweisungen hatte. <br><br><img src="https://habrastorage.org/webt/vi/me/co/vimecoj2x5aezvsojy6vza9erdi.jpeg"><br><br>  Der Grund für den winzigen Adressraum war der Preis.  Der Speicher war in den 60er und frühen 70er Jahren extrem teuer, als jedes Bit aus einem winzigen Magnetkern bestand, der in das Gitter der Steuerdrähte eingewebt war. <br><br>  Die Kerne waren in einer Tafel angeordnet, in diesem Fall jeweils 4096 Bits, die gestapelt wurden, um ein Wort zu erhalten, so dass 4096 Speicherwörter aus 16 Millionen Ringen bestanden ( <i>hier offensichtlich ein Fehler im Originaltext, 4096 Wörter * 16 Bits = 65536 Ringe ca. übersetzt</i> ), von denen jeder zumindest teilweise von Hand zusammengebaut wurde.  Jetzt ist klar, warum Speicher so teuer war. <br><br><img src="https://habrastorage.org/webt/cm/fg/jp/cmfgjpj8yor6yj6qy6r6efh8og4.png"><br><br>  Bell und andere PDP-11-Entwickler wussten, dass die Kernpreise weiter sinken würden und dass Halbleiterspeicher, obwohl sie zu diesem Zeitpunkt nicht so kostengünstig waren, basierend auf einem gespeicherten Byte weiterhin billiger werden würden.  Daher wird die Menge an Speicher, die sich der Käufer leisten kann, mit der Zeit zunehmen, da Benutzer dazu neigen, "Systeme zum gleichen Preis in Dollar" zu kaufen.  Aber trotzdem <br><br>  <i>PDP-11 folgte dieser schlechten Tradition des Sparens von Adressbits, wurde jedoch durch das Prinzip gerettet, dass ein gutes Design mindestens eine wesentliche Änderung überstehen kann.</i> <br><br>  Selbst unter Berücksichtigung der Vorhersagen der Entwickler stellte Bell fest, dass seit der Einführung der PDP-11-Architektur weniger als zwei Jahre vergangen sind und ein Speicherverwaltungsmodul in die Architektur aufgenommen werden musste, um den Zugriff auf einen größeren 18-Bit-Adressraum auf Kosten der zunehmenden Softwarekomplexität zu ermöglichen .  Einige Jahre später wurden weitere 4 Bits hinzugefügt. <br><br>  Obwohl Bell sich vorwirft, voreilig zu sein, wird die Tradition, unzureichenden Adressraum zu schaffen, fairerweise bis heute fortgesetzt.  Erinnern Sie sich an die 640K-Einschränkung unter DOS?  Erinnerst du dich an die Kämpfe mit himem.sys?  Konfrontiert mit einer Situation, in der ein 32-Bit-Programm mehr als 2 GB für Daten benötigt? <br><br>  Also ist niemand perfekt. <br><br><h3>  Nicht genug Register </h3><br>  <i>Die zweite Schwäche der Minicomputer war die Tendenz zu einer unzureichenden Anzahl von Registern.</i>  <i>Dies wurde in PDP-11 behoben, das acht 16-Bit-Register hatte.</i>  <i>Später wurden sechs 32-Bit-Register für die Gleitkomma-Arithmetik hinzugefügt.</i>  <i>Mehr Register könnten die Umschaltzeit für den Aufgabenkontext verlängern.</i> <br><br>  Selbst für die damaligen Mainframes war es nicht ungewöhnlich, nur ein Register bereitzustellen - die Batterie.  Wenn zusätzliche Register bereitgestellt wurden, wurden diese nur als Indexregister und nicht als Allzweckregister verwendet. <br><br>  Interessant ist auch die Bemerkung von Bell, dass zusätzliche Register für den Benutzer unpraktisch sein können.  In den frühen 1970er Jahren war es am häufigsten, Maschinen direkt im Assembler zu programmieren. <br><br>  Es besteht eine starke Korrelation zwischen der Anzahl der Register in der Architektur, der Anzahl der Adressbits und der Größe des Befehls.  All diese Faktoren führen zu unzureichendem Speicher, und es war sinnvoll, das Befehlssystem sorgfältig durchzudenken. <br><br>  In Von Neumann-Maschinen (die praktisch alle Computer der 60er Jahre waren) teilen sich Programm und Daten den gleichen, begrenzten Adressraum, und ein ineffektives Programm verschwendet nicht nur Computerzeit, sondern auch Speicher.  Ein langsames Programm kann toleriert werden, aber wenn das Programm nicht in den Speicher passt, war es fatal, dh die Methode zum Codieren von Anweisungen sollte so effizient wie möglich sein. <br><br>  Schauen wir uns einen sehr häufigen Fall an, bei dem von einem Speicherort zu einem anderen gewechselt wird.  Wie viele Bits werden benötigt, um diesen Vorgang zu beschreiben?  Hier ist eine mögliche Implementierung: <br><br><pre><code class="plaintext hljs">MOV addr addr</code> </pre> <br>  Sie benötigen 16 Bit für die Quelladresse, weitere 16 für die Zieladresse und eine bestimmte Anzahl von Bits, um den MOV-Befehl selbst zu codieren.  Es gebe insgesamt 40 Bits, dies ist kein Vielfaches von 16, was eine komplexe 2,5-Bit-Codierung von Befehlen bedeutet.  Was ist jedoch, wenn wir die Adresse in das Register laden? <br><br><pre> <code class="plaintext hljs">MOV (R0), (R1)</code> </pre> <br>  In diesem Fall müssen wir nur die Register beschreiben, PDP-11 hat 8 Register und nur 3 Bits reichen aus, um das Register zu beschreiben, plus einige Bits, um den Operator zu beschreiben.  Ein solcher Befehl kann leicht in ein 16-Bit-Wort passen und erfordert keine komplexe Codierung von Befehlen mit variabler Länge. <br><br><img src="https://habrastorage.org/webt/ud/dt/01/uddt01pifmvr1f_nkkop39uzxr0.png"><br><br>  In der Realität verwendet der PDP-11 6 Bits pro Register und 4 Bits pro Operation, wenn der Befehl zwei Operanden hat. <br><br><h3>  Hardware-Stack </h3><br>  <i>Die dritte Schwäche von Minicomputern war der Mangel an Hardware-Unterstützung für den Stack.</i>  <i>PDP-11 implementierte einen automatischen Inkrementierungs- und automatischen Dekrementierungsmechanismus für die Adresse.</i>  <i>Diese Lösung ist einzigartig für den PDP-11 und hat sich als äußerst nützlich erwiesen.</i>  <i>(Und diese Lösung wurde von Entwicklern anderer Systeme kopiert.)</i> <br><br>  Heutzutage ist es schwierig, sich Hardware vorzustellen, die keinen Stapel hat, aber tatsächlich ist der Stapel nicht sehr wichtig, wenn Sie keine Rekursion verwenden. <br><br>  Das Design von PDP-11 stammt aus dem Jahr 1969, und wenn wir uns die damaligen Programmiersprachen FORTRAN und COBOL ansehen, haben sie keinen rekursiven Funktionsaufruf unterstützt.  Die Sequenz des Funktionsaufrufs umfasste das Speichern der Rücksprungadresse in einem leeren Wort zu Beginn der Prozedur, was eine Rekursion unmöglich machte. <br><br><img src="https://habrastorage.org/webt/9t/a0/jg/9ta0jg3ud742lxb5ayw93pfv-ke.png"><br><br>  PDP-11 definiert den Stapelzeiger, wie wir ihn heute verstehen, als ein Register, das durch PUSH- und POP-Operationen gesteuert wird, aber PDP-11 ging noch weiter und erlaubte jedem Register, als Stapelzeiger zu arbeiten, indem den Operandenregistern ein Modifikator für die automatische Inkrementierung / Dekrementierung hinzugefügt wurde. <br><br>  Zum Beispiel eine Anweisung: <br><br><pre> <code class="plaintext hljs">MOV R4, -(R6)</code> </pre> <br>  verringert den Wert in R6 um zwei und speichert dann den Wert von R4 an der in R6 gespeicherten Adresse.  Daher platzieren wir in Assembler PDP-11 den Wert auf dem Stapel.  Wenn einer von Ihnen für ARM programmiert hat, sollte Ihnen dies bekannt sein. <br><br>  Dies bedeutet, dass keine dedizierten PUSH- oder POP-Befehle erforderlich sind. Dies spart Befehlsraum, ermöglicht die Verwendung eines beliebigen Registers als Stapelzeiger, obwohl der Stapelzeiger traditionell R6 ist und vom Gerät beim Ausführen eines Unterprogrammaufrufs verwendet wird. <br><br><h3>  Verzögerung unterbrechen </h3><br>  <i>Die vierte Schwäche der Minicomputer dieser Zeit war die begrenzte Unterstützung für Interrupts und langsame Kontextumschaltung, und dieses Problem wurde durch die Verwendung des UNIBUS-Vektorinterrupt-Controllers mit direkter Verbindung von Geräteinterrupts gelöst.</i> <br><br>  Zu diesem Zeitpunkt im Leben von DEC verfügten fast alle Produkte über die PDP-10-Architektur, den DEC-Mainframe, der für interaktive Anwendungen, Labore und Prozesssteuerung entwickelt wurde.  Die Reaktion auf Interrupts, die Verzögerung zwischen der Aktivierung des Interrupt-Signals und dem Beginn der Interrupt-Verarbeitung, ist der Schlüssel zur Erzielung einer hohen Echtzeitleistung. <br><br>  In PDP-11 gibt das Gerät, das den Interrupt ausgelöst hat, die Adresse des Interrupt-Handlers an.  Bell schreibt ehrlich darüber: <br><br>  <i>Der Hauptmechanismus ist sehr schnell, er erfordert nur vier Zyklen des Zugriffs auf den Speicher von dem Moment an, als der Interrupt angefordert wurde, bis der erste Befehl des Interrupt-Handlers ausgeführt wurde.</i> <br><br><h3>  Charakterunterstützung </h3><br>  <i>Die fünfte Schwäche der meisten Minicomputer war die schlechte String-Unterstützung, die in PDP-11 durch die Fähigkeit behoben wurde, Bytes direkt zu adressieren.</i> <br><br>  Die Bedeutung der Unterstützung von Streichern und Charakteren begann in den 1960er Jahren zu wachsen, als Lösungen für Wissenschaft und Wirtschaft auftauchten.  Die zu dieser Zeit dominierende Codierungsmethode war der 6-Bit-Zeichensatz, der ausreichend Platz für Großbuchstaben, Zahlen von 0 bis 9, ein Leerzeichen und mehrere Satzzeichen bot und für den Druck von Abschlüssen ausreichte. <br><br><img src="https://habrastorage.org/webt/4j/7a/2i/4j7a2igan6lbjg_1rs05pxmoeus.jpeg"><br><br>  Da der Speicher sehr teuer war, war das Platzieren eines Zeichens in einem 12-Bit- oder 18-Bit-Wort einfach nicht akzeptabel, und die Zeichen wurden in Wörter gepackt. <br><br>  Dies verbessert die Speichereffizienz, ist jedoch schwierig für Vorgänge wie Verschieben, Vergleichen und Kombinieren, bei denen berücksichtigt werden muss, dass sich das Zeichen im unteren oder oberen Teil des Wortes befinden kann, was die Menge des vom Programm belegten teuren Speichers erhöht. <br><br>  Das Problem wurde in PDP-11 gelöst. Die Maschine konnte sowohl mit 16-Bit-Wörtern als auch mit 8-Bit-Bytes arbeiten, was immer beliebter wurde.  Die Erweiterung der Zeichenlänge um zwei Bit vereinfachte die Zeichenfolgenoperationen und erleichterte die Anpassung an den immer beliebter werdenden 7-Bit-ASCII-Standard, der zu dieser Zeit von DEC unterstützt wurde.  Bell beendet diesen Absatz folgendermaßen: <br><br>  <i>Trotz der Tatsache, dass die Anweisungen zum Verarbeiten von Zeichenfolgen in der Ausrüstung fehlten, konnten gewöhnliche Zeichenfolgenoperationen (Verschieben, Vergleichen, Verketten) als sehr kurzer Zyklus programmiert werden.</i> <br><br>  Und das ist tatsächlich so.  Sie können eine Kopierprozedur in nur zwei Anweisungen schreiben, vorausgesetzt, die Quell- und Zieladresse befinden sich in Registern. <br><br><pre> <code class="plaintext hljs">loop: MOVB (src)+, (dst)+ BNE loop</code> </pre> <br>  Dieser Code nutzt die Tatsache aus, dass der MOV-Befehl die Flags setzt.  Der Zyklus wird fortgesetzt, bis der Wert in der Quelladresse Null wird, und an diesem Punkt fährt die Steuerung mit dem nächsten Befehl fort.  Deshalb enden die Zeilen C mit Null. <br><br><h3>  ROM </h3><br>  <i>Die sechste Schwachstelle von Minicomputern war die Unfähigkeit, ROMs zu verwenden, und PDP-11 hatte diesen Nachteil nicht.</i>  <i>Der größte Teil des für PDP-11 geschriebenen Codes war "sauber" und ermöglichte die erneute Eingabe ohne besondere Programmieranstrengungen, was die direkte Verwendung des ROM ermöglichte.</i> <br><br>  In Prozesssteuerungsanwendungen, in denen die Programme relativ fest sind, müssen sie das Programm jedes Mal von Magnetband oder Lochstreifen herunterladen, was teuer ist.  Sie müssen selten verwendete E / A-Geräte kaufen und warten.  Es ist bequemer, wenn das Programm immer auf dem Computer vorhanden ist.  Aufgrund starker Einschränkungen der Speichermenge und der fehlenden Hardwareunterstützung für den Stack war jedoch häufig selbstmodifizierender Code unvermeidlich, was die Verwendung von ROM stark einschränkte.  Bell sagt stolz, dass der PDP-11 die Situation verändert hat. <br><br><h3>  Primitive E / A. </h3><br>  <i>Die siebte Schwäche von Minicomputern waren die primitiven E / A-Fähigkeiten.</i> <br><br>  In den späten 60er Jahren, als der PDP-11 entwickelt wurde, waren E / A-Geräte sehr teuer.  Die damaligen Mainframes verwendeten die sogenannte Kanal-E / A, bei der der Zentralprozessor ein kleines Programm an die Kanalsteuerung sendete, die das Programm ausführte und das Ergebnis meldete.  Ein Programm könnte beispielsweise Daten von einem Magnetband laden oder eine Lochkarte durchstechen. <br><br>  Kanal-E / A war wichtig, da der Prozessor aus E / A-Vorgängen entladen und gleichzeitig E / A-Aktionen ausgeführt werden konnte, wodurch die Prozessorauslastung erhöht wurde.  Der Nachteil war, dass für die Kanal-E / A eine separate CPU in jedem Kanal-Controller erforderlich war, was die Kosten des gesamten Systems erheblich erhöhte. <br><br><img src="https://habrastorage.org/webt/i8/5d/p-/i85dp-32llbfdd4hxev4ixfzcs0.jpeg"><br><br>  In der Welt der Minicomputer wurden E / A normalerweise direkt an die CPU gesendet, wobei normalerweise spezielle Anweisungen verwendet wurden, die für jedes bestimmte Gerät fest codiert waren, z. B. ein Bandlaufwerk oder ein Konsolendrucker. <br><br>  Der PDP-11 führte etwas Ungewöhnliches ein, abgebildete E / A.  Es war keine solche speicherabgebildete E / A, die Sie mit dem Systemaufruf mmap (2) verwenden können, sondern nur eine Vereinbarung, dass einige Adressen im Speicher nicht nur Speicherzellen sind und ihr Inhalt auf Karten angezeigt wird, die in die Rückwandplatine eingesetzt sind. was im Dezember UNIBUS genannt wurde. <br><br><img src="https://habrastorage.org/webt/zg/bx/9i/zgbx9il5qoyr81cc_zkpbxarjza.jpeg"><br><br>  Zum Beispiel der in 777566 aufgezeichnete Wert <div class="spoiler">  <b class="spoiler_title">4</b> <div class="spoiler_text">  Die Adressen werden wie bei früheren 12-, 18- und 36-Bit-DEC-Computern in Oktal angegeben </div></div>  wird auf ein an die Konsole angeschlossenes Gerät geschrieben, normalerweise ein Druckterminal. <br><br><img src="https://habrastorage.org/webt/0p/_r/wk/0p_rwkprbziqlerzwca8rwp0ulo.jpeg"><br><br>  Wenn Sie den Wert von der Adresse 777570 lesen, haben Sie den von den Schaltern auf der Vorderseite eingegebenen Wert erhalten.  Dies wurde häufig verwendet, um den Bootloader zu konfigurieren. <br><br><img src="https://habrastorage.org/webt/au/d-/4y/aud-4yckvahw_4xpj_wlwyfvqpy.jpeg"><br><br>  In ähnlicher Weise wurde auf das Laufwerk RK05 zugegriffen, indem die Sektornummer, auf die Sie auf die Adresse 777412 zugreifen möchten, die Adresse, an die Sie die Daten in 777410 schreiben möchten, und die Anzahl der Wörter in 777406 geschrieben wurden. Setzen Sie dann das Nullbit auf 777404 auf 1 ( Bit GO), und das Laufwerk überträgt die gewünschte Anzahl von Wörtern direkt in den Speicher. <br><br><img src="https://habrastorage.org/webt/au/d-/4y/aud-4yckvahw_4xpj_wlwyfvqpy.jpeg"><br><br>  Mein Lieblingsgerät war das KW11-L.  Das Schreiben von Bit 6 an die Adresse 777546 löst alle 20 ms einen Interrupt aus.  Warum ist es 20 ms?  Weil es eine Periode der Wechselstromfrequenz ist <br><br><div class="spoiler">  <b class="spoiler_title">5</b> <div class="spoiler_text">  Wenn Sie ein Auto für eine Region mit einer Netzfrequenz von 60 Hz bestellt haben, hatte es eine andere Nummer (Teilenummer) <br></div></div><br>  Ja, wie eine Haushaltsuhr zählte der PDP-11 die Zeit nach Spannungsperioden im Netzwerk. <br><br><h3>  Hohe Programmierkosten </h3><br>  <i>Die neunte Schwäche von Minicomputern waren die hohen Programmierkosten.</i>  <i>Viele Benutzer programmierten in Assemblersprache ohne praktische Editoren und IDEs, Dateisysteme und Debugger, die auf großen Systemen verfügbar sind.</i>  <i>PDP-11 konnte diesen Nachteil nicht überwinden, obwohl PDP-11 komplexere Systeme als die Vorgängermodelle PDP-8 und PDP-15 baute.</i> <br><br>  Aufgrund ihres minimalistischen Charakters boten Minicomputer keine geeignete Umgebung für die Entwicklung von Programmen.  Häufig wird das mühsame Umschalten von Kippschaltern oder möglicherweise das Bearbeiten und Zusammenstellen von Programmen auf einem anderen großen Computer und das Übertragen auf ein Papierband verwendet. <br><br>  Ähnlich wie bei der heutigen Programmierung von Mikrocontrollern bearbeiten wir das Programm auf einer großen Workstation, kompilieren die Ziel-Binärdatei und übertragen sie in den Flash-Speicher des Mikrocontrollers. <br><br><img src="https://habrastorage.org/webt/ep/kq/lh/epkqlhrntlqhzoejdeaownpnmws.jpeg"><br><br>  Es scheint jedoch, dass Bell nichts über die Arbeit von Thompson und Richie wusste, die damit beschäftigt waren, ihre eigene Softwareumgebung auf dem PDP-11 in New Jersey zu erstellen. <br><br><h3>  Leute, die das Design gebaut haben </h3><br>  Fahren wir mit dem zweiten Abschnitt fort: Menschen <br><br>  Dieser Abschnitt ist für mich als Geschichtsinteressierten am interessantesten, da das Studium der Geschichte von Computern wie jedes andere historische Thema im Wesentlichen die Geschichte von Menschen und den Kontext untersucht, in dem sie Entscheidungen getroffen haben. <br><br>  Bell merkt an, dass Computer zwar technologiebasiert, aber von Menschenhand hergestellt sind, und widmete diesen Abschnitt daher der Beschreibung der Dynamik der DEC-Gruppe während der Entwicklung von PDP-11. <br><br>  <i>Die Probleme, mit denen Computerentwickler konfrontiert sind, lassen sich in zwei Teile unterteilen: Probleme aufgrund von Unerfahrenheit und Probleme systemischer Natur.</i> <br><br>  Hier erinnert sich Bell an die Worte von Fred Brooks aus seinem letzten Buch, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mythical Man-Month</a> . <br><br>  Brooks, der Leiter des OS / 360-Projekts, hat jahrelang Probleme, ein einziges Allzweckbetriebssystem zu entwickeln, das auf allen IBM / 360-Modellen ausgeführt werden kann. Dies war das Ziel des Projekts.  Brooks 'Worte waren frisch in Bells Erinnerung, als er diesen Absatz schrieb. <br><br><h3>  Zeitleiste entwerfen </h3><br>  Dieser Abschnitt bietet einen Einblick in die Arbeit der DEC Corporation Ende der 1960er Jahre. <br><br>  Die interne Organisation der Designteams bei DEC schwankte im Laufe der Jahre zwischen Marktorientierung und Produktorientierung.  Als das Unternehmen um 30 oder 40% pro Jahr wuchs, war eine kontinuierliche Umstrukturierung erforderlich.  Zu jedem Zeitpunkt arbeitete etwa ein Drittel der Mitarbeiter weniger als ein Jahr im Unternehmen. <br><br>  Heben Sie Ihre Hände, wenn Ihnen dies bekannt ist. <br><br>  <i>Während der Entwicklung des PDP-11 war das Unternehmen nach Produktlinien strukturiert.</i>  <i>Die Entwickler des Unternehmens waren in kleinen Gruppen organisiert: PDP-10-Gruppe, PDP-15-Gruppe (18-Bit-Maschine), PDP-8-Gruppe, PDP-8 / S-Untergruppe, LINC-8-Gruppe.</i>  <i>Zu jeder Gruppe gehörten Vermarkter und Ingenieure, die für Produktentwicklung, Software und Hardware verantwortlich sind.</i>  <i>Infolge einer solchen Organisation wurde die Erfahrung in der Architektur in Gruppen eingeteilt.</i> <br><br>  Bell widmet einige Zeit der Überprüfung jeder Gruppe, der Auflistung ihrer Stärken und Schwächen und ihres Beitrags zu PDP-11.  Ich werde das alles hier nicht auflisten, mit einer Ausnahme. <br><br>  <i>Die PDP-10-Gruppe war die stärkste im Unternehmen.</i>  <i>Sie bauten große, leistungsstarke Time-Sharing-Maschinen.</i>  <i>Es war in vielerlei Hinsicht eine separate Abteilung des Unternehmens mit einem Minimum an Interaktionen mit anderen Gruppen.</i>  <i>Obwohl die gesamte PDP-10-Gruppe die Funktionsweise der Systemarchitektur am besten verstand, hatte sie keine Ahnung von der Systempalette und war daran interessiert, nur Hochgeschwindigkeitscomputer zu bauen.</i> <br><br>  Ich habe kürzlich für ein Softwareunternehmen gearbeitet, bei dem ein oder zwei der ältesten Produkte fast den gesamten Gewinn des Unternehmens erzielt haben, und ich verstehe die Position von Bell sehr gut.  Der PDP-10 war eine DEC-Version des Mainframes, sehr schnell und zu nur einem Festpreis erhältlich. <br><br>  <i>Die ersten Arbeiten zur Erstellung eines 16-Bit-Computers begannen unter der Aufsicht eines PDP-15-Managers, eines Vermarkters mit technischer Erfahrung.</i>  <i>Das erste Projekt hieß PDP-X und enthielt Spezifikationen für eine Reihe von Maschinen.</i>  <i>Dies war die Architektur der Maschinenfamilie, und sie war besser konzipiert als die spätere PDP-11, aber nicht besonders innovativ.</i>  <i>Leider machte der Gruppenmanager das Management dafür verantwortlich, dass sein Projekt möglicherweise so komplex war wie das PDP-10 (was nicht der Fall war) und dass er sich des Scheiterns des Projekts sicher war und daher niemand anderes große Computer als einen einzigen großen Computer herstellen wollte Firma.</i> <br><br>  Und hier gibt uns Bell eine gute Lektion: Wenn Ihre Kompetenzen in derselben Kette liegen wie die Projekte anderer Manager, verfügen sie über ein wirksames Instrument, um Ihr Projekt zu beenden, bevor es auf den Markt kommt. <br><br>  <i>Rückblickend scheinen die an der Entwicklung von PDP-X beteiligten Personen gleichzeitig an der Entwicklung von Data General gearbeitet zu haben.</i> <br><br>  Dies mag dem Durchschnittsleser nicht aufgefallen sein, aber es ist ein Hinweis auf Shockleys „tückische Acht“ vor einem Jahrzehnt <br><br><div class="spoiler">  <b class="spoiler_title">6</b> <div class="spoiler_text">  Zu dieser Gruppe gehörten Robert Noyce und Gordon Moore, die zehn Jahre später Fairchild verließen und ihre eigene Firma Intel gründeten. <br></div></div><br>  Edson de Castro, PDP-8-Produktmanager und PDP-X-Projektmanager, verließ DEC mit mehreren Mitarbeitern seines Teams, um Data General zu bilden.  Aus den Aufzeichnungen geht nicht hervor, ob de Castro gegangen ist, weil der PDP-X eingestellt wurde, oder ob seine Abreise der letzte Strohhalm war, der das Projekt getötet hat.  Auf jeden Fall war das Ergebnis offensichtlich, wie Bell schreibt. <br><br>  <i>Als das PDP-X-Projekt geschlossen wurde, begann das DCM-Projekt (Desk Calculator Machine, aus Datenschutzgründen gewählter Codename).</i>  <i>Design und Planung waren unberechenbar, da Data General mit seinem sehr kleinen 16-Bit-Computer konkurrierte.</i> <br><br>  Data General konkurrierte nicht mit DEC mit seinem 16-Bit-Nova-Computer auf dem Markt, für den der PDP-8 entwickelt wurde und den de Castro wie seine Westentasche kannte: Rack-montierte Laborgeräte <br><br><img src="https://habrastorage.org/webt/7j/z0/ha/7jz0hacw75yjku2enc4pbz3pgoy.jpeg"><br><br>  12-Bit-PDP-8 gegen 16-Bit-Nova von Data General <br><br><img src="https://habrastorage.org/webt/dt/gl/5l/dtgl5lnjei8r8hyf3ec33ufgioo.jpeg"><br><br><h3>  PDP-11: Noten </h3><br>  Im letzten Teil des Artikels wird PDP-11 mit seinen Vorgängern verglichen, und anschließend bewertet Bell die PDP-11-Architektur selbst.  Der größte Durchbruch war UNIBUS. <br><br>  <i>Generell hat der UNIBUS-Bus alle Erwartungen übertroffen.</i>  <i>Hunderte von Arten von Speichergeräten und Peripheriegeräten konnten daran angeschlossen werden, und es wurde zu einer Standard-Architekturkomponente von Systemen im Preisbereich von 3.000 bis 100.000 US-Dollar (1975).</i> <br><br><h3>  Was ist UNIBUS? </h3><br><img src="https://habrastorage.org/webt/tf/jd/ow/tfjdowtglv5wihs8_bnuuht-11i.jpeg"><br><br>  Die frühesten kommerziellen Computer wurden als eine Reihe von Modulen konzipiert, die über Kabelverbindungen mit einer Rückwandplatine verbunden sind.  In den Tagen der Lampen war dies eine Notwendigkeit, da die Lampen unzuverlässig waren und die Module schnell ausgetauscht werden mussten. <br><br><img src="https://habrastorage.org/webt/i3/je/cz/i3jeczdmrf1xtwgbhwzdazbcwzw.jpeg"><br><br>  Später führte der Wunsch, einen Computer aus Standardmodulen zu bauen, zum Aufbau verallgemeinerter logischer Blöcke, die über eine komplexe Rückwandplatine verbunden waren. <br><br>  Hier ist ein Beispiel für frühe DEC-Module. <br><br><img src="https://habrastorage.org/webt/pg/dl/sv/pgdlsv83s3hiyinvvjjygywglyq.jpeg"><br><br>  Sie können sie auf einer komplexen Rückwandplatine mit Kabelverbindungen montieren und daraus einen Computer erstellen, in diesem Fall PDP-8. <br><br>  UNIBUS ist eine Weiterentwicklung früherer DEC-Entwicklungen und eine Abstraktion eines idealisierten Steuerbusses.  Die Verfügbarkeit von Komponenten mit mittlerer Integration macht eine komplexe Rückwandplatine überflüssig und verlagert die Hauptkomplexität auf die Module, die auf der Rückwandplatine installiert sind.  Auf diese Weise können Standardmodule erstellt werden, die eine Verbindung zu einem Computer herstellen. <br><br>  <i>Der UNIBUS-Bus war standardmäßig ein Bestandteil der Architektur, mit der Sie einfach konfigurierbare Systeme erstellen können.</i>  <i>Jedes Unternehmen, nicht nur DEC, kann problemlos Komponenten herstellen, die mit dem Bus interagieren.</i>  <i>Gute Reifen schaffen eine gute technische Umgebung, in der sich die Menschen auf ein strukturiertes Design konzentrieren können.</i>  <i>UNIBUS schuf eine Sekundärindustrie, die alternative Bezugsquellen für Speicher und Peripheriegeräte anbot.</i>  <i>Neben dem IBM 360-Bus war UNIBUS der in der Computerindustrie am weitesten verbreitete Busstandard.</i> <br><br>  Vor dem Aufkommen von UNIBUS, welche Ein- / Ausgabegeräte der Minicomputer unterstützen konnte, wurde nur von seinen Entwicklern bestimmt.  Die Interaktion mit Geräten wurde von Computerlogikschaltungen fest codiert.  Mit dem Aufkommen von UNIBUS wurde ein weites Feld für die Anpassung des Computers durch den Endbenutzer und ein Feld für Experimente geöffnet. <br><br><h3>  Was hat uns der PDP-11 beigebracht? </h3><br><img src="https://habrastorage.org/webt/nn/e5/ex/nne5exbe74glx2ouw6c_m5ynxxm.jpeg"><br><br>  Die Retrospektive von Bell endet zu dem Zeitpunkt, als der Artikel geschrieben wurde, d.h.  1976-77, aber aus unserer Sicht, vierzig Jahre später, war der Einfluss von PDP-11 enorm. <br><br><h3>  RISC </h3><br>  Als der PDP-11 noch nicht entwickelt war und darüber hinaus nicht als RISC-Maschine angesehen wurde, existierte dieser Begriff zunächst nicht, bevor er 1976 von John Coke in Bezug auf den IBM 801 eingeführt wurde. Für alle, die Programmiererfahrung hatten ARM-Prozessoren, moderne RISC-Prozessoren, deren Ähnlichkeit offensichtlich ist.  So wie das Design von Programmiersprachen sowohl ein Prozess der evolutionären Entwicklung als auch des Ausleihens ist, geschieht dasselbe mit dem Design eines Befehlssystems. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PDP-11 hat auch einen Einsatz direkt in das Herz der ausgewählten E / A-Anweisungen getrieben und das Modell der E / A genehmigt, das dem Speicher zugeordnet ist, was heute der häufigste Mechanismus ist. </font><font style="vertical-align: inherit;">Die einzigen Prozessoren mit separaten E / A-Anweisungen sind der Intel 8080 und sein Cousin Z80.</font></font><br><br><h3>  Unix </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PDP-11 hat einen großen Einfluss auf Software und Betriebssysteme. </font><font style="vertical-align: inherit;">Der PDP-11 war die Maschine, die Ken Thompson und Dennis Ritchie UNIX bei Bell Labs entwickelten.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">7</b> <div class="spoiler_text"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UNIX wurde ursprünglich auf </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PDP-7 erstellt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">1970 wurde die Entwicklung auf PDP-11/20 und später auf PDP-11/45 umgestellt.</font></font><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vor PDP-11 gab es UNIX nicht. </font><font style="vertical-align: inherit;">Vor PDP-11 existierte C nicht, es war der Computer, für den C entwickelt wurde. </font><font style="vertical-align: inherit;">Wenn Sie wissen möchten, warum in klassischem C int 16 Bit hat, dann liegt dies an PDP-11. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UNIX brachte uns die Idee von Pipes, "Alles ist eine Datei" und interaktivem Computing.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> VAX-11/780 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim interaktiven Rechnen ist die Speichernutzung unbegrenzt, und obwohl PDP für die Prozesssteuerung gut war, waren die Anforderungen des interaktiven Rechnens der Grund für die Schaffung eines Ersatzes für PDP-11. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Jahr 1977, als Bell herauskam, wurde der Nachfolger von PDP-11, VAX-11, veröffentlicht, was „virtuelle Adresserweiterung“ bedeutete.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> BSD </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UNIX kam 1974 in Berkeley an, Ken Thompson brachte das Band mit, das den Beginn der Entwicklung an der Westküste von BSD - Berkley Systems Distribution darstellte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berkeley UNIX wurde Anfang der 1980er Jahre auf VAX portiert und florierte als konterkulturelle Alternative zum VMS-Betriebssystem von DEC. </font><font style="vertical-align: inherit;">Berkeley UNIX brachte eine neue Generation von Hackern hervor, die später Unternehmen wie Sun Microsystems und Sprachen wie Self gründeten, was direkt zum Aufkommen von Java führte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UNIX wurde in den 80er Jahren auf eine Vielzahl von Computersystemen portiert, und infolge des „UNIX-Krieges“ gab es verschiedene BSD-Systeme, die noch existieren.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Weiter </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4BSD, ein Derivat der ursprünglichen Berkeley-Distribution, wurde zur Grundlage des Betriebssystems der NeXT-Computerfamilie von Steve Jobs. </font><font style="vertical-align: inherit;">Als Apple 1997 NeXT kaufte, wurden NextSTEP und sein BSD-Derivat zur Grundlage von Darwin, OSX und iOS.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Windows NT </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie wir bereits sagten, gab es bei DEC Verräter, die über Edison de Castro sprachen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dave Cutler, Architekt des VAX VMS-Betriebssystems, verließ Microsoft 1988, nachdem er nicht versucht hatte, ein neues kombiniertes Projekt aus Betriebssystem und Hardware zu starten, das den VAX ersetzen sollte, und brachte sein gesamtes Team mit und leitete die Entwicklung von Windows NT. </font><font style="vertical-align: inherit;">Diejenigen, die die Innenseiten von Windows und dem VMS-Betriebssystem kennen, werden möglicherweise allgemeine Funktionen bemerken.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Xerox Alt </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zum Abschluss des Vortrags über de Castros Geschichte inspirierte die Data General Nova-Reihe Charles Tucker und Butler Lampson, Entwickler bei Xerox Alto, die wiederum Apple Macintosh-Entwickler inspirierten. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Daten allgemein nova </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Rivalität zwischen Data General und DEC setzte sich bis in die 32-Bit-Ära fort, als Tracy Kidder, die 1981 den Pulitzer-Preis gewann, in seinem Buch </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Soul of a New Machine</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Was haben wir von PDP-11 gelernt? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl seine Entwicklung manchmal chaotisch und nicht ohne Mängel war, ist PDP-11 der Schnittpunkt vieler Fäden der Geschichte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hardware, Software, Programmiersprachen, Betriebssysteme und PDP-11 haben dies alles beeinflusst. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es lohnt sich zu feiern</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verwandte Beiträge </font></font></h3><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">What did devops mean ?</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Introducing gb, a project based build tool for the Go programming language</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">avr11: how to add 256 kilobytes of ram to an Arduino</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Padding is hard</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435292/">https://habr.com/ru/post/de435292/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435278/index.html">10 Materialien über ungewöhnliche Musikinstrumente und atypische Wege, um Klang zu extrahieren</a></li>
<li><a href="../de435280/index.html">Werden Beamte benötigt? Die Idee des sozialen Crowdfunding</a></li>
<li><a href="../de435286/index.html">Wie habe ich den Mars oder eine kleine Python-Quest gerettet?</a></li>
<li><a href="../de435288/index.html">Ein Schwarm von Satelliten als Ersatz für große umlaufende Teleskope</a></li>
<li><a href="../de435290/index.html">Englisch lernen - eine unpopuläre Meinung</a></li>
<li><a href="../de435294/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 346 (1. - 6. Januar 2019)</a></li>
<li><a href="../de435296/index.html">Unterhaltungselektronik Hall of Fame: Die Geschichten der besten Geräte der letzten 50 Jahre, Teil 3</a></li>
<li><a href="../de435298/index.html">Google Soli "Radar" entwickelt sich weiter</a></li>
<li><a href="../de435300/index.html">Subjektive Vision einer idealen Programmiersprache</a></li>
<li><a href="../de435302/index.html">Wir prototypisieren per Code. FrontTalks Vortrag</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>