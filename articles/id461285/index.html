<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸŒˆ ğŸ•’ ğŸ‘ƒ 5 algoritma pengambilan sampel utama ğŸ„ â™‚ï¸ ğŸ“¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bekerja dengan data - bekerja dengan algoritma pemrosesan data. 


 Dan saya harus bekerja dengan yang paling beragam setiap hari, jadi saya memutuska...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>5 algoritma pengambilan sampel utama</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461285/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b28/2dd/37e/b282dd37ee67bc3a63741a4f6b263815.png"></div><br><p>  Bekerja dengan data - bekerja dengan algoritma pemrosesan data. </p><br><p>  Dan saya harus bekerja dengan yang paling beragam setiap hari, jadi saya memutuskan untuk membuat daftar yang paling populer dalam serangkaian publikasi. </p><br><p>  <strong>Artikel ini berfokus pada teknik pengambilan sampel yang paling umum untuk bekerja dengan data.</strong> </p><a name="habracut"></a><br><hr><br><br><h1>  <strong>Pengambilan sampel acak sederhana</strong> </h1><br><p>  <em>Misalkan jika Anda ingin membuat pilihan di mana setiap elemen memiliki probabilitas yang sama untuk dipilih.</em> </p><br><p> Di bawah ini kami memilih 100 elemen seperti itu dari dataset. </p><br><pre><code class="python hljs">sample_df = df.sample(<span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre> <br><hr><br><h1>  <strong>Pengambilan sampel bertingkat</strong> </h1><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a52/56f/edb/a5256fedba383abefb27d0d2ecd90286.jpg" width="700" height="341"></div><br><p>  Misalkan kita perlu memperkirakan jumlah suara rata-rata untuk setiap kandidat dalam pemilihan.  Voting berlangsung di tiga kota: </p><br><p>  1 juta pekerja tinggal di kota <strong>A</strong> </p><br><p>  2 juta seniman tinggal di kota <strong>B</strong> </p><br><p>  3 juta warga senior tinggal di kota <strong>C</strong> </p><br><p>  Jika kita mencoba mengambil sampel yang sama-sama berpeluang 60 orang di antara seluruh populasi, maka sampel itu pasti tidak seimbang dibandingkan dengan kota yang berbeda, dan karena itu bias, yang akan mengarah pada kesalahan serius dalam prediksi. </p><br><p>  Jika kami secara khusus membuat sampel masing-masing 10, 20 dan 30 orang dari kota <strong>A</strong> , <strong>B</strong> dan <strong>C</strong> , maka kesalahannya akan minimal. </p><br><p>  Dengan Python, ini bisa dilakukan seperti ini: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.model_selection <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> train_test_split X_train, X_test, y_train, y_test = train_test_split(X, y, stratify=y, test_size=<span class="hljs-number"><span class="hljs-number">0.25</span></span>)</code> </pre> <br><hr><br><h1>  <strong>Pengambilan sampel reservoir</strong> </h1><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fd/b0f/72f/8fdb0f72f33efad234ffce5636d0e570.jpg" width="700" height="467"></div><br><p>  Saya suka rumusan masalah ini: </p><br><p>  <strong><em>Misalkan Anda memiliki aliran elemen dengan ukuran besar yang tidak diketahui yang dapat Anda ulangi sekali saja.</em></strong> </p><br><p>  <strong><em>Buat algoritma yang secara acak memilih elemen dari aliran seolah-olah elemen apa pun dapat dipilih dengan probabilitas yang sama.</em></strong> </p><br><p>  Bagaimana cara melakukannya? </p><br><p>  Misalkan kita perlu memilih 5 objek dari aliran yang tidak terbatas, sehingga setiap elemen dalam aliran dapat dipilih dengan kemungkinan yang sama. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(max)</span></span></span><span class="hljs-function">:</span></span> number = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> number &lt; max: number += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> number <span class="hljs-comment"><span class="hljs-comment">#    stream = generator(10000) #    k=5 reservoir = [] for i, element in enumerate(stream): if i+1&lt;= k: reservoir.append(element) else: probability = k/(i+1) if random.random() &lt; probability: #    ,    reservoir[random.choice(range(0,k))] = element print(reservoir) ------------------------------------ [1369, 4108, 9986, 828, 5589]</span></span></code> </pre> <br><p>  Secara matematis dimungkinkan untuk membuktikan bahwa setiap elemen dapat dipilih dengan kemungkinan yang sama. </p><br><p>  Bagaimana? </p><br><p>  Ketika datang ke matematika, yang terbaik adalah mencoba memulai solusi dengan kasus khusus kecil. </p><br><p>  Jadi mari kita lihat aliran yang terdiri dari 3 elemen, di mana kita hanya perlu memilih 2. </p><br><p>  Kami melihat elemen pertama, simpan di daftar, karena masih ada ruang di dalam tangki.  Kita melihat elemen kedua, simpan dalam daftar, karena masih ada ruang di dalam tangki. </p><br><p>  Kami melihat elemen ketiga.  Ini menjadi lebih menarik di sini.  Kami akan menyimpan elemen ketiga dengan probabilitas 2/3. </p><br><p>  Sekarang mari kita lihat probabilitas akhir dari elemen pertama yang disimpan: </p><br><p>  Probabilitas perpindahan elemen pertama dari reservoir adalah sama dengan probabilitas elemen ketiga yang akan dipilih, dikalikan dengan probabilitas bahwa itu adalah elemen pertama dari dua elemen yang akan dipilih untuk perpindahan.  Itu adalah: </p><br><p>  <b>2/3 * 1/2 = 1/3</b> </p><br><p>  Artinya, probabilitas akhir dari elemen pertama yang akan diselamatkan: </p><br><p>  <b>1 - 1/3 = 2/3</b> </p><br><p>  Benar-benar logika yang sama dapat diterapkan pada elemen kedua, memperluasnya di masa depan ke sejumlah besar elemen dengan peningkatan reservoir. </p><br><p>  Artinya, setiap elemen akan disimpan dengan probabilitas <b>2/3</b> atau dalam kasus umum <b>k / n</b> . </p><br><hr><br><h1>  Undersampling dan oversampling acak </h1><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef1/7fd/7b5/ef17fd7b511aa0ae67d398b3205068b8.png" width="700" height="206"></div>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber</a></em> <br><p>  Terlalu sering dalam hidup ada set data yang tidak seimbang. </p><br><p>  Metode yang banyak digunakan dalam kasus ini disebut resampling <em>(kadang-kadang mereka mengatakan "resampling" dalam terjemahan Rusia - sekitar Terjemahan.)</em> .  Esensinya terletak pada menghilangkan elemen dari set yang terlalu besar (undersampling) dan / atau menambahkan lebih banyak elemen ke set yang tidak cukup besar (oversampling). </p><br><p>  Mari kita mulai dengan membuat beberapa set yang tidak seimbang. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.datasets <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> make_classification X, y = make_classification( n_classes=<span class="hljs-number"><span class="hljs-number">2</span></span>, class_sep=<span class="hljs-number"><span class="hljs-number">1.5</span></span>, weights=[<span class="hljs-number"><span class="hljs-number">0.9</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>], n_informative=<span class="hljs-number"><span class="hljs-number">3</span></span>, n_redundant=<span class="hljs-number"><span class="hljs-number">1</span></span>, flip_y=<span class="hljs-number"><span class="hljs-number">0</span></span>, n_features=<span class="hljs-number"><span class="hljs-number">20</span></span>, n_clusters_per_class=<span class="hljs-number"><span class="hljs-number">1</span></span>, n_samples=<span class="hljs-number"><span class="hljs-number">100</span></span>, random_state=<span class="hljs-number"><span class="hljs-number">10</span></span> ) X = pd.DataFrame(X) X[<span class="hljs-string"><span class="hljs-string">'target'</span></span>] = y</code> </pre> <br><p>  Sekarang kita dapat melakukan undersampling acak dan oversampling seperti ini: </p><br><pre> <code class="python hljs">num_0 = len(X[X[<span class="hljs-string"><span class="hljs-string">'target'</span></span>]==<span class="hljs-number"><span class="hljs-number">0</span></span>]) num_1 = len(X[X[<span class="hljs-string"><span class="hljs-string">'target'</span></span>]==<span class="hljs-number"><span class="hljs-number">1</span></span>]) print(num_0,num_1) <span class="hljs-comment"><span class="hljs-comment">#   undersampled_data = pd.concat([ X[X['target']==0].sample(num_1) , X[X['target']==1] ]) print(len(undersampled_data)) #   oversampled_data = pd.concat([ X[X['target']==0] , X[X['target']==1].sample(num_0, replace=True) ]) print(len(oversampled_data)) ------------------------------------------------------------ OUTPUT: 90 10 20 180</span></span></code> </pre> <br><hr><br><h1>  Andersampling dan oversampling menggunakan tidak seimbang-belajar </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ketidakseimbangan-belajar</a> (imblearn) adalah pustaka python untuk menangani masalah dataset tidak seimbang. </p><br><p>  Ini berisi beberapa metode berbeda untuk resampling. </p><br><h3>  a.  Andersampling menggunakan Tomek Links: </h3><br><p>  Salah satu metode yang disediakan disebut Tomek Links.  "Tautan" dalam hal ini adalah pasangan elemen dari kelas yang berbeda di sekitarnya. </p><br><p>  Dengan menggunakan algoritma, kita akhirnya akan menghapus elemen pasangan dari set yang lebih besar, yang akan memungkinkan classifier bekerja lebih baik. </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39c/0f9/4cb/39c0f94cbe7ea3162713d0b00fac912b.png" width="700" height="199"></div>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber</a></em> <br><hr><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> imblearn.under_sampling <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TomekLinks tl = TomekLinks(return_indices=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, ratio=<span class="hljs-string"><span class="hljs-string">'majority'</span></span>) X_tl, y_tl, id_tl = tl.fit_sample(X, y)</code> </pre> <br><h3>  b.  Oversampling dengan SMOTE: </h3><br><p>  Dalam SMOTE (Sintesis Minority Oversampling Method), kami membuat elemen yang dekat dengan yang sudah ada dalam kumpulan yang lebih kecil. </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c57/e7e/f4f/c57e7ef4f8711ad2eda881651a027867.png" width="700" height="215"></div>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber</a></em> <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> imblearn.over_sampling <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> SMOTE smote = SMOTE(ratio=<span class="hljs-string"><span class="hljs-string">'minority'</span></span>) X_sm, y_sm = smote.fit_sample(X, y)</code> </pre> <br><p>  Tetapi di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">imblearn</a> ada cara lain undersampling (Cluster Centroids, NearMiss, dll.) Dan oversampling (ADASYN dan bSMOTE), yang juga bisa berguna. </p><br><hr><br><h1>  Kesimpulan </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Algoritma</a> adalah darah ilmu data. </p><br><p>  <strong>Pengambilan sampel adalah salah satu bidang terpenting dalam bekerja dengan data, dan hanya gambaran umum yang diberikan di atas.</strong> </p><br><p>  Strategi pengambilan sampel yang dipilih dengan baik dapat menarik seluruh proyek.  Dipilih dengan buruk menyebabkan hasil yang salah.  Karena itu, pilihan harus dibuat dengan bijak. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461285/">https://habr.com/ru/post/id461285/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461273/index.html">Pendekatan serakah dan mesin slot. Analisis tugas ML-track kejuaraan pemrograman</a></li>
<li><a href="../id461277/index.html">Ikhtisar alat SQLIndexManager gratis</a></li>
<li><a href="../id461279/index.html">Cara membuat microservice sederhana di Golang dan gRPC dan kemas menggunakan Docker</a></li>
<li><a href="../id461281/index.html">Panduan untuk menyiapkan server BIND DNS di lingkungan chroot untuk Red Hat (RHEL / CentOS) 7</a></li>
<li><a href="../id461283/index.html">Arsitektur Perangkat Lunak dan Desain Sistem: Gambaran Besar dan Panduan Sumber Daya</a></li>
<li><a href="../id461287/index.html">Mengembangkan AI yang licik dalam permainan taktis berdasarkan heuristik dan mutasi</a></li>
<li><a href="../id461289/index.html">CLion 2019.2 dirilis: dukungan pengembangan tertanam, debugger untuk MSVC, mencari file header yang tidak digunakan</a></li>
<li><a href="../id461291/index.html">Golang: masalah kinerja tertentu</a></li>
<li><a href="../id461297/index.html">Seperti apa serangan bertarget modern itu</a></li>
<li><a href="../id461299/index.html">Bagaimana PC menaklukkan industri media dengan perangkat lunak yang sukses: mendiskusikan Pro Tools dan Media Composer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>