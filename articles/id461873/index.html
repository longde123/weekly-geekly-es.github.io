<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçüé® üë®‚Äçüè´ üóΩ ViewPager 2 - fungsionalitas baru di bungkus lama üê∂ üïµüèª üëâüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ViewPager adalah salah satu komponen Perpustakaan Dukungan Android yang paling terkenal dan banyak digunakan. Semua komidi putar, papan atas, dan peng...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ViewPager 2 - fungsionalitas baru di bungkus lama</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/surfstudio/blog/461873/">  ViewPager adalah salah satu komponen Perpustakaan Dukungan Android yang paling terkenal dan banyak digunakan.  Semua komidi putar, papan atas, dan penggeser paling sederhana dibuat di atasnya.  Pada bulan Februari 2019, tim pengembangan AndroidX merilis ViewPager2.  Mari kita lihat apa saja prasyarat-prasyarat ini dan apa kelebihan dari versi komponen yang diperbarui. <br><br><img src="https://habrastorage.org/webt/eu/aw/ss/euawsscpwdgkcngbjdjqabx1uhc.png"><br><a name="habracut"></a><br><h3>  ViewPager 2 </h3><br>  Pada saat menulis posting (Juli 2019), versi beta dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ViewPager2 tersedia</a> , yang berarti bahwa masalah yang disebutkan di bawah ini dapat diperbaiki dan fungsionalitas ditingkatkan dan diperluas.  Pengembang berjanji di masa depan untuk menambahkan dukungan untuk TabLayout (sementara itu hanya dapat bekerja dengan versi pertama), mengoptimalkan kinerja adaptor, membuat banyak koreksi kecil dan menyelesaikan dokumentasi. <br><br><h3>  Integrasi </h3><br>  Komponen tidak disertakan dengan paket standar, tetapi terhubung secara terpisah.  Untuk melakukan ini, tambahkan baris berikut ke blok dependensi di skrip gradle dari modul Anda: <br><br><pre><code class="java hljs">implementation <span class="hljs-string"><span class="hljs-string">"androidx.viewpager2:viewpager2:1.0.0-beta02"</span></span></code> </pre> <br><h3>  Implementasi </h3><br>  Mari kita mulai dengan kabar baik: beralih dari versi pertama ke versi kedua adalah sesederhana mungkin dan berujung pada perubahan impor.  Sintaksis lama yang baik tidak tersentuh: metode <i>getCurrentItem ()</i> mengembalikan halaman saat ini, <i>ViewPager2.onPageChangeCallback</i> memungkinkan <i>Anda</i> untuk berlangganan ke <i>keadaan</i> pager, adaptor masih diinstal melalui <i>setAdapter ().</i> <br><br><hr><br>  Perlu menggali lebih dalam, karena menjadi jelas bahwa pager pertama dan kedua tidak memiliki kesamaan kecuali antarmuka.  Keakraban dengan penerapan metode setAdapter () tidak menyisakan ruang untuk keraguan: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setAdapter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Adapter adapter)</span></span></span><span class="hljs-function"> </span></span>{ mRecyclerView.setAdapter(adapter); }</code> </pre><br>  Ya, ViewPager2 hanyalah pembungkus dari <b>RecyclerView</b> .  Di satu sisi, ini merupakan nilai tambah yang besar, di sisi lain - ini menambah sakit kepala.  Menyamarkan <i>RecyclerView</i> sebagai selebaran menjadi mungkin dengan munculnya <b>PagerSnapHelper</b> .  Kelas ini mengubah fisika gulir.  Ketika pengguna melepaskan jarinya, <i>PagerSnapHelper</i> menghitung item daftar mana yang paling dekat dengan garis tengah daftar, dan dengan animasi yang halus selaraskan tepat di tengah.  Jadi, jika geseknya cukup tajam, daftar akan bergulir ke elemen berikutnya, jika tidak - dengan animasi kembali ke keadaan semula. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PagerSnapHelper().attachToRecyclerView(mRecyclerView);</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/737/962/b7a/737962b7a5620216a2a6d0c71353a2a1.gif" alt="gambar"><br><blockquote>  Saat menggunakan PagerSnapHelper, pastikan lebar dan tinggi RecyclerView itu sendiri, serta semua ViewHolders-nya, disetel ke MATCH_PARENT.  Jika tidak, perilaku SnapHelper tidak dapat diprediksi, bug dapat terjadi di tempat yang benar-benar tidak terduga.  Semua ini membuat korsel elemen dengan ketinggian kecil agak memakan waktu, meskipun mungkin. </blockquote><br>  Dengan semua hal di atas, dalam tata letak widget akan terlihat seperti ini: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">androidx.viewpager2.widget.ViewPager2</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@+id/main_pager"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:layout_width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"match_parent"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:layout_height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"match_parent"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre><br>  Dalam paket yang sama dengan <i>ViewPager2,</i> kita juga dapat menemukan kelas <b>ScrollEventAdapter</b> , yang membantu menjaga kontinuitas sintaksis.  <i>ScrollEventAdapter</i> mengimplementasikan <b>RecyclerView.OnScrollListener</b> dan mengubah acara gulir <b>menjadi</b> peristiwa <b>OnPageChangeCallback</b> . <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onScrollStateChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull RecyclerView recyclerView, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mAdapterState != STATE_IN_PROGRESS_MANUAL_DRAG &amp;&amp; newState == RecyclerView.SCROLL_STATE_DRAGGING) { ... dispatchStateChanged(SCROLL_STATE_DRAGGING); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ... }</code> </pre><br>  Sekarang <i>OnPageChangeCallback</i> diwakili bukan oleh antarmuka, tetapi oleh kelas abstrak, yang memungkinkan Anda untuk mendefinisikan kembali hanya metode yang diperlukan (dalam kebanyakan kasus, Anda hanya perlu <i>oPageSelected (Int)</i> , yang berfungsi ketika halaman tertentu dipilih): <br><br><pre> <code class="java hljs">main_pager.registerOnPageChangeCallback( object : ViewPager2.OnPageChangeCallback() { <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onPageSelected</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(position: Int)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//do your stuff } } )</span></span></code> </pre><br><h3>  Fitur </h3><br>  <b>Yang perlu diperhatikan adalah metode setPageTransformer ()</b> , yang menggunakan <b>ViewPager2.PageTransformer</b> sebagai parameter.  Ini menetapkan <i>panggilan balik</i> untuk setiap acara pemilihan halaman dan berfungsi untuk mengatur animasi sendiri untuk halaman ini.  <i>Callback</i> menerima tampilan halaman saat ini dan nomornya sebagai input.  Analog terdekat dengan metode ini adalah <i>ItemAnimator</i> dari <i>RecyclerView</i> . <br><br>  Dalam versi baru perpustakaan, dua implementasi transformator ditambahkan: <br><br>  <b>CompositePageTransformer</b> dan <b>MarginPageTransformer</b> .  Yang pertama bertanggung jawab untuk menggabungkan transformer untuk menerapkan beberapa transformasi pada satu pager sekaligus, dan yang kedua untuk membuat indentasi antar halaman: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/53d/c0d/49b/53dc0d49b39527079355f55a5c5cf4e0.gif" alt="gambar"><br><br>  Selain itu, widget baru mendukung perubahan orientasi: hanya dengan memanggil metode <b>setOrientation ()</b> , Anda dapat mengubah pager menjadi daftar vertikal dengan gesek dari atas ke bawah: <br><br><pre> <code class="kotlin hljs">main_pager.setOrientation(ViewPager2.ORIENTATION_VERTICAL)</code> </pre><br>  Ini terjadi lagi berkat transisi ke <i>RecyclerView</i> : di bawah tenda, perubahan dalam orientasi <i>LayoutManager disebut</i> , yang bertanggung jawab untuk menampilkan item daftar.  Perlu dicatat bahwa mendelegasikan sejumlah besar tugas ke kelas lain telah menguntungkan komponen baru: daftarnya telah menjadi jauh lebih kompak dan mudah dibaca. <br><br>  Ini bukan akhir dari kesenangan.  Dalam satu pembaruan, <i>ViewPager2</i> menerima dukungan untuk <i>ItemDecoration</i> : kelas <i>pembantu</i> untuk mendekorasi <i>View</i> anak.  Mekanisme ini dapat digunakan untuk menggambar pemisah antara elemen, batas, sorotan sel. <br><br>  Sudah ada banyak implementasi dekorator siap pakai, karena selama bertahun-tahun mereka telah berhasil digunakan ketika bekerja dengan <i>RecyclerView yang</i> biasa.  Semua perkembangan sekarang berlaku untuk pager.  Di luar kotak, implementasi standar pemisah pager tersedia: <br><br><pre> <code class="kotlin hljs">main_pager.addItemDecoration( DividerItemDecoration(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, RecyclerView.HORIZONTAL) )</code> </pre><br>  Bersamaan dengan pembaruan berikutnya pada Mei 2019, <i>ViewPager2</i> menambahkan metode penting lainnya: <b>setOffscreenPageLimit (Int)</b> .  Dia bertanggung jawab untuk berapa banyak elemen ke kanan dan kiri pusat akan diinisialisasi dalam pager.  Meskipun <i>RecyclerView</i> bertanggung jawab untuk menyimpan dan menampilkan <i>Tampilan secara</i> default, menggunakan metode ini Anda dapat secara eksplisit mengatur jumlah item yang ingin dimuat. <br><br><h3>  Adaptor </h3><br>  Penerus ideologis adaptor pager pertama adalah <i>FragmentStateAdapter</i> : antarmuka interaksi dan penamaan kelas hampir sama.  Perubahan hanya memengaruhi penamaan beberapa metode.  Jika sebelumnya diperlukan untuk mengimplementasikan fungsi abstrak <i>getItem (posisi)</i> untuk mengembalikan instance <i>Fragment yang</i> diinginkan untuk posisi yang diberikan, dan penamaan ini dapat diinterpretasikan dalam dua cara, sekarang fungsi ini telah diubah namanya menjadi <i>createFragment (posisi)</i> .  Jumlah total fragmen disediakan seperti sebelumnya oleh fungsi <i>getCount ()</i> . <br><br>  Dari perubahan struktural penting pada antarmuka, perlu juga dicatat bahwa adaptor sekarang memiliki kemampuan untuk mengontrol siklus hidup unsur-unsurnya, oleh karena itu, bersama dengan <i>FragmentManager</i> dalam konstruktor, ia menerima <i>objek Siklus Hidup</i> , baik <i>Kegiatan</i> atau <i>Fragmen</i> .  Karena itu, untuk keamanan, metode <i>saveState ()</i> dan <i>restoreState ()</i> dinyatakan final dan ditutup untuk warisan. <br>  Kelas <b>FragmentViewHolder</b> bertanggung jawab untuk menyimpan fragmen di dalam <i>RecyclerView</i> .  Metode <b>onCreateViewHolder ()</b> dari <b>FragmentStateAdapter</b> memanggil <b>FragmentViewHolder.create ()</b> . <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FragmentViewHolder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ViewGroup parent)</span></span></span><span class="hljs-function"> </span></span>{ FrameLayout container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrameLayout(parent.getContext()); container.setLayoutParams( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ViewGroup.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT ) ); container.setId(ViewCompat.generateViewId()); container.setSaveEnabled(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FragmentViewHolder(container); }</code> </pre><br>  Ketika metode <b>onBindViewHolder () dipanggil</b> , pengidentifikasi elemen pada posisi saat ini dan pengidentifikasi <i>ViewHolder terkait</i> , untuk lebih lanjut melampirkan fragmen ke dalamnya: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> itemId = holder.getItemId(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> viewHolderId = holder.getContainer().getId(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Long boundItemId = itemForViewHolder(viewHolderId); ... mItemIdToViewHolder.put(itemId, viewHolderId); ensureFragment(position); <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre><br>  Dan akhirnya, ketika melampirkan wadah dari <i>ViewHolder</i> ke hierarki tampilan, sebuah <i>FragmentTransaction</i> dieksekusi, menambahkan <i>Fragmen</i> ke wadah: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">placeFragmentInViewHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> FragmentViewHolder holder)</span></span></span><span class="hljs-function"> </span></span>{ Fragment fragment = mFragments.get(holder.getItemId()); ... scheduleViewAttach(fragment, container); mFragmentManager.beginTransaction() .add(fragment, <span class="hljs-string"><span class="hljs-string">"f"</span></span> + holder.getItemId()) .setMaxLifecycle(fragment, STARTED) .commitNow(); ... }</code> </pre><br>  Dengan demikian, dua penggunaan <i>ViewPager2 muncul</i> : melalui mewarisi kelas adaptor, baik langsung dari <i>RecyclerView.Adapter</i> atau dari <i>FragmentStateAdapter</i> . <br><br><hr><br>  Tentunya Anda akan memiliki pertanyaan: mengapa menggunakan pager kedua dengan Fragmen dan adaptor untuk mereka ketika ada versi pertama yang berfungsi normal?  <i>ViewPager</i> jauh dari "peluru perak" ketika bekerja dengan daftar data dinamis yang besar.  Ini bagus untuk membuat komidi putar dengan set gambar atau spanduk statis, tetapi feed berita dengan paginasi memuat postingan iklan, menyaring melahirkan monster yang didukung keras dan jelek.  Cepat atau lambat, Anda pasti akan menemukan hasrat yang membara untuk menulis ulang segala sesuatu di <i>RecyclerView</i> .  Sekarang Anda tidak perlu melakukan ini, karena pager itu sendiri mengubahnya, meminjam kemampuannya yang kuat untuk bekerja dengan daftar dinamis, sambil membungkusnya dalam sintaksis yang biasa. <br><br>  Satu-satunya hal yang dapat ditawarkan <i>PagerAdapter</i> kepada <i>kami</i> adalah metode <b>notifyDataSetChanged ()</b> , yang memaksa <i>ViewPager untuk</i> menggambar ulang semua item daftar yang diberikan.  Anda mungkin memperhatikan bahwa tidak ada yang menghentikan kami dari menyimpan daftar posisi untuk elemen yang ada dan mengembalikan <i>POSITION_UNCHANGED</i> dari metode <i>getItemPosition ()</i> untuk mereka, hanya itu.  Namun, solusi ini tidak dapat disebut cantik, itu agak rumit, apalagi, sulit untuk memperluas kasus-kasus ketika elemen-elemen dalam daftar terus berubah, dan tidak hanya ditambahkan secara berurutan sampai akhir.  <i>FragmentStateAdapter</i> memiliki gudang penuh metode <i>RecyclerView.Adapter</i> , sehingga logika redrawing elemen dapat dikonfigurasi jauh lebih fleksibel.  Selain itu, bersama dengan <i>FragmentStateAdapter,</i> Anda dapat menggunakan <i>DiffUtil</i> , yang memungkinkan Anda untuk secara otomatis mengotomatiskan pekerjaan pemberitahuan perubahan. <br><br><img src="https://habrastorage.org/webt/8s/j9/xg/8sj9xgon6lnfcn1thlzbhox2jtw.png"><br><blockquote>  <b>Perhatian!</b>  Untuk metode <i>notify</i> ... agar berfungsi dengan benar (kecuali untuk <i>notifyDataSetChanged</i> ), metode <b>getItemId (Int)</b> dan c <b>ontainsItem (Long)</b> harus didefinisikan ulang.  Ini dilakukan karena implementasi default hanya melihat pada nomor halaman, dan jika, misalnya, Anda menambahkan elemen baru setelah yang sekarang, itu tidak akan ditambahkan, karena <i>getItemId</i> akan tetap tidak berubah.  Contoh meng-override dua metode ini berdasarkan daftar elemen bertipe <i>Int</i> : </blockquote><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getItemId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(position: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Long</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items[position].toLong() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">containsItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(itemId: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items.contains(itemId.toInt()) }</code> </pre><br><hr><br>  Alasan utama kemunculan <i>ViewPager2</i> adalah keengganan untuk menemukan kembali roda.  Di satu sisi, <b>tim</b> pengembangan <b>AndroidX</b> jelas siap untuk meninggalkan <i>ViewPager yang</i> sudah usang sekarang dan tentu saja tidak akan berinvestasi dalam memperluas fungsionalitasnya.  Ya, dan mengapa?  Lagi pula, <i>RecyclerView</i> sudah mengetahui semua yang diperlukan.  Di sisi lain, penghapusan dan penghentian dukungan untuk komponen yang banyak digunakan jelas tidak akan menambah loyalitas masyarakat. <br><br>  Untuk meringkas: <i>ViewPager2</i> jelas layak diperhatikan, meskipun saat ini bukan tanpa kelemahan serius. <br><br><h3>  Cons </h3><br><ul><li>  Kelembaban dan sejumlah besar bug (dapat dimaafkan untuk versi beta); </li><li>  Kedekatan.  <i>RecyclerView</i> adalah bidang <i>pribadi</i> dari <i>ViewPager2</i> , yang menghalangi kita dari banyak peluang: tidak mungkin menerapkan <i>swipe-to-dismiss</i> atau <i>drag-n-drop</i> ( <b>ItemTouchHelper</b> terhubung langsung ke <i>RecyclerView</i> ), Anda tidak dapat mendefinisikan kembali <b>ItemAnimator</b> dengan cara apa pun, tidak mengakses <b>LayoutManager</b> secara langsung dan menggunakan <b>RecycledViewPool</b> secara langsung.  Namun, dengan rilis versi baru komponen, jumlah metode antarmuka yang diwarisi dari <i>RecyclerView</i> semakin bertambah (misalnya, <i>ItemDecoration</i> ), dan kami berharap dapat menambahkan metode yang hilang di masa mendatang. </li></ul><br><h3>  Pro </h3><br><ul><li>  Mendukung semua keuntungan <i>RecyclerView.Adapter</i> : menggabungkan elemen dari tipe yang berbeda dalam satu daftar, menambah dan menghapus elemen secara langsung selama swipe, animasi menggambar ulang isi daftar ketika mengubah; </li><li>  Dukungan untuk spektrum penuh metode <i>notify</i> ... dan perhitungan otomatis perubahan menggunakan <i>DiffUtil</i> ; </li><li>  Kemudahan transisi karena kesinambungan sintaksis; </li><li>  Dukungan untuk orientasi vertikal dan horizontal "out of the box"; </li><li>  Dukungan <i>RTL</i> ; </li><li>  Mendukung <i>ItemDecorator</i> ; </li><li>  Dukungan untuk <i>menggulir</i> perangkat lunak melalui <i>fakeScrollBy ()</i> ; </li><li>  Kemampuan untuk secara manual mengatur jumlah item yang dimuat; </li><li>  Kemampuan untuk menggunakan salah satu solusi open-source yang siap pakai untuk mengurangi <i>kode boilerplate</i> , yang tidak dapat dihindari ketika menulis <i>RecyclerView.Adapter</i> kustom.  Misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>EasyAdapter</i></a> . </li></ul><br>  Sebagai ringkasan, saya ingin mengatakan bahwa <b>ViewPager2</b> benar-benar layak untuk dilihat <b>lebih dekat</b> .  Ini adalah solusi yang menjanjikan, dapat dikembangkan, dan fungsional.  Dan meskipun masih terlalu dini untuk meluncurkan <i>widget baru</i> dalam produksi, aman untuk mengatakan bahwa setelah rilis penuh ia dapat dan harus sepenuhnya menggantikan leluhurnya. <br><br>  Bagi mereka yang berani dan tegas, yang terinspirasi artikel untuk bereksperimen, <i>PagerSnapHelper</i> muncul di versi 28 dari <b>Perpustakaan Dukungan</b> , yang berarti Anda dapat menggunakannya bersama dengan <i>RecyclerView</i> Anda dengan membuat <i>ViewPager2 sendiri</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh</a> operasi dari <i>ViewPager2</i> dan <i>FragmentStateAdapter</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rilis-catatan</a> resmi ViewPager2 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461873/">https://habr.com/ru/post/id461873/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461859/index.html">Anda tidak tahu apa-apa tentang teknologi makanan</a></li>
<li><a href="../id461861/index.html">Office 365 Cloud Security: Periksa Point SaaS Pengujian CloudGuard</a></li>
<li><a href="../id461865/index.html">Kursus video ‚ÄúPengantar untuk membalik dari awal menggunakan IDA PRO. Bab 1</a></li>
<li><a href="../id461867/index.html">Cara mengenali gambar dan teks pada ponsel Anda menggunakan ML Kit</a></li>
<li><a href="../id461871/index.html">101 tips untuk menjadi programmer yang baik (dan manusia)</a></li>
<li><a href="../id461875/index.html">5 nm vs 3 nm</a></li>
<li><a href="../id461877/index.html">Java vs Kotlin untuk Android: pendapat pengembang</a></li>
<li><a href="../id461879/index.html">Buku "Linux beraksi"</a></li>
<li><a href="../id461881/index.html">Panduan Pencatatan Node.js</a></li>
<li><a href="../id461885/index.html">EDS adalah jenis penipuan lainnya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>