<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåÄ ü§∑ ü§πüèª Limita√ß√µes de jogos de 8 bits e sua recrea√ß√£o exata no Unity üï§ üîª üëàüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jogos retr√¥ com mec√¢nica simples e gr√°ficos de pixel podem evocar mem√≥rias quentes de jogadores experientes e, ao mesmo tempo, s√£o bastante acess√≠veis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Limita√ß√µes de jogos de 8 bits e sua recrea√ß√£o exata no Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462843/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a7/d1d/acb/2a7d1dacbe9050c41e0fe50ca79e789e.png" alt="imagem"></div><br>  Jogos retr√¥ com mec√¢nica simples e gr√°ficos de pixel podem evocar mem√≥rias quentes de jogadores experientes e, ao mesmo tempo, s√£o bastante acess√≠veis para um p√∫blico mais jovem.  Hoje, muitos jogos s√£o chamados de retro, mas √© necess√°rio esfor√ßo e planejamento para criar um estilo nost√°lgico.  Por isso, convidamos os caras do Mega Cat Studios para nos ajudar a discutir esse t√≥pico.  Nesta postagem, abordaremos tudo o que voc√™ precisa para criar gr√°ficos aut√™nticos no estilo de jogo NES, incluindo op√ß√µes importantes do Unity, estruturas gr√°ficas e paletas de cores. <br><br><h2>  Crie arte aut√™ntica no estilo NES </h2><br>  Para come√ßar, abordaremos o b√°sico da cria√ß√£o de gr√°ficos para jogos que atendem √†s limita√ß√µes do cl√°ssico Nintendo Entertainment System.  Essa gera√ß√£o de consoles imp√µe s√©rias restri√ß√µes aos artistas que procuram reproduzir seus gr√°ficos aut√™nticos.  Essas s√£o restri√ß√µes nas paletas usadas e no tamanho e n√∫mero de objetos na tela.  Al√©m disso, √© importante considerar que a resolu√ß√£o desse console √© de 256 √ó 240 pixels. <br><br><h3>  Paletas </h3><br>  Ao criar gr√°ficos compat√≠veis com NES, o artista deve considerar muitas limita√ß√µes.  Primeiro, a mais importante dessas limita√ß√µes √© como as paletas de cores s√£o usadas na imagem.  O NES √© √∫nico, pois todas as cores poss√≠veis da paleta s√£o "conectadas" ao console.  O NES escolhe quais cores usar na imagem enviando conjuntos de valores para a GPU do NES, ap√≥s o que a GPU retorna as cores correspondentes a esses valores.  A seguir, √© apresentada uma imagem da paleta de cores NES: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/10e/4f9/0fd/10e4f90fdf5bb0ac7832dd5f4ab7d4a9.png"></div><br>  Essas cores n√£o podem ser alteradas porque fazem parte do pr√≥prio console.  Todos os jogos da NES usam combina√ß√µes dessas cores que comp√µem as imagens. <br><a name="habracut"></a><br><h3>  Sub paletas </h3><br>  Para criar combina√ß√µes usadas em jogos, s√£o criadas sub-paletas anexadas a sprites ou imagens de plano de fundo do jogo.  O NES divide a paleta em subpaletas que podem ser atribu√≠das a sprites e planos de fundo.  Cada sub-paleta cont√©m uma cor comum, usada em todas as sub-paletas, e tr√™s cores exclusivas.  Ele pode carregar quatro sub-paletas para planos de fundo e quatro sub-paletas para sprites.  No caso de sprites, a cor geral no in√≠cio de cada sub-paleta √© considerada transparente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/337/59a/330/33759a330bb3449bdf5a33c8ad1f671f.png"></div><br>  Aqui est√° um exemplo de um conjunto de sub-paletas usadas no jogo.  A parte superior mostra as sub-paletas de fundo, a parte inferior mostra as sub-paletas de sprites.  Neste exemplo, preto √© a cor comum usada em todas as sub-paletas.  Como a cor geral √© considerada transparente nos sprites, √© necess√°ria uma segunda cor preta nas sub-paletas dos sprites, que √© usada como a cor vis√≠vel. <br><br><h3>  Atribuindo sub-paletas </h3><br>  As restri√ß√µes ao uso de paletas tornam-se ainda mais rigorosas quando o artista passa a usar as paletas no jogo.  Para explicar isso, voc√™ precisa falar mais sobre como os consoles retr√¥ armazenam e exibem gr√°ficos.  Os gr√°ficos de qualquer console retro s√£o armazenados dentro do jogo como blocos de 8 √ó 8 pixels.  Gra√ßas a isso, os artistas podem economizar espa√ßo reutilizando blocos para objetos diferentes.  (Por exemplo, partes da estrada podem ser reutilizadas criando um penhasco ou construindo a partir delas).  Tamb√©m √© importante que as informa√ß√µes de cores n√£o sejam armazenadas com os gr√°ficos.  Todos os blocos s√£o salvos em uma paleta monocrom√°tica.  Gra√ßas a isso, quando um bloco √© exibido no jogo, voc√™ pode atribuir uma sub-paleta a ele e exibi-lo simultaneamente na tela com diferentes sub-paletas.  Isso √© importante ao recriar gr√°ficos de console retro em plataformas modernas, porque afeta a maneira como atribu√≠mos paletas a gr√°ficos. <br><br>  O NES atribui paletas a sprites e planos de fundo de maneira diferente.  Ela atribui paletas de sprites taylovo.  Isso significa que, com cada bloco 8 √ó 8 no sprite, uma das quatro sub-paletas do sprite pode ser associada. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0a/e7a/d58/d0ae7ad5802681f0f3fd700f52307279.png" width="1200" height="600"></div><br>  Esse personagem ninja usa duas sub-paletas para aumentar a profundidade da cor.  √Ä direita, voc√™ pode ver que est√° dividido em blocos 8 √ó 8 separados.  Nessa forma dividida, √© percept√≠vel que o turquesa claro e o vermelho escuro usados ‚Äã‚Äãna espada e na bandana da cabe√ßa s√£o exclusivos desses ladrilhos, e os contornos roxo e preto escuros s√£o usados ‚Äã‚Äãnos tr√™s ladrilhos restantes. <br><br>  Os fundos est√£o sujeitos a restri√ß√µes muito mais rigorosas.  As paletas de fundo s√£o atribu√≠das a fragmentos 16 √ó 16.  As liga√ß√µes da sub-paleta de plano de fundo da tela inteira s√£o denominadas Tabelas de Atributos (tabelas de atributos).  √â justamente por causa dessas tabelas que a maioria das imagens retro usa ativamente segmentos de blocos repetidos.  Esses segmentos geralmente consistem em 16 x 16 blocos, e √© por isso que s√£o colocados em tabelas de atributos.  Apesar de isso ter sido causado por limita√ß√µes de hardware, esses blocos de fundo 16 √ó 16 se tornaram a caracter√≠stica definidora dos gr√°ficos retr√¥ e agora s√£o absolutamente necess√°rios para sua reconstru√ß√£o em jogos modernos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7d/fb6/dfb/f7dfb6dfb062288789f2d76c2055758f.png" width="1200" height="600"></div><br>  <i>Aqui est√° um exemplo do plano de fundo de uma bela cidade no estilo de RPG, feita levando em conta essas restri√ß√µes.</i>  <i>A imagem √† direita mostra que est√° bem dividida em blocos de 16 √ó 16 pixels e paletas s√£o definidas para cada bloco.</i>  <i>Para economizar espa√ßo, elementos como telhas, grama e tijolos na ponte s√£o compostos de segmentos repetidos desses blocos.</i>  <i>As telhas de edif√≠cios pequenos usam as mesmas telhas, mas recebem sub-paletas diferentes, dando uma apar√™ncia √∫nica.</i> <br><br><h2>  Sobreposi√ß√£o de Sprite </h2><br>  Embora os artistas possam usar subpaletas diferentes para cada bloco de sprite 8 √ó 8, eles podem ter uma situa√ß√£o em que √© necess√°rio dar ao sprite uma maior profundidade de cor.  Nesse caso, voc√™ pode usar a sobreposi√ß√£o de sprite.  Sobrepor sprites √© a divis√£o de um sprite em dois sprites separados e os coloca um em cima do outro.  Isso permite que os artistas contornem a condi√ß√£o de usar uma sub-paleta por bloco 8 √ó 8.  Gra√ßas a isso, os artistas podem dobrar o n√∫mero de cores que podem ser usadas em uma √°rea 8 √ó 8.  A √∫nica desvantagem s√©ria dessa abordagem s√£o as limita√ß√µes da renderiza√ß√£o de sprites.  O NES √© capaz de exibir apenas 64 blocos de sprite 8 √ó 8 por vez e apenas oito blocos de sprite em uma linha horizontal.  Se esse limite for atingido, todos os outros blocos n√£o ser√£o renderizados na tela.  √â por isso que em muitos jogos para NES com um grande n√∫mero de sprites na tela, eles come√ßam a piscar.  Nesse caso, a √∫nica maneira de exibir todos os sprites √© mostr√°-los em quadros alternados.  Tais restri√ß√µes devem ser levadas em considera√ß√£o ao sobrepor camadas de sprites, porque isso duplica n√£o apenas o n√∫mero de cores, mas tamb√©m o n√∫mero de pe√ßas de sprite em uma linha horizontal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/386/5be/239/3865be2393a5aabf1aa3fa534ee3f7d4.png" width="1600" height="503"></div><br>  <i>Aqui est√° um exemplo de Sprite Layering em a√ß√£o.</i>  <i>A vers√£o tricolor original do sprite pirata fantasma √© mostrada √† esquerda.</i>  <i>O artista o dividiu em duas partes - o corpo / chap√©u e o rosto / m√£os, e depois atribuiu a eles paletas diferentes.</i>  <i>√Ä direita est√° o resultado da superposi√ß√£o de dois elementos um no outro.</i> <br><br>  Para contornar as limita√ß√µes da tabela de atributos, voc√™ pode implementar camadas de sprite usando o plano de fundo.  Esse truque geralmente √© usado para imagens est√°ticas, como telas de plotagem e retratos de caracteres, o que lhes confere uma profundidade de cor muito maior.  Para isso, o artista deve desenhar parte da imagem como plano de fundo e, em seguida, aplicar sprites sobre ela para preencher as partes restantes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edd/d4f/9aa/eddd4f9aadcc18eb50358c94dea42022.png" width="1407" height="600"></div><br>  <i>No retrato de um pirata fantasma, tamb√©m s√£o usadas camadas de sprites, dando-lhe uma maior profundidade.</i>  <i>Seu cr√¢nio verde √© exibido na tela como um sprite, e sua gola e chap√©u fazem parte do plano de fundo.</i>  <i>Isso permite que o artista use mais cores no segmento 16 √ó 16 para contornar completamente as limita√ß√µes da tabela de atributos.</i> <br><br><h2>  Bancos gr√°ficos </h2><br>  Para explicar outra limita√ß√£o importante do NES, primeiro precisamos voltar ao fato de que os gr√°ficos s√£o armazenados em blocos.  Os blocos gr√°ficos s√£o armazenados em p√°ginas de 256 blocos, e os blocos dessas p√°ginas n√£o podem ser carregados no VRAM em locais diferentes; portanto, fica dif√≠cil rapidamente combinar e misturar blocos de p√°ginas diferentes.  O console VRAM do NES √© capaz de exibir 512 blocos simultaneamente.  Al√©m disso, ela divide as pe√ßas ao meio para sprites e planos de fundo.  Isso significa que, ao mesmo tempo, o console pode exibir apenas 256 blocos de sprite e 256 blocos de plano de fundo.  Se um artista deseja exibir uma grande variedade de sprites e elementos de fundo, essa restri√ß√£o o impede muito. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/257/f33/d7c/257f33d7c769a4ed014dd36c4c7d4f7e.png" width="513" height="256"></div><br>  <i>Aqui est√° uma representa√ß√£o gr√°fica dos blocos de plano de fundo e sprite do jogo carregados na VRAM.</i>  <i>O console armazena planos de fundo e sprites em p√°ginas separadas.</i> <br><br>  Para contornar essa limita√ß√£o, o NES usa um recurso que permite que um artista divida cada p√°gina em p√°ginas parciais chamadas bancos.  Portanto, embora o NES n√£o possa carregar blocos individuais a partir de diferentes pontos de dados gr√°ficos, ele √© capaz de carregar partes separadas da p√°gina em momentos diferentes.  Na maioria dos jogos, esses bancos t√™m 1 KB e 2 KB de tamanho.  Um banco de 1 KB corresponde a uma quarta p√°gina, ou 64 blocos, e um banco de 2 KB corresponde a meia p√°gina, ou 128 blocos.  O artista deve decidir se deseja reservar cada tipo de banco para elementos de sprites ou fundos, porque √© necess√°rio usar os dois tipos.  Isso significa que √© imposs√≠vel ter bancos de 1 KB para sprites e fundos.  Uma p√°gina deve usar bancos de 1 KB e a outra 2 KB.  Como regra, a maioria dos jogos usa bancos de 1 KB para sprites e 2 KB para planos de fundo, porque os conjuntos de blocos de plano de fundo geralmente s√£o mais est√°ticos e requerem menos variabilidade e substitui√ß√µes em tempo real. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0fc/bb1/484/0fcbb14842a7d9fce566d032a6ab4664.png" width="513" height="256"></div><br>  <i>A imagem enlatada que vimos acima.</i>  <i>O lado esquerdo mostra fundos que usam bancos de 2 KB, ou seja, divididos ao meio, e o lado direito mostra sprites divididos em bancos de 1 KB.</i>  <i>Cada banco pode ser substitu√≠do livremente em tempo real.</i> <br><br>  A utilidade dos bancos de 1K para sprites √© bastante importante.  Se o sprite de um personagem tiver um grande n√∫mero de anima√ß√µes que n√£o couberem em uma p√°gina e, ao mesmo tempo, for necess√°rio carregar outros sprites, as a√ß√µes individuais poder√£o ser baixadas para bancos de 1 KB e substitu√≠das por eles, dependendo do que est√° acontecendo na tela.  Tamb√©m aumenta a variabilidade de sprites que podem ser usados ‚Äã‚Äãem uma √°rea do jogo.  Por exemplo, se um jogador precisa encontrar seis tipos de inimigos no n√≠vel do jogo, mas apenas o jogador e tr√™s outros tipos de sprites s√£o colocados na p√°gina do sprite, quando um tipo de inimigo desaparece da tela, o jogo pode substituir um dos bancos inimigos por um novo tipo de inimigo. <br><br>  Uma das poucas desvantagens s√©rias do uso de bancos de 1 KB para sprites e 2 KB para planos de fundo √© a maneira como o console NES processa a anima√ß√£o em segundo plano.  Para animar um elemento de plano de fundo de um jogo para o NES, um artista deve criar bancos duplicados de elementos de plano de fundo animados.  Cada novo banco duplicado conter√° o pr√≥ximo quadro de anima√ß√£o para cada um dos elementos animados.  Esses bancos se substituem, criando anima√ß√£o.  Se um artista usa bancos de meia p√°gina como pano de fundo, o armazenamento de todos esses bancos duplicados pode exigir muito espa√ßo.  Uma maneira de contornar essa limita√ß√£o √© colocar todos os elementos de fundo animados de todo o jogo em um banco.  Mas o artista se depara com outra limita√ß√£o: ele tem apenas 128 pe√ßas restantes para os elementos est√°ticos de cada plano de fundo.  Cada artista decide qual m√©todo de armazenamento √© melhor para ele. <br><br><h2>  Truques de camada </h2><br>  Muitos jogos daquela √©poca usavam truques para criar efeitos como rolagem de fundo de paralaxe, mas tamb√©m representam um desafio para artistas e designers.  Consoles posteriores de 16 bits tinham suporte para v√°rias camadas de segundo plano, mas o NES n√£o tinha esse recurso.  Todos os fundos eram uma √∫nica imagem plana.  Para criar uma sensa√ß√£o de profundidade e de camadas, v√°rios truques de programa foram usados.  Por exemplo, para criar rolagem de paralaxe, os desenvolvedores poderiam definir um registro que informava quando uma determinada linha horizontal (chamada linha de varredura) era desenhada na tela. <br><br>  Eles poderiam usar esse registro para controlar a velocidade e a dire√ß√£o da rolagem da tela.  Gra√ßas a isso, voc√™ pode criar uma linha de plano de fundo horizontal, que rola a uma velocidade diferente do restante do plano de fundo.  Para artistas e designers, o truque era ter em mente que o fundo ainda √© uma imagem plana.  Se uma plataforma ou qualquer outro elemento que deveria estar ‚Äúna frente‚Äù de um fundo em movimento lento for colocado nessa √°rea, ele tamb√©m rolar√° mais lentamente do que o restante da imagem.  Isso significa que os designers tiveram que organizar os elementos de segundo plano na cena para que o efeito n√£o fosse distorcido. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/acc/36f/7c2/acc36f7c2bab225e5b5f27c283dd68bf.png" width="512" height="448"></div><br>  <i>Neste exemplo, a √°rea destacada em vermelho para simular a profundidade pode ser feita para rolar mais lentamente do que o resto do plano de fundo.</i>  <i>A interface na parte superior da tela n√£o rola, embora tamb√©m fa√ßa parte de uma imagem de plano de fundo plana.</i> <br><br>  H√° mais um truque, gra√ßas ao qual os artistas podem "mover" um dos elementos de fundo para a frente.  Na NES, os desenvolvedores podem fazer com que a prioridade do sprite seja menor que zero.  Se isso for feito, o sprite ser√° exibido em todos os pixels opacos do plano de fundo.  As prioridades do sprite tamb√©m podem ser alteradas e ativadas rapidamente, devido a que elementos individuais podem, se necess√°rio, alterar a prioridade do sprite. <br><br><h2>  Fluxos de trabalho do Unity para a melhor sensa√ß√£o retr√¥ </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="noopener noreferrer"><strong>Fa√ßa o download de um projeto de exemplo e comece a trabalhar conosco!</strong></a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="noopener noreferrer">A Mega Cat Studios</a> de Pittsburgh, PA, transformou a cria√ß√£o de jogos retr√¥ em uma forma de arte.  De fato, alguns de seus jogos podem at√© ser comprados em cartuchos e reproduzidos em consoles retr√¥, como o Sega Genesis. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a93/80b/8a0/a9380b8a014bf276ad8196fb84cb4cd0.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f22/0f2/b85/f220f2b85387769849b6aa8267659804.gif" width="690" height="388"></div><br>  <i>Pequena Medusa e Crise do Caf√©</i> <br><br>  Mudan√ßas recentes nos fluxos de trabalho do Unity transformaram o mecanismo em um ambiente muito adequado para a cria√ß√£o de jogos retr√¥.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="noopener noreferrer">O Tilemap 2D</a> foi aprimorado e agora suporta cart√µes de pe√ßas de pe√ßas retangulares, hexagonais e isom√©tricas!  Al√©m disso, voc√™ pode usar o novo componente Pixel Perfect Camera para obter movimentos hol√≠sticos pixel a pixel e efeitos gr√°ficos.  Voc√™ pode at√© usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="noopener noreferrer">a pilha de p√≥s-processamento</a> para adicionar todos os tipos de belos efeitos retr√¥ da tela.  No entanto, antes de fazer tudo isso, voc√™ deve importar e configurar corretamente os ativos. <br><br><h2>  Prepara√ß√£o de ativos de sprite </h2><br>  Para que os ativos sejam limpos e pixelizados, eles devem primeiro ser configurados corretamente.  Selecione cada um dos ativos que voc√™ est√° usando na janela Projeto e altere os seguintes par√¢metros no inspetor: <br><br><ul><li>  Mude o modo de filtro para "Ponto" </li><li>  Altera√ß√£o de compacta√ß√£o para "Nenhum" </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/727/d21/a9b/727d21a9bc405de801852b22ac9cb612.png"></div><br>  Outros modos de filtragem resultam em um leve desfoque da imagem, o que viola o estilo de pixel claro que estamos buscando.  Ao usar a Compress√£o, os dados da imagem s√£o compactados, resultando em uma ligeira diminui√ß√£o na precis√£o.  √â importante considerar, porque alguns pixels podem mudar de cor devido √† compacta√ß√£o, potencialmente alterando toda a paleta de cores. <br><br>  Quanto menor o tamanho e o n√∫mero de cores no sprite, maior ser√° a compacta√ß√£o.  Aqui est√° um exemplo de compara√ß√£o da compacta√ß√£o normal (padr√£o) e falta de compacta√ß√£o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b82/2f0/b63/b822f0b63afa445828adbaf9d8095290.png" width="650" height="324"></div><br>  <i>Compacta√ß√£o normal / Imagem sem compacta√ß√£o - parece exatamente igual ao original</i> <br><br>  Outro aspecto a considerar √© o par√¢metro Tamanho m√°ximo da imagem no Inspetor.  Se a imagem do sprite for maior em qualquer eixo que a propriedade Tamanho m√°ximo (por padr√£o, √© 2048), ela ser√° ajustada automaticamente para o tamanho m√°ximo.  Isso geralmente resulta em perda de qualidade e a imagem come√ßa a ficar emba√ßada.  Como algumas plataformas n√£o podem suportar texturas maiores que 2048 em qualquer eixo, √© melhor permanecer dentro desse intervalo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/503/968/7cb/5039687cbe1e4e34c623abe9ff91f5f8.png" width="650" height="324"></div><br>  <i>O tamanho m√°ximo √© 2048 / E agora o tamanho m√°ximo √© 4096</i> <br><br>  A imagem acima mostra um sprite de uma folha de sprite (folha de sprite) com um tamanho de eixo √∫nico de 2208 e um tamanho m√°ximo de 2048. Como voc√™ pode ver, aumentando a propriedade Tamanho m√°ximo para 4096, conseguimos garantir o tamanho correto da imagem sem perda de qualidade. <br><br>  Por fim, ao preparar uma sprite ou folha de sprite, voc√™ deve definir o par√¢metro do modo da unidade din√¢mica como Pixels, em vez de Normalizado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3de/9fb/7ed/3de9fb7ed5bc8fbee3860d62ecdb31f8.png"></div><br>  Por esse motivo, o ponto de articula√ß√£o da imagem ser√° determinado com base em pixels, e n√£o em um intervalo suave de 0 a 1 ao longo de cada eixo da imagem.  Se o ponto de ancoragem do sprite n√£o estiver alinhado com precis√£o ao pixel, perderemos a localiza√ß√£o do sprite na precis√£o do pixel.  Os pontos de ancoragem para sprites podem ser definidos no Editor de Sprites, que √© aberto no Inspetor quando o ativo de sprite √© selecionado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/875/577/1dc/8755771dcb7cfec8e19b4e66a1bc7151.png"></div><br><h2>  Instalando o pacote Pixel Perfect 2D </h2><br>  Depois de preparar os ativos, podemos tornar o pixel da c√¢mera perfeito.  O resultado com precis√£o de pixels ficar√° claro e pronunciado.  Sinais de pixel art imprecisos se tornam borr√£o (distor√ß√£o) e a retangularidade de alguns pixels. <br><br>  Um pacote 2D Pixel Perfect pode ser importado usando o Gerenciador de Pacotes do mecanismo Unity.  Clique no menu Janela na barra de ferramentas e selecione Gerenciador de Pacotes.  Na nova janela, clique em Avan√ßado e marque a caixa de sele√ß√£o Mostrar pacotes de visualiza√ß√£o.  Selecione 2D Pixel Perfect na lista √† esquerda e clique em Instalar no canto superior direito da janela. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c8/2e2/f13/2c82e2f13a4d262ae24a269a316b3283.png"></div><br>  Isso √© tudo.  Agora voc√™ est√° pronto para come√ßar a usar o componente de c√¢mera com precis√£o de pixels. <br><br><h2>  Alta Precis√£o de Pixel </h2><br>  O componente Pixel Perfect Camera √© adicionado ao componente Camera do mecanismo Unity e o complementa.  Para adicion√°-lo, v√° para a c√¢mera principal e adicione o componente Pixel Perfect Camera.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se o componente Pixel Perfect Camera n√£o estiver no menu, siga as etapas acima para import√°-lo para o projeto. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43a/181/ee6/43a181ee66528de132ae3cc3391cf699.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora vamos examinar as op√ß√µes dispon√≠veis. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc8/90d/9f4/dc890d9f4960a724e5368e5ee954894c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro, recomendo ativar o modo de execu√ß√£o no modo de edi√ß√£o e definir a propor√ß√£o para "Aspecto livre" na janela do jogo para que voc√™ possa alterar livremente a janela do jogo. </font><font style="vertical-align: inherit;">O componente exibir√° mensagens √∫teis na janela do jogo, indicando se a exibi√ß√£o tem precis√£o de pixels na resolu√ß√£o atual.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/548/fae/889/548fae8890f6f4d1a6ddf9ba3b7bb8dc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora voc√™ pode passar por cada par√¢metro e ver como eles afetam a apar√™ncia do jogo. </font></font><br><br><ul><li> <b>Assets Pixels Per Unit</b> ‚Äî      ,        .     ,       ,        (pixels per unit, PPU),        .          ,     16  16 ,     PPU 16 ‚Äî           1.      PPU. </li><li> <b>Reference Resolution</b> ‚Äî    .      .    -,      . , Sega Genesis   320√ó224.     Sega Genesis     320√ó224. ,    16:9   320√ó180  398√ó224 (      ). </li><li> <b>Upscale Render Texture</b> ‚Äî                 .         ,   ,     -     .  ¬´Upscale Render Texture¬ª         . </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d9/288/eec/3d9288eec3429b321dbabda98d541e37.png" width="650" height="195"></div><br> <i>1.  ( ) 2.  Upscale Render Texture (   45 ,   ,        ) 3.  Upscale Render Texture (  45 ,   ,     ,         .)</i> <br><br><ul><li> <b>Pixel Snapping</b> (     Upscale Render Texture) ‚Äî       (sprite renderer)        ,        PPU. ,          transform .    -      ,     -    . <br><ul><li>  Um exemplo: </li></ul></li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/491/d2f/9ff491d2f7a076c35ea64ae165fd164d.png" width="1280" height="1000"></div><br> <i> Pixel Snapping .     (0, 0),    ‚Äî  (1.075, 0).    . ,       .  Pixel Snapping .    ‚Äî   (0, 0),    (1.075, 0).      .</i> <br><br><ul><li> <strong>Crop Frame (X  Y)</strong> ‚Äî       ,      ,    ,      . </li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Preenchimento estendido</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - sempre dispon√≠vel se voc√™ ativar x e y para o Quadro de corte. </font><font style="vertical-align: inherit;">Esta op√ß√£o faz com que a c√¢mera dimensione a janela do jogo para caber na tela enquanto mant√©m a propor√ß√£o. </font><font style="vertical-align: inherit;">Como a escala √© realizada n√£o apenas para m√∫ltiplos inteiros da resolu√ß√£o de refer√™ncia, em todos os outros casos a precis√£o do pixel ser√° perdida. </font><font style="vertical-align: inherit;">No entanto, a vantagem desse par√¢metro √© que, apesar da perda de precis√£o dos pixels em muitas resolu√ß√µes, n√£o haver√° barras pretas nas bordas e a tela estar√° completamente cheia. </font><font style="vertical-align: inherit;">Embora o preenchimento de extens√£o geralmente cause desfoque, um aviso normal n√£o √© exibido.</font></font></li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/859/034/ad1/859034ad1cc5f30911ff04808bea27c1.png" width="312" height="302"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Car√°ter e plano de fundo, preenchimento de estiramento emba√ßado</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Recomenda√ß√µes da c√¢mera Perfect Pixel </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se voc√™ precisar de uma exibi√ß√£o precisa de pixels com um snap na grade, recomendo o seguinte: </font></font><br><br><ul><li>   ,         ( 320√ó180). </li><li>    Upscale Render Texture <br><ul><li>   ,     ,   90, 180  270       ,      . </li><li> Upscale Render Texture       - ;     .        ,    Pixel Perfect Camera  Run in Edit Mode  ,       .     -     ,       - . </li></ul></li><li>    Pixel Snapping <ul><li>        .       ,     . </li></ul></li><li>  Crop Frame X / Y,   Upscale Render Texture <ul><li>      -   upscale render texture,   X / Y  -      ,          . </li></ul></li><li>  Stretch Fill </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recomendamos configurar a c√¢mera para que ela seja otimizada para uma propor√ß√£o de tela de 16: 9, incluindo resolu√ß√£o de refer√™ncia, se poss√≠vel. No momento da reda√ß√£o deste artigo, a maioria dos jogadores reproduz monitores com uma propor√ß√£o de 16: 9 e uma resolu√ß√£o de 1920 √ó 1080. Por exemplo, a resolu√ß√£o de refer√™ncia de 320 √ó 180 possui uma propor√ß√£o de 16: 9 e, portanto, com uma resolu√ß√£o de 1920 √ó 1080 e outras resolu√ß√µes que s√£o m√∫ltiplas de 320 √ó 180, por exemplo, 1280 √ó 720, n√£o haver√° bordas pretas nas bordas da tela.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na barra de ferramentas do Unity, voc√™ pode ir para Editar&gt; Configura√ß√µes do projeto&gt; Player e limitar as propor√ß√µes suportadas pelo jogo. Se voc√™ achar que uma determinada configura√ß√£o parece boa na propor√ß√£o necess√°ria, mas n√£o se encaixa bem nas propor√ß√µes individuais, aqui voc√™ pode desativar essas propor√ß√µes. No entanto, lembre-se de que nem todos os usu√°rios ter√£o uma tela que seja bem compat√≠vel com suas limita√ß√µes, portanto, isso n√£o √© recomendado. Em vez disso, use o corte para que esses usu√°rios exibam bordas pretas e o jogo n√£o inicie em uma resolu√ß√£o que n√£o corresponda √† tela.</font></font><br><br><h2>  Conclus√£o </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao tentar criar um projeto aut√™ntico para um console retro, √© necess√°rio considerar muitos aspectos t√©cnicos que ningu√©m pensa no desenvolvimento moderno. </font><font style="vertical-align: inherit;">Devido √†s peculiaridades de renderizar imagens e trabalhar com uma pequena quantidade de mem√≥ria de m√°quinas antigas, os designers tiveram que pensar de forma criativa e contornar as limita√ß√µes de hardware. </font><font style="vertical-align: inherit;">Na era moderna, precisamos conhecer essas limita√ß√µes e t√©cnicas para recriar com precis√£o a apar√™ncia e o design dos jogos daquela √©poca. </font><font style="vertical-align: inherit;">No pr√≥ximo post, veremos as limita√ß√µes de design da era dos jogos de 16 bits, bem como o fluxo de trabalho do Unity necess√°rio para recriar o estilo real da "TV antiga".</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt462843/">https://habr.com/ru/post/pt462843/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt462827/index.html">Vida e sucesso de Larry Ellison, fundador da Oracle</a></li>
<li><a href="../pt462831/index.html">Ride the Web 3.0 Wave</a></li>
<li><a href="../pt462833/index.html">O livro "Modelagem preditiva na pr√°tica"</a></li>
<li><a href="../pt462835/index.html">Layout e estilos autom√°ticos do Unity: nosso novo pipeline e ferramentas para interface do usu√°rio</a></li>
<li><a href="../pt462837/index.html">Black Box Testing</a></li>
<li><a href="../pt462845/index.html">Massagem para o seu c√©rebro: fale sobre ASMR</a></li>
<li><a href="../pt462847/index.html">Webinars da Hewlett Packard Enterprise em agosto-outubro de 2019</a></li>
<li><a href="../pt462849/index.html">Algo sobre inode</a></li>
<li><a href="../pt462851/index.html">Criamos um servi√ßo de nuvem para gerenciar suprimentos (Angular + Firebase)</a></li>
<li><a href="../pt462853/index.html">Atualizando Estat√≠sticas em R√©plicas Secund√°rias do Grupo de Disponibilidade</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>