<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤸 📭 🍑 Juego Blockchain VR con token ERC-1155: ¿React 360 o Unity? 🙃 🌉 💃🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Los juegos de realidad virtual siempre han sido una admiración para nosotros. Este es un tipo de magia en un caparazón digital, el efecto total de la ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Juego Blockchain VR con token ERC-1155: ¿React 360 o Unity?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437880/"><p> Los juegos de realidad virtual siempre han sido una admiración para nosotros.  Este es un tipo de magia en un caparazón digital, el efecto total de la inmersión en otro mundo.  En todas las conferencias, los proyectos de realidad virtual reciben la mayor atención, stands a gran escala, cientos de espectadores esperando en la cola para sumergirse en un universo recién creado.  Dado que nuestra compañía no se trata principalmente de entretenimiento, sino más bien de evolución y enfoques progresivos, examinamos en detalle la cuestión de cómo blockchain puede ser útil en un género de desarrollo de juegos tan joven como la realidad virtual. </p><br><p>  La respuesta llegó de inmediato: contratos inteligentes y el último estándar de token de red Ethereum ERC1155, diseñado específicamente para crear activos de juegos / digitales.  ERC1155 es un token que combina las mejores características de los populares ERC20 y ERC721 (los detalles técnicos se pueden encontrar en <a href="">el archivo Léame del repositorio de Github</a> ).  Imagine una situación clásica: noqueó un elemento o aspecto raro y costoso.  ¿Cómo venderlo para que el comprador no lo engañe o usted mismo no tenga la capacidad de tomar libremente el dinero de otras personas sin regalar el artículo?  La respuesta correcta es contratos inteligentes.  Y el token ERC1155 es exactamente lo que necesita para implementar dicha funcionalidad.  Un elemento puede tener sus propias características (en forma de fuerza, daño, durabilidad, protección, daño adicional (característica del token ERC721) y su valor (característico del token ERC20) en un caparazón. ¿No suena inspirador?  Todos los juegos pueden volverse seguros y fáciles de almacenar, transferir y vender sus activos digitales.  Intentemos resolver este problema usando el ejemplo de un juguete que concebimos. </p><br><p>  Se nos ocurrió el concepto con bastante rapidez: un análogo del popular juego de cartas "Munchkin", transferido al universo de realidad virtual, con contratos inteligentes para intercambiar cualquier artículo, armadura y arma que se eliminó durante el juego.  La elección de la tecnología de implementación para nuestros desarrolladores independientes no fue fácil, pero queremos contarte más sobre esta experiencia. </p><a name="habracut"></a><br><p>  <b>Reaccionar 360</b> </p><br><p>  Como la mayoría del equipo tenía una amplia experiencia en desarrollo en React, había un deseo de probar React-360 para resolver la tarea.  La descripción de la herramienta parecía bastante funcional, por lo que tomamos una decisión en su dirección. </p><br><p>  <b>Instalación y descripción</b> </p><br><p>  La instalación de React-360 comienza con la instalación de su CLI con npm, que le ayuda a inicializar, iniciar y construir un proyecto de manera rápida y conveniente desde la línea de comandos. </p><br><p>  Después de la inicialización del proyecto, recibimos una plantilla de proyecto lista para usar en la que los dos archivos principales son client.js e index.js, así como la carpeta static_assets, donde se almacenan todos los archivos aset para renderizado, index.html y otros archivos de configuración. </p><br><p>  <b>Renderizado</b> </p><br><p>  El primer archivo (client.js) contiene el código de representación y funciona con la clase principal React360.  React360 tiene dos tipos de objetos de representación: renderToLocation, que es responsable de representar un objeto 3D, y renderToSurface, que es responsable de representar un objeto 2D.  También definimos un controlador para la cámara, que describe su comportamiento: en nuestro caso, se describe el movimiento de la cámara (como el personaje principal) presionando ciertos botones del teclado.  Luego establecemos el fondo predeterminado para todo el proyecto y en la última línea escribimos React360 en el objeto de la ventana (que es un objeto global para aplicaciones de navegador). </p><br><p><img src="https://habrastorage.org/webt/9o/f_/1_/9of_1_t50ihyw89xz7h2ukfemb0.png" alt="imagen"></p><br><p>  Posteriormente, el método init de React360 se llama en el archivo index.html de la siguiente manera: </p><br><p><img src="https://habrastorage.org/webt/p4/fi/gt/p4figtiael1vnulddyfp-z_ercc.png" alt="imagen"></p><br><p>  En el segundo archivo (index.js), los componentes se registran en la aplicación, para su posterior uso para la representación en el archivo client.js. </p><br><p><img src="https://habrastorage.org/webt/pf/ut/si/pfutsittizddjkex_obmcxbohac.png" alt="imagen"></p><br><p>  Entonces, la representación de flujo del componente (objeto) sale así: </p><br><p>  a) Creación en un archivo separado; <br>  b) Registro en index.js; <br>  c) Representación en client.js. </p><br><p>  <b>Posicionamiento</b> </p><br><p>  El siguiente momento es posicionar un objeto en un plano 3D.  En React-360, al posicionar, como en el renderizado, hay diferencias entre los objetos 3D y 2D.  Los objetos 3D se pueden colocar de dos maneras. </p><br><ol><li>  Vía ubicación al renderizar. </li><li>  Via Transformar en el objeto mismo. </li></ol><br><p>  Elegimos Transformar en la ubicación predeterminada, como aconseja el sitio web oficial React-360.  Traducir es responsable del posicionamiento en el plano 3D. </p><br><p><img src="https://habrastorage.org/webt/ci/p2/mw/cip2mwze4ylkkpdksvhhtoyiclc.png" alt="imagen"></p><br><p>  Los objetos 2D se colocan usando el sistema flexible, como en React Native, que en nuestro caso fue bastante inconveniente: </p><br><p><img src="https://habrastorage.org/webt/g6/my/4r/g6my4ry1w96rbkpqqjlcnzdtyho.png" alt="imagen"></p><br><p>  Para colocar el botón a la derecha de la cámara, tenía que crear una Vista, como en React Native, y establecer su ancho correspondiente a la distancia desde el punto más a la izquierda de la pantalla hasta el lugar donde debería estar el objeto, y la altura correspondiente a la distancia desde el punto superior de la pantalla al área, donde debe estar el objeto.  También era necesario establecer ciertos estilos para que el contenido interno se ubicara en el punto inferior derecho de la Vista.  Como resultado, todo parece engorroso e inconveniente, es más fácil usar el mismo traductor para colocar dichos objetos, presentándolos como objetos 3D con 0 profundidad. </p><br><p>  <b>Importar objetos</b> </p><br><p>  El siguiente elemento es la importación de objetos 3D en React-360.  Y aquí, a primera vista, todo es simple y claro.  Hay un componente de modelo estándar que tiene una fuente de accesorios que acepta un objeto JS de la ruta a los archivos .obj (el archivo del objeto mismo) y .mtl (el archivo material de este objeto): </p><br><p><img src="https://habrastorage.org/webt/ci/p2/mw/cip2mwze4ylkkpdksvhhtoyiclc.png" alt="imagen"></p><br><p>  Pero incluso aquí hubo trampas interesantes.  La conclusión fue que el archivo .mtl tiene una textura de mapa por defecto en formato .tga y la ruta prescrita en el disco de la persona que lo desarrolló.  No solo tuvimos que cambiar la ruta de los archivos manualmente, sino también cambiarlos a .png, ya que los archivos con formato .tga no se representaron en el navegador.  El formato .png nos permitió renderizar texturas correctamente. </p><br><p>  <b>Iluminación</b> </p><br><p>  Como el sistema de iluminación no se describió en la documentación, tuve que ir al código fuente de react-360 y encontrar algo allí con respecto a Lights, y luego ver ejemplos de quién estaba haciendo qué y cómo trabajar con este zoológico.  Por prueba y error, lo descubrimos, lo aplicamos a los modelos AmbientLight, SpotLight y PointLight.  Su posición es la misma que la de los objetos 3D, pero también hay un ángulo: </p><br><p><img src="https://habrastorage.org/webt/aw/tr/b3/awtrb3bxjsgrlniywnq2ohxikr0.png" alt="imagen"></p><br><p>  La luz no se aplicaba al objeto, pero no nos retiramos, y, después de una larga búsqueda y de recorrer varios problemas en el repositorio react-360, nos encontramos con la necesidad de encender los accesorios, y solo después de eso la luz comenzó a actuar sobre el objeto. </p><br><p>  <b>Movimiento</b> </p><br><p>  Hemos tomado la cámara principal como el jugador principal con el que llevamos a cabo movimientos y acciones.  Para hacer esto, escribieron Controller para la cámara, donde inicializaron la función principal de la interfaz: </p><br><p><img src="https://habrastorage.org/webt/3l/mq/xw/3lmqxwpgihssmspqpojjdj6bwtc.png" alt="imagen"></p><br><p>  que transmite la posición actual de la cámara y su rotación.  Puede trabajar con ellos en la cámara para cambiar de acuerdo con algún evento, presionamos los botones WASD como tal evento (como de costumbre), luego quisimos reemplazarlos presionando el botón y moviéndonos a la coordenada en la que se presionó el botón, para que luego reemplácelo con el controlador VR.  Para un dulce, establecieron la velocidad de movimiento y la distancia con la que trabajaron.  Obtuvimos un movimiento con contracciones y una falta total de física: pasamos por texturas, salimos de límites, etc.  En la documentación, el físico no se describe a partir de la palabra "en general" (y, en principio, uno similar no es "amigable para el juego" en esta etapa de la inmersión se vuelve familiar). </p><br><p>  <b>Conclusión</b> </p><br><p>  Aunque React-360 funciona con Three.js y WebGL, es completamente inadecuado para resolver tales problemas; además, probablemente no fue diseñado para desarrolladores de juegos.  React-360 hace un excelente trabajo con presentaciones en 3D, recorridos virtuales de objetos, visualización de panoramas, etc. </p><br><p>  Pero incluso si se compromete a hacer tales cosas en esta pila tecnológica, encontrará dificultades en forma de documentación deficiente, lo que lo obligará a pasar horas resolviendo una tarea pequeña y aparentemente simple. </p><br><pre><code class="plaintext hljs">     JS,   React,     JSX,       ( ), ,  ,     React,     React Native.   -    .</code> </pre> <br><p>  <b>Unidad</b> </p><br><p>  Después de todo el tormento, decidimos usar la segunda herramienta dentro de nuestras competencias.  Esta vez, la elección recayó en Unity, ya que el equipo tiene desarrolladores de C #. </p><br><p>  <b>Instalación y descripción</b> </p><br><p>  La instalación es bastante simple: descarga banal y desempaqueta el kit de distribución desde el sitio oficial.  Hay un "pero": Unity hasta ahora solo funciona en Windows y Mac (desde la versión 10).  Por lo tanto, tuvimos que transferir de Ubuntu a Mac. </p><br><p>  Dado que Unity es un motor de juego que incluye una interfaz de usuario buena y conveniente, el proyecto se crea con un simple clic en el botón, después de lo cual obtienes una plantilla completa de los archivos necesarios.  Básicamente, todo se encuentra en la carpeta Activos. </p><br><p>  <b>Renderizado</b> </p><br><p>  Como el motor en sí mismo está renderizando, no necesita registrar nada. </p><br><p>  <b>Posicionamiento</b> </p><br><p>  El posicionamiento es tan fácil como el renderizado.  Es suficiente arrastrar el objeto al campo y trabajar con los controles deslizantes en la forma adecuada o en una GUI conveniente.  Al igual que con el renderizado, la situación es tal que no era necesario registrar nada. </p><br><p>  <b>Importar objetos</b> </p><br><p>  Un simple Drag'n'Drop, inicialmente dentro del Asset en la carpeta apropiada, y luego una operación similar en el campo GUI.  No hay codigo. </p><br><p>  <b>Iluminación</b> </p><br><p>  Trabajar con iluminación es tan simple como con los párrafos anteriores.  La creación de una nueva iluminación se lleva a cabo en la pestaña correspondiente del proyecto.  El sistema también se describe con suficiente detalle en la documentación. </p><br><p>  <b>Movimiento</b> </p><br><p>  Este es el primer punto donde necesita codificar algo.  A saber, el comportamiento del jugador y la cámara mientras se mueve.  Para el sistema de movimiento, utilizamos el sistema de NavMesh y sus Agentes.  Describimos el área donde puede caminar en la GUI, identificamos la cámara y el modelo como Agente en el Sistema de navegación.  Luego creamos un script, esto se hace de manera muy simple en la GUI: </p><br><ul><li>  El objeto está seleccionado; </li><li>  Se presiona el botón Agregar componentes; </li><li>  Selecciona Nueva secuencia de comandos; </li><li>  El nombre esta escrito. </li></ul><br><p>  Y listo: se crea una plantilla de script estándar en la carpeta raíz.  Solo necesitábamos transferirlo a la carpeta Scripts y abrirlo (por defecto se abre en VS, lo cual es muy conveniente).  La plantilla de script estándar tiene una interfaz intuitiva en forma de dos funciones: </p><br><ul><li>  Inicio: se utiliza al configurar componentes; </li><li>  Actualización: llamada en cada fotograma. </li></ul><br><p>  En la función Inicio, bloqueamos el cursor en el centro de la pantalla y registramos nuestro componente en la propiedad correspondiente de la clase, y también declaramos parámetros predeterminados para las propiedades restantes. </p><br><p>  En la función Actualizar, escribimos la lógica de rotación del objeto detrás del cursor, así como el movimiento del objeto haciendo clic: </p><br><p><img src="https://habrastorage.org/webt/cs/ov/e0/csove0ay8yjktshjs30yarw8omk.png" alt="imagen"></p><br><p>  <b>Conclusión</b> </p><br><p>  Además de la conclusión bastante obvia sobre la conveniencia de Unity, me gustaría señalar que para trabajar en Unity no puedes ser un programador en absoluto.  Unity tiene una gran cantidad de tutoriales para principiantes, muy simple y directo, así como documentación extensa y de alta calidad y una comunidad viva y activa. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/437880/">https://habr.com/ru/post/437880/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../437868/index.html">Semana de la seguridad 05: impresoras, cámaras, 7zip y ética</a></li>
<li><a href="../437870/index.html">Cómo Resident Evil 2 se vino abajo, pero fue capaz de convertirse en el mayor éxito de Capcom</a></li>
<li><a href="../437872/index.html">Zapatero sin botas. Cómo los estudiantes escribieron correos electrónicos de phishing</a></li>
<li><a href="../437876/index.html">"Nubes": cuál es la ventaja sobre el servidor corporativo</a></li>
<li><a href="../437878/index.html">Tendencias de ciberseguridad de BI.ZONE</a></li>
<li><a href="../437882/index.html">ASML se hace cargo de Mapper Lithography después de la quiebra</a></li>
<li><a href="../437884/index.html">Modificación del juego basada en dll-wrapper'a</a></li>
<li><a href="../437888/index.html">Capturando la señal de actividad muscular en el sistema de aprendizaje automático</a></li>
<li><a href="../437890/index.html">CNC en un taller de hobby (parte 1)</a></li>
<li><a href="../437892/index.html">Descripción general del escáner 3D Shining 3D FreeScan X7 / X7 +</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>