<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§úüèø üîÅ üè® Enfoque de ingenier√≠a para el desarrollo de software. De la teor√≠a a la pr√°ctica. üõí üÜñ üö¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬øC√≥mo probar ideas, arquitectura y algoritmos sin escribir c√≥digo? ¬øC√≥mo formular y verificar sus propiedades? ¬øQu√© son los verificadores de modelos y...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Enfoque de ingenier√≠a para el desarrollo de software. De la teor√≠a a la pr√°ctica.</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/471012/"><p> ¬øC√≥mo probar ideas, arquitectura y algoritmos sin escribir c√≥digo?  ¬øC√≥mo formular y verificar sus propiedades?  ¬øQu√© son los verificadores de modelos y los buscadores de modelos?  ¬øQu√© hacer cuando las capacidades de las pruebas no son suficientes? </p><br><p>  Hola  Mi nombre es Vasil Dyadov, ahora trabajo como programador en Yandex.Mail, antes de trabajar en Intel, estaba desarrollando c√≥digo RTL (nivel de transferencia de registro) en Verilog / VHDL para ASIC / FPGA incluso antes.  Hace tiempo que me gusta el tema de la confiabilidad del software y el hardware, las matem√°ticas, las herramientas y los m√©todos utilizados para desarrollar software y l√≥gica con propiedades garantizadas y predefinidas. </p><br><p>  Este es el segundo art√≠culo de una serie (el primer art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> ), dise√±ado para llamar la atenci√≥n de los desarrolladores y gerentes sobre el enfoque de ingenier√≠a para el desarrollo de software.  Recientemente, ha sido ignorado inmerecidamente, a pesar de los cambios revolucionarios en su enfoque y herramientas de apoyo. </p><a name="habracut"></a><br><p>  El primer art√≠culo les pareci√≥ a algunos lectores demasiado abstracto.  A muchos les gustar√≠a ver un ejemplo del uso de un enfoque de ingenier√≠a y especificaciones formales en condiciones cercanas a la realidad. </p><br><p>  En este art√≠culo, veremos un ejemplo de la aplicaci√≥n real de TLA + para resolver un problema pr√°ctico. </p><br><p>  Siempre estoy abierto a discutir temas relacionados con el desarrollo de software, y estar√© encantado de conversar con los lectores (las coordenadas para la comunicaci√≥n est√°n en mi perfil). </p><br><h1 id="chto-takoe-tla">  ¬øQu√© es TLA +? </h1><br><p>  Para empezar, quiero decir algunas palabras sobre TLA + y TLC. </p><br><p>  TLA + (l√≥gica temporal de acciones + datos) es un formalismo que se basa en un tipo de l√≥gica temporal.  Dise√±ado por Leslie Lamport. </p><br><p>  Dentro del marco de este formalismo, se puede describir el espacio de las variantes de comportamiento del sistema y las propiedades de estos comportamientos. </p><br><p>  Para simplificar, podemos suponer que el comportamiento del sistema est√° representado por una secuencia de sus estados (como cuentas infinitas, bolas en una cuerda), y la f√≥rmula TLA + define una clase de cadenas que describen todas las posibles variantes del comportamiento del sistema (una gran cantidad de cuentas). </p><br><p>  TLA + es adecuado para describir m√°quinas interactivas de estado finito no deterministas (por ejemplo, la interacci√≥n de servicios en un sistema), aunque su expresividad es suficiente para describir muchas otras cosas (que pueden expresarse en l√≥gica de primer orden). </p><br><p>  Y TLC es un verificador de modelos de estado expl√≠cito: un programa que, de acuerdo con una descripci√≥n dada del sistema TLA + y f√≥rmulas de propiedades, itera sobre los estados del sistema y determina si el sistema satisface las propiedades especificadas. </p><br><p>  T√≠picamente, trabajar con TLA + / TLC se construye de esta manera: describimos el sistema en TLA +, formalizamos propiedades interesantes en TLA +, ejecutamos TLC para verificaci√≥n. </p><br><p>  Como no es f√°cil describir directamente un sistema m√°s o menos complejo en TLA +, se invent√≥ un lenguaje de nivel superior: PlusCal, que se traduce en TLA +.  PlusCal existe de dos maneras: con Pascal y sintaxis tipo C.  En el art√≠culo que us√© sintaxis tipo Pascal, me parece que es mejor leerlo.  PlusCal con respecto a TLA + es m√°s o menos lo mismo que C con respecto al ensamblador. </p><br><p>  Aqu√≠ no profundizaremos en la teor√≠a.  La literatura para la inmersi√≥n en TLA + / PlusCal / TLC se proporciona al final del art√≠culo. </p><br><p>  Mi tarea principal es mostrar la aplicaci√≥n de TLA + / TLC en un ejemplo simple y comprensible de la vida real. </p><br><p>  En algunos comentarios al art√≠culo anterior, me reprocharon que no pint√© los fundamentos te√≥ricos de las herramientas, pero el prop√≥sito de esta serie de art√≠culos era mostrar la aplicaci√≥n pr√°ctica de herramientas para el enfoque de ingenier√≠a en el desarrollo de software. </p><br><p>  Creo que una inmersi√≥n profunda en la teor√≠a es de poco inter√©s para cualquiera, pero si est√° interesado, siempre puede ir al PM para obtener enlaces y explicaciones, y hasta donde tengo suficiente conocimiento (despu√©s de todo, no soy un matem√°tico te√≥rico, sino un ingeniero de software), intentar√© responder . </p><br><h1 id="postanovka-zadachi">  Declaraci√≥n del problema. </h1><br><p>  Primero, hablar√© un poco sobre la tarea para la que se utiliz√≥ TLA +. </p><br><p>  La tarea est√° relacionada con el procesamiento del flujo de eventos.  Es decir, crear una cola para almacenar eventos y enviar notificaciones sobre estos eventos. </p><br><p>  El almac√©n de datos se organiza f√≠sicamente sobre la base del DBMS PostgreSQL. </p><br><p>  Lo principal que debes saber: </p><br><ol><li>  Hay fuentes de eventos.  Para nuestros prop√≥sitos, podemos limitarnos al hecho de que cada evento se caracteriza por el tiempo en que se planifica su procesamiento.  Estas fuentes escriben eventos en la base de datos.  Por lo general, el tiempo de escritura en la base de datos y el tiempo del procesamiento planificado no est√°n relacionados de ninguna manera. </li><li>  Existen procesos de coordinaci√≥n que leen eventos de la base de datos y env√≠an notificaciones de eventos futuros a aquellos componentes del sistema que deben responder a estas notificaciones. </li><li>  Requisito fundamental: no debemos perder eventos.  La notificaci√≥n del evento en casos extremos puede repetirse, es decir, debe haber una garant√≠a <em>al menos una vez</em> .  En los sistemas distribuidos, es extremadamente dif√≠cil obtener una garant√≠a <em>solo una vez</em> (incluso puede ser imposible, pero debe probarse) sin mecanismos de consenso, y ellos (al menos todo lo que s√©) tienen un efecto muy fuerte en el sistema en t√©rminos de retraso y rendimiento. </li></ol><br><p>  Ahora algunos detalles: </p><br><ol><li>  Hay muchos procesos fuente; pueden generar millones (en el peor de los casos) de eventos que caen en un intervalo de tiempo estrecho. </li><li>  Los eventos se pueden generar tanto para el futuro como para el pasado (por ejemplo, si el proceso de origen se ha ralentizado y registrado un evento por un momento que ya ha pasado). </li><li>  La prioridad del procesamiento de eventos est√° en el tiempo, es decir, primero debemos procesar los primeros eventos. </li><li>  Para cada evento, el proceso de origen genera un n√∫mero aleatorio <em>worker_id</em> , debido a que los eventos se distribuyen entre los coordinadores. </li><li>  Existen varios procesos de coordinaci√≥n (escala seg√∫n las necesidades en funci√≥n de la carga del sistema). </li><li>  Cada proceso de coordinador procesa eventos para su propio conjunto <em>worker_id</em> , es decir, debido a <em>worker_id,</em> evitamos la competencia entre coordinadores y la necesidad de bloqueos. </li></ol><br><p>  Como se puede ver en la descripci√≥n, podemos considerar solo un proceso de coordinaci√≥n y no tener en cuenta <em>worker_id</em> en nuestra tarea. </p><br><p>  Es decir, por simplicidad, suponemos que: </p><br><ol><li>  Hay muchos procesos fuente. </li><li>  El proceso de coordinaci√≥n es uno. </li></ol><br><p>  Describir√© la evoluci√≥n de la idea de resolver este problema en etapas, para que sea m√°s comprensible c√≥mo evolucion√≥ el pensamiento de una implementaci√≥n simple a una optimizada. </p><br><h1 id="reshenie-v-lob">  Decisi√≥n de la frente </h1><br><p>  Crearemos una placa para eventos donde almacenaremos eventos en forma de una <em>marca de tiempo</em> (no estamos interesados ‚Äã‚Äãen otros par√°metros en esta tarea).  Construyamos un √≠ndice en el campo de <em>marca de tiempo</em> . </p><br><p>  Parece ser una soluci√≥n perfectamente normal. </p><br><p>  Solo hay un problema con la escalabilidad: cuantos m√°s eventos, m√°s lentas ser√°n las operaciones de la base de datos. </p><br><p>  Los eventos pueden venir en el pasado, por lo que el coordinador tendr√° que revisar constantemente toda la l√≠nea de tiempo. </p><br><p>  El problema se puede resolver ampliamente dividiendo la base de datos en fragmentos por tiempo, etc. Pero esta es una forma de uso intensivo de recursos. </p><br><p>  Como resultado, el trabajo de los coordinadores se ralentizar√°, ya que tendr√° que leer y combinar datos de varias bases de datos. </p><br><p>  Es dif√≠cil implementar el almacenamiento en cach√© de eventos en el coordinador para no ir a las bases para procesar cada evento. </p><br><p>  M√°s bases de datos: m√°s problemas de tolerancia a fallas. </p><br><p>  Y as√≠ sucesivamente. </p><br><p>  No nos detendremos en esta soluci√≥n frontal en detalle, ya que es trivial y poco interesante. </p><br><h1 id="pervaya-optimizaciya">  Primera optimizaci√≥n </h1><br><p>  Veamos c√≥mo mejorar la soluci√≥n frontal. </p><br><p>  Para optimizar el acceso a la base de datos, puede complicar un poco el √≠ndice, agregar un identificador que aumente de forma mon√≥tona a los eventos que se generar√°n al confirmar una transacci√≥n en la base de datos.  Es decir, el evento ahora se caracteriza por el par <em>{time, id}</em> , donde <em>time</em> es la hora a la que se programa el evento, <em>id</em> es un contador que aumenta de manera mon√≥tona.  Hay una garant√≠a de unicidad de <em>id</em> para cada evento, pero no hay garant√≠a de que los valores de <em>id</em> no tengan agujeros (es decir, puede haber una secuencia de este tipo: <em>1</em> , <em>2</em> , <em>7</em> , <em>15</em> ). </p><br><p>  Parece que ahora podemos almacenar el identificador del √∫ltimo evento de lectura en el proceso del coordinador y, al buscar, seleccionar eventos con identificadores mayores que el √∫ltimo evento procesado. </p><br><p>  Pero aqu√≠ surge el problema de inmediato: los procesos de origen pueden registrar un evento con una marca de tiempo en el futuro.  Luego, tendremos que tener en cuenta constantemente el conjunto de eventos con peque√±os identificadores en el proceso de coordinaci√≥n, cuyo tiempo de procesamiento a√∫n no ha llegado. </p><br><p>  Puede notar que los eventos relativos a la hora actual se dividen en dos clases: </p><br><ol><li>  Eventos con una marca de tiempo en el pasado, pero con un identificador grande.  Se escribieron en la base de datos recientemente, despu√©s de que procesamos ese intervalo de tiempo.  Estos son eventos de alta prioridad y deben procesarse primero para que la notificaci√≥n, que ya llega tarde, ni siquiera llegue tarde. </li><li>  Eventos registrados alguna vez con marcas de tiempo cercanas al momento actual.  Tales eventos tendr√°n un valor identificador bajo. </li></ol><br><p>  En consecuencia, el estado actual del proceso del coordinador se caracteriza por el par {state.time, state.id}. </p><br><p>  Resulta que los eventos de alta prioridad est√°n a la izquierda y por encima de este punto (regi√≥n rosa), y los eventos normales est√°n a la derecha (azul claro): </p><br><p><img src="https://habrastorage.org/webt/n3/x3/q-/n3x3q-kjbxuerrkffffqqnh6hh8.png"></p><br><h2 id="blok-shema">  Diagrama de flujo </h2><br><p>  El algoritmo de trabajo del coordinador es el siguiente: </p><br><p><img src="https://habrastorage.org/webt/j6/4d/ge/j64dgeq_jubcbyn4e3zu9ekfasy.png"></p><br><p><img src="https://habrastorage.org/webt/8y/ux/si/8yuxsi4nubi7q5yvclqizezo6xq.png"></p><br><p>  Al estudiar el algoritmo, pueden surgir preguntas: </p><br><ol><li>  ¬øQu√© pasa si comienza el procesamiento de eventos normales y en ese momento llegan nuevos eventos en el pasado (en la regi√≥n rosa), ¬øno se perder√°n?  Respuesta: se procesar√°n en el pr√≥ximo ciclo de procesamiento de eventos de alta prioridad.  No pueden perderse, ya que <em>se</em> garantiza que su <em>identificaci√≥n</em> ser√° m√°s alta que state.id. </li><li>  ¬øQu√© sucede si despu√©s de procesar todos los eventos normales, al momento de cambiar al procesamiento de eventos de alta prioridad, llegan nuevos eventos con marcas de tiempo del intervalo [estado.hora, estado.hora + Delta], los perdemos?  Respuesta: caer√°n en el √°rea rosa, ya que tendr√°n <em>tiempo</em> &lt;state.time e <em>id</em> &gt; state.id: llegaron recientemente y la <em>identificaci√≥n</em> aumenta de <em>forma</em> monot√≥nica. </li></ol><br><h2 id="primer-raboty-algoritma">  Ejemplo de operaci√≥n de algoritmo </h2><br><p>  Veamos algunos pasos del algoritmo: </p><br><p><img src="https://habrastorage.org/webt/jl/lf/5v/jllf5vhoz843at6gfrtmjmasppw.png"></p><br><p><img src="https://habrastorage.org/webt/z-/ri/zx/z-rizxhocuxtepr7_wnflvgqm14.png"></p><br><p><img src="https://habrastorage.org/webt/oc/dr/pv/ocdrpv4ozmf-pq_itridvcjookc.png"></p><br><p><img src="https://habrastorage.org/webt/uv/xt/aw/uvxtawqbs5ftd8uzebcwqosdrvw.png"></p><br><p><img src="https://habrastorage.org/webt/uo/_s/cg/uo_scglk7ucb_yze8he8b___wro.png"></p><br><p><img src="https://habrastorage.org/webt/ko/8q/24/ko8q24qizzqz5ddew4jbodavvts.png"></p><br><p><img src="https://habrastorage.org/webt/iw/-f/el/iw-felnslp1mdme-thbu_nicbly.png"></p><br><p><img src="https://habrastorage.org/webt/vf/vs/tz/vfvstz05jy9aowpndr-okgajxpk.png"></p><br><h2 id="model">  Modelo </h2><br><p>  Nos aseguraremos de que el algoritmo no pierda eventos y se enviar√°n todas las notificaciones: redactaremos un modelo simple y lo verificaremos. </p><br><p>  Para el modelo usamos TLA +, m√°s precisamente PlusCal, que se traduce en TLA +. </p><br><pre><code class="plaintext hljs">---------------- MODULE events ---------------- EXTENDS Naturals, FiniteSets, Sequences, TLC (* --algorithm Events \*      \*   (by Daniel Jackson) \* small-scope hypothesis,   \*  ,  ÃÅ   \*     \*   \*  : \* Events -   - ,   \*    [time, id], \*     \*      \*   \* Event_Id -    \*   id \* MAX_TIME -  ,   \*   \* TIME_DELTA -   Delta, \*     \*  variables Events = {}, Event_Id = 0, MAX_TIME = 5, TIME_DELTA \in 1..3 define \*   \*   ZERO_EVT == [time |-&gt; 0, id |-&gt; 0] MAX(S) == CHOOSE x \in S: \A y \in S: y &lt;= x MIN(S) == CHOOSE x \in S: \A y \in S: y &gt;= x \*  fold_left/fold_right    RECURSIVE SetReduce(_, _, _) SetReduce(Op(_, _), S, value) == IF S = {} THEN value ELSE LET s == CHOOSE s \in S : TRUE IN SetReduce(Op, S \ {s}, Op(s, value)) (*     (  ) *) ToSeq(S) == LET op(e, val) == Append(val, e) IN SetReduce(op, S, &lt;&lt; &gt;&gt;) (* :    *) ToSet(S) == {S[i] : i \in DOMAIN(S)} (*  map    *) MapSet(Op(_), S) == {Op(x) : x \in S} (*   *) \*   id  GetIds(Evts) == MapSet(LAMBDA x: x.id, Evts) \*   time  GetTimes(Evts) == MapSet(LAMBDA x: x.time, Evts) (*   SQL  *) \*     \*   ORDER BY EventsOrderByTime(e1, e2) == e1.time &lt; e2.time EventsOrderById(e1, e2) == e1.id &lt; e2.id EventsOrder(e1, e2) == \*   time, id \/ EventsOrderByTime(e1, e2) \/ /\ e1.time = e2.time /\ EventsOrderById(e1, e2) \* SELECT * FROM events \* WHERE time &lt;= curr_time AND id &gt;= max_id \* ORDER BY time, id SELECT_HIGH_PRIO(state) == LET \*      \* time &lt;= curr_time \* AND id &gt;= maxt_id selected == {e \in Events : /\ e.time &lt;= state.time /\ e.id &gt;= state.id } IN selected \* SELECT * FROM events \* WHERE time &gt; current_time AND time - Time &lt;= delta_time \* ORDER BY time, id SELECT_NORMAL(state, delta_time) == LET selected == {e \in Events : /\ e.time &lt;= state.time + delta_time /\ e.time &gt; state.time } IN selected \* Safety predicate \*       ALL_EVENTS_PROCESSED(state) == \A e \in Events: \/ e.time &gt;= state.time \/ e.id &gt;= state.id end define; \*  -   fair process inserter = "Sources" variable n, t; begin forever: while TRUE do \*      get_time: \*     \* ,     , \*    with evt_time \in 0..MAX_TIME do t := evt_time; end with; \*     ; \*   : \* 1.   . \* 2.  ,    \* Event_Id -   , \*     commit: \* either -     either Events := Events \cup {[time |-&gt; t, id |-&gt; Event_Id]} || Event_Id := Event_Id + 1; or Event_Id := Event_Id + 1; end either; end while; end process fair process coordinator = "Coordinator" variable state = ZERO_EVT, events = {}; begin forever: while TRUE do \*    high_prio: events := SELECT_HIGH_PRIO(state); \*   process_high_prio: \*          , \*    Events, \*       state.id := MAX({state.id} \union GetIds(events)) || \*      , \*      Events := Events \ events || \*  events  , \*      events := {}; \*  -   normal: events := SELECT_NORMAL(state, TIME_DELTA); process_normal: state.time := MAX({state.time} \union GetTimes(events)) || Events := Events \ events || events := {}; end while; end process end algorithm; *) \* BEGIN TRANSLATION \*  TLA+,     PlusCal  \* END TRANSLATION ================================</code> </pre> <br><p>  Como puede ver, la descripci√≥n es relativamente peque√±a, a pesar de la secci√≥n bastante voluminosa de definiciones (definir), que podr√≠a extraerse en un m√≥dulo separado y luego reutilizarse. </p><br><p>  En los comentarios trat√© de explicar lo que est√° sucediendo en el modelo.  Espero que esto <br>  Lo logr√© y no hay necesidad de pintar el modelo con m√°s detalle. </p><br><p>  Solo me gustar√≠a aclarar un punto con respecto a la atomicidad de las transiciones entre estados y caracter√≠sticas de modelado. </p><br><p>  El modelado se lleva a cabo realizando pasos at√≥micos de procesos.  En una transici√≥n, se realiza un paso at√≥mico de un proceso en el que se puede realizar este paso.  La elecci√≥n del paso y el proceso no es determinista: durante el modelado, se ordenan todas las cadenas posibles de pasos at√≥micos de todos los procesos. </p><br><p>  Puede surgir la pregunta: ¬øqu√© pasa con el modelado del verdadero paralelismo, cuando realizamos simult√°neamente varios pasos at√≥micos en diferentes procesos? </p><br><p>  Esta pregunta Leslie Lamport ha sido respondida durante mucho tiempo en el libro Especificando sistemas y otros trabajos. </p><br><p>  No citar√© la respuesta por completo, en resumen, la esencia es esta: si no hay una escala de tiempo exacta donde cada evento est√© vinculado a un momento espec√≠fico, entonces no hay diferencia en modelar eventos paralelos como eventos secuenciales no deterministas, porque siempre podemos suponer que un evento ocurri√≥ antes que otro valor infinitesimal </p><br><p>  Pero lo realmente importante es la asignaci√≥n competente de los pasos at√≥micos.  Si hay demasiados, se producir√° una explosi√≥n combinatoria del espacio de estado.  Si toma menos pasos de los necesarios, o los selecciona incorrectamente, es decir, la probabilidad de perder un estado / transici√≥n no v√°lido (es decir, perderemos los errores en el modelo). </p><br><p>  Para dividir correctamente los procesos en pasos at√≥micos, debe tener una buena idea de c√≥mo funciona el sistema en t√©rminos de la dependencia de los procesos de los datos y los mecanismos de sincronizaci√≥n. </p><br><p>  Como regla general, dividir los procesos en pasos at√≥micos no causa grandes problemas.  Y si lo hace, entonces indica una falta de comprensi√≥n del problema y no problemas con la compilaci√≥n del modelo y la escritura de la especificaci√≥n TLA +.  Esta es otra caracter√≠stica muy √∫til de las especificaciones formales: requieren un estudio y an√°lisis exhaustivos. <br>  un problema  Como regla general, si la tarea es significativa y bien entendida, no hay problemas con su formalizaci√≥n. </p><br><h2 id="proverka-modeli">  Verificaci√≥n del modelo </h2><br><p>  Para modelar usar√© TLA-toolbox.  Por supuesto, puede ejecutar todo desde la l√≠nea de comandos, pero el <em>IDE</em> es a√∫n m√°s conveniente, especialmente para comenzar a aprender sobre modelado usando TLA +. </p><br><p>  La creaci√≥n del proyecto est√° bien descrita en manuales, art√≠culos y libros, los enlaces a los que he citado al final del art√≠culo, por lo que no me repetir√©.  Lo √∫nico que llamar√© su atenci√≥n es la configuraci√≥n de simulaci√≥n. </p><br><p>  TLC es un <em>verificador de modelos</em> con <em>verificaci√≥n</em> expl√≠cita de estado.  Est√° claro que el espacio estatal debe estar limitado por l√≠mites razonables.  Por un lado, debe ser lo suficientemente grande como para poder verificar las propiedades que nos interesan y, por otro lado, lo suficientemente peque√±o como para completar la simulaci√≥n en un tiempo razonable utilizando recursos aceptables. </p><br><p>  Este es un punto bastante delicado, aqu√≠ debe comprender las propiedades del sistema y el modelo.  Pero r√°pidamente viene con experiencia.  Para empezar, simplemente puede establecer los l√≠mites m√°ximos posibles que a√∫n son aceptables en t√©rminos de tiempo de simulaci√≥n y recursos consumidos. </p><br><p>  Tambi√©n hay un modo de verificar no todo el espacio de estado, sino cadenas selectivas a una cierta profundidad.  A veces tambi√©n es posible y necesario usarlo. </p><br><p>  Volvemos a la configuraci√≥n de simulaci√≥n. </p><br><p>  Primero, definimos las restricciones en el espacio de estado del sistema.  Las limitaciones se establecen en la secci√≥n Configuraci√≥n <em>avanzada de</em> simulaci√≥n de <em>restricciones de estado / Opciones</em> . </p><br><p>  All√≠ indiqu√© una expresi√≥n TLA +: <code>Cardinality(Events) &lt;= 5 /\ Event_Id &lt;= 5</code> , <br>  donde Event_Id es el l√≠mite superior del valor del identificador de evento, <code>Cardinality(Events)</code> es el tama√±o del conjunto de registros de eventos (limitado el modelo base <br>  datos por cinco registros en una placa). </p><br><p>  En la simulaci√≥n, el TLC solo analizar√° los estados en los que esta f√≥rmula es verdadera. </p><br><p>  Todav√≠a puede permitir transiciones de estado v√°lidas ( <em>Opciones avanzadas / Restricci√≥n de acci√≥n</em> ), <br>  pero no lo necesitamos </p><br><p>  A continuaci√≥n, indicamos la f√≥rmula TLA + que describe nuestro sistema: <em>Descripci√≥n general del modelo / F√≥rmula temporal</em> = <code>Spec</code> , donde <em>Spec</em> es el nombre de la f√≥rmula TLA + autogenerada por PlusCal (en el c√≥digo del modelo anterior no es: para ahorrar espacio, no cit√© el resultado de traducir PlusCal a TLA +) . </p><br><p>  La siguiente configuraci√≥n a la que vale la pena prestar atenci√≥n es la comprobaci√≥n de punto muerto. <br>  (marca de verificaci√≥n en <em>Descripci√≥n general del modelo / Punto muerto</em> ).  Cuando esta bandera est√° habilitada, el TLC verificar√° el modelo para los estados "colgantes", es decir, aquellos de los cuales no hay transiciones salientes.  Si hay tales estados en el espacio de estados, esto significa un claro error en el modelo.  O en TLC, que, como cualquier otro programa no trivial, no es inmune a los errores :) En mi (no tan grande) pr√°ctica, todav√≠a no he encontrado puntos muertos. </p><br><p>  Y finalmente, en aras de que se iniciaron todas estas pruebas, la f√≥rmula de seguridad en <em>Model Overview / Invariants</em> = <code>ALL_EVENTS_PROCESSED(state)</code> . </p><br><p>  TLC verificar√° la validez de la f√≥rmula en cada estado, y si se vuelve falsa, <br>  mostrar√° un mensaje de error y mostrar√° la secuencia de estados que condujeron al error. </p><br><p>  Despu√©s de iniciar TLC, despu√©s de trabajar durante aproximadamente 8 minutos, inform√≥ "Sin errores".  Esto significa que el modelo se prueba y cumple con las propiedades especificadas. </p><br><p>  TLC tambi√©n muestra muchas estad√≠sticas interesantes.  Por ejemplo, para este modelo, se obtuvieron 7 677 824 estados √∫nicos; en total, el TLC analiz√≥ 27 109 029 estados, el di√°metro del espacio de estado es 47 (esta es la longitud m√°xima de la cadena de estado antes de la repetici√≥n, <br>  duraci√≥n m√°xima del ciclo desde estados no repetidos en el gr√°fico de estado y transici√≥n). </p><br><p>  Si dividimos 27 millones de estados en 8 minutos, obtenemos aproximadamente 56 mil estados por segundo, lo que puede no parecer muy r√°pido.  Pero tenga en cuenta que ejecut√© la simulaci√≥n en una computadora port√°til que funcionaba en modo de ahorro de energ√≠a (forc√© la frecuencia central a 800 MHz, porque viajaba en ese momento en un tren el√©ctrico), y no optimic√© el modelo para la velocidad de simulaci√≥n en absoluto. </p><br><p>  Hay muchas formas de acelerar la simulaci√≥n: desde portar parte del c√≥digo del modelo TLA + a Java y conectarse a TLC sobre la marcha (es √∫til para acelerar todo tipo de funciones auxiliares) hasta ejecutar TLC en las nubes y en los cl√∫steres (el soporte de la nube de Amazon y Azure est√° integrado en el propio TLC). </p><br><h1 id="vtoraya-optimizaciya">  Segunda optimizaci√≥n </h1><br><p>  En el algoritmo anterior, todo est√° bien, excepto por algunos problemas: </p><br><ol><li>  Hasta que <code>[state.time, state.time + Delta]</code> todos los eventos de la zona azul en el intervalo <code>[state.time, state.time + Delta]</code> , no podemos pasar a eventos de alta prioridad.  Es decir, los eventos tard√≠os llegar√°n tarde a√∫n m√°s.  Y generalmente la demora es impredecible.  Debido a esto, state.time puede estar muy por detr√°s de la hora actual, y esta es la causa del siguiente problema. </li><li>  Los eventos que llegan a la regi√≥n de eventos normales pueden llegar tarde ( <em>id</em> &gt; state.id).  Ya son de alta prioridad y deben considerarse eventos de la regi√≥n rosa, y todav√≠a los consideramos normales y los tratamos como normales. </li><li>  Es dif√≠cil organizar el almacenamiento en cach√© de eventos y la reposici√≥n de cach√© (lectura de la base de datos). </li></ol><br><p>  Si los dos primeros puntos son obvios, entonces el tercero probablemente plantear√° la mayor√≠a de las preguntas.  Deteng√°monos en ello con m√°s detalle. </p><br><p>  Supongamos que queremos leer primero un n√∫mero fijo de eventos en la memoria y luego procesarlos. </p><br><p>  Despu√©s del procesamiento, queremos marcar eventos en la base de datos con consultas de bloque como procesadas, porque si trabaja no con bloques, sino con eventos individuales, no habr√° grandes ganancias con el almacenamiento en cach√©. </p><br><p>  Supongamos que hemos procesado parte de los bloques y queremos complementar el cach√©.  Luego, si llegan eventos tard√≠os de alta prioridad durante el procesamiento, podemos procesarlos temprano. </p><br><p>  Es decir, es muy deseable poder leer eventos en bloques peque√±os para procesar los retrasos lo m√°s r√°pido posible, pero actualizar el atributo de procesamiento en la base de datos con bloques grandes a la vez, para mayor eficiencia. </p><br><p>  ¬øQu√© hacer en este caso? </p><br><p>  Intente trabajar con la base de datos en peque√±os bloques con un √°rea azul y rosa y mueva el punto de estado en peque√±os pasos. </p><br><p>  Por lo tanto, la memoria cach√© se introdujo y se ley√≥ desde los datos de la base de datos, despu√©s de cada lectura, el punto de estado se cambi√≥ para no volver a leer los eventos ya le√≠dos. </p><br><p>  Ahora el algoritmo se ha vuelto un poco m√°s complicado, comenzamos a leer en porciones limitadas. </p><br><h2 id="blok-shema-1">  Diagrama de flujo </h2><br><p><img src="https://habrastorage.org/webt/as/8n/qk/as8nqk0dmos8bsiwiigzphb7gns.png"></p><br><p><img src="https://habrastorage.org/webt/wn/9x/yx/wn9xyxfi4j2021hibcqxe3abhn8.png"></p><br><p>  En este algoritmo, se puede ver que debido a la restricci√≥n en bloques de eventos legibles, el retraso m√°ximo en la transici√≥n del procesamiento de baja prioridad al procesamiento de alta prioridad ser√° igual al tiempo de procesamiento m√°ximo del bloque. </p><br><p>  Es decir, ahora podemos leer eventos en la memoria cach√© en peque√±os bloques y controlar el retraso m√°ximo en la transici√≥n al procesamiento de eventos de alta prioridad mediante el control del tama√±o m√°ximo de bloque para la lectura. </p><br><h2 id="primer-raboty-algoritma-1">  Ejemplo de operaci√≥n de algoritmo </h2><br><p>  Veamos el algoritmo en el trabajo, en pasos.  Por conveniencia, tome <code>LIMIT = 2</code> . </p><br><p><img src="https://habrastorage.org/webt/-i/u8/qz/-iu8qzxfabbn9gcig_ekb1xhabu.png"></p><br><p><img src="https://habrastorage.org/webt/3x/if/ju/3xifju7ktzac6eyyutbhfanpufs.png"></p><br><p><img src="https://habrastorage.org/webt/ab/dg/o7/abdgo7ieinh8ddx6tnthfcsrwre.png"></p><br><p><img src="https://habrastorage.org/webt/ei/qg/al/eiqgal0lfwfiwtdltnb-e1bjyc0.png"></p><br><p><img src="https://habrastorage.org/webt/hp/2i/kd/hp2ikd4mgcqsswoiwwexz_kmp-e.png"></p><br><p><img src="https://habrastorage.org/webt/tq/ct/fv/tqctfvtnrqo939zqut2-8lwjale.png"></p><br><p><img src="https://habrastorage.org/webt/yk/3j/jk/yk3jjkf9htxfmdvwsa1dyrogqqo.png"></p><br><p><img src="https://habrastorage.org/webt/ym/9d/vt/ym9dvt1_ykho82n4xhxwtlbkeow.png"></p><br><p>  Resulta que el problema est√° resuelto?  Pero no  (Est√° claro que si el problema se resolvi√≥ por completo en esta etapa, entonces <br>  este art√≠culo no hubiera sido :)) </p><br><h2 id="oshibka">  El error? </h2><br><p>  De esta forma, el algoritmo funcion√≥ durante bastante tiempo.  Todas las pruebas salieron bien.  Tampoco hubo problemas en la producci√≥n. </p><br><p>  Pero el desarrollador del algoritmo y su implementaci√≥n (mi colega Peter Reznikov) tiene mucha experiencia, e intuitivamente sinti√≥ que algo andaba mal aqu√≠.  Por lo tanto, se realiz√≥ un verificador junto al c√≥digo principal, que se verific√≥ de vez en cuando en un temporizador para ver si hab√≠a alg√∫n evento perdido, y <br>  si alguno, los proces√©. </p><br><p>  De esta forma, el sistema funcion√≥ con √©xito.  Es cierto que nadie mantuvo estad√≠sticas sobre el n√∫mero de eventos seleccionados por el verificador.  Entonces, desafortunadamente, no sabemos cu√°ntas fallas se asociaron con el procesamiento de eventos inoportunos. </p><br><p>  Implement√© una cola similar de objetos con l√≠mite de tiempo.  Al discutir la implementaci√≥n y optimizaci√≥n de algoritmos con Peter Reznikov, hablamos sobre este algoritmo para trabajar con eventos.  Dudaban de que el algoritmo sea correcto.  Decidimos hacer un modelo peque√±o para confirmar o disipar dudas.  Como resultado, encontramos un error. </p><br><h2 id="model-1">  Modelo </h2><br><p>  Antes de desarmar la traza con un error, dar√© el c√≥digo fuente del modelo en el que se detect√≥ el error. </p><br><p>  Las diferencias con el modelo anterior son muy peque√±as, solo hay un l√≠mite en el tama√±o de los bloques de lectura: se agrega el operador L√≠mite y, en consecuencia, se cambian los operadores de selecci√≥n de eventos. </p><br><p>  Para ahorrar espacio, dej√© comentarios solo en las partes modificadas del modelo. </p><br><pre> <code class="plaintext hljs">---------------- MODULE events ---------------- EXTENDS Naturals, FiniteSets, Sequences, TLC (* --algorithm Events \*    LIMIT, \*     \*     \*   variables Events = {}, Event_Id = 0, MAX_TIME = 5, LIMIT \in 1..3, TIME_DELTA \in 1..2 define ZERO_EVT == [time |-&gt; 0, id |-&gt; 0] MAX(S) == CHOOSE x \in S: \A y \in S: y &lt;= x MIN(S) == CHOOSE x \in S: \A y \in S: y &gt;= x RECURSIVE SetReduce(_, _, _) SetReduce(Op(_, _), S, value) == IF S = {} THEN value ELSE LET s == CHOOSE s \in S : TRUE IN SetReduce(Op, S \ {s}, Op(s, value)) ToSeq(S) == LET op(e, val) == Append(val, e) IN SetReduce(op, S, &lt;&lt; &gt;&gt;) ToSet(S) == {S[i] : i \in DOMAIN(S)} MapSet(Op(_), S) == {Op(x) : x \in S} GetIds(Evts) == MapSet(LAMBDA x: x.id, Evts) GetTimes(Evts) == MapSet(LAMBDA x: x.time, Evts) EventsOrderByTime(e1, e2) == e1.time &lt; e2.time EventsOrderById(e1, e2) == e1.id &lt; e2.id EventsOrder(e1, e2) == \/ EventsOrderByTime(e1, e2) \/ /\ e1.time = e2.time /\ EventsOrderById(e1, e2) Limit(S, limit) == LET amount == MIN({limit, Len(S)}) result == IF amount &gt; 0 THEN SubSeq(S, 1, amount) ELSE &lt;&lt; &gt;&gt; IN result \* SELECT * FROM events \* WHERE time &lt;= curr_time AND id &gt; max_id \* ORDER BY id \* LIMIT limit SELECT_HIGH_PRIO(state, limit) == LET selected == {e \in Events : /\ e.time &lt;= state.time /\ e.id &gt;= state.id } \*   Id sorted == SortSeq(ToSeq(selected), EventsOrderById) \*    limited == Limit(sorted, limit) IN ToSet(limited) \* SELECT * FROM events \* WHERE time &gt; current_time \* AND time - Time &lt;= delta_time \* ORDER BY time, id \* LIMIT limit SELECT_NORMAL(state, delta_time, limit) == LET selected == {e \in Events: /\ e.time &lt;= state.time + delta_time /\ e.time &gt; state.time } \*   sorted == SortSeq(ToSeq(selected), EventsOrder) \*   limited == Limit(sorted, limit) IN ToSet(limited) ALL_EVENTS_PROCESSED(state) == \A e \in Events: \/ e.time &gt;= state.time \/ e.id &gt;= state.id end define; fair process inserter = "Sources" variable t; begin forever: while TRUE do get_time: with evt_time \in 0..MAX_TIME do t := evt_time; end with; commit: either Events := Events \union {[time |-&gt; t, id |-&gt; Event_Id]} || Event_Id := Event_Id + 1; or Event_Id := Event_Id + 1; end either; end while; end process fair process event_processor = "Event_processor" variable state = ZERO_EVT, events = {}; begin forever: while TRUE do select: events := LET evts_high_prio == SELECT_HIGH_PRIO(state, LIMIT) new_limit == LIMIT - Cardinality(evts_high_prio) evts_normal == SELECT_NORMAL(state, TIME_DELTA, new_limit) IN evts_high_prio \union evts_normal; proc_evts: Events := Events \ events || state := [ time |-&gt; MAX({state.time} \union GetTimes(events)), id |-&gt; MAX({state.id} \union GetIds(events))] || events := {}; end while; end process end algorithm; *) \* BEGIN TRANSLATION \*  TLA+,     PlusCal  \* END TRANSLATION ===================================================</code> </pre> <br><p>  Un lector atento puede notar que, adem√°s de introducir Limit, las etiquetas en event_processor tambi√©n se han cambiado.  El objetivo es un poco mejor para simular el c√≥digo real que dos <em>selecciones</em> ejecutan en una transacci√≥n, es decir, se puede decir que la selecci√≥n de eventos se realiza at√≥micamente. </p><br><p>  Bueno, y si encontramos un error en un modelo con operaciones at√≥micas m√°s grandes, esto pr√°cticamente garantiza que el mismo error ocurra en el mismo modelo, pero con pasos at√≥micos m√°s peque√±os (una declaraci√≥n bastante fuerte, pero creo que es intuitivo; aunque deber√≠a ser bueno si no se prueba, luego se verifica en una amplia selecci√≥n de modelos). </p><br><h2 id="proverka-modeli-1">  Verificaci√≥n del modelo </h2><br><p>  Comenzamos la simulaci√≥n con los mismos par√°metros que en la primera realizaci√≥n. </p><br><p>  Y obtenemos una violaci√≥n de la propiedad ALL_EVENTS_PROCESSED en el paso 19 de la simulaci√≥n al buscar en ancho. </p><br><p>  Para los datos iniciales dados (este es un espacio de estado muy peque√±o), el error en el paso 19 indica que el error es muy raro y dif√≠cil de detectar, ya que antes se examinaron todas las cadenas de estado con una longitud de menos de 19. </p><br><p>  Por lo tanto, este error es dif√≠cil de detectar en las pruebas.  Solo si sabe d√≥nde buscar y espec√≠ficamente selecciona pruebas y caba√±as temporales. </p><br><p>  No traer√© toda la ruta por ahorrar espacio y tiempo.  Aqu√≠ hay un segmento de varios estados junto con un error: </p><br><p><img src="https://habrastorage.org/webt/1g/xq/en/1gxqen3cvdftawczsxb5apskzlc.png"></p><br><p><img src="https://habrastorage.org/webt/5r/b6/ml/5rb6mlga8u0rfalc1_3klnb6-ky.png"></p><br><p><img src="https://habrastorage.org/webt/5_/cz/n4/5_czn4pqrkbkhy6uocf3zllz39w.png"></p><br><p><img src="https://habrastorage.org/webt/_v/s8/d6/_vs8d6feegcimnw9bla8ylm-878.png"></p><br><p><img src="https://habrastorage.org/webt/wo/0j/qu/wo0jquth7jszanamlk7l3dpkspc.png"></p><br><h2 id="analiz-i-ispravlenie">  An√°lisis y correcci√≥n </h2><br><p>  Que paso </p><br><p>  Como puede ver, el error se manifest√≥ en el hecho de que perdimos el evento {2, 3} debido al hecho de que el l√≠mite termin√≥ en el evento {2, 1}, y despu√©s de eso cambiamos el estado del coordinador.  Esto puede suceder solo si en alg√∫n momento hay varios eventos. </p><br><p>  Es por eso que el error fue esquivo en las pruebas.  Para su manifestaci√≥n, es necesario que coincidan cosas bastante raras: </p><br><ol><li>  Varios eventos llegan al mismo punto en el tiempo. </li><li>  El l√≠mite en la selecci√≥n de eventos finaliz√≥ antes del momento de leer todos estos eventos. </li></ol><br><p>  El error se puede corregir con relativa facilidad si el estado del coordinador se expande un poco: agregue el tiempo y el identificador del √∫ltimo evento de lectura desde el √°rea de eventos normal con la identificaci√≥n m√°xima si el tiempo de este evento corresponde al siguiente valor de estado. </p><br><p>  Si no existe tal evento, establecemos el estado adicional (extra_state) en un estado no v√°lido (UNDEF_EVT) y no lo tenemos en cuenta al trabajar. </p><br><p>  Aquellos eventos de la regi√≥n normal que no se procesaron en el paso anterior del coordinador, consideraremos que ya son de alta prioridad y, en consecuencia, corregiremos la selecci√≥n de predicado de alta prioridad y seguridad. </p><br><p>  Ser√≠a posible introducir otra √°rea intermedia entre alta prioridad y normal, y cambiar el algoritmo.  Primero, procesar√° los de alta prioridad, luego los intermedios, y luego pasar√° a los normales con el posterior cambio de estado. </p><br><p>  Pero tales cambios conducir√≠an a un mayor volumen de refactorizaci√≥n con beneficios obvios (el algoritmo ser√° un poco m√°s claro; otras ventajas no son visibles de inmediato). </p><br><p>  Por lo tanto, decidimos ajustar solo ligeramente el estado actual y la selecci√≥n de eventos de la base de datos. </p><br><h2 id="skorrektirovannaya-model">  Modelo ajustado </h2><br><p>  Aqu√≠ est√° el modelo corregido. </p><br><pre> <code class="plaintext hljs">------------------- MODULE events ------------------- EXTENDS Naturals, FiniteSets, Sequences, TLC \*        CONSTANTS MAX_TIME, LIMIT, TIME_DELTA (* --algorithm Events variables Events = {}, Limit \in LIMIT, Delta \in TIME_DELTA, Event_Id = 0 define \*    \*  ,   extra_state UNDEF_EVT == [time |-&gt; MAX_TIME + 1, id |-&gt; 0] ZERO_EVT == [time |-&gt; 0, id |-&gt; 0] MAX(S) == CHOOSE x \in S: \A y \in S: y &lt;= x MIN(S) == CHOOSE x \in S: \A y \in S: y &gt;= x RECURSIVE SetReduce(_, _, _) SetReduce(Op(_, _), S, value) == IF S = {} THEN value ELSE LET s == CHOOSE s \in S : TRUE IN SetReduce(Op, S \ {s}, Op(s, value)) ToSeq(S) == LET op(e, val) == Append(val, e) IN SetReduce(op, S, &lt;&lt; &gt;&gt;) ToSet(S) == {S[i] : i \in DOMAIN(S)} MapSet(Op(_), S) == {Op(x) : x \in S} GetIds(Evts) == MapSet(LAMBDA x: x.id, Evts) GetTimes(Evts) == MapSet(LAMBDA x: x.time, Evts) EventsOrderByTime(e1, e2) == e1.time &lt; e2.time EventsOrderById(e1, e2) == e1.id &lt; e2.id EventsOrder(e1, e2) == \/ EventsOrderByTime(e1, e2) \/ /\ e1.time = e2.time /\ EventsOrderById(e1, e2) TakeN(S, limit) == LET amount == MIN({limit, Len(S)}) result == IF amount &gt; 0 THEN SubSeq(S, 1, amount) ELSE &lt;&lt; &gt;&gt; IN result (* SELECT * FROM events WHERE time &lt;= curr_time AND id &gt; max_id ORDER BY id Limit limit *) SELECT_HIGH_PRIO(state, limit, extra_state) == LET \*      \* time &lt;= curr_time \* AND id &gt; maxt_id selected == {e \in Events : \/ /\ e.time &lt;= state.time /\ e.id &gt;= state.id \/ /\ e.time = extra_state.time /\ e.id &gt; extra_state.id} sorted == \*  SortSeq(ToSeq(selected), EventsOrderById) limited == TakeN(sorted, limit) IN ToSet(limited) SELECT_NORMAL(state, delta_time, limit) == LET selected == {e \in Events : /\ e.time &lt;= state.time + delta_time /\ e.time &gt; state.time } sorted == SortSeq(ToSeq(selected), EventsOrder) limited == TakeN(sorted, limit) IN ToSet(limited) \*    extra_state UpdateExtraState(events, state, extra_state) == LET exact == {evt \in events : evt.time = state.time} IN IF exact # {} THEN CHOOSE evt \in exact : \A e \in exact: e.id &lt;= evt.id ELSE UNDEF_EVT \*    extra_state ALL_EVENTS_PROCESSED(state, extra_state) == \A e \in Events: \/ e.time &gt;= state.time \/ e.id &gt; state.id \/ /\ e.time = extra_state.time /\ e.id &gt; extra_state.id end define; fair process inserter = "Sources" variable t; begin forever: while TRUE do get_time: with evt_time \in 0..MAX_TIME do t := evt_time; end with; commit: either Events := Events \union {[time |-&gt; t, id |-&gt; Event_Id]} || Event_Id := Event_Id + 1; or Event_Id := Event_Id + 1; end either; end while; end process fair process event_processor = "Event_processor" variable events = {}, state = ZERO_EVT, extra_state = UNDEF_EVT; begin forever: while TRUE do select: events := LET evts_high_prio == SELECT_HIGH_PRIO(state, Limit, extra_state) new_limit == Limit - Cardinality(evts_high_prio) evts_normal == SELECT_NORMAL(state, Delta, new_limit) IN evts_high_prio \union evts_normal; proc_evts: Events := Events \ events || state := [ time |-&gt; MAX({state.time} \union GetTimes(events)), id |-&gt; MAX({state.id} \union GetIds(events)) ]; extra_state := UpdateExtraState(events, state, extra_state) || events := {}; end while; end process end algorithm; *) \* BEGIN TRANSLATION \*  TLA+,     PlusCal  \* END TRANSLATION ===================================================</code> </pre> <br><p>  Como puede ver, los cambios son muy peque√±os: </p><br><ol><li>  Se agregaron datos adicionales al estado extra_state. </li><li>  Cambi√≥ la selecci√≥n de eventos de alta prioridad. </li><li>   UpdateExtraState   extra_state. </li><li>  <em>safety</em> -    . </li></ol><br><h2 id="modelirovanie">  </h2><br><p>    ,   . ,      (,  ,    ,     ). <br>       ,       ,  TLA+/TLC .  :) </p><br><h1 id="zaklyuchenie">  Conclusi√≥n </h1><br><p>     , ,     ( , ,  ,    ). </p><br><p>  ,            ,        TLA+/TLC,     . ,    . </p><br><p>         TLA+/TLC  ,   ,           ( ,     )  . </p><br><p>  ,     ,     ,  TLA+/TLC                . </p><br><h1 id="bibliografiya">  </h1><br><h2 id="knigi">  Libros </h2><br><h3 id="dlya-pogruzheniya-v-oblast">     </h3><br><p>   ,    ,   ,    .      . </p><br><ol><li><p> Michael Jackson <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Problem Frames: Analysing &amp; Structuring Software Development Problems</a> </p><br><p>      (  !),     .   ,   .      ,        . </p><br></li><li><p> Hillel Wayne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Practical TLA+: Planning Driven Development</a> </p><br><p>     TLA+/PlusCal     .  ,    .      .         :    . </p><br></li><li><p>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MODEL CHECKING.      </a> </p><br><p>     .  ,    ,  .      ,            . </p><br></li><li><p> Leslie Lamport <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Specifying Systems: The TLA+ Language and Tools for Hardware and Software Engineers</a> </p><br><p>    TLA+.   ,   .      :     ,   .  ,     TLA+  ,    . </p><br></li></ol><br><h3 id="primery-iz-promyshlennosti">    </h3><br><ol><li><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Formal Development of a Network-Centric RTOS</a> </p><br><p>    TLA+          ( <em>RTOS</em> )       TLC. </p><br><p>      ,      .   ,   TLA+      ,             ,    <em>RTOS</em>   ‚Äî Virtuoso.       ,       . </p><br><p>          ,           (, ,  ,  ,    ). </p><br></li><li><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">w Amazon Web Services Uses Formal Methods</a> </p><br><p>   TLA+      AWS.        : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://lamport.azurewebsites.net/tla/amazon-excerpt.html</a> </p><br></li></ol><br><h2 id="internet">  </h2><br><h3 id="blogi">  </h3><br><ol><li><p> Hillel Wayne (  "Practical TLA+") <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> </p><br><p>     .  ,  .   ,  -   . </p><br></li><li><p> Ron Pressler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> </p><br><p>   .        .  ,      TLA+.       TLA+,    <em>computer</em> <em>science</em>    . </p><br></li><li><p> Leslie Lamport <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> </p><br><p>      TLA+  <em>computer</em> <em>science</em> .  <em>TLA+</em>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . </p><br></li></ol><br><h3 id="prezentacii-i-videokursy">    </h3><br><ol><li><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">. . , . . , . . .      </a> </p><br><p>  ,   ,       . </p><br></li><li><p>   TLA+,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> </p><br><p>   ,     TLA+. ,       TLA+. </p><br></li><li><p> Hillel Wayne </p><br><p>      Hillel Wayne  .      . </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">The Two Hardest Problems in CS (June 5, 2018)</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Everything about distributed systems is terrible | Code Mesh LDN 18</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Designing Distributed Systems with TLA+ | √òredev 2018</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tackling Concurrency Bugs with TLA+</a> </li></ul><br></li><li><p> Ron Pressler </p><br><p>  ,   Hillel Wayne,     .  ,    . Ron Pressler      . ÃÅ       ,    ,     . </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">The Practice and Theory of TLA+</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Why Writing Correct Software Is Hard and Why Math (Alone) Won't Help Us</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">On the Nature of Abstraction</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Finite of sense &amp; infinite of thought | Code Mesh LDN 18</a> </li></ul><br></li></ol><br><h3 id="modelirovanie-1">  </h3><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TLA toolbox</a> + <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TLAPS</a> :        TLA+  <br>           .          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Alloy Analyzer</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/471012/">https://habr.com/ru/post/471012/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../471000/index.html">Juguetes de madera, la √∫ltima parte - 1997</a></li>
<li><a href="../471004/index.html">Juguetes de madera: un ep√≠logo que permanece clavado en el techo</a></li>
<li><a href="../471006/index.html">$ 500 por mes: ¬øen qu√© gastan su dinero los receptores de ingresos b√°sicos incondicionales?</a></li>
<li><a href="../471008/index.html">Hablemos de monitoreo: grabaci√≥n en vivo del podcast Devops Deflope con New Relic en la reuni√≥n del 23 de octubre</a></li>
<li><a href="../471010/index.html">Algoritmo de Grover y b√∫squeda de datos</a></li>
<li><a href="../471014/index.html">Estamos haciendo un dron de agua aut√≥nomo, o como so√±√© con ayudar a Baikal, pero no soy un Gazprom. Parte 1</a></li>
<li><a href="../471016/index.html">Dise√±o de bases de datos. Mejores pr√°cticas</a></li>
<li><a href="../471018/index.html">Comparaci√≥n del rendimiento de la PC y el tel√©fono inteligente, incluido el iPhone 11</a></li>
<li><a href="../471020/index.html">C√≥mo encontrar un error en un microprocesador lanzado hace treinta y cinco a√±os</a></li>
<li><a href="../471022/index.html">Revelando un secreto de 140 a√±os en f√≠sica</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>