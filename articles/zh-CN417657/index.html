<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚂 ⛈️ 🚔 基于递归神经网络创建一个机器人参加AI mini Cup 2018（第2部分） 🔈 🕌 🎀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="这是本文第一部分的继续。 


在本文的第一部分中，作者在mail.ru上谈到了针对Agario游戏的竞赛条件，游戏世界的结构以及机器人的结构。 部分是因为它们仅影响神经网络输出处的输入传感器和命令的设备（以下在图片和文字中将使用缩写NN）。 因此，让我们尝试打开黑匣子，了解其中的所有内容。 


...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>基于递归神经网络创建一个机器人参加AI mini Cup 2018（第2部分）</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417657/"><p><img src="https://habrastorage.org/webt/of/tw/ke/oftwke-wbh5-w_nlsm_p5rmhano.jpeg"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这是本文第一部分的继续。</a> </p><br><p>在本文的第一部分中，作者在mail.ru上谈到了针对Agario游戏的竞赛条件，游戏世界的结构以及机器人的结构。 部分是因为它们仅影响神经网络输出处的输入传感器和命令的设备（以下在图片和文字中将使用缩写NN）。 因此，让我们尝试打开黑匣子，了解其中的所有内容。 </p><a name="habracut"></a><br><p> 这是第一张图片： </p><br><p><img src="https://habrastorage.org/webt/v2/pb/_s/v2pb_sha05gqjtqcqp9bv5mnm0o.jpeg"></p><br><p> 他们示意性地描绘了什么会引起我的读者无聊的笑容，他们又在一年级时再次说过，他们在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">各种资料来源中</a>都多次出现。 但是，我们实际上确实希望将此图片应用到bot的管理中，因此在重要说明之后，我们将对其进行仔细研究。 </p><br><p>  <strong>重要说明：</strong>有大量现成的用于神经网络的解决方案（框架）： </p><br><p><img src="https://habrastorage.org/webt/jt/il/97/jtil97rhtusvazj6iared1q_hnc.png"></p><br><p> 所有这些软件包解决了神经网络开发人员的主要任务：NN的构建和训练或“最佳”权重的搜索。 这种搜索的主要方法是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">反向传播</a> 。 如上链接文章所述，它是上世纪70年代发明的，在此期间，它作为船的底部，已经获得了各种改进，但本质是相同的：以训练示例为基础找到重量系数，每个人都非常希望这些示例中有一个以神经网络的输出信号形式存在的现成答案。 读者可以反对我。 据我所知，已经发明了各种类别和原理的自学网络，但是那里的一切进展都不顺利。 当然，有计划更详细地研究这个动物园，但是我想我会发现志同道合的人发现，即使是最弯曲的DIY制成的自行车，也比理想自行车的传送带复制品更靠近创作者的心脏。 <br> 作者意识到游戏服务器很可能不会拥有这些库，并且组织者将其分配为1个处理器核心的计算能力显然不足以使用沉重的框架，因此作者继续创建了自己的自行车。 关于这一点的重要评论结束了。 </p><br><p> 让我们回到图片，它描述了可能的最简单的具有隐藏层（又名隐藏层或隐藏层）的神经网络。 现在，作者本人一直用这个简单示例的思想稳定地注视着图片，向读者揭示了人工神经网络的深度。 当一切都简化为原始元素时，更容易理解其本质。 底线是隐藏层神经元没有什么可概括的。 而且很可能这甚至不是神经网络，在教科书中，最简单的NN是具有两个输入的网络。 因此，我们就像是最简单的网络中最简单的发现者。 </p><br><p> 让我们尝试描述这个神经网络（伪代码）： <br> 我们以阵列的形式介绍网络拓扑，其中每个元素对应于该层及其中神经元的数量： </p><br><p><code>int array Topology= { 1, 1, 1}</code> <br> 我们还需要神经网络W的权重的浮点数组，考虑到我们的网络是“前馈神经网络（FF或FFNN）”，其中当前层的每个神经元都连接到下一层的每个神经元，我们得到数组W的维数[层数，层中神经元的数量，层中神经元的数量]。 并不是最理想的编码，但是考虑到GPU在文本中非常接近的地方，这是可以理解的。 <br> 我想通过一个简短的<code>CalculateSize</code>过程来计算神经元计数神经元的数量及其在<code>dendritecount</code>神经网络中的连接数，我认为这将更好地向作者解释这些连接的性质： </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> CalculateSize(<span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> Topology, <span class="hljs-type"><span class="hljs-type">int</span></span> neuroncount, <span class="hljs-type"><span class="hljs-type">int</span></span> dendritecount) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i : Topology) // i         neuroncount += i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> layer = <span class="hljs-number"><span class="hljs-number">0</span></span>, layer &lt;Topology.Length - <span class="hljs-number"><span class="hljs-number">1</span></span>, layer++) //   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, i &lt; Topology[layer] + <span class="hljs-number"><span class="hljs-number">1</span></span>, i++) //   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>, j &lt; Topology[layer + <span class="hljs-number"><span class="hljs-number">1</span></span>], j++) //   dendritecount++; }</code> </pre> <br><p> 我的读者，已经很了解这一切的作者，在第一篇文章中提出了这一观点，当然不会问：为什么在第三嵌套循环拓扑[layer1 + 1]而不是拓扑[layer1]中，它给神经元带来的好处多于网络拓扑中的作用。 我不会回答。 对于读者要求功课也很有用。 </p><br><p> 我们距离构建有效的神经网络仅一步之遥。 仍然需要增加对神经元输入及其激活的信号求和的功能。 激活函数有很多，但是最接近神经元性质的激活函数是Sigmoid和Tangensoid <em>（最好将其称为，尽管在文献中未使用此名称，但最大值是切线的，但这是图形的名称，尽管如果图形不是函数的反映又是什么图形？）</em> </p><br><p> 因此，这里我们具有神经元激活功能（它们存在于图片的下部） </p><br><pre> <code class="hljs go">float Sigmoid(float x) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">-10.0f</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">10.0f</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (float)(<span class="hljs-number"><span class="hljs-number">1.0f</span></span> / (<span class="hljs-number"><span class="hljs-number">1.0f</span></span> + expf(-x))); }</code> </pre> <br><p>  Sigmoid返回值从0到1。 </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Tanh</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">-10.0f</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">10.0f</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(tanhf(x)); }</code> </pre> <br><p> 切线返回值从-1到1。 </p><br><p> 信号通过神经网络的主要思想是波：信号被馈送到输入神经元-&gt;通过神经连接，信号进入第二层-&gt;第二层的神经元总结通过神经元权重改变了到达它们的信号-&gt;通过附加偏置权重添加-&gt;我们使用激活函数-&gt;和wu-al进入下一层（逐层读取示例中的第一个循环），也就是说，从一开始就重复该链，只有下一层的神经元才会成为输入神经元。 为简化起见，您甚至不需要存储整个网络的神经元值，只需要存储NN权重和活动层神经元的值即可。 </p><br><p> 再次，我们将信号发送到输入NN，该波穿过各层，在输出层上，我们除去获得的值。 </p><br><p> 在这里，根据读者的口味，可以使用递归或像作者一样的三重循环以编程方式解决问题，从而加快计算速度，而无需围住神经元及其连接和其他OOP形式的对象。 同样，这是由于GPU运算紧密的感觉，在GPU上，由于其大规模并行性，OOP有点停顿了，这与c＃和C ++有关。 </p><br><p> 此外，还邀请读者自愿地独立地使用代码来构建神经网络，对于作者来说，缺少它是非常清楚和熟悉的， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">例如，</a>从头开始<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">构建NN</a>的示例中，网络中有很多示例，因此很难误入歧途，就像那样就像上图中的直接分布神经网络一样简单。 </p><br><p> 但是，尚未离开上一段落的读者会惊叹于何处，并且是正确的。在童年时期，作者通过插图确定了这本书的价值。 您在这里： </p><br><p><img src="https://habrastorage.org/webt/03/jl/dw/03jldwzryoeaxscxxtfi3deakie.jpeg"></p><br><p> 在图片中，我们看到了递归神经元，由这种神经元构建的NN被称为递归神经元或RNN。 指定的神经网络具有短期记忆，并被作者选择为机器人，以适应游戏过程。 当然，作者建立了直接分布神经网络，但是在寻找“有效”解决方案的过程中，他切换到了RNN。 </p><br><p> 循环神经元具有附加状态C，该状态在信号第一次通过时间轴上的神经元Tick + 0传递之后形成。 简单来说，这是神经元输出信号的副本。 在第二步中，读取Tick +1（因为网络以游戏机器人和服务器的频率运行），值C通过附加权重返回到神经层的输入，因此参与了信号的形成，但已经达到Tick +1倍了。 </p><br><p>  <em>注意： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在有关NN游戏机器人管理的研究小组的工作中</a> ，倾向于将两个节奏用于神经网络，一个节奏是游戏Tick的频率，例如第二个节奏的速度是第一个节奏的两倍。</em>  <em>NN的不同部分以不同的频率运行，从而使人对NN内部的游戏情况有不同的认识，从而提高了灵活性。</em> </p><br><p> 为了在bot代码中构建RNN，我们在拓扑中引入了一个额外的数组，其中每个元素对应于该层以及其中的神经状态数： </p><br><p> <code>int array TopologyNN= { numberofSensors, 16, 8, 4}</code> <br> <code>int array TopologyRNN= { 0, 16, 0, 0 }</code> </p> <br><p> 从上面的拓扑可以看出，第二层是循环的，因为它包含神经状态。 我们还以WRR数组的浮点形式（与W数组尺寸相同）引入其他权重。 </p><br><p> 我们的神经网络中的连接数将有所变化： </p><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int layer = <span class="hljs-number"><span class="hljs-number">0</span></span>, layer &lt; TopologyNN.Length - <span class="hljs-number"><span class="hljs-number">1</span></span>, layer++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; TopologyNN[layer] + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> &lt; TopologyNN[layer + <span class="hljs-number"><span class="hljs-number">1</span></span>] , <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>++) dendritecount++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int layer = <span class="hljs-number"><span class="hljs-number">0</span></span>, layer &lt; TopologyRNN.Length - <span class="hljs-number"><span class="hljs-number">1</span></span>, layer++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>&lt; TopologyRNN[layer] + <span class="hljs-number"><span class="hljs-number">1</span></span> , <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>&lt; TopologyRNN[layer], <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>++) dendritecount++;</code> </pre> <br><p> 作者将在本文的结尾处附加一个递归神经网络的通用代码，但要理解的主要原理是：在递归NN的情况下，波穿过层的传递不会从根本上改变任何东西，仅向神经元激活函数添加一个术语。 这是前一个Tick上的神经元状态乘以神经连接权重的术语。 </p><br><p> 我们假设神经网络的理论和实践已经更新，但是作者清楚地意识到，他并没有使读者更进一步地了解如何教授这种简单的神经网络结构以在游戏中做出任何决定。 我们没有包含用于教授NN的示例的库。 在由机器人开发人员组成的Internet小组中，有一种意见：以机器人坐标和其他游戏信息的形式给我们提供一个日志文件，以构成示例库。 但是，不幸的是，作者无法弄清楚如何使用此日志文件来训练NN。 我将很高兴在文章的评论中对此进行讨论。 因此，作者可以用来理解训练方法或找到“有效”神经平衡（神经连接）的唯一方法是遗传算法。 </p><br><p> 准备了有关遗传算法原理的图片： </p><br><p><img src="https://habrastorage.org/webt/-3/ex/ls/-3exlspxldh64avmkbi_3vuewou.jpeg"></p><br><p> 于是<strong>遗传算法</strong> 。 </p><br><p> 作者将尝试不深入研究<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此过程的理论</a> ，而只回忆起继续完整阅读本文所必需的最低要求。 <br> 在遗传算法中，主要工作流体是基因（DNA是分子的名称）。 在我们的案例中，基因组是一组连续的基因或一维浮点长序列。 </p><br><p> 在使用新建的神经网络的初始阶段，有必要对其进行初始化。 初始化是指将-1到1的随机值分配给神经平衡，作者遇到提到-1到1的值范围太<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">极端</a> ，训练网络的权重范围较小，例如，从-0.5到0.5，应该将初始值范围设置为优秀从-1到1。但是我们将采用经典的方法来收集所有困难，并以尽可能大的初始随机变量段作为初始化神经网络的基础。 </p><br><p> 现在将出现<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">双射</a> 。 我们将假设bot基因组的长度（大小）等于神经网络TopologyNN.Length + TopologyRNN.Length的总长度，这并非是作者花了很多时间在计算神经连接的过程上。 </p><br><p>  <em>注意：正如读者已经为他自己指出的那样，我们仅将神经网络的权重传递给基因型，连接结构，激活功能和神经元状态不会被传递。</em>  <em>对于遗传算法，仅神经连接就足够了，这表明它们是信息的载体。</em>  <em>在某些情况下，遗传算法还会改变神经网络中连接的结构，并且实现起来非常简单。</em>  <em>在这里，作者为读者留下了创造力的空间，尽管他本人会很感兴趣地思考它：您需要了解使用两个独立的基因组和两个适应度函数（简化的两个独立的遗传算法），或者都可以使用相同的基因和算法。</em> </p><br><p> 并且由于我们使用随机变量初始化了NN，因此我们也初始化了基因组。 逆过程也是可能的：通过随机变量初始化基因型，然后将其复制到神经权重中。 第二种选择很常见。 由于程序中的遗传算法通常存在于本质本身之外，并且仅与基因组数据和适应度函数的值相关联...停止，停止，读者会说，图片清楚地显示了种群而不是单个基因组的单词。 </p><br><p> 好的，将一些图片添加到读者的头脑炉中： </p><br><p><img src="https://habrastorage.org/webt/h5/dz/ho/h5dzhojhlf6b1xqsol30qo63mdo.jpeg"></p><br><p> 由于作者在写文章文字之前画了这些图片，因此它们支持文字，但不跟着当前故事的字母开头。 </p><br><p> 从所获信息中可以得出，遗传算法的主要工作主体是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">基因组</a> 。 这与作者先前所说的有些相反，但是在现实世界中如何做到没有小矛盾。 昨天，太阳绕着地球旋转，今天，作者讨论了该软件bot内部的神经网络。 难怪他还记得理性的烤箱。 <br> 我相信读者本人可以解决世界矛盾的问题。 机器人世界完全是本文的自给自足。 </p><br><p> 但是对于本文的这一部分，作者已经设法做到的是形成大量的机器人。 <br> 让我们从软件方面看一下： </p><br><p> 有一个Bot（它可以是OOP中的一个对象，也可以是一个结构，尽管它也可能是对象或只是数据数组）。 在内部，Bot包含有关其坐标，速度，质量的信息以及在游戏过程中有用的其他信息，但是对我们而言，现在最主要的是，它包含指向其基因型或基因型本身的链接，具体取决于实现方式。 然后，您可以采取不同的方式，将自己限制在神经网络权重数组中，或者引入其他基因型数组，因为这将方便读者在他们的想象中进行想象。 在第一阶段，作者在程序中分配了神经平衡和基因型阵列。 然后，他拒绝重复信息，并将自己局限于神经网络的权重。 </p><br><p> 按照故事的逻辑，您需要告诉机器人的数量是上述机器人的一个数组。 什么游戏循环...再次停止，什么游戏循环？ 开发人员有礼貌地为服务器上的游戏世界模拟程序中的一个Bot或一个本地模拟器中的最多四个bot提供了一个位置。 如果您还记得作者选择的神经网络的拓扑： </p><br><p><img src="https://habrastorage.org/webt/vh/1d/xq/vh1dxqmwqoejzszyh3zpfyykve4.jpeg"></p><br><p> 为了简化故事，假设该基因型包含大约1000个神经连接，顺便说一下，在模拟器中，基因型如下所示（红色是负基因值，绿色是正值，每行是一个单独的基因组）： </p><br><p><img src="https://habrastorage.org/webt/ri/h0/s-/rih0s-ss3gaflldpts95rm9yo4u.jpeg"></p><br><p>  <em>照片上的注释：随着时间的流逝，模式在解决方案之一的主导方向上发生变化，垂直条纹是常见的基因型基因。</em> </p><br><p> 因此，我们从比赛的组织者那里获得了1000个基因型基因，并且在游戏世界模拟器程序中最多有四个机器人。 您需要模拟几次机器人大战，以便即使是最聪明的人也可以通过蛮力接近“有效” <br> 基因型，请阅读神经连接的“有效”组合，条件是每个神经连接的步长在-1到1之间变化，哪一步呢？ 初始化是随机浮动，它是15个小数位。 我们尚不清楚这一步骤。 关于神经权重组合的变体数，作者假设这是一个无限数，当选择某个步长时，可能是一个有限数，但是无论如何，即使考虑从机器人队列中依次启动加上官方模拟器的同时并行启动，这些数字在模拟器中的位置也要多于4个。在一台计算机上（对于老式编程的爱好者：计算机）。 </p><br><p><img src="https://habrastorage.org/webt/it/-8/if/it-8ifszotccnx4wguexdtditpm.jpeg"></p><br><p> 希望这些图片对读者有所帮助。 </p><br><p> 在这里您需要暂停讨论软件解决方案的体系结构。 由于以单独的软件bot形式上传到比赛站点的解决方案不再适用。 必须在组织者生态系统和试图为他找到神经网络配置的程序的框架内，根据比赛规则将机器人程序分开。 下图取自会议的演示文稿，但通常反映了真实情况。 </p><br><p><img src="https://habrastorage.org/webt/-i/hb/ph/-ihbph2b0hlv3lfzxze7ihmu3-q.jpeg"></p><br><p> 他回想起一个胡闹的笑话： </p><br><p>  <em>大型组织。</em> <em><br></em>  <em>时间18.00，所有员工合为一体。</em>  <em>突然，一名员工关闭计算机，穿好衣服离开。</em> <em><br></em>  <em>每个人都惊讶地看着他。</em> <em><br></em>  <em>第二天</em>  <em>同一员工在18.00关闭计算机并离开。</em>  <em>每个人都继续工作，并开始不高兴地窃窃私语。</em> <em><br></em>  <em>第二天。</em>  <em>同一位员工在18.00关闭计算机...</em> <em><br></em>  <em>一位同事接近他：</em> <em><br></em>  <em>-由于您不感到羞耻，我们正在工作，本季度末，有许多报告，我们也希望准时回家，您真是个好人...</em> <em><br></em>  <em>-伙计们，我通常在度假！</em> </p><br><p>  ...待续。 </p><br><p> 是的，我几乎忘记附加RNN计算过程代码，它是有效的并且独立编写，因此可能其中有错误。 为了进行放大，我将按原样使用它，它是用c ++应用于CUDA（用于在GPU上进行计算的库）的。 </p><br><p> 注意：多维数组在GPU上不能很好地相处，当然会有纹理和矩阵计算，但是它们建议使用一维数组。 </p><br><p> 例如，尺寸为M乘以j的数组[i，j]会变成[i * M + j]形式的数组。 </p><br><div class="spoiler">  <b class="spoiler_title">RNN计算程序的源代码</b> <div class="spoiler_text"><pre> <code class="hljs powershell">__global__ void cudaRNN(Bot *bot, argumentsRNN *RNN, ConstantStruct *Const, int *Topology, int *TopologyRNN, int numElements, int gameTick) { int tid = blockIdx.x * blockDim.x + threadIdx.x; int threadN = gridDim.x * blockDim.x; int TopologySize = Const-&gt;TopologySize; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int pos = tid; pos &lt; numElements; pos += threadN) { const int ii = pos; const int iiA = pos*Const-&gt;ArrayDim; int ArrayDim = Const-&gt;ArrayDim; const int iiAT = ii*TopologySize*ArrayDim; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bot[<span class="hljs-type"><span class="hljs-type">pos</span></span>].TTF != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; bot[<span class="hljs-type"><span class="hljs-type">pos</span></span>].Mass&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>) { RNN-&gt;outputs[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">Topology</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]] = <span class="hljs-number"><span class="hljs-number">1</span></span>.f; //bias int neuroncount7 = Topology[<span class="hljs-number"><span class="hljs-number">0</span></span>]; neuroncount7++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int layer1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; layer1 &lt; TopologySize - <span class="hljs-number"><span class="hljs-number">1</span></span>; layer1++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int j4 = <span class="hljs-number"><span class="hljs-number">0</span></span>; j4 &lt; Topology[<span class="hljs-type"><span class="hljs-type">layer1</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>]; j4++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i5 = <span class="hljs-number"><span class="hljs-number">0</span></span>; i5 &lt; Topology[<span class="hljs-type"><span class="hljs-type">layer1</span></span>] + <span class="hljs-number"><span class="hljs-number">1</span></span>; i5++) { RNN-&gt;sums[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">j4</span></span>] = RNN-&gt;sums[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">j4</span></span>] + RNN-&gt;outputs[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">i5</span></span>] * RNN-&gt;NNweights[((<span class="hljs-type"><span class="hljs-type">ii</span></span>*<span class="hljs-type"><span class="hljs-type">TopologySize</span></span> + <span class="hljs-type"><span class="hljs-type">layer1</span></span>)*<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span><span class="hljs-type"><span class="hljs-type">Dim</span></span> + <span class="hljs-type"><span class="hljs-type">i5</span></span>)*<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span><span class="hljs-type"><span class="hljs-type">Dim</span></span> + <span class="hljs-type"><span class="hljs-type">j4</span></span>]; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TopologyRNN[<span class="hljs-type"><span class="hljs-type">layer1</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int j14 = <span class="hljs-number"><span class="hljs-number">0</span></span>; j14 &lt; Topology[<span class="hljs-type"><span class="hljs-type">layer1</span></span>]; j14++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i15 = <span class="hljs-number"><span class="hljs-number">0</span></span>; i15 &lt; Topology[<span class="hljs-type"><span class="hljs-type">layer1</span></span>]; i15++) { RNN-&gt;sumsContext[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">j14</span></span>] = RNN-&gt;sumsContext[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">j14</span></span>] + RNN-&gt;neuronContext[<span class="hljs-type"><span class="hljs-type">iiAT</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span><span class="hljs-type"><span class="hljs-type">Dim</span></span> * <span class="hljs-type"><span class="hljs-type">layer1</span></span> + <span class="hljs-type"><span class="hljs-type">i15</span></span>] * RNN-&gt;MNweights[((<span class="hljs-type"><span class="hljs-type">ii</span></span>*<span class="hljs-type"><span class="hljs-type">TopologySize</span></span> + <span class="hljs-type"><span class="hljs-type">layer1</span></span>)*<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span><span class="hljs-type"><span class="hljs-type">Dim</span></span> + <span class="hljs-type"><span class="hljs-type">i15</span></span>)*<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span><span class="hljs-type"><span class="hljs-type">Dim</span></span> + <span class="hljs-type"><span class="hljs-type">j14</span></span>]; } RNN-&gt;sumsContext[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">j14</span></span>] = RNN-&gt;sumsContext[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">j14</span></span>] + <span class="hljs-number"><span class="hljs-number">1.0</span></span>f* RNN-&gt;MNweights[((<span class="hljs-type"><span class="hljs-type">ii</span></span>*<span class="hljs-type"><span class="hljs-type">TopologySize</span></span> + <span class="hljs-type"><span class="hljs-type">layer1</span></span>)*<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span><span class="hljs-type"><span class="hljs-type">Dim</span></span> + <span class="hljs-type"><span class="hljs-type">Topology</span></span>[<span class="hljs-type"><span class="hljs-type">layer1</span></span>])*<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span><span class="hljs-type"><span class="hljs-type">Dim</span></span> + <span class="hljs-type"><span class="hljs-type">j14</span></span>]; //bias=<span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int t = <span class="hljs-number"><span class="hljs-number">0</span></span>; t &lt; Topology[<span class="hljs-type"><span class="hljs-type">layer1</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>]; t++) { RNN-&gt;outputs[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">t</span></span>] = Tanh(RNN-&gt;sums[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">t</span></span>] + RNN-&gt;sumsContext[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">t</span></span>]); RNN-&gt;neuronContext[<span class="hljs-type"><span class="hljs-type">iiAT</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span><span class="hljs-type"><span class="hljs-type">Dim</span></span> * <span class="hljs-type"><span class="hljs-type">layer1</span></span> + <span class="hljs-type"><span class="hljs-type">t</span></span>] = RNN-&gt;outputs[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">t</span></span>]; } //SoftMax /* double sum = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt;ArrayDim; ++k) sum += exp(RNN-&gt;outputs[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">k</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; ArrayDim; ++k) RNN-&gt;outputs[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">k</span></span>] = exp(RNN-&gt;outputs[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">k</span></span>]) / sum; */ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; i1 &lt; Topology[<span class="hljs-type"><span class="hljs-type">layer1</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>]; i1++) { RNN-&gt;outputs[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">i1</span></span>] = Sigmoid(RNN-&gt;sums[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">i1</span></span>]); //sigma } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (layer1 + <span class="hljs-number"><span class="hljs-number">1</span></span> != TopologySize - <span class="hljs-number"><span class="hljs-number">1</span></span>) { RNN-&gt;outputs[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">Topology</span></span>[<span class="hljs-type"><span class="hljs-type">layer1</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>]] = <span class="hljs-number"><span class="hljs-number">1</span></span>.f; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; i2 &lt; ArrayDim; i2++) { RNN-&gt;sums[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">i2</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>.f; RNN-&gt;sumsContext[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">i2</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>.f; } } } } }</code> </pre> </div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN417657/">https://habr.com/ru/post/zh-CN417657/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN417647/index.html">白俄罗斯提出的一项有关保护个人数据的法案-其内幕是什么</a></li>
<li><a href="../zh-CN417649/index.html">OpenAI克服了Dota 2的重要AI限制</a></li>
<li><a href="../zh-CN417651/index.html">读者应该怎么做才能使您阅读更多？</a></li>
<li><a href="../zh-CN417653/index.html">公开课“数据库的基本概念”</a></li>
<li><a href="../zh-CN417655/index.html">背景：Roscosmos State Corporation及其工作</a></li>
<li><a href="../zh-CN417659/index.html">Neuropoet和其他未来的流行歌星</a></li>
<li><a href="../zh-CN417661/index.html">奥布里·德·格雷访问乔·罗根</a></li>
<li><a href="../zh-CN417665/index.html">英语语法作为数学。 那些没有锻炼的人从哪里开始</a></li>
<li><a href="../zh-CN417667/index.html">AI。 战术屏障追踪器</a></li>
<li><a href="../zh-CN417671/index.html">SAP网络研讨会中的ABAP编程语言的新功能</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>