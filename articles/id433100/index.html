<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤛🏼 👻 ☹️ Bekerja dengan database dari suatu aplikasi 🐛 👨🏻‍🚒 🤚🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada awalnya saya akan menguraikan beberapa masalah dan fitur ketika bekerja dengan database, saya akan menunjukkan lubang pada abstraksi. Selanjutnya...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bekerja dengan database dari suatu aplikasi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433100/"><p>  Pada awalnya saya akan menguraikan beberapa masalah dan fitur ketika bekerja dengan database, saya akan menunjukkan lubang pada abstraksi.  Selanjutnya, kami akan menganalisis abstraksi yang lebih sederhana berdasarkan kekebalan. </p><br><p>  Diasumsikan bahwa pembaca agak akrab dengan pola <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rekaman Aktif</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemeta Data</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Peta Identitas,</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Unit Kerja</a> . </p><br><p>  Masalah dan solusi dipertimbangkan dalam konteks proyek yang cukup besar yang tidak dapat dibuang dan dengan cepat ditulis ulang. </p><a name="habracut"></a><br><h2 id="identity-map">  Peta identitas </h2><br><p>  Masalah pertama adalah masalah mempertahankan identitas.  Identitas adalah sesuatu yang secara unik mengidentifikasi entitas.  Dalam database, ini adalah kunci utama, dan di memori, tautan (penunjuk).  Ini bagus ketika tautan hanya menunjuk ke satu objek. </p><br><p>  Untuk pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ActiveRecord</a> ruby, ini tidak begitu: </p><br><pre><code class="ruby hljs">post_a = Post.find <span class="hljs-number"><span class="hljs-number">1</span></span> post_b = Post.find <span class="hljs-number"><span class="hljs-number">1</span></span> post_a.object_id != post_b.object_id <span class="hljs-comment"><span class="hljs-comment"># true post_a.title = "foo" post_b.title != "foo" # true</span></span></code> </pre> <br><p>  Yaitu  kita mendapatkan 2 referensi ke 2 objek berbeda dalam memori. </p><br><p>  Dengan demikian, kita bisa kehilangan perubahan jika kita secara tidak sengaja mulai bekerja dengan entitas yang sama, tetapi diwakili oleh objek yang berbeda. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hibernate</a> memiliki sesi, sebenarnya cache tingkat pertama yang menyimpan pemetaan pengenal entitas ke objek di memori.  Jika kami meminta kembali entitas yang sama, kami akan mendapatkan tautan ke objek yang ada.  Yaitu  Hibernate mengimplementasikan pola <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Peta Identitas</a> . </p><br><h2 id="dolgie-tranzakcii">  Transaksi panjang </h2><br><p>  Tetapi bagaimana jika kita tidak memilih dengan pengidentifikasi?  Untuk mencegah keadaan objek dan keadaan database tidak sinkron, Hibernasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">siram</a> sebelum meminta pilihan. <br>  yaitu  dump objek kotor dalam database sehingga permintaan membaca data yang disepakati. </p><br><p>  Pendekatan ini memaksa Anda untuk menjaga transaksi basis data tetap terbuka saat transaksi bisnis sedang berlangsung. <br>  Jika transaksi bisnis panjang, maka proses yang bertanggung jawab untuk koneksi dalam database itu sendiri juga tidak aktif.  Misalnya, ini dapat terjadi jika transaksi bisnis meminta data melalui jaringan atau melakukan perhitungan yang rumit. </p><br><h2 id="n1">  N +1 </h2><br><p>  Mungkin "lubang" terbesar dalam abstraksi ORM adalah masalah kueri N +1. </p><br><p>  Contoh ruby ​​untuk pustaka ActiveRecord: </p><br><pre> <code class="ruby hljs">posts = Post.all <span class="hljs-comment"><span class="hljs-comment"># select * from posts posts.each do |post| like = post.likes.order(id: :desc).first # SELECT * FROM likes WHERE post_id = ? ORDER BY id DESC LIMIT 1 # ... end</span></span></code> </pre> <br><p>  ORM menuntun programmer pada gagasan bahwa ia hanya bekerja dengan objek dalam memori.  Tetapi bekerja dengan layanan yang tersedia melalui jaringan, dan pada pembentukan koneksi dan transfer data <br>  itu butuh waktu.  Bahkan jika permintaan dieksekusi 50 ms, maka 20 permintaan akan dieksekusi selama satu detik. </p><br><h2 id="dopolnitelnye-dannye">  Data tambahan </h2><br><p>  Katakan untuk menghindari masalah N +1 yang dijelaskan di atas, Anda menulisnya <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">permintaan</a> : </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> posts <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> LATERAL ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> likes <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> post_id = posts.id <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> likes.id <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> last_like <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre> <br><p>  Yaitu  selain atribut posting, semua atribut seperti yang terakhir juga dipilih.  Entitas apa yang dipetakan data ini?  Dalam hal ini, Anda dapat mengembalikan pasangan dari pos dan suka, karena  hasilnya berisi semua atribut yang diperlukan. </p><br><p>  Tetapi bagaimana jika kita memilih hanya bagian dari bidang, atau bidang yang dipilih yang tidak ada dalam model, misalnya, jumlah suka publikasi?  Apakah mereka perlu dipetakan ke entitas?  Mungkin meninggalkan mereka hanya data? </p><br><h2 id="state--identity">  Status &amp; identitas </h2><br><p>  Pertimbangkan kode js: </p><br><pre> <code class="plaintext hljs">const alice = { id: 0, name: 'Alice' };</code> </pre> <br><p>  Di sini, referensi objek diberi nama <code>alice</code> .  Karena  itu adalah sebuah konstanta, maka tidak ada cara untuk memanggil Alice objek lain.  Pada saat yang sama, objek itu sendiri tetap bisa berubah. </p><br><p>  Misalnya, kami dapat menetapkan pengidentifikasi yang ada: </p><br><pre> <code class="plaintext hljs">const bob = { id: 1, name: 'Bob' }; alice.id = bob.id;</code> </pre> <br><p>  Biarkan saya mengingatkan Anda bahwa suatu entitas memiliki 2 identitas: tautan dan kunci utama dalam database.  Dan konstanta tidak bisa berhenti membuat Alice Bob, bahkan setelah menabung. </p><br><p>  Objek, tautan yang kami sebut <code>alice</code> , melakukan 2 tugas: secara simultan memodelkan identitas dan status.  Status adalah nilai yang menggambarkan entitas pada titik waktu tertentu. </p><br><p>  Tetapi bagaimana jika kita memisahkan 2 tanggung jawab ini dan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">struktur abadi</a> untuk negara? </p><br><pre> <code class="plaintext hljs">function Ref(initialState, validator) { let state = initialState; this.deref = () =&gt; state; this.swap = (updater) =&gt; { const newState = updater(state); if (! validator(state, newState) ) throw "Invalid state"; state = newState; return newState; }; } const UserState = Immutable.Record({ id: null, name: '' }); const aliceState = new UserState({id: 0, name: 'Alice'}); const alice = new Ref( aliceState, (oldS, newS) =&gt; oldS.id === newS.id ); alice.swap( oldS =&gt; oldS.set('name', 'Queen Alice') ); alice.swap( oldS =&gt; oldS.set('id', 1) ); // BOOM!</code> </pre> <br><p>  <code>Ref</code> - wadah untuk keadaan tidak berubah, memungkinkan penggantian yang terkontrol.  <code>Ref</code> model identitas sama seperti kita beri nama objek.  Kami menyebutnya Sungai Volga, tetapi setiap saat memiliki keadaan yang tidak berubah. </p><br><h2 id="storage">  Penyimpanan </h2><br><p>  Pertimbangkan API berikut: </p><br><pre> <code class="plaintext hljs">storage.tx( t =&gt; { const alice = t.get(0); const bobState = new UserState({id: 1, name: 'Bob'}); const bob = t.create(bobState); alice.swap( oldS =&gt; oldS.update('friends', old =&gt; old.push(bob.deref.id)) ); });</code> </pre> <br><p>  <code>t.get</code> dan <code>t.create</code> kembalikan instance dari <code>Ref</code> . </p><br><p>  Kami membuka transaksi bisnis <code>t</code> , menemukan Alice dengan pengenalnya, menciptakan Bob dan menunjukkan bahwa Alice menganggap Bob sebagai temannya. </p><br><p>  Objek <code>t</code> mengontrol pembuatan <code>ref</code> . </p><br><p>  <code>t</code> dapat menyimpan dalam dirinya sendiri pemetaan pengidentifikasi entitas ke negara <code>ref</code> yang <code>ref</code> .  Yaitu  dapat mengimplementasikan Identity Map.  Dalam hal ini, <code>t</code> bertindak sebagai cache, atas permintaan Alice yang berulang, tidak akan ada permintaan ke database. </p><br><p>  <code>t</code> dapat mengingat keadaan awal entitas untuk melacak pada akhir transaksi yang perubahannya harus ditulis ke database.  Yaitu  dapat mengimplementasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Unit Kerja</a> .  Atau, jika dukungan pengamat ditambahkan ke <code>Ref</code> , dimungkinkan untuk mereset perubahan ke database dengan setiap perubahan dalam <code>ref</code> .  Ini adalah pendekatan optimis dan pesimis untuk memperbaiki perubahan. </p><br><p>  Dengan pendekatan optimis, Anda perlu melacak versi entitas yang ada. <br>  Ketika mengubah dari database, kita harus mengingat versi, dan ketika melakukan perubahan, periksa bahwa versi entitas dalam database tidak berbeda dari yang awal.  Jika tidak, Anda perlu mengulangi transaksi bisnis.  Pendekatan ini memungkinkan penggunaan operasi penyisipan dan penghapusan grup dan transaksi basis data yang sangat singkat, yang menghemat sumber daya. </p><br><p>  Dengan pendekatan pesimistis, transaksi basis data sepenuhnya konsisten dengan transaksi bisnis.  Yaitu  kami terpaksa menarik koneksi dari kolam semua pada saat transaksi bisnis selesai. </p><br><p>  API memungkinkan Anda untuk mengekstraksi entitas satu per satu, yang sangat tidak optimal.  Karena  kami telah menerapkan pola <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Peta Identitas</a> , maka kami dapat memasukkan metode <code>preload</code> di API: </p><br><pre> <code class="plaintext hljs">storage.tx( t =&gt; { t.preload([0, 1, 2, 3]); const alice = t.get(0); // from cache });</code> </pre> <br><h2 id="queries">  Pertanyaan </h2><br><p>  Jika kita tidak ingin transaksi lama, maka kita tidak dapat membuat pilihan dengan kunci arbitrer, karena  memori mungkin berisi benda-benda kotor dan seleksi akan mengembalikan hasil yang tidak terduga. </p><br><p>  Kami dapat menggunakan Kueri dan mengambil data (keadaan) di luar transaksi dan membaca kembali data saat dalam transaksi. </p><br><pre> <code class="plaintext hljs">const aliceId = userQuery.findByEmail('alice@mail.com'); storage.tx( t =&gt; { const alice = t.getOne(aliceId); });</code> </pre> <br><p>  Dengan demikian ada pembagian tanggung jawab.  Untuk kueri, kita dapat menggunakan mesin pencari untuk membaca skala menggunakan replika.  Dan API penyimpanan selalu bekerja dengan penyimpanan utama (master).  Tentu, replika akan berisi data yang sudah ketinggalan zaman, membaca kembali data dalam transaksi memecahkan masalah ini. </p><br><h2 id="commands">  Perintah </h2><br><p>  Ada situasi ketika operasi dapat dilakukan tanpa membaca data.  Misalnya, kurangi biaya bulanan dari akun semua pelanggan.  Atau masukkan dan perbarui data (siaga) jika terjadi konflik. </p><br><p>  Jika terjadi masalah kinerja, bundel dari Storage and Query dapat diganti dengan perintah seperti itu. </p><br><h2 id="svyazi">  Komunikasi </h2><br><p>  Jika entitas secara acak merujuk satu sama lain, sulit untuk memastikan konsistensi ketika mengubahnya.  Hubungan mencoba menyederhanakan, merampingkan, mengabaikan yang tidak perlu. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Agregat</a> adalah cara untuk mengatur hubungan.  Setiap agregat memiliki entitas root dan entitas bersarang.  Entitas eksternal apa pun dapat merujuk hanya ke akar agregat.  Root memastikan integritas seluruh unit.  Transaksi tidak dapat melewati batas agregat, dengan kata lain, seluruh agregat terlibat dalam transaksi. </p><br><p>  Agregat dapat, misalnya, terdiri dari Prapaskah (root) dan terjemahannya.  Atau Ordo dan Posisinya. </p><br><p>  API kami bekerja dengan seluruh agregat.  Pada saat yang sama, integritas referensial antara agregat terletak pada aplikasi.  API tidak mendukung pemuatan tautan yang malas. <br>  Tapi kita bisa memilih arah hubungan.  Pertimbangkan hubungan satu-ke-banyak Pengguna - Posting.  Kami dapat menyimpan ID pengguna di pos, tetapi apakah itu akan nyaman?  Kami akan mendapatkan lebih banyak informasi jika kami menyimpan array pengidentifikasi pos di pengguna. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Saya menekankan masalah ketika bekerja dengan database, menunjukkan opsi untuk menggunakan kekebalan. <br>  Format artikel tidak memungkinkan untuk mengungkapkan topik secara terperinci. </p><br><p>  Jika Anda tertarik dengan pendekatan ini, maka perhatikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi</a> buku saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari awal</a> , yang menjelaskan pembuatan aplikasi web dari awal dengan penekanan pada arsitektur.  Ia memahami SOLID, Clean Architecture, pola bekerja dengan database.  Sampel kode dalam buku dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi</a> itu sendiri ditulis dalam bahasa Clojure, yang diilhami oleh ide-ide kekebalan dan kenyamanan pemrosesan data. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433100/">https://habr.com/ru/post/id433100/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433088/index.html">Bagaimana Anda menyukainya, Elon Musk: BMW dan Porsche telah mengembangkan pengisian daya yang menambahkan 100 km perjalanan dalam 3 menit</a></li>
<li><a href="../id433090/index.html">Teknik Indeks Bitmap Oracle</a></li>
<li><a href="../id433092/index.html">Pemodelan CG Level 80: Karakter Photorealistic Realistis di Unreal</a></li>
<li><a href="../id433094/index.html">Pemodelan numerik di perusahaan industri besar</a></li>
<li><a href="../id433098/index.html">Kisah DDR3, SPD dan produsen Cina asli</a></li>
<li><a href="../id433102/index.html">Mengapa para ilmuwan percaya bahwa Planet Kesembilan tidak ada</a></li>
<li><a href="../id433104/index.html">Tantangan Foobar: tes rahasia Google untuk pengembang</a></li>
<li><a href="../id433106/index.html">SpaceX dan NASA menegaskan kembali niat mereka untuk meluncurkan peluncuran debut kapal Crew Dragon pada Januari 2019</a></li>
<li><a href="../id433108/index.html">ld -z kode terpisah</a></li>
<li><a href="../id433112/index.html">Menghibur JavaScript: Hari Salju</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>