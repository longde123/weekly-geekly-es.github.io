<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌂 ⚗️ 👼🏿 Una pequeña descripción de SIMD en .NET / C # ⏏️ 🙆🏻 ⚾️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Su atención es invitada a una pequeña descripción de las capacidades de vectorización de algoritmos en .NET Framework y .NETCORE. El propósito del art...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Una pequeña descripción de SIMD en .NET / C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435840/"><p> Su atención es invitada a una pequeña descripción de las capacidades de vectorización de algoritmos en .NET Framework y .NETCORE.  El propósito del artículo es presentar estas técnicas a aquellos que no las conocían en absoluto y mostrar que .NET no va muy por detrás de los lenguajes "reales, compilados" para los nativos. <br>  desarrollo </p><a name="habracut"></a><br><p>  Estoy empezando a aprender técnicas de vectorización, por lo que si alguien de la comunidad me señala un canto explícito o sugiere versiones mejoradas de los algoritmos que se describen a continuación, estaré muy feliz. </p><br><h2 id="nemnogo-istorii">  Un poco de historia </h2><br><p>  En .NET, SIMD apareció por primera vez en 2015 con el lanzamiento de .NET Framework 4.6.  Luego se agregaron los tipos Matrix3x2, Matrix4x4, Plane, Quaternion, Vector2, Vector3 y Vector4, lo que permitió la construcción de cálculos vectorizados.  Más tarde, se agregó el tipo Vector &lt;T&gt;, que proporcionó más oportunidades para vectorizar algoritmos.  Pero muchos programadores todavía estaban descontentos porque  los tipos anteriores limitaron el flujo de pensamientos del programador y no permitieron el uso completo de las instrucciones SIMD de los procesadores modernos.  Ya en nuestro tiempo, en .NET Core 3.0 Preview, ha aparecido el espacio de nombres System.Runtime.Intrinsics, que proporciona mucha más libertad para elegir instrucciones.  Para obtener los mejores resultados en velocidad, debe usar RyuJit y construir en x64 o desactivar Prefer 32-bit y construir en AnyCPU.  Todos los puntos de referencia que ejecuté en una computadora con un procesador Intel Core i7-6700 3.40GHz (Skylake). </p><br><h2 id="summiruem-elementy-massiva">  Resumir los elementos de la matriz. </h2><br><p>  Decidí comenzar con el problema clásico, que a menudo se escribe primero cuando se trata de vectorización.  Esta es la tarea de encontrar la suma de los elementos de la matriz.  Escribiremos cuatro implementaciones de esta tarea, resumiremos los elementos de la matriz Array: </p><br><p>  Más obvio </p><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Naive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Array) { result += i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Usando LINQ </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LINQ</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; Array.Aggregate&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>, (current, i) =&gt; current + i);</code> </pre> <br><p>  Usando vectores de System.Numerics: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vectors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Count; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accVector = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(array, i); accVector = Vector.Add(accVector, v); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = Vector.Dot(accVector, Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.One); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { result += array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Usando código del espacio System.Runtime.Intrinsics: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intrinsics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = <span class="hljs-number"><span class="hljs-number">256</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accVector = Vector256&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ptr = array) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = Avx2.LoadVector256(ptr + i); accVector = Avx2.Add(accVector, v); } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = <span class="hljs-keyword"><span class="hljs-keyword">stackalloc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[vectorSize]; Avx2.Store(temp, accVector); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; vectorSize; j++) { result += temp[j]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { result += array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Lancé un punto de referencia sobre estos 4 métodos en mi computadora y obtuve este resultado: </p><br><div class="scrollable-table"><table><thead><tr><th>  Método </th><th>  ItemsCount </th><th>  Mediana </th></tr></thead><tbody><tr><td>  Ingenuo </td><td>  10 </td><td>  75,12 ns </td></tr><tr><td>  LINQ </td><td>  10 </td><td>  1 186.85 ns </td></tr><tr><td>  Vectores </td><td>  10 </td><td>  60.09 ns </td></tr><tr><td>  Intrínseca </td><td>  10 </td><td>  255,40 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Ingenuo </td><td>  100 </td><td>  360.56 ns </td></tr><tr><td>  LINQ </td><td>  100 </td><td>  2 719,24 ns </td></tr><tr><td>  Vectores </td><td>  100 </td><td>  60.09 ns </td></tr><tr><td>  Intrínseca </td><td>  100 </td><td>  345,54 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Ingenuo </td><td>  1000 </td><td>  1 847,88 ns </td></tr><tr><td>  LINQ </td><td>  1000 </td><td>  12 033,78 ns </td></tr><tr><td>  Vectores </td><td>  1000 </td><td>  240,38 ns </td></tr><tr><td>  Intrínseca </td><td>  1000 </td><td>  630.98 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Ingenuo </td><td>  10,000 </td><td>  18 403,72 ns </td></tr><tr><td>  LINQ </td><td>  10,000 </td><td>  102 489,96 ns </td></tr><tr><td>  Vectores </td><td>  10,000 </td><td>  7 316,42 ns </td></tr><tr><td>  Intrínseca </td><td>  10,000 </td><td>  3 365.25 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Ingenuo </td><td>  100,000 </td><td>  176 630,67 ns </td></tr><tr><td>  LINQ </td><td>  100,000 </td><td>  975 998,24 ns </td></tr><tr><td>  Vectores </td><td>  100,000 </td><td>  78 828,03 ns </td></tr><tr><td>  Intrínseca </td><td>  100,000 </td><td>  41 269,41 ns </td></tr></tbody></table></div><br><p>  Se puede ver que las soluciones con vectores e intrínsecos son mucho más rápidas que la solución obvia y con LINQ.  Ahora tenemos que descubrir qué sucede en estos dos métodos. </p><br><p>  Considere el método de Vectores con más detalle: </p><br><div class="spoiler">  <b class="spoiler_title">Vectores</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vectors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Count; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accVector = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(array, i); accVector = Vector.Add(accVector, v); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = Vector.Dot(accVector, Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.One); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { result += array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><ul><li>  int vectorSize = Vector &lt;int&gt; .Count;  - esta es la cantidad de números de 4 bytes que podemos poner en un vector.  Si se usa la aceleración de hardware, este valor muestra cuántos números de 4 bytes se pueden colocar en un registro SIMD.  De hecho, muestra cuántos elementos de este tipo puede realizar operaciones en paralelo; </li><li>  accVector: un vector en el que se acumulará el resultado de la función; <br>  var v = nuevo Vector &lt;int&gt; (matriz, i);  - los datos se cargan en un nuevo vector v, desde la matriz, comenzando desde el índice i.  Se cargarán exactamente los datos de vectorSize. </li><li>  accVector = Vector.Add (accVector, v);  - Se añaden dos vectores. <br>  Por ejemplo, en la matriz se almacenan 8 números: {0, 1, 2, 3, 4, 5, 6, 7} y vectorSize == 4, luego: <br>  En la primera iteración del bucle accVector = {0, 0, 0, 0}, v = {0, 1, 2, 3}, después de la adición en accVector será: {0, 0, 0, 0} + {0, 1, 2 , 3} = {0, 1, 2, 3}. <br>  En la segunda iteración, v = {4, 5, 6, 7} y después de la suma accVector = {0, 1, 2, 3} + {4, 5, 6, 7} = {4, 6, 8, 10}. </li><li>  Solo queda obtener de alguna manera la suma de todos los elementos del vector, para esto podemos aplicar la multiplicación escalar por un vector lleno de unidades: int result = Vector.Dot (accVector, Vector &lt;int&gt; .One); <br>  Entonces resulta: {4, 6, 8, 10} <em>{1, 1, 1, 1} = 4</em> 1 + 6 <em>1 + 8</em> 1 + 10 * 1 = 28. </li><li>  Al final, si es necesario, se suman los números que no caben en el último vector. </li></ul><br><p>  Si nos fijamos en el código del método intrínseco: </p><br><div class="spoiler">  <b class="spoiler_title">Intrínseca</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intrinsics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = <span class="hljs-number"><span class="hljs-number">256</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accVector = Vector256&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ptr = array) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = Avx2.LoadVector256(ptr + i); accVector = Avx2.Add(accVector, v); } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = <span class="hljs-keyword"><span class="hljs-keyword">stackalloc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[vectorSize]; Avx2.Store(temp, accVector); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; vectorSize; j++) { result += temp[j]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { result += array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><p>  Puede ver que es muy similar a Vectores con algunas excepciones: </p><br><ul><li>  vectorSize está dado por constante.  Esto se debe a que las instrucciones Avx2 que operan en registros de 256 bits se usan explícitamente en este método.  En una aplicación real, debería verificarse si el procesador Avx2 actual admite instrucciones y, si no, llamar a otro código.  Se parece a esto: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Avx2.IsSupported) { DoThingsForAvx2(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Avx.IsSupported) { DoThingsForAvx(); } ... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Sse2.IsSupported) { DoThingsForSse2(); } ...</code> </pre> </li><li>  var accVector = Vector256 &lt;int&gt; .Zero;  accVector se declara como un vector de 256 bits lleno de ceros. </li><li>  fixed (int * ptr = Array): se ingresa un puntero a una matriz en ptr. </li><li>  Luego, las mismas operaciones que en Vectores: cargar datos en un vector y agregar dos vectores. </li><li>  Para resumir los elementos del vector se aplicó el siguiente método: <br><ul><li>  se crea una matriz en la pila: var temp = stackalloc int [vectorSize]; </li><li>  el vector se carga en esta matriz: Avx2.Store (temp, accVector); </li><li>  en un bucle se suman los elementos de la matriz. </li></ul></li><li>  entonces se suman los elementos de la matriz que no se colocan en el último vector </li></ul><br><h2 id="sravnivaem-dva-massiva">  Compara dos matrices </h2><br><p>  Es necesario comparar dos matrices de bytes.  En realidad, este es el problema por el cual comencé a aprender SIMD en .NET.  Nuevamente, escribiremos varios métodos para el punto de referencia, compararemos dos matrices: ArrayA y ArrayB: </p><br><p>  La solución más obvia: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Naive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ArrayA.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ArrayA[i] != ArrayB[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><p>  Solución a través de LINQ: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LINQ</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; ArrayA.SequenceEqual(ArrayB);</code> </pre> <br><p>  Solución a través de la función MemCmp: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"msvcrt.dll"</span></span></span><span class="hljs-meta">, CallingConvention = CallingConvention.Cdecl)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memcmp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] b1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] b2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MemCmp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; memcmp(ArrayA, ArrayB, ArrayA.Length) == <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><p>  Usando vectores de System.Numerics: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vectors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;.Count; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; ArrayA.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> va = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;(ArrayA, i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;(ArrayB, i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Vector.EqualsAll(va, vb)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; ArrayA.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ArrayA[i] != ArrayB[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><p>  Usando intrínsecos: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intrinsics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = <span class="hljs-number"><span class="hljs-number">256</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> equalsMask = <span class="hljs-keyword"><span class="hljs-keyword">unchecked</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (<span class="hljs-number"><span class="hljs-number">0b1111</span></span>_1111_1111_1111_1111_1111_1111_1111)); <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>* ptrA = ArrayA) <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>* ptrB = ArrayB) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; ArrayA.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> va = Avx2.LoadVector256(ptrA + i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vb = Avx2.LoadVector256(ptrB + i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areEqual = Avx2.CompareEqual(va, vb); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Avx2.MoveMask(areEqual) != equalsMask) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; ArrayA.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ArrayA[i] != ArrayB[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  El resultado del benchmark en mi computadora: </p><br><div class="scrollable-table"><table><thead><tr><th>  Método </th><th>  ItemsCount </th><th>  Mediana </th></tr></thead><tbody><tr><td>  Ingenuo </td><td>  10,000 </td><td>  66 719,1 ns </td></tr><tr><td>  LINQ </td><td>  10,000 </td><td>  71 211,1 ns </td></tr><tr><td>  Vectores </td><td>  10,000 </td><td>  3 695.8 ns </td></tr><tr><td>  Memcmp </td><td>  10,000 </td><td>  600,9 ns </td></tr><tr><td>  Intrínseca </td><td>  10,000 </td><td>  1 607,5 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Ingenuo </td><td>  100,000 </td><td>  588 633,7 ns </td></tr><tr><td>  LINQ </td><td>  100,000 </td><td>  651 191.3 ns </td></tr><tr><td>  Vectores </td><td>  100,000 </td><td>  34 659,1 ns </td></tr><tr><td>  Memcmp </td><td>  100,000 </td><td>  5 513,6 ns </td></tr><tr><td>  Intrínseca </td><td>  100,000 </td><td>  12,078.9 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Ingenuo </td><td>  1,000,000 </td><td>  5 637 293,1 ns </td></tr><tr><td>  LINQ </td><td>  1,000,000 </td><td>  6 622 666,0 ns </td></tr><tr><td>  Vectores </td><td>  1,000,000 </td><td>  777 974,2 ns </td></tr><tr><td>  Memcmp </td><td>  1,000,000 </td><td>  361 704,5 ns </td></tr><tr><td>  Intrínseca </td><td>  1,000,000 </td><td>  434 252,7 ns </td></tr></tbody></table></div><br><p>  Creo que todo el código para estos métodos es comprensible, con la excepción de dos líneas en intrínsecos: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areEqual = Avx2.CompareEqual(va, vb); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Avx2.MoveMask(areEqual) != equalsMask) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><p>  En el primero, se comparan dos vectores para igualdad y el resultado se almacena en el vector areEqual, en el que todos los bits se establecen en 1 en un elemento en una posición específica si los elementos correspondientes en va y vb son iguales.  Resulta que si los vectores de los bytes va y vb son completamente iguales, entonces en areEquals todos los elementos deberían ser iguales a 255 (11111111b).  Porque  Avx2.CompareEqual es un contenedor sobre _mm256_cmpeq_epi8, luego <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el sitio de Intel</a> puede ver el pseudocódigo de esta operación: <br>  El método MoveMask de un vector crea un número de 32 bits.  Los valores de bits son los bits altos de cada uno de los 32 elementos de un solo byte del vector.  El pseudocódigo se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . </p><br><p>  Por lo tanto, si algunos bytes en va y vb no coinciden, en areEqual los bytes correspondientes serán 0, por lo tanto, los bits más significativos de estos bytes también serán 0, lo que significa que los bits correspondientes en la respuesta Avx2.MoveMask también serán 0 y la comparación con equalsMask no funcionará. </p><br><p>  Analicemos un pequeño ejemplo, suponiendo que la longitud del vector es de 8 bytes (para escribirlo fue menor): </p><br><ul><li>  Sea va = {100, 10, 20, 30, 100, 40, 50, 100}, y vb = {100, 20, 10, 30, 100, 40, 80, 90}; </li><li>  Entonces areEqual será igual a {255, 0, 0, 255, 255, 255, 0, 0}; </li><li>  El método MoveMask devolverá 10011100b, que deberá compararse con la máscara 11111111b, porque  Como estas máscaras son desiguales, resulta que los vectores va y vb no son iguales. </li></ul><br><h2 id="podschityvaem-skolko-raz-element-vstrechaetsya-v-kollekcii">  Cuente cuántas veces ocurre un elemento en la colección </h2><br><p>  A veces es necesario calcular cuántas veces se encuentra un elemento en particular en una colección, por ejemplo, ints, este algoritmo también se puede acelerar.  Escribamos algunos métodos para comparar, buscaremos el elemento Item en la matriz de Array. </p><br><p>  Lo más obvio: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Naive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Array) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == Item) { result++; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  usando LINQ: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LINQ</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; Array.Count(i =&gt; i == Item);</code> </pre> <br><p>  utilizando vectores de System.Numerics.Vectors: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vectors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mask = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(Item); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Count; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accResult = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(array, i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areEqual = Vector.Equals(v, mask); accResult = Vector.Subtract(accResult, areEqual); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array[i] == Item) { result++; } } result += Vector.Dot(accResult, Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.One); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Usando intrínsecos: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intrinsics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = <span class="hljs-number"><span class="hljs-number">256</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-comment"><span class="hljs-comment">//var mask = Avx2.SetAllVector256(Item); //var mask = Avx2.SetVector256(Item, Item, Item, Item, Item, Item, Item, Item); var temp = stackalloc int[vectorSize]; for (int j = 0; j &lt; vectorSize; j++) { temp[j] = Item; } var mask = Avx2.LoadVector256(temp); var accVector = Vector256&lt;int&gt;.Zero; int i; var array = Array; fixed (int* ptr = array) { for (i = 0; i &lt; array.Length - vectorSize; i += vectorSize) { var v = Avx2.LoadVector256(ptr + i); var areEqual = Avx2.CompareEqual(v, mask); accVector = Avx2.Subtract(accVector, areEqual); } } int result = 0; Avx2.Store(temp, accVector); for(int j = 0; j &lt; vectorSize; j++) { result += temp[j]; } for(; i &lt; array.Length; i++) { if (array[i] == Item) { result++; } } return result; }</span></span></code> </pre> <br><p>  El resultado del benchmark en mi computadora: </p><br><div class="scrollable-table"><table><thead><tr><th>  Método </th><th>  ItemsCount </th><th>  Mediana </th></tr></thead><tbody><tr><td>  Ingenuo </td><td>  1000 </td><td>  2 824,41 ns </td></tr><tr><td>  LINQ </td><td>  1000 </td><td>  12 138.95 ns </td></tr><tr><td>  Vectores </td><td>  1000 </td><td>  961.50 ns </td></tr><tr><td>  Intrínseca </td><td>  1000 </td><td>  691.08 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Ingenuo </td><td>  10,000 </td><td>  27 072.25 ns </td></tr><tr><td>  LINQ </td><td>  10,000 </td><td>  113 967,87 ns </td></tr><tr><td>  Vectores </td><td>  10,000 </td><td>  7 571,82 ns </td></tr><tr><td>  Intrínseca </td><td>  10,000 </td><td>  4.296,71 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Ingenuo </td><td>  100,000 </td><td>  361 028,46 ns </td></tr><tr><td>  LINQ </td><td>  100,000 </td><td>  1.091.994,28 ns </td></tr><tr><td>  Vectores </td><td>  100,000 </td><td>  82 839,29 ns </td></tr><tr><td>  Intrínseca </td><td>  100,000 </td><td>  40 307,91 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Ingenuo </td><td>  1,000,000 </td><td>  1 634 175,46 ns </td></tr><tr><td>  LINQ </td><td>  1,000,000 </td><td>  6 194 257,38 ns </td></tr><tr><td>  Vectores </td><td>  1,000,000 </td><td>  583 901,29 ns </td></tr><tr><td>  Intrínseca </td><td>  1,000,000 </td><td>  413 520,38 ns </td></tr></tbody></table></div><br><p>  Los métodos de Vectores e Intrínsecos son completamente idénticos en lógica, las diferencias están solo en la implementación de operaciones específicas.  La idea en su conjunto es: </p><br><ul><li>  se crea un vector de máscara en el que se almacena el número requerido en cada elemento; </li><li>  La parte de la matriz se carga en el vector v y se compara con la máscara, luego todos los bits se establecerán en elementos iguales en areEqual, porque  areEqual es un vector de ints, entonces si configura todos los bits de un elemento, obtenemos -1 en este elemento ((int) (1111_1111_1111_1111_1111_1111_1111_1111b) == -1); </li><li>  el vector areEqual se resta de accVector y luego accVector será la suma de cuántas veces se produjo el elemento elemento en todos los vectores v para cada posición (menos min da un plus). </li></ul><br><p>  Todo el código del artículo se puede encontrar en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> </p><br><h2 id="zaklyuchenie">  Conclusión </h2><br><p>  Examiné solo una parte muy pequeña de las posibilidades que ofrece .NET para los cálculos de vectorización.  Para obtener una lista completa y actualizada de intrínsecos disponibles en .NETCORE bajo x86, puede consultar el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">código fuente</a> .  Es conveniente que en los archivos C # en el resumen de cada intrínseco haya su propio nombre del mundo de C, lo que simplifica la comprensión del propósito de este intrínseco y la traducción de los algoritmos C ++ / C existentes a .NET.  La documentación de System.Numerics.Vector está disponible en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">msdn</a> . </p><br><p>  En mi opinión, .NET tiene una gran ventaja sobre C ++, porque  La compilación JIT ya tiene lugar en la máquina del cliente, el compilador puede optimizar el código para un procesador de cliente específico, proporcionando el máximo rendimiento.  Al mismo tiempo, un programador para escribir código rápido puede permanecer dentro del marco de un lenguaje y tecnología. </p><br><p>  UPD (15/09/2019): </p><br><div class="spoiler">  <b class="spoiler_title">Había una jamba en los puntos de referencia</b> <div class="spoiler_text"><p>  En los puntos de referencia, usé IterationSetup, que, como resultó, puede afectar en gran medida el rendimiento de los puntos de referencia que funcionan en menos de 100 ms.  Si lo rehace en GlobalSetup, los resultados serán así. </p><br><p>  Suma de elementos de matriz: </p><br><div class="scrollable-table"><table><thead><tr><th>  Método </th><th>  ItemsCount </th><th>  Media </th><th>  Error </th><th>  Stddev </th><th>  Ratio </th></tr></thead><tbody><tr><td>  Ingenuo </td><td>  10 </td><td>  3.531 ns </td><td>  0.0336 ns </td><td>  0.0314 ns </td><td>  1.00 </td></tr><tr><td>  LINQ </td><td>  10 </td><td>  76,925 ns </td><td>  0.4166 ns </td><td>  0.3897 ns </td><td>  21,79 </td></tr><tr><td>  Vectores </td><td>  10 </td><td>  2.750 ns </td><td>  0.0210 ns </td><td>  0,0196 ns </td><td>  0,78 </td></tr><tr><td>  Intrínseca </td><td>  10 </td><td>  6.513 ns </td><td>  0.0623 ns </td><td>  0,0582 ns </td><td>  1,84 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Ingenuo </td><td>  100 </td><td>  47,982 ns </td><td>  0.3975 ns </td><td>  0.3524 ns </td><td>  1.00 </td></tr><tr><td>  LINQ </td><td>  100 </td><td>  590.414 ns </td><td>  3.8808 ns </td><td>  3.4402 ns </td><td>  12,31 </td></tr><tr><td>  Vectores </td><td>  100 </td><td>  10.122 ns </td><td>  0.0747 ns </td><td>  0.0699 ns </td><td>  0,21 </td></tr><tr><td>  Intrínseca </td><td>  100 </td><td>  14,277 ns </td><td>  0.0566 ns </td><td>  0.0529 ns </td><td>  0,30 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Ingenuo </td><td>  1000 </td><td>  569.910 ns </td><td>  2.8297 ns </td><td>  2.6469 ns </td><td>  1.00 </td></tr><tr><td>  LINQ </td><td>  1000 </td><td>  5,658.570 ns </td><td>  31.7465 ns </td><td>  29.6957 ns </td><td>  9,93 </td></tr><tr><td>  Vectores </td><td>  1000 </td><td>  79.598 ns </td><td>  0.3498 ns </td><td>  0.3272 ns </td><td>  0,14 </td></tr><tr><td>  Intrínseca </td><td>  1000 </td><td>  66,970 ns </td><td>  0.3937 ns </td><td>  0.3682 ns </td><td>  0,12 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Ingenuo </td><td>  10,000 </td><td>  5.637.571 ns </td><td>  37.5050 ns </td><td>  29.2814 ns </td><td>  1.00 </td></tr><tr><td>  LINQ </td><td>  10,000 </td><td>  56.498.987 ns </td><td>  294.8776 ns </td><td>  275.8287 ns </td><td>  10.02 </td></tr><tr><td>  Vectores </td><td>  10,000 </td><td>  772.900 ns </td><td>  2.6802 ns </td><td>  2.5070 ns </td><td>  0,14 </td></tr><tr><td>  Intrínseca </td><td>  10,000 </td><td>  579.152 ns </td><td>  2.8371 ns </td><td>  2.6538 ns </td><td>  0,10 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Ingenuo </td><td>  100,000 </td><td>  56,352.865 ns </td><td>  230.7916 ns </td><td>  215.8826 ns </td><td>  1.00 </td></tr><tr><td>  LINQ </td><td>  100,000 </td><td>  562,610.571 ns </td><td>  3.775,7631 ns </td><td>  3.152,9332 ns </td><td>  9,98 </td></tr><tr><td>  Vectores </td><td>  100,000 </td><td>  8.389.647 ns </td><td>  165.9590 ns </td><td>  227.1666 ns </td><td>  0,15 </td></tr><tr><td>  Intrínseca </td><td>  100,000 </td><td>  7.261.334 ns </td><td>  89.6468 ns </td><td>  69.9903 ns </td><td>  0,13 </td></tr></tbody></table></div><br><p>  Comparando dos matrices: </p><br><div class="scrollable-table"><table><thead><tr><th>  Método </th><th>  ItemsCount </th><th>  Media </th><th>  Error </th><th>  Stddev </th><th>  Ratio </th></tr></thead><tbody><tr><td>  Ingenuo </td><td>  10,000 </td><td>  7.033,8 ns </td><td>  50.636 ns </td><td>  47.365 ns </td><td>  1.00 </td></tr><tr><td>  LINQ </td><td>  10,000 </td><td>  64.841,4 ns </td><td>  289.157 ns </td><td>  270.478 ns </td><td>  9.22 </td></tr><tr><td>  Vectores </td><td>  10,000 </td><td>  504.0 ns </td><td>  2.406 ns </td><td>  2.251 ns </td><td>  0,07 </td></tr><tr><td>  Memcmp </td><td>  10,000 </td><td>  368,1 ns </td><td>  2.637 ns </td><td>  2.466 ns </td><td>  0,05 </td></tr><tr><td>  Intrínseca </td><td>  10,000 </td><td>  283,6 ns </td><td>  1.135 ns </td><td>  1.061 ns </td><td>  0,04 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Ingenuo </td><td>  100,000 </td><td>  85,214.4 ns </td><td>  903.868 ns </td><td>  845.478 ns </td><td>  1.00 </td></tr><tr><td>  LINQ </td><td>  100,000 </td><td>  702,279.4 ns </td><td>  2,846.609 ns </td><td>  2,662.720 ns </td><td>  8.24 </td></tr><tr><td>  Vectores </td><td>  100,000 </td><td>  5.179,2 ns </td><td>  45,337 ns </td><td>  42,409 ns </td><td>  0,06 </td></tr><tr><td>  Memcmp </td><td>  100,000 </td><td>  4,510.5 ns </td><td>  24.292 ns </td><td>  22.723 ns </td><td>  0,05 </td></tr><tr><td>  Intrínseca </td><td>  100,000 </td><td>  2,957.0 ns </td><td>  11.452 ns </td><td>  10.712 ns </td><td>  0,03 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Ingenuo </td><td>  1,000,000 </td><td>  844,006.1 ns </td><td>  3,552.478 ns </td><td>  3.322,990 ns </td><td>  1.00 </td></tr><tr><td>  LINQ </td><td>  1,000,000 </td><td>  6.483.079,3 ns </td><td>  42,641.040 ns </td><td>  39,886.455 ns </td><td>  7.68 </td></tr><tr><td>  Vectores </td><td>  1,000,000 </td><td>  54,180.1 ns </td><td>  357.258 ns </td><td>  334,180 ns </td><td>  0,06 </td></tr><tr><td>  Memcmp </td><td>  1,000,000 </td><td>  49,480.1 ns </td><td>  515.675 ns </td><td>  457.133 ns </td><td>  0,06 </td></tr><tr><td>  Intrínseca </td><td>  1,000,000 </td><td>  36,633.9 ns </td><td>  680.525 ns </td><td>  636.564 ns </td><td>  0,04 </td></tr></tbody></table></div><br><p>  El número de ocurrencias de un elemento en una matriz: </p><br><div class="scrollable-table"><table><thead><tr><th>  Método </th><th>  ItemsCount </th><th>  Media </th><th>  Error </th><th>  Stddev </th><th>  Ratio </th></tr></thead><tbody><tr><td>  Ingenuo </td><td>  10 </td><td>  8.844 ns </td><td>  0,0772 ns </td><td>  0.0603 ns </td><td>  1.00 </td></tr><tr><td>  LINQ </td><td>  10 </td><td>  87.456 ns </td><td>  0.9496 ns </td><td>  0.8883 ns </td><td>  9,89 </td></tr><tr><td>  Vectores </td><td>  10 </td><td>  3.140 ns </td><td>  0,0406 ns </td><td>  0.0380 ns </td><td>  0,36 </td></tr><tr><td>  Intrínseca </td><td>  10 </td><td>  13.813 ns </td><td>  0.0825 ns </td><td>  0,0772 ns </td><td>  1,56 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Ingenuo </td><td>  100 </td><td>  107,310 ns </td><td>  0,6975 ns </td><td>  0.6183 ns </td><td>  1.00 </td></tr><tr><td>  LINQ </td><td>  100 </td><td>  626.285 ns </td><td>  5.7677 ns </td><td>  5.3951 ns </td><td>  5.83 </td></tr><tr><td>  Vectores </td><td>  100 </td><td>  11.844 ns </td><td>  0.2113 ns </td><td>  0.1873 ns </td><td>  0,11 </td></tr><tr><td>  Intrínseca </td><td>  100 </td><td>  19,616 ns </td><td>  0.1018 ns </td><td>  0,0903 ns </td><td>  0,18 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Ingenuo </td><td>  1000 </td><td>  1,032.466 ns </td><td>  6.3799 ns </td><td>  5.6556 ns </td><td>  1.00 </td></tr><tr><td>  LINQ </td><td>  1000 </td><td>  6.266,605 ns </td><td>  42.6585 ns </td><td>  39.9028 ns </td><td>  6.07 </td></tr><tr><td>  Vectores </td><td>  1000 </td><td>  83,417 ns </td><td>  0.5393 ns </td><td>  0.4780 ns </td><td>  0,08 </td></tr><tr><td>  Intrínseca </td><td>  1000 </td><td>  88.358 ns </td><td>  0.4921 ns </td><td>  0.4603 ns </td><td>  0,09 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Ingenuo </td><td>  10,000 </td><td>  9,942.503 ns </td><td>  47,9732 ns </td><td>  40.0598 ns </td><td>  1.00 </td></tr><tr><td>  LINQ </td><td>  10,000 </td><td>  62,305.598 ns </td><td>  643.8775 ns </td><td>  502.6972 ns </td><td>  6.27 </td></tr><tr><td>  Vectores </td><td>  10,000 </td><td>  914.967 ns </td><td>  7.2959 ns </td><td>  6.8246 ns </td><td>  0,09 </td></tr><tr><td>  Intrínseca </td><td>  10,000 </td><td>  931.698 ns </td><td>  6.3444 ns </td><td>  5.9346 ns </td><td>  0,09 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Ingenuo </td><td>  100,000 </td><td>  94,834.804 ns </td><td>  793.8585 ns </td><td>  703.7349 ns </td><td>  1.00 </td></tr><tr><td>  LINQ </td><td>  100,000 </td><td>  626,620.968 ns </td><td>  4,696.9221 ns </td><td>  4,393.5038 ns </td><td>  6.61 </td></tr><tr><td>  Vectores </td><td>  100,000 </td><td>  9,000.827 ns </td><td>  179.5351 ns </td><td>  192.1005 ns </td><td>  0,09 </td></tr><tr><td>  Intrínseca </td><td>  100,000 </td><td>  8.690.771 ns </td><td>  101.7078 ns </td><td>  95.1376 ns </td><td>  0,09 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Ingenuo </td><td>  1,000,000 </td><td>  959,302.249 ns </td><td>  4.268.2488 ns </td><td>  3.783,6914 ns </td><td>  1.00 </td></tr><tr><td>  LINQ </td><td>  1,000,000 </td><td>  6.218.681.888 ns </td><td>  31,321.9277 ns </td><td>  29,298.5506 ns </td><td>  6.48 </td></tr><tr><td>  Vectores </td><td>  1,000,000 </td><td>  99,778.488 ns </td><td>  1,975.6001 ns </td><td>  4,252.6877 ns </td><td>  0,10 </td></tr><tr><td>  Intrínseca </td><td>  1,000,000 </td><td>  96,449.350 ns </td><td>  1,171.8067 ns </td><td>  978.5116 ns </td><td>  0,10 </td></tr></tbody></table></div></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es435840/">https://habr.com/ru/post/es435840/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es435828/index.html">Matemáticas en Gamedev es simple. Curvas y ondas de unidad para efecto lluvia</a></li>
<li><a href="../es435830/index.html">OMEGA - Automatización del tiempo de eventos deportivos.</a></li>
<li><a href="../es435834/index.html">EXAMEN - Método de clasificación de texto de vanguardia</a></li>
<li><a href="../es435836/index.html">Las firmas más grandes de Wall Street acuerdan lanzar un nuevo intercambio para competir con Nasdaq y NYSE</a></li>
<li><a href="../es435838/index.html">Funciones perezosas de JavaScript</a></li>
<li><a href="../es435842/index.html">Creación de modelos de juegos en 3D para los pobres: Indie Way</a></li>
<li><a href="../es435846/index.html">Conferencias y hackatones para escolares y estudiantes: 11 eventos temáticos</a></li>
<li><a href="../es435848/index.html">Nuevos dispositivos y tecnologías con CES 2019 de Microsoft y socios</a></li>
<li><a href="../es435854/index.html">Notas de un fitoquímico. Radio banana</a></li>
<li><a href="../es435856/index.html">¿Qué antivirus se usan en los firewalls modernos?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>