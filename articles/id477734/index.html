<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💢 🍤 🦊 Memahami UICollectionViewLayout dengan Aplikasi Foto 👨🏾‍🏭 🤚🏼 📏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Nama saya Nikita, saya bekerja pada SDK seluler di ABBYY, dan saya juga berurusan dengan komponen UI untuk pemindaian dan nyaman melihat d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memahami UICollectionViewLayout dengan Aplikasi Foto</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/abbyy/blog/477734/"> Halo, Habr!  Nama saya Nikita, saya bekerja pada SDK seluler di ABBYY, dan saya juga berurusan dengan komponen UI untuk pemindaian dan nyaman melihat dokumen multi-halaman pada smartphone.  Komponen ini mengurangi waktu untuk mengembangkan aplikasi berdasarkan <a href="http://www.abbyy.com/ru-ru/mobile-capture-sdk/%3Futm_source%3Dhabr%26utm_medium%3Dpost%26utm_campaign%3D%25D0%25BF%25D0%25BE%25D0%25BD%25D0%25B8%25D0%25BC%25D0%25B0%25D0%25B5%25D0%25BC_ui">teknologi ABBYY Mobile Capture</a> dan terdiri dari beberapa bagian.  Pertama, kamera untuk memindai dokumen;  kedua, layar editor dengan hasil pengambilan (yaitu, mengambil foto secara otomatis) dan layar untuk memperbaiki batas-batas dokumen. <br><br>  Sudah cukup bagi pengembang untuk memanggil beberapa metode - dan sekarang dalam aplikasinya kamera sudah tersedia yang secara otomatis memindai dokumen.  Tetapi, di samping kamera yang dikonfigurasi, Anda perlu memberi pelanggan akses yang mudah ke hasil pemindaian, mis.  mengambil foto secara otomatis.  Dan jika klien memindai kontrak atau piagam, maka mungkin ada banyak foto seperti itu. <br><br>  Dalam posting ini saya akan berbicara tentang kesulitan yang muncul selama implementasi layar editor dengan hasil penangkapan dokumen.  Layar itu sendiri adalah dua <code>UICollectionView</code> , saya akan menyebutnya besar dan kecil.  Saya akan menghilangkan kemungkinan menyesuaikan batas-batas dokumen dan pekerjaan lain dengan dokumen secara manual, dan saya akan fokus pada animasi dan fitur tata letak selama gulir.  Di bawah ini di GIF Anda dapat melihat apa yang terjadi pada akhirnya.  Tautan ke repositori akan berada di akhir artikel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/r2/xs/of/r2xsofivnhzdmlxt67ld_2atq-q.gif"></div><br><br>  Sebagai referensi, saya sering memperhatikan aplikasi sistem Apple.  Ketika Anda dengan hati-hati melihat animasi dan solusi antarmuka lainnya dari aplikasi mereka, Anda mulai mengagumi sikap penuh perhatian mereka terhadap berbagai hal sepele.  Sekarang kita akan melihat aplikasi <i>Foto</i> (iOS 12) sebagai referensi.  Saya akan menarik perhatian Anda ke fitur spesifik dari aplikasi ini, dan kemudian kami akan mencoba mengimplementasikannya. <br><a name="habracut"></a><br>  Kami akan membahas sebagian besar <code>UICollectionViewFlowLayout</code> penyesuaian <code>UICollectionViewFlowLayout</code> , melihat bagaimana teknik umum seperti paralaks dan korsel diimplementasikan, dan membahas masalah yang terkait dengan animasi khusus ketika memasukkan dan menghapus sel. <br><br><h2>  Ulasan Fitur </h2><br>  Untuk menambahkan spesifik, saya akan menjelaskan hal-hal kecil apa yang menyenangkan saya dalam aplikasi <i>Foto</i> , dan kemudian saya akan menerapkannya dalam urutan yang sesuai. <br><br><ol><li>  Efek paralaks dalam koleksi besar </li><li>  Elemen-elemen koleksi kecil terpusat. </li><li>  Ukuran item yang dinamis dalam koleksi kecil </li><li>  Logika penempatan unsur-unsur sel kecil tidak hanya bergantung pada contentOffset, tetapi juga pada interaksi pengguna </li><li>  Animasi khusus untuk dipindahkan dan dihapus </li><li>  Indeks sel "aktif" tidak hilang saat mengubah orientasi </li></ol><br><h3>  1. Parallax </h3><br>  Apa itu paralaks? <br><blockquote>  Pengguliran Parallax adalah teknik dalam grafik komputer di mana gambar latar belakang bergerak melewati kamera lebih lambat daripada gambar latar depan, menciptakan ilusi kedalaman dalam adegan 2D dan menambah kesan pencelupan dalam pengalaman virtual. </blockquote>  Anda dapat melihat bahwa saat menggulir, bingkai sel bergerak lebih cepat daripada gambar yang ada di dalamnya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9u/qc/7j/9uqc7jfa_e81lg-_9h6uleidmdg.gif"></div><div style="text-align:center;"><img src="https://habrastorage.org/webt/oc/jt/nv/ocjtnvvyckaotg52-tooulyfddq.png"></div><br>  Ayo mulai!  Buat subkelas sel, masukkan UIImageView ke dalamnya. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PreviewCollectionViewCell</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UICollectionViewCell</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> imageView = <span class="hljs-type"><span class="hljs-type">UIImageView</span></span>()​ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(frame: <span class="hljs-type"><span class="hljs-type">CGRect</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(frame: frame) addSubview(imageView) clipsToBounds = <span class="hljs-literal"><span class="hljs-literal">true</span></span> imageView.snp.makeConstraints { $<span class="hljs-number"><span class="hljs-number">0</span></span>.edges.equalToSuperview() } } }</code> </pre><br>  Sekarang Anda perlu memahami cara menggeser <code>imageView</code> , menciptakan efek paralaks.  Untuk melakukan ini, Anda perlu mendefinisikan kembali perilaku sel selama pengguliran.  Apple: <br><blockquote>  Hindari subkelas <code>UICollectionView</code> .  Tampilan koleksi memiliki sedikit atau tidak ada tampilan tersendiri.  Sebagai gantinya, ini menarik semua pandangannya dari objek sumber data Anda dan semua informasi terkait tata letak dari objek tata letak.  Jika Anda mencoba untuk meletakkan item dalam tiga dimensi, cara yang tepat untuk melakukannya adalah dengan mengimplementasikan tata letak khusus yang mengatur transformasi 3D dari setiap sel dan melihatnya dengan tepat. </blockquote>  Ok, mari kita buat <b>objek layout</b> kita.  <code>UICollectionView</code> memiliki <code>collectionViewLayout</code> propertiViewLayout, dari mana ia mempelajari informasi tentang penentuan posisi sel.  <code>UICollectionViewFlowLayout</code> adalah implementasi dari abstrak <code>UICollectionViewLayout</code> , yang merupakan properti <code>collectionViewLayout</code> . <br><blockquote>  <code>UICollectionViewLayout</code> sedang menunggu seseorang untuk <code>UICollectionViewLayout</code> dan menyediakan konten yang sesuai.  <code>UICollectionViewFlowLayout</code> adalah kelas konkret dari <code>UICollectionViewLayout</code> yang memiliki keempat anggotanya diimplementasikan, dengan cara sel-sel akan diatur dalam cara grid. <br></blockquote>  Buat subkelas dari <code>UICollectionViewFlowLayout</code> dan timpa <code>layoutAttributesForElements(in:)</code> .  Metode mengembalikan array <code>UICollectionViewLayoutAttributes</code> , yang menyediakan informasi tentang cara menampilkan sel tertentu. <br><br>  Koleksi meminta atribut setiap kali perubahan <code>contentOffset</code> , serta ketika tata letak tidak valid.  Selain itu, kami akan membuat atribut khusus dengan menambahkan properti <code>parallaxValue</code> , yang menentukan seberapa banyak bingkai gambar yang tertunda dari bingkai sel.  Untuk subclass atribut, Anda harus mengganti <code>NSCopiyng</code> untuk mereka.  Apple: <br><blockquote>  Jika Anda subkelas dan mengimplementasikan atribut tata letak khusus, Anda juga harus mengganti metode isEqual: yang diwarisi untuk membandingkan nilai properti Anda.  Di iOS 7 dan yang lebih baru, tampilan koleksi tidak menerapkan atribut tata letak jika atribut tersebut tidak berubah.  Ini menentukan apakah atribut telah berubah dengan membandingkan objek atribut lama dan baru menggunakan metode isEqual:.  Karena implementasi default metode ini hanya memeriksa properti yang ada di kelas ini, Anda harus mengimplementasikan versi metode Anda sendiri untuk membandingkan properti tambahan apa pun.  Jika semua properti khusus Anda sama, hubungi <code>super</code> dan kembalikan nilai yang dihasilkan pada akhir implementasi Anda. <br></blockquote>  Bagaimana cara mengetahui <code>parallaxValue</code> ?  Mari kita hitung berapa banyak yang Anda butuhkan untuk memindahkan pusat sel sehingga berdiri di tengah.  Jika jarak ini lebih besar dari lebar sel, maka palu di atasnya.  Kalau tidak, bagi jarak ini dengan lebar <b>sel</b> .  Semakin dekat jarak ini dengan nol, semakin lemah efek paralaksnya. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParallaxLayoutAttributes</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UICollectionViewLayoutAttributes</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parallaxValue: <span class="hljs-type"><span class="hljs-type">CGFloat?</span></span> }​ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PreviewLayout</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UICollectionViewFlowLayout</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> offsetBetweenCells: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> = <span class="hljs-number"><span class="hljs-number">44</span></span>​ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldInvalidateLayout</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(forBoundsChange newBounds: CGRect)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> }​ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">var</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">layoutAttributesClass</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnyClass</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">ParallaxLayoutAttributes</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> }​ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">layoutAttributesForElements</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rect: CGRect)</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">UICollectionViewLayoutAttributes</span></span>]? { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.layoutAttributesForElements(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: rect)? .compactMap { $<span class="hljs-number"><span class="hljs-number">0</span></span>.copy() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">ParallaxLayoutAttributes</span></span> } .compactMap(prepareAttributes) }​ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepareAttributes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(attributes: ParallaxLayoutAttributes)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">ParallaxLayoutAttributes</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> collectionView = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.collectionView <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> attributes }​ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> width = itemSize.width <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> centerX = width / <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> distanceToCenter = attributes.center.x - collectionView.contentOffset.x <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> relativeDistanceToCenter = (distanceToCenter - centerX) / width​ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(relativeDistanceToCenter) &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span> { attributes.parallaxValue = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> attributes.transform = .identity } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { attributes.parallaxValue = relativeDistanceToCenter attributes.transform = <span class="hljs-type"><span class="hljs-type">CGAffineTransform</span></span>(translationX: relativeDistanceToCenter * offsetBetweenCells, y: <span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> attributes } }</code> </pre> <div style="text-align:center;"><img src="https://habrastorage.org/webt/2u/pw/f3/2upwf3rrqmsjxh-btqrm3zau7tm.png"></div><br><br><img src="https://habrastorage.org/webt/bz/x_/ol/bzx_olvusogre4usqir2uvl3uxm.png" alt="gambar"><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fx/pi/9z/fxpi9zj22hrlkywk5ptjieqq9ma.png"></div><br>  Ketika koleksi menerima atribut yang diperlukan, sel <b>menerapkannya</b> .  Perilaku ini dapat ditimpa dalam subkelas sel.  Mari kita <code>imageView</code> pada nilainya tergantung pada <code>parallaxValue</code> .  Namun, untuk pengalihan gambar dengan <code>contentMode == .aspectFit</code> agar berfungsi dengan benar, ini tidak cukup, karena bingkai gambar tidak sesuai dengan bingkai <code>imageView</code> , di mana konten dipotong ketika <code>clipsToBounds == true</code> .  Pasang topeng yang sesuai dengan ukuran gambar dengan <code>contentMode</code> sesuai dan kami akan memperbaruinya jika perlu.  Sekarang semuanya berfungsi! <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PreviewCollectionViewCell</span></span></span><span class="hljs-class"> </span></span>{​ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">layoutSubviews</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {​ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.layoutSubviews() <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> imageSize = imageView.image?.size <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> imageRect = <span class="hljs-type"><span class="hljs-type">AVMakeRect</span></span>(aspectRatio: imageSize, insideRect: bounds)​ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> path = <span class="hljs-type"><span class="hljs-type">UIBezierPath</span></span>(rect: imageRect) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> shapeLayer = <span class="hljs-type"><span class="hljs-type">CAShapeLayer</span></span>() shapeLayer.path = path.cgPath layer.mask = shapeLayer } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> layoutAttributes: UICollectionViewLayoutAttributes)</span></span></span></span> {​ <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> attrs = layoutAttributes <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">ParallaxLayoutAttributes</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.apply(layoutAttributes) } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> parallaxValue = attrs.parallaxValue ?? <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> transition = -(bounds.width * <span class="hljs-number"><span class="hljs-number">0.3</span></span> * parallaxValue) imageView.transform = <span class="hljs-type"><span class="hljs-type">CGAffineTransform</span></span>(translationX: transition, y: .zero) } }</code> </pre> <div style="text-align:center;"><img src="https://habrastorage.org/webt/j_/9e/-h/j_9e-hdvix9nueitnhf0elsk80o.png"></div><br><br><h3>  2. Elemen-elemen koleksi kecil terpusat </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/6cc/d9e/a78/6ccd9ea78faa45a085233d593c6feddb.gif"><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/c9/ld/ra/c9ldral4qoinyvhoacyfveqbwtm.png"></div><br>  Semuanya sangat sederhana di sini.  Efek ini dapat dicapai dengan mengatur <code>inset</code> besar di kiri dan kanan.  Ketika menggulir ke kanan / kiri, perlu untuk mulai <code>bouncing</code> hanya ketika sel terakhir telah meninggalkan konten yang terlihat.  Artinya, konten yang terlihat harus sama dengan ukuran sel. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThumbnailFlowLayout</span></span></span><span class="hljs-class"> </span></span>{​ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> farInset: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> collection = collectionView <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> .zero } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (collection.bounds.width - itemSize.width) / <span class="hljs-number"><span class="hljs-number">2</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> insets: <span class="hljs-type"><span class="hljs-type">UIEdgeInsets</span></span> { <span class="hljs-type"><span class="hljs-type">UIEdgeInsets</span></span>(top: .zero, <span class="hljs-keyword"><span class="hljs-keyword">left</span></span>: farInset, bottom: .zero, <span class="hljs-keyword"><span class="hljs-keyword">right</span></span>: farInset) }​ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { collectionView?.contentInset = insets <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.prepare() } }</code> </pre> <div style="text-align:center;"><img src="https://habrastorage.org/webt/vv/me/ty/vvmetyazz7-6mzze8-7knxoasxw.png"></div><br><br><img src="https://habrastorage.org/webt/hr/qa/k6/hrqak6wkoeqsf7nvy8bky_tauym.jpeg" alt="gambar"><div style="text-align:center;"><img src="https://habrastorage.org/webt/he/pk/br/hepkbrq20vpteyatek3hv8pi8mg.png"></div><br><br>  Lebih lanjut tentang pemusatan: ketika koleksi selesai bergulir, tata letak meminta <code>contentOffset</code> untuk berhenti.  Untuk melakukan ini, <code>targetContentOffset(forProposedContentOffset:withScrollingVelocity:)</code> .  Apple: <br><blockquote>  Jika Anda ingin perilaku pengguliran untuk snap ke batas-batas tertentu, Anda dapat menimpa metode ini dan menggunakannya untuk mengubah titik di mana untuk berhenti.  Misalnya, Anda mungkin menggunakan metode ini untuk selalu berhenti menggulir pada batas antara item, sebagai lawan berhenti di tengah item. <br></blockquote>  Untuk membuat semuanya indah, kita akan <b>selalu</b> berhenti di tengah sel terdekat.  Menghitung pusat sel terdekat adalah tugas yang agak sepele, tetapi Anda harus berhati-hati dan mempertimbangkan <code>contentInset</code> . <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">targetContentOffset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(forProposedContentOffset proposedContentOffset: CGPoint, withScrollingVelocity velocity: CGPoint)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CGPoint</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> collection = collectionView <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.targetContentOffset(forProposedContentOffset: proposedContentOffset, withScrollingVelocity: velocity) } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cellWithSpacing = itemSize.width + config.distanceBetween <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> relative = (proposedContentOffset.x + collection.contentInset.<span class="hljs-keyword"><span class="hljs-keyword">left</span></span>) / cellWithSpacing <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> leftIndex = <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, floor(relative)) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rightIndex = <span class="hljs-built_in"><span class="hljs-built_in">min</span></span>(ceil(relative), <span class="hljs-type"><span class="hljs-type">CGFloat</span></span>(itemsCount)) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> leftCenter = leftIndex * cellWithSpacing - collection.contentInset.<span class="hljs-keyword"><span class="hljs-keyword">left</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rightCenter = rightIndex * cellWithSpacing - collection.contentInset.<span class="hljs-keyword"><span class="hljs-keyword">left</span></span>​ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(leftCenter - proposedContentOffset.x) &lt; <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(rightCenter - proposedContentOffset.x) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: leftCenter, y: proposedContentOffset.y) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: rightCenter, y: proposedContentOffset.y) } }</code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n4/dj/ed/n4djedqhgual-kqq4o3vg-mjxay.gif"></div><div style="text-align:center;"><img src="https://habrastorage.org/webt/0x/bj/xn/0xbjxn8vk5gxiuwvjvjklvhfusa.png"></div><br><br><h3>  3. Ukuran dinamis dari elemen koleksi kecil </h3><br>  Jika Anda menggulir koleksi besar, <code>contentOffset</code> berubah untuk yang kecil <code>contentOffset</code> .  Selain itu, sel pusat dari koleksi kecil tidak sebesar yang lain.  Sel samping memiliki ukuran tetap, dan sel pusat bertepatan dengan rasio aspek dari gambar yang dikandungnya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6e3/c61/03e/6e3c6103e3602c9a3cbf0b7553a05386.gif"><div style="text-align:center;"><img src="https://habrastorage.org/webt/hw/8q/ma/hw8qma82pik2sus_ul5rbvu8rbm.png"></div><br>  Anda dapat menggunakan teknik yang sama seperti dalam kasus paralaks.  Mari kita membuat <code>UICollectionViewFlowLayout</code> khusus untuk koleksi kecil dan mendefinisikan ulang <code>prepareAttributes(attributes:</code> Mengingat bahwa lebih lanjut logika tata letak koleksi kecil akan rumit, kami akan membuat entitas terpisah untuk menyimpan dan menghitung geometri sel. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cell</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> indexPath: <span class="hljs-type"><span class="hljs-type">IndexPath</span></span>​ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dims: <span class="hljs-type"><span class="hljs-type">Dimensions</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state: <span class="hljs-type"><span class="hljs-type">State</span></span>​ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(new state: State)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Cell</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">Cell</span></span>(indexPath: indexPath, dims: dims, state: state) } }​ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cell</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dimensions</span></span></span><span class="hljs-class"> </span></span>{​ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> defaultSize: <span class="hljs-type"><span class="hljs-type">CGSize</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> aspectRatio: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> inset: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> insetAsExpanded: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> }​ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> </span></span>{​ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> expanding: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span>​ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> `<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>`: <span class="hljs-type"><span class="hljs-type">State</span></span> { <span class="hljs-type"><span class="hljs-type">State</span></span>(expanding: .zero) } } }</code> </pre> <div style="text-align:center;"><img src="https://habrastorage.org/webt/0c/ma/im/0cmaim03nqx9dpkohrfumymr11a.png"></div><br>  <code>UICollectionViewFlowLayout</code> memiliki properti <code>collectionViewContentSize</code> yang menentukan ukuran area yang dapat digulir.  Agar tidak menyulitkan hidup kita, mari kita biarkan konstan, terlepas dari ukuran sel pusat.  Untuk geometri yang benar untuk setiap sel, Anda perlu mengetahui <code>aspectRatio</code> gambar dan keterpencilan pusat sel dari <code>contentOffset</code> .  Semakin dekat sel, semakin dekat ukurannya. <code>size.width / size.height</code> <code>aspectRatio</code> . <code>aspectRatio</code> ke <code>aspectRatio</code> .  Saat mengubah ukuran sel tertentu, pindahkan sel yang tersisa (ke kanan dan kiri) menggunakan <code>affineTransform</code> .  Ternyata untuk menghitung geometri sel tertentu, Anda perlu mengetahui atribut tetangga (terlihat). <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cell</span></span></span><span class="hljs-class"> </span></span>{​ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attributes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(from layout: ThumbnailLayout, with sideCells: [Cell])</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UICollectionViewLayoutAttributes?</span></span> {​ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> attributes = layout.layoutAttributesForItem(at: indexPath)​ attributes?.size = size attributes?.center = center​ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> translate = sideCells.<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>) { (current, cell) -&gt; <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> indexPath &lt; cell.indexPath { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current - cell.additionalWidth / <span class="hljs-number"><span class="hljs-number">2</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> indexPath &gt; cell.indexPath { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current + cell.additionalWidth / <span class="hljs-number"><span class="hljs-number">2</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current } attributes?.transform = <span class="hljs-type"><span class="hljs-type">CGAffineTransform</span></span>(translationX: translate, y: .zero)​ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> attributes } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> additionalWidth: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> { (dims.defaultSize.height * dims.aspectRatio - dims.defaultSize.width) * state.expanding } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> size: <span class="hljs-type"><span class="hljs-type">CGSize</span></span> { <span class="hljs-type"><span class="hljs-type">CGSize</span></span>(width: dims.defaultSize.width + additionalWidth, height: dims.defaultSize.height) } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> center: <span class="hljs-type"><span class="hljs-type">CGPoint</span></span> { <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span>(indexPath.row) * (dims.defaultSize.width + dims.inset) + dims.defaultSize.width / <span class="hljs-number"><span class="hljs-number">2</span></span>, y: dims.defaultSize.height / <span class="hljs-number"><span class="hljs-number">2</span></span>) } }</code> </pre> <br>  <code>state.expanding</code> dianggap hampir sama dengan <code>parallaxValue</code> . <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index: IndexPath, offsetX: CGFloat)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Cell</span></span> {​ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cell = <span class="hljs-type"><span class="hljs-type">Cell</span></span>( indexPath: index, dims: <span class="hljs-type"><span class="hljs-type">Cell</span></span>.<span class="hljs-type"><span class="hljs-type">Dimensions</span></span>( defaultSize: itemSize, aspectRatio: dataSource(index.row), inset: config.distanceBetween, insetAsExpanded: config.distanceBetweenFocused), state: .<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>)​ <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> attribute = cell.attributes(from: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, with: []) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell }​ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cellOffset = attribute.center.x - itemSize.width / <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> widthWithOffset = itemSize.width + config.distanceBetween <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(cellOffset - offsetX) &lt; widthWithOffset { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> expanding = <span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(cellOffset - offsetX) / widthWithOffset <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell.updated(by: .expand(expanding)) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell }​ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">layoutAttributesForElements</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rect: CGRect)</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">UICollectionViewLayoutAttributes</span></span>]? { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> ..&lt; itemsCount) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { <span class="hljs-type"><span class="hljs-type">IndexPath</span></span>(row: $<span class="hljs-number"><span class="hljs-number">0</span></span>, section: <span class="hljs-number"><span class="hljs-number">0</span></span>) } .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { cell(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: $<span class="hljs-number"><span class="hljs-number">0</span></span>, offsetX: offsetWithoutInsets.x) } .compactMap { $<span class="hljs-number"><span class="hljs-number">0</span></span>.attributes(from: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, with: cells) } }</code> </pre> <br><br><h3>  4. Logika penempatan unsur-unsur sel kecil tidak hanya bergantung pada contentOffset, tetapi juga pada interaksi pengguna </h3><br>  Saat pengguna menggulir koleksi kecil, semua sel memiliki ukuran yang sama.  Saat menggulir koleksi besar, ini tidak benar.  ( <i>lihat gifs 3 dan 5</i> ).  Mari kita menulis animator yang akan memperbarui properti tata letak <code>ThumbnailLayout</code> .  Animator akan menyimpan <code>DisplayLink</code> dalam dirinya sendiri dan memanggil blok 60 kali per detik, memberikan akses ke kemajuan saat ini.  Sangat mudah untuk <code>easing functions</code> berbagai <code>easing functions</code> ke animator.  Implementasinya dapat dilihat di github pada tautan di akhir posting. <br><br>  Mari kita masukkan properti <code>ThumbnailLayout</code> di <code>ThumbnailLayout</code> , dimana <code>expanding</code> semua <code>Cell</code> akan dikalikan.  Ternyata <code>aspectRatio</code> mengatakan berapa banyak <code>aspectRatio</code> gambar tertentu akan mempengaruhi ukurannya jika menjadi terpusat.  Dengan <code>expandingRate == 0</code> semua sel akan berukuran sama.  Di awal gulir koleksi kecil, kami akan menjalankan animator yang menetapkan <code>expandingRate</code> ke 0, dan di akhir gulir, menjadi sebaliknya. Bahkan, saat memperbarui tata letak, ukuran sel pusat dan sel samping akan berubah.  Tidak <code>contentOffset</code> - <code>contentOffset</code> dengan <code>contentOffset</code> dan menyentak! <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScrollAnimation</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class"> </span></span>{​ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> `</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Type</span></span></span><span class="hljs-class">` </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> begin <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> end }​ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> type: <span class="hljs-type"><span class="hljs-type">Type</span></span>​ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(completion: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> toValue: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.type == .begin ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> currentExpanding = thumbnails.config.expandingRate <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> duration = <span class="hljs-type"><span class="hljs-type">TimeInterval</span></span>(<span class="hljs-number"><span class="hljs-number">0.15</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(currentExpanding - toValue))​ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> animator = <span class="hljs-type"><span class="hljs-type">Animator</span></span>(onProgress: { current, <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rate = currentExpanding + (toValue - currentExpanding) * current <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.thumbnails.config.expandingRate = rate <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.thumbnails.invalidateLayout() }, easing: .easeInOut)​ animator.animate(duration: duration) { <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> completion() } } }</code> </pre> <div style="text-align:center;"><img src="https://habrastorage.org/webt/sy/sz/ff/syszffr_19xmccnvyw-do9lcqhy.png"></div><br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scrollViewWillBeginDragging</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scrollView: UIScrollView)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> scrollView == thumbnails.collectionView { handle(event: .beginScrolling) <span class="hljs-comment"><span class="hljs-comment">// call ScrollAnimation.run(type: .begin) } }​ func scrollViewDidEndDragging(_ scrollView: UIScrollView, willDecelerate decelerate: Bool) { if scrollView == thumbnails.collectionView &amp;&amp; !decelerate { thumbnailEndScrolling() } }​ func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) { if scrollView == thumbnails.collectionView { thumbnailEndScrolling() } }​ func thumbnailEndScrolling() { handle(event: .endScrolling) // call ScrollAnimation.run(type: .end) }</span></span></code> </pre> <div style="text-align:center;"><img src="https://habrastorage.org/webt/nu/v0/x7/nuv0x7phez1lg2osumphtri1wao.png"></div><br><br><h3>  5. Animasi khusus untuk dipindahkan dan dihapus </h3><br>  Ada banyak artikel yang memberi tahu cara membuat animasi khusus untuk memperbarui sel, tetapi dalam kasus kami mereka tidak akan membantu kami.  Artikel dan tutorial menjelaskan cara mengganti atribut sel yang diperbarui.  Dalam kasus kami, mengubah tata letak sel yang dihapus menyebabkan efek samping - <code>expanding</code> sel tetangga, yang cenderung menggantikan yang dihapus selama animasi, berubah. <br><br>  Memperbarui konten di <code>UICollectionViewFlowLayout</code> berfungsi sebagai berikut.  Setelah menghapus / menambahkan sel, metode <code>prepare(forCollectionViewUpdates:)</code> dimulai, memberikan array <code>UICollectionViewUpdateItem</code> , yang memberi tahu kita sel mana di mana indeks diperbarui / dihapus / ditambahkan.  Selanjutnya, tata letak akan memanggil sekelompok metode <br><br><pre> <code class="swift hljs">finalLayoutAttributesForDisappearingItem(at:) initialLayoutAttributesForAppearingDecorationElement(ofKind:at:)</code> </pre> <br>  dan teman-teman mereka untuk dekorasi / pemandangan tambahan.  Ketika atribut untuk data yang diperbarui diterima, <code>finalizeCollectionViewUpdates</code> dipanggil.  Apple: <br><blockquote>  Tampilan koleksi memanggil metode ini sebagai langkah terakhir sebelum melanjutkan untuk menganimasikan perubahan apa pun yang terjadi.  Metode ini disebut dalam blok animasi yang digunakan untuk melakukan semua penyisipan, penghapusan, dan memindahkan animasi sehingga Anda dapat membuat animasi tambahan menggunakan metode ini sesuai kebutuhan.  Jika tidak, Anda dapat menggunakannya untuk melakukan tugas-tugas menit terakhir yang terkait dengan mengelola informasi status objek tata letak Anda. <br></blockquote>  Masalahnya adalah kita dapat mengkhususkan atribut hanya untuk sel yang <b>diperbarui</b> , dan kita perlu mengubahnya untuk semua sel, dan dengan cara yang berbeda.  Sel tengah baru harus mengubah <code>aspectRatio</code> , dan sel samping harus <code>transform</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/223/6ad/9e0/2236ad9e0cff5fac58a4b490570340c4.gif"><div style="text-align:center;"><img src="https://habrastorage.org/webt/1b/wa/pf/1bwapfugwecsrwjnnw3imlnviyk.png"></div><br>  Setelah memeriksa bagaimana animasi default sel pengumpulan selama penghapusan / penyisipan bekerja, diketahui bahwa lapisan lapisan dalam <code>finalizeCollectionViewUpdates</code> berisi <code>CABasicAnimation</code> , yang dapat diubah di sana jika Anda ingin menyesuaikan animasi untuk sel yang tersisa.  Keadaan menjadi lebih buruk ketika log menunjukkan bahwa antara <code>performBatchUpdates</code> dan <code>performBatchUpdates</code> <code>prepare(forCollectionViewUpdates:)</code> <code>prepareAttributes(attributes:)</code> <code>prepare(forCollectionViewUpdates:)</code> dipanggil, dan mungkin sudah ada jumlah sel yang salah, meskipun <code>collectionViewUpdates</code> belum dimulai, sangat sulit untuk mempertahankan dan memahami hal ini.  Apa yang bisa dilakukan tentang ini?  Anda dapat menonaktifkan animasi bawaan ini! <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(forCollectionViewUpdates updateItems: [UICollectionViewUpdateItem])</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.prepare(forCollectionViewUpdates: updateItems) <span class="hljs-type"><span class="hljs-type">CATransaction</span></span>.begin() <span class="hljs-type"><span class="hljs-type">CATransaction</span></span>.setDisableActions(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) }​ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finalizeCollectionViewUpdates</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-type"><span class="hljs-type">CATransaction</span></span>.commit() }</code> </pre><div style="text-align:center;"><img src="https://habrastorage.org/webt/69/ja/x4/69jax4yhfpsjyr5jej-xxpb6pkc.png"></div><br>  Berbekal animator yang sudah ditulis, kami akan melakukan semua animasi yang diperlukan berdasarkan permintaan untuk dihapus, dan kami akan meluncurkan pembaruan <code>dataSource</code> di akhir animasi.  Dengan demikian, kami akan menyederhanakan animasi koleksi saat memperbarui, karena kami sendiri mengontrol kapan jumlah sel akan berubah. <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( at indexPath: IndexPath, dataSourceUpdate: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>, completion: (() -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)?) {​ <span class="hljs-type"><span class="hljs-type">DeleteAnimation</span></span>(thumbnails: thumbnails, preview: preview, index: indexPath).run { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> previousCount = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.thumbnails.itemsCount <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> previousCount == indexPath.row + <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.activeIndex = previousCount - <span class="hljs-number"><span class="hljs-number">1</span></span> } dataSourceUpdate() <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.thumbnails.collectionView?.deleteItems(at: [indexPath]) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.preview.collectionView?.deleteItems(at: [indexPath]) completion?() } }</code> </pre> <br>  Bagaimana cara kerja animasi seperti itu?  Di <code>ThumbnailLayout</code> mari kita simpan brosur opsional yang memperbarui geometri sel tertentu. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThumbnailLayout</span></span></span><span class="hljs-class"> </span></span>{​ <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">CellUpdate</span></span> = (<span class="hljs-type"><span class="hljs-type">Cell</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Cell</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> updates: [<span class="hljs-type"><span class="hljs-type">IndexPath</span></span>: <span class="hljs-type"><span class="hljs-type">CellUpdate</span></span>] = [:] <span class="hljs-comment"><span class="hljs-comment">// ... override func layoutAttributesForElements(in rect: CGRect) -&gt; [UICollectionViewLayoutAttributes]? {​ let cells = (0 ..&lt; itemsCount) .map { IndexPath(row: $0, section: 0) } .map { cell(for: $0, offsetX: offsetWithoutInsets.x) } .map { cell -&gt; Cell in if let update = self.config.updates[cell.indexPath] { return update(cell) } return cell } return cells.compactMap { $0.attributes(from: self, with: cells) } }</span></span></code> </pre> <br>  Dengan alat seperti itu, Anda dapat melakukan apa saja dengan geometri sel, melempar pembaruan selama karya animator dan menghapusnya sebagai pujian.  Ada juga kemungkinan menggabungkan pembaruan. <br><br><pre> <code class="swift hljs">updates[index] = newUpdate(updates[index])</code> </pre><br>  Menghapus kode animasi agak rumit, terletak di file <i>DeleteAnimation.swift</i> di repositori.  Animasi perpindahan fokus antar sel diimplementasikan dengan cara yang sama. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/001/d8d/ca0/001d8dca06df6b68773652760a019bf3.gif"><div style="text-align:center;"><img src="https://habrastorage.org/webt/mi/6q/bs/mi6qbskcng_u5ehyixy1q0xp_ce.png"></div><br><br><h3>  6. Indeks sel "aktif" tidak hilang ketika mengubah orientasi </h3><br>  <code>scrollViewDidScroll(_ scrollView:)</code> dipanggil bahkan jika Anda cukup memberi nilai pada <code>contentOffset</code> , dan juga saat mengubah orientasi.  Ketika gulir dua koleksi disinkronkan, beberapa masalah mungkin timbul selama pembaruan tata letak.  Trik berikut membantu: pada pembaruan tata letak, Anda dapat mengatur <code>scrollView.delegate</code> ke <code>nil</code> . <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScrollSynchronizer</span></span></span><span class="hljs-class"> </span></span>{​ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { preview.collectionView?.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> thumbnails.collectionView?.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> }​ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unbind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { preview.collectionView?.delegate = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> thumbnails.collectionView?.delegate = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } }</code> </pre> <br>  Saat memperbarui ukuran sel pada saat perubahan orientasi, akan terlihat seperti ini: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PhotosViewController</span></span></span><span class="hljs-class"> </span></span>{​ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewWillTransition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewWillTransition(to: size, with: coordinator)​ contentView.synchronizer.unbind() coordinator.animate(alongsideTransition: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>?.contentView.synchronizer.bind() } } }</code> </pre> <br>  Agar tidak kehilangan <code>contentOffset</code> diinginkan saat mengubah orientasi, Anda dapat memperbarui <code>targetIndexPath</code> di <code>scrollView.delegate</code> .  Ketika Anda mengubah orientasi, tata letak akan dinonaktifkan jika Anda menimpa <code>shouldInvalidateLayout(forBoundsChange:)</code> .  Ketika mengubah <code>bounds</code> tata letak akan meminta untuk mengklarifikasi <code>contentOffset</code> , untuk memperjelasnya, Anda perlu mendefinisikan kembali <code>targetContentOffset(forProposedContentOffset:)</code> .  Apple: <br><blockquote>  Selama pembaruan tata letak, atau saat beralih di antara tata letak, tampilan koleksi memanggil metode ini untuk memberi Anda kesempatan untuk mengubah offset konten yang diusulkan untuk digunakan pada akhir animasi.  Anda dapat mengganti metode ini jika animasi atau transisi dapat menyebabkan item diposisikan dengan cara yang tidak optimal untuk desain Anda. <br><br>  Tampilan pengumpulan memanggil metode ini setelah memanggil metode <code>prepare()</code> dan <code>collectionViewContentSize</code> . </blockquote><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">targetContentOffset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(forProposedContentOffset proposedContentOffset: CGPoint)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CGPoint</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> targetOffset = <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.targetContentOffset(forProposedContentOffset: proposedContentOffset) <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> layoutHandler = layoutHandler <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> targetOffset } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> offset = <span class="hljs-type"><span class="hljs-type">CGFloat</span></span>(layoutHandler.targetIndex) / <span class="hljs-type"><span class="hljs-type">CGFloat</span></span>(itemsCount) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>( x: collectionViewContentSize.width * offset - farInset, y: targetOffset.y) }</code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i5/5r/sf/i55rsfdujvblk7om3yq2yerabhu.gif"></div><div style="text-align:center;"><img src="https://habrastorage.org/webt/ng/ls/6w/ngls6wjfkhkajrg3706i_g11lyo.png"></div><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terima kasih sudah membaca! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semua kode dapat ditemukan di </font></font><a href="https://github.com/YetAnotherRzmn/PhotosApp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/YetAnotherRzmn/PhotosApp</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id477734/">https://habr.com/ru/post/id477734/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id477722/index.html">Panduan Gaya Google di C ++. Bagian 8</a></li>
<li><a href="../id477724/index.html">Habraseminar merek SDM: tentang bakat, perburuan, dan konten</a></li>
<li><a href="../id477728/index.html">Apa yang harus dilakukan memimpin tim sehingga tim tidak kehabisan tenaga</a></li>
<li><a href="../id477730/index.html">ChipWhisperer: Serangan Energi pada Magma</a></li>
<li><a href="../id477732/index.html">Klasifikasi jari yang salah dari sistem navigasi bawah air</a></li>
<li><a href="../id477736/index.html">Jalur penguji: dari "rem tangan" ke otomatisasi</a></li>
<li><a href="../id477738/index.html">iKassa atau bagaimana kami menjinakkan "kasir digital"</a></li>
<li><a href="../id477740/index.html">Dan ke mana harus melihat teleskop ini dengan mata Anda?</a></li>
<li><a href="../id477742/index.html">"Halo, Checkmarx!" Cara menulis permintaan untuk Checkmarx SAST dan menemukan kerentanan keren</a></li>
<li><a href="../id477744/index.html">Mengapa profesional terkadang membuat aplikasi yang buruk?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>