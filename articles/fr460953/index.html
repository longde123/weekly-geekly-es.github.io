<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÖüèø üë©‚Äçüé® üóø Les pointeurs sont complexes, ou qu'est-ce qui est stock√© dans un octet? ‚úåüèæ üßìüèΩ üë®üèΩ‚Äçüé§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je vous pr√©sente la traduction de l'article "Les pointeurs sont compliqu√©s, ou: qu'est-ce qu'un octet?" paternit√© de Ralf Jung. 


 Cet...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Les pointeurs sont complexes, ou qu'est-ce qui est stock√© dans un octet?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460953/"><p>  Bonjour, Habr!  Je vous pr√©sente la traduction de l'article "Les pointeurs sont compliqu√©s, ou: qu'est-ce qu'un octet?"  paternit√© de Ralf Jung. </p><br><p>  Cet √©t√©, je travaille √† nouveau √† temps plein sur Rust, et je vais √† nouveau (entre autres) travailler sur le ¬´mod√®le de m√©moire¬ª pour Rust / MIR.  Cependant, avant de parler de mes id√©es, je dois enfin dissiper le mythe selon lequel ¬´les pointeurs sont simples: ce ne sont que des chiffres¬ª.  Les deux parties de cette d√©claration sont erron√©es, au moins dans les langages avec des fonctionnalit√©s dangereuses, comme Rust ou C: les pointeurs ne peuvent pas √™tre appel√©s nombres premiers ou (ordinaires). </p><br><p>  Je voudrais √©galement discuter de la partie du mod√®le de m√©moire qui doit √™tre abord√©e avant de parler des parties les plus complexes: sous <em>quelle forme les</em> donn√©es sont-elles stock√©es en m√©moire?  Une m√©moire se compose d'octets, d'unit√©s adressables minimales et des √©l√©ments les plus petits accessibles (au moins sur la plupart des plates-formes), mais quelles sont les valeurs d'octets possibles?  Encore une fois, il s'av√®re que ¬´c'est juste un nombre √† 8 bits¬ª ne convient pas comme r√©ponse. <a name="habracut"></a></p><br><p>  J'esp√®re qu'apr√®s avoir lu ce post, vous serez d'accord avec moi concernant les deux d√©clarations. </p><br><h1 id="ukazateli-slozhny">  Les pointeurs sont compliqu√©s </h1><br><p>  Quel est le probl√®me avec "les pointeurs sont des nombres r√©guliers"?  Examinons l'exemple suivant: (J'utilise C ++ ici, car l'√©criture de code non s√©curis√© en C ++ est plus facile que d'√©crire en Rust, et le code non s√©curis√© est juste l'endroit o√π les probl√®mes apparaissent. Insecure Rust et C ont tous les m√™mes probl√®mes que et C ++). </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> y = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; y[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-comment"><span class="hljs-comment">/* -     */</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x_ptr = &amp;x[i]; *x_ptr = <span class="hljs-number"><span class="hljs-number">23</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre> <br><p>  Optimiser la derni√®re lecture de y [0] avec un retour de 42 est toujours tr√®s b√©n√©fique.  La justification de cette optimisation est que la modification de x_ptr qui pointe vers x ne peut pas changer y. </p><br><p>  Cependant, lorsque nous traitons des langages de bas niveau tels que C ++, nous pouvons violer cette hypoth√®se en attribuant √† i la valeur yx.  Puisque &amp; x [i] est identique √† x + i, nous √©crivons 23 dans &amp; y [0]. </p><br><p>  Bien s√ªr, cela n'emp√™che pas les compilateurs C ++ d'effectuer de telles optimisations.  Pour r√©soudre ce probl√®me, la norme indique que notre code a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">UB</a> . </p><br><p>  Premi√®rement, il n'est pas autoris√© d'effectuer des op√©rations arithm√©tiques sur des pointeurs (comme dans le cas de &amp; x [i]), si dans ce cas le pointeur <a href="">d√©passe les limites du tableau</a> .  Notre programme viole cette r√®gle: x [i] va au-del√† de x, donc c'est UB.  En d'autres termes, m√™me le <em>calcul de</em> la valeur x_ptr est UB, donc nous n'arrivons m√™me pas √† l'endroit o√π nous voulons <em>utiliser</em> ce pointeur. </p><br><p>  (Il s'av√®re que i = yx est √©galement UB, car <a href="">seuls les pointeurs pointant vers la m√™me allocation de m√©moire peuvent √™tre soustraits</a> . Cependant, nous pourrions √©crire i = ((size_t) y - (size_t) x) / sizeof (int) pour contourner c'est une limitation.) </p><br><p>  Mais nous n'avons pas encore fini: cette r√®gle a la seule exception que nous pouvons utiliser √† notre avantage.  Si l'op√©ration arithm√©tique calcule la valeur du pointeur vers l'adresse <em>exactement apr√®s la</em> fin du tableau, alors tout est en ordre.  (Cette exception est n√©cessaire pour calculer vec.end () pour les boucles les plus courantes en C ++ 98.) </p><br><p>  Modifions un peu l'exemple: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> y = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; y[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x_ptr = x+<span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    if (x_ptr == &amp;y[0]) *x_ptr = 23; return y[0]; }</span></span></code> </pre> <br><p>  Imaginez maintenant que x et y ont √©t√© allou√©s l' <em>un apr√®s l'autre</em> , y ayant une adresse plus grande.  Alors x_ptr pointe <em>vers le d√©but de</em> y!  La condition est alors vraie et l'affectation se produit.  Dans le m√™me temps, il n'y a pas d'UB en raison de la sortie du pointeur √† l'√©tranger. </p><br><p>  Il semble que cela ne permette pas l'optimisation.  Cependant, le standard C ++ a un autre atout dans sa manche pour aider les cr√©ateurs de compilateurs: en fait, il ne nous permet pas d'utiliser x_ptr.  Selon ce que la norme dit sur l' <a href="">ajout de nombres aux pointeurs</a> , x_ptr pointe vers l'adresse apr√®s le dernier √©l√©ment du tableau.  Il <em>ne</em> pointe <em>pas</em> vers un √©l√©ment sp√©cifique d'un autre objet, <em>m√™me s'ils ont la m√™me adresse</em> .  (Au moins, c'est une interpr√©tation courante de la norme sur la base de laquelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LLVM optimise ce code</a> .) </p><br><p>  Et m√™me si x_ptr et &amp; y [0] pointent vers la m√™me <em>adresse</em> , cela ne fait pas d'eux le <em>m√™me pointeur</em> , c'est-√†-dire qu'ils ne peuvent pas √™tre utilis√©s de mani√®re interchangeable: &amp; y [0] pointe vers le premier √©l√©ment de y;  x_ptr pointe vers l'adresse apr√®s x.  Si nous rempla√ßons * x_ptr = 23 par la cha√Æne * &amp; y [0] = 0, nous changerons la valeur du programme, m√™me si l'√©galit√© des deux pointeurs a √©t√© v√©rifi√©e. </p><br><p>  Cela m√©rite d'√™tre r√©p√©t√©: </p><br><blockquote>  Ce n'est pas parce que deux pointeurs pointent vers la m√™me adresse qu'ils sont √©gaux et peuvent √™tre utilis√©s de mani√®re interchangeable. </blockquote><p>  Oui, cette diff√©rence est insaisissable.  En fait, cela provoque toujours des diff√©rences dans les programmes compil√©s avec LLVM et GCC. </p><br><p>  Notez √©galement que cette r√®gle one-after n'est pas le seul endroit en C / C ++ o√π l'on peut observer un tel effet.  Un autre exemple est le mot-cl√© restrict en C, qui peut √™tre utilis√© pour exprimer que les pointeurs ne se chevauchent pas (ne sont pas √©gaux): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">restrict</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">restrict</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ *x = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x == y) { *y = <span class="hljs-number"><span class="hljs-number">23</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *x; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> foo(&amp;x, &amp;x); }</code> </pre> <br><p>  L'appel test () appelle UB, car deux acc√®s √† la m√©moire dans foo ne doivent pas se produire √† la m√™me adresse.  En rempla√ßant * y par * x dans foo, nous changerons la valeur du programme, et il n'appellera plus UB.  Encore une fois: bien que x et y aient la m√™me adresse, ils ne peuvent pas √™tre utilis√©s de mani√®re interchangeable. </p><br><p>  Les pointeurs ne sont certainement pas que des chiffres. </p><br><h1 id="prostaya-model-ukazateley">  Mod√®le de pointeur simple </h1><br><p>  Alors qu'est-ce qu'un pointeur?  Je ne connais pas la r√©ponse compl√®te.  En fait, c'est un domaine ouvert pour la recherche. </p><br><p>  Un point important: nous examinons ici un <em>mod√®le de</em> pointeur <em>abstrait</em> .  Bien s√ªr, sur un vrai ordinateur, les pointeurs sont des nombres.  Mais un v√©ritable ordinateur n'effectue pas les optimisations que font les compilateurs C ++ modernes.  Si nous √©crivions les programmes ci-dessus dans l'assembleur, il n'y aurait pas d'UB, pas d'optimisations.  C ++ et Rust adoptent une approche plus ¬´sup√©rieure¬ª de la m√©moire et des pointeurs, limitant le programmeur au compilateur.  Lorsqu'il est n√©cessaire de d√©crire formellement ce qu'un programmeur peut et ne peut pas faire dans ces langages, le mod√®le des pointeurs sous forme de nombres est bris√©, nous devons donc trouver autre chose.  Ceci est un autre exemple d'utilisation d'une ¬´machine virtuelle¬ª diff√©rente d'un v√©ritable ordinateur √† des fins de sp√©cification - une id√©e dont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">j'ai parl√© plus t√¥t</a> . </p><br><p>  Voici une phrase simple (en fait, ce mod√®le de pointeurs est utilis√© par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CompCert</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mon travail par RustBelt</a> , ainsi que la fa√ßon dont l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">interpr√©teur miri</a> impl√©mente les <a href="">pointeurs</a> ): un pointeur est une paire d'ID qui identifie de mani√®re unique une zone m√©moire (allocation), et le d√©calage est relatif √† ce domaine.  Si vous √©crivez ceci en rouille: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pointer</span></span></span></span> { alloc_id: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, offset: <span class="hljs-built_in"><span class="hljs-built_in">isize</span></span>, }</code> </pre> <br><p>  Les op√©rations d'ajout (soustraction) d'un nombre √† un pointeur (√† partir d'un pointeur) n'affectent que le d√©calage, et par cons√©quent le pointeur ne peut jamais quitter la zone m√©moire.  La soustraction de pointeurs n'est possible que s'ils appartiennent √† la m√™me zone m√©moire (conform√©ment √† <a href="">C ++</a> ). </p><br><p>  (Comme nous pouvons le voir, la norme C ++ applique ces r√®gles aux tableaux, pas aux zones de m√©moire. Cependant, LLVM les applique au niveau de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la zone</a> .) </p><br><p>  Il s'av√®re (et miri montre la m√™me chose) que ce mod√®le peut bien nous servir.  Nous nous souvenons toujours de la r√©gion de m√©moire √† laquelle appartient le pointeur, afin de pouvoir distinguer le pointeur suivant d'une r√©gion de m√©moire du pointeur au d√©but d'une autre r√©gion.  Ainsi miri peut trouver que notre deuxi√®me exemple (avec &amp; x [8]) a UB. </p><br><h1 id="nasha-model-razvalivaetsya-na-kuski">  Notre mod√®le s'effondre </h1><br><p>  Dans notre mod√®le, les pointeurs, bien qu'ils ne soient pas des nombres, sont au moins simples.  Cependant, ce mod√®le commencera √† s'effondrer sous nos yeux, d√®s que vous vous souviendrez de la conversion des pointeurs en nombres.  Dans miri, la conversion d'un pointeur en un nombre ne fait rien, nous obtenons simplement une variable num√©rique (c'est-√†-dire que son <em>type</em> indique qu'il s'agit d'un nombre) dont la <em>valeur</em> est un pointeur (c'est-√†-dire une paire de zone de m√©moire et un d√©calage).  Cependant, multiplier ce nombre par 2 conduit √† une erreur, car on ne sait pas vraiment ce que signifie "multiplier un tel pointeur abstrait par 2". </p><br><p>  Je dois pr√©ciser: ce n'est <em>pas une</em> bonne solution quand il s'agit de d√©finir la s√©mantique d'un langage.  Cependant, cela fonctionne bien pour l'interpr√®te.  C'est l'approche la plus simple, et nous l'avons choisie car il n'est pas clair comment cela peut √™tre fait autrement (sauf pour ne pas prendre en charge de telles r√©ductions du tout - mais avec leur support, miri peut ex√©cuter plus de programmes): dans notre machine abstraite, il n'y a pas un seul "espace d'adressage", dans lequel toutes les zones de m√©moire allou√©es seraient situ√©es, et tous les pointeurs √©taient mapp√©s √† des num√©ros diff√©rents sp√©cifiques.  Chaque zone de m√©moire est identifi√©e par un ID (masqu√©).  Maintenant, nous pouvons commencer √† ajouter des donn√©es suppl√©mentaires √† notre mod√®le, telles que l'adresse de base pour chaque zone de m√©moire, et l'utiliser d'une mani√®re ou d'une autre pour ramener le num√©ro au pointeur ... et √† ce stade, le processus devient vraiment tr√®s compliqu√©, et, en tout cas, une discussion de cela Les mod√®les ne visent pas √† r√©diger un article.  Son objectif est de discuter de la n√©cessit√© d'un tel mod√®le.  Si vous √™tes int√©ress√©, je vous recommande de lire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce document</a> , qui examine de plus pr√®s l'id√©e ci-dessus d'ajouter une adresse de base. </p><br><p>  En bref, les conversions de pointeurs et de nombres entre eux sont d√©routants et difficiles √† d√©terminer formellement, compte tenu des optimisations discut√©es ci-dessus.  Il existe un conflit entre l'approche de haut niveau requise pour les optimisations et l'approche de bas niveau n√©cessaire pour d√©crire la conversion de pointeurs en nombres et vice versa.  Pour la plupart, nous ignorons simplement ce probl√®me dans miri et, dans la mesure du possible, essayons d'en faire autant que possible en utilisant le mod√®le simple avec lequel nous travaillons.  Une d√©finition compl√®te de langages tels que C ++ ou Rust, bien s√ªr, ne peut pas aller d'une mani√®re aussi simple, elle devrait expliquer ce qui se passe r√©ellement.  Pour autant que je sache, il n'y a pas de solution appropri√©e, mais la recherche universitaire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">approche de la v√©rit√©</a> . </p><br><p>  C'est pourquoi les pointeurs ne sont pas non plus simples. </p><br><h1 id="ot-ukazateley-k-baytam">  Des pointeurs aux octets </h1><br><p>  J'esp√®re avoir avanc√© un argument convaincant selon lequel les nombres ne sont pas le seul type de donn√©es √† prendre en compte si nous voulons d√©crire formellement des langages de bas niveau comme C ++ ou la partie (non s√©curis√©e) de Rust.  Cependant, cela signifie qu'une op√©ration simple comme la lecture d'un octet dans la m√©moire ne peut pas simplement renvoyer u8.  Imaginez que nous <a href="">impl√©mentions memcpy</a> en lisant chaque octet de la source tour √† tour dans une variable locale v, puis stockons cette valeur dans l'emplacement cible.  Mais que faire si cet octet fait partie d'un pointeur?  Si le pointeur est une paire d'ID de zone de m√©moire et de d√©calage, alors quel sera son premier octet?  Nous devons dire √† quoi la valeur de v est √©gale, nous devrons donc en quelque sorte r√©pondre √† cette question.  (Et c'est un probl√®me compl√®tement diff√©rent de celui de la multiplication, qui √©tait dans la section pr√©c√©dente. Nous supposons simplement qu'il existe un type abstrait de Ponter.) </p><br><p>  Nous ne pouvons pas repr√©senter l'octet du pointeur comme une valeur de la plage 0..256 (remarque: ci-apr√®s 0 est activ√©, 256 ne l'est pas).  En g√©n√©ral, si nous utilisons un mod√®le de repr√©sentation de m√©moire na√Øf, la partie ¬´cach√©e¬ª suppl√©mentaire du pointeur (celle qui en fait plus qu'un simple nombre) sera perdue lorsque le pointeur est √©crit en m√©moire et relu.  Nous devrons r√©soudre ce probl√®me, et pour cela, nous devrons √©tendre notre concept d '¬´octet¬ª pour repr√©senter cet √©tat suppl√©mentaire.  Ainsi, l'octet est maintenant <em>soit la</em> valeur de la plage 0..256 ("bits bruts"), <em>soit</em> le ni√®me octet d'un pointeur abstrait.  Si nous devions impl√©menter notre mod√®le de m√©moire dans Rust, cela pourrait ressembler √† ceci: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ByteV1</span></span></span></span> { Bits(<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>), PtrFragment(Pointer, <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>), }</code> </pre> <br><p>  Par exemple, PtrFragment (ptr, 0) repr√©sente le premier octet du pointeur ptr.  Ainsi, memcpy peut "casser" le pointeur en octets s√©par√©s qui repr√©sentent ce pointeur en m√©moire et les copier individuellement.  Sur une architecture 32 bits, la repr√©sentation ptr compl√®te contiendra 4 octets: </p><br><pre> <code class="rust hljs">[PtrFragment(ptr, <span class="hljs-number"><span class="hljs-number">0</span></span>), PtrFragment(ptr, <span class="hljs-number"><span class="hljs-number">1</span></span>), PtrFragment(ptr, <span class="hljs-number"><span class="hljs-number">2</span></span>), PtrFragment(ptr, <span class="hljs-number"><span class="hljs-number">3</span></span>)]</code> </pre> <br><p>  Cette repr√©sentation prend en charge toutes les op√©rations de d√©placement de donn√©es sur des pointeurs au niveau des octets, ce qui est tout √† fait suffisant pour la m√©morisation.  Les op√©rations arithm√©tiques ou binaires ne sont pas enti√®rement prises en charge;  comme indiqu√© ci-dessus, cela n√©cessiterait une repr√©sentation plus complexe des pointeurs. </p><br><h1 id="neinicializirovannaya-pamyat">  M√©moire non initialis√©e </h1><br><p>  Cependant, nous n'avons pas fini avec notre d√©finition de "octet".  Pour d√©crire compl√®tement le comportement du programme, nous devons consid√©rer une autre option: un octet en m√©moire peut √™tre <em>non initialis√©</em> .  La derni√®re d√©finition d'octet ressemblera √† ceci (supposons que nous ayons un type de pointeur pour les pointeurs): </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Byte</span></span></span></span> { Bits(<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>), PtrFragment(Pointer, <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>), Uninit, }</code> </pre> <br><p>  Nous utilisons la valeur Uninit pour tous les octets de la m√©moire allou√©e dans lesquels nous n'avons encore √©crit aucune valeur.  Il est possible de lire la m√©moire non initialis√©e sans probl√®me, mais toute autre <em>action</em> avec ces octets (par exemple, l'arithm√©tique num√©rique) conduit √† UB. </p><br><p>  Ceci est tr√®s similaire aux r√®gles LLVM en ce qui concerne la valeur de poison sp√©cial.  Notez que LLVM a <em>√©galement</em> une valeur undef, qui est utilis√©e pour la m√©moire non initialis√©e et fonctionne un peu diff√©remment.  Cependant, la compilation de notre Uninit en undef est correcte (undef est √† certains √©gards "plus faible"), et il existe des suggestions <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pour supprimer undef de LLVM et utiliser du poison √† la place</a> . </p><br><p>  Vous vous demandez peut-√™tre pourquoi nous avons une valeur sp√©ciale Uninit.  Pourquoi ne pas choisir un b: u8 arbitraire pour chaque nouvel octet, puis utiliser Bits (b) comme valeur initiale?  C'est vraiment une option.  Cependant, tout d'abord, tous les compilateurs sont arriv√©s √† l'approche en utilisant une valeur sp√©ciale pour la m√©moire non initialis√©e.  Ne pas suivre cette approche signifie non seulement causer des probl√®mes de compilation via LLVM, mais √©galement passer en revue toutes les optimisations et s'assurer qu'elles fonctionnent correctement avec ce mod√®le modifi√©.  Le point cl√© ici: vous pouvez toujours remplacer Uninit en toute s√©curit√© par toute autre valeur: toute op√©ration recevant cette valeur entra√Ænera en tout cas UB. </p><br><p>  Par exemple, ce code C est plus facile √† optimiser avec Uninit: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condA()) x = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     ,       ,  condA() //  ,      x. use(x); //  x = 1. }</span></span></code> </pre> <br><p>  Avec Uninit, nous pouvons facilement dire que x a une valeur Uninit ou une valeur de 1, et puisque le remplacement de Uninit par 1 fonctionne, l'optimisation est facilement expliqu√©e.  Sans Uninit, x est ¬´une sorte de motif binaire arbitraire¬ª ou 1, et la m√™me optimisation est plus difficile √† expliquer. </p><br><p>  (Nous pouvons affirmer que nous pouvons √©changer des op√©rations lorsque nous faisons un choix non d√©terministe, mais nous devrons alors prouver que le code qui est difficile √† analyser n'utilise en aucun cas x. Uninit √©vite ce probl√®me avec des preuves inutiles.) </p><br><p>  Enfin, Uninit est le meilleur choix pour les interpr√®tes comme miri.  Ces interpr√®tes ont des probl√®mes avec des op√©rations telles que ¬´s√©lectionner simplement l'une de ces valeurs¬ª (c'est-√†-dire des op√©rations non d√©terministes), car elles ont tendance √† parcourir tous les chemins possibles d'ex√©cution du programme, ce qui signifie qu'elles doivent essayer toutes les valeurs possibles.  L'utilisation de Uninit au lieu d'un mod√®le de bits arbitraire signifie que miri peut vous dire apr√®s l'ex√©cution d'un programme si votre programme utilise de mani√®re incorrecte des valeurs non initialis√©es. </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  Nous avons vu que dans des langages comme C ++ et Rust (contrairement aux vrais ordinateurs) les pointeurs peuvent √™tre diff√©rents m√™me s'ils pointent vers la m√™me adresse, et qu'un octet est plus qu'un simple nombre compris entre 0 et 256.  Par cons√©quent, si en 1978 le langage C pouvait √™tre "assembleur portable", c'est maintenant une affirmation incroyablement erron√©e. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr460953/">https://habr.com/ru/post/fr460953/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr460943/index.html">Comment choisir des cl√©s prometteuses pour le r√©f√©rencement en fonction des pr√©visions de sc√©nario dans Google Data Studio (+ mod√®le)</a></li>
<li><a href="../fr460945/index.html">Exp√©rience de l'utilisation d'un canal de t√©l√©gramme pour accro√Ætre la reconnaissance et la croissance des revenus d'un studio de jeux</a></li>
<li><a href="../fr460947/index.html">WASM Meet Up 1/08</a></li>
<li><a href="../fr460949/index.html">¬´Et l'impossible est possible¬ª: nous transformons une bo√Æte noire en blanc gr√¢ce √† l'analyse binaire</a></li>
<li><a href="../fr460951/index.html">Cr√©er des fonds d'√©cran Android Live</a></li>
<li><a href="../fr460955/index.html">Programme √©ducatif pour transmettre des param√®tres par valeur aux constructeurs et aux setters (C ++ moderne, exemples)</a></li>
<li><a href="../fr460959/index.html">La nouvelle technologie de Microsoft permet aux copies 3D d'une personne r√©elle de parler n'importe quelle langue</a></li>
<li><a href="../fr460961/index.html">Configuration de tests unitaires dans des projets mixtes Swift + Objective-C</a></li>
<li><a href="../fr460965/index.html">Split Controller sans ces storyboards</a></li>
<li><a href="../fr460967/index.html">Troy Hunt: 10 le√ßons financi√®res personnelles pour les professionnels des technologies de l'information</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>