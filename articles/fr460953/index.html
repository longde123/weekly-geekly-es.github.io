<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💅🏿 👩‍🎨 🗿 Les pointeurs sont complexes, ou qu'est-ce qui est stocké dans un octet? ✌🏾 🧓🏽 👨🏽‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je vous présente la traduction de l'article "Les pointeurs sont compliqués, ou: qu'est-ce qu'un octet?" paternité de Ralf Jung. 


 Cet...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Les pointeurs sont complexes, ou qu'est-ce qui est stocké dans un octet?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460953/"><p>  Bonjour, Habr!  Je vous présente la traduction de l'article "Les pointeurs sont compliqués, ou: qu'est-ce qu'un octet?"  paternité de Ralf Jung. </p><br><p>  Cet été, je travaille à nouveau à temps plein sur Rust, et je vais à nouveau (entre autres) travailler sur le «modèle de mémoire» pour Rust / MIR.  Cependant, avant de parler de mes idées, je dois enfin dissiper le mythe selon lequel «les pointeurs sont simples: ce ne sont que des chiffres».  Les deux parties de cette déclaration sont erronées, au moins dans les langages avec des fonctionnalités dangereuses, comme Rust ou C: les pointeurs ne peuvent pas être appelés nombres premiers ou (ordinaires). </p><br><p>  Je voudrais également discuter de la partie du modèle de mémoire qui doit être abordée avant de parler des parties les plus complexes: sous <em>quelle forme les</em> données sont-elles stockées en mémoire?  Une mémoire se compose d'octets, d'unités adressables minimales et des éléments les plus petits accessibles (au moins sur la plupart des plates-formes), mais quelles sont les valeurs d'octets possibles?  Encore une fois, il s'avère que «c'est juste un nombre à 8 bits» ne convient pas comme réponse. <a name="habracut"></a></p><br><p>  J'espère qu'après avoir lu ce post, vous serez d'accord avec moi concernant les deux déclarations. </p><br><h1 id="ukazateli-slozhny">  Les pointeurs sont compliqués </h1><br><p>  Quel est le problème avec "les pointeurs sont des nombres réguliers"?  Examinons l'exemple suivant: (J'utilise C ++ ici, car l'écriture de code non sécurisé en C ++ est plus facile que d'écrire en Rust, et le code non sécurisé est juste l'endroit où les problèmes apparaissent. Insecure Rust et C ont tous les mêmes problèmes que et C ++). </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> y = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; y[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-comment"><span class="hljs-comment">/* -     */</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x_ptr = &amp;x[i]; *x_ptr = <span class="hljs-number"><span class="hljs-number">23</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre> <br><p>  Optimiser la dernière lecture de y [0] avec un retour de 42 est toujours très bénéfique.  La justification de cette optimisation est que la modification de x_ptr qui pointe vers x ne peut pas changer y. </p><br><p>  Cependant, lorsque nous traitons des langages de bas niveau tels que C ++, nous pouvons violer cette hypothèse en attribuant à i la valeur yx.  Puisque &amp; x [i] est identique à x + i, nous écrivons 23 dans &amp; y [0]. </p><br><p>  Bien sûr, cela n'empêche pas les compilateurs C ++ d'effectuer de telles optimisations.  Pour résoudre ce problème, la norme indique que notre code a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">UB</a> . </p><br><p>  Premièrement, il n'est pas autorisé d'effectuer des opérations arithmétiques sur des pointeurs (comme dans le cas de &amp; x [i]), si dans ce cas le pointeur <a href="">dépasse les limites du tableau</a> .  Notre programme viole cette règle: x [i] va au-delà de x, donc c'est UB.  En d'autres termes, même le <em>calcul de</em> la valeur x_ptr est UB, donc nous n'arrivons même pas à l'endroit où nous voulons <em>utiliser</em> ce pointeur. </p><br><p>  (Il s'avère que i = yx est également UB, car <a href="">seuls les pointeurs pointant vers la même allocation de mémoire peuvent être soustraits</a> . Cependant, nous pourrions écrire i = ((size_t) y - (size_t) x) / sizeof (int) pour contourner c'est une limitation.) </p><br><p>  Mais nous n'avons pas encore fini: cette règle a la seule exception que nous pouvons utiliser à notre avantage.  Si l'opération arithmétique calcule la valeur du pointeur vers l'adresse <em>exactement après la</em> fin du tableau, alors tout est en ordre.  (Cette exception est nécessaire pour calculer vec.end () pour les boucles les plus courantes en C ++ 98.) </p><br><p>  Modifions un peu l'exemple: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> y = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; y[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x_ptr = x+<span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    if (x_ptr == &amp;y[0]) *x_ptr = 23; return y[0]; }</span></span></code> </pre> <br><p>  Imaginez maintenant que x et y ont été alloués l' <em>un après l'autre</em> , y ayant une adresse plus grande.  Alors x_ptr pointe <em>vers le début de</em> y!  La condition est alors vraie et l'affectation se produit.  Dans le même temps, il n'y a pas d'UB en raison de la sortie du pointeur à l'étranger. </p><br><p>  Il semble que cela ne permette pas l'optimisation.  Cependant, le standard C ++ a un autre atout dans sa manche pour aider les créateurs de compilateurs: en fait, il ne nous permet pas d'utiliser x_ptr.  Selon ce que la norme dit sur l' <a href="">ajout de nombres aux pointeurs</a> , x_ptr pointe vers l'adresse après le dernier élément du tableau.  Il <em>ne</em> pointe <em>pas</em> vers un élément spécifique d'un autre objet, <em>même s'ils ont la même adresse</em> .  (Au moins, c'est une interprétation courante de la norme sur la base de laquelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LLVM optimise ce code</a> .) </p><br><p>  Et même si x_ptr et &amp; y [0] pointent vers la même <em>adresse</em> , cela ne fait pas d'eux le <em>même pointeur</em> , c'est-à-dire qu'ils ne peuvent pas être utilisés de manière interchangeable: &amp; y [0] pointe vers le premier élément de y;  x_ptr pointe vers l'adresse après x.  Si nous remplaçons * x_ptr = 23 par la chaîne * &amp; y [0] = 0, nous changerons la valeur du programme, même si l'égalité des deux pointeurs a été vérifiée. </p><br><p>  Cela mérite d'être répété: </p><br><blockquote>  Ce n'est pas parce que deux pointeurs pointent vers la même adresse qu'ils sont égaux et peuvent être utilisés de manière interchangeable. </blockquote><p>  Oui, cette différence est insaisissable.  En fait, cela provoque toujours des différences dans les programmes compilés avec LLVM et GCC. </p><br><p>  Notez également que cette règle one-after n'est pas le seul endroit en C / C ++ où l'on peut observer un tel effet.  Un autre exemple est le mot-clé restrict en C, qui peut être utilisé pour exprimer que les pointeurs ne se chevauchent pas (ne sont pas égaux): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">restrict</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">restrict</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ *x = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x == y) { *y = <span class="hljs-number"><span class="hljs-number">23</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *x; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> foo(&amp;x, &amp;x); }</code> </pre> <br><p>  L'appel test () appelle UB, car deux accès à la mémoire dans foo ne doivent pas se produire à la même adresse.  En remplaçant * y par * x dans foo, nous changerons la valeur du programme, et il n'appellera plus UB.  Encore une fois: bien que x et y aient la même adresse, ils ne peuvent pas être utilisés de manière interchangeable. </p><br><p>  Les pointeurs ne sont certainement pas que des chiffres. </p><br><h1 id="prostaya-model-ukazateley">  Modèle de pointeur simple </h1><br><p>  Alors qu'est-ce qu'un pointeur?  Je ne connais pas la réponse complète.  En fait, c'est un domaine ouvert pour la recherche. </p><br><p>  Un point important: nous examinons ici un <em>modèle de</em> pointeur <em>abstrait</em> .  Bien sûr, sur un vrai ordinateur, les pointeurs sont des nombres.  Mais un véritable ordinateur n'effectue pas les optimisations que font les compilateurs C ++ modernes.  Si nous écrivions les programmes ci-dessus dans l'assembleur, il n'y aurait pas d'UB, pas d'optimisations.  C ++ et Rust adoptent une approche plus «supérieure» de la mémoire et des pointeurs, limitant le programmeur au compilateur.  Lorsqu'il est nécessaire de décrire formellement ce qu'un programmeur peut et ne peut pas faire dans ces langages, le modèle des pointeurs sous forme de nombres est brisé, nous devons donc trouver autre chose.  Ceci est un autre exemple d'utilisation d'une «machine virtuelle» différente d'un véritable ordinateur à des fins de spécification - une idée dont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">j'ai parlé plus tôt</a> . </p><br><p>  Voici une phrase simple (en fait, ce modèle de pointeurs est utilisé par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CompCert</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mon travail par RustBelt</a> , ainsi que la façon dont l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">interpréteur miri</a> implémente les <a href="">pointeurs</a> ): un pointeur est une paire d'ID qui identifie de manière unique une zone mémoire (allocation), et le décalage est relatif à ce domaine.  Si vous écrivez ceci en rouille: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pointer</span></span></span></span> { alloc_id: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, offset: <span class="hljs-built_in"><span class="hljs-built_in">isize</span></span>, }</code> </pre> <br><p>  Les opérations d'ajout (soustraction) d'un nombre à un pointeur (à partir d'un pointeur) n'affectent que le décalage, et par conséquent le pointeur ne peut jamais quitter la zone mémoire.  La soustraction de pointeurs n'est possible que s'ils appartiennent à la même zone mémoire (conformément à <a href="">C ++</a> ). </p><br><p>  (Comme nous pouvons le voir, la norme C ++ applique ces règles aux tableaux, pas aux zones de mémoire. Cependant, LLVM les applique au niveau de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la zone</a> .) </p><br><p>  Il s'avère (et miri montre la même chose) que ce modèle peut bien nous servir.  Nous nous souvenons toujours de la région de mémoire à laquelle appartient le pointeur, afin de pouvoir distinguer le pointeur suivant d'une région de mémoire du pointeur au début d'une autre région.  Ainsi miri peut trouver que notre deuxième exemple (avec &amp; x [8]) a UB. </p><br><h1 id="nasha-model-razvalivaetsya-na-kuski">  Notre modèle s'effondre </h1><br><p>  Dans notre modèle, les pointeurs, bien qu'ils ne soient pas des nombres, sont au moins simples.  Cependant, ce modèle commencera à s'effondrer sous nos yeux, dès que vous vous souviendrez de la conversion des pointeurs en nombres.  Dans miri, la conversion d'un pointeur en un nombre ne fait rien, nous obtenons simplement une variable numérique (c'est-à-dire que son <em>type</em> indique qu'il s'agit d'un nombre) dont la <em>valeur</em> est un pointeur (c'est-à-dire une paire de zone de mémoire et un décalage).  Cependant, multiplier ce nombre par 2 conduit à une erreur, car on ne sait pas vraiment ce que signifie "multiplier un tel pointeur abstrait par 2". </p><br><p>  Je dois préciser: ce n'est <em>pas une</em> bonne solution quand il s'agit de définir la sémantique d'un langage.  Cependant, cela fonctionne bien pour l'interprète.  C'est l'approche la plus simple, et nous l'avons choisie car il n'est pas clair comment cela peut être fait autrement (sauf pour ne pas prendre en charge de telles réductions du tout - mais avec leur support, miri peut exécuter plus de programmes): dans notre machine abstraite, il n'y a pas un seul "espace d'adressage", dans lequel toutes les zones de mémoire allouées seraient situées, et tous les pointeurs étaient mappés à des numéros différents spécifiques.  Chaque zone de mémoire est identifiée par un ID (masqué).  Maintenant, nous pouvons commencer à ajouter des données supplémentaires à notre modèle, telles que l'adresse de base pour chaque zone de mémoire, et l'utiliser d'une manière ou d'une autre pour ramener le numéro au pointeur ... et à ce stade, le processus devient vraiment très compliqué, et, en tout cas, une discussion de cela Les modèles ne visent pas à rédiger un article.  Son objectif est de discuter de la nécessité d'un tel modèle.  Si vous êtes intéressé, je vous recommande de lire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce document</a> , qui examine de plus près l'idée ci-dessus d'ajouter une adresse de base. </p><br><p>  En bref, les conversions de pointeurs et de nombres entre eux sont déroutants et difficiles à déterminer formellement, compte tenu des optimisations discutées ci-dessus.  Il existe un conflit entre l'approche de haut niveau requise pour les optimisations et l'approche de bas niveau nécessaire pour décrire la conversion de pointeurs en nombres et vice versa.  Pour la plupart, nous ignorons simplement ce problème dans miri et, dans la mesure du possible, essayons d'en faire autant que possible en utilisant le modèle simple avec lequel nous travaillons.  Une définition complète de langages tels que C ++ ou Rust, bien sûr, ne peut pas aller d'une manière aussi simple, elle devrait expliquer ce qui se passe réellement.  Pour autant que je sache, il n'y a pas de solution appropriée, mais la recherche universitaire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">approche de la vérité</a> . </p><br><p>  C'est pourquoi les pointeurs ne sont pas non plus simples. </p><br><h1 id="ot-ukazateley-k-baytam">  Des pointeurs aux octets </h1><br><p>  J'espère avoir avancé un argument convaincant selon lequel les nombres ne sont pas le seul type de données à prendre en compte si nous voulons décrire formellement des langages de bas niveau comme C ++ ou la partie (non sécurisée) de Rust.  Cependant, cela signifie qu'une opération simple comme la lecture d'un octet dans la mémoire ne peut pas simplement renvoyer u8.  Imaginez que nous <a href="">implémentions memcpy</a> en lisant chaque octet de la source tour à tour dans une variable locale v, puis stockons cette valeur dans l'emplacement cible.  Mais que faire si cet octet fait partie d'un pointeur?  Si le pointeur est une paire d'ID de zone de mémoire et de décalage, alors quel sera son premier octet?  Nous devons dire à quoi la valeur de v est égale, nous devrons donc en quelque sorte répondre à cette question.  (Et c'est un problème complètement différent de celui de la multiplication, qui était dans la section précédente. Nous supposons simplement qu'il existe un type abstrait de Ponter.) </p><br><p>  Nous ne pouvons pas représenter l'octet du pointeur comme une valeur de la plage 0..256 (remarque: ci-après 0 est activé, 256 ne l'est pas).  En général, si nous utilisons un modèle de représentation de mémoire naïf, la partie «cachée» supplémentaire du pointeur (celle qui en fait plus qu'un simple nombre) sera perdue lorsque le pointeur est écrit en mémoire et relu.  Nous devrons résoudre ce problème, et pour cela, nous devrons étendre notre concept d '«octet» pour représenter cet état supplémentaire.  Ainsi, l'octet est maintenant <em>soit la</em> valeur de la plage 0..256 ("bits bruts"), <em>soit</em> le nième octet d'un pointeur abstrait.  Si nous devions implémenter notre modèle de mémoire dans Rust, cela pourrait ressembler à ceci: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ByteV1</span></span></span></span> { Bits(<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>), PtrFragment(Pointer, <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>), }</code> </pre> <br><p>  Par exemple, PtrFragment (ptr, 0) représente le premier octet du pointeur ptr.  Ainsi, memcpy peut "casser" le pointeur en octets séparés qui représentent ce pointeur en mémoire et les copier individuellement.  Sur une architecture 32 bits, la représentation ptr complète contiendra 4 octets: </p><br><pre> <code class="rust hljs">[PtrFragment(ptr, <span class="hljs-number"><span class="hljs-number">0</span></span>), PtrFragment(ptr, <span class="hljs-number"><span class="hljs-number">1</span></span>), PtrFragment(ptr, <span class="hljs-number"><span class="hljs-number">2</span></span>), PtrFragment(ptr, <span class="hljs-number"><span class="hljs-number">3</span></span>)]</code> </pre> <br><p>  Cette représentation prend en charge toutes les opérations de déplacement de données sur des pointeurs au niveau des octets, ce qui est tout à fait suffisant pour la mémorisation.  Les opérations arithmétiques ou binaires ne sont pas entièrement prises en charge;  comme indiqué ci-dessus, cela nécessiterait une représentation plus complexe des pointeurs. </p><br><h1 id="neinicializirovannaya-pamyat">  Mémoire non initialisée </h1><br><p>  Cependant, nous n'avons pas fini avec notre définition de "octet".  Pour décrire complètement le comportement du programme, nous devons considérer une autre option: un octet en mémoire peut être <em>non initialisé</em> .  La dernière définition d'octet ressemblera à ceci (supposons que nous ayons un type de pointeur pour les pointeurs): </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Byte</span></span></span></span> { Bits(<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>), PtrFragment(Pointer, <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>), Uninit, }</code> </pre> <br><p>  Nous utilisons la valeur Uninit pour tous les octets de la mémoire allouée dans lesquels nous n'avons encore écrit aucune valeur.  Il est possible de lire la mémoire non initialisée sans problème, mais toute autre <em>action</em> avec ces octets (par exemple, l'arithmétique numérique) conduit à UB. </p><br><p>  Ceci est très similaire aux règles LLVM en ce qui concerne la valeur de poison spécial.  Notez que LLVM a <em>également</em> une valeur undef, qui est utilisée pour la mémoire non initialisée et fonctionne un peu différemment.  Cependant, la compilation de notre Uninit en undef est correcte (undef est à certains égards "plus faible"), et il existe des suggestions <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pour supprimer undef de LLVM et utiliser du poison à la place</a> . </p><br><p>  Vous vous demandez peut-être pourquoi nous avons une valeur spéciale Uninit.  Pourquoi ne pas choisir un b: u8 arbitraire pour chaque nouvel octet, puis utiliser Bits (b) comme valeur initiale?  C'est vraiment une option.  Cependant, tout d'abord, tous les compilateurs sont arrivés à l'approche en utilisant une valeur spéciale pour la mémoire non initialisée.  Ne pas suivre cette approche signifie non seulement causer des problèmes de compilation via LLVM, mais également passer en revue toutes les optimisations et s'assurer qu'elles fonctionnent correctement avec ce modèle modifié.  Le point clé ici: vous pouvez toujours remplacer Uninit en toute sécurité par toute autre valeur: toute opération recevant cette valeur entraînera en tout cas UB. </p><br><p>  Par exemple, ce code C est plus facile à optimiser avec Uninit: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condA()) x = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     ,       ,  condA() //  ,      x. use(x); //  x = 1. }</span></span></code> </pre> <br><p>  Avec Uninit, nous pouvons facilement dire que x a une valeur Uninit ou une valeur de 1, et puisque le remplacement de Uninit par 1 fonctionne, l'optimisation est facilement expliquée.  Sans Uninit, x est «une sorte de motif binaire arbitraire» ou 1, et la même optimisation est plus difficile à expliquer. </p><br><p>  (Nous pouvons affirmer que nous pouvons échanger des opérations lorsque nous faisons un choix non déterministe, mais nous devrons alors prouver que le code qui est difficile à analyser n'utilise en aucun cas x. Uninit évite ce problème avec des preuves inutiles.) </p><br><p>  Enfin, Uninit est le meilleur choix pour les interprètes comme miri.  Ces interprètes ont des problèmes avec des opérations telles que «sélectionner simplement l'une de ces valeurs» (c'est-à-dire des opérations non déterministes), car elles ont tendance à parcourir tous les chemins possibles d'exécution du programme, ce qui signifie qu'elles doivent essayer toutes les valeurs possibles.  L'utilisation de Uninit au lieu d'un modèle de bits arbitraire signifie que miri peut vous dire après l'exécution d'un programme si votre programme utilise de manière incorrecte des valeurs non initialisées. </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  Nous avons vu que dans des langages comme C ++ et Rust (contrairement aux vrais ordinateurs) les pointeurs peuvent être différents même s'ils pointent vers la même adresse, et qu'un octet est plus qu'un simple nombre compris entre 0 et 256.  Par conséquent, si en 1978 le langage C pouvait être "assembleur portable", c'est maintenant une affirmation incroyablement erronée. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr460953/">https://habr.com/ru/post/fr460953/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr460943/index.html">Comment choisir des clés prometteuses pour le référencement en fonction des prévisions de scénario dans Google Data Studio (+ modèle)</a></li>
<li><a href="../fr460945/index.html">Expérience de l'utilisation d'un canal de télégramme pour accroître la reconnaissance et la croissance des revenus d'un studio de jeux</a></li>
<li><a href="../fr460947/index.html">WASM Meet Up 1/08</a></li>
<li><a href="../fr460949/index.html">«Et l'impossible est possible»: nous transformons une boîte noire en blanc grâce à l'analyse binaire</a></li>
<li><a href="../fr460951/index.html">Créer des fonds d'écran Android Live</a></li>
<li><a href="../fr460955/index.html">Programme éducatif pour transmettre des paramètres par valeur aux constructeurs et aux setters (C ++ moderne, exemples)</a></li>
<li><a href="../fr460959/index.html">La nouvelle technologie de Microsoft permet aux copies 3D d'une personne réelle de parler n'importe quelle langue</a></li>
<li><a href="../fr460961/index.html">Configuration de tests unitaires dans des projets mixtes Swift + Objective-C</a></li>
<li><a href="../fr460965/index.html">Split Controller sans ces storyboards</a></li>
<li><a href="../fr460967/index.html">Troy Hunt: 10 leçons financières personnelles pour les professionnels des technologies de l'information</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>