<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ¾â€ğŸ’» â™“ï¸ ğŸ¡ Porting JS ke Elbrus ğŸ¼ ğŸ³ ğŸ‘©â€ğŸ‘§â€ğŸ‘§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini adalah kisah tentang porting JavaScript ke platform domestik Elbrus, dibuat oleh orang-orang dari UniPro. Artikel ini memberikan analisis komparat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Porting JS ke Elbrus</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/419155/">  Ini adalah kisah tentang porting JavaScript ke platform domestik Elbrus, dibuat oleh orang-orang dari UniPro.  Artikel ini memberikan analisis komparatif singkat tentang platform, detail proses dan jebakan. <br><br><img src="https://habrastorage.org/webt/6x/ai/-j/6xai-jeiycantp_i5sdieoiglzc.jpeg"><br><br>  Artikel ini didasarkan pada laporan oleh Dmitry ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">dbezheckov</a> ) Bezhetskov dan Vladimir ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">volodyabo</a> ) Anufrienko dengan HolyJS 2018 Piter.  Di bawah potongan Anda akan menemukan transkrip video dan teks dari laporan. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1zWUN6y2WbI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Bagian 1. Elbrus, berasal dari Rusia </h2><br>  Pertama, kita akan mengerti apa itu Elbrus.  Berikut adalah beberapa fitur utama platform ini dibandingkan dengan x86. <br><br><h3>  Arsitektur VLIW </h3><br>  Solusi arsitektur yang sama sekali berbeda dari arsitektur superscalar, yang lebih umum di pasaran sekarang.  VLIW memungkinkan Anda untuk mengekspresikan maksud kode dengan lebih baik karena kontrol eksplisit dari semua perangkat aritmatika-logika independen (ALU), yang dimiliki oleh Elbrus, 4. Namun, ini tidak mengecualikan kemungkinan downtime dari beberapa ALU, namun demikian meningkatkan kinerja teoritis dengan satu siklus clock. prosesor. <br><br><h3>  Bundling tim </h3><br>  Perintah prosesor siap digabungkan dalam bundel (Bundel).  Satu bundel adalah satu instruksi besar yang dijalankan per jam bersyarat.  Ini memiliki banyak instruksi atom yang dieksekusi secara independen dan segera dalam arsitektur Elbrus. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e77/da3/ebc/e77da3ebc083c57d019b34bbc58483af.png"><br><br>  Pada gambar di sebelah kanan, persegi panjang abu-abu menunjukkan bundel yang diperoleh dengan memproses kode JS di sebelah kiri.  Jika semuanya hampir jelas dengan instruksi ldd, fmuld, faddd, fsqrts, maka pernyataan pengembalian di awal bundel pertama mengejutkan bagi orang-orang yang tidak terbiasa dengan assembler Elbrus.  Instruksi ini memuat alamat pengirim dari fungsi floatMath saat ini ke dalam register ctpr3 terlebih dahulu, sehingga prosesor dapat mengatur untuk mengunduh instruksi yang diperlukan.  Kemudian, dalam bundel terakhir, kami sudah melakukan transisi ke alamat yang dimuat sebelumnya di ctpr3. <br><br>  Perlu juga dicatat bahwa Elbrus memiliki lebih banyak register 192 + 32 + 32 versus 16 + 16 +8 untuk x86. <br><br><h3>  Spekulatif eksplisit versus implisit </h3><br>  Elbrus mendukung spekulatif eksplisit di tingkat perintah.  Oleh karena itu, kita dapat memanggil dan memuat a.bar dari memori bahkan sebelum memeriksa apakah itu tidak nol, seperti yang terlihat pada kode di sebelah kanan.  Jika membaca secara logis pada akhirnya ternyata tidak valid, maka nilai dalam b hanya akan ditandai sebagai perangkat keras yang salah dan tidak mungkin untuk mengaksesnya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/822/ec0/bcb/822ec0bcbb07ec7cff3a3e35656ef99e.png"><br><br><h3>  Dukungan Eksekusi Bersyarat </h3><br>  Elbrus juga mendukung eksekusi bersyarat.  Pertimbangkan ini dalam contoh berikut. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a34/39b/005/a3439b00564ddec3a66383e76bb58b96.png"><br><br>  Seperti yang dapat kita lihat, kode dari contoh sebelumnya tentang spekulatif juga berkurang karena penggunaan konvolusi ekspresi kondisional menjadi ketergantungan, bukan oleh kontrol, tetapi oleh data.  Perangkat keras Elbrus mendukung register predikat, di mana Anda hanya dapat menyimpan dua nilai benar atau salah.  Fitur utamanya adalah Anda dapat menandai instruksi dengan predikat seperti itu dan tergantung pada nilainya pada saat eksekusi, instruksi tersebut akan dieksekusi atau tidak.  Dalam contoh ini, instruksi cmpeq melakukan perbandingan dan menempatkan hasil logisnya pada predikat P1, yang kemudian digunakan sebagai penanda untuk memuat nilai dari b ke dalam hasil.  Dengan demikian, jika predikatnya sama dengan true, maka nilai 0 tetap di hasilnya. <br><br>  Pendekatan ini memungkinkan Anda untuk mengubah grafik kontrol program yang cukup kompleks menjadi eksekusi predikat dan, karenanya, meningkatkan kepenuhan bundel.  Sekarang kita dapat menghasilkan lebih banyak tim independen di bawah predikat yang berbeda dan mengisinya dengan bundel.  Elbrus mendukung 32 register predikat, yang memungkinkan Anda untuk menyandikan 65 aliran kontrol (ditambah satu untuk tidak adanya predikat pada perintah). <br><br><h3>  Tiga tumpukan perangkat keras dibandingkan dengan yang ada di Intel </h3><br>  Dua di antaranya dilindungi dari modifikasi oleh programmer.  Satu - tumpukan rantai - bertanggung jawab untuk menyimpan alamat untuk pengembalian dari fungsi, yang lain - tumpukan register - berisi parameter yang dilewati.  Stack pengguna ketiga - menyimpan variabel dan data pengguna.  Dalam intel, semuanya disimpan di satu tumpukan, yang menimbulkan kerentanan, karena semua alamat transisi, parameter berada di satu tempat yang tidak dilindungi oleh modifikasi oleh pengguna. <br><br><h3>  Tidak ada prediktor cabang dinamis </h3><br>  Alih-alih, sebuah skema dengan persiapan-konversi dan persiapan transisi digunakan sehingga pipa eksekusi tidak berhenti. <br><br><h3>  Jadi mengapa kita perlu JS di Elbrus? </h3><br><ol><li>  Substitusi impor. <br></li><li>  Pengenalan Elbrus ke pasar komputer rumahan, di mana Javascript sudah diperlukan untuk peramban yang sama. <br></li><li>  Elbrus sudah dibutuhkan di industri, misalnya dengan Node.js.  Oleh karena itu, Anda perlu mem-port Node ke arsitektur ini. <br></li><li>  Perkembangan arsitektur Elbrus, serta spesialis di bidang ini. <br></li></ol><br><h3>  Jika tidak ada juru bahasa, dua penyusun datang </h3><br>  Implementasi v8 sebelumnya dari Google diambil sebagai dasar.  Ia bekerja seperti ini: pohon sintaksis abstrak dibuat dari kode sumber, kemudian tergantung pada apakah kode itu dieksekusi atau tidak, menggunakan salah satu dari dua kompiler (Crankshaft atau FullCodegen), masing-masing, kode biner yang dioptimalkan atau tidak dioptimalkan dibuat.  Tidak ada penerjemah. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/569/0ab/9f1/5690ab9f1edaf8273f6fe62b64110d27.png"><br><br><h3>  Bagaimana cara kerja FullCodegen? </h3><br>  Simpul pohon sintaksis diterjemahkan ke dalam kode biner, setelah itu semuanya "direkatkan" bersama-sama.  Satu node adalah sekitar 300 baris kode dalam assembler makro.  Ini, pertama, memberikan cakrawala optimalisasi, dan, kedua, tidak ada transisi bytecode, seperti dalam interpreter.  Ini sederhana, tetapi pada saat yang sama ada masalah - selama porting Anda harus menulis ulang banyak kode di assembler makro. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b8/38c/79a/6b838c79ab83cd76a498d82bf4ac3884.png"><br><br>  Namun demikian, semua ini dilakukan, dan hasilnya adalah versi kompiler FullCodegen 1.0 untuk Elbrus.  Semuanya dilakukan melalui runtime C ++ v8, mereka tidak mengoptimalkan apa pun, kode assembler hanya ditulis ulang dari x86 ke arsitektur Elbrus. <br><br><h3>  Codegen 1.1 </h3><br>  Akibatnya, hasilnya tidak persis sama dengan yang diharapkan, dan diputuskan untuk merilis FullCodegen 1.1: <br><br><ul><li>  Membuat runtime lebih sedikit, menulis di assembler makro; <br></li><li>  Menambahkan konversi if manual (pada gambar, sebagai contoh, variabel js diperiksa benar atau salah); <br></li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/588/974/2f1/5889742f19fa70280dcb5665e1e733d8.png"><br><br>  Perhatikan bahwa memeriksa NaN, undefined, null dilakukan sekaligus, tanpa menggunakan if, yang akan diperlukan dalam arsitektur Intel. <br><br><ul><li>  Kode tersebut tidak hanya ditulis ulang dengan Intel, tetapi juga menerapkan spekulativeness di stubs dan mengimplementasikan jalur cepat juga melalui MAsm (assembler makro). <br></li></ul><br>  Tes dilakukan di Google Octane.  Mesin uji: <br><br><ul><li>  Elbrus: E2S 750 MHz, 24 GB <br></li><li>  Intel: core i7 3.4 GHz, 16 GB <br></li></ul><br>  Hasil lebih lanjut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fb4/922/ff5/fb4922ff553518321227b4a0c57f91bd.png"><br><br>  Pada histogram adalah rasio hasil, yaitu  berapa kali Elbrus lebih buruk dari Intel.  Pada dua tes, Crypto dan zlib, hasilnya terasa lebih buruk karena Elbrus belum memiliki instruksi perangkat keras untuk bekerja dengan enkripsi.  Secara umum, mengingat perbedaan frekuensi, ternyata cukup baik. <br><br>  Berikut ini adalah tes dibandingkan dengan juru bahasa js dari firefox, yang merupakan bagian dari distribusi Elbrus standar.  Lebih banyak lebih baik. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0ab/c77/0d4/0abc770d4a1717ca18156070f0b762a4.png"><br>  Putusan - kompiler melakukan pekerjaan dengan baik lagi. <br><br><h3>  Hasil Pengembangan </h3><br><ul><li>  Mesin JS baru lulus tes test262.  Ini memberinya hak untuk disebut lingkungan runtime lengkap ECMAScript 262. <br></li><li>  Produktivitas meningkat rata-rata lima kali dibandingkan dengan mesin sebelumnya - interpreter. <br></li><li>  Node.js 6.10 juga porting sebagai contoh menggunakan V8, karena itu tidak sulit. <br></li><li>  Namun, ini masih lebih buruk daripada Core i7 di FullCodegen sebanyak tujuh kali. <br></li></ul><br><h3>  Tampaknya tidak ada yang menandakan </h3><br>  Semuanya akan baik-baik saja, tetapi di sini Google mengumumkan bahwa itu tidak lagi mendukung FullCodegen dan Crankshaft dan mereka akan dihapus.  Setelah itu tim menerima pesanan pengembangan untuk browser Firefox, dan lebih lanjut tentang itu nanti. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9d7/f15/543/9d7f155439ad3b1436ebc4cc9c59d50a.png"><br><br><h2>  Bagian 2. Firefox dan monyet laba-laba </h2><br>  Ini tentang mesin browser Firefox - SpiderMonkey.  Pada gambar, perbedaan antara mesin ini dan V8 yang lebih baru. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c91/301/274/c9130127464ac436103ab6e8ed8c187d.png"><br><br>  Dapat dilihat bahwa pada tahap pertama semuanya tampak seperti kode sumber diurai menjadi pohon sintaksis abstrak, kemudian ke dalam kode byte, dan kemudian perbedaan dimulai. <br><br>  Dalam SpiderMonkey, bytecode ditafsirkan oleh penerjemah C ++, yang pada dasarnya menyerupai saklar besar, di dalamnya bytecode melompat.  Selanjutnya, kode yang diinterpretasikan masuk ke Baseline kompilator yang melakukan neotimisasi.  Kemudian, pada tahap akhir, Ion kompiler yang mengoptimalkan dimasukkan dalam kasing.  Dalam mesin V8, bytecode diproses oleh juru bahasa Ingnition, dan kemudian oleh kompiler TurboFan. <br><br><h3>  Baseline, aku memilihmu! </h3><br>  Porting dimulai dengan kompiler Baseline.  Ini pada dasarnya adalah mesin bertumpuk.  Yaitu, ada tumpukan tertentu dari mana sel-sel ia mengambil variabel, mengingatnya, melakukan beberapa tindakan dengan mereka, setelah itu ia mengembalikan kedua variabel dan hasil tindakan kembali ke sel-sel tumpukan.  Di bawah ini dalam beberapa gambar mekanisme ini ditunjukkan langkah demi langkah sehubungan dengan fungsi sederhana foo: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d4a/8fb/d66/d4a8fbd66d65c39e23a22ed8c21b844e.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/744/c7a/927/744c7a92704b61ec0063a5223de84bda.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/fdd/0bb/b3f/fdd0bbb3f000f2738af72ee77afbc719.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/cfe/b02/db2/cfeb02db22e24368fca8632db5cf93f2.png"><br><br><h3>  Apa itu bingkai? </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/4a8/386/e3c/4a8386e3c926b0175dcd7508cfbd0783.png"><br><br>  Pada gambar di atas Anda dapat melihat bingkai kata.  Secara kasar, ini adalah konteks Javascript pada perangkat keras, yaitu, set data pada tumpukan yang menjelaskan salah satu fungsi Anda.  Pada gambar di bawah ini, fungsinya adalah foo, dan di sebelah kanannya adalah seperti apa yang terlihat di stack: argumen, deskripsi fungsi, alamat kembali, indikasi bingkai sebelumnya, karena fungsi dipanggil dari suatu tempat dan agar dapat kembali ke tempat panggilan dengan benar, informasi ini harus disimpan dalam stack, dan kemudian variabel lokal sendiri berfungsi dan operan untuk perhitungan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/14d/c18/a75/14dc18a750ddcddf752bc1ed53a6eed0.png"><br><br>  Dengan demikian, <b>keuntungan dari Baseline</b> : <br><br><ul><li>  Sepertinya FullCodegen, jadi pengalaman portingnya sangat berguna; <br></li><li>  Port assembler, dapatkan kompiler yang berfungsi; <br></li><li>  Lebih mudah untuk debug; <br></li><li>  Stub apa pun dapat ditulis ulang. <br></li></ul><br>  Namun ada juga <b>kelemahannya</b> : <br><br><ul><li>  Kode linier, sampai Anda mengeksekusi kode satu byte, Anda tidak akan dapat menjalankan yang berikut, yang tidak terlalu baik untuk arsitektur dengan komputasi paralel; <br></li><li>  Karena bekerja dengan bytecode, Anda tidak benar-benar mengoptimalkan. <br></li></ul><br>  Hanya tinggal menerapkan assembler makro dan mendapatkan kompiler yang sudah jadi.  Debugging tidak menjadi pertanda baik, itu sudah cukup untuk melihat stack pada arsitektur x86, dan kemudian pada yang diperoleh saat porting untuk menemukan masalah. <br><br>  Akibatnya, dalam pengujian dengan kompiler baru, produktivitas meningkat tiga kali lipat: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/79e/20b/20b/79e20b20b8126f69cd9031c406af0da0.png"><br><br>  Namun, Octane tidak mendukung pengecualian.  Dan implementasinya sangat penting. <br><br><h3>  Pekerjaan luar biasa </h3><br>  Pertama, mari kita lihat bagaimana pengecualian berfungsi pada x86.  Ketika program sedang berjalan, alamat pengirim dari fungsi ditulis ke stack.  Pada titik tertentu, pengecualian terjadi.  Kami beralih ke penangan pengecualian runtime, yang menggunakan bingkai yang kita bicarakan di atas.  Kami menemukan di mana tepatnya pengecualian terjadi, setelah itu kami harus memundurkan tumpukan ke kondisi yang diinginkan, dan kemudian alamat pengirim berubah ke tempat di mana pengecualian akan diproses. <br><br>  Masalahnya adalah bahwa karena perangkat stack lain pada arsitektur Elbrus, ini tidak akan berfungsi.  Akan perlu untuk menghitung dengan system call berapa banyak yang Anda butuhkan untuk mundur dalam Chain stack.  Selanjutnya, kami membuat panggilan sistem untuk mendapatkan tumpukan panggilan.  Selanjutnya, dalam alamat di tumpukan Rantai, kami membuat pengganti untuk alamat yang mengembalikannya. <br><br>  Di bawah ini adalah ilustrasi urutan langkah-langkah ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/21e/288/52b/21e28852b593e04e9712f55ced7484a5.png"><br><br>  Namun, bukan cara tercepat, pengecualian ditangani.  Namun tetap saja, pada Intel terlihat sedikit lebih sederhana: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f4d/e44/ee6/f4de44ee6d999e24e8a275b027c4442e.png"><br><br>  Dengan Elbrus, akan ada lebih banyak lompatan ke pawang: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8cc/239/b1f/8cc239b1f908dc1ab6c02953ef7641d9.png"><br>  Itu sebabnya Anda tidak harus mendasarkan logika program pada pengecualian, terutama pada Elbrus. <br><br><h3>  Optimalkan! </h3><br>  Jadi, penanganan pengecualian diterapkan.  Sekarang kami akan memberi tahu Anda bagaimana kami membuatnya sedikit lebih cepat: <br><br><ul><li>  Menulis ulang cache inline; <br></li></ul><br><ul><li>  Membuat pengaturan penundaan secara manual (dan kemudian otomatis); <br></li><li>  Mereka membuat persiapan untuk transisi (lebih tinggi dalam kode): semakin awal transisi disiapkan, semakin baik; <br></li><li>  Pengumpul sampah tambahan yang didukung <br></li></ul><br>  Paragraf kedua akan membahas sedikit lebih detail.  Kami telah memeriksa contoh kecil bekerja dengan bundel, dan kami akan beralih ke itu. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/805/722/9dd/8057229ddec6aa5091fa132de5506a9a.png"><br><br>  Operasi apa pun, misalnya, memuat, tidak dilakukan dalam satu siklus, dalam hal ini dilakukan dalam tiga siklus.  Jadi, jika kita ingin mengalikan dua angka, kita memasuki operasi perkalian, tetapi operan itu sendiri belum dimuat, prosesor hanya bisa menunggu mereka memuat.  Dan dia akan menunggu sejumlah langkah, kelipatan empat.  Tetapi jika Anda mengatur penundaan secara manual, waktu tunggu dapat dikurangi, sehingga meningkatkan kinerja.  Selanjutnya, proses mengatur penundaan otomatis. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/af7/721/cba/af7721cba060984416301fb89004a502.png"><br><br>  Hasil optimasi BaseLine v1.0 vs Baseline v1.1.  Tentu, mesinnya menjadi lebih cepat. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f3/d34/6cf/8f3d346cf9c1731bff2d85d0e52df5eb.png"><br><br><h3>  Bagaimana programmer tidak bisa membuat senjata Ion? </h3><br>  Pada gelombang kesuksesan dari implementasi Baseline v1.1, diputuskan untuk port Ion kompiler mengoptimalkan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b97/887/d35/b97887d35eae9e30d300fa7d60b24942.png"><br><br>  Bagaimana cara kerja kompiler yang mengoptimalkan?  Kode sumber ditafsirkan, kompilasi dimulai.  Dalam proses mengeksekusi bytecode, Ion mengumpulkan data pada jenis yang digunakan dalam program, dan analisis "fungsi panas" - yang dilakukan lebih sering daripada yang lain.  Setelah itu, keputusan dibuat untuk menyusunnya dengan lebih baik, untuk mengoptimalkan.  Selanjutnya, representasi tingkat tinggi dari kompiler, grafik operasi, dibangun.  Grafik dioptimalkan (opt 1, opt 2, opt ...), representasi level rendah dibuat, terdiri dari instruksi mesin, register dicadangkan, kode biner yang dioptimalkan secara langsung dihasilkan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/294/80d/48a/29480d48a92487c40bd4a7de91c7b1ef.png"><br><br>  Ada lebih banyak register di Elbrus dan tim itu sendiri besar, oleh karena itu kita perlu: <br><br><ul><li>  Perencana Tim <br></li><li>  Pengalokasi daftar sendiri; <br></li><li>  LIR Sendiri (Representasi Tingkat Menengah Rendah); <br></li><li>  Pembuat kode sendiri. <br></li></ul><br>  Tim sudah memiliki pengalaman porting Java ke Elbrus, mereka memutuskan untuk menggunakan perpustakaan yang sama untuk pembuatan kode untuk porting Ion.  Dia disebut TANGO.  Itu memiliki: <br><br><ul><li>  Perencana Tim <br></li><li>  Pengalokasi daftar sendiri; <br></li><li>  Optimalisasi tingkat rendah. <br></li></ul><br>  Tetap memperkenalkan perwakilan tingkat tinggi di TANGO, untuk membuat pemilih.  Masalahnya adalah bahwa tampilan tingkat rendah di TANGO seperti assembler, yang sulit untuk dipertahankan dan didebug.  Seperti apa seharusnya kompiler di dalam?  Untuk pemahaman yang lebih baik, Mozilla membuat kompiler HolyJit mereka sendiri, ada juga opsi untuk menulis bahasa mini Anda sendiri untuk menerjemahkan antara representasi level tinggi dan level rendah. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0a3/6b2/94b/0a36b294b7fb8241b5be77a22a4d0e09.png"><br><br>  Pembangunan masih berlangsung.  Nah dan selanjutnya tentang bagaimana tidak berlebihan dengan optimasi. <br><br><h2>  Bagian 3. Yang terbaik adalah musuh dari yang baik </h2><br><h3>  Kompilasi seperti apa adanya </h3><br>  Proses optimasi di Ion, ketika kode memanas dan kemudian mengkompilasi dan mengoptimalkan, serakah, ini dapat dilihat pada contoh berikut. <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{
 &nbsp;<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b;
}

<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomeStuff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{
 &nbsp;<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1100</span></span>; ++i) {
 &nbsp;&nbsp;&nbsp;print(foo(obj,obj));
 &nbsp;}
}

doSomeStuff(<span class="hljs-string"><span class="hljs-string">"HollyJS"</span></span>);
doSomeStuff({<span class="hljs-attr"><span class="hljs-attr">n</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>});
</code></pre><br>
   JS Shell    (  ), &nbsp;&nbsp;   Mozilla,   :<br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7ab/cdb/646/7abcdb646a834281b059d5a418d659c2.png"><br>
<br>
 .  ,     ,   -     bailout ().  ,   .      foo     object,           ,     ,        .    ,  :<br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomeStuff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{
 &nbsp;<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1100</span></span>; ++i) {
 &nbsp;&nbsp;&nbsp;<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment"><span class="hljs-comment">// bailout</span></span>
 &nbsp;&nbsp;&nbsp;print(foo_only_str(obj, obj));
 &nbsp;}
}
</code></pre><br>
         ,            .<br>
<br>
       .   ,         ,   DCE.<br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/677/41e/90f/67741e90f8b4e89225a55ab86c434601.png"><br>
<br>
<h2> </h2><br>
       ,  ,        ,          .<br>
<br>
   ,   ,    ,  SpiderMonkey  Resume Point. -   ,     .     ,       baseline .   ,   runtime   ,    .   lowering, regAlloc,     (snapshot),   ,    .      baseline .<br>
<br>
   :<br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bd4/449/349/bd444934928405be1d22ecefc3926427.png"><br>
<br>
 runtime  x86    : ,        .        .  ,       ,    ,    ,      ,    . ,      ,   Type .   :<br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b39/e8a/1ca/b39e8a1ca896a3550e80405177ccbf48.png"><br>
<br>
    ,       ,           chain . ,     ,  . <br>
<br>
    :    ,       chain-,    N ,    ,         baseline,         . &nbsp;<br>
<br>
    ,        .<br>
<br>
    :<br>
<img src="https://habrastorage.org/getpro/habr/post_images/6f3/684/575/6f3684575e08d56fb5eaf64cede1e3c3.png"><br>
<br>
    Ion  4-            baseline.     :<br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/9e6/325/b40/9e6325b406a27d6cdfee2ab2a9409488.png"><br>
<br>
<h2></h2><br>
,   ,     SpiderMonkey, V8  Node.    â€”  .     . <br>
<br>
      .       ,   ,      chain-.<br>
<br>
<blockquote>  ,  : 24-25      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HolyJS</a>,      .      â€”  ,      .</blockquote></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id419155/">https://habr.com/ru/post/id419155/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id419145/index.html">Fintech Digest: Kapitalisasi Apple melebihi $ 1 triliun, AI membantu eBay meningkatkan pendapatan hingga miliaran</a></li>
<li><a href="../id419147/index.html">Kubus 1000 dimensi: apakah mungkin untuk membuat model komputasi memori manusia saat ini?</a></li>
<li><a href="../id419149/index.html">Panduan untuk Mikrotik RoMON</a></li>
<li><a href="../id419151/index.html">Rumah pintar: dimensi baru kenyamanan dan pengejaran keunggulan. Bagian dua</a></li>
<li><a href="../id419153/index.html">Memorandum Hak Cyborg</a></li>
<li><a href="../id419159/index.html">Kode JS, angka Romawi, teka-teki geometris: bagaimana kita mengenkripsi zaman kita</a></li>
<li><a href="../id419161/index.html">Pemodelan permukaan air menggunakan prosesor FFT dan NeuroMatrix DSP</a></li>
<li><a href="../id419165/index.html">Kami mengirim SMS "anonim" dari Konsol ke nomor yang diinginkan menggunakan layanan bytehand dan C ++</a></li>
<li><a href="../id419169/index.html">"Dunia Wild West" melalui mata pengembang</a></li>
<li><a href="../id419171/index.html">Menonaktifkan keadaan runtime memeriksa dalam aplikasi Android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>