<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëçüèø üõí üë©üèº‚Äçüè≠ C√≥mo implementar un lenguaje de programaci√≥n en JavaScript. Parte 2: Int√©rprete üè≥Ô∏è‚Äçüåà üñ±Ô∏è üåø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Le presento la segunda parte de mi traducci√≥n de la gu√≠a para implementar su lenguaje de programaci√≥n JavaScript: PL Tutorial . 
 Del traductor 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo implementar un lenguaje de programaci√≥n en JavaScript. Parte 2: Int√©rprete</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443812/"><p>  Hola  Le presento la segunda parte de mi traducci√≥n de la gu√≠a para implementar su lenguaje de programaci√≥n JavaScript: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PL Tutorial</a> . </p><br><h1 id="ot-perevodchika">  Del traductor </h1><br><p>  Crearemos nuestro propio lenguaje de programaci√≥n - <strong>lenguaje Œª</strong> (en el idioma original - Œª).  En el proceso de creaci√≥n, utilizaremos muchas t√©cnicas interesantes, como el descenso recursivo, el estilo de transferencia de control y las t√©cnicas b√°sicas de optimizaci√≥n.  Se crear√°n dos versiones del int√©rprete: los int√©rpretes regulares y los de CPS, el transcompilador en JavaScript. </p><br><p>  El autor del original es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mihai Bazon</a> , autor de la famosa biblioteca UglifyJS (una herramienta para minimizar y formatear el c√≥digo JS). </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Contenido</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo implementar un lenguaje de programaci√≥n en JavaScript.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1: analizador</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo implementar un lenguaje de programaci√≥n en JavaScript.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2: Int√©rprete</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo implementar un lenguaje de programaci√≥n en JavaScript.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3: int√©rprete de CPS</a> </li><li>  C√≥mo implementar un lenguaje de programaci√≥n en JavaScript.  Parte 4: Trans Compilaci√≥n en JS </li></ol></div></div><br><p> PD Hay un error en el int√©rprete y el compilador: en expresiones como <code>a() &amp;&amp; b()</code> o <code>a() || b()</code>  <code>a() || b()</code> ambas partes siempre se ejecutan.  Esto, por supuesto, est√° mal porque <code>a()</code> falso para el operador <code>&amp;&amp;</code> , o no es falso para el <code>||</code>  , entonces el valor de <code>b()</code> no juega ning√∫n papel.  Esto no es dif√≠cil de arreglar. </p><br><h1 id="prostoy-interpretator">  Int√©rprete simple </h1><br><p>  En la parte anterior, escribimos 3 funciones: <code>InputStream</code> , <code>TokenStream</code> y <code>parse</code> .  Para obtener el AST del c√≥digo, usamos el siguiente c√≥digo: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ast = parse(TokenStream(InputStream(code)));</code> </pre> <br><p>  Escribir un int√©rprete es m√°s f√°cil que un analizador sint√°ctico: simplemente atravesamos recursivamente el √°rbol y ejecutamos las expresiones en su orden normal. </p><br><h2 id="kontekst-environment">  Contexto ( <code>Environment</code> ) </h2><br><p>  Para la correcta ejecuci√≥n del c√≥digo, necesitamos un contexto: un objeto que contenga todas las variables en una ubicaci√≥n determinada.  Se pasar√° como argumento a la funci√≥n de <code>evaluate</code> . </p><br><p>  Cada vez que ingresamos al nodo <code>lambda</code> , debemos agregar nuevas variables al contexto - argumentos de funci√≥n.  Si el argumento se superpone a la variable del bloque externo, debemos restaurar el valor anterior de la variable despu√©s de salir de la funci√≥n. </p><br><p>  La forma m√°s f√°cil de hacer esto es usar el prototipo de herencia de JavaScript.  Cuando ingresamos a una nueva funci√≥n, creamos un nuevo contexto, establecemos el contexto externo como su prototipo y llamamos a la funci√≥n en el nuevo contexto.  Gracias a esto, no tenemos nada: en el contexto externo, todas sus variables permanecer√°n. </p><br><p>  Aqu√≠ est√° la implementaci√≥n del objeto <code>Environment</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Environment</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">parent</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.vars = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(parent ? parent.vars : <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.parent = parent; } Environment.prototype = { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Environment(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }, <span class="hljs-attr"><span class="hljs-attr">lookup</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (scope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.hasOwnProperty.call(scope.vars, name)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> scope; scope = scope.parent; } }, <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.vars) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.vars[name]; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Undefined variable "</span></span> + name); }, <span class="hljs-attr"><span class="hljs-attr">set</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lookup(name); <span class="hljs-comment"><span class="hljs-comment">//          if (!scope &amp;&amp; this.parent) throw new Error("Undefined variable " + name); return (scope || this).vars[name] = value; }, def: function(name, value) { return this.vars[name] = value; } };</span></span></code> </pre> <br><p>  El objeto <code>Environment</code> tiene un campo <code>parent</code> que apunta al contexto externo.  Ser√° <code>null</code> para el contexto global.  Tiene un campo <code>vars</code> en el que hay todas las variables que pertenecen a este contexto.  Para un contexto global, es inmediatamente igual a un objeto vac√≠o ( <code>Object.create(null)</code> ) y una copia de las variables del contexto primario ( <code>Object.create(parent.vars)</code> ) para uno no global. </p><br><p>  Tiene varios m√©todos: </p><br><ul><li>  <code>extend()</code> : copia el contexto actual. </li><li>  <code>lookup(name)</code> : busca el contexto en el que <code>name</code> define la variable llamada <code>name</code> . </li><li>  <code>get(name)</code> : obtiene el valor de una variable llamada <code>name</code> .  Lanza una excepci√≥n si la variable no se ha definido. </li><li>  <code>set(name, value)</code> : establece el valor de una variable.  Este m√©todo busca el contexto en el que se define la variable.  Si no est√° definido, y no estamos en un contexto global, se lanzar√° una excepci√≥n. </li><li>  <code>def(name, value)</code> : crea (o superpone o anula) una variable en el contexto actual. </li></ul><br><h2 id="funkciya-evaluate">  <code>evaluate</code> funci√≥n </h2><br><p>  Ahora que tenemos el objeto <code>Environment</code> , podemos pasar a resolver el problema principal.  Esta funci√≥n ser√° un gran bloque de <code>switch</code> , que realizar√° alguna acci√≥n dependiendo del tipo de nodo transmitido: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">exp, env</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (exp.type) {</code> </pre> <br><p>  Para literales, simplemente devolvemos su valor: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"num"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"str"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"bool"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> exp.value;</code> </pre> <br><p>  Las variables se toman del contexto (el nombre de la variable est√° contenido en el campo de <code>value</code> ): </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"var"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> env.get(exp.value);</code> </pre> <br><p>  Para asignar, debemos asegurarnos de que en el lado izquierdo tengamos el nombre de la variable (nodo <code>var</code> ).  Si no es as√≠, simplemente lanzamos una excepci√≥n (no admitimos la asignaci√≥n a otra cosa que no sean variables).  A continuaci√≥n, establecemos el valor de la variable usando <code>env.set</code> .  Tenga en cuenta que el lado derecho de la expresi√≥n debe calcularse utilizando la llamada recursiva para <code>evaluate</code> : </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"assign"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exp.left.type != <span class="hljs-string"><span class="hljs-string">"var"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Cannot assign to "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(exp.left)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> env.set(exp.left.value, evaluate(exp.right, env));</code> </pre> <br><p>  Para un nodo de tipo <code>binary</code> debemos aplicar el operador para ambos operandos.  Escribiremos la funci√≥n <code>apply_op</code> m√°s tarde.  Adem√°s, llamamos <code>evaluate</code> para ambas partes de la expresi√≥n: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"binary"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> apply_op(exp.operator, evaluate(exp.left, env), evaluate(exp.right, env));</code> </pre> <br><p>  Un nodo de tipo <code>lambda</code> devolver√° un cierre de JavaScript normal, por lo que puede llamarse como una funci√≥n normal incluso desde JavaScript.  <code>make_lambda</code> funci√≥n <code>make_lambda</code> , que mostrar√© m√°s adelante: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"lambda"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_lambda(env, exp);</code> </pre> <br><p>  La ejecuci√≥n del nodo <code>if</code> bastante simple: primero encontramos el valor de la condici√≥n.  Si no es falso, devuelve el valor de la rama <code>then</code> .  De lo contrario, si hay una rama <code>else</code> , entonces su valor, o <code>false</code> : </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"if"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cond = evaluate(exp.cond, env); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cond !== <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluate(exp.then, env); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> exp.else ? evaluate(exp.else, env) : <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br><p>  El nodo <code>prog</code> es una secuencia de expresiones.  Simplemente ejecutamos todas las expresiones en orden y tomamos el valor de esta √∫ltima (el valor de la secuencia vac√≠a es <code>false</code> ): </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"prog"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> val = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; exp.prog.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">exp</span></span></span><span class="hljs-function">)</span></span>{ val = evaluate(exp, env) }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val;</code> </pre> <br><p>  Para un nodo de tipo <code>call</code> necesitamos llamar a una funci√≥n.  Antes de eso, encontraremos el valor de la funci√≥n en s√≠, encontraremos los valores de todos los argumentos y llamaremos a la funci√≥n usando <code>apply</code> : </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"call"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> func = evaluate(exp.func, env); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> func.apply(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, exp.args.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arg</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluate(arg, env); }));</code> </pre> <br><p>  Nunca llegaremos aqu√≠, pero en caso de que agreguemos un nuevo tipo de nodo al analizador y olvidemos agregarlo al int√©rprete: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"I don't know how to evaluate "</span></span> + exp.type); } }</code> </pre> <br><p>  Esta fue la parte principal del int√©rprete.  Arriba, utilizamos dos funciones que a√∫n no hemos implementado, as√≠ que comencemos: </p><br><h4 id="apply_op">  <code>apply_op</code> : </h4><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply_op</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">op, a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">num</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> x != <span class="hljs-string"><span class="hljs-string">"number"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Expected number but got "</span></span> + x); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">div</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num(x) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Divide by zero"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (op) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"+"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) + num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"-"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) - num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"*"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) * num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"/"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) / div(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"%"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) % div(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"&amp;&amp;"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a !== <span class="hljs-literal"><span class="hljs-literal">false</span></span> &amp;&amp; b; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"||"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a !== <span class="hljs-literal"><span class="hljs-literal">false</span></span> ? a : b; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) &lt; num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"&gt;"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) &gt; num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;="</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) &lt;= num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"&gt;="</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) &gt;= num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"=="</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a === b; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"!="</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a !== b; } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Can't apply operator "</span></span> + op); }</code> </pre> <br><p>  Recibe el tipo de operador y los argumentos.  <code>switch</code> simple e intuitivo.  A diferencia de JavaScript, que puede tomar cualquier valor, como variables, incluso aquellas que no tienen sentido.  Requerimos que los operandos de los operadores aritm√©ticos sean n√∫meros y no permitan la divisi√≥n por cero.  Para las cuerdas, llegaremos a algo m√°s tarde. </p><br><h4 id="make_lambda">  <code>make_lambda</code> : </h4><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">env, exp</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> names = exp.vars; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = env.extend(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; names.length; ++i) scope.def(names[i], i &lt; <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.length ? <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[i] : <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluate(exp.body, scope); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lambda; }</code> </pre> <br><p>  Como puede ver arriba, devuelve una funci√≥n JavaScript normal que utiliza el contexto pasado y las funciones AST.  Todo el trabajo se realiza solo cuando se llama a la funci√≥n en s√≠: se crea un contexto, se establecen argumentos (si no son suficientes, se vuelven <code>false</code> ).  Entonces el cuerpo de la funci√≥n simplemente se ejecuta en un nuevo contexto. </p><br><h4 id="nativnye-funkcii">  Funciones nativas </h4><br><p>  Como puede ver, no ten√≠amos forma de interactuar con JavaScript desde nuestro idioma.  Sol√≠a ‚Äã‚Äãusar las funciones <code>print</code> e <code>println</code> , pero no las <code>println</code> en ning√∫n lado.  Necesitamos escribirlos en JavaScript y simplemente agregarlos al contexto global. </p><br><p>  Aqu√≠ hay un ejemplo de dicho c√≥digo: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  -   var code = "sum = lambda(x, y) x + y; print(sum(2, 3));"; // ,  parse  TokenStream,      InputStream var ast = parse(TokenStream(InputStream(code))); //    var globalEnv = new Environment(); //  ""  "print" globalEnv.def("print", function(txt){ console.log(txt); }); //  evaluate(ast, globalEnv); //  5</span></span></code> </pre> <br><h4 id="ves-kod">  C√≥digo completo </h4><br><p>  Puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">descargar todo el c√≥digo</a> que hemos escrito todo este tiempo.  Se puede iniciar con NodeJS.  Simplemente pase el c√≥digo a la secuencia est√°ndar: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'sum = lambda(x, y) x + y; println(sum(2, 3));'</span></span> | node lambda-eval1.js</code> </pre> <br><h1 id="primery-koda">  Ejemplos de c√≥digo </h1><br><p>  Nuestro lenguaje de programaci√≥n, aunque simple, puede (en teor√≠a) resolver cualquier problema que una computadora pueda resolver.  Esto se debe a que algunos tipos m√°s inteligentes que nunca ser√©, Alonzo Church y Alan Turing, una vez demostraron que el c√°lculo Œª (c√°lculo lambda) es equivalente a una m√°quina Turing, y nuestro lenguaje Œª implementa c√°lculo Œª. </p><br><p>  Esto significa que incluso si nuestro idioma no tiene ninguna oportunidad, podemos ser capaces de darnos cuenta utilizando lo que ya tenemos.  O, si esto es dif√≠cil de hacer, podemos escribir un int√©rprete para otro idioma en este. </p><br><h4 id="cikly">  Ciclos </h4><br><p>  Los bucles no son un problema si tenemos recurrencia.  Ya he mostrado un ejemplo de un bucle implementado adem√°s de la recursividad.  Intent√©moslo de nuevo. </p><br><pre> <code class="python hljs">print_range = Œª(a, b) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a &lt;= b { print(a); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a + <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;= b { print(<span class="hljs-string"><span class="hljs-string">", "</span></span>); print_range(a + <span class="hljs-number"><span class="hljs-number">1</span></span>, b); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> println(<span class="hljs-string"><span class="hljs-string">""</span></span>); }; print_range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre> <br><p>  Pero aqu√≠ tenemos un problema: si aumentamos el n√∫mero de iteraciones, digamos, a 1000. Por ejemplo, aparece el error "Tama√±o m√°ximo de la pila de llamadas excedido" despu√©s de 600. Esto sucede porque el int√©rprete es recursivo y la recursividad alcanza la m√°xima profundidad. </p><br><p>  Este es un problema grave, pero hay una soluci√≥n.  Me gustar√≠a agregar nuevas construcciones para la iteraci√≥n ( <code>for</code> o <code>while</code> ), pero intentemos prescindir de ellas.  La recursi√≥n se ve hermosa, as√≠ que dej√©moslo.  M√°s adelante veremos c√≥mo sortear esta limitaci√≥n. </p><br><h4 id="struktury-dannyh-ih-otsutstvie">  Estructuras de datos (falta de ellas) </h4><br><p>  Hay tres tipos de datos en nuestro idioma Œª: n√∫meros, cadenas y tipos booleanos.  Puede parecer que no puede crear tipos complejos, como matrices u objetos.  Pero esto no es un tatuaje, tenemos un tipo m√°s: funci√≥n.  Resulta que si seguimos el c√°lculo Œª, entonces podemos crear cualquier estructura de datos, incluidos los objetos, incluso con herencia. </p><br><p>  Lo mostrar√© en el ejemplo de las listas.  Imaginemos que tenemos una funci√≥n <code>cons</code> que crea un objeto que contiene dos valores.  Llamemos a este objeto "celda" o "par".  Vamos a nombrar uno de los valores "auto" y el otro "cdr".  Solo porque se llaman as√≠ en Lisp.  Ahora, si tenemos un objeto "celda", entonces podemos obtener sus valores usando las funciones <code>car</code> y <code>cdr</code> : </p><br><pre> <code class="python hljs">x = cons(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>); print(car(x)); <span class="hljs-comment"><span class="hljs-comment">#  10 print(cdr(x)); #  20</span></span></code> </pre> <br><p>  Ahora podemos definir f√°cilmente una lista: </p><br><blockquote>  Una lista es un par que contiene el primer elemento en `car` y los elementos restantes en` cdr`.  ¬°Pero `cdr` puede contener solo un valor!  Este valor ser√° una lista.  Una lista es un par que contiene el primer elemento en `car` y los elementos restantes en` cdr`.  ¬°Pero `cdr` puede contener solo un valor!  Este valor ser√° una lista.  [...] <br></blockquote><p>  Este es un tipo de datos recursivo.  Pero queda un problema: ¬øcu√°ndo debe detenerse?  L√≥gicamente, deber√≠amos parar cuando <code>cdr</code> es una lista vac√≠a.  Pero, ¬øqu√© es una lista vac√≠a?  Para hacer esto, agreguemos un nuevo objeto llamado "NIL".  Se puede usar como pareja (podemos usar <code>car</code> y <code>cdr</code> en √©l, pero su resultado ser√° <code>NIL</code> ).  Ahora creemos una lista de los elementos 1, 2, 3, 4, 5: </p><br><pre> <code class="python hljs">x = cons(<span class="hljs-number"><span class="hljs-number">1</span></span>, cons(<span class="hljs-number"><span class="hljs-number">2</span></span>, cons(<span class="hljs-number"><span class="hljs-number">3</span></span>, cons(<span class="hljs-number"><span class="hljs-number">4</span></span>, cons(<span class="hljs-number"><span class="hljs-number">5</span></span>, NIL))))); print(car(x)); <span class="hljs-comment"><span class="hljs-comment"># 1 print(car(cdr(x))); # 2  Lisp  . cadr print(car(cdr(cdr(x)))); # 3 caddr print(car(cdr(cdr(cdr(x))))); # 4 cadddr print(car(cdr(cdr(cdr(cdr(x)))))); # 5     .</span></span></code> </pre> <br><p>  Se ve horrible cuando no hay una sintaxis especial para esto.  Pero solo quer√≠a mostrar que esto se puede hacer usando las caracter√≠sticas del lenguaje Œª existentes.  Aqu√≠ est√° la implementaci√≥n: </p><br><pre> <code class="python hljs">cons = Œª(a, b) Œª(f) f(a, b); car = Œª(cell) cell(Œª(a, b) a); cdr = Œª(cell) cell(Œª(a, b) b); NIL = Œª(f) f(NIL, NIL);</code> </pre> <br><p>  Cuando vi por primera vez <code>cons</code> / <code>car</code> / <code>cdr</code> hechos de esta manera, me sorprendi√≥ que no necesitaran un solo <code>if</code> (pero esto es extra√±o dado el hecho de que no est√° en el c√°lculo Œª original).  Por supuesto, ning√∫n lenguaje de programaci√≥n hace esto de esta manera, porque es extremadamente ineficiente, pero no hace que los c√°lculos Œª sean menos hermosos.  En un lenguaje claro, este c√≥digo hace lo siguiente: </p><br><ul><li>  la funci√≥n <code>cons</code> toma dos valores ( <code>a</code> y <code>b</code> ) y devuelve la funci√≥n que los contiene.  Esa funci√≥n es el objeto mismo de la pareja.  Ella toma un argumento y lo llama para ambos valores de la pareja. </li><li>  La funci√≥n <code>car</code> llama al argumento pasado, pasando una funci√≥n que devuelve el primer argumento. </li><li>  la funci√≥n <code>cdr</code> hace lo mismo que la funci√≥n <code>car</code> , pero la √∫nica diferencia es que la funci√≥n pasada devuelve el segundo argumento. </li><li>  la funci√≥n <code>NIL</code> funciona igual que <code>cons</code> , pero devuelve un par con dos valores iguales a NIL. </li></ul><br><pre> <code class="python hljs">cons = Œª(a, b) Œª(f) f(a, b); car = Œª(cell) cell(Œª(a, b) a); cdr = Œª(cell) cell(Œª(a, b) b); NIL = Œª(f) f(NIL, NIL); x = cons(<span class="hljs-number"><span class="hljs-number">1</span></span>, cons(<span class="hljs-number"><span class="hljs-number">2</span></span>, cons(<span class="hljs-number"><span class="hljs-number">3</span></span>, cons(<span class="hljs-number"><span class="hljs-number">4</span></span>, cons(<span class="hljs-number"><span class="hljs-number">5</span></span>, NIL))))); println(car(x)); <span class="hljs-comment"><span class="hljs-comment"># 1 println(car(cdr(x))); # 2 println(car(cdr(cdr(x)))); # 3 println(car(cdr(cdr(cdr(x))))); # 4 println(car(cdr(cdr(cdr(cdr(x)))))); # 5</span></span></code> </pre> <br><p>  Hay muchos algoritmos en las listas que se pueden implementar de forma recursiva y tener un aspecto l√≥gico.  Por ejemplo, aqu√≠ hay una funci√≥n que llama a la funci√≥n pasada para cada elemento de la lista: </p><br><pre> <code class="python hljs">foreach = Œª(list, f) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> list != NIL { f(car(list)); foreach(cdr(list), f); }; foreach(x, println);</code> </pre> <br><p>  Y aqu√≠ hay otro que crea una lista para un rango de n√∫meros: </p><br><pre> <code class="python hljs">range = Œª(a, b) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a &lt;= b then cons(a, range(a + <span class="hljs-number"><span class="hljs-number">1</span></span>, b)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> NIL; <span class="hljs-comment"><span class="hljs-comment">#     1  8 foreach(range(1, 8), Œª(x) println(x * x));</span></span></code> </pre> <br><p>  Las listas que implementamos anteriormente son inmutables (no podemos cambiar <code>car</code> o <code>cdr</code> despu√©s de que se haya creado la lista).  La mayor√≠a de Lisp tiene funciones para cambiar un par.  En Scheme se les llama <code>set-car!</code>  / <code>set-cdr!</code>  .  En Common Lisp, <code>rplaca</code> / <code>rplacd</code> .  Esta vez usamos los nombres de Scheme: </p><br><pre> <code class="python hljs">cons = Œª(x, y) Œª(a, i, v) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a == <span class="hljs-string"><span class="hljs-string">"get"</span></span> then <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">0</span></span> then x <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">0</span></span> then x = v <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> y = v; car = Œª(cell) cell(<span class="hljs-string"><span class="hljs-string">"get"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); cdr = Œª(cell) cell(<span class="hljs-string"><span class="hljs-string">"get"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); set-car! = Œª(cell, val) cell(<span class="hljs-string"><span class="hljs-string">"set"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, val); set-cdr! = Œª(cell, val) cell(<span class="hljs-string"><span class="hljs-string">"set"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, val); <span class="hljs-comment"><span class="hljs-comment">#  NIL     NIL = cons(0, 0); set-car!(NIL, NIL); set-cdr!(NIL, NIL); ## : x = cons(1, 2); println(car(x)); # 1 println(cdr(x)); # 2 set-car!(x, 10); set-cdr!(x, 20); println(car(x)); # 10 println(cdr(x)); # 20</span></span></code> </pre> <br><p>  Esto muestra que podemos implementar estructuras de datos mutables.  No profundizar√© en c√≥mo funciona, est√° claro en el c√≥digo. </p><br><p>  Podemos ir m√°s all√° e implementar los objetos, pero sin cambios en la sintaxis ser√° dif√≠cil de hacer.  Otra forma es implementar una nueva sintaxis en el tokenizador / analizador y agregar su procesamiento en el int√©rprete.  Todos los lenguajes de programaci√≥n m√°s importantes hacen esto, y es necesario lograr un rendimiento normal.  Agregaremos una nueva sintaxis en la siguiente parte del art√≠culo. </p><br><p>  [Del traductor: si est√° interesado en el c√°lculo lambda, hay un art√≠culo interesante sobre Habr√© dedicado a este tema: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√°lculo Lambda en JavaScript</a> .] </p><br><h1 id="novye-sintaksicheskie-konstrukcii">  Nuevas construcciones de sintaxis </h1><br><p>  Nuestro lenguaje Œª tiene bastantes construcciones sint√°cticas.  Por ejemplo, no hay una forma directa de agregar nuevas variables.  Como dije antes, debemos usar IIFE, por lo que se ve as√≠: </p><br><pre> <code class="python hljs">(Œª(x, y){ (Œª(z){ <span class="hljs-comment"><span class="hljs-comment">## it gets worse when one of the vars depends on another print(x + y + z); })(x + y); })(2, 3);</span></span></code> </pre> <br><p>  Agregaremos la palabra clave <code>let</code> .  Esto nos permitir√° escribir algo como esto: </p><br><pre> <code class="python hljs">let (x = <span class="hljs-number"><span class="hljs-number">2</span></span>, y = <span class="hljs-number"><span class="hljs-number">3</span></span>, z = x + y) print(x + y + z);</code> </pre> <br><p>  Para cada variable en el bloque <code>let</code> , las variables anteriores deber√≠an estar disponibles incluso desde el mismo bloque.  Por lo tanto, el c√≥digo anterior ser√° equivalente a lo siguiente: </p><br><pre> <code class="python hljs">(Œª(x){ (Œª(y){ (Œª(z){ print(x + y + z); })(x + y); })(<span class="hljs-number"><span class="hljs-number">3</span></span>); })(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br><p>  Estos cambios pueden realizarse directamente en el analizador y luego no requerir√°n cambios en el int√©rprete.  En lugar de agregar un nuevo nodo <code>let</code> , podemos convertirlo en nodos <code>call</code> y <code>lambda</code> .  Esto significa que no hicimos ning√∫n cambio sem√°ntico en nuestro idioma, esto se llama "az√∫car sint√°ctico", y la operaci√≥n de convertir esto en nodos AST que exist√≠a antes se llama "sin az√∫car" (original: "desugaring"). </p><br><p>  Sin embargo, debemos cambiar el analizador de todos modos.  Agreguemos un nuevo nodo "let" porque se puede interpretar de manera m√°s eficiente (no es necesario crear cierres y llamarlos de inmediato, solo necesitamos copiar y cambiar el contexto). </p><br><p>  Adem√°s, agregaremos soporte para "let named", que estaba en Scheme.  Facilita la creaci√≥n de bucles: </p><br><pre> <code class="python hljs">print(let loop (n = <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> then n + loop(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  Este es un ciclo "recursivo" que cuenta la suma de 10 + 9 + ... + 0. Anteriormente, tendr√≠amos que hacerlo as√≠: </p><br><pre> <code class="python hljs">print((Œª(loop){ loop = Œª(n) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> then n + loop(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; loop(<span class="hljs-number"><span class="hljs-number">10</span></span>); })());</code> </pre> <br><p>  Adem√°s, para facilitar esto, agregaremos la sintaxis de "funciones con un nombre".  Se ver√° as√≠: </p><br><pre> <code class="python hljs">print((Œª loop (n) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> then n + loop(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-number"><span class="hljs-number">10</span></span>));</code> </pre> <br><p>  Modificaciones que deben hacerse para esto: </p><br><ul><li>  Soporte para nombre opcional despu√©s de la palabra clave <code>lambda</code> .  Si est√° presente, entonces debemos agregar una variable al contexto actual que apunte a la funci√≥n misma.  Esto es exactamente lo mismo que las funciones con un nombre en JavaScript. </li><li>  Soporte para la nueva palabra clave <code>let</code> .  Luego viene un nombre opcional y una lista (posiblemente vac√≠a) de definiciones de variables en esta forma: <code>foo = EXPRESSION</code> , separadas por comas.  El cuerpo de la expresi√≥n <code>let</code> es una expresi√≥n √∫nica (que, por supuesto, puede ser una secuencia de expresiones). </li></ul><br><h4 id="izmeneniya-v-parsere">  Cambios de analizador </h4><br><p>  Primero, un peque√±o cambio en el tokenizador, agregue la palabra clave <code>let</code> a la lista de palabras clave: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keywords = <span class="hljs-string"><span class="hljs-string">" let if then else lambda Œª true false "</span></span>;</code> </pre> <br><p>  Cambie la funci√≥n <code>parse_lambda</code> que lea un nombre opcional: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"lambda"</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: input.peek().type == <span class="hljs-string"><span class="hljs-string">"var"</span></span> ? input.next().value : <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-comment"><span class="hljs-comment">//   vars: delimited("(", ")", ",", parse_varname), body: parse_expression() }; }</span></span></code> </pre> <br><p>  Ahora agregue una funci√≥n que analice la expresi√≥n <code>let</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_let</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ skip_kw(<span class="hljs-string"><span class="hljs-string">"let"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (input.peek().type == <span class="hljs-string"><span class="hljs-string">"var"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = input.next().value; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> defs = delimited(<span class="hljs-string"><span class="hljs-string">"("</span></span>, <span class="hljs-string"><span class="hljs-string">")"</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, parse_vardef); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"call"</span></span>, <span class="hljs-attr"><span class="hljs-attr">func</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"lambda"</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: name, <span class="hljs-attr"><span class="hljs-attr">vars</span></span>: defs.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">def</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> def.name }), <span class="hljs-attr"><span class="hljs-attr">body</span></span>: parse_expression(), }, <span class="hljs-attr"><span class="hljs-attr">args</span></span>: defs.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">def</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> def.def || FALSE }) }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"let"</span></span>, <span class="hljs-attr"><span class="hljs-attr">vars</span></span>: delimited(<span class="hljs-string"><span class="hljs-string">"("</span></span>, <span class="hljs-string"><span class="hljs-string">")"</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, parse_vardef), <span class="hljs-attr"><span class="hljs-attr">body</span></span>: parse_expression(), }; }</code> </pre> <br><p>  Esto maneja dos casos.  Si despu√©s de <code>let</code> hay un token de tipo <code>var</code> , este se <code>let</code> con un nombre.  Adem√°s, leemos la lista de definiciones usando la funci√≥n <code>delimited</code> , ya que est√°n entre par√©ntesis y separadas por comas, y usamos la funci√≥n <code>parse_vardef</code> , que se muestra a continuaci√≥n.  A continuaci√≥n, devolvemos un nodo de tipo <code>call</code> , que llama inmediatamente a una funci√≥n llamada (IIFE).  Los argumentos de la funci√≥n son las variables definidas por <code>let</code> , y el nodo de <code>call</code> pasar√° los valores como argumentos.  Y, por supuesto, el cuerpo de la funci√≥n se lee usando <code>parse_expression()</code> . </p><br><p>  Si es un <code>let</code> simple, entonces devolvemos un nodo de tipo <code>let</code> con los campos <code>vars</code> y <code>body</code> .  El campo <code>vars</code> contiene una matriz de variables en el siguiente formato: <code>{ name: VARIABLE, def: AST }</code> , que se analizan mediante la siguiente funci√≥n: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_vardef</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = parse_varname(), def; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_op(<span class="hljs-string"><span class="hljs-string">"="</span></span>)) { input.next(); def = parse_expression(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: name, <span class="hljs-attr"><span class="hljs-attr">def</span></span>: def }; }</code> </pre> <br><p>  Adem√°s, debe agregar una verificaci√≥n para un nuevo tipo de expresi√≥n en la funci√≥n <code>parse_atom</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      parse_if if (is_kw("let")) return parse_let();</span></span></code> </pre> <br><h4 id="izmeneniya-v-interpretatore">  Cambios de int√©rprete </h4><br><p>  Dado que decidimos cambiar la estructura del AST en lugar de "descifrarlo" en los viejos tipos de nodos, debemos agregar el procesamiento de la nueva l√≥gica al int√©rprete. </p><br><p>  Para agregar soporte para el nombre de la funci√≥n opcional, modificamos la funci√≥n <code>make_lambda</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">env, exp</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exp.name) { <span class="hljs-comment"><span class="hljs-comment">//  env = env.extend(); //  env.def(exp.name, lambda); //  } //  function lambda() { var names = exp.vars; var scope = env.extend(); for (var i = 0; i &lt; names.length; ++i) scope.def(names[i], i &lt; arguments.length ? arguments[i] : false); return evaluate(exp.body, scope); } return lambda; }</span></span></code> </pre> <br><p>  Si la funci√≥n tiene un nombre, cuando creamos el cierre, hacemos una copia del contexto y agregamos la funci√≥n al contexto.  El resto sigue igual. </p><br><p>  Y finalmente, para procesar un nodo de tipo <code>let</code> , agregamos el siguiente caso al int√©rprete: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"let"</span></span>: exp.vars.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = env.extend(); scope.def(v.name, v.def ? evaluate(v.def, env) : <span class="hljs-literal"><span class="hljs-literal">false</span></span>); env = scope; }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluate(exp.body, env);</code> </pre> <br><p>  Tenga en cuenta que para cada variable se crea un nuevo contexto en el que se agrega una nueva variable.  Despu√©s de eso, simplemente ejecutamos el cuerpo en el √∫ltimo contexto. </p><br><h4 id="primery">  Ejemplos </h4><br><pre> <code class="python hljs">println(let loop (n = <span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> then n + loop(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>); let (x = <span class="hljs-number"><span class="hljs-number">2</span></span>, y = x + <span class="hljs-number"><span class="hljs-number">1</span></span>, z = x + y) println(x + y + z); <span class="hljs-comment"><span class="hljs-comment">#   ..     let # print(x + y + z); let (x = 10) { let (x = x * 2, y = x * x) { println(x); ## 20 println(y); ## 400 }; println(x); ## 10 };</span></span></code> </pre> <br><h4 id="proizvoditelnost-interpretatora">   </h4><br><p>   ‚Äî  . </p><br><p>   .        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> , ,           ,     .        JavaScript    Œª. </p><br><p>    : </p><br><pre> <code class="javascript hljs">globalEnv.def(<span class="hljs-string"><span class="hljs-string">"fibJS"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fibJS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fibJS(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) + fibJS(n - <span class="hljs-number"><span class="hljs-number">2</span></span>); }); globalEnv.def(<span class="hljs-string"><span class="hljs-string">"time"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t1 = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ret = fn(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t2 = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); println(<span class="hljs-string"><span class="hljs-string">"Time: "</span></span> + (t2 - t1) + <span class="hljs-string"><span class="hljs-string">"ms"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; });</code> </pre> <br><p>  <code>time</code>  ,       ,  ,    . </p><br><pre> <code class="python hljs">fib = Œª(n) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> then n <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> fib(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) + fib(n - <span class="hljs-number"><span class="hljs-number">2</span></span>); print(<span class="hljs-string"><span class="hljs-string">"fib(10): "</span></span>); time( Œª() println(fib(<span class="hljs-number"><span class="hljs-number">10</span></span>)) ); print(<span class="hljs-string"><span class="hljs-string">"fibJS(10): "</span></span>); time( Œª() println(fibJS(<span class="hljs-number"><span class="hljs-number">10</span></span>)) ); println(<span class="hljs-string"><span class="hljs-string">"---"</span></span>);</code> </pre> <br><p>   ,   Google Chrome,   n (27),  Œª  ,  ,   JS   4 . , ,  . </p><br><p>       Œª  JavaScript.    ,      <code>for</code> / <code>while</code> ;          JS.        ?  JS   ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a>  . </p><br><p> ,         ,          <em> </em> JavaScript,    ,    JavaScript. </p><br><p>    ,  ,  .   ,     . </p><br><h4 id="zaklyuchenie">  Conclusi√≥n </h4><br><p>       ,       .  ,       - ;  ,       ,            ?   ‚Äî JavaScript. ,         JavaScript ‚Äî     ? ,       ,    JavaScript,        , ,    .  JavaScript    ( ,       ). </p><br><p>  ,    ,  Lisp ‚Äî   :            //.    ,  ,        ..  Lisp  .    Lisp        <code>let</code> ,        ,                Lisp. </p><br><p>  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">     JavaScript.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3: int√©rprete de CPS</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/443812/">https://habr.com/ru/post/443812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443794/index.html">Las principales direcciones para las nuevas empresas de TI en el campo de las ventas de bienes ra√≠ces</a></li>
<li><a href="../443798/index.html">Hacks de Zotero: almacenamiento sincronizado ilimitado y su uso sin problemas con rmarkdown</a></li>
<li><a href="../443804/index.html">C # es un lenguaje de bajo nivel?</a></li>
<li><a href="../443808/index.html">An√°lisis de ni√±as con baja responsabilidad social (a cargo de Power BI, Qlik Sense, Tableau)</a></li>
<li><a href="../443810/index.html">¬øCu√°nto ganan los desarrolladores de diferentes calificaciones, 2018?</a></li>
<li><a href="../443814/index.html">Dar es mi "negocio anterior"</a></li>
<li><a href="../443816/index.html">El Ministerio de Comunicaciones insiste en un solo operador 5G</a></li>
<li><a href="../443818/index.html">Resumen de eventos de TI de marzo (segunda parte)</a></li>
<li><a href="../443820/index.html">C√≥mo el aeropuerto de Fukuoka descubri√≥ qu√© medidas ser√≠an efectivas para reducir las colas</a></li>
<li><a href="../443822/index.html">Orquesta de rendimiento</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>