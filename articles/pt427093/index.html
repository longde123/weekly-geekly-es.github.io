<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤬 🎶 🎧 Curso MIT "Segurança de sistemas de computadores". Aula 12: Segurança de Rede, Parte 3 👃🏻 👨🏿‍🍳 🎸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instituto de Tecnologia de Massachusetts. Curso de Aula nº 6.858. "Segurança de sistemas de computador". Nikolai Zeldovich, James Mickens. 2014 ano 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Curso MIT "Segurança de sistemas de computadores". Aula 12: Segurança de Rede, Parte 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/427093/"><h3>  Instituto de Tecnologia de Massachusetts.  Curso de Aula nº 6.858.  "Segurança de sistemas de computador".  Nikolai Zeldovich, James Mickens.  2014 ano </h3><br>  Computer Systems Security é um curso sobre o desenvolvimento e implementação de sistemas de computador seguros.  As palestras abrangem modelos de ameaças, ataques que comprometem a segurança e técnicas de segurança baseadas em trabalhos científicos recentes.  Os tópicos incluem segurança do sistema operacional (SO), recursos, gerenciamento de fluxo de informações, segurança de idiomas, protocolos de rede, segurança de hardware e segurança de aplicativos da web. <br><br>  Palestra 1: “Introdução: modelos de ameaças” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 2: “Controle de ataques de hackers” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Aula 3: “Estouros de Buffer: Explorações e Proteção” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 4: “Separação de Privilégios” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 5: “De onde vêm os sistemas de segurança?” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> <br>  Palestra 6: “Oportunidades” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 7: “Sandbox do Cliente Nativo” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Aula 8: “Modelo de Segurança de Rede” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Aula 9: “Segurança de aplicativos da Web” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 10: “Execução Simbólica” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Aula 11: “Linguagem de Programação Ur / Web” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Aula 12: Segurança de rede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <a name="habracut"></a><br><br>  <b>Aluno:</b> existe algum tipo de assinatura para domínios de nível superior inexistentes? <br><br>  <b>Professor:</b> Eu acho que sim.  Um domínio de ponto é apenas outro domínio e implementa o mesmo mecanismo.  Atualmente, os domínios "ponto" e "ponto.com" usam a SEC DNS, e existem todos esses registros que dizem, por exemplo, que .in é o nome de domínio que existe e o nome "ponto" também existe, e não há mais nada entre eles.  Portanto, nos domínios de nível superior, todas essas coisas estão presentes. <br><br><img src="https://habrastorage.org/webt/2u/gs/44/2ugs448d0swpqq4xpdcq7qrzo5e.jpeg"><br><br>  <b>Aluno:</b> além do perigo de ataques de DoS, por que nos preocupamos tanto com a repetição de nomes de domínio no mit.edu? <br><br>  <b>Professor:</b> não sei ao certo.  De qualquer forma, o AFS possui um arquivo de texto que lista todos esses nomes de domínio do MIT.  Mas acho que, em geral, algumas empresas se sentem um pouco estranhas nesse sentido, porque geralmente têm nomes internos que estão no DNS e que não podem ser dados a pessoas de fora.  Penso que, de fato, esta é uma área confusa que nunca foi formalizada e que não explica exatamente o que garante que os usuários do DNS ofereçam.  Geralmente, as pessoas assumem que, se existir um nome confidencial, no caso do DNS, ele não será divulgado. <br><br>  Penso que este é outro local em que este sistema não possui uma especificação clara em termos do que deve ou não fornecer. <br><br>  <b>Aluno: é</b> possível definir o período de validade de uma assinatura destacando-a de alguma forma? <br><br>  <b>Professor:</b> essas coisas têm uma data de validade, por exemplo, você pode assinar que esse conjunto de nomes é válido por uma semana e, em seguida, os clientes, se tiverem um relógio sincronizado, podem rejeitar as mensagens antigas assinadas. <br><br>  Portanto, podemos assumir que discutimos ataques adivinhando os números de sequência TCP SYN.  Outra questão interessante sobre o TCP é o ataque DDoS, que explora o fato de o servidor estar em algum estado.  Se você observar esse handshake, que foi desenhado anteriormente no quadro, verá que, quando o cliente estabelece uma conexão com o servidor, o servidor deve lembrar o número de série do cliente SNc.  Portanto, o servidor deve suportar alguma estrutura de dados em um bloco separado, o que mostra que esse número de sequência é usado para esta conexão. <br><br><img src="https://habrastorage.org/webt/lf/_t/al/lf_tald10iu_psgepzhjfretcr0.jpeg"><br><br>  Este é um tipo de tabela em que o número de sequência SN é armazenado e que a conexão cliente-servidor possui o número de sequência SNc.  O motivo pelo qual o servidor deve manter essa tabela é porque ele precisa descobrir qual o número de sequência SNc correto deve levar posteriormente, por exemplo, SNc + 1.  Além disso, o servidor também precisa armazenar números de SNs, que são muito mais importantes, pois mostram ao servidor que a conexão é estabelecida com o "cara certo". <br><br>  O problema é que esta tabela não possui uma borda real.  Dessa forma, você pode obter pacotes de alguma máquina sem saber quem os está enviando.  Você acaba de obter um pacote que se parece com C-&gt; S com um endereço de origem que afirma ser C. Para potencialmente aceitar essa conexão desse endereço IP, você deve criar uma entrada na tabela.  Além disso, esses registros existem por um longo tempo, porque, talvez, alguém estabeleça uma conexão com você a partir de um local muito distante e, ao mesmo tempo, muitos pacotes sejam perdidos.  Na pior das hipóteses, pode levar, por exemplo, um minuto até que alguém termine esse handshake TCP.  Portanto, você deve manter esse estado na pilha TCP por um tempo relativamente longo e não há como adivinhar se será válido ou não. <br><br>  Portanto, o ataque de DoS mais comum contra a maioria das pilhas TCP criadas pelas pessoas é a transmissão simples de um grande número de pacotes.  Se eu sou um invasor, basta enviar um grande número de pacotes SYN para um servidor específico e causar o estouro dessa tabela. <br><br>  O problema é que, na melhor das hipóteses, um invasor simplesmente usa o mesmo endereço IP de origem.  Nesse caso, você pode simplesmente dizer que cada cliente tem permissão apenas para duas entradas, ou algo assim.  E então o invasor pode usar no máximo 2 duas entradas na tabela. <br><br>  O problema, é claro, é que um invasor pode falsificar endereços IP de clientes e fazer com que pareçam aleatórios.  Então, será muito difícil para o servidor distinguir quem está tentando estabelecer uma conexão com ele - um invasor ou algum cliente que o servidor nunca ouviu falar antes. <br><br>  Portanto, se você procurar algum site que aceite conexões de qualquer lugar do mundo, isso será um grande problema.  Como você nega o acesso a todos ou deve poder armazenar o estado para a maioria das tentativas de conexão falsas. <br><br>  Portanto, esse é um problema para o TCP e a maioria dos protocolos que permitem um tipo de iniciação de conexão, no qual o servidor deve salvar o estado.  Mas há algumas correções implementadas no TCP sobre as quais falaremos em um segundo, e elas tentarão lidar com esse problema, chamado SYN Flooding in TCP. <br><br><img src="https://habrastorage.org/webt/ds/iv/2l/dsiv2l98atlrnyqwfzc3pg2-jma.jpeg"><br><br>  Em geral, esse é um problema que você deve conhecer e tentar evitar em qualquer protocolo que esteja desenvolvendo.  Você deve especificar que o servidor não deve salvar o estado até poder autenticar e identificar o cliente.  Porque somente após a autenticação do cliente é possível tomar uma decisão se é permitido conectar-se, por exemplo, apenas uma vez; nesse caso, o servidor não precisa salvar o estado para esta conexão. <br><br>  O problema é que você garante a preservação do estado antes mesmo de saber quem está se conectando a você.  Vamos ver como podemos combater o ataque de inundação do SYN Flooding, que é o servidor que está acumulando muito estado. <br><br>  Você pode alterar o TCP novamente, por exemplo, corrigi-lo facilmente com criptografia ou outra coisa ou alterar o que é responsável por salvar algum estado.  Mas o fato é que precisamos usar o TCP como ele é.  Poderíamos resolver esse problema sem modificar o protocolo TCP existente? <br><br>  Este é novamente um exercício para tentar descobrir exatamente quais truques poderíamos executar, ou melhor, quais suposições poderíamos deixar em paz e ainda assim aderir ao formato de cabeçalho TCP existente ao trabalhar com eles. <br><br>  E o truque é encontrar uma maneira inteligente de criar um servidor sem estado, para que ele não precise armazenar esta tabela na memória.  Isso pode ser feito escolhendo SNs com cuidado, ou seja, em vez da fórmula que consideramos anteriormente e onde tivemos que adicionar essa função, escolheremos os números de série de uma maneira completamente diferente.  Vou lhe dar a fórmula exata, e depois falaremos sobre por que é realmente interessante e quais são as boas propriedades. <br><br>  Se o servidor detectar que está sofrendo um ataque desse tipo, entrará no modo em que seleciona SNs usando a fórmula com a mesma função F que consideramos anteriormente. <br><br><img src="https://habrastorage.org/webt/ai/u5/2u/aiu52uoadhfflnvhgntwy_bedju.jpeg"><br><br>  Esta função possui o endereço IP de origem, o endereço IP de destino, da mesma forma que antes - porta de origem, porta de destino, carimbo de data e hora e chave.  E vamos combinar essa função com um carimbo de data / hora, em vez de "granulação grossa", com alguns minutos de tamanho.  Há uma separação entre essas duas partes do cabeçalho - a função e o registro de data e hora, que não precisam de muitos bits.  Esqueci como exatamente esse protocolo funciona em um computador real, mas você pode imaginar que o carimbo de data / hora leva 8 bits e o restante da fórmula do número de sequência é de 24 bits. <br><br>  Então, por que esse é um bom plano?  O que está acontecendo aqui?  Por que essa fórmula estranha é necessária?  Você deve se lembrar do que tentamos obter dos números de série.  Duas coisas acontecem aqui. <br><br>  O primeiro é a proteção contra pacotes duplicados.  Permaneceu na placa um circuito com esse número de série à moda antiga, ao qual adicionamos uma função para impedir a duplicação de pacotes de conexões anteriores. <br><br><img src="https://habrastorage.org/webt/sw/06/2g/sw062gymfw2nxnff7rciprvtjsy.jpeg"><br><br>  Acontece que as pessoas não conseguiram encontrar uma maneira melhor de se proteger de ataques como o SYN Flooding, exceto usar esse plano de ação, que funciona bem em algumas situações.  Era um plano, mas outro era uma função de data e hora em que abandonamos esse componente do estilo antigo.  Em vez disso, focaremos em garantir que, se alguém nos fornecer esse número de sequência ACK (SNs) em resposta ao pacote, essa pessoa será o cliente "certo". <br><br>  Você se lembra que, para evitar ataques de falsificação de IP, meio que confiamos nesse valor (SNs).  Afinal, se o servidor enviar esse valor de SNs para o cliente na segunda etapa, esperamos que somente esse cliente possa nos enviar o valor corrigido de SNs na terceira etapa, concluindo a conexão. <br><br>  É por isso que você teve que armazenar esse número de série em uma tabela, porque, caso contrário, como você saberia se essa é uma resposta real ou falsa?  A razão para usar esta função F é que agora não podemos salvar esta tabela na memória. <br><br>  Em vez disso, quando a tentativa de conexão é mostrada, mostrada na primeira etapa, na segunda etapa calculamos os SNs usando essa fórmula e simplesmente os enviamos de volta ao cliente que deseja entrar em contato conosco, e esquecemos essa conexão. <br><br><img src="https://habrastorage.org/webt/u7/uh/ml/u7uhml0zefpx1udtmt4j5xnaqxw.jpeg"><br><br>  Então, quando o terceiro pacote chegar e seu valor (SNs) corresponder ao que esperamos ver, significa que alguém recebeu nossa resposta na segunda etapa e finalmente a enviou para nós.  Finalmente, após esta terceira etapa, podemos colocar o registro real dessa conexão TCP na memória.  Essa é uma maneira de adiar a persistência do servidor até que o cliente envie o valor exato do número de série.  A construção dessa construção possibilita verificar se o cliente enviou ao servidor exatamente a resposta que se espera dele e não algum valor arbitrário. <br><br>  <b>Aluno:</b> o SNc dura apenas um tempo limitado? <br><br>  <b>Professor:</b> sim, o servidor não armazena o valor SNc permanentemente, e isso não é muito bom.  Eu não mostrei isso no diagrama, mas aqui no final da terceira linha há um campo que mostra que esse pacote não possui dados, mas inclui o número de sequência SNc apenas porque possui esse campo. <br><br><img src="https://habrastorage.org/webt/bv/5t/xz/bv5txzbklzepqcnw7bmu9n9ykki.jpeg"><br><br>  Assim, o servidor pode restaurar o valor do SNc, porque o cliente o incluirá neste pacote de qualquer maneira.  Anteriormente, isso não importava, mas agora é como se fosse relevante.  Não vamos verificar nada aqui, mas a existência de tal campo é em si uma coisa boa.  No entanto, tem algumas conseqüências tristes.  Por exemplo, se você usar algumas coisas complicadas que podem ser abusadas aqui.  Mas isso não é tão ruim quanto sobrecarregar a memória do servidor com solicitações do cliente. <br><br>  Porque a única coisa que nos preocupa é liberar o armazenamento dessa tabela e a confiança de que as conexões são estabelecidas com clientes genuínos.  E se esse cliente estabelecer um milhão de conexões comigo, pararei de aceitar solicitações dele, é bastante simples.  O problema é que é difícil distinguir endereços falsos de endereços de clientes genuínos. <br><br>  <b>Aluno:</b> preciso manter um registro de data e hora? <br><br>  <b>Professor:</b> sim, há uma coisa inteligente!  Quando obtemos o valor dos SNs na terceira etapa, precisamos descobrir como calcular os dados de entrada para esta função F, a fim de verificar se esse valor está correto.  Portanto, pegamos o carimbo de data / hora localizado no final da embalagem e o usamos para calcular dentro da função.  Tudo o resto podemos restaurar.  Sabemos quem acabou de nos enviar o terceiro passo e pacote, temos todos esses campos e nossa chave, que, novamente, ainda é secreta, e o carimbo de data e hora dos últimos 8 bits da sequência.  Nesse caso, pode acontecer que excluamos carimbos de data / hora muito antigos, simplesmente banindo conexões antigas. <br><br>  <b>Aluno:</b> Eu acredito que você usa isso quando é atacado, apenas porque perde 8 bits de segurança ou por algum outro motivo? <br><br>  <b>Professor:</b> sim, isso não é muito bom, tem muitas propriedades ruins.  De certa forma, estamos realmente perdendo 8 bits de segurança.  Porque agora a parte indiscutível é de apenas 24 bits em vez de 32. <br><br>  Outro problema é o que acontece se você perder determinados pacotes?  No TCP, geralmente é aceito que, se o terceiro pacote for perdido, o cliente poderá estar esperando por nada.  Ou, desculpe-me, talvez o protocolo que executamos sobre essa conexão TCP seja um protocolo que pressupõe que o servidor inicialmente pretenda dizer algo, então eu me conecto e apenas ouço a resposta.  E no SMTP, por exemplo, o servidor deve me enviar algo como uma saudação por meio do protocolo.  Suponha que eu me conecte ao servidor SMTP, envie o terceiro pacote, acho que fiz tudo e apenas aguarde o servidor me responder, por exemplo: <br><br>  "Olá, este é um servidor SMTP, por favor me envie seu email!" <br><br>  Portanto, este terceiro pacote pode ser perdido.  No TCP real, o servidor lembra que, na segunda etapa, respondeu ao cliente, mas nunca recebeu um terceiro pacote de resposta.  Portanto, o servidor enviará ao cliente novamente um segundo pacote para reiniciar o terceiro pacote.  Obviamente, se o servidor não armazenar nenhum estado, ele não fará ideia do que enviar.  Isso torna o estabelecimento de uma conexão um tanto problemático, porque ambos os lados esperam um passo recíproco um do outro.  O servidor nem sabe que o cliente está aguardando uma resposta e o cliente está aguardando a resposta do servidor, embora não atenda porque não armazena o estado.  Portanto, esse é outro motivo pelo qual você não usa o modo produtivo do servidor constantemente. <br><br>  <b>Aluno:</b> você também pode ter perda de dados se estabelecer duas conexões de curta duração a partir de um host imediatamente após o outro. <br><br>  <b>Professor:</b> sim, claro.  Outra coisa é que nos recusamos a usar esse estilo antigo de número de sequência ISN, o que aumentou a independência dessas múltiplas conexões em um curto espaço de tempo.  Eu acho que há uma série de compromissos aqui, acabamos de falar sobre três deles, então há mais algumas razões para preocupação. <br><br>  Se pudéssemos desenvolver um protocolo a partir do zero, buscando o melhor, poderíamos apenas ter um bom volume de 64 bits separado para a função F e um volume de 64 bits para o registro de data e hora, e poderíamos usá-lo constantemente, sem desistir todas essas coisas legais. <br><br>  <b>Aluno:</b> os SNs no segundo e terceiro passo devem ser os mesmos? <br><br>  <b>Professor: é</b> claro, porque, caso contrário, o servidor não poderá concluir que este cliente recebeu nosso pacote.  Se o servidor não verificar se esses SNs têm o mesmo significado de antes, isso pode ser ainda pior - porque eu poderia falsificar uma conexão de um endereço IP arbitrário na primeira etapa e obter essa resposta na segunda etapa.  Ou eu nem receberia essa resposta porque ela é direcionada para um endereço IP diferente.  Na terceira etapa, eu estabeleço uma conexão a partir de outro endereço IP.  Nesse caso, o servidor suportaria a conexão estabelecida, espere que eu envie dados e assim por diante. <br><br><img src="https://habrastorage.org/webt/4l/ta/ju/4ltajum6836awmvn0sgd43vygee.jpeg"><br><br>  <b>Aluno:</b> mas o timestamp será diferente, certo?  Como o servidor pode recontar isso usando um novo carimbo de data e hora se ele não armazena o estado? <br><br>  <b>Professor:</b> como eu disse, esses registros de data e hora são bastante "granulares" e são classificados em minutos.  Se você se conectar no mesmo minuto, tudo estará em ordem, se você se conectar na borda do minuto - isso é muito ruim. <br><br>  Outro problema com este circuito é que ele é imperfeito de várias maneiras.  Mas a maioria dos sistemas em funcionamento, incluindo Linux, tem maneiras de detectar muitas entradas nesta tabela.  E quando a ameaça de seu transbordamento ocorre, o sistema muda para outro esquema. <br><br>  <b>Aluno:</b> se um invasor controla um grande número de endereços IP e faz o que você disse, mesmo se você alternar ... <br><br>  <b>Professor:</b> sim, você realmente pode fazer pouco.  A razão pela qual esse esquema nos importou tanto foi porque queríamos filtrar ou de alguma forma distinguir entre os agressores e os "mocinhos".  Se um invasor tiver mais endereços IP e apenas controlar mais máquinas do que os mocinhos, ele poderá se conectar ao nosso servidor, solicitar várias páginas da web ou manter contato. <br><br>  E então será muito difícil para o servidor determinar se as solicitações são recebidas de clientes legítimos ou se é apenas um invasor que liga os recursos do servidor.  Então você está absolutamente certo.  Esse esquema só funciona se o invasor tiver um pequeno número de endereços IP e desejar obter um efeito. <br><br>  E isso é motivo de preocupação, porque hoje alguns invasores controlam um grande número de computadores invadidos por usuários comuns.  Isso lhes permite criar DoS com uma frota de máquinas localizadas em todo o mundo, e é muito difícil se defender. <br><br>  Quero mencionar mais uma coisa interessante - a negação do serviço DoS é ruim por si só, mas ainda pior quando os próprios protocolos contribuem para esse ataque.  O invasor sabe disso e ataca principalmente sistemas com protocolos como o DNS.  O protocolo DNS inclui um cliente enviando uma solicitação ao servidor e o servidor envia uma resposta de volta ao cliente.  E, em muitos casos, o tamanho da resposta em bytes é muito maior que o volume da solicitação. <br><br><img src="https://habrastorage.org/webt/sy/gv/mq/sygvmq26-ayo8twvl0f6lkxnkja.jpeg"><br><br>  Você perguntou sobre o servidor mit.edu.  ,        ,     mit.edu —   ,    mit.edu,  ,    DNS SEC,   . <br><br>      100 ,   —  1000 . ,    «» -            .        ,        DNS-    .      100   - DNS-,  ,      ,       1000    . <br><br>     ,        .      ,       TCP SYN Flooding, DNS-      ,       .           , ,     « ». <br><br>        DNS.             .       ,           DNS-.        ,        .       . <br><br> <b>:</b>        DNS-     … <br><br> <b>:</b> ,     DNS-  ,    - . <br><br> <b>:</b>         ,      ? <br><br> <b>:</b>  ,       DNS-,    .     DNS-,     .      10    DNS-,      ,      ,  , ,      .    . ,  ,      DNS-,        . <br><br>     ,    DNS    ,     ,     ,           .       ,          . <br><br>  ,   ,       ,       –    ,   ,   ,   .    ,       ,   .       . <br><br>     DNS-         ,        .      ,           ,          . <br><br>        ,   : «,      ,   »!  ,  ,  DNS-            . <br><br>   ,         .   -  -,        .    DoS    ,                   .          ,    ,       ,  ,       . <br><br><img src="https://habrastorage.org/webt/ub/2r/rc/ub2rrcc5_hvwg939goz50wj08ve.jpeg"><br><br>    ,     ,   .     ,            ,      ,  . <br><br>      ,        ,      .        . <br><br> ,      DHCP,         .    , ,   IP-.  , , MIT  DHCP,   ,   , ,   IP-,    ,  DNS-,    ,         . <br><br>    ,    DHCP          DHCP-,         ,    DHCP-.           ,      ,     . ,          DHCP      IP-, : «,     DNS-  »!        DNS     . <br><br>   ,      .     ,  BGP,        IP-,       .    ,   ,   BGP, : «,         IP-!»,       : „, ,     “. <br><br><img src="https://habrastorage.org/webt/z2/tv/1u/z2tv1u_2r9qcpdqgfpgtf22xxgq.jpeg"><br><br> ,     ,     ,    IP-     .      IP-  ,  ,  IP-   .       IP-  ,      .      ,     .    ,   ,   ,     IP-.                ,     ,    . <br><br>       DNS SEC.  ,  ,     DNS,      ,       .    ,     ,  , ,        DNS SEC. <br><br> ,  ,       ,       .         :              ,      ,      ,  ,   ,      DoS — .             . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, você deve tentar evitar coisas como ataques SYN Flooding e ataques RST que permitem desconectar um usuário de rede arbitrário. </font><font style="vertical-align: inherit;">São coisas realmente prejudiciais em um nível baixo e difíceis de corrigir em um nível alto. </font><font style="vertical-align: inherit;">Porém, mais ou menos, garante a integridade e a confidencialidade dos dados usando criptografia. </font><font style="vertical-align: inherit;">Falaremos sobre como fazer isso na próxima palestra sobre Cerberus.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/BZTWXl9QNK8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A versão completa do curso está disponível </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br>  Obrigado por ficar conosco.  Você gosta dos nossos artigos?  Deseja ver materiais mais interessantes?  Ajude-nos fazendo um pedido ou recomendando a seus amigos, um <b>desconto de 30% para os usuários da Habr em um análogo exclusivo de servidores básicos que inventamos para você:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Toda a verdade sobre o VPS (KVM) E5-2650 v4 (6 núcleos) 10GB DDR4 240GB SSD 1Gbps da US $ 20 ou como dividir o servidor?</a>  (as opções estão disponíveis com RAID1 e RAID10, até 24 núcleos e até 40GB DDR4). <br><br>  <b>VPS (KVM) E5-2650 v4 (6 núcleos) 10GB DDR4 240GB SSD de 1Gbps até dezembro de graça</b> quando pagar por um período de seis meses, você pode fazer o pedido <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  <b>Dell R730xd 2 vezes mais barato?</b>  Somente nós temos <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2 TVs Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 a partir de US $ 249</a> na Holanda e nos EUA!</b>  Leia sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como criar um prédio de infraestrutura.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">classe usando servidores Dell R730xd E5-2650 v4 custando 9.000 euros por um centavo?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt427093/">https://habr.com/ru/post/pt427093/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt427077/index.html">Laplace Blur - É possível blub Laplace em vez de Gauss, quantas vezes é mais rápido e vale a pena a perda da precisão de 1/32</a></li>
<li><a href="../pt427079/index.html">NetApp Insight 2018</a></li>
<li><a href="../pt427081/index.html">Critérios da mente humana, do ponto de vista de um programador</a></li>
<li><a href="../pt427087/index.html">Curso MIT "Segurança de sistemas de computadores". Palestra 12: Segurança de Rede, Parte 2</a></li>
<li><a href="../pt427091/index.html">Verificação numérica da hipótese abc (sim, essa)</a></li>
<li><a href="../pt427095/index.html">Antimônio - CAD de um mundo paralelo</a></li>
<li><a href="../pt427097/index.html">O aplicativo móvel ajuda a detectar depressão e outros problemas psicológicos nos estágios iniciais.</a></li>
<li><a href="../pt427101/index.html">O Google planeja cobrar dos fabricantes de dispositivos móveis até US $ 40 por cada dispositivo vendido</a></li>
<li><a href="../pt427105/index.html">Aprenda a aprender: a educação continuada é a chave para a competitividade na era da economia digital</a></li>
<li><a href="../pt427107/index.html">Parsim X12 "no joelho"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>