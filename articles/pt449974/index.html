<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëµüèª üëäüèº üçû Netramesh - solu√ß√£o leve de malha de servi√ßo üëâ üëç ü•Ä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No processo de transi√ß√£o de um aplicativo monol√≠tico para uma arquitetura de microsservi√ßo, enfrentamos novos problemas. 


 Em um aplicativo monol√≠ti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Netramesh - solu√ß√£o leve de malha de servi√ßo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/avito/blog/449974/"><p>  No processo de transi√ß√£o de um aplicativo monol√≠tico para uma arquitetura de microsservi√ßo, enfrentamos novos problemas. </p><br><p>  Em um aplicativo monol√≠tico, geralmente √© bastante simples determinar em qual parte do sistema ocorreu um erro.  Provavelmente, o problema est√° no c√≥digo do pr√≥prio mon√≥lito ou no banco de dados.  Mas quando come√ßamos a procurar um problema na arquitetura de microsservi√ßos, nem tudo √© t√£o √≥bvio.  Voc√™ precisa encontrar todo o caminho que a solicita√ß√£o percorreu do come√ßo ao fim, para selecion√°-lo em centenas de microsservi√ßos.  Al√©m disso, muitos deles tamb√©m t√™m seus pr√≥prios reposit√≥rios, o que tamb√©m pode causar erros l√≥gicos, al√©m de problemas com desempenho e toler√¢ncia a falhas. </p><br><p><img src="https://habrastorage.org/webt/m8/0j/9n/m80j9nw5mgqijdf5crurmq7jv0q.png"></p><br><p>  Durante muito tempo, eu estava procurando por uma ferramenta que ajudasse a lidar com esses problemas (escrevi sobre ela em Habr√©: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2</a> ), mas, no final, criei minha pr√≥pria solu√ß√£o de c√≥digo aberto.  No artigo, falo sobre os benef√≠cios da abordagem de malha de servi√ßo e compartilho uma nova ferramenta para sua implementa√ß√£o. </p><a name="habracut"></a><br><p> O rastreamento distribu√≠do √© uma solu√ß√£o comum para o problema de encontrar erros em sistemas distribu√≠dos.  Mas e se o sistema ainda n√£o implementou essa abordagem para coletar informa√ß√µes sobre intera√ß√µes de rede ou, pior ainda, na parte do sistema que j√° funciona corretamente e na parte que n√£o funciona, uma vez que n√£o √© adicionado aos servi√ßos antigos?  Para determinar a causa raiz exata do problema, voc√™ deve ter uma imagem completa do que est√° acontecendo no sistema.  √â especialmente importante entender quais microsservi√ßos est√£o envolvidos nos principais caminhos cr√≠ticos dos neg√≥cios. </p><br><p>  Aqui, uma abordagem de malha de servi√ßo pode vir em nosso aux√≠lio, que lidar√° com todo o mecanismo para coletar informa√ß√µes de rede em um n√≠vel inferior ao que os pr√≥prios servi√ßos fazem.  Essa abordagem nos permite interceptar todo o tr√°fego e analis√°-lo em tempo real.  Al√©m disso, os aplicativos a respeito nem deveriam saber de nada. </p><br><h1 id="service-mesh-podhod">  Abordagem de malha de servi√ßo </h1><br><p>  A id√©ia principal da abordagem de malha de servi√ßo √© adicionar outra camada de infraestrutura na rede, o que nos permitir√° fazer qualquer coisa com a intera√ß√£o entre servi√ßos.  A maioria das implementa√ß√µes funciona da seguinte maneira: um cont√™iner lateral adicional com um proxy transparente √© adicionado a cada microsservi√ßo, atrav√©s do qual todo o tr√°fego de servi√ßo de entrada e sa√≠da √© passado.  E √© neste local que podemos fazer o balanceamento do cliente, aplicar pol√≠ticas de seguran√ßa, introduzir restri√ß√µes no n√∫mero de solicita√ß√µes e coletar informa√ß√µes importantes sobre a intera√ß√£o dos servi√ßos na produ√ß√£o. </p><br><p><img src="https://habrastorage.org/webt/6r/zb/zk/6rzbzk2278btzronnwaok9jyqcw.png"></p><br><h1 id="resheniya">  Solu√ß√µes </h1><br><p>  J√° existem v√°rias implementa√ß√µes dessa abordagem: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Istio</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">linkerd2</a> .  Eles fornecem muitos recursos prontos para uso.  Mas, ao mesmo tempo, uma grande sobrecarga chega a recursos.  Al√©m disso, quanto maior o cluster em que esse sistema funciona, mais recursos ser√£o necess√°rios para manter a nova infraestrutura.  No Avito, operamos clusters kubernetes com milhares de inst√¢ncias de servi√ßo (e seu n√∫mero continua crescendo rapidamente).  Na implementa√ß√£o atual, o Istio consome ~ 300Mb de RAM por inst√¢ncia de servi√ßo.  Devido ao grande n√∫mero de recursos, o balanceamento transparente tamb√©m afeta o tempo total de resposta dos servi√ßos (at√© 10 ms). </p><br><p>  Como resultado, analisamos exatamente quais recursos precis√°vamos no momento e decidimos que a principal raz√£o pela qual come√ßamos a implementar essas solu√ß√µes era a capacidade de coletar informa√ß√µes de rastreamento de todo o sistema de forma transparente.  Tamb√©m quer√≠amos ter controle sobre a intera√ß√£o dos servi√ßos e fazer v√°rias manipula√ß√µes com os cabe√ßalhos transferidos entre os servi√ßos. </p><br><p>  No final, chegamos √† nossa decis√£o: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Netramesh</a> . </p><br><h1 id="netramesh">  Netramesh </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O Netramesh</a> √© uma solu√ß√£o de malha de servi√ßo leve com escalabilidade infinita, independentemente do n√∫mero de servi√ßos no sistema. </p><br><p>  Os principais objetivos da nova solu√ß√£o foram uma pequena sobrecarga de recursos e alto desempenho.  Dentre os principais recursos, imediatamente desejamos poder enviar transparentemente intervalos de rastreamento para o nosso sistema Jaeger. </p><br><p>  Hoje, a maioria das solu√ß√µes em nuvem √© implementada no Golang.  E, √© claro, existem raz√µes para isso.  Escrever aplicativos de rede Golang que funcionam de forma ass√≠ncrona com E / S e escalonam para kernels conforme necess√°rio √© conveniente e bastante simples.  E, o que tamb√©m √© muito importante, o desempenho √© suficiente para resolver esse problema.  Portanto, tamb√©m escolhemos Golang. </p><br><h1 id="proizvoditelnost">  Desempenho </h1><br><p>  Concentramos nossos esfor√ßos em obter o m√°ximo desempenho.  Para uma solu√ß√£o implantada ao lado de cada inst√¢ncia do servi√ßo, √© necess√°rio um pequeno consumo de RAM e tempo do processador.  E, √© claro, o atraso na resposta tamb√©m deve ser pequeno. </p><br><p>  Vamos ver quais s√£o os resultados. </p><br><h2 id="ram">  RAM </h2><br><p>  O Netramesh consome ~ 10 Mb sem tr√°fego e 50 Mb no m√°ximo, com uma carga de at√© 10.000 RPS por inst√¢ncia. </p><br><p>  O proxy enviado do Istio sempre consome ~ 300Mb em nossos clusters com milhares de inst√¢ncias.  Isso n√£o permite dimension√°-lo para todo o cluster. </p><br><p><img src="https://habrastorage.org/webt/y6/io/ys/y6ioysd0roxkllgujmzof3lps30.png"></p><br><p><img src="https://habrastorage.org/webt/mi/70/2q/mi702qegemdopjkdh7or3bqv9c0.png"></p><br><p>  Com o Netramesh, obtivemos ~ 10 vezes menos consumo de mem√≥ria. </p><br><h2 id="cpu">  CPU </h2><br><p>  O uso da CPU √© relativamente igual sob carga.  Depende do n√∫mero de solicita√ß√µes por unidade de tempo para o side-car.  Valores em 3000 solicita√ß√µes por segundo no pico: </p><br><p><img src="https://habrastorage.org/webt/nm/dp/5s/nmdp5ssxux47zzuohvhacbgjqzw.png"></p><br><p><img src="https://habrastorage.org/webt/8y/kn/bq/8yknbqlejeqprvut2c2n_pgsay0.png"></p><br><p>  H√° outro ponto importante: Netramesh - uma solu√ß√£o sem um plano de controle e sem carga n√£o consome tempo da CPU.  Com o Istio, os sidecar sempre atualizam os terminais de servi√ßo.  Como resultado, podemos ver uma imagem sem carga: </p><br><p><img src="https://habrastorage.org/webt/hz/ne/2h/hzne2hf6m_z_tefolvtoiwuwcpq.png"></p><br><p>  Usamos HTTP / 1 para nos comunicarmos entre servi√ßos.  O aumento no tempo de resposta para o Istio quando o proxy atrav√©s do enviado era de 5 a 10 ms, o que √© bastante para servi√ßos prontos para responder em um milissegundo.  Com o Netramesh, esse tempo diminuiu para 0,5-2ms. </p><br><h1 id="masshtabiruemost">  Escalabilidade </h1><br><p>  Uma pequena quantidade de recursos gastos por cada proxy possibilita coloc√°-lo ao lado de cada servi√ßo.  O Netramesh foi criado intencionalmente sem um componente do plano de controle para simplesmente manter a leveza de cada carro lateral.  Geralmente, em solu√ß√µes de malha de servi√ßo, o plano de controle distribui informa√ß√µes de descoberta de servi√ßo para cada carro lateral.  Junto com ele, h√° informa√ß√µes sobre tempos limite, configura√ß√µes de balanceamento.  Tudo isso permite que voc√™ fa√ßa muitas coisas √∫teis, mas, infelizmente, aumenta de tamanho lateralmente. </p><br><h1 id="service-discovery">  Descoberta de servi√ßo </h1><br><p><img src="https://habrastorage.org/webt/sl/2o/gf/sl2ogfr5t31zfqwefxmcoe89xmu.png"></p><br><p>  O Netramesh n√£o adiciona nenhum mecanismo adicional para descoberta de servi√ßo.  Todo o tr√°fego √© proxy de forma transparente atrav√©s do carro lateral netra. </p><br><p> O Netramesh suporta o protocolo de aplicativo HTTP / 1.  Uma lista configur√°vel de portas √© usada para determin√°-lo.  Normalmente, existem v√°rias portas em um sistema que se comunicam por HTTP.  Por exemplo, usamos 80, 8890, 8080 para interagir com servi√ßos e solicita√ß√µes externas.Neste caso, eles podem ser configurados usando a <code>NETRA_HTTP_PORTS</code> ambiente <code>NETRA_HTTP_PORTS</code> . </p><br><p>  Se voc√™ usar o Kubernetes como uma orquestra e seu mecanismo de entidades de Servi√ßo para intera√ß√£o intracluster entre servi√ßos, o mecanismo permanecer√° exatamente o mesmo.  Primeiro, o microsservi√ßo obt√©m o endere√ßo IP do servi√ßo usando o kube-dns e abre uma nova conex√£o a ele.  Essa conex√£o √© estabelecida primeiro com o netra-sidecar local, e todos os pacotes TCP chegam inicialmente no netra.  Em seguida, o netra-sidecar estabelece uma conex√£o com o destino original.  O NAT no IP do pod no n√≥ permanece exatamente o mesmo que sem o netra. </p><br><h1 id="raspredelennyy-tracing-i-prokidyvanie-konteksta">  Rastreamento distribu√≠do e rolagem de contexto </h1><br><p>  O Netramesh fornece a funcionalidade necess√°ria para enviar intervalos de rastreamento sobre intera√ß√µes HTTP.  O Netra-sidecar analisa o protocolo HTTP, mede os atrasos na solicita√ß√£o, recupera as informa√ß√µes necess√°rias dos cabe√ßalhos HTTP.  Por fim, obtemos todos os rastreamentos em um √∫nico sistema Jaeger.  Para o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ajuste</a> fino <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">,</a> voc√™ tamb√©m pode usar as vari√°veis ‚Äã‚Äãde ambiente fornecidas pela <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">biblioteca</a> oficial do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">jaeger go</a> . </p><br><p><img src="https://habrastorage.org/webt/ak/rg/_a/akrg_a52och5z3sfg625xb8se6m.png"></p><br><p><img src="https://habrastorage.org/webt/ol/c9/ga/olc9gakhzkqcbgkcnjbhsy2e5eo.png"></p><br><p>  Mas h√° um problema.  At√© que os servi√ßos gerem e encaminhem um cabe√ßalho uber especial, n√£o veremos os intervalos de rastreamento conectados no sistema.  E √© isso que precisamos para encontrar rapidamente a causa dos problemas.  Aqui o Netramesh tem uma solu√ß√£o novamente.  Os proxies leem os cabe√ßalhos HTTP e, se n√£o tiverem um ID de rastreamento uber, gere-o.  O Netramesh tamb√©m armazena informa√ß√µes sobre solicita√ß√µes de entrada e sa√≠da no sidecar e as compara, enriquecendo os cabe√ßalhos necess√°rios das solicita√ß√µes de sa√≠da.  Tudo o que precisa ser feito nos servi√ßos √© lan√ßar apenas um cabe√ßalho <code>X-Request-Id</code> , que pode ser configurado usando a <code>NETRA_HTTP_REQUEST_ID_HEADER_NAME</code> ambiente <code>NETRA_HTTP_REQUEST_ID_HEADER_NAME</code> .  Para controlar o tamanho do contexto no Netramesh, voc√™ pode definir as seguintes vari√°veis ‚Äã‚Äãde ambiente: <code>NETRA_TRACING_CONTEXT_EXPIRATION_MILLISECONDS</code> (o tempo durante o qual o contexto ser√° armazenado) e <code>NETRA_TRACING_CONTEXT_CLEANUP_INTERVAL</code> (periodicidade da limpeza de contexto). </p><br><p>  Tamb√©m √© poss√≠vel combinar v√°rios caminhos no seu sistema, marcando-os com um marcador de sess√£o especial.  O Netra permite definir <code>HTTP_HEADER_TAG_MAP</code> para transformar cabe√ßalhos HTTP em tags de extens√£o de rastreio apropriadas.  Isso pode ser especialmente √∫til para testes.  Depois de passar no teste funcional, voc√™ pode ver qual parte do sistema foi afetada pela filtragem pela chave da sess√£o correspondente. </p><br><h1 id="opredelenie-istochnika-zaprosa">  Determinando a origem da solicita√ß√£o </h1><br><p>  Para determinar de onde veio a solicita√ß√£o, voc√™ pode usar a fun√ß√£o para adicionar automaticamente um cabe√ßalho a uma fonte.  Usando a <code>NETRA_HTTP_X_SOURCE_HEADER_NAME</code> ambiente <code>NETRA_HTTP_X_SOURCE_HEADER_NAME</code> voc√™ pode especificar o nome do cabe√ßalho que ser√° definido automaticamente.  Usando <code>NETRA_HTTP_X_SOURCE_VALUE</code> voc√™ pode definir o valor no qual o cabe√ßalho X-Source ser√° definido para todas as solicita√ß√µes de sa√≠da. </p><br><p>  Isso permite que voc√™ uniformemente em toda a rede fa√ßa a distribui√ß√£o desse cabe√ßalho √∫til.  Ent√£o voc√™ j√° pode us√°-lo em servi√ßos e adicion√°-lo a logs e m√©tricas. </p><br><h1 id="routing-trafika-i-vnutrennosti-netramesh">  Tr√°fego Netramesh e roteamento interno </h1><br><p>  O Netramesh consiste em dois componentes principais.  O primeiro, netra-init, define regras de rede para interceptar tr√°fego.  Ele usa <a href="">regras de redirecionamento do iptables</a> para interceptar todo ou parte do tr√°fego no side-car, que √© o segundo componente principal do Netramesh.  Voc√™ pode configurar as portas que deseja interceptar para as sess√µes TCP de entrada e sa√≠da: <code>INBOUND_INTERCEPT_PORTS, OUTBOUND_INTERCEPT_PORTS</code> . </p><br><p>  A ferramenta tamb√©m possui um recurso interessante - roteamento probabil√≠stico.  Se voc√™ usar o Netramesh exclusivamente para coletar extens√µes de rastreamento, em um ambiente de produ√ß√£o, poder√° economizar recursos e ativar o roteamento probabil√≠stico usando as vari√°veis <code>NETRA_INBOUND_PROBABILITY</code> e <code>NETRA_OUTBOUND_PROBABILITY</code> (de 0 a 1).  O valor padr√£o √© 1 (todo o tr√°fego √© interceptado). </p><br><p>  Ap√≥s uma intercepta√ß√£o bem-sucedida, o netra sidecar aceita uma nova conex√£o e usa a op√ß√£o de soquete <code>SO_ORIGINAL_DST</code> para obter o destino original.  O Netra ent√£o abre uma nova conex√£o com o endere√ßo IP original e estabelece uma comunica√ß√£o TCP bidirecional entre as partes, ouvindo todo o tr√°fego que passa.  Se a porta for definida como HTTP, o Netra tentar√° analis√°-la e encaminh√°-la.  Se a an√°lise HTTP n√£o for bem-sucedida, o Netra far√° fallback no TCP e nos bytes de proxy transparentemente. </p><br><h1 id="postroenie-grafa-zavisimostey">  Construindo um gr√°fico de depend√™ncia </h1><br><p>  Depois de receber muitas informa√ß√µes de rastreamento em Jaeger, quero obter um gr√°fico completo das intera√ß√µes no sistema.  Mas se o seu sistema estiver suficientemente carregado e bilh√µes de extens√µes de rastreamento se acumularem por dia, tornar sua agrega√ß√£o uma tarefa n√£o t√£o simples.  Existe uma maneira oficial de fazer isso: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">depend√™ncias de centelha</a> .  No entanto, levar√° horas para criar o gr√°fico completo e for√ßar o download de todo o conjunto de dados do Jaeger nas √∫ltimas 24 horas. </p><br><p>  Se voc√™ usar o Elasticsearch para armazenar intervalos de rastreamento, poder√° usar um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">utilit√°rio simples no Golang</a> que criar√° o mesmo gr√°fico em minutos usando os recursos e os recursos do Elasticsearch. </p><br><p><img src="https://habrastorage.org/webt/ob/t8/av/obt8avxi13fb9ykb1rj3ljreup0.png"></p><br><h1 id="kak-ispolzovat-netramesh">  Como usar o Netramesh </h1><br><p>  O Netra pode ser simplesmente adicionado a qualquer servi√ßo que esteja executando qualquer orquestrador.  Voc√™ pode ver um exemplo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p><br><p>  No momento, a Netra n√£o tem a capacidade de implantar side-car automaticamente nos servi√ßos, mas h√° planos de implementa√ß√£o. </p><br><h1 id="buduschee-netramesh">  Future Netramesh </h1><br><p>  O principal objetivo do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Netramesh</a> √© alcan√ßar custos m√≠nimos de recursos e alto desempenho, oferecendo as principais oportunidades de observabilidade e controle da intera√ß√£o entre servi√ßos. </p><br><p>  No futuro, o Netramesh receber√° suporte para protocolos em n√≠vel de aplicativo que n√£o sejam HTTP.  Em um futuro pr√≥ximo, haver√° a possibilidade de roteamento L7. </p><br><p>  Use o Netramesh se encontrar problemas semelhantes e escreva-nos perguntas e sugest√µes. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt449974/">https://habr.com/ru/post/pt449974/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt449964/index.html">Test drive nanoCAD SPDS Canteiro de obras 8. Parte 2</a></li>
<li><a href="../pt449966/index.html">Tabelas em Figma. Design da grade de dados por um componente</a></li>
<li><a href="../pt449968/index.html">Redmadrobot discute AppsConf 2019: v√≠deo</a></li>
<li><a href="../pt449970/index.html">Poste com a bandeira preta ou Como eu n√£o coloquei seu curso em v√≠deo no rastreador</a></li>
<li><a href="../pt449972/index.html">Como injetar rapidamente pools no upstream?</a></li>
<li><a href="../pt449976/index.html">Cont√™ineres associativos multithread em C ++. Relat√≥rio Yandex</a></li>
<li><a href="../pt449978/index.html">Igor Antarov do Moscow Tesla Club luta contra 20 mitos sobre Tesla e carros el√©tricos</a></li>
<li><a href="../pt449984/index.html">Google News e Leo Tolstoy: visualizando incorpora√ß√µes de palavras do Word2Vec usando t-SNE</a></li>
<li><a href="../pt449986/index.html">Blockchain: o que devemos construir um caso?</a></li>
<li><a href="../pt449990/index.html">Como fazer amigos de l√°tex, f√≥rmulas e Habr?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>