<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤½ğŸ¼ ğŸ—“ï¸ ğŸ”§ CrÃ©ation d'un module logiciel pour le programmateur XELTEK SuperPro 6100 ğŸ‘¨ğŸ¾â€ğŸ”¬ ğŸ˜‚ ğŸ‘©ğŸ¼â€ğŸ¤â€ğŸ‘¨ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PrÃ©face 
 Dans un article prÃ©cÃ©dent, le mÃ©canisme de protection du programmateur XELTEK SuperPro 6100 contre le clonage a Ã©tÃ© examinÃ©. 

 Cet article ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>CrÃ©ation d'un module logiciel pour le programmateur XELTEK SuperPro 6100</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430634/"><h4>  PrÃ©face </h4><br>  Dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> prÃ©cÃ©dent, le mÃ©canisme de protection du programmateur XELTEK SuperPro 6100 contre le clonage a Ã©tÃ© examinÃ©. <br><br>  Cet article dÃ©crira la crÃ©ation de son propre module logiciel pour ce programmeur, qui, par une certaine modification du code, peut Ãªtre adaptÃ© pour fonctionner avec tout autre type de microcircuits - actuellement non pris en charge ou, comme dans notre cas, dÃ©clarÃ© uniquement formellement. <br><br><h4>  Contexte </h4><br>  Une fois de plus, nous avons eu une tÃ¢che qui, Ã  premiÃ¨re vue, a Ã©tÃ© rÃ©solue tout simplement - il Ã©tait nÃ©cessaire de faire une copie d'une puce de mÃ©moire flash spÃ©cialisÃ©e - mDOC H3 SDED5-512M. <br><br>  Cette puce a Ã©tÃ© dÃ©veloppÃ©e il y a plus de dix ans.  Voici le pdf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">(1)</a> avec sa description.  Vous trouverez ci-dessous un court extrait de l'annonce en russe: <br><br>  <i>... msystems a prÃ©parÃ© la famille mDOC pour une utilisation en tant que disques SSD ...</i> <i><br></i>  <i>Le logiciel TrueFFS intÃ©grÃ©, qui est chargÃ© de gÃ©rer la mÃ©moire flash mDOC H3, exÃ©cute son propre contrÃ´leur de module, qui le transforme en une unitÃ© complÃ¨te et autonome, facilement ajoutÃ©e Ã  une variÃ©tÃ© d'appareils portables. ...</i> <br><a name="habracut"></a><br>  Dans la liste des SuperPro 6100 pris en charge par le programmeur, une telle puce a Ã©tÃ© rÃ©pertoriÃ©e et a mÃªme trouvÃ© l'adaptateur DX5057 correspondant.  Mais aprÃ¨s avoir assemblÃ© l'ensemble du concepteur et choisi cette puce, le programme a montrÃ© l'image suivante avec l'Ã©lÃ©ment mystÃ©rieux "DimageMain", dont la description n'a Ã©tÃ© trouvÃ©e ni dans la documentation ni sur le site Web du dÃ©veloppeur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0l/dy/hk/0ldyhknaorevv2x5mjq4cens0qw.jpeg"></div><br>  Ayant tentÃ© d'effectuer l'opÃ©ration Â«DimageMainÂ» sans puce dans l'adaptateur, un avertissement a Ã©tÃ© reÃ§u concernant son absence, et aprÃ¨s confirmation de ce fait, le programme a affichÃ© les informations suivantes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kh/x4/hk/khx4hkhkb3uu2w5zbpguawdzhh4.jpeg"></div><br>  A en juger par l'inscription Â«mDOC H3 Write ImageÂ», Â«ImageÂ» est une image qui peut Ãªtre Ã©crite sur une puce Ã  l'aide de ce programmateur.  Mais comment lire cette image Ã  partir d'un microcircuit dÃ©jÃ  enregistrÃ©, comment l'effacer, etc.? <br><br>  Un peu plus tard sur Internet, j'ai trouvÃ© un fichier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">(2)</a> de la sociÃ©tÃ© Dataman, qui montre partiellement la structure de l'image ci-dessus et mentionne le logiciel pour sa crÃ©ation. <br>  Ainsi, de nouveaux efforts visaient Ã  rechercher des utilitaires dans M-Systems dÃ©crits dans le document Software Utilities for TrueFFS 7.1 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">(3)</a> . <br><br>  La demande d'assistance technique des anciens Â«M-SystemsÂ», aujourd'hui Â«SanDiskÂ», n'a pas donnÃ© de rÃ©sultat - il n'y a tout simplement pas de rÃ©ponse. <br><br>  Sur Internet, il n'a Ã©tÃ© possible de trouver que d'anciens utilitaires ne prenant pas en charge la version des puces H3.  Le SDK complet de SanDisk n'a pas non plus Ã©tÃ© trouvÃ©, seulement ses Â«fragmentsÂ» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">(5)</a> en termes d'implÃ©mentation d'un pilote pour Linux. <br><br>  Pendant que nous Ã©tudiions les informations accumulÃ©es, la ligne suivante a attirÃ© l'attention du fichier Dataman: "Les fichiers image peuvent Ãªtre crÃ©Ã©s avec l'utilitaire SanDisk Docshell ou PG4UW." <br><br>  Les utilitaires SanDisk Docshell ne se sont pas trouvÃ©s en aucune faÃ§on, j'ai donc dÃ» comprendre comment PG4UW <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">(4)</a> fonctionnait avec cette puce.  Ils n'ont pas intÃ©grÃ© l'intÃ©gralitÃ© du SDK SanDisk dans leur logiciel, mais ont crÃ©Ã© un plug-in avec les mÃ©thodes exportÃ©es nÃ©cessaires au fonctionnement des utilitaires TrueFFS, qui sont ensuite appelÃ©es Ã  partir de leur programme. <br>  Nous irons de la mÃªme faÃ§on. <br><br><h4>  CrÃ©ation de votre propre module logiciel </h4><br>  Voici un dÃ©ni de responsabilitÃ©, Ã  savoir que l'auteur ne porte aucune responsabilitÃ© pour toute utilisation par vous des matÃ©riaux de cet article. <br>  En d'autres termes - vous seul serez responsable de vos actions, ce qui peut vous inciter Ã  vous familiariser avec ce matÃ©riel. <br><br>  <em>Nous convenons, comme dans l'article prÃ©cÃ©dent, d'appeler le programmeur programmeur de SuperPro 6100 simplement Â«logicielÂ», et l'ordinateur sur lequel ce programme fonctionne est Â«hÃ´teÂ».</em>  <em>Maintenant, nous avons un autre programme qui fonctionne dans le programmeur lui-mÃªme.</em>  <em>Nous l'appellerons le Â«module logicielÂ».</em> <br><br>  Le manuel Software Utilities for TrueFFS 7.1 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">(3)</a> dÃ©crit les fonctions implÃ©mentÃ©es par les utilitaires DOCSHELL, qui entrent dans les quatre catÃ©gories suivantes: <br><br><ul><li>  DFORMAT - utilitaires pour formater un pÃ©riphÃ©rique mDOC. </li><li>  DINFO - utilitaires pour obtenir une variÃ©tÃ© d'informations sur le pÃ©riphÃ©rique mDOC et les sections qui s'y trouvent. </li><li>  DIMAGE - utilitaires pour lire, Ã©crire et comparer le pÃ©riphÃ©rique image mDOC. </li><li>  SPLITIMAGE - utilitaires pour diviser l'image du pÃ©riphÃ©rique mDOC en parties. </li></ul><br>  Les utilitaires DOCSHELL Ã©taient destinÃ©s Ã  la ligne de commande, par consÃ©quent, l'interface de communication avec le plug-in DOCSHELL.dll a Ã©tÃ© implÃ©mentÃ©e Ã  l'aide du mÃªme mÃ©canisme de commande de texte. <br>  Avant de commencer la communication avec Â«DOCSHELL.dllÂ», il est nÃ©cessaire d'appeler chacune des mÃ©thodes exportÃ©es et de leur passer des pointeurs vers les fonctions implÃ©mentÃ©es dans le logiciel pour un Ã©change physique avec la puce mDOC.  Il s'agit de l'Ã©criture et de la lecture (en plusieurs modifications), ainsi que des mÃ©thodes de rÃ©ception de messages texte sur la progression des opÃ©rations en cours et des mÃ©thodes de travail avec les fichiers image. <br><br>  L'une des mÃ©thodes mainEntry exportÃ©es comme argument d'entrÃ©e <br>  accepte une chaÃ®ne ASCIIZ - la commande dÃ©crite dans le manuel Software Utilities for TrueFFS 7.1 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">(3)</a> . <br><br>  L'analyseur Ã  l'intÃ©rieur de "DOCSHELL.dll" traite la commande reÃ§ue et, selon la commande et ses arguments, appelle l'une ou l'autre mÃ©thode Ã  partir du logiciel de programmation principal Ã  l'aide du pointeur reÃ§u lors de l'initialisation initiale. <br><br>  Logiciel pour le programmeur, nous avons dÃ©cidÃ© d'Ã©crire le vÃ´tre.  Cette approche, d'une part, nous a Ã©vitÃ© de Â«creuserÂ» dans les fichiers d'origine pour respecter les accords sur l'Ã©change d'informations entre l'hÃ´te et le programmeur, et d'autre part, elle a grandement facilitÃ© le processus de dÃ©bogage, ce qui, si le module Ã©tait intÃ©grÃ© au logiciel d'origine, rendait impossible Ã  certains Ã©gards ou extrÃªmement difficile. <br><br>  L'interface utilisateur native du programmeur a Ã©tÃ© Ã©crite en C # dans Visual Studio 2017. Les sources <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">(6)</a> sont incluses. <br><br>  Bien sÃ»r, la fonctionnalitÃ© Ã©tait en premier lieu, il n'Ã©tait donc pas question de claquer l'apparence, ainsi que le texte du code source lui-mÃªme.  Par consÃ©quent, la Â«conceptionÂ» minimaliste du programme est la suivante. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oz/ki/8b/ozki8byinhgupo_k6hvfnzab-oc.jpeg"></div><br>  En haut de la fenÃªtre principale (et uniquement) se trouve un menu pour les boutons dont vous pouvez attribuer des fonctions arbitraires.  L'Ã©lÃ©ment de menu Â«XILINXÂ» sera dÃ©crit plus loin. <br><br>  Voici deux fenÃªtres.  La partie supÃ©rieure affiche les messages envoyÃ©s du programme au plugin "DOCSHELL.dll" et reÃ§us de celui-ci. <br><br>  Dans la fenÃªtre du bas, vous pouvez taper les commandes dont vous avez besoin et double-cliquer dessus dans la ligne correspondante. <br><br>  Au dÃ©marrage du programme, certaines commandes y seront affichÃ©es. <br><br>  <em>Si vous vous mettez soudainement au travail avec une vraie puce - faites attention, car</em>  <em>aucun avertissement que vous risquez de perdre toutes les donnÃ©es lors du formatage, etc.</em>  <em>Le programme n'est pas mis en Å“uvre.</em> <br><br>  Le fichier Â«DOCSHELL.dllÂ» se trouve dans le rÃ©pertoire avec le programme PG4UW <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">(4)</a> installÃ© depuis Â«DatamanÂ» (il est possible depuis Â«ElnecÂ»). <br><br>  Pour pouvoir utiliser une DLL tierce dans votre programme, vous avez besoin d'un fichier d'en-tÃªte avec une description des mÃ©thodes exportÃ©es et de leurs arguments.  En raison de son absence, j'ai dÃ» rÃ©cupÃ©rer moi-mÃªme ces informations.  Les mÃ©thodes pour une telle rÃ©cupÃ©ration sont au-delÃ  de la portÃ©e de cet article, donc les arguments des mÃ©thodes exportÃ©es peuvent Ãªtre trouvÃ©s dans les sources jointes. <br><br>  Avec l'interface utilisateur en termes d'interaction avec le plugin, la question est devenue plus claire.  Vous pouvez maintenant procÃ©der Ã  l'implÃ©mentation de la communication avec le microcircuit au niveau physique afin de pouvoir exÃ©cuter les commandes de lecture / Ã©criture de / vers mDOC reÃ§ues du plugin. <br><br>  Le module du programme pour le programmeur a Ã©tÃ© Ã©crit en langage C dans l'IDE "IAR Embedded Workbench for ARM".  Les sources <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">(7)</a> sont jointes. <br><br>  Son dÃ©bogage a Ã©tÃ© effectuÃ© Ã  l'aide du dÃ©bogueur JTAG J-Link, connectÃ© au programmateur via un connecteur JTAG montÃ© sur le cÃ´tÃ© du boÃ®tier et connectÃ© Ã  la carte mÃ¨re par un cÃ¢ble plat. <br><br>  <em>Le dÃ©bogueur JTAG J-Link v9 a Ã©tÃ© achetÃ© sur Aliexpress.</em>  <em>Les pilotes installÃ©s avec Â«IAR Embedded Workbench for ARMÂ» fonctionnent Ã  merveille avec lui, et mÃªme la mise Ã  jour du firmware natif de SEGGER a rÃ©ussi.</em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/md/5e/vq/md5evqm8gj7khtrvdsucwhd5yac.jpeg"></div><br>  Structurellement, le programmateur est constituÃ© de huit cartes situÃ©es l'une au-dessus de l'autre et reliÃ©es entre elles par des connecteurs. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3v/1n/b6/3v1nb6ntkgimwtwtir0lcekdgmm.jpeg"></div><br>  Les convertisseurs DC-DC rÃ©glables sont situÃ©s sur la carte la plus basse pour gÃ©nÃ©rer plusieurs tensions nÃ©cessaires pour travailler avec divers microcircuits de mÃ©moire. <br>  Au-dessus se trouve une carte mÃ¨re sur laquelle le microcontrÃ´leur ATMEL AT91SAM9G20 ARM, SDRAM, SPI FLASH avec firmware, puce ID AE801 avec modÃ¨le de programmateur et numÃ©ro de sÃ©rie, puce USB ISP1582, convertisseur numÃ©rique-analogique TLC7226 pour la gestion de la tension des convertisseurs DC-DC, un certain nombre d'autres puces et connecteurs externes pour connecter une alimentation et un cÃ¢ble USB pour se connecter Ã  l'hÃ´te. <br><br>  Sur la troisiÃ¨me carte infÃ©rieure se trouve la puce XILINX XC2S50E, qui contrÃ´le les jambes de la puce sur l'adaptateur connectÃ© au programmateur pendant les procÃ©dures de lecture / Ã©criture, etc. <br>  Sur les cinq autres cartes se trouvent des registres et des ensembles chargÃ©s sÃ©quentiellement avec des commutateurs Ã  transistors connectÃ©s Ã  leurs sorties, Ã  travers lesquels il est possible d'appliquer des microcircuits Ã  ces jambes de l'adaptateur formÃ© par des convertisseurs de tension DC-DC, <br>  y compris la "terre".  Ã‰tant donnÃ© que les registres contrÃ´lant les clÃ©s de transistor sont chargÃ©s sÃ©quentiellement et que le nombre de branches contrÃ´lÃ©es dans l'adaptateur peut atteindre 144, il faut beaucoup de temps pour charger tous les blocs de clÃ©s.  Par consÃ©quent, Ã  l'aide de commutateurs Ã  transistors, seuls les niveaux statiques sont transmis au microcircuit: masse, alimentation, etc.  Et avec XILINX - dynamique: adresses, donnÃ©es, CS, OE, RD, WR, etc. <br><br>  Pour aller plus loin, il fallait, au minimum, avoir un moyen de crÃ©er un firmware pour le microcircuit XILINX XC2S50E et un schÃ©ma de circuit, sinon de tout le programmeur, alors au moins une partie CPU - FPGA - adaptateur - socket. <br><br>  Quant Ã  l'IDE pour XILINX Spartan-IIE, j'ai dÃ» utiliser l'ancienne version d'ISE 10.1, car  tous les IDE suivants ne prennent pas en charge le modÃ¨le FPGA Spartan-II. <br><br>  La situation avec le schÃ©ma de circuit s'est avÃ©rÃ©e plus compliquÃ©e.  Pour identifier les composÃ©s qui nous intÃ©ressent, nous avons dÃ» Â«retirerÂ» les processeurs U4 et XILINX U12 des cartes pour accÃ©der aux pads sous leurs boÃ®tiers BGA, car  ils n'ont pas tous un interrupteur vers l'arriÃ¨re. <br><table><tbody><tr><td><div style="text-align:center;"><img src="https://habrastorage.org/webt/em/i6/xz/emi6xzfj5g9ks4imtdzvrc9mqa0.jpeg"></div></td><td><div style="text-align:center;"><img src="https://habrastorage.org/webt/fl/rg/st/flrgstgrxvaicirr108z0ahlphs.jpeg"></div></td></tr></tbody></table>  L'hÃ´te communique avec le programmateur via USB via plusieurs points d'extrÃ©mitÃ© (points d'extrÃ©mitÃ©).  L'hÃ´te agit toujours en tant qu'hÃ´te.  Par lâ€™un des points de terminaison, lâ€™hÃ´te envoie une commande au programmeur et, Ã  travers lui, reÃ§oit une confirmation, <br>  Ã  travers un autre, ils Ã©changent des donnÃ©es entre eux. <br><br>  L'analyse des commandes de l'hÃ´te dans le module de programme est effectuÃ©e dans la mÃ©thode USB_ReceiveBuf_EP1RX_Parse (). <br><br>  Le package de commandes est dÃ©crit par la structure CMD_PROG et se compose de plusieurs champs.  Si le champ Cmd contient 1, il s'agit d'une commande pour travailler avec le microcircuit et le champ ProgProcNum dans ce cas est l'index dans le tableau _progProcedures des structures PROG_PROC, dans l'un des champs, un pointeur vers la commande Ã  exÃ©cuter est stockÃ©. <br><br>  Dans le rÃ©pertoire avec le programme installÃ© "SUPERPRO 6100N", il y a un sous-rÃ©pertoire "\ lib".  Il avec l'extension "* .bin" stocke les fichiers du firmware XILINX pour tous les types de puces pris en charge par le programmeur.  Parmi eux, il existe deux micrologiciels universels pour vÃ©rifier le contact des jambes du microcircuit avec les contacts des prises de l'adaptateur. <br><br>  Il s'agit de Â«GENERAL ~ .BINÂ» avec une traction interne pour toutes les jambes de traction XILINX et Â«GENERAL_.BINÂ» avec une traction interne vers le bas. <br><br>  La vÃ©rification du contact des jambes de microcircuit est effectuÃ©e dans la mÃ©thode SOCKET_CkeckInsertIC () du module logiciel comme suit. <br><br>  Tout d'abord, le firmware Â«GENERAL_.BINÂ» est chargÃ© dans XILINX et avec son aide, toutes les branches FPGA connectÃ©es au socket sont configurÃ©es pour la sortie et le Â«1Â» logique leur est fourni.  Puis, Ã  son tour, chaque branche FPGA est reconfigurÃ©e en entrÃ©e, un niveau logique est lu Ã  partir de celle-ci, puis "1" est de nouveau Ã©mis vers cette branche. <br><br>  Si le pied de microcircuit a un contact Ã©lectrique avec le pied de prise correspondant, alors Â«1Â» doit Ãªtre lu Ã  partir de celui-ci (Ã  travers les diodes de protection internes du microcircuit de tous les autres pieds).  Et en l'absence de contact, du fait que toutes les broches FPGA sont tirÃ©es dans le sol, Â«0Â» sera lu sur cette entrÃ©e.  AprÃ¨s cela, un tableau de niveaux logiques lus de cette maniÃ¨re est envoyÃ© Ã  l'hÃ´te et y est traitÃ©.  Ensuite, l'exÃ©cution de l'opÃ©ration spÃ©cifiÃ©e se poursuit, ou un message s'affiche sur le non-contact des jambes correspondantes du microcircuit dans la prise. <br>  AprÃ¨s avoir rÃ©ussi ce test, l'hÃ´te envoie au programmeur le micrologiciel pour XILINX correspondant Ã  la puce installÃ©e dans l'adaptateur. <br><br>  La compilation d'un programme pour FPGA dans ISE 10.1 (exÃ©cution sÃ©quentielle de procÃ©dures de synthÃ¨se (Synthesize), implÃ©mentation d'une conception (Implement Design) et gÃ©nÃ©ration de fichiers de programmation (Generate Programming File)) crÃ©e un fichier de configuration binaire "xeltek.bin" de 78756 octets dans le rÃ©pertoire du projet.  <em>Pour cela, dans les propriÃ©tÃ©s du processus Â«GÃ©nÃ©rer un fichier de programmationÂ» dans la fenÃªtre Â«ProcessusÂ» de la catÃ©gorie Â«Options gÃ©nÃ©ralesÂ», deux options doivent Ãªtre dÃ©finies: Â«CrÃ©er un fichier bitÂ» et Â«CrÃ©er un fichier de configuration bibaryÂ».</em> <br><br>  On ne sait pas pour quelles raisons, mais les programmeurs XELTEK ont dÃ©cidÃ© de modifier les fichiers ainsi obtenus en mettant en miroir tous les bits de chaque octet. <br><br>  Si, pour quelque raison que ce soit, vous devez Â«mettre en miroirÂ» votre propre fichier de cette maniÃ¨re, ou Â«mettre en miroirÂ» le fichier du rÃ©pertoire Â«\ libÂ» vers la vue normale, dans le logiciel du menu Â«XILINXÂ», il y a Ã  cet effet l'Ã©lÃ©ment Â«Bitstream ConverterÂ» (Ã  la fin du nom le fichier rÃ©sultant est soulignÃ©). <br><br>  Pour travailler avec la puce SDED5 au niveau physique, les quatre mÃ©thodes suivantes sont implÃ©mentÃ©es dans le module logiciel: <br><br>  - PROGPROC_FLWRITE_IO_WORD () - enregistrer un mot (16 bits) Ã  l'adresse indiquÃ©e <br>  - PROGPROC_FLREAD_IO_WORD () - lire le mot (16 bits) Ã  l'adresse indiquÃ©e <br>  - PROGPROC_hal_blk_write_nor () - Ã©crire un ou plusieurs secteurs (512 octets chacun) Ã  l'adresse spÃ©cifiÃ©e <br>  - PROGPROC_hal_blk_read_nor () - lire un ou plusieurs secteurs (512 octets chacun) Ã  l'adresse spÃ©cifiÃ©e <br><br>  Pour interagir avec le FPGA XILINX dans notre micrologiciel, nous avons identifiÃ© quatre registres (ports d'E / S, dÃ©crits dans le fichier common.h pour les sources ARM). <br><br>  - _IC_ADDR (0x30000010) <br>  - _IC_DATA (0x30000012) <br>  - _IC_CTRL (0x30000014) // Sortie: 0 - WE, 1 - 0E, 2 - CE, 3 - RSTIN;  Dans: 0 - OCCUPÃ‰ <br>  - _IC_ENABLE (0x30000016) // In: 7 - Autorisation de travail (0 - actif, 1 - toutes les jambes sur le socket en Z) <br><br>  _IC_ADDR et _IC_DATA sont des registres d'adresse et de donnÃ©es 16 bits pour la puce programmable SDED5; <br>  _IC_CTRL - Registre de contrÃ´le Ã  8 bits Ã  travers lequel les signaux WE, OE, CE et RSTIN sont dÃ©finis et le signal BUSY est lu Ã  partir de SDED5. <br><br>  Les modules logiciels d'origine utilisent des adresses de 0x30000000 Ã  0x3000000E pour communiquer avec les FPGA.  CPLD avec l'inscription XELTEK est installÃ© comme dÃ©codeur d'adresse dans le programmeur, et comme nous ne connaissons pas son firmware, nous avons utilisÃ© des adresses de 0x30000010 juste au cas oÃ¹ pour rÃ©duire la probabilitÃ© de consÃ©quences inattendues de manifester la logique de comportement de quelqu'un d'autre lors de l'utilisation d'adresses "standard". <br><br>  AprÃ¨s avoir chargÃ© son micrologiciel dans le FPGA, toutes les sorties FPGA connectÃ©es aux jambes du microcircuit dans la prise sont Ã  l'Ã©tat Z et pour commencer Ã  travailler avec, vous devez activer la rÃ©solution en Ã©crivant de zÃ©ro au septiÃ¨me bit du registre _IC_ENABLE. <br><br>  L'algorithme de l'ensemble du systÃ¨me peut se prÃ©senter comme suit. <br><br><ol><li>  AprÃ¨s avoir dÃ©marrÃ© le logiciel sur l'hÃ´te, il vÃ©rifie s'il y a une connexion au programmateur via USB et affiche le message correspondant dans la barre d'Ã©tat en bas de la fenÃªtre principale <br>  (le programmateur peut Ãªtre connectÃ© aprÃ¨s le dÃ©marrage du programme). </li><li>  L'utilisateur sÃ©lectionne le type de puce avec lequel il a l'intention de travailler. </li><li>  Dans la base de donnÃ©es (dans le cas le plus simple, juste dans le fichier), le microcircuit sÃ©lectionnÃ© correspond au type d'adaptateur requis et une demande est envoyÃ©e au programmeur pour le type d'adaptateur installÃ© dans celui-ci. </li><li>  Le programmeur demande Ã  l'adaptateur son type et renvoie ces informations Ã  l'hÃ´te, oÃ¹ ces informations sont comparÃ©es Ã  celles trouvÃ©es dans la base de donnÃ©es, et si les types d'adaptateurs correspondent, le travail se poursuit. </li><li>  Pour chaque type de microcircuit sÃ©lectionnÃ© dans le logiciel, un menu correspondant doit Ãªtre affichÃ© avec les commandes disponibles pour ce microcircuit (lecture, Ã©criture, vÃ©rification de propretÃ©, comparaison, etc.). </li><li>  Lorsque vous sÃ©lectionnez un Ã©lÃ©ment de menu pour travailler avec le microcircuit, la commande correspondante est envoyÃ©e au programmateur, aprÃ¨s quoi le programmeur vÃ©rifie d'abord le contact Ã©lectrique des contacts de la prise avec les jambes du microcircuit, puis, en cas de succÃ¨s, exÃ©cute cette commande. </li></ol><br>  <em>Dans les codes sources joints Ã  l'article, pour simplifier la tÃ¢che, les points du deuxiÃ¨me au cinquiÃ¨me inclus ne sont pas implÃ©mentÃ©s.</em> <br><br><h4>  RÃ©sumÃ© </h4><br>  Nous n'avons pas Ã©tÃ© confrontÃ©s Ã  la tÃ¢che d'intÃ©grer le module logiciel dans le logiciel d'origine, <br>  par consÃ©quent, le matÃ©riau dÃ©crit dans cet article ne prÃ©tend pas Ãªtre une solution complÃ¨te. <br>  Nous espÃ©rons que les informations prÃ©sentÃ©es ici seront utiles Ã  une certaine catÃ©gorie de lecteurs, et au mieux de nos capacitÃ©s et de la disponibilitÃ© de temps libre, nous essaierons de rÃ©pondre Ã  vos questions. <br><br>  Merci de votre intÃ©rÃªt! <br><br><h4>  Les ressources </h4><br>  1. <a name="ref1"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PDF - Lecteur flash intÃ©grÃ© mDOC H3 (EFD) avec logiciel de gestion du flash TrueFFS intÃ©grÃ©</a> <br>  2. <a name="ref2"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PDF - Programmation des mÃ©moires flash mDOC H3 Ã  l'aide de programmeurs de pÃ©riphÃ©riques Dataman</a> <br>  3. <a name="ref3"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PDF - Software_Utilities_TrueFFS_7.1</a> <br>  4. <a name="PG4UW"></a>  <a href="">Logiciel de contrÃ´le de Dataman - PG4UW</a> <br>  5. <a name="linux"></a>  <a href="">ImplÃ©mentation du pilote mDOC H3 pour Linux (les performances n'ont pas Ã©tÃ© testÃ©es)</a> <br>  6. <a name="refSrcHost"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fichiers source du programmeur hÃ´te (Visual Studio 2017).</a> <br>  7. <a name="refSrcModule"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fichiers source du module logiciel (IAR Embedded Workbench for ARM v8.30.1).</a> <br>  8. <a name="refSrcFPGA"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fichiers source pour FPGA XILINX XC2S50E (XILINX ISE 10.1).</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430634/">https://habr.com/ru/post/fr430634/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430622/index.html">PensÃ©e fonctionnelle. Partie 5</a></li>
<li><a href="../fr430626/index.html">Annonce du Meetup Moscou GraphQL</a></li>
<li><a href="../fr430628/index.html">Algorithme de Fortune, dÃ©tails d'implÃ©mentation</a></li>
<li><a href="../fr430630/index.html">Comparaison des baskets Two Balls des annÃ©es 60 et 2016. De la semelle aux lacets</a></li>
<li><a href="../fr430632/index.html">Service en entreprise: comment les dÃ©taillants Ã©trangers ouvrent des magasins clÃ© en main en Russie</a></li>
<li><a href="../fr430636/index.html">Cervelet et noyaux basaux au lieu de la boule de cristal: comment le cerveau prÃ©dit l'avenir</a></li>
<li><a href="../fr430640/index.html">Mer Rouge: pourquoi les actions d'Apple et d'autres sociÃ©tÃ©s technologiques baissent</a></li>
<li><a href="../fr430642/index.html">Direction "Photonique" aux JO "Je suis un professionnel", ou comment s'inscrire dans une magistrature sans examens</a></li>
<li><a href="../fr430644/index.html">Une nouvelle vulnÃ©rabilitÃ© dans Facebook entraÃ®ne la fuite des donnÃ©es personnelles des utilisateurs</a></li>
<li><a href="../fr430646/index.html">SÃ©rialisation binaire .Net sans rÃ©fÃ©rence Ã  l'assembly avec le type source ou comment nÃ©gocier avec BinaryFormatter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>