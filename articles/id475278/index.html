<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏼 🧕🏿 🔪 Cara mengintip peretas sementara peretas mengintip Anda 🏂 👩‍🏭 🗣️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sebelum memilih topik diploma, saya perhatikan bahwa situasi meluas ketika, selama serangan komputer, seseorang dianggap hanya dari satu sisi - orang ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara mengintip peretas sementara peretas mengintip Anda</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/475278/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/m_/wr/qv/m_wrqv9vsfdi1u6jalzwcjxqs9k.png"></div><br>  Sebelum memilih topik diploma, saya perhatikan bahwa situasi meluas ketika, selama serangan komputer, seseorang dianggap hanya dari satu sisi - orang yang diserang sebagai kerentanan. <br><br>  Selama serangan, semua orang hanya tertarik pada alat dan tindakan para pelanggar, dan hanya setelah semuanya terjadi - siapa yang berada di belakang serangan dan tujuan apa yang ingin mereka capai. <br><br>  Tahun-tahun berlalu (sudah hampir enam tahun), tetapi topik ini masih tidak meninggalkan saya sendirian. <br><br>  Saat menulis ijazah, menjadi jelas bahwa saya sangat melebih-lebihkan kekuatan saya dan tidak dapat membuat proyek skala ini untuk satu orang dalam enam bulan.  Setidaknya saya tidak berhasil. <br><br>  Kurangnya pengalaman pada sistem nyata juga berdampak, dan beberapa keputusan desain dipikirkan kembali ketika menulis diploma, tetapi saya sampai pada beberapa poin hanya setelah bertahun-tahun. <br><br>  Artikel ini adalah tentang rancangan desain dan kekurangan serta pertanyaan yang muncul selama proses desain. <br><br>  Saya akan senang jika seseorang tertarik pada sisi serangan komputer ini dan dia bisa menggunakan pencapaian saya yang sederhana. <br><br>  Dan ya, "peretas" dalam judul artikel hanya digunakan dalam satu makna yang didefinisikan secara ketat - pelanggar keamanan informasi. <br><a name="habracut"></a><br>  Tema diploma: merancang sistem untuk secara dinamis menentukan target potensial pelanggar keamanan jaringan komputer. <br><br>  Ide umum: ketika kita entah bagaimana memperbaiki serangan (misalnya, menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SIEM</a> ), kemudian berdasarkan data ini kita mengasumsikan apa yang ingin dilakukan penyusup pada akhirnya. <br><br>  Ketika saya menulis diploma, menjadi jelas bahwa beberapa poin dalam diploma dapat dan harus ditingkatkan. <br><br>  Saya sudah berbicara tentang bagian dari diploma saya, atau lebih tepatnya tentang salah satu masalah yang saya temui dalam proses penulisan, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Artikel saya bukan yang terbaik, tetapi saya belajar sesuatu yang berguna untuk diri saya sendiri di komentar, terima kasih kepada semua komentator. <br><br><h2>  Tentang tata letak </h2><br>  Hal pertama yang ingin saya perhatikan, pertama-tama, lulusan adalah tata letak. <br>  Segalanya dan terus-menerus.  Ini akan menjadi jelas di mana dan apa yang salah.  Dan jika itu tidak jelas, maka tingkatkan keterampilan Anda.  Sayangnya, saya bukan seorang programmer atau pengembang, dan dengan administrasi saya tidak begitu.  Saya sangat suka menciptakan sesuatu yang baru atau mencari kemacetan dalam ide.  Oleh karena itu, membuat prototipe dan melakukan percobaan hampir seluruhnya jatuh pada supervisor lulusan saya, yang karenanya banyak terima kasih padanya. <br><br>  Saya tidak memiliki infrastruktur sendiri. <br><br>  Anda dapat bersatu dengan seseorang dan chip dalam besi.  Ambil, misalnya, beberapa laptop, router dan sistem ini dalam bentuk miniatur. <br><br>  Anda juga dapat membeli di situs-situs iklan baris gratis lama, tidak terlalu segar, tetapi langsung mengandung besi.  Kadang-kadang mereka menjual "1.000 rubel, tetapi pikap." <br><br><h2>  Langsung ke intinya </h2><br>  Di mana harus mulai memprediksi? <br><br>  Untuk memahami apa yang terjadi di masa sekarang. <br><br>  SIEM OSSIM bertanggung jawab untuk ini.  Pada saat yang sama, pengembang menyatakan bahwa ia dapat menentukan serangan dan membuat rantai serangan CVE.  Untuk ini saya ketagihan - Saya tidak perlu menentukan serangan sendiri dan saya bisa berkonsentrasi langsung pada menentukan target potensial.  Bagaimana SIEM OSSIM mendefinisikan serangan dan menugaskan CVE tidak terlalu menarik bagi saya, jujur ​​saja.  Belum lama ini, saya mencoba mencari tahu, tetapi tidak dapat menemukan spesifiknya. <br><br>  Selain itu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CAPEC</a> dapat digunakan untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">prediksi</a> .  Namun, saya jauh lebih tertarik menggunakan CVE / CVSS dan CAPEC saya tidak membayar jumlah perhatian yang layak. <br><br>  Tapi sebelum itu, kami akan mengurus semua yang kami sukai - klasifikasi pelanggar. <br><br><h2>  Klasifikasi pelanggar </h2><br>  Saya sudah mengangkat topik ini, tetapi mari kita lanjutkan lagi, hanya dengan cepat. <br><br>  SIEM mengumpulkan serangan dalam rantai CVE.  Dari CVE / CVSS kami mengambil vektor AccessComplexity.  Versi kedua CVSS digunakan, jadi ada tiga gradasi, dan bukan dua, seperti sekarang. <br><div class="scrollable-table"><table><tbody><tr><th>  Tingkat keterampilan pelaku kejahatan keamanan </th><th>  Kesulitan akses </th></tr><tr><td align="center">  Rendah </td><td align="center">  Rendah </td></tr><tr><td align="center">  Sedang </td><td align="center">  Sedang </td></tr><tr><td align="center">  Tinggi </td><td align="center">  Tinggi </td></tr></tbody></table></div><br>  Entah bagaimana tidak mengesankan, bukan?  Akan lebih menarik lebih lanjut.  Selain itu, ini tidak terjadi di artikel terakhir. <br><blockquote>  Keamanan informasi adalah proses memastikan ketersediaan, integritas, dan kerahasiaan informasi. </blockquote><br>  Ini adalah salah satu definisi yang diterima secara umum. <br><br>  Tetapi bagaimana jika kita mengklasifikasikan pelanggar dengan melanggar properti informasi ini? <br><br>  Jadi klasifikasi berikut telah berubah: <br><br><ul><li>  Scout </li><li>  Perusak </li><li>  Penyerang </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_p/0r/v6/_p0rv6z2p6hf4jtcv8olv6gumqs.png"></div><br><blockquote>  "Scout" - tujuan utamanya adalah untuk mengungkapkan informasi tentang sistem, atau untuk memperoleh informasi (data, file, dll.) Darinya. <br><br>  "Destroyer" (Destroyer) - tujuan utamanya adalah untuk mengganggu sistem atau komponennya, hingga kegagalan. <br><br>  "Invader" - tujuan utamanya adalah untuk mendapatkan kendali atas sistem atau komponennya. </blockquote><br><br>  Pembagian "peran" seperti itu bagi saya tampaknya lima tahun lalu sebagai ide yang bagus.  Namun, bagi saya itu ide yang bagus. <br><br>  Untuk mengklasifikasikan pelanggar berdasarkan kelas-kelas ini, kami mengambil dari CVE / CVSS ConfImpact ("Dampak pada Kerahasiaan"), IntegImpact ("Dampak pada Aksesibilitas"), AvailImpact ("Dampak pada Integritas"). <br><br>  Dalam vektor, pengaruh dapat mengambil nilai-nilai berikut: tidak ada pengaruh pada sumber daya ( <abbr title="Tidak ada">N</abbr> ), pengaruh parsial pada sumber daya ( <abbr title="Sebagian">P</abbr> ), kontrol penuh atas sumber daya ( <abbr title="Lengkap">C</abbr> ). <br><div class="scrollable-table"><table><tbody><tr><th>  Kelas </th><th>  Dampak Kerahasiaan </th><th>  Dampak Ketersediaan </th><th>  Dampaknya pada integritas </th></tr><tr><td align="center">  Scout </td><td align="center">  N </td><td align="center">  P / c </td><td align="center">  N </td></tr><tr><td align="center">  Perusak </td><td align="center">  P / c </td><td align="center">  Tidak ada </td><td align="center">  N </td></tr><tr><td align="center">  Penyerang </td><td align="center">  N / P / C </td><td align="center">  N / P / C </td><td align="center">  P / c </td></tr></tbody></table></div><br>  Sebagai kesimpulan, kami menunjukkan bahwa kelas memiliki efek yang berbeda pada sistem: yang paling penting, "Scout" dan yang paling utama "Invader". <br>  Dengan demikian, setelah mendapatkan rantai serangan dari SIEM, kita dapat mengklasifikasikan pengganggu.  Dan sudah tentang ini kita dapat menarik beberapa kesimpulan tentang tujuan pelanggar. <br>  Melewati serangkaian serangan, penyusup hanya bisa meningkatkan keterampilan dan kelasnya, tetapi tidak mengurangi mereka.  Rendah → Sedang → Tinggi dan Scout → Destroyer → Invader. <br><br>  Klasifikasi digunakan dalam memprediksi maksud penyusup secara tidak langsung. <br>  Tetapi mengklasifikasikan pelanggar seseorang dapat mengasumsikan apa yang mereka perjuangkan. <br>  Mungkin kita dapat mengatakan bahwa klasifikasi adalah tempat yang paling berfungsi dengan baik dalam diploma. <br>  Semua nuansa yang membingungkan saya pada umumnya dijelaskan dalam artikel sebelumnya. <br><br><h2>  Arsitektur </h2><br>  Pertama mari kita lihat arsitektur solusinya. <br><blockquote>  Komponen utama dari subsistem sistem untuk secara dinamis menentukan target potensial penyusup keamanan adalah tiga modul yang dinamai sesuai dengan tiga penyihir Skandinavia Skandinavia yang menentukan nasib seseorang - Urd, Verdandi dan Skuld. </blockquote><br>  Berbicara tentang "penyihir Skandinavia" dalam membela diploma, saya yakin bahwa ini adalah ide yang bagus dan entah bagaimana akan membantu "meredakan situasi."  Tidak.  Tampaknya efeknya sebaliknya.  Tapi aku merasakannya setelah semua bersuara.  Mungkin pendekatan ini cocok jika Anda seorang pembicara di suatu tempat pada hari-hari tertentu, tetapi tidak sebelum komisi negara. <br><br>  Namun demikian, untuk memberikan nama-nama seperti itu kepada subsistem membantu saya memahami bagaimana sistem seharusnya bekerja. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5y/ny/xq/5ynyxql9qq8pidf2ta5-oqulqwu.png"></div><br>  Sistem ini secara fungsional dibagi menjadi tiga subsistem utama: <br><br><ul><li>  Basis Pengetahuan (Urd - Past); </li><li>  Sistem Pengumpulan Informasi (Verdandi - Sekarang); </li><li>  Sistem peramalan target (Skuld - Future). </li></ul><br>  Tempat pusat diberikan kepada DBMS - database server yang termasuk dalam basis pengetahuan. <br>  Diasumsikan bahwa akan ada semacam basis data global di mana pengguna akan merekam dan menerima grafik serangan.  Mereka seharusnya terlihat seperti ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/u3/nn/xb/u3nnxbdzqpaksehrbddfrgh1mwk.png"></div><br>  Jadi bagaimana cara menyimpan grafik dalam database dan bekerja dengannya sebagai grafik?  Sederhana - ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">basis data grafik</a> . <br>  Tetapi pada saat itulah saya menyadari bahwa saya tidak dapat melakukannya sendiri dan diploma telah bergerak secara khusus ke arah konsep, daripada sistem yang benar-benar dikembangkan dan bekerja. <br><br>  Saya perlu menemukan di database SIEM di mana serangan disimpan, dan kemudian menulis parser yang akan mentransfer informasi ini ke basis data grafik. <br><br>  Bagaimana basis diisi: SIEM mendeteksi serangan, memberi saya CVE, saya menambahkan simpul baru ke basis atau, jika sudah ada simpul semacam itu, saya meningkatkan jumlah transisi antara simpul dengan satu unit.  Jika serangan berlanjut, saya menambahkan simpul / transisi. <br><br><blockquote>  Pendekatan ini memiliki kelebihan, seperti: <br><br><ul><li>  mengisi sendiri, mis.  tidak diperlukan langkah-langkah tambahan untuk membuat grafik serangan baru, karena penyerang sendiri yang melakukannya; </li><li>  redundansi rendah, mis.  hanya grafik serangan yang benar-benar digunakan penyerang yang ada dalam grafik. </li></ul><br>  Kelemahan utama dari pendekatan ini adalah bahwa jika seorang penyerang menggunakan serangan yang sebelumnya tidak digunakan, maka tidak mungkin untuk memprediksi tindakannya. <br><br>  Metode ini dapat ditingkatkan dengan menambahkan grafik serangan yang dimodelkan dengan cara lain ke database, mengatur transisi ke "0". <br></blockquote><br>  Juga, metode ini menggunakan basis data grafik memiliki dua kesulitan murni praktis: <br><br><ol><li>  Menulis ke basis data. </li><li>  Baca dari database. </li></ol><br>  Masalah dengan rekaman adalah deteksi serangan.  Pada titik apa Anda perlu menulis serangan ke markas? <br><br>  Kapan serangan selesai?  Serangannya bisa panjang.  Pada titik apa Anda menyadari bahwa itu lengkap?  Tiba-tiba, si penyusup tidak memiliki keterampilan yang diperlukan dan berhenti mengembangkan serangan?  Dan jika serangan selesai, maka infrastruktur untuk mengirim data tentang serangan itu mungkin tidak lagi. <br><br>  Dalam proses?  Tulis setiap transisi di CVE?  Yah, bukan pilihan yang buruk, tetapi bagi saya sepertinya akan ada jebakan di sini juga. <br><br>  Masalah dengan membaca adalah volume pohon yang diperkirakan perlu diambil dari server.  Dalam hal sumber daya dan lead time, operasi ini tampaknya menjadi bencana. <br><br>  Anda dapat mencoba untuk tidak membuat pilihan untuk setiap deteksi transisi oleh grafik serangan (lebih lanjut tentang itu nanti), tetapi untuk menyinkronkan seluruh database.  Tapi saya bahkan tidak bisa membayangkan berapa banyak basis akan menempati pada saat itu ketika mulai diketik dengan data nyata. <br><br>  Selain database server, saya menggunakan yang lokal, yang akan mengumpulkan statistik serangan pada sistem tertentu. <br><br>  Anda juga dapat mengatakan bahwa serangan offline tidak dapat ditambahkan ke database.  Phishing, dan memang semua rekayasa sosial, akan melewati kita.  Kita hanya akan dapat menentukan seberapa jauh si pembunuh telah bergerak di sepanjang rantai pembunuhan ketika dia sudah mencoba membunuh kita. <br><br><h2>  Ajaib </h2><br>  Sekarang tinggal beralih ke yang paling penting dan menarik.  Untuk peramalan. <br><br><h3>  Algoritma Peramalan Historis </h3><br>  Sekarang bagi saya sepertinya "algoritma statistik" akan menjadi nama yang lebih memadai.  Tetapi kemudian saya menganggap bahwa lebih baik tidak menggunakan kata "statistik" dalam ijazah. <br><br>  Algoritma yang ditemukan mungkin adalah yang paling berharga dalam diploma saya (sekali lagi, terima kasih telah menulis kode pseudo, terima kasih kepada supervisor diploma saya). <br><br><blockquote>  1. Dapatkan CVE_ID, HOST_ID dari acara keamanan <br>  2. Dgraph = DirectedGraph (CVE_ID) <br>  jika DirectedGraph == 0 kembali <br>  3. Set_Edges: = DirectedGraph.getOutEdges (CVE_ID, HOST_ID, DirectedGraph.getRoot ()) <br>  4. Set_Edges: = MAX_EXPLOIT_FREQUENCY (SET_EDGES) <br>  If (SET_EDGES) == null kembali <br>  if (SET_EDGES.SIZE ()&gt; 1) <br>  SET_EDGES: = MIN_ACCESS.COMPLEXITY (SET_EDGES) <br>  if (SET_EDGES.SIZE ()&gt; 1) <br>  SET_EDGES: = MIN_IMPACT_GOAL (SET_EDGES) <br>  untuk setiap EDGES ∈ SET_EDGES <br>  edge.Exploit_Probability == ((edge.AttackFrequency) / (1 + ¬edge.AttackFrequency)) <br>  5. Lanjutkan ke langkah 3. </blockquote><br>  Selama bertahun-tahun, tidak mudah bagi saya untuk membaca sendiri algoritma ini, jadi mari kita sedikit lebih sederhana. <br><br>  Kami mendapatkan nama host, CVE-id dari acara keamanan yang SIEM berikan kepada kami, dan dari database kami memilih subtree yang dimulai dengan kerentanan yang CVE-id kami terima. <br>  Di antara kerentanan terdekat, kami memilih satu dengan frekuensi penggunaan tertinggi. <br><br>  Jika ada beberapa kerentanan dengan frekuensi yang sama, maka kami mengambil satu yang memiliki kompleksitas akses lebih sedikit. <br><br>  Jika ada beberapa kerentanan dengan kompleksitas akses yang sama, maka kerentanan diambil dengan dampak yang lebih kecil ImpactGoal (dari klasifikasi). <br><br>  Jika dalam hal ini ada beberapa kerentanan, maka kerentanan ini dianggap sama kemungkinannya dan beberapa cara digunakan dalam menentukan target potensial. <br>  Untuk setiap kerentanan, probabilitas mengeksploitasi kerentanan dihitung: frekuensi menggunakan jalur ke kerentanan yang kami anggap kemungkinan dibagi dengan jumlah frekuensi menggunakan semua wajah keluar dari node ini. <br><br>  Setelah menyelesaikan langkah-langkah ini, kami kembali melihat kerentanan di sekitar kami, yaitu  kita berkeliling pohon sampai akhir. <br><br><h4>  Visualisasi algoritma peramalan historis </h4><br>  Kami memiliki basis serangan tertentu yang sudah terbentuk. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6_/xb/-g/6_xb-g2jtyqa5kaoasqwvewpa4c.png"></div><br>  Kami mendapatkan serangan dan CVE pertama dari SIEM. <br><br>  Merah menunjukkan kerentanan yang diperoleh dari SIEM.  Kerentanan abu - abu dibuang selama algoritme, karena tidak ada lagi jalan bagi mereka.  Hitam - kerentanan dan frekuensi penggunaan jalur, yang masih dianggap sebagai jalur yang mungkin dalam pohon serangan.  Oranye - kerentanan dan frekuensi penggunaan jalur, diidentifikasi oleh algoritma sebagai yang paling memungkinkan. <br>  Dalam hal ini, kami mendapatkan CVE potensial berikut dengan jumlah transisi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ac/h1/tv/ach1tvsa-2rkrntqnazxufopvfo.png"></div><br>  Dapatkan CVE berikutnya dari SIEM. <br><br>  Jangan menebak.  Ya, dan pada tahap berikutnya hanya ada dua jalur dan mereka memiliki jumlah transisi yang sama.  Kami melihat kompleksitas operasi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4n/mu/nj/4nmunj-w9ntyrpkkqjwli1wwmic.png"></div><br>  Sekali lagi tidak menebak.  Transisinya sama lagi.  Ya, dan kompleksitas operasi bertepatan.  Kami melihat vektor pengaruh. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tp/fz/dg/tpfzdgtfjgjilffnf3bt3ze9sf4.png"></div><br><h4>  Masalah algoritma peramalan historis </h4><br>  Ini adalah pendekatan dahi.  Tidak terlalu elegan.  Tetapi tanpa pengalaman nyata menyelidiki serangan komputer, ini adalah maksimum yang bisa saya peras. <br><br>  Juga harus disebutkan bahwa dalam kenyataannya, hanya kondisi pada jumlah transisi yang paling mungkin akan digunakan, karena probabilitas bahwa jumlah transisi akan bertepatan kemungkinan besar sangat kecil. <br><br>  Dan juga kesulitan dimulai dengan fakta bahwa, misalnya, ada serangan Destroyer dan serangan Invader.  Mereka berpotongan dalam satu CVE.  Jika lebih sering mereka mengikuti jalur Destroyer, maka serangan Invader setelah beralih ke CVE ini tidak akan diprediksi dengan benar. <br><br>  Ada satu lagi nuansa yang dalam uraian algoritma dikatakan bahwa probabilitas untuk tujuan akhir dihitung.  Tetapi formula yang saya usulkan sangat buruk di persimpangan seperti itu.  Perhitungan probabilitas tetap, tetapi telah menjadi lebih mudah, tetapi tidak mungkin berfungsi dengan benar. <br><br>  Dan yang paling penting, itu ... Saya, tentu saja, bukan spesialis dalam penyelidikan serangan komputer (seperti yang telah saya katakan lebih dari sekali), tetapi sesuatu memberitahu saya bahwa dalam kenyataannya database saya akan terlihat seperti ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6h/ht/4v/6hht4vvzlyaxwutssy3ncwogwik.png"></div><br>  Yaitu  sedikit kekacauan.  Dan ini adalah pilihan yang lebih atau kurang baik, seperti yang menurut saya. <br><br>  Database seperti itu akan lebih atau kurang berfungsi dengan baik di dalam host yang sama (dan bahkan CVE dalam perangkat lunak aplikasi mungkin tidak dihitung dengan benar).  Tapi bagaimana cara memprediksi pergerakan penyusup di antara stasiun?  Kita perlu memfilter CVE dari basis data berdasarkan audit keamanan. <br><br><h3>  Algoritma analitik </h3><br>  Intinya adalah untuk membangun basis data serangan CVE menggunakan CAPEC / CWE.  Hanya pada transisi tidak akan ada informasi. <br><br>  Kami mendapatkan CVE dari SIEM, menggunakannya untuk mengklasifikasikan pengganggu, dan kemudian memilih dalam basis data CVE yang paling sesuai dengan kelas dan keterampilan pengganggu. <br><br>  Sayangnya, ini adalah salah satu bagian yang paling tidak berkembang dalam diploma saya. <br><br><h2>  Desain Abstrak </h2><br>  Sulit menilai sumber daya apa yang dibutuhkan untuk memelihara database.  Setidaknya itu sulit bagiku. <br><br>  Ada kesulitan tertentu baik dengan menulis data baru ke database, dan dengan mengunduh data dari itu. <br><br>  Sistem tidak diterapkan dengan cara apa pun, kecuali di atas kertas, tetapi percobaan harus dilakukan "dengan tangan".  Saya bahkan tidak bisa membayangkan berapa lama waktu yang saya butuhkan untuk mengimplementasikan semacam demo.  Mungkin, jika saya memulai implementasi saat menulis ijazah, maka saya akan menyelesaikannya. <br><br>  Klasifikasi pelanggar berfungsi sebagai alat tambahan dalam menentukan tujuan. <br><br>  Sistem itu sendiri dapat bertindak sebagai sumber data untuk beberapa <abbr title="sistem pendukung keputusan">DSS</abbr> .  Misalnya, jika ada upaya untuk menyerang dari Invader, dan kemudian tiba-tiba berhenti, maka DSS dapat merekomendasikan audit karena Invader dapat mencapai tujuannya. <br><br>  Juga, jika Anda belajar menentukan siapa yang melakukan serangan, Anda dapat mencoba menentukan tujuan dari pelaku tertentu.  Anda juga dapat mencoba melakukan yang sebaliknya - katakan siapa yang melakukan serangan terhadap serangan itu. <br><br>  Sistem perlu diintegrasikan tidak hanya dengan SIEM, tetapi juga dengan sistem analisis keamanan. <br><br>  "Algoritma historis" adalah alat yang dapat digunakan untuk menentukan tujuan, tetapi ada banyak peringatan.  Ini bukan solusi yang paling elegan, tetapi sejauh ini.  Kita harus terus berpikir, memperbaiki.  Atau menolak dan mengambil algoritma yang sama sekali berbeda. <br><br>  Menggunakan CAPEC memiliki kelebihan dan kekurangan, tetapi membutuhkan kerja tambahan. <br><br>  Mungkin yang paling ofensif untuk sistem ini dari sudut pandang konseptual bisa jika pengganggu ... tidak memiliki tujuan.  Dia mendapatkan akses ke sistem karena dia bisa melakukannya.  Mungkin dia tidak merencanakan peretasan ini.  Dan kemudian dia tidak tahu apa yang harus dilakukan selanjutnya.  Atau mulai berperilaku seperti rubah di kandang ayam. <br><br>  Sistem ini sangat terkait dengan kemampuan SIEM untuk mendeteksi serangan, serta menentukan serangan CVE mana yang sedang digunakan.  Menghadapi sistem 0 hari memudar dalam ketiga metode perkiraan.  Dan Anda harus hidup dengannya, tetapi jangan pernah lupa. <br><br><blockquote>  Sistem ini memungkinkan Anda untuk menerima informasi tambahan tentang penyusup, karena sebagian besar sistem hanya memberikan informasi teknis tentang serangan itu, sementara informasi tentang motivator, tujuan, dan tingkat keterampilan penyusup juga penting dan sistem mereka yang saya coba dapatkan. <br><br>  Terima kasih atas perhatian anda </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id475278/">https://habr.com/ru/post/id475278/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id475264/index.html">Sniffer yang bisa: bagaimana keluarga FakeSecurity menginfeksi toko online</a></li>
<li><a href="../id475268/index.html">Parameterisasi tidak pasti sebagai metode universal untuk membangun arsitektur aplikasi di C ++ dan Java untuk minimum. harga</a></li>
<li><a href="../id475270/index.html">SwiftUI: Membuat Bagian yang Dapat Diperluas / Dilipat dalam Tampilan Daftar</a></li>
<li><a href="../id475272/index.html">Bermigrasi ke infrastruktur menunggu async di Rust</a></li>
<li><a href="../id475276/index.html">Cara menulis menegaskan dengan benar</a></li>
<li><a href="../id475280/index.html">Kata sandi Cisco, migrasi zona DNS, nol permintaan LDAP, kami kumpulkan paket Ethernet. Memecahkan masalah pada jaringan dengan r0ot-mi. Bagian 2</a></li>
<li><a href="../id475284/index.html">Manajer dan monyet satu menit, ringkasan</a></li>
<li><a href="../id475286/index.html">Trigenerasi: alternatif untuk pasokan energi terpusat</a></li>
<li><a href="../id475294/index.html">DevOops 2019 melalui mata pengembang</a></li>
<li><a href="../id475296/index.html">Kami mengundang Anda ke DINS Java EVENING pada 21 November: kami melihat AWS Lambda beraksi dan berkenalan dengan kerangka kerja Akka</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>