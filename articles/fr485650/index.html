<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö™ üë©üèæ‚Äçüé§ üßõüèΩ Docker Image Reduction Techniques üö£üèø üôçüèΩ ‚úùÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vous √™tes-vous d√©j√† demand√© pourquoi la taille d'un conteneur Docker contenant une seule application peut √™tre d'environ 400 Mo? Ou peut-√™tre √©tiez-vo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Docker Image Reduction Techniques</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/485650/">  Vous √™tes-vous d√©j√† demand√© pourquoi la taille d'un conteneur Docker contenant une seule application peut √™tre d'environ 400 Mo?  Ou peut-√™tre √©tiez-vous pr√©occup√© par la taille assez grande de l'image Docker contenant un seul binaire de plusieurs dizaines de Mo? <br><br> <a href="https://habr.com/ru/company/ruvds/blog/485650/"><img src="https://habrastorage.org/webt/ny/az/k8/nyazk8uqdkaog5lwtukn8qz1zpu.jpeg"></a> <br><br>  L'auteur de l'article, dont nous publions aujourd'hui la traduction, souhaite analyser les principaux facteurs affectant la taille des conteneurs Docker.  Il va, en outre, partager des recommandations sur la r√©duction de la taille des conteneurs. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Couches d'images Docker</font> </h2><br>  Une image d'un conteneur Docker est essentiellement une collection de fichiers empil√©s les uns sur les autres en plusieurs couches.  Un conteneur de travail est assembl√© √† partir de ces fichiers.  Docker utilise le syst√®me de fichiers <a href="https://en.wikipedia.org/wiki/UnionFS">UnionFS</a> , dans lequel les fichiers sont regroup√©s en couches.  Un calque peut contenir un ou plusieurs fichiers, les calques se chevauchent.  Lors de l'ex√©cution du conteneur, le contenu des couches est combin√©, de sorte que l'utilisateur final du conteneur per√ßoit les mat√©riaux ¬´dispos√©s¬ª dans les couches comme un syst√®me de fichiers unique. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a2/3ba/eea/0a23baeea85753e1a66d8399ff188b4c.png"></div><br>  <i><font color="#999999">Vue UnionFS simplifi√©e</font></i> <br><br>  Le syst√®me de fichiers r√©sultant est pr√©sent√© √† l'utilisateur final √† l'aide d'une impl√©mentation UnionFS (Docker <a href="https://docs.docker.com/storage/storagedriver/select-storage-driver/">prend en charge de</a> nombreuses impl√©mentations similaires via des pilotes de stockage de plug-in).  La taille totale des fichiers re√ßus par l'utilisateur final est √©gale √† la somme des tailles des fichiers dans les couches.  Lorsque Docker cr√©e un conteneur bas√© sur l'image, il utilise toutes les couches en lecture seule de l'image, en ajoutant une couche mince au-dessus de ces couches qui prend en charge la lecture et l'√©criture.  C'est cette couche qui vous permet de modifier des fichiers dans un conteneur en cours d'ex√©cution. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aaf/895/c00/aaf895c00a3353efa96934aeabd85f6f.png"></div><br>  <i><font color="#999999">Le conteneur en cours d'ex√©cution contient une couche en lecture-√©criture situ√©e au-dessus des couches en lecture seule</font></i> <br><br>  Que se passe-t-il si un fichier est supprim√© dans la <code>Layer 4</code> conteneur sch√©matis√© ci-dessus?  Bien que ce fichier ne soit pas disponible dans le syst√®me de fichiers que l'utilisateur voit, en fait, la taille de ce fichier sera toujours l'un des composants de la taille du conteneur, car ce fichier restera dans l'une des couches en lecture seule. <br><br>  Il est assez simple de commencer √† cr√©er l'image avec un petit fichier ex√©cutable d'application et d'acc√©der √† la tr√®s grande image.  Ci-dessous, nous examinerons diff√©rentes m√©thodes pour rendre les conteneurs aussi petits que possible. <br><br><h2>  <font color="#3AC1EF">Faites attention au chemin d'acc√®s au dossier, en fonction des mat√©riaux dont les images sont collect√©es</font> </h2><br>  Quelle est la m√©thode la plus courante pour assembler des images Docker?  Apparemment - comme √ßa: <br><br><pre> <code class="plaintext hljs">docker build .</code> </pre> <br>  Le point de cette commande indique √† Docker que nous consid√©rons que le r√©pertoire de travail actuel est la racine du syst√®me de fichiers utilis√© dans le processus d'assemblage d'image. <br><br>  Afin de mieux comprendre ce qui se passe apr√®s l'ex√©cution de la commande ci-dessus, il convient de se rappeler que la construction d'une image Docker est un processus client-serveur.  L'interface de ligne de commande Docker (client), √† laquelle nous donnons la <code>docker build</code> , utilise le moteur Docker (serveur) pour cr√©er l'image du conteneur.  Pour limiter l'acc√®s au syst√®me de fichiers de base du client, le syst√®me d'assemblage d'images doit savoir o√π se trouve la racine du syst√®me de fichiers virtuel.  C'est l√† que les instructions du fichier <code>Dockerfile</code> recherchent les ressources de fichiers qui peuvent √©ventuellement se retrouver dans l'image en cours d'assemblage. <br><br>  Imaginez un endroit o√π un <code>Dockerfile</code> g√©n√©ralement plac√©.  C'est probablement le r√©pertoire racine du projet?  S'il y a un <code>Dockerfile</code> √† la racine du projet, qui est utilis√© par la <code>docker build</code> pour construire l'image, il s'av√®re que tous les fichiers du projet peuvent entrer dans l'image.  Cela peut conduire au fait que des milliers de fichiers ind√©sirables de plusieurs m√©gaoctets peuvent entrer dans le contexte de l'assemblage d'image.  Si vous utilisez l√©g√®rement les commandes <code>ADD</code> et <code>COPY</code> dans le <code>Dockerfile</code> , tous les fichiers de projet peuvent bien faire partie de l'image finale.  Le plus souvent, ceux qui collectent des images n'en ont pas besoin, car l'image finale ne doit g√©n√©ralement inclure que certains fichiers s√©lectionn√©s. <br><br>  Assurez-vous toujours que la commande <code>docker build</code> chemin d'acc√®s correct et qu'il n'y a aucune commande dans le <code>Dockerfile</code> qui ajoute des fichiers inutiles √† l'image.  Si, pour une raison ou une autre, vous devez faire du root du projet le contexte de g√©n√©ration, vous pouvez y inclure des fichiers de mani√®re s√©lective et les en exclure √† l'aide de <code>.dockerignore</code> . <br><br><h2>  <font color="#3AC1EF">Optimiser les calques d'image</font> </h2><br>  Le nombre maximal de couches qu'une image peut avoir est de 127 (compte tenu de la prise en charge d'un tel nombre de couches utilis√©es par le pilote d'entrep√¥t de donn√©es).  Cette limitation, si elle est absolument n√©cessaire, peut √™tre assouplie, mais avec cette approche, la gamme de syst√®mes sur lesquels ces images peuvent √™tre collect√©es est r√©duite.  Le fait est que le moteur Docker doit fonctionner sur un syst√®me dont le noyau est modifi√© en cons√©quence. <br><br>  Comme mentionn√© dans la section pr√©c√©dente, en raison du fait que UnionFS est utilis√© lors de l'assemblage d'images, les fichiers qui tombent dans une certaine couche y restent m√™me s'ils ont √©t√© supprim√©s des couches sus-jacentes.  Voyons cela en utilisant le Dockerfile exp√©rimental: <br><br><pre> <code class="plaintext hljs">FROM alpine RUN wget http://xcal1.vodafone.co.uk/10MB.zip -P /tmp RUN rm /tmp/10MB.zip</code> </pre> <br>  Assemblons l'image: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44b/d7c/e6d/44bd7ce6d60c71fd0856e96bd48ec5b7.png"></div><br>  <i><font color="#999999">Assemblage d'une image exp√©rimentale dans laquelle il y a un espace irrationnellement utilis√©</font></i> <br><br>  Explorez l'image √† l'aide de la <a href="https://github.com/wagoodman/dive">plong√©e</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2da/e7f/1a5/2dae7f1a5875ece43a52042632a21401.png"></div><br>  <i><font color="#999999">L'indicateur de performance d'image est de 34%</font></i> <br><br>  L'indicateur d'efficacit√© d'image de 34% indique qu'une quantit√© consid√©rable d'espace d'image est utilis√©e de mani√®re irrationnelle.  Cela conduit √† une augmentation du temps de d√©marrage de l'image, √† un gaspillage inutile des ressources r√©seau, √† un temps de d√©marrage plus lent du conteneur. <br><br>  Comment se d√©barrasser de ce probl√®me?  Examinons plusieurs options. <br><br><h3>  <font color="#3AC1EF">‚ñç Fusion des r√©sultats du travail d'√©quipe</font> </h3><br>  Avez-vous d√©j√† vu des <code>Dockerfile</code> contenant de tr√®s longues directives <code>RUN</code> dans lesquelles de nombreuses commandes shell sont combin√©es √† l'aide de <code>&amp;&amp;</code> ?  Il s'agit de la fusion des r√©sultats des √©quipes. <br><br>  En utilisant cette m√©thode, nous cr√©ons, sur la base des r√©sultats d'une seule longue √©quipe, une seule couche.  Puisqu'il n'y aura aucun calque dans l'image contenant des fichiers supprim√©s dans les calques suivants, l'image finale n'inclura pas de tels ¬´fichiers fant√¥mes¬ª.  Consid√©rez ceci comme un exemple, en amenant le <code>Dockerfile</code> ci-dessus √† cet √©tat: <br><br><pre> <code class="plaintext hljs">FROM alpine RUN wget http://xcal1.vodafone.co.uk/10MB.zip -P /tmp &amp;&amp; rm /tmp/10MB.zip</code> </pre> <br>  Apr√®s cela, nous analysons l'image: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbe/87f/a16/fbe87fa1633aec55d8fdcbe4d8d1014e.png"></div><br>  <i><font color="#999999">La fusion des √©quipes vous a permis de cr√©er une image 100% optimis√©e</font></i> <br><br>  L'application de cette technique pour optimiser la taille des images dans la pratique est qu'apr√®s avoir fini de travailler sur le fichier <code>Dockerfile</code> , vous devez l'analyser et savoir si vous pouvez utiliser la fusion de commandes pour r√©duire la quantit√© d'espace gaspill√©. <br><br><h3>  <font color="#3AC1EF">‚ñçApplication de l'option --squash</font> </h3><br>  Dans les cas o√π vous utilisez les <code>Dockerfile</code> autres personnes que vous ne souhaitez pas ou ne pouvez pas modifier, une alternative √† la fusion des commandes peut √™tre l'assemblage d'une image √† l'aide de l'option <code>--squash</code> . <br><br>  Les versions modernes de Docker (√† partir de la version 1.13) vous permettent de regrouper toutes les couches en une seule, √©liminant ainsi les "ressources fant√¥mes".  Dans ce cas, vous pouvez utiliser le <code>Dockerfile</code> origine non <code>Dockerfile</code> , contenant de nombreuses commandes distinctes.  Mais vous devez cr√©er l'image en utilisant l'option <code>--squash</code> : <br><br><pre> <code class="plaintext hljs">docker build --squash .</code> </pre> <br>  L'image r√©sultante s'av√®re √©galement 100% optimis√©e: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/923/10f/5fc/92310f5fc60ee677d39db75f3d0bac93.png"></div><br>  <i><font color="#999999">L'utilisation de l'option --squash lors de l'assemblage a permis de cr√©er une image 100% optimis√©e</font></i> <br><br>  Ici, vous pouvez pr√™ter attention √† un d√©tail int√©ressant.  √Ä savoir, dans <code>Dockerfile</code> une couche a √©t√© cr√©√©e pour ajouter un fichier et une autre couche pour supprimer ce fichier.  L'option <code>--squash</code> est suffisamment intelligente pour comprendre que dans ce sc√©nario, vous n'avez pas du tout besoin de cr√©er de couches suppl√©mentaires (dans l'image finale, il n'y a que la couche <code>9ccd9‚Ä¶</code> partir de l'image de base que nous utilisons).  En g√©n√©ral, pour cela, nous pouvons mettre <code>--squash</code> un plus suppl√©mentaire.  Certes, en utilisant <code>--squash</code> , vous devez consid√©rer que cela peut interf√©rer avec l'utilisation des couches mises en cache. <br><br>  Par cons√©quent, il est recommand√© de prendre en compte le fait que lorsque vous travaillez avec le <code>Dockerfile</code> quelqu'un d'autre que vous ne souhaitez pas modifier, vous pouvez r√©duire la quantit√© d'espace d'image utilis√© de mani√®re irrationnelle en collectant des images √† l'aide de l'option <code>--squash</code> .  Pour analyser l'image finie, vous pouvez utiliser l'outil de <a href="https://github.com/wagoodman/dive">plong√©e</a> . <br><br><h2>  <font color="#3AC1EF">Supprimer les caches et les fichiers temporaires</font> </h2><br>  Lors de la conteneurisation d'applications, une situation se produit souvent lorsque vous devez placer des outils, des biblioth√®ques et des utilitaires suppl√©mentaires dans l'image avec eux.  Cela se fait en utilisant des gestionnaires de paquets comme <code>apk</code> , <code>yum</code> , <code>apt</code> . <br><br>  Les gestionnaires de packages s'efforcent de gagner du temps pour l'utilisateur et de ne pas charger √† nouveau sa connexion r√©seau lors de l'installation des packages.  Par cons√©quent, ils mettent en cache les donn√©es t√©l√©charg√©es.  Pour que la taille de l'image Docker finale soit aussi petite que possible, nous n'avons pas besoin de stocker les caches du gestionnaire de packages dans cette image.  Apr√®s tout, si nous avons besoin d'une autre image, nous pouvons toujours la reconstruire en utilisant le <code>Dockerfile</code> mis √† jour. <br><br>  Afin de supprimer les caches cr√©√©s par les trois gestionnaires de packages populaires susmentionn√©s, √† la fin d'une commande agr√©g√©e (c'est-√†-dire celle qui s'ex√©cute pour cr√©er une couche), vous pouvez ajouter ce qui suit: <br><br><pre> <code class="plaintext hljs">APK: ... &amp;&amp; rm -rf /etc/apk/cache YUM: ... &amp;&amp; rm -rf /var/cache/yum APT: ... &amp;&amp; rm -rf /var/cache/apt</code> </pre> <br>  Par cons√©quent, il est recommand√© qu'avant de terminer le travail sur le <code>Dockerfile</code> ajouter des <code>Dockerfile</code> qui suppriment les caches des gestionnaires de packages utilis√©s pour cr√©er l'image.  La m√™me chose s'applique √† tous les fichiers temporaires qui n'affectent pas le bon fonctionnement du conteneur. <br><br><h2>  <font color="#3AC1EF">Choisissez soigneusement votre image de base</font> </h2><br>  Chaque <code>Dockerfile</code> commence par une directive <code>FROM</code> .  C'est l√† que nous d√©finissons l'image de base sur la base de laquelle notre image sera cr√©√©e. <br><br>  Voici ce que la <a href="https://docs.docker.com/engine/reference/builder/">documentation</a> Docker en dit: ¬´L'instruction <code>FROM</code> initialise une nouvelle phase de construction et configure l'image de base pour les instructions qui suivent.  Par cons√©quent, un <code>Dockerfile</code> correctement compos√© doit commencer par une instruction <code>FROM</code> .  Une image peut √™tre n'importe quelle image r√©alisable.  Il est plus facile de commencer √† assembler votre propre image, en prenant comme base une image d'un r√©f√©rentiel public. " <br><br>  De toute √©vidence, il existe de nombreuses images de base, chacune ayant ses propres caract√©ristiques et capacit√©s.  La s√©lection correcte d'une image de base qui contient exactement ce dont l'application a besoin, ni plus ni moins, a un impact √©norme sur la taille de l'image finale. <br><br>  Comme vous pouvez vous y attendre, les tailles des images de base populaires varient √©norm√©ment: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/847/e59/97c/847e5997cf00104e3b212874ee830243.png"></div><br>  <i><font color="#999999">Tailles d'images de docker de base populaires</font></i> <br><br>  Ainsi, la conteneurisation de l'application en utilisant l'image de base d' <a href="https://hub.docker.com/layers/ubuntu/library/ubuntu/19.10/images/sha256-bceb2fb47400491f75a9056a3d4e219cbe5f9512d4220ca43f3f5cb3d08e9d04">Ubuntu 19.10</a> conduira au fait que la taille de l'image, en plus de la taille de l'application, sera ajout√©e √† 73 Mo suppl√©mentaires.  Si nous collectons la m√™me image sur la base de l'image d' <a href="https://hub.docker.com/layers/alpine/library/alpine/3.10.3/images/sha256-77cbe97593c890eb1c4cadcbca37809ebff2b5f46a036666866c99f08a708967">Alpine 3.10.3</a> , nous n'obtiendrons un ¬´additif¬ª que d'un montant de 6 Mo.  √âtant donn√© que Docker met en cache les couches d'images, les ressources r√©seau sont consacr√©es au chargement d'une image uniquement lorsque le conteneur est lanc√© pour la premi√®re fois de la mani√®re appropri√©e (en d'autres termes, la premi√®re fois que l'image est charg√©e).  Mais la taille de l'image elle-m√™me n'en diminue pas. <br><br>  Ici, vous pouvez arriver √† la conclusion (tout √† fait logique) suivante: "Donc - j'utiliserai toujours Alpine!".  Mais, malheureusement, dans le monde du d√©veloppement logiciel, tout n'est pas si simple. <br><br>  Peut-√™tre que <a href="https://gitlab.alpinelinux.org/groups/alpine/-/activity">les d√©veloppeurs d'Alpine Linux ont</a> d√©couvert un ingr√©dient secret qu'Ubuntu ou Debian ne peuvent toujours pas trouver?  Non.  Le fait est que pour cr√©er une image Docker, dont la taille est d'un ordre de grandeur inf√©rieur √† la taille de l'image du m√™me Debian, les d√©veloppeurs Alpine ont d√ª prendre des d√©cisions sur ce qui doit √™tre inclus dans l'image et ce qui n'est pas n√©cessaire.  Avant d'appeler Alpine l'image de base que vous utiliserez toujours, vous devez lui demander si elle contient tout ce dont vous avez besoin.  De plus, m√™me si Alpine poss√®de un gestionnaire de packages, il se peut que le package sp√©cifique utilis√© dans votre environnement de travail bas√©, par exemple, sur Ubuntu, ne soit pas disponible dans Alpine.  Ou - pas un package, mais la version souhait√©e du package.  Ce sont les compromis que vous devez conna√Ætre avant de choisir et de tester l'image de base la mieux adapt√©e √† votre projet. <br><br>  Et enfin, si vous avez vraiment besoin de l'une des plus grandes images de base, vous pouvez utiliser l'outil pour r√©duire la taille de l'image.  Par exemple - un outil open source gratuit <a href="https://dockersl.im/">DockerSlim</a> .  Cela r√©duira la taille de l'image finie. <br><br>  En fin de compte, nous pouvons dire que l'utilisation d'une image de base soigneusement s√©lectionn√©e est extr√™mement importante pour cr√©er vos propres images compactes.  √âvaluez les besoins de votre projet et s√©lectionnez une image qui contient ce dont vous avez besoin tout en ayant des dimensions qui vous conviennent. <br><br><h2>  <font color="#3AC1EF">Pensez √† cr√©er une image qui n'a pas d'image de base.</font> </h2><br>  Si votre application peut s'ex√©cuter sans un environnement suppl√©mentaire fourni de mani√®re basique, vous pouvez d√©cider de ne pas utiliser une image de base.  Bien s√ªr, puisque l'instruction <code>FROM</code> doit √™tre pr√©sente dans le <code>Dockerfile</code> , vous ne pouvez pas vous en passer.  Elle doit en outre pointer vers une sorte d'image.  Quelle image utiliser dans une telle situation? <br><br>  Un look <a href="https://hub.docker.com/_/scratch">Scratch</a> pourrait √™tre utile ici.  D'apr√®s sa description, vous pouvez d√©couvrir qu'il est sp√©cialement rendu vide et con√ßu pour cr√©er des images, si vous parlez le langage <code>Dockerfile</code> , <code>FROM scratch</code> , c'est-√†-dire √† partir de z√©ro.  Cette image est particuli√®rement utile lors de la cr√©ation d'images de base (telles que des images debian et busybox) ou des images extr√™mement minimales (celles qui contiennent un seul fichier binaire et ce qui est requis pour son fonctionnement, par exemple, est quelque chose comme hello-world).  L'utilisation de cette image comme base de l'image d√©crite par le <code>Dockerfile</code> est similaire √† l'utilisation d'une ¬´op√©ration vide¬ª dans certains programmes.  L'application d'une image de travail ne cr√©era pas de couche suppl√©mentaire dans l'image finie. <br><br>  Par cons√©quent, si votre application est un ex√©cutable autonome qui peut fonctionner seul, le choix de l'image de base de base vous permettra de r√©duire la taille du conteneur. <br><br><h2>  <font color="#3AC1EF">Utiliser des builds en plusieurs √©tapes</font> </h2><br>  Les builds en plusieurs √©tapes ont √©t√© au centre de l'attention depuis Docker 05/17.  C'√©tait une opportunit√© attendue depuis longtemps.  Il permet aux cr√©ateurs d'images d'abandonner leurs propres scripts pour cr√©er des images et impl√©menter tout ce dont ils ont besoin en utilisant le format <code>Dockerfile</code> bien connu. <br><br>  En termes g√©n√©raux, un assemblage √† plusieurs √©tapes peut √™tre consid√©r√© comme combinant plusieurs <code>Dockerfile</code> , ou comme un <code>Dockerfile</code> , qui contient plusieurs instructions <code>FROM</code> . <br><br>  Avant l'√©mergence d'assemblages √† plusieurs √©tapes, si vous deviez cr√©er un assemblage de votre projet et le distribuer dans un conteneur √† l'aide du <code>Dockerfile</code> , vous auriez probablement besoin de terminer le processus d'assemblage, ce qui conduirait √† l'apparition d'un conteneur, comme celui illustr√© ci-dessous: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/060/270/1b9/0602701b97e37b957b0e77663b79faec.png"></div><br>  <i><font color="#999999">Cr√©ez et distribuez une application sans utiliser la technologie de construction en plusieurs √©tapes</font></i> <br><br>  Bien que d'un point de vue technique, tout ait √©t√© fait correctement, l'image finale et le conteneur r√©sultant sont remplis de couches cr√©√©es dans le processus de pr√©paration des mat√©riaux du projet.  Et ces couches ne sont pas n√©cessaires pour former l'environnement d'ex√©cution du projet. <br><br>  Les assemblages en plusieurs √©tapes vous permettent de s√©parer les phases de cr√©ation et de pr√©paration des mat√©riaux du projet de l'environnement dans lequel le code du projet est ex√©cut√©. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b30/938/c61/b30938c61707b5fb08866fac84df1c85.png"></div><br>  <i><font color="#999999">Assemblage en plusieurs √©tapes, s√©paration du processus de cr√©ation et de pr√©paration des mat√©riaux du projet de l'environnement d'ex√©cution</font></i> <br><br>  Dans le m√™me temps, un seul <code>Dockerfile</code> suffit pour d√©crire le processus complet de construction du projet.  Mais maintenant, vous pouvez copier du mat√©riel d'une √©tape √† l'autre et vous d√©barrasser des donn√©es inutiles. <br><br>  Les assemblys √† plusieurs √©tages vous permettent de cr√©er des assemblys multiplateformes qui peuvent √™tre utilis√©s √† plusieurs reprises sans utiliser vos propres scripts d'assemblage √©crits pour un syst√®me d'exploitation sp√©cifique.  La taille finale de l'image peut √™tre minimis√©e en raison de la possibilit√© d'inclusion s√©lective de mat√©riaux g√©n√©r√©s aux √©tapes pr√©c√©dentes du processus d'assemblage d'image. <br><br><h2>  <font color="#3AC1EF">R√©sum√©</font> </h2><br>  La cr√©ation d'images de conteneur Docker est un processus auquel les programmeurs modernes doivent souvent faire face.  Il existe de nombreuses ressources pour cr√©er des <code>Dockerfile</code> , et vous pouvez trouver de nombreux exemples de ces fichiers sur Internet.  Mais peu importe ce que vous utilisez, lors de la cr√©ation de votre propre <code>Dockerfile</code> toujours utile de consid√©rer la taille des images r√©sultantes. <br><br>  Ici, nous avons examin√© plusieurs techniques pour minimiser la taille des images Docker.  <code>Dockerfile</code> au contenu du <code>Dockerfile</code> , y compris uniquement ce dont vous avez vraiment besoin, choisir la bonne image de base, utiliser la technologie de construction en plusieurs √©tapes - tout cela peut aider √† r√©duire s√©rieusement la taille des images Docker que vous cr√©ez. <br><br>  <b>PS</b> Nous avons lanc√© le <a href="https://ruvds.com/ru-rub/marketplace">march√©</a> sur le site Web de RUVDS.  Sur le march√©, l'image <a href="https://ruvds.com/ru-rub/marketplace/docker">Docker</a> est install√©e en un clic, vous pouvez v√©rifier le fonctionnement des conteneurs sur <a href="https://ruvds.com/">VPS</a> , 3 jours pour les tests sont fournis gratuitement pour tous les nouveaux clients. <br><br>  <b>Chers lecteurs!</b>  Comment optimisez-vous la taille de vos images Docker? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr485650/">https://habr.com/ru/post/fr485650/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr485632/index.html">Surveillance du score de cr√©dit dans Power BI</a></li>
<li><a href="../fr485636/index.html">Les virus r√©sistants aux CRISPR construisent des abris pour prot√©ger les g√©nomes des enzymes p√©n√©trant l'ADN</a></li>
<li><a href="../fr485640/index.html">M√©thodes de masquage des pages Web</a></li>
<li><a href="../fr485646/index.html">Conseils Python utiles que vous n'avez jamais rencontr√©s auparavant. 2e partie</a></li>
<li><a href="../fr485648/index.html">L'approche pythonique des boucles for: range () et enumerate ()</a></li>
<li><a href="../fr485652/index.html">Statistiques des commentaires en ligne Confluence</a></li>
<li><a href="../fr485654/index.html">Une id√©e tir√©e de la physique aide l'IA √† travailler dans des dimensions plus √©lev√©es.</a></li>
<li><a href="../fr485660/index.html">La soci√©t√© de protection DDoS a elle-m√™me lanc√© des attaques DDoS, a reconnu son fondateur</a></li>
<li><a href="../fr485664/index.html">Cr√©ation de param√®tres dynamiques dans un travail Jenkins, ou comment rendre votre t√¢che conviviale</a></li>
<li><a href="../fr485672/index.html">Redis Best Practices, Partie 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>