<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚪 👩🏾‍🎤 🧛🏽 Docker Image Reduction Techniques 🚣🏿 🙍🏽 ✝️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vous êtes-vous déjà demandé pourquoi la taille d'un conteneur Docker contenant une seule application peut être d'environ 400 Mo? Ou peut-être étiez-vo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Docker Image Reduction Techniques</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/485650/">  Vous êtes-vous déjà demandé pourquoi la taille d'un conteneur Docker contenant une seule application peut être d'environ 400 Mo?  Ou peut-être étiez-vous préoccupé par la taille assez grande de l'image Docker contenant un seul binaire de plusieurs dizaines de Mo? <br><br> <a href="https://habr.com/ru/company/ruvds/blog/485650/"><img src="https://habrastorage.org/webt/ny/az/k8/nyazk8uqdkaog5lwtukn8qz1zpu.jpeg"></a> <br><br>  L'auteur de l'article, dont nous publions aujourd'hui la traduction, souhaite analyser les principaux facteurs affectant la taille des conteneurs Docker.  Il va, en outre, partager des recommandations sur la réduction de la taille des conteneurs. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Couches d'images Docker</font> </h2><br>  Une image d'un conteneur Docker est essentiellement une collection de fichiers empilés les uns sur les autres en plusieurs couches.  Un conteneur de travail est assemblé à partir de ces fichiers.  Docker utilise le système de fichiers <a href="https://en.wikipedia.org/wiki/UnionFS">UnionFS</a> , dans lequel les fichiers sont regroupés en couches.  Un calque peut contenir un ou plusieurs fichiers, les calques se chevauchent.  Lors de l'exécution du conteneur, le contenu des couches est combiné, de sorte que l'utilisateur final du conteneur perçoit les matériaux «disposés» dans les couches comme un système de fichiers unique. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a2/3ba/eea/0a23baeea85753e1a66d8399ff188b4c.png"></div><br>  <i><font color="#999999">Vue UnionFS simplifiée</font></i> <br><br>  Le système de fichiers résultant est présenté à l'utilisateur final à l'aide d'une implémentation UnionFS (Docker <a href="https://docs.docker.com/storage/storagedriver/select-storage-driver/">prend en charge de</a> nombreuses implémentations similaires via des pilotes de stockage de plug-in).  La taille totale des fichiers reçus par l'utilisateur final est égale à la somme des tailles des fichiers dans les couches.  Lorsque Docker crée un conteneur basé sur l'image, il utilise toutes les couches en lecture seule de l'image, en ajoutant une couche mince au-dessus de ces couches qui prend en charge la lecture et l'écriture.  C'est cette couche qui vous permet de modifier des fichiers dans un conteneur en cours d'exécution. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aaf/895/c00/aaf895c00a3353efa96934aeabd85f6f.png"></div><br>  <i><font color="#999999">Le conteneur en cours d'exécution contient une couche en lecture-écriture située au-dessus des couches en lecture seule</font></i> <br><br>  Que se passe-t-il si un fichier est supprimé dans la <code>Layer 4</code> conteneur schématisé ci-dessus?  Bien que ce fichier ne soit pas disponible dans le système de fichiers que l'utilisateur voit, en fait, la taille de ce fichier sera toujours l'un des composants de la taille du conteneur, car ce fichier restera dans l'une des couches en lecture seule. <br><br>  Il est assez simple de commencer à créer l'image avec un petit fichier exécutable d'application et d'accéder à la très grande image.  Ci-dessous, nous examinerons différentes méthodes pour rendre les conteneurs aussi petits que possible. <br><br><h2>  <font color="#3AC1EF">Faites attention au chemin d'accès au dossier, en fonction des matériaux dont les images sont collectées</font> </h2><br>  Quelle est la méthode la plus courante pour assembler des images Docker?  Apparemment - comme ça: <br><br><pre> <code class="plaintext hljs">docker build .</code> </pre> <br>  Le point de cette commande indique à Docker que nous considérons que le répertoire de travail actuel est la racine du système de fichiers utilisé dans le processus d'assemblage d'image. <br><br>  Afin de mieux comprendre ce qui se passe après l'exécution de la commande ci-dessus, il convient de se rappeler que la construction d'une image Docker est un processus client-serveur.  L'interface de ligne de commande Docker (client), à laquelle nous donnons la <code>docker build</code> , utilise le moteur Docker (serveur) pour créer l'image du conteneur.  Pour limiter l'accès au système de fichiers de base du client, le système d'assemblage d'images doit savoir où se trouve la racine du système de fichiers virtuel.  C'est là que les instructions du fichier <code>Dockerfile</code> recherchent les ressources de fichiers qui peuvent éventuellement se retrouver dans l'image en cours d'assemblage. <br><br>  Imaginez un endroit où un <code>Dockerfile</code> généralement placé.  C'est probablement le répertoire racine du projet?  S'il y a un <code>Dockerfile</code> à la racine du projet, qui est utilisé par la <code>docker build</code> pour construire l'image, il s'avère que tous les fichiers du projet peuvent entrer dans l'image.  Cela peut conduire au fait que des milliers de fichiers indésirables de plusieurs mégaoctets peuvent entrer dans le contexte de l'assemblage d'image.  Si vous utilisez légèrement les commandes <code>ADD</code> et <code>COPY</code> dans le <code>Dockerfile</code> , tous les fichiers de projet peuvent bien faire partie de l'image finale.  Le plus souvent, ceux qui collectent des images n'en ont pas besoin, car l'image finale ne doit généralement inclure que certains fichiers sélectionnés. <br><br>  Assurez-vous toujours que la commande <code>docker build</code> chemin d'accès correct et qu'il n'y a aucune commande dans le <code>Dockerfile</code> qui ajoute des fichiers inutiles à l'image.  Si, pour une raison ou une autre, vous devez faire du root du projet le contexte de génération, vous pouvez y inclure des fichiers de manière sélective et les en exclure à l'aide de <code>.dockerignore</code> . <br><br><h2>  <font color="#3AC1EF">Optimiser les calques d'image</font> </h2><br>  Le nombre maximal de couches qu'une image peut avoir est de 127 (compte tenu de la prise en charge d'un tel nombre de couches utilisées par le pilote d'entrepôt de données).  Cette limitation, si elle est absolument nécessaire, peut être assouplie, mais avec cette approche, la gamme de systèmes sur lesquels ces images peuvent être collectées est réduite.  Le fait est que le moteur Docker doit fonctionner sur un système dont le noyau est modifié en conséquence. <br><br>  Comme mentionné dans la section précédente, en raison du fait que UnionFS est utilisé lors de l'assemblage d'images, les fichiers qui tombent dans une certaine couche y restent même s'ils ont été supprimés des couches sus-jacentes.  Voyons cela en utilisant le Dockerfile expérimental: <br><br><pre> <code class="plaintext hljs">FROM alpine RUN wget http://xcal1.vodafone.co.uk/10MB.zip -P /tmp RUN rm /tmp/10MB.zip</code> </pre> <br>  Assemblons l'image: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44b/d7c/e6d/44bd7ce6d60c71fd0856e96bd48ec5b7.png"></div><br>  <i><font color="#999999">Assemblage d'une image expérimentale dans laquelle il y a un espace irrationnellement utilisé</font></i> <br><br>  Explorez l'image à l'aide de la <a href="https://github.com/wagoodman/dive">plongée</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2da/e7f/1a5/2dae7f1a5875ece43a52042632a21401.png"></div><br>  <i><font color="#999999">L'indicateur de performance d'image est de 34%</font></i> <br><br>  L'indicateur d'efficacité d'image de 34% indique qu'une quantité considérable d'espace d'image est utilisée de manière irrationnelle.  Cela conduit à une augmentation du temps de démarrage de l'image, à un gaspillage inutile des ressources réseau, à un temps de démarrage plus lent du conteneur. <br><br>  Comment se débarrasser de ce problème?  Examinons plusieurs options. <br><br><h3>  <font color="#3AC1EF">▍ Fusion des résultats du travail d'équipe</font> </h3><br>  Avez-vous déjà vu des <code>Dockerfile</code> contenant de très longues directives <code>RUN</code> dans lesquelles de nombreuses commandes shell sont combinées à l'aide de <code>&amp;&amp;</code> ?  Il s'agit de la fusion des résultats des équipes. <br><br>  En utilisant cette méthode, nous créons, sur la base des résultats d'une seule longue équipe, une seule couche.  Puisqu'il n'y aura aucun calque dans l'image contenant des fichiers supprimés dans les calques suivants, l'image finale n'inclura pas de tels «fichiers fantômes».  Considérez ceci comme un exemple, en amenant le <code>Dockerfile</code> ci-dessus à cet état: <br><br><pre> <code class="plaintext hljs">FROM alpine RUN wget http://xcal1.vodafone.co.uk/10MB.zip -P /tmp &amp;&amp; rm /tmp/10MB.zip</code> </pre> <br>  Après cela, nous analysons l'image: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbe/87f/a16/fbe87fa1633aec55d8fdcbe4d8d1014e.png"></div><br>  <i><font color="#999999">La fusion des équipes vous a permis de créer une image 100% optimisée</font></i> <br><br>  L'application de cette technique pour optimiser la taille des images dans la pratique est qu'après avoir fini de travailler sur le fichier <code>Dockerfile</code> , vous devez l'analyser et savoir si vous pouvez utiliser la fusion de commandes pour réduire la quantité d'espace gaspillé. <br><br><h3>  <font color="#3AC1EF">▍Application de l'option --squash</font> </h3><br>  Dans les cas où vous utilisez les <code>Dockerfile</code> autres personnes que vous ne souhaitez pas ou ne pouvez pas modifier, une alternative à la fusion des commandes peut être l'assemblage d'une image à l'aide de l'option <code>--squash</code> . <br><br>  Les versions modernes de Docker (à partir de la version 1.13) vous permettent de regrouper toutes les couches en une seule, éliminant ainsi les "ressources fantômes".  Dans ce cas, vous pouvez utiliser le <code>Dockerfile</code> origine non <code>Dockerfile</code> , contenant de nombreuses commandes distinctes.  Mais vous devez créer l'image en utilisant l'option <code>--squash</code> : <br><br><pre> <code class="plaintext hljs">docker build --squash .</code> </pre> <br>  L'image résultante s'avère également 100% optimisée: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/923/10f/5fc/92310f5fc60ee677d39db75f3d0bac93.png"></div><br>  <i><font color="#999999">L'utilisation de l'option --squash lors de l'assemblage a permis de créer une image 100% optimisée</font></i> <br><br>  Ici, vous pouvez prêter attention à un détail intéressant.  À savoir, dans <code>Dockerfile</code> une couche a été créée pour ajouter un fichier et une autre couche pour supprimer ce fichier.  L'option <code>--squash</code> est suffisamment intelligente pour comprendre que dans ce scénario, vous n'avez pas du tout besoin de créer de couches supplémentaires (dans l'image finale, il n'y a que la couche <code>9ccd9…</code> partir de l'image de base que nous utilisons).  En général, pour cela, nous pouvons mettre <code>--squash</code> un plus supplémentaire.  Certes, en utilisant <code>--squash</code> , vous devez considérer que cela peut interférer avec l'utilisation des couches mises en cache. <br><br>  Par conséquent, il est recommandé de prendre en compte le fait que lorsque vous travaillez avec le <code>Dockerfile</code> quelqu'un d'autre que vous ne souhaitez pas modifier, vous pouvez réduire la quantité d'espace d'image utilisé de manière irrationnelle en collectant des images à l'aide de l'option <code>--squash</code> .  Pour analyser l'image finie, vous pouvez utiliser l'outil de <a href="https://github.com/wagoodman/dive">plongée</a> . <br><br><h2>  <font color="#3AC1EF">Supprimer les caches et les fichiers temporaires</font> </h2><br>  Lors de la conteneurisation d'applications, une situation se produit souvent lorsque vous devez placer des outils, des bibliothèques et des utilitaires supplémentaires dans l'image avec eux.  Cela se fait en utilisant des gestionnaires de paquets comme <code>apk</code> , <code>yum</code> , <code>apt</code> . <br><br>  Les gestionnaires de packages s'efforcent de gagner du temps pour l'utilisateur et de ne pas charger à nouveau sa connexion réseau lors de l'installation des packages.  Par conséquent, ils mettent en cache les données téléchargées.  Pour que la taille de l'image Docker finale soit aussi petite que possible, nous n'avons pas besoin de stocker les caches du gestionnaire de packages dans cette image.  Après tout, si nous avons besoin d'une autre image, nous pouvons toujours la reconstruire en utilisant le <code>Dockerfile</code> mis à jour. <br><br>  Afin de supprimer les caches créés par les trois gestionnaires de packages populaires susmentionnés, à la fin d'une commande agrégée (c'est-à-dire celle qui s'exécute pour créer une couche), vous pouvez ajouter ce qui suit: <br><br><pre> <code class="plaintext hljs">APK: ... &amp;&amp; rm -rf /etc/apk/cache YUM: ... &amp;&amp; rm -rf /var/cache/yum APT: ... &amp;&amp; rm -rf /var/cache/apt</code> </pre> <br>  Par conséquent, il est recommandé qu'avant de terminer le travail sur le <code>Dockerfile</code> ajouter des <code>Dockerfile</code> qui suppriment les caches des gestionnaires de packages utilisés pour créer l'image.  La même chose s'applique à tous les fichiers temporaires qui n'affectent pas le bon fonctionnement du conteneur. <br><br><h2>  <font color="#3AC1EF">Choisissez soigneusement votre image de base</font> </h2><br>  Chaque <code>Dockerfile</code> commence par une directive <code>FROM</code> .  C'est là que nous définissons l'image de base sur la base de laquelle notre image sera créée. <br><br>  Voici ce que la <a href="https://docs.docker.com/engine/reference/builder/">documentation</a> Docker en dit: «L'instruction <code>FROM</code> initialise une nouvelle phase de construction et configure l'image de base pour les instructions qui suivent.  Par conséquent, un <code>Dockerfile</code> correctement composé doit commencer par une instruction <code>FROM</code> .  Une image peut être n'importe quelle image réalisable.  Il est plus facile de commencer à assembler votre propre image, en prenant comme base une image d'un référentiel public. " <br><br>  De toute évidence, il existe de nombreuses images de base, chacune ayant ses propres caractéristiques et capacités.  La sélection correcte d'une image de base qui contient exactement ce dont l'application a besoin, ni plus ni moins, a un impact énorme sur la taille de l'image finale. <br><br>  Comme vous pouvez vous y attendre, les tailles des images de base populaires varient énormément: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/847/e59/97c/847e5997cf00104e3b212874ee830243.png"></div><br>  <i><font color="#999999">Tailles d'images de docker de base populaires</font></i> <br><br>  Ainsi, la conteneurisation de l'application en utilisant l'image de base d' <a href="https://hub.docker.com/layers/ubuntu/library/ubuntu/19.10/images/sha256-bceb2fb47400491f75a9056a3d4e219cbe5f9512d4220ca43f3f5cb3d08e9d04">Ubuntu 19.10</a> conduira au fait que la taille de l'image, en plus de la taille de l'application, sera ajoutée à 73 Mo supplémentaires.  Si nous collectons la même image sur la base de l'image d' <a href="https://hub.docker.com/layers/alpine/library/alpine/3.10.3/images/sha256-77cbe97593c890eb1c4cadcbca37809ebff2b5f46a036666866c99f08a708967">Alpine 3.10.3</a> , nous n'obtiendrons un «additif» que d'un montant de 6 Mo.  Étant donné que Docker met en cache les couches d'images, les ressources réseau sont consacrées au chargement d'une image uniquement lorsque le conteneur est lancé pour la première fois de la manière appropriée (en d'autres termes, la première fois que l'image est chargée).  Mais la taille de l'image elle-même n'en diminue pas. <br><br>  Ici, vous pouvez arriver à la conclusion (tout à fait logique) suivante: "Donc - j'utiliserai toujours Alpine!".  Mais, malheureusement, dans le monde du développement logiciel, tout n'est pas si simple. <br><br>  Peut-être que <a href="https://gitlab.alpinelinux.org/groups/alpine/-/activity">les développeurs d'Alpine Linux ont</a> découvert un ingrédient secret qu'Ubuntu ou Debian ne peuvent toujours pas trouver?  Non.  Le fait est que pour créer une image Docker, dont la taille est d'un ordre de grandeur inférieur à la taille de l'image du même Debian, les développeurs Alpine ont dû prendre des décisions sur ce qui doit être inclus dans l'image et ce qui n'est pas nécessaire.  Avant d'appeler Alpine l'image de base que vous utiliserez toujours, vous devez lui demander si elle contient tout ce dont vous avez besoin.  De plus, même si Alpine possède un gestionnaire de packages, il se peut que le package spécifique utilisé dans votre environnement de travail basé, par exemple, sur Ubuntu, ne soit pas disponible dans Alpine.  Ou - pas un package, mais la version souhaitée du package.  Ce sont les compromis que vous devez connaître avant de choisir et de tester l'image de base la mieux adaptée à votre projet. <br><br>  Et enfin, si vous avez vraiment besoin de l'une des plus grandes images de base, vous pouvez utiliser l'outil pour réduire la taille de l'image.  Par exemple - un outil open source gratuit <a href="https://dockersl.im/">DockerSlim</a> .  Cela réduira la taille de l'image finie. <br><br>  En fin de compte, nous pouvons dire que l'utilisation d'une image de base soigneusement sélectionnée est extrêmement importante pour créer vos propres images compactes.  Évaluez les besoins de votre projet et sélectionnez une image qui contient ce dont vous avez besoin tout en ayant des dimensions qui vous conviennent. <br><br><h2>  <font color="#3AC1EF">Pensez à créer une image qui n'a pas d'image de base.</font> </h2><br>  Si votre application peut s'exécuter sans un environnement supplémentaire fourni de manière basique, vous pouvez décider de ne pas utiliser une image de base.  Bien sûr, puisque l'instruction <code>FROM</code> doit être présente dans le <code>Dockerfile</code> , vous ne pouvez pas vous en passer.  Elle doit en outre pointer vers une sorte d'image.  Quelle image utiliser dans une telle situation? <br><br>  Un look <a href="https://hub.docker.com/_/scratch">Scratch</a> pourrait être utile ici.  D'après sa description, vous pouvez découvrir qu'il est spécialement rendu vide et conçu pour créer des images, si vous parlez le langage <code>Dockerfile</code> , <code>FROM scratch</code> , c'est-à-dire à partir de zéro.  Cette image est particulièrement utile lors de la création d'images de base (telles que des images debian et busybox) ou des images extrêmement minimales (celles qui contiennent un seul fichier binaire et ce qui est requis pour son fonctionnement, par exemple, est quelque chose comme hello-world).  L'utilisation de cette image comme base de l'image décrite par le <code>Dockerfile</code> est similaire à l'utilisation d'une «opération vide» dans certains programmes.  L'application d'une image de travail ne créera pas de couche supplémentaire dans l'image finie. <br><br>  Par conséquent, si votre application est un exécutable autonome qui peut fonctionner seul, le choix de l'image de base de base vous permettra de réduire la taille du conteneur. <br><br><h2>  <font color="#3AC1EF">Utiliser des builds en plusieurs étapes</font> </h2><br>  Les builds en plusieurs étapes ont été au centre de l'attention depuis Docker 05/17.  C'était une opportunité attendue depuis longtemps.  Il permet aux créateurs d'images d'abandonner leurs propres scripts pour créer des images et implémenter tout ce dont ils ont besoin en utilisant le format <code>Dockerfile</code> bien connu. <br><br>  En termes généraux, un assemblage à plusieurs étapes peut être considéré comme combinant plusieurs <code>Dockerfile</code> , ou comme un <code>Dockerfile</code> , qui contient plusieurs instructions <code>FROM</code> . <br><br>  Avant l'émergence d'assemblages à plusieurs étapes, si vous deviez créer un assemblage de votre projet et le distribuer dans un conteneur à l'aide du <code>Dockerfile</code> , vous auriez probablement besoin de terminer le processus d'assemblage, ce qui conduirait à l'apparition d'un conteneur, comme celui illustré ci-dessous: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/060/270/1b9/0602701b97e37b957b0e77663b79faec.png"></div><br>  <i><font color="#999999">Créez et distribuez une application sans utiliser la technologie de construction en plusieurs étapes</font></i> <br><br>  Bien que d'un point de vue technique, tout ait été fait correctement, l'image finale et le conteneur résultant sont remplis de couches créées dans le processus de préparation des matériaux du projet.  Et ces couches ne sont pas nécessaires pour former l'environnement d'exécution du projet. <br><br>  Les assemblages en plusieurs étapes vous permettent de séparer les phases de création et de préparation des matériaux du projet de l'environnement dans lequel le code du projet est exécuté. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b30/938/c61/b30938c61707b5fb08866fac84df1c85.png"></div><br>  <i><font color="#999999">Assemblage en plusieurs étapes, séparation du processus de création et de préparation des matériaux du projet de l'environnement d'exécution</font></i> <br><br>  Dans le même temps, un seul <code>Dockerfile</code> suffit pour décrire le processus complet de construction du projet.  Mais maintenant, vous pouvez copier du matériel d'une étape à l'autre et vous débarrasser des données inutiles. <br><br>  Les assemblys à plusieurs étages vous permettent de créer des assemblys multiplateformes qui peuvent être utilisés à plusieurs reprises sans utiliser vos propres scripts d'assemblage écrits pour un système d'exploitation spécifique.  La taille finale de l'image peut être minimisée en raison de la possibilité d'inclusion sélective de matériaux générés aux étapes précédentes du processus d'assemblage d'image. <br><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>  La création d'images de conteneur Docker est un processus auquel les programmeurs modernes doivent souvent faire face.  Il existe de nombreuses ressources pour créer des <code>Dockerfile</code> , et vous pouvez trouver de nombreux exemples de ces fichiers sur Internet.  Mais peu importe ce que vous utilisez, lors de la création de votre propre <code>Dockerfile</code> toujours utile de considérer la taille des images résultantes. <br><br>  Ici, nous avons examiné plusieurs techniques pour minimiser la taille des images Docker.  <code>Dockerfile</code> au contenu du <code>Dockerfile</code> , y compris uniquement ce dont vous avez vraiment besoin, choisir la bonne image de base, utiliser la technologie de construction en plusieurs étapes - tout cela peut aider à réduire sérieusement la taille des images Docker que vous créez. <br><br>  <b>PS</b> Nous avons lancé le <a href="https://ruvds.com/ru-rub/marketplace">marché</a> sur le site Web de RUVDS.  Sur le marché, l'image <a href="https://ruvds.com/ru-rub/marketplace/docker">Docker</a> est installée en un clic, vous pouvez vérifier le fonctionnement des conteneurs sur <a href="https://ruvds.com/">VPS</a> , 3 jours pour les tests sont fournis gratuitement pour tous les nouveaux clients. <br><br>  <b>Chers lecteurs!</b>  Comment optimisez-vous la taille de vos images Docker? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr485650/">https://habr.com/ru/post/fr485650/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr485632/index.html">Surveillance du score de crédit dans Power BI</a></li>
<li><a href="../fr485636/index.html">Les virus résistants aux CRISPR construisent des abris pour protéger les génomes des enzymes pénétrant l'ADN</a></li>
<li><a href="../fr485640/index.html">Méthodes de masquage des pages Web</a></li>
<li><a href="../fr485646/index.html">Conseils Python utiles que vous n'avez jamais rencontrés auparavant. 2e partie</a></li>
<li><a href="../fr485648/index.html">L'approche pythonique des boucles for: range () et enumerate ()</a></li>
<li><a href="../fr485652/index.html">Statistiques des commentaires en ligne Confluence</a></li>
<li><a href="../fr485654/index.html">Une idée tirée de la physique aide l'IA à travailler dans des dimensions plus élevées.</a></li>
<li><a href="../fr485660/index.html">La société de protection DDoS a elle-même lancé des attaques DDoS, a reconnu son fondateur</a></li>
<li><a href="../fr485664/index.html">Création de paramètres dynamiques dans un travail Jenkins, ou comment rendre votre tâche conviviale</a></li>
<li><a href="../fr485672/index.html">Redis Best Practices, Partie 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>