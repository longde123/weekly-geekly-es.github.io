<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤟🏽 🐣 🔓 Création de Tower Defense dans Unity: scénarios et vagues d'ennemis 🍬 👩‍👧 😩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[ Les première , deuxième , troisième et quatrième parties du didacticiel] 



- Prise en charge des ennemis de petites, moyennes et grandes tailles. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Création de Tower Defense dans Unity: scénarios et vagues d'ennemis</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466855/">  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les première</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deuxième</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">troisième</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">quatrième</a> parties du didacticiel] <br><br><ul><li>  Prise en charge des ennemis de petites, moyennes et grandes tailles. </li><li>  Créez des scénarios de jeu avec plusieurs vagues d'ennemis. </li><li>  Séparation de la configuration des actifs et de l'état du gameplay. </li><li>  Commencez, arrêtez, gagnez, battez et accélérez le jeu. </li><li>  Créez des scénarios répétitifs sans fin. </li></ul><br>  Ceci est la cinquième partie d'une série de tutoriels sur la création d'un jeu de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tower defense</a> simple.  Dans ce document, nous apprendrons à créer des scénarios de gameplay qui génèrent des vagues de divers ennemis. <br><br>  Le didacticiel a été créé dans Unity 2018.4.6f1. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b12/6aa/945/b126aa94582cc44651853c3ee69be82b.jpg" width="512" height="256"></div><br>  <i>Ça devient assez confortable.</i> <br><a name="habracut"></a><br><h2>  Plus d'ennemis </h2><br>  Ce n'est pas très intéressant de créer le même cube bleu à chaque fois.  La première étape pour prendre en charge des scénarios de jeu plus intéressants sera de prendre en charge plusieurs types d'ennemis. <br><br><h3>  Configurations ennemies </h3><br>  Il existe de nombreuses façons de rendre les ennemis uniques, mais nous ne compliquerons pas: nous les classons comme petits, moyens et grands.  Pour les étiqueter, créez une énumération <code>EnemyType</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> EnemyType { Small, Medium, Large }</code> </pre> <br>  Changez <code>EnemyFactory</code> pour qu'il <code>EnemyFactory</code> en charge les trois types d'ennemis au lieu d'un.  Pour les trois ennemis, les mêmes champs de configuration sont nécessaires, nous ajoutons donc une classe <code>EnemyConfig</code> imbriquée les contenant tous, puis ajoutons trois champs de configuration de ce type à l'usine.  Étant donné que cette classe est utilisée uniquement pour la configuration et que nous ne l'utiliserons nulle part ailleurs, vous pouvez simplement rendre ses champs publics afin que l'usine puisse y accéder.  <code>EnemyConfig</code> lui <code>EnemyConfig</code> même <code>EnemyConfig</code> pas tenu d'être public. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemyFactory</span></span> : <span class="hljs-title"><span class="hljs-title">GameObjectFactory</span></span> { [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemyConfig</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Enemy prefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; [FloatRangeSlider(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">2f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FloatRange scale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">1f</span></span>); [FloatRangeSlider(<span class="hljs-number"><span class="hljs-number">0.2f</span></span>, <span class="hljs-number"><span class="hljs-number">5f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FloatRange speed = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">1f</span></span>); [FloatRangeSlider(<span class="hljs-number"><span class="hljs-number">-0.4f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FloatRange pathOffset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">0f</span></span>); } [SerializeField] EnemyConfig small = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, medium = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, large = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; … }</code> </pre> <br>  Rendons également la santé personnalisable pour chaque ennemi, car il est logique que les grands ennemis en aient plus que les petits. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">FloatRangeSlider(10f, 1000f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FloatRange health = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">100f</span></span>);</code> </pre> <br>  Ajoutez un paramètre de type à <code>Get</code> pour obtenir un type d'ennemi spécifique, et le type par défaut sera moyen.  Nous allons utiliser le type pour obtenir la configuration correcte, pour laquelle une méthode distincte est utile, puis créer et initialiser l'ennemi comme auparavant, uniquement avec l'argument santé ajouté. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">EnemyConfig </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetConfig</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemyType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EnemyType.Small: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> small; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EnemyType.Medium: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> medium; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EnemyType.Large: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> large; } Debug.Assert(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"Unsupported enemy type!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Enemy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemyType type = EnemyType.Medium</span></span></span><span class="hljs-function">)</span></span> { EnemyConfig config = GetConfig(type); Enemy instance = CreateGameObjectInstance(config.prefab); instance.OriginFactory = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; instance.Initialize( config.scale.RandomValueInRange, config.speed.RandomValueInRange, config.pathOffset.RandomValueInRange, config.health.RandomValueInRange ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; }</code> </pre> <br>  Ajoutez le paramètre de santé requis à <code>Enemy.Initialize</code> et utilisez-le pour définir la santé au lieu de la déterminer par la taille de l'ennemi. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathOffset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> health </span></span></span><span class="hljs-function">)</span></span> { … Health = health; }</code> </pre> <br><h3>  Nous créons le design de différents ennemis </h3><br>  Vous pouvez choisir quelle sera la conception des trois ennemis, mais dans le tutoriel, je m'efforcerai de simplifier au maximum.  J'ai dupliqué le préfabriqué d'origine de l'ennemi et l'ai utilisé pour les trois tailles, en changeant uniquement le matériau: jaune pour petit, bleu pour moyen et rouge pour grand.  Je n'ai pas changé l'échelle du cube préfabriqué, mais j'ai utilisé la configuration d'échelle d'usine pour définir les dimensions.  De plus, selon la taille, j'ai augmenté leur santé et réduit leur vitesse. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd7/070/231/bd707023151022e921c5b6956bb20c02.png" width="320" height="348"></div><br>  <i>Usine de cubes ennemis de trois tailles.</i> <br><br>  Le moyen le plus rapide consiste à faire apparaître les trois types dans le jeu en changeant <code>Game.SpawnEnemy</code> afin qu'il obtienne un type d'ennemi aléatoire au lieu de l'ennemi du milieu. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnEnemy</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile spawnPoint = board.GetSpawnPoint(Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, board.SpawnPointCount)); Enemy enemy = enemyFactory.Get((EnemyType)(Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>))); enemy.SpawnOn(spawnPoint); enemies.Add(enemy); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/537/73b/b92/53773bb9299a8ec9c56b485718049e5b.png" width="230" height="230"></div><br>  <i>Ennemis de différents types.</i> <br><br><h3>  Plusieurs usines </h3><br>  Maintenant, l'usine d'ennemis définit un grand nombre de trois ennemis.  L'usine existante crée des cubes de trois tailles, mais rien ne nous empêche de faire une autre usine qui crée autre chose, par exemple des sphères de trois tailles.  Nous pouvons changer les ennemis créés en nommant une autre usine dans le jeu, passant ainsi à un sujet différent. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65f/7e5/330/65f7e5330945ea654f1caef579fe567f.png" width="230" height="230"></div><br>  <i>Ennemis sphériques.</i> <br><br><h2>  Vagues d'ennemis </h2><br>  La deuxième étape de la création de scénarios de gameplay sera le rejet des ennemis qui se reproduisent avec une fréquence constante.  Les ennemis doivent être créés par vagues successives jusqu'à la fin du script ou la perte du joueur. <br><br><h3>  Séquences de création </h3><br>  Une vague d'ennemis se compose d'un groupe d'ennemis créés l'un après l'autre jusqu'à ce que la vague soit terminée.  Une vague peut contenir différents types d'ennemis et le délai entre leur création peut varier.  Afin de ne pas compliquer l'implémentation, nous commencerons par une simple séquence d'apparition qui crée le même type d'ennemis avec une fréquence constante.  Ensuite, l'onde ne sera qu'une liste de ces séquences. <br><br>  Pour configurer chaque séquence, créez une classe <code>EnemySpawnSequence</code> .  Comme c'est assez compliqué, mettez-le dans un fichier séparé.  La séquence doit savoir quelle usine utiliser, quel type d'ennemi créer, leur nombre et leur fréquence.  Pour simplifier la configuration, nous allons faire du dernier paramètre une pause, qui détermine le temps qui doit s'écouler avant de créer l'ennemi suivant.  Notez que cette approche vous permet d'utiliser plusieurs usines ennemies dans la vague. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemySpawnSequence</span></span> { [SerializeField] EnemyFactory factory = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; [SerializeField] EnemyType type = EnemyType.Medium; [SerializeField, Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> amount = <span class="hljs-number"><span class="hljs-number">1</span></span>; [SerializeField, Range(<span class="hljs-number"><span class="hljs-number">0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">10f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cooldown = <span class="hljs-number"><span class="hljs-number">1f</span></span>; }</code> </pre> <br><h3>  Les vagues </h3><br>  Une vague est un simple tableau de séquences de création ennemies.  Créez pour lui un type d' <code>EnemyWave</code> EnemyWave qui commence par une séquence standard. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [CreateAssetMenu] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemyWave</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { [SerializeField] EnemySpawnSequence[] spawnSequences = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EnemySpawnSequence() }; }</code> </pre> <br>  Maintenant, nous pouvons créer des vagues d'ennemis.  Par exemple, j'ai créé une vague qui génère un groupe d'ennemis cubiques, en commençant par dix petits, avec une fréquence de deux par seconde.  Ils sont suivis de cinq moyennes, créées une fois par seconde, et, enfin, d'un gros ennemi avec une pause de cinq secondes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b16/af3/47f/b16af347f057760db35703515642db89.png" width="320" height="376"></div><br>  <i>Une vague de cubes croissants.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Puis-je ajouter un délai entre les séquences?</b> <div class="spoiler_text">  Vous pouvez l'implémenter indirectement.  Par exemple, insérez un délai de quatre secondes entre les petits et les cubes moyens, réduisez le nombre de petits cubes d'un et insérez une séquence d'un petit cube avec une pause de quatre secondes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/59b/ff4/3f9/59bff43f9a71002c0bd562f270b755ea.png" width="320" height="272"></div><br>  <i>Délai de quatre secondes entre les cubes petits et moyens.</i> </div></div><br><h3>  Scénarios </h3><br>  Le scénario de gameplay est créé à partir d'une séquence de vagues.  Pour cela, créez un <code>GameScenario</code> actif <code>GameScenario</code> avec un seul tableau de vagues, puis utilisez-le pour créer le scénario. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [CreateAssetMenu] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameScenario</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { [SerializeField] EnemyWave[] waves = {}; }</code> </pre> <br>  Par exemple, j'ai créé un scénario avec deux vagues d'ennemis petits-moyens-grands (MSC), d'abord avec des cubes, puis avec des sphères. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/796/df0/73b/796df073b24d092d35093b6e56b8be79.png" width="320" height="142"></div><br>  <i>Scénario avec deux vagues de MSC.</i> <br><br><h3>  Mouvement séquentiel </h3><br>  Les types d'actifs sont utilisés pour créer des scripts, mais comme il s'agit d'actifs, ils doivent contenir des données qui ne changent pas pendant le jeu.  Cependant, pour faire avancer le scénario, nous devons en quelque sorte suivre leur statut.  Une façon consiste à dupliquer l'actif utilisé dans le jeu afin que le doublon suive son état.  Mais nous n'avons pas besoin de dupliquer l'ensemble de l'actif, il suffit de préciser et les liens vers l'actif suffisent.  <code>EnemySpawnSequence</code> donc une classe d' <code>State</code> distincte, d'abord pour <code>EnemySpawnSequence</code> .  Puisqu'il ne s'applique qu'à une séquence, nous le faisons imbriqué.  Elle n'est valide que lorsqu'elle a une référence à une séquence, nous allons donc lui donner une méthode constructeur avec un paramètre de séquence. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/18c/752/4fd/18c7524fdac87c062a6c683bbdee1866.png" width="315" height="50"></div><br>  <i>Un type d'état imbriqué qui fait référence à sa séquence.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemySpawnSequence</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">State</span></span> { EnemySpawnSequence sequence; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemySpawnSequence sequence</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sequence = sequence; } } }</code> </pre> <br>  Lorsque nous voulons commencer à avancer dans une séquence, nous avons besoin d'une nouvelle instance de l'état pour cela.  Ajoutez des séquences à la méthode <code>Begin</code> , qui construit et renvoie l'état.  Grâce à cela, tous ceux qui appellent <code>Begin</code> seront responsables de faire correspondre l'état, et la séquence elle-même restera apatride.  Il sera même possible d'avancer en parallèle plusieurs fois dans la même séquence. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemySpawnSequence</span></span> { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Begin</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> State(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">State</span></span> { … } }</code> </pre> <br>  Pour que l'État survive après des redémarrages à chaud, vous devez le rendre sérialisable. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">System.Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">State</span></span> { … }</code> </pre> <br>  L'inconvénient de cette approche est que chaque fois que nous exécutons une séquence, nous devons créer un nouvel objet d'état.  Nous pouvons éviter l'allocation de mémoire en en faisant une structure au lieu d'une classe.  C'est normal tant que la condition reste petite.  Gardez juste à l'esprit que l'état est un type de valeur.  Lorsqu'il est transféré, il est copié, alors suivez-le au même endroit. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">System.Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> State { … }</code> </pre> <br>  L'état de la séquence ne comprend que deux aspects: le nombre d'ennemis générés et la progression du temps de pause.  Nous ajoutons la méthode <code>Progress</code> , qui augmente la valeur de la pause du delta temporel, puis la réinitialise lorsque la valeur configurée est atteinte, similaire à ce qui se passe avec le temps de génération dans <code>Game.Update</code> .  Nous augmenterons le nombre d'ennemis chaque fois que cela se produira.  De plus, la valeur de pause doit commencer par la valeur maximale afin que la séquence crée des ennemis sans pause au début. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cooldown; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemySpawnSequence sequence</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sequence = sequence; count = <span class="hljs-number"><span class="hljs-number">0</span></span>; cooldown = sequence.cooldown; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { cooldown += Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cooldown &gt;= sequence.cooldown) { cooldown -= sequence.cooldown; count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50c/aba/5e5/50caba5e50d89e05a6cb9a631feb1c6d.png" width="315" height="74"></div><br>  <i>L'état ne contient que les données nécessaires.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Puis-je accéder à EnemySpawnSequence.cooldown depuis State?</b> <div class="spoiler_text">  Oui, car l' <code>State</code> est défini dans la même portée.  Par conséquent, les types imbriqués connaissent les membres privés des types qui les contiennent. </div></div><br>  La progression doit se poursuivre jusqu'à ce que le nombre d'ennemis souhaité soit créé et que la pause se termine.  À ce stade, <code>Progress</code> devrait signaler l'achèvement, mais il est fort probable que nous surpassions un peu la valeur.  Par conséquent, à ce moment, nous devons retourner le temps supplémentaire afin de l'utiliser dans l'avancement dans la séquence suivante.  Pour que cela fonctionne, vous devez transformer le delta temporel en paramètre.  Nous devons également indiquer que nous n'avons pas encore terminé, et cela peut être réalisé en renvoyant une valeur négative. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> deltaTime</span></span></span><span class="hljs-function">)</span></span> { cooldown += deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cooldown &gt;= sequence.cooldown) { cooldown -= sequence.cooldown; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt;= sequence.amount) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cooldown; } count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1f</span></span>; }</code> </pre> <br><h3>  Créez des ennemis n'importe où </h3><br>  Pour que les séquences engendrent des ennemis, nous devons convertir <code>Game.SpawnEnemy</code> en une autre méthode statique publique. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnEnemy</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemyFactory factory, EnemyType type</span></span></span><span class="hljs-function">)</span></span> { GameTile spawnPoint = instance.board.GetSpawnPoint( Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, instance.board.SpawnPointCount) ); Enemy enemy = factory.Get(type); enemy.SpawnOn(spawnPoint); instance.enemies.Add(enemy); }</code> </pre> <br>  Puisque le <code>Game</code> lui-même ne générera plus d'ennemis, nous pouvons supprimer l'usine ennemie, la vitesse de création, le processus de promotion de la création et le code de création ennemi de <code>Update</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { }</code> </pre> <br>  Nous appellerons <code>Game.SpawnEnemy</code> dans <code>EnemySpawnSequence.State.Progress</code> après avoir augmenté le nombre d'ennemis. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> deltaTime</span></span></span><span class="hljs-function">)</span></span> { cooldown += deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cooldown &gt;= sequence.cooldown) { … count += <span class="hljs-number"><span class="hljs-number">1</span></span>; Game.SpawnEnemy(sequence.factory, sequence.type); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1f</span></span>; }</code> </pre> <br><h3>  Avancement des vagues </h3><br>  Prenons la même approche pour se déplacer le long d'une séquence que pour se déplacer le long d'une vague entière.  Donnons à <code>EnemyWave</code> sa propre méthode <code>Begin</code> , qui renvoie une nouvelle instance de la structure <code>State</code> imbriquée.  Dans ce cas, l'état contient l'indice d'onde et l'état de la séquence active, que nous initialisons au début de la première séquence. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9eb/9f8/bc7/9eb9f8bc7769dd0c65624802ac2a97b8.png" width="315" height="128"></div><br>  <i>Un état d'onde contenant l'état d'une séquence.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemyWave</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { [SerializeField] EnemySpawnSequence[] spawnSequences = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EnemySpawnSequence() }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Begin</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> State(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> State { EnemyWave wave; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index; EnemySpawnSequence.State sequence; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemyWave wave</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wave = wave; index = <span class="hljs-number"><span class="hljs-number">0</span></span>; Debug.Assert(wave.spawnSequences.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Empty wave!"</span></span>); sequence = wave.spawnSequences[<span class="hljs-number"><span class="hljs-number">0</span></span>].Begin(); } } }</code> </pre> <br>  Nous ajoutons également la méthode <code>EnemyWave.State</code> <code>Progress</code> , qui utilise la même approche que précédemment, avec des modifications mineures.  Nous commençons par nous déplacer le long de la séquence active et remplaçons le delta temporel par le résultat de cet appel.  Tant qu'il reste du temps, nous passons à la séquence suivante, si elle est accessible, et nous progressons.  S'il n'y a plus de séquence, nous renvoyons le temps restant;  sinon, retournez une valeur négative. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> deltaTime</span></span></span><span class="hljs-function">)</span></span> { deltaTime = sequence.Progress(deltaTime); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (deltaTime &gt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++index &gt;= wave.spawnSequences.Length) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> deltaTime; } sequence = wave.spawnSequences[index].Begin(); deltaTime = sequence.Progress(deltaTime); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1f</span></span>; }</code> </pre> <br><h3>  Promotion de script </h3><br>  Ajoutez <code>GameScenario</code> au même traitement.  Dans ce cas, l'état contient l'indice d'onde et l'état de l'onde active. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameScenario</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { [SerializeField] EnemyWave[] waves = {}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Begin</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> State(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> State { GameScenario scenario; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index; EnemyWave.State wave; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameScenario scenario</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scenario = scenario; index = <span class="hljs-number"><span class="hljs-number">0</span></span>; Debug.Assert(scenario.waves.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Empty scenario!"</span></span>); wave = scenario.waves[<span class="hljs-number"><span class="hljs-number">0</span></span>].Begin(); } } }</code> </pre> <br>  Puisque nous sommes au niveau supérieur, la méthode <code>Progress</code> ne nécessite pas de paramètre et vous pouvez utiliser directement <code>Time.deltaTime</code> .  Nous n'avons pas besoin de renvoyer le temps restant, mais nous devons montrer si le script est terminé.  Nous retournerons <code>false</code> après la fin de la dernière vague et <code>true</code> pour montrer que le script est toujours actif. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> deltaTime = wave.Progress(Time.deltaTime); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (deltaTime &gt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++index &gt;= scenario.waves.Length) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } wave = scenario.waves[index].Begin(); deltaTime = wave.Progress(deltaTime); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3>  Exécution de script </h3><br>  Pour jouer à un script de <code>Game</code> , vous avez besoin d'un champ de configuration de script et d'un suivi de son état.  Nous allons simplement exécuter le script dans Awake et exécuter <code>Update</code> sur celui-ci jusqu'à ce que le statut du reste du jeu soit mis à jour. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameScenario scenario = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; GameScenario.State activeScenario; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { board.Initialize(boardSize, tileContentFactory); board.ShowGrid = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; activeScenario = scenario.Begin(); } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … activeScenario.Progress(); enemies.GameUpdate(); Physics.SyncTransforms(); board.GameUpdate(); nonEnemies.GameUpdate(); }</code> </pre> <br>  Maintenant, le script configuré sera lancé au début du jeu.  La promotion sera effectuée jusqu'à son achèvement, et après quoi rien ne se passera. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mk/x0/uf/mkx0ufxshpgvy29wjr_nxdmneu4.gif"></div><br>  <i>Deux vagues ont accéléré 10 fois.</i> <br><br><h2>  Démarrer et terminer les jeux </h2><br>  Nous pouvons reproduire un scénario, mais après son achèvement, de nouveaux ennemis n'apparaîtront pas.  Pour que le jeu continue, nous devons permettre de démarrer un nouveau scénario, soit manuellement, soit parce que le joueur a perdu / gagné.  Vous pouvez également implémenter un choix de plusieurs scénarios, mais dans ce tutoriel, nous ne le considérerons pas. <br><br><h3>  Le début d'un nouveau jeu </h3><br>  Idéalement, nous devons avoir la possibilité de commencer un nouveau jeu à tout moment.  Pour ce faire, vous devez réinitialiser l'état actuel de l'ensemble du jeu, c'est-à-dire que nous devrons réinitialiser de nombreux objets.  Tout d'abord, ajoutez une méthode <code>Clear</code> à la <code>GameBehaviorCollection</code> qui utilise tous ses comportements. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; behaviors.Count; i++) { behaviors[i].Recycle(); } behaviors.Clear(); }</code> </pre> <br>  Cela suggère que tous les comportements peuvent être éliminés, mais jusqu'à présent ce n'est pas le cas.  Pour que cela fonctionne, ajoutez <code>GameBehavior</code> méthode de <code>Recycle</code> abstraite à <code>GameBehavior</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Recycle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>;</code> </pre> <br>  La méthode <code>Recycle</code> de la classe <code>WarEntity</code> doit la remplacer explicitement. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Recycle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { originFactory.Reclaim(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  <code>Enemy</code> n'a pas encore de méthode de <code>Recycle</code> , alors ajoutez-le.  Tout ce qu'il a à faire est de forcer l'usine à la retourner.  Ensuite, nous appelons <code>Recycle</code> partout où nous accédons directement à l'usine. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Health &lt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { Recycle(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } progress += Time.deltaTime * progressFactor; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (progress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tileTo == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Recycle(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } … } … } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Recycle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { OriginFactory.Reclaim(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  <code>GameBoard</code> doit également être réinitialisé, nous allons donc lui donner la méthode <code>Clear</code> , qui vide toutes les tuiles, réinitialise tous les points de création et met à jour le contenu, puis définit les points de début et de fin standard.  Ensuite, au lieu de répéter le code, nous pouvons appeler <code>Clear</code> à la fin de <code>Initialize</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector2Int size, GameTileContentFactory contentFactory </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { … } } Clear(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.Content = contentFactory.Get(GameTileContentType.Empty); } spawnPoints.Clear(); updatingContent.Clear(); ToggleDestination(tiles[tiles.Length / <span class="hljs-number"><span class="hljs-number">2</span></span>]); ToggleSpawnPoint(tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }</code> </pre> <br>  Nous pouvons maintenant ajouter la méthode <code>BeginNewGame</code> au <code>Game</code> , en <code>BeginNewGame</code> les ennemis, d'autres objets et le champ, puis en démarrant un nouveau script. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginNewGame</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { enemies.Clear(); nonEnemies.Clear(); board.Clear(); activeScenario = scenario.Begin(); }</code> </pre> <br>  Nous appellerons cette méthode dans <code>Update</code> si vous appuyez sur B avant de passer au script. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.B)) { BeginNewGame(); } activeScenario.Progress(); … }</code> </pre> <br><h3>  Perdre </h3><br>  Le but du jeu est de vaincre tous les ennemis avant qu'un certain nombre d'entre eux n'atteignent le point final.  Le nombre d'ennemis nécessaires pour déclencher la condition de défaite dépend de la santé initiale du joueur, pour laquelle nous ajouterons un champ de configuration au <code>Game</code> .  Puisque nous comptons les ennemis, nous utiliserons un entier, pas un flottant. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(0, 100)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startingPlayerHealth = <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f3/9c5/11a/4f39c511ab9d362b1cc7e55610a317aa.png" width="320" height="38"></div><br>  <i>Initialement, un joueur a 10 points de vie.</i> <br><br>  Dans le cas de Awake ou du début d'une nouvelle partie, nous attribuons la valeur initiale à la santé actuelle du joueur. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> playerHealth; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { playerHealth = startingPlayerHealth; … } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginNewGame</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { playerHealth = startingPlayerHealth; … }</code> </pre> <br>  Ajoutez une méthode <code>EnemyReachedDestination</code> statique publique <code>EnemyReachedDestination</code> que les ennemis puissent dire à <code>Game</code> qu'ils ont atteint le point final.  Dans ce cas, réduisez la santé du joueur. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnemyReachedDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { instance.playerHealth -= <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Appelez cette méthode dans <code>Enemy.GameUpdate</code> au moment approprié. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tileTo == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Game.EnemyReachedDestination(); Recycle(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Nous pouvons maintenant vérifier l'état de la défaite dans <code>Game.Update</code> .  Si la santé du joueur est égale ou inférieure à zéro, la condition de défaite est déclenchée.  Nous enregistrons simplement ces informations et commençons immédiatement une nouvelle partie avant d'avancer.  Mais nous ne le ferons qu'avec une santé initiale positive.  Cela nous permet d'utiliser 0 comme santé initiale, ce qui rend impossible la perte.  Il nous sera donc pratique de tester les scripts. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (playerHealth &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; startingPlayerHealth &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Defeat!"</span></span>); BeginNewGame(); } activeScenario.Progress();</code> </pre> <br><h3>  Victoire </h3><br>  Une alternative à la défaite est la victoire, qui est obtenue à la fin du scénario, si le joueur est toujours en vie.  Autrement dit, lorsque le résultat de <code>GameScenario.Progess</code> est <code>false</code> , nous <code>GameScenario.Progess</code> un message de victoire dans le journal, commençons une nouvelle partie et passons immédiatement dessus. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (playerHealth &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Defeat!"</span></span>); BeginNewGame(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!activeScenario.Progress()) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Victory!"</span></span>); BeginNewGame(); activeScenario.Progress(); }</code> </pre> <br>  Cependant, la victoire interviendra après la fin de la dernière pause, même s'il reste des ennemis sur le terrain.  Nous devons reporter la victoire jusqu'à ce que tous les ennemis disparaissent, ce qui peut être réalisé en vérifiant si la collection d'ennemis est vide.  Nous supposons qu'il a la propriété <code>IsEmpty</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!activeScenario.Progress() &amp;&amp; enemies.IsEmpty) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Victory!"</span></span>); BeginNewGame(); activeScenario.Progress(); }</code> </pre> <br>  Ajoutez la propriété souhaitée à <code>GameBehaviorCollection</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsEmpty =&gt; behaviors.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><h3>  Contrôle du temps </h3><br>  Implémentons également la fonction de gestion du temps, cela vous aidera dans les tests et est souvent une fonction de gameplay.  Pour commencer, laissez <code>Game.Update</code> rechercher une barre d'espace et utilisez cet événement pour activer / désactiver les pauses dans le jeu.  Cela peut être fait en commutant les valeurs <code>Time.timeScale</code> entre zéro et un.  Cela ne changera pas la logique du jeu, mais fera geler tous les objets en place.  Ou vous pouvez utiliser une très petite valeur au lieu de 0, par exemple 0,01, pour créer un mouvement extrêmement lent. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> pausedTimeScale = <span class="hljs-number"><span class="hljs-number">0f</span></span>; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.Space)) { Time.timeScale = Time.timeScale &gt; pausedTimeScale ? pausedTimeScale : <span class="hljs-number"><span class="hljs-number">1f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.B)) { BeginNewGame(); } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deuxièmement, nous ajouterons </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la vitesse du jeu </font><font style="vertical-align: inherit;">au </font><font style="vertical-align: inherit;">curseur pour accélérer le temps.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(1f, 10f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> playSpeed = <span class="hljs-number"><span class="hljs-number">1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5d/641/4e9/b5d6414e9cd53d7ac89c5c1b3699b806.png" width="320" height="38"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vitesse de jeu. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la pause n'est pas activée et que la valeur de pause n'est pas affectée à l'échelle de temps, nous la rendons égale à la vitesse du jeu. </font><font style="vertical-align: inherit;">De plus, lors de la suppression d'une pause, nous utilisons la vitesse du jeu au lieu de l'unité.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.Space)) { Time.timeScale = Time.timeScale &gt; pausedTimeScale ? pausedTimeScale : playSpeed; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Time.timeScale &gt; pausedTimeScale) { Time.timeScale = playSpeed; }</code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Scénarios de boucle </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans certains scénarios, il peut être nécessaire de parcourir toutes les vagues plusieurs fois. </font><font style="vertical-align: inherit;">Il est possible d'implémenter la prise en charge d'une telle fonction en permettant de répéter les scénarios en bouclant plusieurs fois toutes les vagues. </font><font style="vertical-align: inherit;">Vous pouvez encore améliorer cette fonction, par exemple, en incluant la possibilité de répéter uniquement la dernière vague, mais dans ce tutoriel, nous allons simplement répéter tout le script.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Avancement cyclique sur les vagues </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez au </font></font><code>GameScenario</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">curseur de configuration pour définir le nombre de cycles, par défaut, affectez-lui une valeur de 1. Au minimum, faites zéro et le script se répétera sans fin. </font><font style="vertical-align: inherit;">Nous allons donc créer un scénario de survie qui ne peut pas être vaincu, et le but est de vérifier combien le joueur peut tenir.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(0, 10)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cycles = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0c/5d0/9df/d0c5d09dfd50e0e088c1848aaa32d531.png" width="320" height="38"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scénario à deux cycles. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, il </font></font><code>GameScenario.State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devrait suivre le numéro de cycle.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cycle, index; EnemyWave.State wave; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameScenario scenario</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scenario = scenario; cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; index = <span class="hljs-number"><span class="hljs-number">0</span></span>; wave = scenario.waves[<span class="hljs-number"><span class="hljs-number">0</span></span>].Begin(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans </font></font><code>Progress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous exécuterons après l'achèvement de l'incrément du cycle, et </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne </font><font style="vertical-align: inherit;">reviendrons </font><font style="vertical-align: inherit;">que si un nombre suffisant de cycles s'est écoulé. </font><font style="vertical-align: inherit;">Sinon, nous remettons à zéro l'index des vagues et continuons de bouger.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> deltaTime = wave.Progress(Time.deltaTime); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (deltaTime &gt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++index &gt;= scenario.waves.Length) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++cycle &gt;= scenario.cycles &amp;&amp; scenario.cycles &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } index = <span class="hljs-number"><span class="hljs-number">0</span></span>; } wave = scenario.waves[index].Begin(); deltaTime = wave.Progress(deltaTime); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Accélération </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si le joueur a réussi à vaincre le cycle une fois, il pourra le vaincre à nouveau sans aucun problème. Pour garder le scénario complexe, nous devons augmenter la complexité. La façon la plus simple de le faire, en réduisant dans les cycles suivants toutes les pauses entre la création d'ennemis. Ensuite, les ennemis apparaîtront plus rapidement et vaincront inévitablement le joueur dans le scénario de survie. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez un </font></font><code>GameScenario</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">curseur de configuration pour contrôler l'accélération par cycle. Cette valeur est ajoutée à l'échelle de temps après chaque cycle uniquement pour réduire les pauses. Par exemple, avec une accélération de 0,5, le premier cycle a une vitesse de pause de × 1, le deuxième cycle a une vitesse de × 1,5, le troisième × 2, le quatrième × 2,5, etc.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cycleSpeedUp = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous devez maintenant ajouter l'échelle de temps et </font></font><code>GameScenario.State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Elle est toujours initialement égale à 1 et augmente d'une valeur donnée d'accélération après chaque cycle. </font><font style="vertical-align: inherit;">Utilisez-le à l'échelle </font></font><code>Time.deltaTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avant de vous déplacer le long de la vague.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> timeScale; EnemyWave.State wave; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameScenario scenario</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scenario = scenario; cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; index = <span class="hljs-number"><span class="hljs-number">0</span></span>; timeScale = <span class="hljs-number"><span class="hljs-number">1f</span></span>; wave = scenario.waves[<span class="hljs-number"><span class="hljs-number">0</span></span>].Begin(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> deltaTime = wave.Progress(timeScale * Time.deltaTime); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (deltaTime &gt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++index &gt;= scenario.waves.Length) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++cycle &gt;= scenario.cycles &amp;&amp; scenario.cycles &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } index = <span class="hljs-number"><span class="hljs-number">0</span></span>; timeScale += scenario.cycleSpeedUp; } wave = scenario.waves[index].Begin(); deltaTime = wave.Progress(deltaTime); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qv/-d/3s/qv-d3srpikyuiorxx9vjk06wir8.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trois cycles avec une vitesse de création ennemie croissante; </font><font style="vertical-align: inherit;">accéléré dix fois. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Souhaitez-vous recevoir des informations sur la sortie de nouveaux tutoriels? </font><font style="vertical-align: inherit;">Suivez ma page sur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patreon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Article PDF du </font></a></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">référentiel</font></font></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr466855/">https://habr.com/ru/post/fr466855/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr466839/index.html">L'histoire de la création de Norton Commander. Partie 1/3</a></li>
<li><a href="../fr466841/index.html">Pourquoi un coussin chauffant, s'il y a un ordinateur portable: l'étude de la résistance thermique au niveau atomique</a></li>
<li><a href="../fr466845/index.html">Interview inversée: quelles questions poser à l'entreprise?</a></li>
<li><a href="../fr466849/index.html">noexcept-ctcheck ou quelques macros simples pour aider le compilateur à écrire du code noexcept</a></li>
<li><a href="../fr466851/index.html">Ligne Agilex - FPGA Intel 10 nm</a></li>
<li><a href="../fr466857/index.html">Exécution d'application en arrière-plan dans iOS 13</a></li>
<li><a href="../fr466859/index.html">Utilisation du service AD ​​Federation pour autoriser les utilisateurs AWS avec une distribution de droits</a></li>
<li><a href="../fr466861/index.html">Comment échapper à la réalité en utilisant un hackathon</a></li>
<li><a href="../fr466863/index.html">Configuration d'Asymptote</a></li>
<li><a href="../fr466865/index.html">En attendant le 1er novembre: interdiction ou légalisation des crypto-monnaies</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>