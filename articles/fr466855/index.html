<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§üüèΩ üê£ üîì Cr√©ation de Tower Defense dans Unity: sc√©narios et vagues d'ennemis üç¨ üë©‚Äçüëß üò©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[ Les premi√®re , deuxi√®me , troisi√®me et quatri√®me parties du didacticiel] 



- Prise en charge des ennemis de petites, moyennes et grandes tailles. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cr√©ation de Tower Defense dans Unity: sc√©narios et vagues d'ennemis</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466855/">  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les premi√®re</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deuxi√®me</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">troisi√®me</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">quatri√®me</a> parties du didacticiel] <br><br><ul><li>  Prise en charge des ennemis de petites, moyennes et grandes tailles. </li><li>  Cr√©ez des sc√©narios de jeu avec plusieurs vagues d'ennemis. </li><li>  S√©paration de la configuration des actifs et de l'√©tat du gameplay. </li><li>  Commencez, arr√™tez, gagnez, battez et acc√©l√©rez le jeu. </li><li>  Cr√©ez des sc√©narios r√©p√©titifs sans fin. </li></ul><br>  Ceci est la cinqui√®me partie d'une s√©rie de tutoriels sur la cr√©ation d'un jeu de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tower defense</a> simple.  Dans ce document, nous apprendrons √† cr√©er des sc√©narios de gameplay qui g√©n√®rent des vagues de divers ennemis. <br><br>  Le didacticiel a √©t√© cr√©√© dans Unity 2018.4.6f1. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b12/6aa/945/b126aa94582cc44651853c3ee69be82b.jpg" width="512" height="256"></div><br>  <i>√áa devient assez confortable.</i> <br><a name="habracut"></a><br><h2>  Plus d'ennemis </h2><br>  Ce n'est pas tr√®s int√©ressant de cr√©er le m√™me cube bleu √† chaque fois.  La premi√®re √©tape pour prendre en charge des sc√©narios de jeu plus int√©ressants sera de prendre en charge plusieurs types d'ennemis. <br><br><h3>  Configurations ennemies </h3><br>  Il existe de nombreuses fa√ßons de rendre les ennemis uniques, mais nous ne compliquerons pas: nous les classons comme petits, moyens et grands.  Pour les √©tiqueter, cr√©ez une √©num√©ration <code>EnemyType</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> EnemyType { Small, Medium, Large }</code> </pre> <br>  Changez <code>EnemyFactory</code> pour qu'il <code>EnemyFactory</code> en charge les trois types d'ennemis au lieu d'un.  Pour les trois ennemis, les m√™mes champs de configuration sont n√©cessaires, nous ajoutons donc une classe <code>EnemyConfig</code> imbriqu√©e les contenant tous, puis ajoutons trois champs de configuration de ce type √† l'usine.  √âtant donn√© que cette classe est utilis√©e uniquement pour la configuration et que nous ne l'utiliserons nulle part ailleurs, vous pouvez simplement rendre ses champs publics afin que l'usine puisse y acc√©der.  <code>EnemyConfig</code> lui <code>EnemyConfig</code> m√™me <code>EnemyConfig</code> pas tenu d'√™tre public. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemyFactory</span></span> : <span class="hljs-title"><span class="hljs-title">GameObjectFactory</span></span> { [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemyConfig</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Enemy prefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; [FloatRangeSlider(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">2f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FloatRange scale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">1f</span></span>); [FloatRangeSlider(<span class="hljs-number"><span class="hljs-number">0.2f</span></span>, <span class="hljs-number"><span class="hljs-number">5f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FloatRange speed = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">1f</span></span>); [FloatRangeSlider(<span class="hljs-number"><span class="hljs-number">-0.4f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FloatRange pathOffset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">0f</span></span>); } [SerializeField] EnemyConfig small = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, medium = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, large = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; ‚Ä¶ }</code> </pre> <br>  Rendons √©galement la sant√© personnalisable pour chaque ennemi, car il est logique que les grands ennemis en aient plus que les petits. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">FloatRangeSlider(10f, 1000f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FloatRange health = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">100f</span></span>);</code> </pre> <br>  Ajoutez un param√®tre de type √† <code>Get</code> pour obtenir un type d'ennemi sp√©cifique, et le type par d√©faut sera moyen.  Nous allons utiliser le type pour obtenir la configuration correcte, pour laquelle une m√©thode distincte est utile, puis cr√©er et initialiser l'ennemi comme auparavant, uniquement avec l'argument sant√© ajout√©. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">EnemyConfig </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetConfig</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemyType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EnemyType.Small: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> small; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EnemyType.Medium: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> medium; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EnemyType.Large: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> large; } Debug.Assert(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"Unsupported enemy type!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Enemy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemyType type = EnemyType.Medium</span></span></span><span class="hljs-function">)</span></span> { EnemyConfig config = GetConfig(type); Enemy instance = CreateGameObjectInstance(config.prefab); instance.OriginFactory = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; instance.Initialize( config.scale.RandomValueInRange, config.speed.RandomValueInRange, config.pathOffset.RandomValueInRange, config.health.RandomValueInRange ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; }</code> </pre> <br>  Ajoutez le param√®tre de sant√© requis √† <code>Enemy.Initialize</code> et utilisez-le pour d√©finir la sant√© au lieu de la d√©terminer par la taille de l'ennemi. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathOffset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> health </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Health = health; }</code> </pre> <br><h3>  Nous cr√©ons le design de diff√©rents ennemis </h3><br>  Vous pouvez choisir quelle sera la conception des trois ennemis, mais dans le tutoriel, je m'efforcerai de simplifier au maximum.  J'ai dupliqu√© le pr√©fabriqu√© d'origine de l'ennemi et l'ai utilis√© pour les trois tailles, en changeant uniquement le mat√©riau: jaune pour petit, bleu pour moyen et rouge pour grand.  Je n'ai pas chang√© l'√©chelle du cube pr√©fabriqu√©, mais j'ai utilis√© la configuration d'√©chelle d'usine pour d√©finir les dimensions.  De plus, selon la taille, j'ai augment√© leur sant√© et r√©duit leur vitesse. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd7/070/231/bd707023151022e921c5b6956bb20c02.png" width="320" height="348"></div><br>  <i>Usine de cubes ennemis de trois tailles.</i> <br><br>  Le moyen le plus rapide consiste √† faire appara√Ætre les trois types dans le jeu en changeant <code>Game.SpawnEnemy</code> afin qu'il obtienne un type d'ennemi al√©atoire au lieu de l'ennemi du milieu. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnEnemy</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile spawnPoint = board.GetSpawnPoint(Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, board.SpawnPointCount)); Enemy enemy = enemyFactory.Get((EnemyType)(Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>))); enemy.SpawnOn(spawnPoint); enemies.Add(enemy); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/537/73b/b92/53773bb9299a8ec9c56b485718049e5b.png" width="230" height="230"></div><br>  <i>Ennemis de diff√©rents types.</i> <br><br><h3>  Plusieurs usines </h3><br>  Maintenant, l'usine d'ennemis d√©finit un grand nombre de trois ennemis.  L'usine existante cr√©e des cubes de trois tailles, mais rien ne nous emp√™che de faire une autre usine qui cr√©e autre chose, par exemple des sph√®res de trois tailles.  Nous pouvons changer les ennemis cr√©√©s en nommant une autre usine dans le jeu, passant ainsi √† un sujet diff√©rent. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65f/7e5/330/65f7e5330945ea654f1caef579fe567f.png" width="230" height="230"></div><br>  <i>Ennemis sph√©riques.</i> <br><br><h2>  Vagues d'ennemis </h2><br>  La deuxi√®me √©tape de la cr√©ation de sc√©narios de gameplay sera le rejet des ennemis qui se reproduisent avec une fr√©quence constante.  Les ennemis doivent √™tre cr√©√©s par vagues successives jusqu'√† la fin du script ou la perte du joueur. <br><br><h3>  S√©quences de cr√©ation </h3><br>  Une vague d'ennemis se compose d'un groupe d'ennemis cr√©√©s l'un apr√®s l'autre jusqu'√† ce que la vague soit termin√©e.  Une vague peut contenir diff√©rents types d'ennemis et le d√©lai entre leur cr√©ation peut varier.  Afin de ne pas compliquer l'impl√©mentation, nous commencerons par une simple s√©quence d'apparition qui cr√©e le m√™me type d'ennemis avec une fr√©quence constante.  Ensuite, l'onde ne sera qu'une liste de ces s√©quences. <br><br>  Pour configurer chaque s√©quence, cr√©ez une classe <code>EnemySpawnSequence</code> .  Comme c'est assez compliqu√©, mettez-le dans un fichier s√©par√©.  La s√©quence doit savoir quelle usine utiliser, quel type d'ennemi cr√©er, leur nombre et leur fr√©quence.  Pour simplifier la configuration, nous allons faire du dernier param√®tre une pause, qui d√©termine le temps qui doit s'√©couler avant de cr√©er l'ennemi suivant.  Notez que cette approche vous permet d'utiliser plusieurs usines ennemies dans la vague. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemySpawnSequence</span></span> { [SerializeField] EnemyFactory factory = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; [SerializeField] EnemyType type = EnemyType.Medium; [SerializeField, Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> amount = <span class="hljs-number"><span class="hljs-number">1</span></span>; [SerializeField, Range(<span class="hljs-number"><span class="hljs-number">0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">10f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cooldown = <span class="hljs-number"><span class="hljs-number">1f</span></span>; }</code> </pre> <br><h3>  Les vagues </h3><br>  Une vague est un simple tableau de s√©quences de cr√©ation ennemies.  Cr√©ez pour lui un type d' <code>EnemyWave</code> EnemyWave qui commence par une s√©quence standard. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [CreateAssetMenu] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemyWave</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { [SerializeField] EnemySpawnSequence[] spawnSequences = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EnemySpawnSequence() }; }</code> </pre> <br>  Maintenant, nous pouvons cr√©er des vagues d'ennemis.  Par exemple, j'ai cr√©√© une vague qui g√©n√®re un groupe d'ennemis cubiques, en commen√ßant par dix petits, avec une fr√©quence de deux par seconde.  Ils sont suivis de cinq moyennes, cr√©√©es une fois par seconde, et, enfin, d'un gros ennemi avec une pause de cinq secondes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b16/af3/47f/b16af347f057760db35703515642db89.png" width="320" height="376"></div><br>  <i>Une vague de cubes croissants.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Puis-je ajouter un d√©lai entre les s√©quences?</b> <div class="spoiler_text">  Vous pouvez l'impl√©menter indirectement.  Par exemple, ins√©rez un d√©lai de quatre secondes entre les petits et les cubes moyens, r√©duisez le nombre de petits cubes d'un et ins√©rez une s√©quence d'un petit cube avec une pause de quatre secondes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/59b/ff4/3f9/59bff43f9a71002c0bd562f270b755ea.png" width="320" height="272"></div><br>  <i>D√©lai de quatre secondes entre les cubes petits et moyens.</i> </div></div><br><h3>  Sc√©narios </h3><br>  Le sc√©nario de gameplay est cr√©√© √† partir d'une s√©quence de vagues.  Pour cela, cr√©ez un <code>GameScenario</code> actif <code>GameScenario</code> avec un seul tableau de vagues, puis utilisez-le pour cr√©er le sc√©nario. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [CreateAssetMenu] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameScenario</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { [SerializeField] EnemyWave[] waves = {}; }</code> </pre> <br>  Par exemple, j'ai cr√©√© un sc√©nario avec deux vagues d'ennemis petits-moyens-grands (MSC), d'abord avec des cubes, puis avec des sph√®res. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/796/df0/73b/796df073b24d092d35093b6e56b8be79.png" width="320" height="142"></div><br>  <i>Sc√©nario avec deux vagues de MSC.</i> <br><br><h3>  Mouvement s√©quentiel </h3><br>  Les types d'actifs sont utilis√©s pour cr√©er des scripts, mais comme il s'agit d'actifs, ils doivent contenir des donn√©es qui ne changent pas pendant le jeu.  Cependant, pour faire avancer le sc√©nario, nous devons en quelque sorte suivre leur statut.  Une fa√ßon consiste √† dupliquer l'actif utilis√© dans le jeu afin que le doublon suive son √©tat.  Mais nous n'avons pas besoin de dupliquer l'ensemble de l'actif, il suffit de pr√©ciser et les liens vers l'actif suffisent.  <code>EnemySpawnSequence</code> donc une classe d' <code>State</code> distincte, d'abord pour <code>EnemySpawnSequence</code> .  Puisqu'il ne s'applique qu'√† une s√©quence, nous le faisons imbriqu√©.  Elle n'est valide que lorsqu'elle a une r√©f√©rence √† une s√©quence, nous allons donc lui donner une m√©thode constructeur avec un param√®tre de s√©quence. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/18c/752/4fd/18c7524fdac87c062a6c683bbdee1866.png" width="315" height="50"></div><br>  <i>Un type d'√©tat imbriqu√© qui fait r√©f√©rence √† sa s√©quence.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemySpawnSequence</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">State</span></span> { EnemySpawnSequence sequence; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemySpawnSequence sequence</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sequence = sequence; } } }</code> </pre> <br>  Lorsque nous voulons commencer √† avancer dans une s√©quence, nous avons besoin d'une nouvelle instance de l'√©tat pour cela.  Ajoutez des s√©quences √† la m√©thode <code>Begin</code> , qui construit et renvoie l'√©tat.  Gr√¢ce √† cela, tous ceux qui appellent <code>Begin</code> seront responsables de faire correspondre l'√©tat, et la s√©quence elle-m√™me restera apatride.  Il sera m√™me possible d'avancer en parall√®le plusieurs fois dans la m√™me s√©quence. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemySpawnSequence</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Begin</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> State(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">State</span></span> { ‚Ä¶ } }</code> </pre> <br>  Pour que l'√âtat survive apr√®s des red√©marrages √† chaud, vous devez le rendre s√©rialisable. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">System.Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">State</span></span> { ‚Ä¶ }</code> </pre> <br>  L'inconv√©nient de cette approche est que chaque fois que nous ex√©cutons une s√©quence, nous devons cr√©er un nouvel objet d'√©tat.  Nous pouvons √©viter l'allocation de m√©moire en en faisant une structure au lieu d'une classe.  C'est normal tant que la condition reste petite.  Gardez juste √† l'esprit que l'√©tat est un type de valeur.  Lorsqu'il est transf√©r√©, il est copi√©, alors suivez-le au m√™me endroit. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">System.Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> State { ‚Ä¶ }</code> </pre> <br>  L'√©tat de la s√©quence ne comprend que deux aspects: le nombre d'ennemis g√©n√©r√©s et la progression du temps de pause.  Nous ajoutons la m√©thode <code>Progress</code> , qui augmente la valeur de la pause du delta temporel, puis la r√©initialise lorsque la valeur configur√©e est atteinte, similaire √† ce qui se passe avec le temps de g√©n√©ration dans <code>Game.Update</code> .  Nous augmenterons le nombre d'ennemis chaque fois que cela se produira.  De plus, la valeur de pause doit commencer par la valeur maximale afin que la s√©quence cr√©e des ennemis sans pause au d√©but. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cooldown; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemySpawnSequence sequence</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sequence = sequence; count = <span class="hljs-number"><span class="hljs-number">0</span></span>; cooldown = sequence.cooldown; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { cooldown += Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cooldown &gt;= sequence.cooldown) { cooldown -= sequence.cooldown; count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50c/aba/5e5/50caba5e50d89e05a6cb9a631feb1c6d.png" width="315" height="74"></div><br>  <i>L'√©tat ne contient que les donn√©es n√©cessaires.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Puis-je acc√©der √† EnemySpawnSequence.cooldown depuis State?</b> <div class="spoiler_text">  Oui, car l' <code>State</code> est d√©fini dans la m√™me port√©e.  Par cons√©quent, les types imbriqu√©s connaissent les membres priv√©s des types qui les contiennent. </div></div><br>  La progression doit se poursuivre jusqu'√† ce que le nombre d'ennemis souhait√© soit cr√©√© et que la pause se termine.  √Ä ce stade, <code>Progress</code> devrait signaler l'ach√®vement, mais il est fort probable que nous surpassions un peu la valeur.  Par cons√©quent, √† ce moment, nous devons retourner le temps suppl√©mentaire afin de l'utiliser dans l'avancement dans la s√©quence suivante.  Pour que cela fonctionne, vous devez transformer le delta temporel en param√®tre.  Nous devons √©galement indiquer que nous n'avons pas encore termin√©, et cela peut √™tre r√©alis√© en renvoyant une valeur n√©gative. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> deltaTime</span></span></span><span class="hljs-function">)</span></span> { cooldown += deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cooldown &gt;= sequence.cooldown) { cooldown -= sequence.cooldown; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt;= sequence.amount) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cooldown; } count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1f</span></span>; }</code> </pre> <br><h3>  Cr√©ez des ennemis n'importe o√π </h3><br>  Pour que les s√©quences engendrent des ennemis, nous devons convertir <code>Game.SpawnEnemy</code> en une autre m√©thode statique publique. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnEnemy</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemyFactory factory, EnemyType type</span></span></span><span class="hljs-function">)</span></span> { GameTile spawnPoint = instance.board.GetSpawnPoint( Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, instance.board.SpawnPointCount) ); Enemy enemy = factory.Get(type); enemy.SpawnOn(spawnPoint); instance.enemies.Add(enemy); }</code> </pre> <br>  Puisque le <code>Game</code> lui-m√™me ne g√©n√©rera plus d'ennemis, nous pouvons supprimer l'usine ennemie, la vitesse de cr√©ation, le processus de promotion de la cr√©ation et le code de cr√©ation ennemi de <code>Update</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { }</code> </pre> <br>  Nous appellerons <code>Game.SpawnEnemy</code> dans <code>EnemySpawnSequence.State.Progress</code> apr√®s avoir augment√© le nombre d'ennemis. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> deltaTime</span></span></span><span class="hljs-function">)</span></span> { cooldown += deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cooldown &gt;= sequence.cooldown) { ‚Ä¶ count += <span class="hljs-number"><span class="hljs-number">1</span></span>; Game.SpawnEnemy(sequence.factory, sequence.type); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1f</span></span>; }</code> </pre> <br><h3>  Avancement des vagues </h3><br>  Prenons la m√™me approche pour se d√©placer le long d'une s√©quence que pour se d√©placer le long d'une vague enti√®re.  Donnons √† <code>EnemyWave</code> sa propre m√©thode <code>Begin</code> , qui renvoie une nouvelle instance de la structure <code>State</code> imbriqu√©e.  Dans ce cas, l'√©tat contient l'indice d'onde et l'√©tat de la s√©quence active, que nous initialisons au d√©but de la premi√®re s√©quence. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9eb/9f8/bc7/9eb9f8bc7769dd0c65624802ac2a97b8.png" width="315" height="128"></div><br>  <i>Un √©tat d'onde contenant l'√©tat d'une s√©quence.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemyWave</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { [SerializeField] EnemySpawnSequence[] spawnSequences = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EnemySpawnSequence() }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Begin</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> State(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> State { EnemyWave wave; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index; EnemySpawnSequence.State sequence; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemyWave wave</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wave = wave; index = <span class="hljs-number"><span class="hljs-number">0</span></span>; Debug.Assert(wave.spawnSequences.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Empty wave!"</span></span>); sequence = wave.spawnSequences[<span class="hljs-number"><span class="hljs-number">0</span></span>].Begin(); } } }</code> </pre> <br>  Nous ajoutons √©galement la m√©thode <code>EnemyWave.State</code> <code>Progress</code> , qui utilise la m√™me approche que pr√©c√©demment, avec des modifications mineures.  Nous commen√ßons par nous d√©placer le long de la s√©quence active et rempla√ßons le delta temporel par le r√©sultat de cet appel.  Tant qu'il reste du temps, nous passons √† la s√©quence suivante, si elle est accessible, et nous progressons.  S'il n'y a plus de s√©quence, nous renvoyons le temps restant;  sinon, retournez une valeur n√©gative. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> deltaTime</span></span></span><span class="hljs-function">)</span></span> { deltaTime = sequence.Progress(deltaTime); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (deltaTime &gt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++index &gt;= wave.spawnSequences.Length) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> deltaTime; } sequence = wave.spawnSequences[index].Begin(); deltaTime = sequence.Progress(deltaTime); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1f</span></span>; }</code> </pre> <br><h3>  Promotion de script </h3><br>  Ajoutez <code>GameScenario</code> au m√™me traitement.  Dans ce cas, l'√©tat contient l'indice d'onde et l'√©tat de l'onde active. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameScenario</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { [SerializeField] EnemyWave[] waves = {}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Begin</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> State(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> State { GameScenario scenario; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index; EnemyWave.State wave; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameScenario scenario</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scenario = scenario; index = <span class="hljs-number"><span class="hljs-number">0</span></span>; Debug.Assert(scenario.waves.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Empty scenario!"</span></span>); wave = scenario.waves[<span class="hljs-number"><span class="hljs-number">0</span></span>].Begin(); } } }</code> </pre> <br>  Puisque nous sommes au niveau sup√©rieur, la m√©thode <code>Progress</code> ne n√©cessite pas de param√®tre et vous pouvez utiliser directement <code>Time.deltaTime</code> .  Nous n'avons pas besoin de renvoyer le temps restant, mais nous devons montrer si le script est termin√©.  Nous retournerons <code>false</code> apr√®s la fin de la derni√®re vague et <code>true</code> pour montrer que le script est toujours actif. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> deltaTime = wave.Progress(Time.deltaTime); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (deltaTime &gt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++index &gt;= scenario.waves.Length) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } wave = scenario.waves[index].Begin(); deltaTime = wave.Progress(deltaTime); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3>  Ex√©cution de script </h3><br>  Pour jouer √† un script de <code>Game</code> , vous avez besoin d'un champ de configuration de script et d'un suivi de son √©tat.  Nous allons simplement ex√©cuter le script dans Awake et ex√©cuter <code>Update</code> sur celui-ci jusqu'√† ce que le statut du reste du jeu soit mis √† jour. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameScenario scenario = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; GameScenario.State activeScenario; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { board.Initialize(boardSize, tileContentFactory); board.ShowGrid = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; activeScenario = scenario.Begin(); } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ activeScenario.Progress(); enemies.GameUpdate(); Physics.SyncTransforms(); board.GameUpdate(); nonEnemies.GameUpdate(); }</code> </pre> <br>  Maintenant, le script configur√© sera lanc√© au d√©but du jeu.  La promotion sera effectu√©e jusqu'√† son ach√®vement, et apr√®s quoi rien ne se passera. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mk/x0/uf/mkx0ufxshpgvy29wjr_nxdmneu4.gif"></div><br>  <i>Deux vagues ont acc√©l√©r√© 10 fois.</i> <br><br><h2>  D√©marrer et terminer les jeux </h2><br>  Nous pouvons reproduire un sc√©nario, mais apr√®s son ach√®vement, de nouveaux ennemis n'appara√Ætront pas.  Pour que le jeu continue, nous devons permettre de d√©marrer un nouveau sc√©nario, soit manuellement, soit parce que le joueur a perdu / gagn√©.  Vous pouvez √©galement impl√©menter un choix de plusieurs sc√©narios, mais dans ce tutoriel, nous ne le consid√©rerons pas. <br><br><h3>  Le d√©but d'un nouveau jeu </h3><br>  Id√©alement, nous devons avoir la possibilit√© de commencer un nouveau jeu √† tout moment.  Pour ce faire, vous devez r√©initialiser l'√©tat actuel de l'ensemble du jeu, c'est-√†-dire que nous devrons r√©initialiser de nombreux objets.  Tout d'abord, ajoutez une m√©thode <code>Clear</code> √† la <code>GameBehaviorCollection</code> qui utilise tous ses comportements. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; behaviors.Count; i++) { behaviors[i].Recycle(); } behaviors.Clear(); }</code> </pre> <br>  Cela sugg√®re que tous les comportements peuvent √™tre √©limin√©s, mais jusqu'√† pr√©sent ce n'est pas le cas.  Pour que cela fonctionne, ajoutez <code>GameBehavior</code> m√©thode de <code>Recycle</code> abstraite √† <code>GameBehavior</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Recycle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>;</code> </pre> <br>  La m√©thode <code>Recycle</code> de la classe <code>WarEntity</code> doit la remplacer explicitement. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Recycle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { originFactory.Reclaim(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  <code>Enemy</code> n'a pas encore de m√©thode de <code>Recycle</code> , alors ajoutez-le.  Tout ce qu'il a √† faire est de forcer l'usine √† la retourner.  Ensuite, nous appelons <code>Recycle</code> partout o√π nous acc√©dons directement √† l'usine. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Health &lt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { Recycle(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } progress += Time.deltaTime * progressFactor; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (progress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tileTo == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Recycle(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } ‚Ä¶ } ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Recycle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { OriginFactory.Reclaim(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  <code>GameBoard</code> doit √©galement √™tre r√©initialis√©, nous allons donc lui donner la m√©thode <code>Clear</code> , qui vide toutes les tuiles, r√©initialise tous les points de cr√©ation et met √† jour le contenu, puis d√©finit les points de d√©but et de fin standard.  Ensuite, au lieu de r√©p√©ter le code, nous pouvons appeler <code>Clear</code> √† la fin de <code>Initialize</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector2Int size, GameTileContentFactory contentFactory </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { ‚Ä¶ } } Clear(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.Content = contentFactory.Get(GameTileContentType.Empty); } spawnPoints.Clear(); updatingContent.Clear(); ToggleDestination(tiles[tiles.Length / <span class="hljs-number"><span class="hljs-number">2</span></span>]); ToggleSpawnPoint(tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }</code> </pre> <br>  Nous pouvons maintenant ajouter la m√©thode <code>BeginNewGame</code> au <code>Game</code> , en <code>BeginNewGame</code> les ennemis, d'autres objets et le champ, puis en d√©marrant un nouveau script. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginNewGame</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { enemies.Clear(); nonEnemies.Clear(); board.Clear(); activeScenario = scenario.Begin(); }</code> </pre> <br>  Nous appellerons cette m√©thode dans <code>Update</code> si vous appuyez sur B avant de passer au script. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.B)) { BeginNewGame(); } activeScenario.Progress(); ‚Ä¶ }</code> </pre> <br><h3>  Perdre </h3><br>  Le but du jeu est de vaincre tous les ennemis avant qu'un certain nombre d'entre eux n'atteignent le point final.  Le nombre d'ennemis n√©cessaires pour d√©clencher la condition de d√©faite d√©pend de la sant√© initiale du joueur, pour laquelle nous ajouterons un champ de configuration au <code>Game</code> .  Puisque nous comptons les ennemis, nous utiliserons un entier, pas un flottant. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(0, 100)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startingPlayerHealth = <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f3/9c5/11a/4f39c511ab9d362b1cc7e55610a317aa.png" width="320" height="38"></div><br>  <i>Initialement, un joueur a 10 points de vie.</i> <br><br>  Dans le cas de Awake ou du d√©but d'une nouvelle partie, nous attribuons la valeur initiale √† la sant√© actuelle du joueur. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> playerHealth; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { playerHealth = startingPlayerHealth; ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginNewGame</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { playerHealth = startingPlayerHealth; ‚Ä¶ }</code> </pre> <br>  Ajoutez une m√©thode <code>EnemyReachedDestination</code> statique publique <code>EnemyReachedDestination</code> que les ennemis puissent dire √† <code>Game</code> qu'ils ont atteint le point final.  Dans ce cas, r√©duisez la sant√© du joueur. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnemyReachedDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { instance.playerHealth -= <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Appelez cette m√©thode dans <code>Enemy.GameUpdate</code> au moment appropri√©. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tileTo == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Game.EnemyReachedDestination(); Recycle(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Nous pouvons maintenant v√©rifier l'√©tat de la d√©faite dans <code>Game.Update</code> .  Si la sant√© du joueur est √©gale ou inf√©rieure √† z√©ro, la condition de d√©faite est d√©clench√©e.  Nous enregistrons simplement ces informations et commen√ßons imm√©diatement une nouvelle partie avant d'avancer.  Mais nous ne le ferons qu'avec une sant√© initiale positive.  Cela nous permet d'utiliser 0 comme sant√© initiale, ce qui rend impossible la perte.  Il nous sera donc pratique de tester les scripts. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (playerHealth &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; startingPlayerHealth &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Defeat!"</span></span>); BeginNewGame(); } activeScenario.Progress();</code> </pre> <br><h3>  Victoire </h3><br>  Une alternative √† la d√©faite est la victoire, qui est obtenue √† la fin du sc√©nario, si le joueur est toujours en vie.  Autrement dit, lorsque le r√©sultat de <code>GameScenario.Progess</code> est <code>false</code> , nous <code>GameScenario.Progess</code> un message de victoire dans le journal, commen√ßons une nouvelle partie et passons imm√©diatement dessus. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (playerHealth &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Defeat!"</span></span>); BeginNewGame(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!activeScenario.Progress()) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Victory!"</span></span>); BeginNewGame(); activeScenario.Progress(); }</code> </pre> <br>  Cependant, la victoire interviendra apr√®s la fin de la derni√®re pause, m√™me s'il reste des ennemis sur le terrain.  Nous devons reporter la victoire jusqu'√† ce que tous les ennemis disparaissent, ce qui peut √™tre r√©alis√© en v√©rifiant si la collection d'ennemis est vide.  Nous supposons qu'il a la propri√©t√© <code>IsEmpty</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!activeScenario.Progress() &amp;&amp; enemies.IsEmpty) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Victory!"</span></span>); BeginNewGame(); activeScenario.Progress(); }</code> </pre> <br>  Ajoutez la propri√©t√© souhait√©e √† <code>GameBehaviorCollection</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsEmpty =&gt; behaviors.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><h3>  Contr√¥le du temps </h3><br>  Impl√©mentons √©galement la fonction de gestion du temps, cela vous aidera dans les tests et est souvent une fonction de gameplay.  Pour commencer, laissez <code>Game.Update</code> rechercher une barre d'espace et utilisez cet √©v√©nement pour activer / d√©sactiver les pauses dans le jeu.  Cela peut √™tre fait en commutant les valeurs <code>Time.timeScale</code> entre z√©ro et un.  Cela ne changera pas la logique du jeu, mais fera geler tous les objets en place.  Ou vous pouvez utiliser une tr√®s petite valeur au lieu de 0, par exemple 0,01, pour cr√©er un mouvement extr√™mement lent. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> pausedTimeScale = <span class="hljs-number"><span class="hljs-number">0f</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.Space)) { Time.timeScale = Time.timeScale &gt; pausedTimeScale ? pausedTimeScale : <span class="hljs-number"><span class="hljs-number">1f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.B)) { BeginNewGame(); } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deuxi√®mement, nous ajouterons </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la vitesse du jeu </font><font style="vertical-align: inherit;">au </font><font style="vertical-align: inherit;">curseur pour acc√©l√©rer le temps.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(1f, 10f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> playSpeed = <span class="hljs-number"><span class="hljs-number">1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5d/641/4e9/b5d6414e9cd53d7ac89c5c1b3699b806.png" width="320" height="38"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vitesse de jeu. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la pause n'est pas activ√©e et que la valeur de pause n'est pas affect√©e √† l'√©chelle de temps, nous la rendons √©gale √† la vitesse du jeu. </font><font style="vertical-align: inherit;">De plus, lors de la suppression d'une pause, nous utilisons la vitesse du jeu au lieu de l'unit√©.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.Space)) { Time.timeScale = Time.timeScale &gt; pausedTimeScale ? pausedTimeScale : playSpeed; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Time.timeScale &gt; pausedTimeScale) { Time.timeScale = playSpeed; }</code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sc√©narios de boucle </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans certains sc√©narios, il peut √™tre n√©cessaire de parcourir toutes les vagues plusieurs fois. </font><font style="vertical-align: inherit;">Il est possible d'impl√©menter la prise en charge d'une telle fonction en permettant de r√©p√©ter les sc√©narios en bouclant plusieurs fois toutes les vagues. </font><font style="vertical-align: inherit;">Vous pouvez encore am√©liorer cette fonction, par exemple, en incluant la possibilit√© de r√©p√©ter uniquement la derni√®re vague, mais dans ce tutoriel, nous allons simplement r√©p√©ter tout le script.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Avancement cyclique sur les vagues </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez au </font></font><code>GameScenario</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">curseur de configuration pour d√©finir le nombre de cycles, par d√©faut, affectez-lui une valeur de 1. Au minimum, faites z√©ro et le script se r√©p√©tera sans fin. </font><font style="vertical-align: inherit;">Nous allons donc cr√©er un sc√©nario de survie qui ne peut pas √™tre vaincu, et le but est de v√©rifier combien le joueur peut tenir.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(0, 10)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cycles = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0c/5d0/9df/d0c5d09dfd50e0e088c1848aaa32d531.png" width="320" height="38"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sc√©nario √† deux cycles. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, il </font></font><code>GameScenario.State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devrait suivre le num√©ro de cycle.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cycle, index; EnemyWave.State wave; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameScenario scenario</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scenario = scenario; cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; index = <span class="hljs-number"><span class="hljs-number">0</span></span>; wave = scenario.waves[<span class="hljs-number"><span class="hljs-number">0</span></span>].Begin(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans </font></font><code>Progress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous ex√©cuterons apr√®s l'ach√®vement de l'incr√©ment du cycle, et </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne </font><font style="vertical-align: inherit;">reviendrons </font><font style="vertical-align: inherit;">que si un nombre suffisant de cycles s'est √©coul√©. </font><font style="vertical-align: inherit;">Sinon, nous remettons √† z√©ro l'index des vagues et continuons de bouger.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> deltaTime = wave.Progress(Time.deltaTime); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (deltaTime &gt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++index &gt;= scenario.waves.Length) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++cycle &gt;= scenario.cycles &amp;&amp; scenario.cycles &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } index = <span class="hljs-number"><span class="hljs-number">0</span></span>; } wave = scenario.waves[index].Begin(); deltaTime = wave.Progress(deltaTime); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Acc√©l√©ration </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si le joueur a r√©ussi √† vaincre le cycle une fois, il pourra le vaincre √† nouveau sans aucun probl√®me. Pour garder le sc√©nario complexe, nous devons augmenter la complexit√©. La fa√ßon la plus simple de le faire, en r√©duisant dans les cycles suivants toutes les pauses entre la cr√©ation d'ennemis. Ensuite, les ennemis appara√Ætront plus rapidement et vaincront in√©vitablement le joueur dans le sc√©nario de survie. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez un </font></font><code>GameScenario</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">curseur de configuration pour contr√¥ler l'acc√©l√©ration par cycle. Cette valeur est ajout√©e √† l'√©chelle de temps apr√®s chaque cycle uniquement pour r√©duire les pauses. Par exemple, avec une acc√©l√©ration de 0,5, le premier cycle a une vitesse de pause de √ó 1, le deuxi√®me cycle a une vitesse de √ó 1,5, le troisi√®me √ó 2, le quatri√®me √ó 2,5, etc.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cycleSpeedUp = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous devez maintenant ajouter l'√©chelle de temps et </font></font><code>GameScenario.State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Elle est toujours initialement √©gale √† 1 et augmente d'une valeur donn√©e d'acc√©l√©ration apr√®s chaque cycle. </font><font style="vertical-align: inherit;">Utilisez-le √† l'√©chelle </font></font><code>Time.deltaTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avant de vous d√©placer le long de la vague.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> timeScale; EnemyWave.State wave; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameScenario scenario</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scenario = scenario; cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; index = <span class="hljs-number"><span class="hljs-number">0</span></span>; timeScale = <span class="hljs-number"><span class="hljs-number">1f</span></span>; wave = scenario.waves[<span class="hljs-number"><span class="hljs-number">0</span></span>].Begin(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> deltaTime = wave.Progress(timeScale * Time.deltaTime); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (deltaTime &gt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++index &gt;= scenario.waves.Length) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++cycle &gt;= scenario.cycles &amp;&amp; scenario.cycles &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } index = <span class="hljs-number"><span class="hljs-number">0</span></span>; timeScale += scenario.cycleSpeedUp; } wave = scenario.waves[index].Begin(); deltaTime = wave.Progress(deltaTime); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qv/-d/3s/qv-d3srpikyuiorxx9vjk06wir8.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trois cycles avec une vitesse de cr√©ation ennemie croissante; </font><font style="vertical-align: inherit;">acc√©l√©r√© dix fois. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Souhaitez-vous recevoir des informations sur la sortie de nouveaux tutoriels? </font><font style="vertical-align: inherit;">Suivez ma page sur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patreon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Article PDF du </font></a></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r√©f√©rentiel</font></font></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr466855/">https://habr.com/ru/post/fr466855/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr466839/index.html">L'histoire de la cr√©ation de Norton Commander. Partie 1/3</a></li>
<li><a href="../fr466841/index.html">Pourquoi un coussin chauffant, s'il y a un ordinateur portable: l'√©tude de la r√©sistance thermique au niveau atomique</a></li>
<li><a href="../fr466845/index.html">Interview invers√©e: quelles questions poser √† l'entreprise?</a></li>
<li><a href="../fr466849/index.html">noexcept-ctcheck ou quelques macros simples pour aider le compilateur √† √©crire du code noexcept</a></li>
<li><a href="../fr466851/index.html">Ligne Agilex - FPGA Intel 10 nm</a></li>
<li><a href="../fr466857/index.html">Ex√©cution d'application en arri√®re-plan dans iOS 13</a></li>
<li><a href="../fr466859/index.html">Utilisation du service AD ‚Äã‚ÄãFederation pour autoriser les utilisateurs AWS avec une distribution de droits</a></li>
<li><a href="../fr466861/index.html">Comment √©chapper √† la r√©alit√© en utilisant un hackathon</a></li>
<li><a href="../fr466863/index.html">Configuration d'Asymptote</a></li>
<li><a href="../fr466865/index.html">En attendant le 1er novembre: interdiction ou l√©galisation des crypto-monnaies</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>