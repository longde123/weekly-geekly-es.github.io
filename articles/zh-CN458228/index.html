<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>➖ 😯 👖 为什么我们需要虚拟功能 🍟 👩🏻‍🤝‍👨🏾 👨🏽‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha 如果您知道标题中问题的答案，那么恭喜，您不需要本文。 它是针对像我这样的编程初学者的，他们不能总是独立地理解C ++和其他类型语言的所有复杂性，并且如果可以的话，最好还是从别人的错误中学习。 

 在本文中，我将不仅仅回答“ 为什么我们需要C ++中的虚函数 ”这个问题，而是将通过实践给出一...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>为什么我们需要虚拟功能</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458228/">哈Ha 如果您知道标题中问题的答案，那么恭喜，您不需要本文。 它是针对像我这样的编程初学者的，他们不能总是独立地理解C ++和其他类型语言的所有复杂性，并且如果可以的话，最好还是从别人的错误中学习。 <br><br> 在本文中，我将不仅仅回答“ <i>为什么我们需要C ++中的虚函数</i> ”这个问题，而是将通过实践给出一个示例。 作为一个简短的答案，您可以转向产生如下内容的搜索引擎：“ <i>需要虚拟函数来提供多态性-三只OOP鲸鱼之一。由于有了它们，机器本身可以通过指针确定对象的类型，而无需向程序员加载此任务。</i> ” 好的，但是“为什么”问题仍然存在，尽管现在含义有所不同：“ <i>为什么要依靠机器，花更多的时间和内存，如果您可以自己播客指针，因为它所指向的对象类型几乎总是已知的？</i> ”的确，乍一看，强制转换会使虚函数失效，而这正是导致误解和错误代码的原因。 在小型项目中，损失是看不见的，但是，正如您将很快看到的那样，随着程序的增长，种姓的增加几乎以几何级数递增。 <br><a name="habracut"></a><br> 首先，让我们回顾一下可能根本需要种姓和虚函数的地方。 当为使用类型A声明的对象分配新操作以为与类型A兼容的类型B的对象（通常从A继承）分配内存时，类型就会丢失。通常，该对象不是一个对象，而是整个数组。 相同类型的指针数组，每个指针都在等待分配完全不同类型的对象的存储区。 这是我们将考虑的示例。 <br><br> 我不会拖很长时间了，任务是这样的：基于一个用Markedit超文本标记语言标记的文档（您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>阅读有关内容），构建一个解析树，并创建一个包含相同HTML标记文档的文件。 我的解决方案由三个顺序例程组成：将源文本解析为标记，从标记构建语法树，并基于该语法构建HTML文档。 我们对第二部分感兴趣。 <br> 事实是目标树的节点具有不同的类型（节，段落，文本节点，链接，脚注等），但是对于父节点，指向子节点的指针存储在数组中，因此具有一种类型-节点。 <br><br> 解析器本身的简化形式是这样的：它使用<b>Root</b>类型创建树语法<b>树</b>的“根”，声明常规类型<b>Node</b>的<b>open_node</b>指针（立即为其分配<b>树</b>地址）和枚举类型<b>Node_type</b>的<b>类型</b>变量，然后循环开始， <b>从头</b>开始<b>遍历</b>令牌到最后。 每次迭代时，首先将<b>open_node</b>打开节点的类型输入到type变量中（枚举形式的类型存储在节点的结构中），然后是<b>switch语句</b> ，该<b>语句</b>检查下一个标记的类型（词法分析器已经仔细提供了标记的类型）。 在交换机的每个分支中，都提供了另​​一个分支来检查<b>类型</b>变量，正如我们记得的那样，其中包含打开节点的类型。 根据其值，将执行不同的操作，例如：将某个类型的节点列表添加到一个打开的节点，在一个打开的节点中打开某个类型的另一个节点，并将其地址传递给<b>open_node</b> ，关闭该打开的节点，引发异常。 适用于本文的主题，我们对第二个示例感兴趣。 每个打开的节点（通常是每个可以打开的节点）已经包含一个指向<b>Node</b>类型的<b>节点</b>的指针数组。 因此，当我们在一个打开的节点中打开一个新节点（将另一个类型的对象的内存区域分配给下一个数组指针）时，对于C ++语义分析器，它仍然是<b>Node</b>类型的实例，而无需获取新的字段和方法。 现在将指向它的指针分配给变量<b>open_node</b> ，而不会丢失<b>Node</b>的类型。 但是，当您需要调用方法（例如段落）时，如何使用常规<b>Node</b>类型的指针呢？ 例如， <b>open_bold（）</b> ，它将在其中打开一个粗体字体节点？ 毕竟， <b>open_bold（）被</b>声明并定义为<b>Paragraph</b>类的方法，而<b>Node</b>完全不知道它。 另外， <b>open_node</b>也被声明为指向<b>Node</b>的指针，并且它必须接受所有打开节点类型的方法。 <br><br> 这里有两种解决方案：显而易见的解决方案和正确的解决方案。 对于初学者来说显而易见的是<b>static_cast</b> ，并且虚函数是正确的。 我们首先来看一下使用第一种方法编写的开关解析器的一个分支： <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Lexer::BOLD_START: { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::SECTION) { open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::PARAGRAPH) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::TITLE) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Title*&gt;(open_node)-&gt;open_bold(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::QUOTE) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Quote*&gt;(open_node)-&gt;open_bold(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::UNORDERED_LIST) { open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (open_node-&gt;get_type() != Node::SECTION) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::ORDERED_LIST) { open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Ordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (open_node-&gt;get_type() != Node::SECTION) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::LINK) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Link*&gt;(open_node)-&gt;open_bold(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment">// INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_bold(); break; }</span></span></code> </pre> <br> 还不错 现在，我将不再使用它很长时间，我将展示使用虚函数编写的同一部分代码： <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Lexer::BOLD_START: { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_bold(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_bold(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::UNORDERED_LIST) { open_node = open_node-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_bold(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment">// PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_bold(); break; }</span></span></code> </pre><br> 收益是显而易见的，但是我们真的需要吗？ 毕竟，您必须在<b>Node</b>类中将所有派生类的所有方法声明为虚方法，并以某种方式在每个派生类中实现它们。 答案是肯定的。 该程序中没有专门的方法（29），并且在与它们不相关的派生类中的实现仅由一行组成： <b>throw string（“ error！”）;</b>  。 您可以启用广告素材模式，并为每次异常抛出提供唯一的一行。 但最重要的是-由于减少了代码，减少了错误数量。 强制转换是导致代码错误的最重要原因之一。 因为在应用<b>static_cast之后，</b>如果调用的类包含在给定的类中<b>，则</b>编译器将停止宣誓。 同时，不同的类可能包含具有相同名称的不同方法。 就我而言，代码中隐藏了6个！ 错误，而其中之一在多个开关分支中重复。 这是： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node:: open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Title*&gt;(open_node)-&gt;open_italic();</code> </pre><br> 接下来，在扰流器下，我提供了解析器的第一版和第二版的完整列表。 <br><br><div class="spoiler">  <b class="spoiler_title">解析器与转换</b> <div class="spoiler_text"><pre> <code class="cpp hljs">Root * Parser::parse (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Lexer &amp;lexer) { <span class="hljs-function"><span class="hljs-function">Node * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">open_node</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tree)</span></span></span></span>; Node::Node_type type; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> i(<span class="hljs-number"><span class="hljs-number">0</span></span>), len(lexer.count()); i &lt; len; i++) { type = open_node-&gt;get_type(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::CITE || type == Node::TEXT || type == Node::NEWLINE || type == Node::NOTIFICATION || type == Node::IMAGE) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"error!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (lexer[i].type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Lexer::NEWLINE: { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::ROOT || type == Node::SECTION) ; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::PARAGRAPH) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;add_text(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::TITLE) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Title*&gt;(open_node)-&gt;add_text(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::QUOTE) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Quote*&gt;(open_node)-&gt;add_text(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::UNORDERED_LIST) { open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (open_node-&gt;get_type() != Node::SECTION) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;close(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::ORDERED_LIST) { open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Ordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (open_node-&gt;get_type() != Node::SECTION) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;close(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::LINK) { open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Link*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment">// INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); break; } case Lexer::DOUBLE_NEWLINE: { if (type == Node::ROOT || type == Node::SECTION) ; else if (type == Node::PARAGRAPH) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } } else if (type == Node::QUOTE) { open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } } else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } } else throw string("unexpected double newline!"); break; } case Lexer::UNDERLINE: { if (type == Node::ROOT) open_node = tree-&gt;add_line(); else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;add_line(); } else if (type == Node::PARAGRAPH) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;add_line(); } else if (type == Node::TITLE) throw string("unexpected underline inside title!"); else if (type == Node::QUOTE) { open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;add_line(); } else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;add_line(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;add_line(); } else // INLINE throw string("unexpected underline inside inline span!"); break; } case Lexer::TITLE_START: { if (lexer[i].lexeme.size() &gt; 7) throw string("invalid title: \"" + lexer[i].lexeme + "\"!"); if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_title(lexer[i].lexeme.size()-1); } else if (type == Node::SECTION) open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_title(lexer[i].lexeme.size()-1); else if (type == Node::PARAGRAPH) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_title(lexer[i].lexeme.size()-1); } else if (type == Node::TITLE) throw string("title can't contain another title!"); else if (type == Node::QUOTE) { open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_title(lexer[i].lexeme.size()-1); } else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_title(lexer[i].lexeme.size()-1); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_title(lexer[i].lexeme.size()-1); } else if (type == Node::LINK) throw string("link can't contain a title!"); else // INLINE throw string("inline span can't contain a title!"); break; } case Lexer::BOLD_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_bold(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_bold(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_bold(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_bold(); break; } case Lexer::ITALIC_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_italic(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_italic(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_italic(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_italic(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_italic(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_italic(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_italic(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_italic(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_italic(); break; } case Lexer::UNDERLINED_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_underlined(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_underlined(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_underlined(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_underlined(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_underlined(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_underlined(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_underlined(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_underlined(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_underlined(); break; } case Lexer::OVERLINED_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_overlined(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_overlined(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_overlined(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_overlined(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_overlined(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_overlined(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_overlined(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_overlined(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_overlined(); break; } case Lexer::THROWLINED_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_throwlined(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_throwlined(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_throwlined(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_throwlined(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_throwlined(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_throwlined(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_throwlined(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_throwlined(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_throwlined(); break; } case Lexer::SUBSCRIPT_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_subscript(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_subscript(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_subscript(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_subscript(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_subscript(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_subscript(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_subscript(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_subscript(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_subscript(); break; } case Lexer::SUPERSCRIPT_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_superscript(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_superscript(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_superscript(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_superscript(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_superscript(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_superscript(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_superscript(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_superscript(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_superscript(); break; } case Lexer::MARKED_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_marked(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_marked(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_marked(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_marked(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_marked(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_marked(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_marked(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_marked(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_marked(); break; } case Lexer::MONOSPACE_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_monospace(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_monospace(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_monospace(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_monospace(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_monospace(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_monospace(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_monospace(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_monospace(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_monospace(); break; } case Lexer::SPAN_OR_IMAGE_FINISH: { if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;close(); else if (type == Node::BOLD || type == Node::ITALIC || type == Node::UNDERLINED || type == Node::OVERLINED || type == Node::THROWLINED || type == Node::SUBSCRIPT || type == Node::SUPERSCRIPT || type == Node::MARKED || type == Node::MONOSPACE) open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;close(); else if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("]"); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("]"); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("]"); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;add_text("]"); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;add_text("]"); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("]"); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("]"); } else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;add_text("&gt;"); break; } case Lexer::LINK_START: { if (i &gt; len-3 || lexer[++i].type != Lexer::TEXT || lexer[++i].type != Lexer::LINK_FINISH) throw string("unclosed link!"); if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); break; } case Lexer::LINK_FINISH: { if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;close(); else if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("&gt;"); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section&gt;(open_node).open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("&gt;"); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("&gt;"); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;add_text("&gt;"); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;add_text("&gt;"); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("&gt;"); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("&gt;"); } else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;add_text("&gt;"); break; } case Lexer::IMAGE_START: { if (i &gt; len-5 || lexer[++i].type != Lexer::TEXT || lexer[++i].type != Lexer::LINK_FINISH || (lexer[++i].type != Lexer::TEXT &amp;&amp; lexer[i].type != Lexer::SPAN_OR_IMAGE_FINISH) || (lexer[i].type == Lexer::TEXT &amp;&amp; lexer[i+1].type != Lexer::SPAN_OR_IMAGE_FINISH)) throw string("unclosed image defintion!"); if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::PARAGRAPH) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::TITLE) { if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::QUOTE) { open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::LINK) { if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } else { // INLINE if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } break; } case Lexer::CITE: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); } else if (type == Node::SECTION) open_node = static_cast&lt;Section*&gt;(open_node)-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); else if (type == Node::PARAGRAPH) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); } else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;add_image(lexer[i-3].lexeme, lexer[i-1].lexeme); else if (type == Node::QUOTE) { open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); } else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); } else if (type == Node::LINK) throw string("link can't contain a cite!"); else // INLINE throw string("inline span can't contain a cite!"); break; } case Lexer::QUOTE_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); } else if (type == Node::SECTION) open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); else if (type == Node::PARAGRAPH) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); } else if (type == Node::TITLE) { open_node = static_cast&lt;Title*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); } else if (type == Node::QUOTE) { open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); } else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); } else if (type == Node::LINK) { open_node = static_cast&lt;Link*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); } else { // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); } break; } case Lexer::NOTIFICATION: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } else if (type == Node::PARAGRAPH) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } else if (type == Node::TITLE) { open_node = static_cast&lt;Title*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } else if (type == Node::QUOTE) { open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } else if (type == Node::LINK) { open_node = static_cast&lt;Link*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } else { // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } break; } case Lexer::TEXT: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); } else if (type == Node::LINK) { open_node = static_cast&lt;Link*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); } else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); break; } case Lexer::UNORDERED_LIST_ITEM_MARKER: { break; } case Lexer::ORDERED_LIST_ITEM_MARKER: { break; } case Lexer::END: { if (type == Node::ROOT) open_node = tree-&gt;close(); else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;close(); } else if (type == Node::PARAGRAPH) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;close(); } else if (type == Node::QUOTE) { open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;close(); } else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;close(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;close(); } else // LINK || INLINE throw string("unexpected ending!"); /// ROOT, /// SECTION, /// PARAGRAPH, TITLE, QUOTE, UNORDERED_LIST, ORDERED_LIST, /// BOLD, ITALIC, UNDERLINED, OVERLINED, THROWLINED, SUBSCRIPT, SUPERSCRIPT, MARKED, MONOSPACE, /// LINK break; } } } concatenate(); return tree; }</span></span></code> </pre></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以访问虚拟方法的解析器</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">Root * Parser::parse (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Lexer &amp;lexer) { <span class="hljs-function"><span class="hljs-function">Node * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">open_node</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tree)</span></span></span></span>; Node::Node_type type; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> i(<span class="hljs-number"><span class="hljs-number">0</span></span>), len(lexer.count()); i &lt; len; i++) { type = open_node-&gt;get_type(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::CITE || type == Node::TEXT || type == Node::NEWLINE || type == Node::NOTIFICATION || type == Node::IMAGE) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"error!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (lexer[i].type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Lexer::NEWLINE: { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::ROOT || type == Node::SECTION) ; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::PARAGRAPH || type == Node::TITLE || type == Node::QUOTE || type == Node::TITLE || type == Node::QUOTE) open_node = open_node-&gt;add_text(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment">// LINK, INLINE open_node = open_node-&gt;add_text(lexer[i].lexeme); break; } case Lexer::DOUBLE_NEWLINE: { if (type == Node::ROOT || type == Node::SECTION) ; else if (type == Node::PARAGRAPH || type == Node::QUOTE || type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); } else throw string("unexpected double newline!"); break; } case Lexer::UNDERLINE: { if (type == Node::ROOT) open_node = tree-&gt;add_line(); else if (type == Node::SECTION) { open_node = open_node-&gt;close(); open_node = tree-&gt;add_line(); } else if (type == Node::PARAGRAPH || type == Node::QUOTE || type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;close(); open_node = tree-&gt;add_line(); } else if (type == Node::TITLE) throw string("unexpected underline inside title!"); else if (type == Node::LINK) throw string("unexpected underline inside link!"); else // INLINE throw string("unexpected underline inside inline span!"); break; } case Lexer::TITLE_START: { if (lexer[i].lexeme.size() &gt; 7) throw string("invalid title: \"" + lexer[i].lexeme + "\"!"); if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_title(lexer[i].lexeme.size()-1); } else if (type == Node::SECTION) open_node = open_node-&gt;open_title(lexer[i].lexeme.size()-1); else if (type == Node::PARAGRAPH || type == Node::QUOTE || type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_title(lexer[i].lexeme.size()-1); } else if (type == Node::TITLE) throw string("title can't contain another title!"); else if (type == Node::LINK) throw string("link can't contain a title!"); else // INLINE throw string("inline span can't contain a title!"); break; } case Lexer::BOLD_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_bold(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_bold(); } else if (type == Node::UNORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_bold(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_bold(); break; } case Lexer::ITALIC_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_italic(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_italic(); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_italic(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_italic(); break; } case Lexer::UNDERLINED_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_underlined(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_underlined(); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_underlined(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_underlined(); break; } case Lexer::OVERLINED_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_overlined(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_overlined(); } else if (type == Node::PARAGRAPH) open_node = open_node-&gt;open_overlined(); else if (type == Node::TITLE) open_node = open_node-&gt;open_overlined(); else if (type == Node::QUOTE) open_node = open_node-&gt;open_overlined(); else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_overlined(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_overlined(); break; } case Lexer::THROWLINED_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_throwlined(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_throwlined(); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_throwlined(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_throwlined(); break; } case Lexer::SUBSCRIPT_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_subscript(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_subscript(); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_subscript(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_subscript(); break; } case Lexer::SUPERSCRIPT_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_superscript(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_superscript(); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_superscript(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_superscript(); break; } case Lexer::MARKED_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_marked(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_marked(); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_marked(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_marked(); break; } case Lexer::MONOSPACE_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_monospace(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_monospace(); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_monospace(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_monospace(); break; } case Lexer::SPAN_OR_IMAGE_FINISH: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text("]"); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text("]"); } else if (type == Node::PARAGRAPH || type == Node::QUOTE || type == Node::LINK) open_node = open_node-&gt;add_text("]"); else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text("]"); } else // TITLE, INLINE open_node = open_node-&gt;close(); break; } case Lexer::LINK_START: { if (i &gt; len-3 || lexer[++i].type != Lexer::TEXT || lexer[++i].type != Lexer::LINK_FINISH) throw string("unclosed link!"); if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_link(lexer[i-1].lexeme); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_link(lexer[i-1].lexeme); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_link(lexer[i-1].lexeme); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_link(lexer[i-1].lexeme); break; } case Lexer::LINK_FINISH: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text("&gt;"); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text("&gt;"); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text("&gt;"); } else if (type == Node::LINK) open_node = open_node-&gt;close(); else // PARAGRAPH, TITLE, QUOTE, INLINE open_node = open_node-&gt;add_text("&gt;"); break; } case Lexer::IMAGE_START: { if (i &gt; len-5 || lexer[++i].type != Lexer::TEXT || lexer[++i].type != Lexer::LINK_FINISH || (lexer[++i].type != Lexer::TEXT &amp;&amp; lexer[i].type != Lexer::SPAN_OR_IMAGE_FINISH) || (lexer[i].type == Lexer::TEXT &amp;&amp; lexer[i+1].type != Lexer::SPAN_OR_IMAGE_FINISH)) throw string("unclosed image defintion!"); if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); if (lexer[i].type == Lexer::TEXT) { open_node = open_node-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = open_node-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); if (lexer[i].type == Lexer::TEXT) { open_node = open_node-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = open_node-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::PARAGRAPH || type == Node::QUOTE || type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { if (lexer[i].type == Lexer::TEXT) { open_node = open_node-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = open_node-&gt;add_image(lexer[i-2].lexeme, ""); } else { // TITLE, LINK, INLINE if (lexer[i].type == Lexer::TEXT) { open_node = open_node-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = open_node-&gt;add_image(lexer[i-2].lexeme, ""); } break; } case Lexer::CITE: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); } else if (type == Node::SECTION) open_node = open_node-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); else if (type == Node::PARAGRAPH || type == Node::QUOTE || type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); } else if (type == Node::TITLE) throw string("title cant't contain a cite!"); else if (type == Node::LINK) throw string("link can't contain a cite!"); else // INLINE throw string("inline span can't contain a cite!"); break; } case Lexer::QUOTE_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_quote(); } else if (type == Node::SECTION) open_node = open_node-&gt;open_quote(); else { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_quote(); } break; } case Lexer::NOTIFICATION: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_notification(lexer[i].lexeme); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_notification(lexer[i].lexeme); } else { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_notification(lexer[i].lexeme); } break; } case Lexer::TEXT: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text(lexer[i].lexeme); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text(lexer[i].lexeme); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text(lexer[i].lexeme); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;add_text(lexer[i].lexeme); break; } case Lexer::UNORDERED_LIST_ITEM_MARKER: { break; } case Lexer::ORDERED_LIST_ITEM_MARKER: { break; } case Lexer::END: { if (type == Node::ROOT) open_node = tree-&gt;close(); else if (type == Node::SECTION) { open_node = open_node-&gt;close(); open_node = tree-&gt;close(); } else if (type == Node::PARAGRAPH || type == Node::QUOTE || type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;close(); open_node = tree-&gt;close(); } else // LINK || INLINE throw string("unexpected ending!"); break; } } } concatenate(); return tree; }</span></span></code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从1357行开始，代码减少到487，几乎是三倍，这还不包括行的长度！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还有一个问题：交货时间如何？</font><font style="vertical-align: inherit;">为了确定开放节点的类型，我们必须为计算机本身支付多少毫秒？</font><font style="vertical-align: inherit;">我进行了一个实验-在家用计算机上，同一文档的第一种和第二种情况下，解析器的工作时间以毫秒为单位固定。</font><font style="vertical-align: inherit;">结果是：</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">投放-538毫秒。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">虚拟功能-1174毫秒。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">总计636毫秒-代码紧凑和没有错误的费用。</font><font style="vertical-align: inherit;">这很多吗？</font><font style="vertical-align: inherit;">可能吧 </font><font style="vertical-align: inherit;">但是，如果我们需要一个尽可能快地运行并且需要尽可能少的内存的程序，我们就不会去OOP并用汇编语言来编写它，这要花一个星期的时间，并且冒犯大量错误的风险。</font><font style="vertical-align: inherit;">所以我的选择是在程序中</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static_cast</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dynamic_cast</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相遇的地方</font><font style="vertical-align: inherit;">，用虚拟函数替换它们。</font><font style="vertical-align: inherit;">您对此有何看法？</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN458228/">https://habr.com/ru/post/zh-CN458228/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN458214/index.html">Pentest实验室的“ Pentestit测试实验室12”-全部通过</a></li>
<li><a href="../zh-CN458218/index.html">上颌面手术还是不行？ 那是问题</a></li>
<li><a href="../zh-CN458220/index.html">＃304移动开发人员的有趣材料摘要（6月24日至30日）</a></li>
<li><a href="../zh-CN458222/index.html">打破记忆游戏：整个侦探故事</a></li>
<li><a href="../zh-CN458224/index.html">Boeing-737 Max的软件由外包商编写，每小时收入9美元</a></li>
<li><a href="../zh-CN458230/index.html">人工智能，无人机和摄像头如何确保我们的道路和桥梁安全</a></li>
<li><a href="../zh-CN458240/index.html">人工智能，无人机和摄像头如何确保道路和桥梁的安全</a></li>
<li><a href="../zh-CN458242/index.html">C ++ 20中的新太空飞船运算符</a></li>
<li><a href="../zh-CN458244/index.html">为了安全使用公共Wi-Fi网络，您需要了解的内容无穷无尽的清单</a></li>
<li><a href="../zh-CN458246/index.html">生活中的偶然巧合，或结果证明您在拖拉机工厂被送上蛋糕</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>