<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😁 👨🏻 ☪️ Nouveautés de JPA 2.2 🥕 🕢 🎷</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonnes vacances à tous! 

 Il est arrivé si soudainement que le début du deuxième groupe «Java Enterprise Developer» a coïncidé avec le 256e jour de l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nouveautés de JPA 2.2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/423195/">  Bonnes vacances à tous! <br><br>  Il est arrivé si soudainement que le début du deuxième groupe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Java Enterprise Developer» a</a> coïncidé avec le 256e jour de l'année.  <s>Coïncidence?</s>  <s>Je ne pense pas.</s> <br><br>  Eh bien, nous partageons l'avant-dernier intérêt: quelles nouveautés JPA 2.2 a-t-il apporté - résultats de streaming, conversion de date améliorée, nouvelles annotations - quelques exemples d'améliorations utiles. <br><br>  C'est parti! <br><br>  L'API Java Persistence (JPA) est une spécification Java EE fondamentale largement utilisée dans l'industrie.  Que vous développiez pour la plate-forme Java EE ou pour le framework Java alternatif, JPA est votre choix pour sauvegarder les données.  JPA 2.1 a amélioré les spécifications, permettant aux développeurs de résoudre des problèmes tels que la génération automatique de schémas de base de données et un travail efficace avec les procédures stockées dans la base de données.  La dernière version, JPA 2.2, améliore les spécifications en fonction de ces changements. <br>  Dans cet article, je vais parler de nouvelles fonctionnalités et donner des exemples qui vous aideront à démarrer avec.  À titre d'exemple, j'utilise le projet «Java EE 8 Playground», qui est disponible sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> .  L'exemple d'application est basé sur la spécification Java EE 8 et utilise les cadres JavaServer Faces (JSF), Enterprise JavaBeans (EJB) et JPA pour la persistance.  Vous devez être familier avec JPA pour comprendre de quoi il s'agit. <br><br><img src="https://habrastorage.org/webt/2a/o5/xl/2ao5xlvs1k6qa91gdq0ndz3akis.png"><br><a name="habracut"></a><br>  <b>Utilisation de JPA 2.2</b> <br><br>  JPA version 2.2 fait partie de la plate-forme Java EE 8. Il convient de noter que seuls les serveurs d'applications compatibles Java EE 8 fournissent une spécification prête à l'emploi prête à l'emploi.  Au moment d'écrire ces lignes (fin 2017), il y avait pas mal de tels serveurs d'applications.  Cependant, l'utilisation de JPA 2.2 avec Java EE7 est facile.  Vous devez d'abord télécharger les fichiers JAR appropriés à l'aide de <a href="">Maven Central</a> et les ajouter au projet.  Si vous utilisez Maven dans votre projet, ajoutez les coordonnées au fichier Maven POM: <br><br><pre><code class="java hljs">&lt;dependency&gt; &lt;groupId&gt;javax.persistence&lt;/groupId&gt; &lt;artifactId&gt;javax.persistence-api&lt;/artifactId&gt; &lt;version&gt;<span class="hljs-number"><span class="hljs-number">2.2</span></span>&lt;/version&gt; &lt;/dependency&gt;</code> </pre> <br>  Sélectionnez ensuite l'implémentation JPA que vous souhaitez utiliser.  Depuis JPA 2.2, EclipseLink et Hibernate ont des implémentations compatibles.  Comme exemples dans cet article, j'utilise <a href="">EclipseLink</a> en ajoutant la dépendance suivante: <br><br><pre> <code class="java hljs">&lt;dependency&gt; &lt;groupId&gt;org.eclipse.persistence&lt;/groupId&gt; &lt;artifactId&gt;eclipselink&lt;/artifactId&gt; &lt;version&gt;<span class="hljs-number"><span class="hljs-number">2.7</span></span>.0 &lt;/version&gt; &lt;/dependency&gt;</code> </pre> <br>  Si vous utilisez un serveur compatible Java EE 8, tel que GlassFish 5 ou Payara 5, vous devriez pouvoir spécifier la zone «fournie» pour ces dépendances dans le fichier POM.  Sinon, spécifiez la zone «compiler» pour les inclure dans l'assemblage du projet. <br><br>  <b>Prise en charge de la date et de l'heure Java 8</b> <br><br>  L'un des ajouts les plus positifs est peut-être la prise en charge de l'API date et heure Java 8.  Depuis la sortie de Java SE 8 en 2014, les développeurs ont utilisé des solutions de contournement pour utiliser l'API Date et Heure avec JPA.  Bien que la plupart des solutions de contournement soient assez simples, la nécessité d'ajouter une prise en charge de base pour l'API de date et heure mise à jour est attendue depuis longtemps.  La prise en charge JPA pour l'API Date et heure inclut les types suivants: <br><br><ul><li> <code>java.time.LocalDate</code> </li> <li> <code>java.time.LocalTime</code> </li> <li> <code>java.time.LocalDateTime</code> </li> <li> <code>java.time.OffsetTime</code> </li> <li> <code>java.time.OffsetDateTime</code> </li> </ul><br>  Pour une meilleure compréhension, je vais d'abord expliquer comment le support de l'API Date et Heure fonctionne sans JPA 2.2.  JPA 2.1 ne peut fonctionner qu'avec des constructions de date plus anciennes telles que <code>java.util.Date</code> et <code>java.sql.Timestamp</code> .  Par conséquent, vous devez utiliser un convertisseur pour convertir la date stockée dans la base de données en une ancienne conception prise en charge par JPA 2.1, puis la convertir en une API de date et heure mise à jour pour une utilisation dans l'application.  Un convertisseur de date dans JPA 2.1 capable d'une telle conversion peut ressembler à la liste 1. Le convertisseur qu'il <code>LocalDate</code> est utilisé pour convertir entre <code>LocalDate</code> et <code>java.util.Date</code> . <br><br>  <i>Listing 1</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Converter</span></span>(autoApply = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDateTimeConverter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AttributeConverter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDate</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Date</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Date </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToDatabaseColumn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LocalDate entityValue)</span></span></span><span class="hljs-function"> </span></span>{ LocalTime time = LocalTime.now(); Instant instant = time.atDate(entityValue) .atZone(ZoneId.systemDefault()) .toInstant(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Date.from(instant); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> LocalDate </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToEntityAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Date databaseValue)</span></span></span></span>{ Instant instant = Instant.ofEpochMilli(databaseValue.getTime()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LocalDateTime.ofInstant(instant, ZoneId.systemDefault()).toLocalDate(); } }</code> </pre> <br>  JPA 2.2 n'a plus besoin d'écrire un tel convertisseur, car vous utilisez des types date-heure pris en charge.  La prise en charge de ces types est intégrée, vous pouvez donc simplement spécifier le type pris en charge dans le champ de classe d'entité sans code supplémentaire.  L'extrait de code ci-dessous illustre ce concept.  Notez qu'il n'est pas nécessaire d'ajouter d'annotation au code <code>@Temporal</code> , car le mappage de type se produit automatiquement. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ . . . <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(name = <span class="hljs-string"><span class="hljs-string">"WORK_DATE"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> LocalDate workDate; . . . }</code> </pre> <br>  Étant donné que les types date-heure pris en charge sont des objets de première classe dans le JPA, ils peuvent être spécifiés sans cérémonies supplémentaires.  Dans JPA 2.1 <code>@Temporal</code> annotation doit être décrite dans tous les champs et propriétés constants des <code>java.util.Calendar</code> <code>java.util.Date</code> et <code>java.util.Calendar</code> . <br><br>  Il convient de noter que seule une partie des types de données-heure est prise en charge dans cette version, mais le convertisseur d'attribut peut être facilement généré pour fonctionner avec d'autres types, par exemple, pour convertir <code>LocalDateTime</code> en <code>ZonedDateTime</code> .  Le plus gros problème lors de l'écriture d'un tel convertisseur est de déterminer la meilleure façon de convertir entre différents types.  Pour rendre les choses encore plus faciles, des convertisseurs d'attributs peuvent désormais être implémentés.  Je vais donner un exemple d'implémentation ci-dessous. <br><br>  Le code du Listing 2 montre comment convertir l'heure de <code>LocalDateTime</code> en <code>ZonedDateTime</code> . <br><br>  <i>Listing 2</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Converter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalToZonedConverter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AttributeConverter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZonedDateTime</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDateTime</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> LocalDateTime </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToDatabaseColumn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ZonedDateTime entityValue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> entityValue.toLocalDateTime(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ZonedDateTime </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToEntityAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LocalDateTime databaseValue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ZonedDateTime.of(databaseValue, ZoneId.systemDefault()); } }</code> </pre> <br>  Plus précisément, cet exemple est très simple car <code>ZonedDateTime</code> contient des méthodes faciles à convertir.  La conversion se produit en appelant la méthode <code>toLocalDateTime()</code> .  La conversion inverse peut être effectuée en appelant la méthode <code>ZonedDateTimeOf()</code> et en transmettant la valeur <code>ZoneId</code> avec <code>ZoneId</code> pour utiliser le fuseau horaire. <br><br>  <b>Convertisseurs d'attributs intégrés</b> <br><br>  Les convertisseurs d'attributs étaient un très bon ajout à JPA 2.1, car ils permettaient aux types d'attributs d'être plus flexibles.  La mise à jour JPA 2.2 ajoute une capacité utile pour rendre les convertisseurs d'attributs implémentables.  Cela signifie que vous pouvez incorporer des ressources Contexts and Dependency Injection (CDI) directement dans le convertisseur d'attributs.  Cette modification est cohérente avec d'autres améliorations CDI dans les spécifications Java EE 8, telles que les convertisseurs JSF avancés, car ils peuvent désormais également utiliser l'injection CDI. <br><br>  Pour profiter de cette nouvelle fonctionnalité, il vous suffit d'incorporer les ressources CDI dans le convertisseur d'attributs, si nécessaire.  Le listing 2 fournit un exemple de convertisseur d'attributs, et maintenant je vais le démonter, expliquant tous les détails importants. <br><br>  La classe de convertisseur doit implémenter l'interface <code>javax.persistence.AttributeConverter</code> transmettant les valeurs X et Y. La valeur X correspond au type de données dans l'objet Java et la valeur Y doit correspondre au type de colonne de base de données.  Ensuite, la classe du convertisseur doit être annotée avec <code>@Converter</code> .  Enfin, la classe doit remplacer les <code>convertToDatabaseColumn()</code> et <code>convertToEntityAttribute()</code> .  L'implémentation dans chacune de ces méthodes doit convertir les valeurs de types spécifiques et y revenir. <br><br>  Pour appliquer automatiquement le convertisseur chaque fois que le type de données spécifié est utilisé, ajoutez «automatique», comme dans <code>@Converter(autoApply=true)</code> .  Pour appliquer un convertisseur à un seul attribut, utilisez l'annotation @Converter au niveau de l'attribut, comme illustré ici: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Convert</span></span>(converter=LocalDateConverter.java) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> LocalDate workDate;</code> </pre> <br>  Le convertisseur peut également être appliqué au niveau de la classe: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Convert</span></span>(attributeName=<span class="hljs-string"><span class="hljs-string">"workDate"</span></span>, converter = LocalDateConverter.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ . . .</code> </pre> <br>  Supposons que je veuille chiffrer les valeurs contenues dans le champ <code>creditLimit</code> de l'entité <code>Customer</code> lors de son enregistrement.  Pour implémenter ce processus, les valeurs doivent être chiffrées avant d'être enregistrées et déchiffrées après avoir été récupérées de la base de données.  Cela peut être fait par le convertisseur et, en utilisant JPA 2.2, je peux intégrer l'objet de chiffrement dans le convertisseur pour obtenir le résultat souhaité.  Le listing 3 en donne un exemple. <br><br>  <i>Listing 3</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Converter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreditLimitConverter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AttributeConverter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BigDecimal</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BigDecimal</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> CreditLimitEncryptor encryptor; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BigDecimal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToDatabaseColumn</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BigDecimal entityValue)</span></span></span><span class="hljs-function"> </span></span>{ String encryptedFormat = encryptor.base64encode(entityValue.toString()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BigDecimal.valueOf(Long.valueOf(encryptedFormat)); } ... }</code> </pre> <br>  Dans ce code, le processus est effectué en <code>CreditLimitEncryptor</code> classe <code>CreditLimitEncryptor</code> dans le convertisseur, puis en l'utilisant pour aider le processus. <br><br>  <b>Résultats des requêtes de streaming</b> <br><br>  Désormais, vous pouvez facilement profiter pleinement des fonctionnalités des flux Java SE 8 lorsque vous travaillez avec des résultats de requête.  Les threads simplifient non seulement la lecture, l'écriture et la maintenance du code, mais aident également à améliorer les performances des requêtes dans certaines situations.  Certaines implémentations de threads permettent également d'éviter un nombre excessivement élevé de demandes de données simultanées, bien que dans certains cas, l'utilisation de la pagination <code>ResultSet</code> puisse fonctionner mieux que les flux. <br><br>  Pour activer cette fonction, la méthode <code>getResultStream()</code> a été ajoutée aux <code>TypedQuery</code> <code>Query</code> et <code>TypedQuery</code> .  Cette modification mineure permet à JPA de renvoyer simplement un flux de résultats au lieu d'une liste.  Ainsi, si vous travaillez avec un <code>ResultSet</code> volumineux, il est logique de comparer les performances entre une nouvelle implémentation de thread et un <code>ResultSets</code> ou une pagination déroulante.  La raison en est que les implémentations de threads récupèrent tous les enregistrements à la fois, les stockent dans une liste, puis les renvoient.  Un <code>ResultSet</code> scrollable et une technique de pagination récupèrent les données au coup par coup, ce qui pourrait être mieux pour les grands ensembles de données. <br><br>  Les fournisseurs de persistance peuvent décider de remplacer la nouvelle méthode <code>getResultStream()</code> une implémentation améliorée.  Hibernate inclut déjà une méthode stream () qui utilise un <code>ResultSet</code> déroulant pour analyser les résultats des enregistrements au lieu de les renvoyer complètement.  Cela permet à Hibernate de travailler avec de très grands ensembles de données et de bien le faire.  On peut s'attendre à ce que d'autres fournisseurs remplacent cette méthode pour fournir des fonctionnalités similaires qui sont avantageuses pour JPA. <br><br>  En plus des performances, la possibilité de diffuser les résultats est un ajout intéressant à JPA, qui fournit un moyen pratique de travailler avec les données.  Je vais vous montrer quelques scénarios où cela peut être utile, mais les possibilités elles-mêmes sont infinies.  Dans les deux scénarios, je recherche l'entité <code>Job</code> et renvoie le flux.  Tout d'abord, regardez le code suivant, où j'analyse simplement le flux de <code>Jobs</code> rapport à un <code>Customer</code> spécifique en appelant la méthode d'interface <code>Query</code> <code>getResultStream()</code> .  Ensuite, j'utilise ce fil pour afficher les détails concernant le <code>customer</code> et la <code>work date</code> Job'a. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByCustomer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PoolCustomer customer)</span></span></span></span>{ Stream&lt;Job&gt; jobList = em.createQuery(<span class="hljs-string"><span class="hljs-string">"select object(o) from Job o "</span></span> + <span class="hljs-string"><span class="hljs-string">"where o.customer = :customer"</span></span>) .setParameter(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>, customer) .getResultStream(); jobList.map(j -&gt; j.getCustomerId() + <span class="hljs-string"><span class="hljs-string">" ordered job "</span></span> + j.getId() + <span class="hljs-string"><span class="hljs-string">" - Starting "</span></span> + j.getWorkDate()) .forEach(jm -&gt; System.out.println(jm)); }</code> </pre> <br><br>  Cette méthode peut être légèrement modifiée afin qu'elle renvoie une liste de résultats à l'aide de la méthode <code>Collectors .toList()</code> comme suit. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Job&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByCustomer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PoolCustomer customer)</span></span></span></span>{ Stream&lt;Job&gt; jobList = em.createQuery( <span class="hljs-string"><span class="hljs-string">"select object(o) from Job o "</span></span> + <span class="hljs-string"><span class="hljs-string">"where o.customerId = :customer"</span></span>) .setParameter(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>, customer) .getResultStream(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jobList.collect(Collectors.toList()); }</code> </pre> <br>  Dans le scénario suivant, illustré ci-dessous, je trouve une <code>List</code> tâches liées aux pools d'un formulaire spécifique.  Dans ce cas, je renvoie toutes les tâches correspondant au formulaire soumis sous forme de chaîne.  Semblable au premier exemple, je renvoie d'abord un flux d'enregistrements <code>Jobs</code> .  Ensuite, je filtre les enregistrements en fonction du formulaire de pool de clients.  Comme vous pouvez le voir, le code résultant est très compact et facile à lire. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Job&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByCustPoolShape</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String poolShape)</span></span></span></span>{ Stream&lt;Job&gt; jobstream = em.createQuery( <span class="hljs-string"><span class="hljs-string">"select object(o) from Job o"</span></span>) .getResultStream(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jobstream.filter( c -&gt; poolShape.equals(c.getCustomerId().getPoolId().getShape())) .collect(Collectors.toList()); }</code> </pre><br>  Comme je l'ai mentionné précédemment, il est important de se souvenir des performances dans les scénarios où de grandes quantités de données sont retournées.  Il existe des conditions dans lesquelles les threads sont plus utiles pour interroger des bases de données, mais il y a aussi ceux où ils peuvent entraîner une dégradation des performances.  Une bonne règle de base est que si les données peuvent être interrogées dans le cadre d'une requête SQL, il est logique de le faire.  Parfois, les avantages de l'utilisation d'une syntaxe de thread élégante ne l'emportent pas sur les meilleures performances pouvant être obtenues à l'aide du filtrage SQL standard. <br><br>  <b>Prise en charge des annotations en double</b> <br><br>  Lorsque Java SE 8 a été publié, des annotations en double sont devenues possibles, vous permettant de réutiliser des annotations dans la déclaration.  Certaines situations nécessitent l'utilisation de la même annotation sur une classe ou un champ plusieurs fois.  Par exemple, il peut y avoir plus d'une annotation <code>@SqlResultSetMapping</code> pour une classe d'entité donnée.  Dans les situations où la prise en charge de la ré-annotation est requise, l'annotation de conteneur doit être utilisée.  Les annotations en double réduisent non seulement la nécessité d'encapsuler des collections d'annotations identiques dans des annotations de conteneur, mais peuvent également faciliter la lecture du code. <br><br>  Cela fonctionne comme suit: l'implémentation de la classe d'annotation doit être marquée avec la méta-annotation <code>@Repeatable</code> pour indiquer qu'elle peut être utilisée plusieurs fois.  La méta annotation <code>@Repeatable</code> prend le type de la classe d'annotation de conteneur.  Par exemple, la <code>NamedQuery</code> annotation <code>NamedQuery</code> désormais marquée avec l' <code>@Repeatable(NamedQueries.class)</code> .  Dans ce cas, l'annotation de conteneur est toujours utilisée, mais vous n'avez pas à y penser lorsque vous utilisez la même annotation sur la déclaration ou la classe, car <code>@Repeatable</code> résume ce détail. <br><br>  Nous donnons un exemple.  Si vous souhaitez ajouter plusieurs annotations <code>@NamedQuery</code> à une classe d'entité dans JPA 2.1, vous devez les encapsuler dans l'annotation <code>@NamedQueries</code> , comme indiqué dans le Listing 4. <br><br>  <i>Listing 4</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"CUSTOMER"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@XmlRootElement</span></span> <span class="hljs-meta"><span class="hljs-meta">@NamedQueries</span></span>({ <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findAll"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c"</span></span>) , <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findByCustomerId"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c "</span></span> + <span class="hljs-string"><span class="hljs-string">"WHERE c.customerId = :customerId"</span></span>) , <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findByName"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c "</span></span> + <span class="hljs-string"><span class="hljs-string">"WHERE c.name = :name"</span></span>) . . .)}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Customer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ . . . }</code> </pre> <br>  Cependant, dans JPA 2.2, tout est différent.  Étant donné que <code>@NamedQuery</code> est une annotation en double, elle peut être spécifiée dans la classe d'entité plusieurs fois, comme indiqué dans le listing 5. <br><br>  <i>Listing 5</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"CUSTOMER"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@XmlRootElement</span></span> <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findAll"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findByCustomerId"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c "</span></span> + <span class="hljs-string"><span class="hljs-string">"WHERE c.customerId = :customerId"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findByName"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c "</span></span> + <span class="hljs-string"><span class="hljs-string">"WHERE c.name = :name"</span></span>) . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Customer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ . . . }</code> </pre> <br>  Liste des annotations en double: <br><br><ul><li> <code>@AssociationOverride</code> </li> <li> <code>@AttributeOverride</code> </li> <li> <code>@Convert</code> </li> <li> <code>@JoinColumn</code> </li> <li> <code>@MapKeyJoinColumn</code> </li> <li> <code>@NamedEntityGraphy</code> </li> <li> <code>@NamedNativeQuery</code> </li> <li> <code>@NamedQuery</code> </li> <li> <code>@NamedStoredProcedureQuery</code> </li> <li> <code>@PersistenceContext</code> </li> <li> <code>@PersistenceUnit</code> </li> <li> <code>@PrimaryKeyJoinColumn</code> </li> <li> <code>@SecondaryTable</code> </li> <li> <code>@SqlResultSetMapping</code> </li> </ul><br>  <b>Conclusion</b> <br><br>  La version JPA 2.2 a quelques changements, mais les améliorations incluses sont importantes.  Enfin, le JPA est aligné sur Java SE 8, permettant aux développeurs d'utiliser des fonctionnalités telles que l'API Date et heure, les résultats de requête en streaming et les annotations répétées.  Cette version améliore également la cohérence CDI en ajoutant la possibilité d'incorporer des ressources CDI dans les convertisseurs d'attributs.  JPA 2.2 est maintenant disponible et fait partie de Java EE 8, je pense que vous aimerez l'utiliser. <br><br>  LA FIN <br><br>  Comme toujours, nous attendons vos questions et commentaires. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr423195/">https://habr.com/ru/post/fr423195/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr423185/index.html">Ne le mangez pas! Impression de sucre 3D utile</a></li>
<li><a href="../fr423187/index.html">Certificats racine et intermédiaire des autorités de certification autorisées de la Russie</a></li>
<li><a href="../fr423189/index.html">Recherche: la moitié des entreprises corrigent des vulnérabilités en un mois - pourquoi?</a></li>
<li><a href="../fr423191/index.html">Lancement des éléments des plateformes offshore. Partie 1</a></li>
<li><a href="../fr423193/index.html">Configurer les notifications Web Push à l'aide de pywebpush étape par étape</a></li>
<li><a href="../fr423197/index.html">LOLWUT: une œuvre d'art dans une équipe db</a></li>
<li><a href="../fr423203/index.html">Un chef d'équipe cool sera responsable du service</a></li>
<li><a href="../fr423205/index.html">Projet de stockage sur MS SQL Server, intégration avec 1C 7.7 et automatisation du développement en SSDT</a></li>
<li><a href="../fr423207/index.html">Comment effectuer une mise à jour automatique d'un client de jeu en ligne</a></li>
<li><a href="../fr423209/index.html">Killer Form 2? Présentation de l'imprimante 3D dentaire MoonRay S100</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>