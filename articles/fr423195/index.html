<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòÅ üë®üèª ‚ò™Ô∏è Nouveaut√©s de JPA 2.2 ü•ï üï¢ üé∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonnes vacances √† tous! 

 Il est arriv√© si soudainement que le d√©but du deuxi√®me groupe ¬´Java Enterprise Developer¬ª a co√Øncid√© avec le 256e jour de l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nouveaut√©s de JPA 2.2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/423195/">  Bonnes vacances √† tous! <br><br>  Il est arriv√© si soudainement que le d√©but du deuxi√®me groupe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´Java Enterprise Developer¬ª a</a> co√Øncid√© avec le 256e jour de l'ann√©e.  <s>Co√Øncidence?</s>  <s>Je ne pense pas.</s> <br><br>  Eh bien, nous partageons l'avant-dernier int√©r√™t: quelles nouveaut√©s JPA 2.2 a-t-il apport√© - r√©sultats de streaming, conversion de date am√©lior√©e, nouvelles annotations - quelques exemples d'am√©liorations utiles. <br><br>  C'est parti! <br><br>  L'API Java Persistence (JPA) est une sp√©cification Java EE fondamentale largement utilis√©e dans l'industrie.  Que vous d√©veloppiez pour la plate-forme Java EE ou pour le framework Java alternatif, JPA est votre choix pour sauvegarder les donn√©es.  JPA 2.1 a am√©lior√© les sp√©cifications, permettant aux d√©veloppeurs de r√©soudre des probl√®mes tels que la g√©n√©ration automatique de sch√©mas de base de donn√©es et un travail efficace avec les proc√©dures stock√©es dans la base de donn√©es.  La derni√®re version, JPA 2.2, am√©liore les sp√©cifications en fonction de ces changements. <br>  Dans cet article, je vais parler de nouvelles fonctionnalit√©s et donner des exemples qui vous aideront √† d√©marrer avec.  √Ä titre d'exemple, j'utilise le projet ¬´Java EE 8 Playground¬ª, qui est disponible sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> .  L'exemple d'application est bas√© sur la sp√©cification Java EE 8 et utilise les cadres JavaServer Faces (JSF), Enterprise JavaBeans (EJB) et JPA pour la persistance.  Vous devez √™tre familier avec JPA pour comprendre de quoi il s'agit. <br><br><img src="https://habrastorage.org/webt/2a/o5/xl/2ao5xlvs1k6qa91gdq0ndz3akis.png"><br><a name="habracut"></a><br>  <b>Utilisation de JPA 2.2</b> <br><br>  JPA version 2.2 fait partie de la plate-forme Java EE 8. Il convient de noter que seuls les serveurs d'applications compatibles Java EE 8 fournissent une sp√©cification pr√™te √† l'emploi pr√™te √† l'emploi.  Au moment d'√©crire ces lignes (fin 2017), il y avait pas mal de tels serveurs d'applications.  Cependant, l'utilisation de JPA 2.2 avec Java EE7 est facile.  Vous devez d'abord t√©l√©charger les fichiers JAR appropri√©s √† l'aide de <a href="">Maven Central</a> et les ajouter au projet.  Si vous utilisez Maven dans votre projet, ajoutez les coordonn√©es au fichier Maven POM: <br><br><pre><code class="java hljs">&lt;dependency&gt; &lt;groupId&gt;javax.persistence&lt;/groupId&gt; &lt;artifactId&gt;javax.persistence-api&lt;/artifactId&gt; &lt;version&gt;<span class="hljs-number"><span class="hljs-number">2.2</span></span>&lt;/version&gt; &lt;/dependency&gt;</code> </pre> <br>  S√©lectionnez ensuite l'impl√©mentation JPA que vous souhaitez utiliser.  Depuis JPA 2.2, EclipseLink et Hibernate ont des impl√©mentations compatibles.  Comme exemples dans cet article, j'utilise <a href="">EclipseLink</a> en ajoutant la d√©pendance suivante: <br><br><pre> <code class="java hljs">&lt;dependency&gt; &lt;groupId&gt;org.eclipse.persistence&lt;/groupId&gt; &lt;artifactId&gt;eclipselink&lt;/artifactId&gt; &lt;version&gt;<span class="hljs-number"><span class="hljs-number">2.7</span></span>.0 &lt;/version&gt; &lt;/dependency&gt;</code> </pre> <br>  Si vous utilisez un serveur compatible Java EE 8, tel que GlassFish 5 ou Payara 5, vous devriez pouvoir sp√©cifier la zone ¬´fournie¬ª pour ces d√©pendances dans le fichier POM.  Sinon, sp√©cifiez la zone ¬´compiler¬ª pour les inclure dans l'assemblage du projet. <br><br>  <b>Prise en charge de la date et de l'heure Java 8</b> <br><br>  L'un des ajouts les plus positifs est peut-√™tre la prise en charge de l'API date et heure Java 8.  Depuis la sortie de Java SE 8 en 2014, les d√©veloppeurs ont utilis√© des solutions de contournement pour utiliser l'API Date et Heure avec JPA.  Bien que la plupart des solutions de contournement soient assez simples, la n√©cessit√© d'ajouter une prise en charge de base pour l'API de date et heure mise √† jour est attendue depuis longtemps.  La prise en charge JPA pour l'API Date et heure inclut les types suivants: <br><br><ul><li> <code>java.time.LocalDate</code> </li> <li> <code>java.time.LocalTime</code> </li> <li> <code>java.time.LocalDateTime</code> </li> <li> <code>java.time.OffsetTime</code> </li> <li> <code>java.time.OffsetDateTime</code> </li> </ul><br>  Pour une meilleure compr√©hension, je vais d'abord expliquer comment le support de l'API Date et Heure fonctionne sans JPA 2.2.  JPA 2.1 ne peut fonctionner qu'avec des constructions de date plus anciennes telles que <code>java.util.Date</code> et <code>java.sql.Timestamp</code> .  Par cons√©quent, vous devez utiliser un convertisseur pour convertir la date stock√©e dans la base de donn√©es en une ancienne conception prise en charge par JPA 2.1, puis la convertir en une API de date et heure mise √† jour pour une utilisation dans l'application.  Un convertisseur de date dans JPA 2.1 capable d'une telle conversion peut ressembler √† la liste 1. Le convertisseur qu'il <code>LocalDate</code> est utilis√© pour convertir entre <code>LocalDate</code> et <code>java.util.Date</code> . <br><br>  <i>Listing 1</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Converter</span></span>(autoApply = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDateTimeConverter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AttributeConverter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDate</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Date</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Date </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToDatabaseColumn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LocalDate entityValue)</span></span></span><span class="hljs-function"> </span></span>{ LocalTime time = LocalTime.now(); Instant instant = time.atDate(entityValue) .atZone(ZoneId.systemDefault()) .toInstant(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Date.from(instant); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> LocalDate </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToEntityAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Date databaseValue)</span></span></span></span>{ Instant instant = Instant.ofEpochMilli(databaseValue.getTime()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LocalDateTime.ofInstant(instant, ZoneId.systemDefault()).toLocalDate(); } }</code> </pre> <br>  JPA 2.2 n'a plus besoin d'√©crire un tel convertisseur, car vous utilisez des types date-heure pris en charge.  La prise en charge de ces types est int√©gr√©e, vous pouvez donc simplement sp√©cifier le type pris en charge dans le champ de classe d'entit√© sans code suppl√©mentaire.  L'extrait de code ci-dessous illustre ce concept.  Notez qu'il n'est pas n√©cessaire d'ajouter d'annotation au code <code>@Temporal</code> , car le mappage de type se produit automatiquement. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ . . . <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(name = <span class="hljs-string"><span class="hljs-string">"WORK_DATE"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> LocalDate workDate; . . . }</code> </pre> <br>  √âtant donn√© que les types date-heure pris en charge sont des objets de premi√®re classe dans le JPA, ils peuvent √™tre sp√©cifi√©s sans c√©r√©monies suppl√©mentaires.  Dans JPA 2.1 <code>@Temporal</code> annotation doit √™tre d√©crite dans tous les champs et propri√©t√©s constants des <code>java.util.Calendar</code> <code>java.util.Date</code> et <code>java.util.Calendar</code> . <br><br>  Il convient de noter que seule une partie des types de donn√©es-heure est prise en charge dans cette version, mais le convertisseur d'attribut peut √™tre facilement g√©n√©r√© pour fonctionner avec d'autres types, par exemple, pour convertir <code>LocalDateTime</code> en <code>ZonedDateTime</code> .  Le plus gros probl√®me lors de l'√©criture d'un tel convertisseur est de d√©terminer la meilleure fa√ßon de convertir entre diff√©rents types.  Pour rendre les choses encore plus faciles, des convertisseurs d'attributs peuvent d√©sormais √™tre impl√©ment√©s.  Je vais donner un exemple d'impl√©mentation ci-dessous. <br><br>  Le code du Listing 2 montre comment convertir l'heure de <code>LocalDateTime</code> en <code>ZonedDateTime</code> . <br><br>  <i>Listing 2</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Converter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalToZonedConverter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AttributeConverter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZonedDateTime</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDateTime</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> LocalDateTime </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToDatabaseColumn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ZonedDateTime entityValue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> entityValue.toLocalDateTime(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ZonedDateTime </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToEntityAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LocalDateTime databaseValue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ZonedDateTime.of(databaseValue, ZoneId.systemDefault()); } }</code> </pre> <br>  Plus pr√©cis√©ment, cet exemple est tr√®s simple car <code>ZonedDateTime</code> contient des m√©thodes faciles √† convertir.  La conversion se produit en appelant la m√©thode <code>toLocalDateTime()</code> .  La conversion inverse peut √™tre effectu√©e en appelant la m√©thode <code>ZonedDateTimeOf()</code> et en transmettant la valeur <code>ZoneId</code> avec <code>ZoneId</code> pour utiliser le fuseau horaire. <br><br>  <b>Convertisseurs d'attributs int√©gr√©s</b> <br><br>  Les convertisseurs d'attributs √©taient un tr√®s bon ajout √† JPA 2.1, car ils permettaient aux types d'attributs d'√™tre plus flexibles.  La mise √† jour JPA 2.2 ajoute une capacit√© utile pour rendre les convertisseurs d'attributs impl√©mentables.  Cela signifie que vous pouvez incorporer des ressources Contexts and Dependency Injection (CDI) directement dans le convertisseur d'attributs.  Cette modification est coh√©rente avec d'autres am√©liorations CDI dans les sp√©cifications Java EE 8, telles que les convertisseurs JSF avanc√©s, car ils peuvent d√©sormais √©galement utiliser l'injection CDI. <br><br>  Pour profiter de cette nouvelle fonctionnalit√©, il vous suffit d'incorporer les ressources CDI dans le convertisseur d'attributs, si n√©cessaire.  Le listing 2 fournit un exemple de convertisseur d'attributs, et maintenant je vais le d√©monter, expliquant tous les d√©tails importants. <br><br>  La classe de convertisseur doit impl√©menter l'interface <code>javax.persistence.AttributeConverter</code> transmettant les valeurs X et Y. La valeur X correspond au type de donn√©es dans l'objet Java et la valeur Y doit correspondre au type de colonne de base de donn√©es.  Ensuite, la classe du convertisseur doit √™tre annot√©e avec <code>@Converter</code> .  Enfin, la classe doit remplacer les <code>convertToDatabaseColumn()</code> et <code>convertToEntityAttribute()</code> .  L'impl√©mentation dans chacune de ces m√©thodes doit convertir les valeurs de types sp√©cifiques et y revenir. <br><br>  Pour appliquer automatiquement le convertisseur chaque fois que le type de donn√©es sp√©cifi√© est utilis√©, ajoutez ¬´automatique¬ª, comme dans <code>@Converter(autoApply=true)</code> .  Pour appliquer un convertisseur √† un seul attribut, utilisez l'annotation @Converter au niveau de l'attribut, comme illustr√© ici: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Convert</span></span>(converter=LocalDateConverter.java) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> LocalDate workDate;</code> </pre> <br>  Le convertisseur peut √©galement √™tre appliqu√© au niveau de la classe: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Convert</span></span>(attributeName=<span class="hljs-string"><span class="hljs-string">"workDate"</span></span>, converter = LocalDateConverter.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ . . .</code> </pre> <br>  Supposons que je veuille chiffrer les valeurs contenues dans le champ <code>creditLimit</code> de l'entit√© <code>Customer</code> lors de son enregistrement.  Pour impl√©menter ce processus, les valeurs doivent √™tre chiffr√©es avant d'√™tre enregistr√©es et d√©chiffr√©es apr√®s avoir √©t√© r√©cup√©r√©es de la base de donn√©es.  Cela peut √™tre fait par le convertisseur et, en utilisant JPA 2.2, je peux int√©grer l'objet de chiffrement dans le convertisseur pour obtenir le r√©sultat souhait√©.  Le listing 3 en donne un exemple. <br><br>  <i>Listing 3</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Converter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreditLimitConverter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AttributeConverter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BigDecimal</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BigDecimal</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> CreditLimitEncryptor encryptor; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BigDecimal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToDatabaseColumn</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BigDecimal entityValue)</span></span></span><span class="hljs-function"> </span></span>{ String encryptedFormat = encryptor.base64encode(entityValue.toString()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BigDecimal.valueOf(Long.valueOf(encryptedFormat)); } ... }</code> </pre> <br>  Dans ce code, le processus est effectu√© en <code>CreditLimitEncryptor</code> classe <code>CreditLimitEncryptor</code> dans le convertisseur, puis en l'utilisant pour aider le processus. <br><br>  <b>R√©sultats des requ√™tes de streaming</b> <br><br>  D√©sormais, vous pouvez facilement profiter pleinement des fonctionnalit√©s des flux Java SE 8 lorsque vous travaillez avec des r√©sultats de requ√™te.  Les threads simplifient non seulement la lecture, l'√©criture et la maintenance du code, mais aident √©galement √† am√©liorer les performances des requ√™tes dans certaines situations.  Certaines impl√©mentations de threads permettent √©galement d'√©viter un nombre excessivement √©lev√© de demandes de donn√©es simultan√©es, bien que dans certains cas, l'utilisation de la pagination <code>ResultSet</code> puisse fonctionner mieux que les flux. <br><br>  Pour activer cette fonction, la m√©thode <code>getResultStream()</code> a √©t√© ajout√©e aux <code>TypedQuery</code> <code>Query</code> et <code>TypedQuery</code> .  Cette modification mineure permet √† JPA de renvoyer simplement un flux de r√©sultats au lieu d'une liste.  Ainsi, si vous travaillez avec un <code>ResultSet</code> volumineux, il est logique de comparer les performances entre une nouvelle impl√©mentation de thread et un <code>ResultSets</code> ou une pagination d√©roulante.  La raison en est que les impl√©mentations de threads r√©cup√®rent tous les enregistrements √† la fois, les stockent dans une liste, puis les renvoient.  Un <code>ResultSet</code> scrollable et une technique de pagination r√©cup√®rent les donn√©es au coup par coup, ce qui pourrait √™tre mieux pour les grands ensembles de donn√©es. <br><br>  Les fournisseurs de persistance peuvent d√©cider de remplacer la nouvelle m√©thode <code>getResultStream()</code> une impl√©mentation am√©lior√©e.  Hibernate inclut d√©j√† une m√©thode stream () qui utilise un <code>ResultSet</code> d√©roulant pour analyser les r√©sultats des enregistrements au lieu de les renvoyer compl√®tement.  Cela permet √† Hibernate de travailler avec de tr√®s grands ensembles de donn√©es et de bien le faire.  On peut s'attendre √† ce que d'autres fournisseurs remplacent cette m√©thode pour fournir des fonctionnalit√©s similaires qui sont avantageuses pour JPA. <br><br>  En plus des performances, la possibilit√© de diffuser les r√©sultats est un ajout int√©ressant √† JPA, qui fournit un moyen pratique de travailler avec les donn√©es.  Je vais vous montrer quelques sc√©narios o√π cela peut √™tre utile, mais les possibilit√©s elles-m√™mes sont infinies.  Dans les deux sc√©narios, je recherche l'entit√© <code>Job</code> et renvoie le flux.  Tout d'abord, regardez le code suivant, o√π j'analyse simplement le flux de <code>Jobs</code> rapport √† un <code>Customer</code> sp√©cifique en appelant la m√©thode d'interface <code>Query</code> <code>getResultStream()</code> .  Ensuite, j'utilise ce fil pour afficher les d√©tails concernant le <code>customer</code> et la <code>work date</code> Job'a. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByCustomer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PoolCustomer customer)</span></span></span></span>{ Stream&lt;Job&gt; jobList = em.createQuery(<span class="hljs-string"><span class="hljs-string">"select object(o) from Job o "</span></span> + <span class="hljs-string"><span class="hljs-string">"where o.customer = :customer"</span></span>) .setParameter(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>, customer) .getResultStream(); jobList.map(j -&gt; j.getCustomerId() + <span class="hljs-string"><span class="hljs-string">" ordered job "</span></span> + j.getId() + <span class="hljs-string"><span class="hljs-string">" - Starting "</span></span> + j.getWorkDate()) .forEach(jm -&gt; System.out.println(jm)); }</code> </pre> <br><br>  Cette m√©thode peut √™tre l√©g√®rement modifi√©e afin qu'elle renvoie une liste de r√©sultats √† l'aide de la m√©thode <code>Collectors .toList()</code> comme suit. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Job&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByCustomer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PoolCustomer customer)</span></span></span></span>{ Stream&lt;Job&gt; jobList = em.createQuery( <span class="hljs-string"><span class="hljs-string">"select object(o) from Job o "</span></span> + <span class="hljs-string"><span class="hljs-string">"where o.customerId = :customer"</span></span>) .setParameter(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>, customer) .getResultStream(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jobList.collect(Collectors.toList()); }</code> </pre> <br>  Dans le sc√©nario suivant, illustr√© ci-dessous, je trouve une <code>List</code> t√¢ches li√©es aux pools d'un formulaire sp√©cifique.  Dans ce cas, je renvoie toutes les t√¢ches correspondant au formulaire soumis sous forme de cha√Æne.  Semblable au premier exemple, je renvoie d'abord un flux d'enregistrements <code>Jobs</code> .  Ensuite, je filtre les enregistrements en fonction du formulaire de pool de clients.  Comme vous pouvez le voir, le code r√©sultant est tr√®s compact et facile √† lire. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Job&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByCustPoolShape</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String poolShape)</span></span></span></span>{ Stream&lt;Job&gt; jobstream = em.createQuery( <span class="hljs-string"><span class="hljs-string">"select object(o) from Job o"</span></span>) .getResultStream(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jobstream.filter( c -&gt; poolShape.equals(c.getCustomerId().getPoolId().getShape())) .collect(Collectors.toList()); }</code> </pre><br>  Comme je l'ai mentionn√© pr√©c√©demment, il est important de se souvenir des performances dans les sc√©narios o√π de grandes quantit√©s de donn√©es sont retourn√©es.  Il existe des conditions dans lesquelles les threads sont plus utiles pour interroger des bases de donn√©es, mais il y a aussi ceux o√π ils peuvent entra√Æner une d√©gradation des performances.  Une bonne r√®gle de base est que si les donn√©es peuvent √™tre interrog√©es dans le cadre d'une requ√™te SQL, il est logique de le faire.  Parfois, les avantages de l'utilisation d'une syntaxe de thread √©l√©gante ne l'emportent pas sur les meilleures performances pouvant √™tre obtenues √† l'aide du filtrage SQL standard. <br><br>  <b>Prise en charge des annotations en double</b> <br><br>  Lorsque Java SE 8 a √©t√© publi√©, des annotations en double sont devenues possibles, vous permettant de r√©utiliser des annotations dans la d√©claration.  Certaines situations n√©cessitent l'utilisation de la m√™me annotation sur une classe ou un champ plusieurs fois.  Par exemple, il peut y avoir plus d'une annotation <code>@SqlResultSetMapping</code> pour une classe d'entit√© donn√©e.  Dans les situations o√π la prise en charge de la r√©-annotation est requise, l'annotation de conteneur doit √™tre utilis√©e.  Les annotations en double r√©duisent non seulement la n√©cessit√© d'encapsuler des collections d'annotations identiques dans des annotations de conteneur, mais peuvent √©galement faciliter la lecture du code. <br><br>  Cela fonctionne comme suit: l'impl√©mentation de la classe d'annotation doit √™tre marqu√©e avec la m√©ta-annotation <code>@Repeatable</code> pour indiquer qu'elle peut √™tre utilis√©e plusieurs fois.  La m√©ta annotation <code>@Repeatable</code> prend le type de la classe d'annotation de conteneur.  Par exemple, la <code>NamedQuery</code> annotation <code>NamedQuery</code> d√©sormais marqu√©e avec l' <code>@Repeatable(NamedQueries.class)</code> .  Dans ce cas, l'annotation de conteneur est toujours utilis√©e, mais vous n'avez pas √† y penser lorsque vous utilisez la m√™me annotation sur la d√©claration ou la classe, car <code>@Repeatable</code> r√©sume ce d√©tail. <br><br>  Nous donnons un exemple.  Si vous souhaitez ajouter plusieurs annotations <code>@NamedQuery</code> √† une classe d'entit√© dans JPA 2.1, vous devez les encapsuler dans l'annotation <code>@NamedQueries</code> , comme indiqu√© dans le Listing 4. <br><br>  <i>Listing 4</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"CUSTOMER"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@XmlRootElement</span></span> <span class="hljs-meta"><span class="hljs-meta">@NamedQueries</span></span>({ <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findAll"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c"</span></span>) , <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findByCustomerId"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c "</span></span> + <span class="hljs-string"><span class="hljs-string">"WHERE c.customerId = :customerId"</span></span>) , <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findByName"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c "</span></span> + <span class="hljs-string"><span class="hljs-string">"WHERE c.name = :name"</span></span>) . . .)}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Customer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ . . . }</code> </pre> <br>  Cependant, dans JPA 2.2, tout est diff√©rent.  √âtant donn√© que <code>@NamedQuery</code> est une annotation en double, elle peut √™tre sp√©cifi√©e dans la classe d'entit√© plusieurs fois, comme indiqu√© dans le listing 5. <br><br>  <i>Listing 5</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"CUSTOMER"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@XmlRootElement</span></span> <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findAll"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findByCustomerId"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c "</span></span> + <span class="hljs-string"><span class="hljs-string">"WHERE c.customerId = :customerId"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findByName"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c "</span></span> + <span class="hljs-string"><span class="hljs-string">"WHERE c.name = :name"</span></span>) . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Customer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ . . . }</code> </pre> <br>  Liste des annotations en double: <br><br><ul><li> <code>@AssociationOverride</code> </li> <li> <code>@AttributeOverride</code> </li> <li> <code>@Convert</code> </li> <li> <code>@JoinColumn</code> </li> <li> <code>@MapKeyJoinColumn</code> </li> <li> <code>@NamedEntityGraphy</code> </li> <li> <code>@NamedNativeQuery</code> </li> <li> <code>@NamedQuery</code> </li> <li> <code>@NamedStoredProcedureQuery</code> </li> <li> <code>@PersistenceContext</code> </li> <li> <code>@PersistenceUnit</code> </li> <li> <code>@PrimaryKeyJoinColumn</code> </li> <li> <code>@SecondaryTable</code> </li> <li> <code>@SqlResultSetMapping</code> </li> </ul><br>  <b>Conclusion</b> <br><br>  La version JPA 2.2 a quelques changements, mais les am√©liorations incluses sont importantes.  Enfin, le JPA est align√© sur Java SE 8, permettant aux d√©veloppeurs d'utiliser des fonctionnalit√©s telles que l'API Date et heure, les r√©sultats de requ√™te en streaming et les annotations r√©p√©t√©es.  Cette version am√©liore √©galement la coh√©rence CDI en ajoutant la possibilit√© d'incorporer des ressources CDI dans les convertisseurs d'attributs.  JPA 2.2 est maintenant disponible et fait partie de Java EE 8, je pense que vous aimerez l'utiliser. <br><br>  LA FIN <br><br>  Comme toujours, nous attendons vos questions et commentaires. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr423195/">https://habr.com/ru/post/fr423195/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr423185/index.html">Ne le mangez pas! Impression de sucre 3D utile</a></li>
<li><a href="../fr423187/index.html">Certificats racine et interm√©diaire des autorit√©s de certification autoris√©es de la Russie</a></li>
<li><a href="../fr423189/index.html">Recherche: la moiti√© des entreprises corrigent des vuln√©rabilit√©s en un mois - pourquoi?</a></li>
<li><a href="../fr423191/index.html">Lancement des √©l√©ments des plateformes offshore. Partie 1</a></li>
<li><a href="../fr423193/index.html">Configurer les notifications Web Push √† l'aide de pywebpush √©tape par √©tape</a></li>
<li><a href="../fr423197/index.html">LOLWUT: une ≈ìuvre d'art dans une √©quipe db</a></li>
<li><a href="../fr423203/index.html">Un chef d'√©quipe cool sera responsable du service</a></li>
<li><a href="../fr423205/index.html">Projet de stockage sur MS SQL Server, int√©gration avec 1C 7.7 et automatisation du d√©veloppement en SSDT</a></li>
<li><a href="../fr423207/index.html">Comment effectuer une mise √† jour automatique d'un client de jeu en ligne</a></li>
<li><a href="../fr423209/index.html">Killer Form 2? Pr√©sentation de l'imprimante 3D dentaire MoonRay S100</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>