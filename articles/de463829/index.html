<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🤝‍👩🏼 ☝🏽 🤚🏾 FreePBX Konfigurieren von Asterisk für E-Mail-Benachrichtigungen über verpasste eingehende Anrufe in der Warteschlange 🥂 ✏️ 🚌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="IP ATC Asterisk ist ein leistungsstarker IP-Telefonieprozessor. Die für Asterisk erstellte webbasierte FreePBX-Oberfläche vereinfacht die Konfiguratio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>FreePBX Konfigurieren von Asterisk für E-Mail-Benachrichtigungen über verpasste eingehende Anrufe in der Warteschlange</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463829/"><img src="https://habrastorage.org/webt/ke/dl/08/kedl08qszm8sgw39uk2zteenbja.png" alt="Bild"><br>  IP ATC Asterisk ist ein leistungsstarker IP-Telefonieprozessor.  Die für Asterisk erstellte webbasierte FreePBX-Oberfläche vereinfacht die Konfiguration erheblich und senkt den Anmeldeschwellenwert. <br>  Wenn Sie eine Aufgabe im Zusammenhang mit IP-Telefonie entwickeln können, kann diese mit ziemlicher Sicherheit in Asterisk implementiert werden.  Aber seien Sie sicher, dass Ausdauer und Ausdauer von Ihnen verlangt werden. <br><br>  Wir standen vor der Aufgabe, E-Mail-Benachrichtigungen über verpasste Anrufe einzurichten.  Genauer gesagt, um per E-Mail über Fälle zu benachrichtigen, in denen ein eingehender Anruf in die Warteschlange gestellt wurde, aber niemand (von den Agenten) diesen eingehenden Anruf beantwortet hat. <br><br>  Überraschenderweise haben wir in FreePBX keine regulären Tools zur Lösung dieses Problems gefunden.  Ich werde darüber sprechen, wie wir dieses Problem unter dem Schnitt gelöst haben. <br><a name="habracut"></a><br>  <b>Vorwort</b> <br><br>  Bevor wir das Problem „frontal“ gelöst haben, haben wir sicherlich im Internet nach Informationen gesucht, aber keine schlüsselfertigen Lösungen gefunden (vielleicht sahen sie schlecht aus, aber was können Sie tun ...). <br><br>  Es gibt nicht so viele Arbeitsfähigkeiten direkt in Asterisk, wie wir möchten, daher wurde die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> vorgeschlagene Lösung nicht vollständig verstanden und verworfen. <br><br>  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> vorgeschlagene Lösung hat mir gefallen, obwohl sie nicht funktioniert hat.  Daher betonten sie, dass die Arbeit in Asterisk im Kontext von [ext-queues] notwendig ist.  Und da wir in Freepbx arbeiten, müssen wir in der Konfigurationsdatei "extensions_override_freepbx.conf" arbeiten.  Wir haben festgestellt, dass es praktisch ist, verpasste Anrufe vor dem Hangupcall-Ereignis (Ende eines Anrufs) abzufangen. <br>  Nachdem wir die Diskussion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> gelesen hatten, kam die Idee auf, dass wir die Variable "Disposition" in der CDR für alle Agenten in der Warteschlange filtern müssen.  Nach dem Lesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser</a> Informationen wurden ganz bestimmte Schritte zur Lösung der Aufgabe gebildet. <br><br>  <b>Was haben wir:</b> <br><br>  Es gibt FreePBX 13.0.197, das Asterisk 13.12.1 verwendet.  Betriebssystemversion SHMZ Release 6.6 (Final).  Die Distribution basiert auf CentOS. <br><br>  Asterisk ist mit IVR (Sprachmenü) konfiguriert, das eingehende Anrufe in verschiedene Warteschlangen (Warteschlangen) verteilt.  Agenten (Agenten) werden jeder Warteschlange zugewiesen, d. H. Agenten. <br><br>  <b>Theorie</b> <br><br>  <b>Was passiert bei Asterisk?</b> <br><br>  Wenn ein eingehender Anruf bei Asterisk eintrifft, geht dieser Anruf an den IVR.  Der Anrufer trifft eine Auswahl, indem er eine bestimmte Nummer am Telefon drückt und eine bestimmte Warteschlange eingibt.  Danach erhalten alle freien Agenten der Warteschlange gleichzeitig einen Anruf. <br><br>  Um besser zu verstehen, was in diesem Moment passiert und was als nächstes passiert, wenden wir uns dem Bericht CDR zu (Abb. 1). <br><br><img src="https://habrastorage.org/webt/sv/qg/86/svqg86ls1ot8x4lcl5syw7oq3w0.png" alt="Bild"><br>  <i>Abb. 1</i> <br><br>  Wenn ein eingehender Anruf in die Warteschlange fiel, wurde für alle Agenten der Wert der Variablen "Disposition" gleich "KEINE ANTWORT", wenn die Agenten zu diesem Zeitpunkt nicht beschäftigt waren.  Die Variable "Disposition" kann andere Werte annehmen (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://asterisk-pbx.ru/wiki/asterisk/cf/cdr</a> ), mit Ausnahme des Werts "ANTWORT".  Und in dem Moment, in dem einer der Agenten den eingehenden Anruf beantwortet, wird der Wert der Variablen "Disposition" dieses Agenten gleich "ANTWORT". <br>  In der Berichts-CDR können Sie feststellen, dass alle Ereignisse mit derselben „eindeutigen ID“ (Systemspalte) angezeigt werden, wenn der Anruf in die Warteschlange gestellt wird (in der Spalte App wird der Wert zu „Warteschlange“). <br><br>  <b>CDR in Kürze</b> <br><br>  Es ist wichtig zu verstehen, was eine CDR ist und zu welchem ​​Zeitpunkt in der CDR die Daten eingegeben werden, die wir in der Berichts-CDR beobachten.  Die CDR ist relativ zum Betriebssystem die Datenbank, in die Asterisk einen detaillierten Anrufbericht schreibt (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://asterisk-pbx.ru/wiki/asterisk/cf/cdr</a> ).  In unserem Fall handelt es sich um eine Datenbank namens asteriskcdrdb, die sich in MySQL befindet.  Empirisch haben wir festgestellt, dass Daten zu einem Anruf mit einer bestimmten „eindeutigen ID“ nicht unmittelbar nach dem Auftreten eines Ereignisses, sondern nach dem Hangupcall-Ereignis (Ende des Anrufs) in asteriskcdrdb eingegeben werden. <br><br>  <b>Das Prinzip der geschaffenen Lösung</b> <br><br>  Da wir mehr Wissen in Bash als Wissen in Asterisk haben, lautet die Hauptidee wie folgt.  Rufen Sie vor dem Hangupcall-Ereignis das Bash-Skript auf.  Übergeben Sie 3 Parameter an dieses Skript.  Der erste Parameter ist "uniqueid", um vom CDR empfangene Daten zu filtern.  Der zweite Parameter ist "CALLERID (num)" (die Nummer des Anrufers), um zu wissen, wen er zurückrufen soll.  Der dritte Parameter ist "NODEST" (Warteschlangennummer), an den der Anruf empfangen wurde, um zu wissen, bei welchem ​​Problem ein Anruf aufgetreten ist und an wen eine E-Mail-Benachrichtigung über einen verpassten Anruf gesendet werden soll. <br>  Das Bash-Skript sollte eine Verbindung zur Datenbank asteriskcdrdb in MySQL herstellen und alle Werte der Variablen "Disposition" mit einer bestimmten "uniqueid" übernehmen.  Von den erhaltenen Daten müssen die Werte "NO ANTWORT", "BUSY", "FAILED", "UNKNOWN" ausgeschlossen werden.  Infolgedessen bleibt entweder "ANTWORT" - sie haben den eingehenden Anruf beantwortet oder gar nichts - der verpasste Anruf. <br><br>  Wenn der Anruf verpasst wurde, sollte das Skript eine E-Mail-Benachrichtigung senden. <br>  Mit Blick auf die Zukunft stelle ich einen wichtigen Punkt fest.  Asterisk führt die Befehle nacheinander aus und wartet auf ihre Ausführung (was im Allgemeinen logisch ist).  Und wir werden das Bash-Skript aufrufen, bevor der Befehl hangupcall ausgeführt wird.  In dem Moment, in dem das Skript direkt ausgeführt wird, werden die Informationen über die gesuchte Uniqueid noch nicht in die CDR eingegeben.  Um dieses Problem zu lösen, rufen wir das Bash-Skript mit dem Parameter "&amp;" auf, sodass Asterisk sofort mit dem nächsten Schritt fortfährt, dh dem Auflegen.  Und innerhalb des Bash-Skripts werden wir zu Beginn eine kleine Zeitverzögerung festlegen, damit Asterisk die Daten mit der für uns interessanten „Uniqueid“ in die CDR eingeben kann. <br><br>  <b>Übe</b> <br><br>  Bevor Sie mit der Konfiguration von Asterisk und der Erstellung eines Bash-Skripts fortfahren, müssen Sie das Senden von E-Mail-Benachrichtigungen konfigurieren.  Dafür verwenden wir das Postfix-Dienstprogramm. <br><br>  <b>Postfix-Setup</b> <br><br>  Wir haben eine Mail-Domain "luck.ru" in Yandex.  Wir werden Postfix im SMTP-Client-Modus konfigurieren und Briefe vom Konto asterisk@lucky.ru senden. <br>  Die Lösung finden Sie hier: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.dmosk.ru/miniinstruktions.php?mini=postfix-over-yandex</a> . <br><br>  Zuerst installieren / aktualisieren / nach Paketen suchen: <br><br><pre><code class="bash hljs">yum install postfix yum install mailx yum install cyrus-sasl cyrus-sasl-lib cyrus-sasl-plain</code> </pre> <br>  Wir werden die Haupt-Postfix-Konfigurationsdatei "/etc/postfix/main.cf" nicht überschreiben, sondern sichern: <br><br><pre> <code class="bash hljs">cp /etc/postfix/main.cf /etc/postfix/main.cf.sav</code> </pre> <br>  Wir bearbeiten die Datei "/etc/postfix/main.cf" und bringen sie in das folgende Formular: <br><br><pre> <code class="bash hljs">nano /etc/postfix/main.cf <span class="hljs-comment"><span class="hljs-comment">##################### relayhost = smtp_sasl_auth_enable = yes smtp_sasl_password_maps = hash:/etc/postfix/private/sasl_passwd smtp_sasl_security_options = noanonymous smtp_sasl_type = cyrus smtp_sasl_mechanism_filter = login smtp_sender_dependent_authentication = yes sender_dependent_relayhost_maps = hash:/etc/postfix/private/sender_relay smtp_generic_maps = hash:/etc/postfix/generic smtp_tls_CAfile = /etc/postfix/ca.pem smtp_use_tls = yes smtputf8_autodetect_classes = all #####################</span></span></code> </pre> <br>  Nicht jede Zeile in "/etc/postfix/main.cf" kann kommentiert werden.  Kommentare in einigen Zeilen werden vom Parser nicht festgelegt und an die Verarbeitung übergeben. Dies führt zu Fehlern.  Es ist besser, Kommentare in dieser Datei abzulehnen.  Sie können damit experimentieren, indem Sie im nächsten Fenster "tail -f / var / log / messages" ausführen. <br><br>  Ich werde die Zeile "smtputf8_autodetect_classes = all" markieren.  Dieser Eintrag enthält standardmäßig utf-8, mit dem Sie das kyrillische Alphabet sowohl im Hauptteil des Buchstabens als auch in der Betreffzeile ohne zusätzliche Manipulationen verwenden können (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://www.postfix.org/SMTPUTF8_README.html</a> ). <br><br>  Erstellen Sie ein Verzeichnis für die Konfigurationsdateien: <br><br><pre> <code class="bash hljs">mkdir /etc/postfix/private</code> </pre> <br>  Wir bearbeiten die Datei "/ etc / postfix / private / sender_relay".  Darin müssen Sie angeben, auf welchen SMTP-Server Sie bei Verwendung unserer Mail-Domain verweisen müssen: <br><br><pre> <code class="bash hljs">nano /etc/postfix/private/sender_relay <span class="hljs-comment"><span class="hljs-comment">##################### @lucky.ru smtp.yandex.ru #####################</span></span></code> </pre> <br>  Wir bearbeiten die Datei "/ etc / postfix / private / sasl_passwd".  Darin geben wir die E-Mail-Adresse an, die wir zum Senden von Briefen verwenden werden, sowie den Benutzernamen und das Passwort für dieses Konto (wir geben den Benutzernamen und das Passwort durch einen Doppelpunkt an): <br><br><pre> <code class="bash hljs">nano /etc/postfix/private/sasl_passwd <span class="hljs-comment"><span class="hljs-comment">##################### asterisk@lucky.ru asterisk@lucky.ru:password_asterisk #####################</span></span></code> </pre> <br>  Bearbeiten der Datei / etc / postfix / generic.  Darin werden wir die Regeln für das Ersetzen der ausgehenden Adresse aufschreiben (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://wiki.merionet.ru/ip-telephoniya/30/postfix-nastrojka-otpravki-pochty-v-asterisk/</a> ): <br><br><pre> <code class="bash hljs">nano /etc/postfix/generic <span class="hljs-comment"><span class="hljs-comment">##################### root asterisk@lucky.ru root@localhost asterisk@lucky.ru root@localhost.localdomain asterisk@lucky.ru root@freepbx asterisk@lucky.ru root@freepbx.localdomain asterisk@lucky.ru root@asterisk asterisk@lucky.ru root@asterisk.localdomain asterisk@lucky.ru asterisk asterisk@lucky.ru asterisk@localhost asterisk@lucky.ru asterisk@localhost.localdomain asterisk@lucky.ru asterisk@freepbx asterisk@lucky.ru asterisk@freepbx.localdomain asterisk@lucky.ru asterisk@asterisk asterisk@lucky.ru asterisk@asterisk.localdomain asterisk@lucky.ru root@localdomain.localdomain asterisk@lucky.ru #####################</span></span></code> </pre> <br>  Die anfängliche Ausgangsadresse hängt vom Inhalt von "/ etc / hosts" und "/ etc / hostname" sowie vom Namen des Benutzers ab, der den Brief senden wird.  Das heißt, trotz der Tatsache, dass wir den SMTP-Client verwenden und Briefe von asterisk@lucky.ru senden, ersetzt postfix zunächst "etwas Eigenes" in die Absenderadresse und dies sollte mit den Regeln aus dieser Konfigurationsdatei korrigiert werden. <br><br>  Ich werde den Inhalt meiner Datei / etc / hosts auflisten: <br><br><pre> <code class="bash hljs">cat /etc/hosts <span class="hljs-comment"><span class="hljs-comment">##################### 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 asterisk.localdomain 127.0.0.1 localhost.localdomain localhost ::1 asterisk localhost localhost6 #####################</span></span></code> </pre> <br>  Es ist wichtig, dass der Server über eine Domäne verfügt (der Wert nach dem Punkt), da das Mail-Dienstprogramm den Domänennamen in "/ etc / hosts" "sucht" und ihn nicht sofort findet, wenn es ihn nicht sofort "findet" erst dann sende einen brief.  Das heißt, wenn die Domain nicht registriert ist, wird der Brief mit einer Verzögerung von einigen Minuten verlassen. <br><br>  Ich werde den Inhalt meiner Datei / etc / hostname auflisten: <br><br><pre> <code class="bash hljs">cat /etc/hostname <span class="hljs-comment"><span class="hljs-comment">##################### asterisk #####################</span></span></code> </pre> <br>  Als Nächstes müssen Sie die erstellten Konfigurationsdateien in indizierte Datenbanken übertragen. Führen Sie dazu den folgenden Befehl aus: <br><br><pre> <code class="bash hljs">postmap /etc/postfix/generic &amp;&amp; postmap /etc/postfix/private/{sasl_passwd,sender_relay}</code> </pre> <br>  Als Nächstes müssen wir das Zertifikat smtp.yandex.ru herunterladen und auf dem Server ablegen. Führen Sie dazu den folgenden Befehl aus: <br><br><pre> <code class="bash hljs">openssl s_client -starttls smtp -crlf -connect smtp.yandex.ru:25 &gt; /etc/postfix/ca.pem</code> </pre> <br>  Nachdem die technischen Informationen auf dem Bildschirm angezeigt werden, bleibt das Team "weiterhin hängen".  Drücken Sie Strg + C, um den Vorgang abzubrechen. <br><br>  Löschen Sie nun manuell den gesamten Müll aus der resultierenden Datei und lassen Sie nur das Zertifikat.  Sie sollten so etwas bekommen: <br><br><pre> <code class="bash hljs">nano /etc/postfix/ca.pem <span class="hljs-comment"><span class="hljs-comment">##################### -----BEGIN CERTIFICATE----- MIIGazCCBVOgAwIBAgIQcUU9mJXW4OUs5Gf0JfLtsjANBgkqhkiG9w0BAQsFADBf ... nRG0DfdqYIuPGApFORYe -----END CERTIFICATE----- #####################</span></span></code> </pre> <br>  Starten Sie schließlich postfix neu: <br><br><pre> <code class="bash hljs">service postfix restart</code> </pre> <br>  Wir senden einen Testbrief: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"  "</span></span> | mail -s <span class="hljs-string"><span class="hljs-string">" "</span></span> admin@lucky.ru</code> </pre> <br>  admin@lucky.ru - Zieladresse <br><br>  Damit ist die Posfix-Konfiguration abgeschlossen. <br><br>  <b>Ein Bash-Skript schreiben</b> <br><br>  Erstellen Sie ein Verzeichnis zum Speichern eines Bash-Skripts (hier gefällt es jemandem wo): <br><br><pre> <code class="bash hljs">mkdir /home/asterisk/scripts</code> </pre> <br>  Erstellen Sie eine Bash-Skriptdatei: <br><br><pre> <code class="bash hljs">touch /home/asterisk/scripts/noanswer.sh</code> </pre> <br>  Wir geben der Skriptdatei die Berechtigung zum Ausführen: <br><br><pre> <code class="bash hljs">chmod +x /home/asterisk/scripts/noanswer.sh</code> </pre> <br>  Wenn Zweifel an den Rechten an der Datei bestehen, können Sie während des Debuggens vollen Zugriff auf die Datei gewähren.  Aber es ist "nicht sicher". <br><br><pre> <code class="bash hljs">chmod 777 /home/asterisk/scripts/noanswer.sh</code> </pre> <br>  Der Text des Bash-Skripts: <br><br><pre> <code class="bash hljs">nano /home/asterisk/scripts/noanswer.sh <span class="hljs-comment"><span class="hljs-comment">##################### #!/bin/bash sleep 7 res_sql="SELECT disposition FROM cdr WHERE uniqueid = '$1'" answer=`mysql -u freepbxuser -pPassword_freepbxuser -D asteriskcdrdb -B -N -e "$res_sql" | grep -E -v "NO ANSWER|BUSY|FAILED|UNKNOWN" | head -n 1` error_kod=0 if [ "$answer" != "ANSWERED" ] then case $3 in 68800) address="big_boss@lucky.ru" subject="  " ;; 63100) address="debian@lucky.ru" subject="  linux debian" ;; 63200) address="windows@lucky.ru" subject="  windows" ;; 63300) address="freebsd@lucky.ru" subject="  freebsd" ;; 63400) address="ubuntu@lucky.ru" subject="  linux ubuntu" ;; 63500) address="centos@lucky.ru" subject="  linux centos" ;; *) address="admin@lucky.ru" error_kod=1 ;; esac case $error_kod in 0) echo "    $2,  $subject." | mail -s "   $2" $address echo "   $address   $2,  $subject. uid=$1" | mail -s "   $2" admin@lucky.ru ;; 1) echo "   $2.  . uid=$1" | mail -s "   $2" admin@lucky.ru ;; esac fi #####################</span></span></code> </pre> <br>  Eine kurze Analyse des Skripts: <br>  "Schlaf 7": <br><br>  Dies ist die gleiche Zeitverzögerung, über die ich früher geschrieben habe.  Wir haben eine Verzögerung von 7 Sekunden.  Obwohl ich denke, eine Sekunde ist genug. <br><br><pre> <code class="sql hljs">«res_sql="<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> disposition <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> cdr <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> uniqueid = <span class="hljs-string"><span class="hljs-string">'$1'</span></span><span class="hljs-string"><span class="hljs-string">"»:</span></span></code> </pre> <br>  Die Abfrage in MySQL haben wir der Einfachheit halber in eine separate Variable eingefügt. <br><br>  Als nächstes stellen wir eine Anfrage in MySQL und filtern die resultierende Ausgabe.  Wir entfernen alle Optionen außer "ANTWORT", falls vorhanden.  Wenn es mehrere "ANTWORTEN" -Werte gibt, sollte nur einer übrig bleiben.  Am Ende erhalten wir in der Variablen "Antwort" entweder "ANTWORT" oder "". <br>  Wenn der Wert der Antwortvariablen nicht gleich ANTWORT ist, handelt es sich um einen verpassten Anruf.  Abhängig von der Warteschlangennummer legen wir mithilfe des Falloperators die Adresse fest, an die eine E-Mail-Benachrichtigung gesendet werden muss, und was in diese Nachricht geschrieben werden soll (variabler Teil der Nachricht). <br><br>  Das Folgende ist eine Option, wenn die Warteschlange in Asterisk festgelegt, aber nicht im Skript beschrieben ist.  In diesem Fall erhält admin@lucky.ru einen Brief, in dem angegeben wird, dass die Warteschlange dem Skript nicht bekannt ist. <br><br>  Wenn die Warteschlange beschrieben ist, werden ein Zielbrief und ein doppelter Brief an admin@lucky.ru gesendet, in denen "uniqueid" angegeben ist, damit Sie bei Bedarf Ereignisse bei diesem Anruf verfolgen können. <br><br>  Damit ist das Skript beendet. <br><br>  Ich stelle fest, dass wir für die Verbindung zu MySQL den Benutzernamen und das Passwort verwendet haben, die wir im Voraus erkannt haben.  Führen Sie in FreePBX den folgenden Befehl aus, um die Asterisk-Benutzeranmeldung in MySQL herauszufinden. <br><br><pre> <code class="bash hljs">cat /etc/amportal.conf | grep AMPDBUSER</code> </pre> <br>  Führen Sie den folgenden Befehl aus, um das Kennwort des Asterisk-Benutzers in MySQL herauszufinden. <br><br><pre> <code class="bash hljs">cat /etc/amportal.conf | grep AMPDBPASS</code> </pre> <br>  <b>Konfigurieren Sie Asterisk</b> <br><br>  Wir benutzen FreePBX.  FreePBX verfügt über verschiedene Arten von Konfigurationsdateien (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://asterisk-pbx.ru/wiki/freepbx/files</a> ). Einige davon werden beim Neustart von FreePBX überschrieben, andere werden nicht überschrieben (sie werden als benutzerdefiniert bezeichnet), da sie speziell entwickelt wurden für den Benutzer. <br><br>  Wir werden mit der Konfigurationsdatei "extensions_override_freepbx.conf" arbeiten, da diese vom Typ custom ist. <br><br>  Stellen Sie zunächst sicher, dass die Datei "extensions_override_freepbx.conf" mit der Datei "/etc/asterisk/extensions.conf" verbunden ist.  Führen Sie dazu den folgenden Befehl aus: <br><br><pre> <code class="bash hljs">cat /etc/asterisk/extensions.conf | grep extensions_override_freepbx.conf <span class="hljs-comment"><span class="hljs-comment">##################### #include extensions_override_freepbx.conf #####################</span></span></code> </pre> <br>  Wir bearbeiten die Datei "/etc/asterisk/extensions_override_freepbx.conf" und bringen sie in das folgende Formular: <br><br><pre> <code class="bash hljs">nano /etc/asterisk/extensions_override_freepbx.conf <span class="hljs-comment"><span class="hljs-comment">##################### [ext-queues] exten =&gt; h,1,System(/home/asterisk/scripts/noanswer.sh ${CDR(uniqueid)} ${CALLERID(num)} ${NODEST} &amp;) exten =&gt; h,2,Macro(hangupcall,) #####################</span></span></code> </pre> <br>  Wie ich bereits geschrieben habe, ist das Symbol "&amp;" am Ende erforderlich.  Da wir in einem Bash-Skript mit CDR-Daten direkt aus der MySQL-Datenbank arbeiten und diese Daten erst nach Ausführung von „exten =&gt; h, 2, Macro (hangupcall,)“ in MySQL eingegeben werden, müssen wir nicht auf den Abschluss des Bash-Skripts warten und fahren Sie mit dem nächsten Schritt in Asterisk fort.  Und das Bash-Skript selbst muss eine Zeitverzögerung enthalten, bevor es seinen Hauptteil ausführt. <br><br>  Damit die Änderungen in der Konfigurationsdatei "/etc/asterisk/extensions_override_freepbx.conf" wirksam werden, müssen Sie den Asterisk-Kernel mit dem folgenden Befehl neu starten: <br><br><pre> <code class="bash hljs">/usr/sbin/asterisk -rx <span class="hljs-string"><span class="hljs-string">"core restart now"</span></span></code> </pre> <br>  Dies muss erfolgen, nachdem das Bash-Skript erstellt wurde. <br><br>  <b>Fazit</b> <br><br>  Dies ist wahrscheinlich die 1001. Möglichkeit, verpasste Anrufe in Asterisk abzufangen.  Teilen Sie in den Kommentaren mit, wie Sie dieses Problem lösen.  Und was kann Ihrer Meinung nach verbessert / erneuert / optimiert werden?  Wir werden für die konstruktiven Ideen dankbar sein. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463829/">https://habr.com/ru/post/de463829/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463817/index.html">20 Produktmanager und die mehrdimensionalste Matrixstruktur von allen. Gespräch mit Skyeng</a></li>
<li><a href="../de463819/index.html">PostgreSQL-Sperren: 2. String-Sperren</a></li>
<li><a href="../de463821/index.html">AMO, Bitrix, 1C und andere: Wie wählt man aus, wo man anfangen soll?</a></li>
<li><a href="../de463823/index.html">Rust 1.37.0 Release: Profilgesteuerte Optimierung, unbenannte Konstanten und Frachtanbieter</a></li>
<li><a href="../de463825/index.html">Google Sheets-Projektmanagement-Tool</a></li>
<li><a href="../de463831/index.html">Was ist los mit IT-Ausbildung in Russland</a></li>
<li><a href="../de463833/index.html">Eine kleine Umfrage zu Blockern</a></li>
<li><a href="../de463835/index.html">Dieses gefährliche IoT: Geschäftsbedrohungen und -lösungen</a></li>
<li><a href="../de463839/index.html">Museum DataArt. Lunolet und sowjetische Taschenrechner</a></li>
<li><a href="../de463845/index.html">Telegramm, wer ist das?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>