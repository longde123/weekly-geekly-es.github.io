<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆕 👩🏽‍💻 👨🏽‍⚕️ PIM-Prinzipien 👩🏾‍⚖️ 🌄 🅾️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das PIM-Protokoll ist eine Reihe von Protokollen zum Übertragen von Multicast in einem Netzwerk zwischen Routern. Nachbarschaftsbeziehungen werden auf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PIM-Prinzipien</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450582/"> Das PIM-Protokoll ist eine Reihe von Protokollen zum Übertragen von Multicast in einem Netzwerk zwischen Routern.  Nachbarschaftsbeziehungen werden auf die gleiche Weise aufgebaut wie bei dynamischen Routing-Protokollen.  PIMv2 sendet alle 30 Sekunden Hello-Nachrichten an die reservierte Multicast-Adresse 224.0.0.13 (All-PIM-Router).  Die Nachricht enthält Hold-Timer - normalerweise 3,5 * Hallo Timer, das sind standardmäßig 105 Sekunden. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/e67/8a0/1fc/e678a01fc7879ecf22bc6f9a3825f9a6.jpg" alt="Mein Bild"></a> <br>  PIM verwendet zwei Hauptbetriebsarten - Dense- und Sparse-Modus.  Beginnen wir mit dem Dichtemodus. <a name="habracut"></a><br>  <b>Quellbasierte Verteilungsbäume.</b> <br>  Der Dense-Mode-Modus empfiehlt sich bei einer großen Anzahl von Clients verschiedener Multicast-Gruppen.  Wenn ein Router Multicast-Verkehr empfängt, überprüft er ihn zunächst auf die RPF-Regel.  RPF - Diese Regel wird verwendet, um die Quelle eines Multicasts mit einer Unicast-Routing-Tabelle zu überprüfen.  Es ist erforderlich, dass der Datenverkehr an die Schnittstelle gelangt, hinter der dieser Host gemäß der Version der Unicast-Routing-Tabelle versteckt ist.  Dieser Mechanismus löst das Problem des Auftretens von Schleifen während der Multicast-Übertragung. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/6cd/08c/fb6/6cd08cfb6842680447d56860334af52c.png" alt="Mein Bild"></a> <br>  R3 aus der Multicast-Nachricht erkennt die Quelle des Multicast (Quell-IP) und überprüft die beiden Streams von R1 und R2 aus seiner Unicast-Tabelle.  Der Stream von der in der Tabelle angegebenen Schnittstelle (R1 bis R3) wird weiter übertragen, und der Stream von R2 wird gelöscht, da zum Senden an die Quelle des Multicasts Pakete über S0 / 1 gesendet werden müssen. <br>  Die Frage ist, was passiert, wenn Sie zwei äquivalente Routen mit derselben Metrik haben?  In diesem Fall wählt der Router den nächsten Hop für diese Routen.  Wer eine höhere IP-Adresse hat, hat gewonnen.  Wenn Sie dieses Verhalten ändern müssen, können Sie ECMP verwenden.  Weitere Details <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br>  Nach Überprüfung der RPF-Regel sendet der Router ein Multicast-Paket an alle seine PIM-Nachbarn, mit Ausnahme desjenigen, von dem das Paket empfangen wurde.  Andere PIM-Router wiederholen diesen Vorgang.  Der Pfad, den ein Multicast-Paket von der Quelle an die endgültigen Empfänger übergeben hat, bildet einen Baum, der als quellenbasierter Verteilungsbaum, SPT (Shortest Path Tree) und Quellbaum bezeichnet wird.  Drei verschiedene Namen, wählen Sie einen. <br>  So lösen Sie das Problem mit der Tatsache, dass einige Router keinen Multicast-Stream aufgegeben haben und niemand ihn senden kann und der übergeordnete Router ihn sendet.  Dafür wurde der Prune-Mechanismus erfunden. <br>  <b>Nachricht beschneiden.</b> <br>  Zum Beispiel sendet R2 weiterhin R3-Multicast, obwohl R3 es nach der RPF-Regel löscht.  Warum den Kanal laden?  R3 sendet eine PIM-Prune-Nachricht und R2 entfernt beim Empfang dieser Nachricht die S0 / 1-Schnittstelle aus der Liste der ausgehenden Schnittstellen für diesen Stream, der Liste der Schnittstellen, von denen dieser Datenverkehr gesendet werden soll. <br><blockquote>  Das Folgende ist eine formellere Definition einer PIM Prune-Nachricht: <br>  Die PIM-Prune-Nachricht wird von einem Router an einen zweiten Router gesendet, damit der zweite Router die Verbindung entfernt, über die der Prune von einem bestimmten (S, G) SPT empfangen wird. </blockquote><br>  Nach dem Empfang der Prune-Nachricht setzt R2 den Prune-Timer auf 3 Minuten.  Nach drei Minuten wird erneut Datenverkehr gesendet, bis die nächste Prune-Nachricht empfangen wird.  Dies ist in PIMv1. <br>  In PIMv2 wird der Statusaktualisierungs-Timer hinzugefügt (standardmäßig 60 Sekunden).  Sobald eine Prune-Nachricht von R3 gesendet wurde, startet dieser Timer auf R3.  Nach Ablauf dieses Timers sendet R3 eine Statusaktualisierungsnachricht, die den 3-Minuten-Prune-Timer für diese Gruppe auf R2 zurücksetzt. <br>  Gründe für das Senden einer Prune-Nachricht: <br><ul><li>  Wenn ein Multicast-Paket eine RPF-Prüfung nicht bestanden hat. </li><li>  Wenn keine lokal verbundenen Clients eine Multicast-Gruppe (IGMP-Join) angefordert haben und keine PIM-Nachbarn vorhanden sind, an die Multicast-Verkehr (Non-Prune-Schnittstelle) gesendet werden kann. </li></ul><br>  <b>Transplantationsnachricht.</b> <br>  Stellen Sie sich vor, R3 wollte keinen Datenverkehr von R2, hat Prune gesendet und Multicast von R1 empfangen.  Aber plötzlich fiel der Kanal zwischen R1-R3 und R3 ohne Multicast.  Sie können 3 Minuten warten, bis der Prune Timer auf R2 abläuft.  3 Minuten, um eine lange Zeit zu warten, um nicht zu warten, müssen Sie eine Nachricht senden, die diese Schnittstelle S0 / 1 auf R2 sofort aus dem beschnittenen Zustand anzeigt.  Diese Nachricht ist eine Transplantationsnachricht.  Nach dem Empfang der Graft-Nachricht sendet R2 als Antwort eine Graft-ACK. <br>  <b>Prune Override.</b> <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/bc7/1d0/e9f/bc71d0e9f81b292e75d4a016a9b657ef.png" alt="Mein Bild"></a> <br>  Schauen wir uns dieses Schema an.  R1 sendet Multicast in einem Segment mit zwei Routern.  R3 empfängt und sendet Verkehr, R2 empfängt, aber es gibt niemanden, der Verkehr sendet.  Es sendet eine Prune-Nachricht an R1 in diesem Segment.  R1 sollte Fa0 / 0 aus der Liste entfernen und die Übertragung in diesem Segment beenden, aber was passiert mit R3?  Und R3 ist im selben Segment, er erhielt auch diese Nachricht von Prune und erkannte die Tragödie der Situation.  Bevor R1 die Übertragung beendet, stellt es den Timer auf 3 Sekunden ein und beendet die Übertragung nach 3 Sekunden.  3 Sekunden - nur so viel Zeit für R3, um Ihren Multicast nicht zu verlieren.  Daher sendet R3 so schnell wie möglich eine Pim Join-Nachricht für diese Gruppe, und R1 denkt nicht mehr daran, die Übertragung zu beenden.  Über Beiträge unten beitreten. <br>  <b>Nachricht bestätigen.</b> <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/f1d/9d1/d68/f1d9d1d6855fdc188deb28c75bde2d0d.png" alt="Mein Bild"></a> <br>  Stellen Sie sich diese Situation vor: Zwei Router senden gleichzeitig an dasselbe Netzwerk.  Sie empfangen denselben Stream von der Quelle und senden ihn beide an dasselbe Netzwerk hinter der e0-Schnittstelle.  Daher müssen sie bestimmen, wer der einzige einzelne Sender für dieses Netzwerk sein wird.  Hierfür werden Assert-Meldungen verwendet.  Wenn R2 und R3 eine Verdoppelung des Multicast-Verkehrs erkennen, dh Multicast, den sie auf R2 und R3 senden, die sie selbst senden, verstehen die Router, dass hier etwas nicht stimmt.  In diesem Fall senden die Router Assert-Nachrichten, die die administrative Entfernung und die Routenmetrik enthalten, über die die Multicast-Quelle erreicht wird - 10.1.1.10.  Der Gewinner wird wie folgt ermittelt: <br><ol><li>  Der mit niedrigerem AD. </li><li>  Wenn AD gleich ist, wer hat dann die niedrigere Metrik? </li><li>  Wenn es Gleichheit gibt, dann die mit einer höheren IP in dem Netzwerk, an das sie diesen Multicast senden. </li></ol><br>  Wenn Sie diese Abstimmung gewinnen, wird der Router zum Designated Router.  Pim Hello wird auch zur Auswahl von DR verwendet.  Zu Beginn des Artikels wurde eine PIM-Hallo-Nachricht angezeigt, dort können Sie das DR-Feld erkennen.  Der Gewinner ist derjenige mit einer höheren IP-Adresse auf diesem Link. <br>  Nützlicher Teller: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/3de/e1a/c84/3dee1ac8448b1fceaa9f1972eff802b7.png" alt="Mein Bild"></a> <br>  <b>MROUTE-Tabelle.</b> <br>  Nach der ersten Überprüfung der Funktionsweise des PIM-Protokolls müssen wir herausfinden, wie mit der Multicast-Routing-Tabelle gearbeitet wird.  In der Mroute-Tabelle werden Informationen darüber gespeichert, welche Streams von Clients angefordert wurden und welche Streams von Multicast-Servern stammen. <br>  Wenn Sie beispielsweise auf einer Schnittstelle einen IGMP-Mitgliedschaftsbericht oder einen PIM-Join erhalten, wird der Routing-Tabelle ein Eintrag vom Typ (*, G) hinzugefügt: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/afd/3ed/52c/afd3ed52cef0f9f105a0b58dff18edee.jpg" alt="Mein Bild"></a> <br>  Dieser Eintrag bedeutet, dass eine Verkehrsanforderung mit der Adresse 238.38.38.38 empfangen wurde.  Das DC-Flag bedeutet, dass der Multicast im dichten Modus arbeitet, und C bedeutet, dass der Empfänger direkt mit dem Router verbunden ist, dh der Router hat den IGMP-Mitgliedschaftsbericht und PIM Join erhalten. <br>  Wenn es einen Datensatz wie (S, G) gibt, bedeutet dies, dass wir einen Multicast-Stream haben: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/a78/cf2/332/a78cf23325ddc6e0c3d65322340d7ff6.jpg" alt="Mein Bild"></a> <br>  Im Feld S - 192.168.1.11 haben wir die IP-Adresse der Multicast-Quelle registriert, diese wird von der RPF-Regel überprüft.  Bei Problemen überprüfen Sie zunächst die Unicast-Tabelle auf die Route zur Quelle.  Im Feld Eingehende Schnittstelle wird die Schnittstelle angegeben, an der der Multicast ankommt.  In der Unicast-Routing-Tabelle muss sich die Route zur Quelle auf die hier angegebene Schnittstelle beziehen.  Die ausgehende Schnittstelle gibt an, wohin der Multicast umgeleitet wird.  Wenn es leer ist, gab es keine Anforderungen für diesen Datenverkehr an den Router.  Weitere Informationen zu allen Flags finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br>  <b>PIM Sparse-Modus.</b> <br>  Die Sparse-Mode-Strategie ist das Gegenteil von Dense-Mode.  Wenn der Sparse-Modus Multicast-Verkehr empfängt, sendet er Verkehr nur über die Schnittstellen, an denen Anforderungen für diesen Stream aufgetreten sind, z. B. Pim Join- oder IGMP-Berichtsnachrichten, die diesen Verkehr anfordern. <br>  Ähnliche Elemente für SM und DM: <br><ul><li>  Nachbarschaftsbeziehungen werden auf die gleiche Weise wie in PIM DM aufgebaut. </li><li>  Die RPF-Regel funktioniert. </li><li>  Die Wahl von DR ist ähnlich. </li><li>  Die Prune Overrides-Engine und die Assert-Meldungen sind ähnlich. </li></ul><br>  Um zu steuern, wer wo, wo und welchen Multicast-Verkehr im Netzwerk benötigt wird, wird ein gemeinsames Informationszentrum benötigt.  Ein solches Zentrum haben wir Rendezvous Point (RP).  Jeder, der eine Art Multicast-Verkehr wünscht oder jemand hat begonnen, Multicast-Verkehr von der Quelle zu empfangen, sendet ihn dann an das RP. <br>  Wenn der RP Multicast-Verkehr empfängt, sendet er ihn an die Router, die diesen Verkehr zuvor angefordert haben. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/025/d45/651/025d4565117dce5f8da07609c823c63e.jpg" alt="Mein Bild"></a> <br>  Stellen Sie sich eine solche Topologie vor, in der RP R3 ist.  Sobald R1 Verkehr von S1 empfängt, kapselt es dieses Multicast-Paket in eine Unicast-PIM-Registernachricht und sendet es an RP.  Woher weiß er, wer RP ist?  In diesem Fall ist es statisch konfiguriert, und wir werden später über die dynamische RP-Optimierung sprechen. <br><blockquote>  IP-PIM-RP-Adresse 3.3.3.3 </blockquote><br>  RP wird schauen - gab es irgendwelche Informationen von jemandem, der diesen Verkehr erhalten möchte?  Angenommen, es war nicht so.  Dann sendet RP R1 eine PIM-Register-Stop-Nachricht, was bedeutet, dass niemand diesen Multicast benötigt. Die Registrierung wird abgelehnt.  R1 sendet keine Multicasts.  Die Multicast-Quelle sendet sie jedoch, sodass R1 nach dem Empfang von Register-Stop den Register-Suppression-Timer startet, der 60 Sekunden beträgt.  5 Sekunden vor Ablauf des Timers sendet R1 eine leere Registernachricht mit einem Null-Register-Bit (dh ohne ein gekapseltes Multicast-Paket) an die RP-Seite.  RP wird sich wiederum so verhalten: <br><ul><li>  Wenn es keine und keine Empfänger gab, antwortet es mit einer Register-Stop-Nachricht. </li><li>  Wenn die Empfänger erschienen sind, wird er ihm in keiner Weise antworten.  R1, der innerhalb von 5 Sekunden keine Ablehnung seiner Registrierung erhalten hat, wird begeistert sein und eine Nachricht mit dem gekapselten Multicast an RP senden. </li></ul><br>  Wenn der Multicast das RP erreicht, scheint er aussortiert zu sein. Versuchen wir nun, die Frage zu beantworten, wie das RP den Empfängern Datenverkehr bringt.  Hier müssen Sie ein neues Konzept einführen - Root-Path Tree (RPT).  Ein RPT ist ein Baum mit einer Wurzel im RP, die zu den Empfängern wächst, die auf jedem PIM-SM-Router verzweigen.  RP erstellt es durch Empfang von PIM Join-Nachrichten und fügt dem Baum einen neuen Zweig hinzu.  Und jeder nachgeschaltete Router auch.  Die allgemeine Regel sieht folgendermaßen aus: <br><ul><li>  Wenn ein PIM-SM-Router auf einer beliebigen Schnittstelle eine PIM-Join-Nachricht empfängt, mit Ausnahme der Schnittstelle, hinter der der RP verborgen ist, fügt er dem Baum einen neuen Zweig hinzu. </li><li>  Ein Zweig wird auch hinzugefügt, wenn der PIM-SM-Router einen IGMP-Mitgliedschaftsbericht von einem direkt verbundenen Host empfängt. </li></ul><br>  Stellen Sie sich vor, wir haben einen Multicast-Client auf dem R5-Router für Gruppe 228.8.8.8.  Sobald R5 einen IGMP-Mitgliedschaftsbericht vom Host erhält, sendet R5 einen PIM-Join in Richtung RP und fügt dem Baum selbst eine Schnittstelle hinzu, die den Host betrachtet.  Als nächstes empfängt R4 einen PIM-Join von R5, fügt die Gi0 / 1-Schnittstelle zum Baum hinzu und sendet den PIM-Join in Richtung RP.  Schließlich empfängt RP (R3) einen PIM-Join und fügt dem Baum Gi0 / 0 hinzu.  Somit wird die Registrierung des Multicast-Empfängers erhalten.  Wir bauen einen Baum mit der Wurzel R3-Gi0 / 0 → R4-Gi0 / 1 → R5-Gi0 / 0. <br>  Danach wird PIM Join an R1 gesendet und R1 beginnt mit dem Senden von Multicast-Verkehr.  Es ist wichtig zu beachten, dass, wenn der Host vor Beginn der Multicast-Übertragung Datenverkehr angefordert hat, der RP keinen PIM-Join sendet und überhaupt nichts an die R1-Seite sendet. <br>  Wenn der Host plötzlich während des Sendens eines Multicasts aufhört, ihn zu empfangen, sobald der RP PIM Prune auf der Gi0 / 0-Schnittstelle empfängt, sendet er sofort den PIM Register-Stop direkt an R1 und dann die PIM Prune-Nachricht über die Gi0 / 1-Schnittstelle.  PIM Register-Stop wird von Unicast an die Adresse gesendet, von der das PIM Register angekommen ist. <br>  Wie bereits erwähnt, wird R4 ein Eintrag hinzugefügt, sobald der Router einen PIM-Join an einen anderen sendet, z. B. R5 auf R4: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/9f7/730/678/9f7730678743efb4e9670d18fcd54525.jpg" alt="Mein Bild"></a> <br>  Und der Timer startet, dass R5 zum Zurücksetzen dieses Timers ständig PIM-Join-Nachrichten senden muss, sonst wird R4 von der ausgehenden Liste ausgeschlossen.  R5 sendet alle 60 PIM Join-Nachrichten. <br>  <b>Baumumschaltung mit kürzestem Pfad.</b> <br>  Wir werden eine Schnittstelle zwischen R1 und R5 hinzufügen, um zu sehen, wie der Verkehr mit dieser Topologie fließen wird. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/afd/113/eb0/afd113eb01e7deda4c389fbb1a02060a.jpg" alt="Mein Bild"></a> <br>  Angenommen, der Datenverkehr wurde gemäß dem alten Schema R1-R2-R3-R4-R5 gesendet und empfangen, und hier haben wir die Schnittstelle zwischen R1 und R5 verbunden und konfiguriert. <br>  Zunächst müssen wir die Unicast-Routing-Tabelle auf R5 neu erstellen, und jetzt wird das Netzwerk 192.168.1.0/24 über die R5 Gi0 / 2-Schnittstelle erreicht.  Wenn R5 nun einen Multicast auf der Gi0 / 1-Schnittstelle empfängt, versteht er, dass die RPF-Regel nicht erfüllt ist und es logischer wäre, einen Multicast auf Gi0 / 2 zu empfangen.  Es sollte die Verbindung zum RPT trennen und einen kürzeren Baum erstellen, der als Shortest-Path Tree (SPT) bezeichnet wird.  Zu diesem Zweck sendet er über Gi0 / 2 einen PIM-Join an R1 und R1 beginnt, Multicasts auch über Gi0 / 2 zu senden.  Jetzt muss sich R5 vom RPT abmelden, um nicht zwei Kopien zu erhalten.  Dazu sendet er eine Prune-Nachricht, die die IP-Adresse der Quelle angibt und ein spezielles Bit einfügt - RPT-Bit.  Dies bedeutet, dass ich keinen Datenverkehr senden muss. Ich habe hier einen besseren Baum.  Der RP sendet auch Nachrichten an die R1 PIM Prune-Seite, sendet jedoch keine Register-Stop-Nachricht.  Ein weiteres Feature: R5 sendet nun ständig PIM Prune an RP, da R1 weiterhin jede Minute PIM Register an RP sendet.  RP, bis es neue Leute gibt, die diesen Verkehr wünschen, wird ihn ablehnen.  R5 benachrichtigt den RP, dass er weiterhin Multicast über SPT empfängt. <br>  <b>Dynamische RP-Suche.</b> <b><br></b>  <b>Auto-RP</b> <br>  Diese Technologie ist proprietär von Cisco und nicht besonders beliebt, aber noch am Leben.  Auto-RP besteht aus zwei Hauptschritten: <br>  1) RP sendet RP-Announce-Nachrichten an die reservierte Adresse - 224.0.1.39 und deklariert sich selbst als RP für alle oder für bestimmte Gruppen.  Diese Nachricht wird jede Minute gesendet. <br>  2) Es ist ein RP-Mapping-Agent erforderlich, der RP-Discovery-Nachrichten sendet, die angeben, für welche Gruppen welche RP abgehört werden sollen.  Aus dieser Nachricht bestimmen gewöhnliche PIM-Router den RP für sich.  Der Mapping Agent kann entweder der RP-Router selbst oder ein separater PIM-Router sein.  RP-Discovery wird mit einem Timer von einer Minute an die Adresse 224.0.1.40 gesendet. <br>  Schauen wir uns den Prozess genauer an: <br>  Stellen Sie R3 als RP ein: <br><blockquote>  IP PIM Send-RP-Announce Loopback 0 Bereich 10 </blockquote><br>  R2 als Mapping-Agent: <br><blockquote>  IP PIM Send-RP-Discovery Loopback 0 Bereich 10 </blockquote><br>  Und bei allen anderen erwarten wir RP durch Auto-RP: <br><blockquote>  IP PIM Autorp Listener </blockquote><br>  Sobald wir R3 konfiguriert haben, wird RP-Announce gesendet: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/aae/ae2/565/aaeae25659fbacd4ba49ae4c5486f46f.jpg" alt="Mein Bild"></a> <br>  Und R2 wartet nach dem Einrichten des Mapping-Agenten auf die RP-Announce-Nachricht.  Erst wenn er mindestens ein RP findet, sendet er RP-Discovery: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/fb8/e44/7c2/fb8e447c26e33ecda18cb82c5f05c938.jpg" alt="Mein Bild"></a> <br>  Sobald reguläre Router (PIM RP Listener) diese Nachricht erhalten, wissen sie, wo sie nach dem RP suchen müssen. <br>  Eines der Hauptprobleme von Auto-RP besteht darin, dass Sie zum Empfangen von RP-Announce- und RP-Discovery-Nachrichten PIM Join an die Adressen 224.0.1.39-40 senden müssen und zum Senden wissen müssen, wo sich das RP befindet.  Das klassische Problem von Huhn und Eiern.  Um dieses Problem zu lösen, wurde der PIM Sparse-Dense-Mode erfunden.  Wenn der Router RP nicht kennt, arbeitet er im Dichtemodus, wenn er es weiß, im Sparse-Modus.  Wenn der PIM-Sparse-Modus und der Befehl ip pim autorp listener auf den Schnittstellen normaler Router konfiguriert sind, arbeitet der Router im Dense-Modus nur für das Multicast-Direkt-Auto-RP-Protokoll (224.0.1.39-40). <br>  <b>BootStrap Router (BSR).</b> <br>  Diese Funktion funktioniert ähnlich wie Auto-RP.  Jeder RP sendet eine Mapping-Agent-Nachricht, die Mapping-Informationen sammelt und dann alle anderen Router informiert.  Wir beschreiben den Prozess ähnlich wie bei Auto-RP: <br>  1) Sobald wir R3 als Kandidaten für ein RP konfiguriert haben, lautet der Befehl: <br><blockquote>  ip pim rp-Kandidat Loopback 0 </blockquote><br>  Daß R3 nichts unternimmt, um spezielle Nachrichten zu senden, muss er zunächst einen Mapping-Agenten finden.  Damit gehen wir zum zweiten Schritt über. <br>  2) Konfigurieren Sie R2 als Mapping-Agent: <br><blockquote>  ip pim bsr-Kandidat Loopback 0 </blockquote><br>  R2 beginnt mit dem Senden von PIM-Bootstrap-Nachrichten, wobei es sich als Mapping-Agent ausgibt: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/729/3a4/ad1/7293a4ad164ed8342ff42ceffee9a32b.jpg" alt="Mein Bild"></a> <br>  Diese Nachricht wird an die Adresse 224.0.013 gesendet, die das PIM-Protokoll für seine anderen Nachrichten verwendet.  Er schickt sie in alle Richtungen und daher gibt es kein Problem mit Hühnchen und Eiern, wie es bei Auto-RP der Fall war. <br>  3) Sobald der RP eine Nachricht vom BSR des Routers empfängt, sendet er sofort eine Unicast-Nachricht an die Adresse des BSR des Routers: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/5ed/217/8c1/5ed2178c151886f79c1e6197b9b5385b.jpg" alt="Mein Bild"></a> <br>  Wenn der BSR danach Informationen über den RP empfängt, sendet er diese mit Multicast an die Adresse 224.0.0.13, die alle PIM-Router abhören.  Daher gibt es kein Analogon zum <i>Befehl ip pim autorp listener</i> für reguläre Router in BSR. <br>  <b>Anycast RP mit Multicast Source Discovery Protocol (MSDP).</b> <br>  Mit Auto-RP und BSR können wir die Last auf das RP wie folgt verteilen: Jede Multicast-Gruppe hat nur ein aktives RP.  Es funktioniert nicht, die Lastverteilung für eine Multicast-Gruppe auf mehrere RP zu beschränken.  MSDP gibt dazu RP-Routern dieselbe IP-Adresse mit einer Maske von 255.255.255.255 aus.  MSDP erkennt Informationen mithilfe einer der folgenden Methoden: statisch, Auto-RP oder BSR. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/406/51a/032/40651a032dadaaf6e0c51cbf06c3fbf3.png" alt="Mein Bild"></a> <br>  Im Bild haben wir eine Auto-RP-Konfiguration mit MSDP.  Beide RPs sind mit der IP-Adresse 172.16.1.1/32 auf der Loopback 1-Schnittstelle konfiguriert und werden für alle Gruppen verwendet.  Bei RP-Announce sprechen beide Router über sich selbst und beziehen sich auf diese Adresse.  Nachdem der Auto-RP-Mapping-Agent Informationen erhalten hat, sendet er RP-Discovery über das RP mit der Adresse 172.16.1.1/32.  Über das Netzwerk 172.16.1.1/32 teilen wir Routern mit, die IGP bzw. verwenden.  Somit fordern oder registrieren PIM-Router Flüsse von dem RP, der als nächster Sprung auf der Route zum Netzwerk 172.16.1.1/32 angegeben ist.  Das MSDP-Protokoll selbst ist so konzipiert, dass die RPs selbst Multicast-Informationsnachrichten austauschen. <br>  Betrachten Sie die folgende Topologie: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/2ba/f2d/dc4/2baf2ddc4deb54ebb671a6fb52282a41.jpg" alt="Mein Bild"></a> <br>  Switch6 sendet Datenverkehr an die Adresse 238.38.38.38, und bisher weiß nur RP-R1 davon.  Hier haben Switch7 und Switch8 diese Gruppe angefordert.  Die Router R5 und R4 senden PIM Join an R1 bzw. R3.  Warum?  Die Route bis 13.13.13.13 auf R5 bezieht sich auf R1 gemäß der IGP-Metrik wie auf R4. <br>  RP-R1 kennt den Stream und sendet ihn in Richtung R5, aber R4 weiß nichts darüber, da R1 ihn einfach nicht sendet.  Daher ist MSDP erforderlich.  Wir konfigurieren es auf R1 und R5: <br><blockquote>  ip msdp peer 3.3.3.3 Verbindungsquelle Loopback1 auf R1 </blockquote><br><blockquote>  ip msdp peer 1.1.1.1 Verbindungsquelle Loopback3 auf R3 </blockquote><br>  Sie werden eine Sitzung untereinander auslösen und beim Empfang eines Streams dies ihrem RP-Nachbarn melden. <br>  Sobald RP-R1 den Stream von Switch6 empfängt, sendet es Unicast MSDP Source-Active sofort eine Nachricht, die Informationen wie (S, G) enthält - Informationen über die Quelle und das Ziel des Multicasts.  Wenn RP-R3 weiß, dass eine Quelle wie Switch6 eine Anforderung von R4 für diesen Stream empfängt, sendet sie an Switch6 PIM Join, basierend auf der Routing-Tabelle.  Daher beginnt R1, nachdem es einen solchen PIM-Join erhalten hat, Verkehr in Richtung RP-R3 zu senden. <br>  MSDP wird über TCP ausgeführt. RPs senden sich gegenseitig Keepalive-Nachrichten, um die Lebensfähigkeit zu überprüfen.  Der Timer beträgt 60 Sekunden. <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Funktion der Aufteilung von MSDP-Peers in verschiedene Domänen bleibt unverständlich, da die Keepalive- und SA-Nachrichten keine Zugehörigkeit zu einer Domäne anzeigen. </font><font style="vertical-align: inherit;">Auch in dieser Topologie wurde die Konfiguration unter Angabe verschiedener Domänen getestet - es gab keinen Unterschied im Betrieb. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn jemand klarstellen kann, lesen Sie gerne die Kommentare. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daran denke ich, um den Artikel zu beenden. </font><font style="vertical-align: inherit;">Im Folgenden finden Sie nützliche Materialien und Links, die verwendet wurden:</font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CCIE Routing and Switching v5.0 Offizieller Zertifizierungsleitfaden, Band 2, 5. Auflage, Narbik Kocharians, Terry Vinson. </font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Netzwerke für die Kleinsten. </font><font style="vertical-align: inherit;">Teil neun. </font><font style="vertical-align: inherit;">Multicast</font></font></a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de450582/">https://habr.com/ru/post/de450582/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de450568/index.html">Jedes Gift hat sein eigenes Gegenmittel. Wie man spart oder zumindest versucht (upd: über Gegenmittel gegen häusliche Vergiftungen)</a></li>
<li><a href="../de450572/index.html">Samba DC als zweiter Controller in der AD-Domäne von Windows 2012R2 und Roaming-Ordnern für Clients unter Windows und Linux</a></li>
<li><a href="../de450574/index.html">Erstellen Sie ein Multiplayer-.io-Webspiel</a></li>
<li><a href="../de450576/index.html">Neue Regeln für die Anonymität von Messenger</a></li>
<li><a href="../de450578/index.html">Was ist in der Luft zu hören? Wir empfangen und decodieren die interessantesten Signale. Teil 2, UKW</a></li>
<li><a href="../de450586/index.html">Fish Redux - Neue Redux-Bibliothek für Flattern</a></li>
<li><a href="../de450592/index.html">In Deutschland können die Kosten für die Fahrt mit einem Elektroauto höher sein als mit einem Dieselauto</a></li>
<li><a href="../de450594/index.html">Fibonacci gerade Zahlen</a></li>
<li><a href="../de450596/index.html">11. Check Point Erste Schritte R80.20. Bedrohungspräventionspolitik</a></li>
<li><a href="../de450598/index.html">Über den "gelben Regen" und den "orangefarbenen Agenten"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>