<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦖 👨🏻‍🚀 🎂 Machen Sie mehr mit Mustern in C # 8.0 🏗️ 🌄 🏦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Visual Studio 2019 Preview 2 ist da! Und damit stehen Ihnen einige weitere C # 8.0-Funktionen zur Verfügung. Es geht hauptsächlich um Mustervergleich,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Machen Sie mehr mit Mustern in C # 8.0</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/438256/"><img width="120" align="left" src="https://habrastorage.org/webt/8w/rq/7v/8wrq7vfhyqv2saamr2d5z2jha5o.png"><p>  Visual Studio 2019 Preview 2 ist da!  Und damit stehen Ihnen einige weitere C # 8.0-Funktionen zur Verfügung.  Es geht hauptsächlich um Mustervergleich, obwohl ich am Ende noch einige andere Neuigkeiten und Änderungen ansprechen werde. </p><br><a name="habracut"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Original im Blog</a> <br><br><h1>  Mehr Muster an mehr Orten </h1><br><p> Als C # 7.0 Pattern Matching einführte, sagten wir, dass wir in Zukunft <em>mehr</em> Muster an <em>mehr</em> Stellen hinzufügen würden.  Diese Zeit ist gekommen!  Wir fügen das hinzu, was wir als <em>rekursive Muster bezeichnen</em> , sowie eine kompaktere Ausdrucksform von <code>switch</code> Anweisungen, die Switch- <em>Ausdrücke</em> genannt werden (Sie haben es erraten!). </p><br><p>  Hier ist ein einfaches C # 7.0-Beispiel für Muster, um uns zu beginnen: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X { get; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Y { get; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Point</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>=&gt; (X, Y) = (x, y); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Deconstruct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(out </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, out </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>=&gt; (x, y) = (X, Y); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (o) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Point p when pX == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pY == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"origin"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Point p: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $<span class="hljs-string"><span class="hljs-string">"({pX}, {pY})"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"unknown"</span></span>; } }</code> </pre><br><h2>  Ausdrücke wechseln </h2><br><p>  Lassen Sie uns zunächst feststellen, dass viele <code>switch</code> Anweisungen in den Fallkörpern nicht wirklich interessante Arbeit leisten.  Oft erzeugen sie alle nur einen Wert, entweder indem sie ihn einer Variablen zuweisen oder indem sie ihn zurückgeben (wie oben).  In all diesen Situationen ist die switch-Anweisung offen gesagt ziemlich klobig.  Es fühlt sich an wie das 5 Jahrzehnte alte Sprachmerkmal, mit vielen Zeremonien. </p><br><p>  Wir beschlossen, dass es Zeit war, eine Ausdrucksform des <code>switch</code> hinzuzufügen.  Hier ist es, angewendet auf das obige Beispiel: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point p when pX == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pY == <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point p =&gt; $<span class="hljs-string"><span class="hljs-string">"({pX}, {pY})"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> }; }</code> </pre><br><p>  Hier haben sich einige Dinge gegenüber switch-Anweisungen geändert.  Lassen Sie uns sie auflisten: </p><br><ul><li>  Das Schlüsselwort <code>switch</code> lautet "infix" zwischen dem getesteten Wert und der <code>{...}</code> Liste der Fälle.  Das macht es kompositorischer mit anderen Ausdrücken und auch visuell leichter von einer switch-Anweisung zu unterscheiden. </li><li>  Das <code>case</code> Schlüsselwort und das <code>:</code> wurden der Kürze halber durch einen Lambda-Pfeil <code>=&gt;</code> . </li><li>  <code>default</code> wurde der Kürze halber durch das <code>_</code> Verwerfungsmuster <code>_</code> ersetzt. </li><li>  Die Körper sind Ausdrücke!  Das Ergebnis des ausgewählten Körpers wird zum Ergebnis des Schalterausdrucks. </li></ul><br><p>  Da ein Ausdruck entweder einen Wert haben oder eine Ausnahme auslösen muss, löst ein Schalterausdruck, der ohne Übereinstimmung das Ende erreicht, eine Ausnahme aus.  Der Compiler warnt Sie hervorragend, wenn dies der Fall sein kann, zwingt Sie jedoch nicht dazu, alle Switch-Ausdrücke mit einem Catch-All zu beenden: Vielleicht wissen Sie es besser! </p><br><p>  Da unsere <code>Display</code> Methode jetzt aus einer einzelnen return-Anweisung besteht, können wir sie natürlich so vereinfachen, dass sie einen Ausdruck enthält: </p><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object o)</span></span></span><span class="hljs-function"> </span></span>=&gt; o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point p when pX == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pY == <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point p =&gt; $<span class="hljs-string"><span class="hljs-string">"({pX}, {pY})"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> };</code> </pre><br><p>  Um ehrlich zu sein, bin ich mir nicht sicher, welche Formatierungsanleitung wir hier geben werden, aber es sollte klar sein, dass dies viel knapper und klarer ist, insbesondere weil die Kürze es Ihnen normalerweise ermöglicht, den Schalter wie oben "tabellarisch" zu formatieren , mit Mustern und Körpern auf derselben Linie, und die <code>=&gt;</code> s sind untereinander aufgereiht. </p><br><p>  Übrigens planen wir, ein nachfolgendes Komma nach dem letzten Fall in Übereinstimmung mit allen anderen "durch Kommas getrennten Listen in geschweiften Klammern" in C # zuzulassen, aber Vorschau 2 erlaubt dies noch nicht. </p><br><h2>  Eigenschaftsmuster </h2><br><p>  Apropos Kürze, die Muster werden plötzlich zu den schwersten Elementen des obigen Schalterausdrucks!  Lassen Sie uns etwas dagegen tun. </p><br><p>  Beachten Sie, dass der switch-Ausdruck das <em>Typmuster</em> <code>Point p</code> (zweimal) sowie eine <code>when</code> Klausel verwendet, um zusätzliche Bedingungen für den ersten <code>case</code> hinzuzufügen. </p><br><p>  In C # 8.0 fügen wir dem Typmuster weitere optionale Elemente hinzu, sodass das Muster selbst weiter in den Wert eingreifen kann, der mit dem Muster übereinstimmt.  Sie können es zu einem <em>Eigenschaftsmuster machen,</em> indem Sie <code>{...}</code> mit verschachtelten Mustern hinzufügen, um sie auf die zugänglichen Eigenschaften oder Felder des Werts anzuwenden.  Lassen Sie uns den Schalterausdruck wie folgt umschreiben: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object o)</span></span></span><span class="hljs-function"> </span></span>=&gt; o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point { X: <span class="hljs-number"><span class="hljs-number">0</span></span>, Y: <span class="hljs-number"><span class="hljs-number">0</span></span> } p =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point { X: var x, Y: var y } p =&gt; $<span class="hljs-string"><span class="hljs-string">"({x}, {y})"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> };</code> </pre><br><p>  In beiden Fällen wird weiterhin geprüft, ob <code>o</code> ein <code>Point</code> .  Der erste Fall wendet dann das konstante Muster <code>0</code> rekursiv auf die <code>X</code> und <code>Y</code> Eigenschaften von <code>p</code> und prüft, ob sie diesen Wert haben.  Somit können wir die <code>when</code> Klausel in diesem und vielen häufigen Fällen beseitigen. </p><br><p>  Der zweite Fall wendet das <code>var</code> Muster auf jedes von <code>X</code> und <code>Y</code>  Denken Sie daran, dass das <code>var</code> Muster in C # 7.0 immer erfolgreich ist und einfach eine neue Variable deklariert, die den Wert enthält.  Somit erhalten <code>x</code> und <code>y</code> die int-Werte von <code>pX</code> und <code>pY</code> . </p><br><p>  Wir verwenden <code>p</code> nie und können es hier sogar weglassen: </p><br><pre> <code class="cpp hljs"> Point { X: <span class="hljs-number"><span class="hljs-number">0</span></span>, Y: <span class="hljs-number"><span class="hljs-number">0</span></span> } =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point { X: var x, Y: var y } =&gt; $<span class="hljs-string"><span class="hljs-string">"({x}, {y})"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span></code> </pre><br><p>  Eine Sache, die für alle Typmuster einschließlich Eigenschaftsmuster gilt, ist, dass der Wert ungleich Null sein muss.  Dies eröffnet die Möglichkeit, dass das "leere" Eigenschaftsmuster <code>{}</code> als kompaktes "Nicht-Null" -Muster verwendet wird.  Zum Beispiel könnten wir den Fallback-Fall durch die folgenden zwei Fälle ersetzen: </p><br><pre> <code class="cpp hljs"> {} =&gt; o.ToString(), null =&gt; <span class="hljs-string"><span class="hljs-string">"null"</span></span></code> </pre><br><p>  Das <code>{}</code> behandelt verbleibende Nicht- <code>null</code> Objekte, und <code>null</code> erhält die Nullen, sodass der Schalter vollständig ist und der Compiler sich nicht über durchfallende Werte beschwert. </p><br><h2>  Positionsmuster </h2><br><p>  Das Eigenschaftsmuster hat den zweiten <code>Point</code> nicht genau <em>kürzer gemacht</em> und scheint die Mühe dort nicht wert zu sein, aber es kann noch mehr getan werden. </p><br><p>  Beachten Sie, dass die <code>Point</code> Klasse eine <code>Deconstruct</code> Methode hat, einen sogenannten <em>Deconstructor</em> .  In C # 7.0 erlaubten Dekonstruktoren, dass ein Wert bei der Zuweisung dekonstruiert wurde, sodass Sie zB schreiben konnten: </p><br><pre> <code class="cpp hljs">(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y) = GetPoint(); <span class="hljs-comment"><span class="hljs-comment">// split up the Point according to its deconstructor</span></span></code> </pre><br><p>  C # 7.0 hat die Dekonstruktion nicht in Muster integriert.  Dies ändert sich mit <em>Positionsmustern,</em> die eine zusätzliche Möglichkeit darstellen, Typmuster in C # 8.0 zu erweitern.  Wenn der übereinstimmende Typ ein Tupeltyp ist oder einen Dekonstruktor hat, können wir Positionsmuster als kompakte Methode zum Anwenden rekursiver Muster verwenden, ohne Eigenschaften benennen zu müssen: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object o)</span></span></span><span class="hljs-function"> </span></span>=&gt; o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point(var x, var y) =&gt; $<span class="hljs-string"><span class="hljs-string">"({x}, {y})"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> };</code> </pre><br><p>  Sobald das Objekt als <code>Point</code> abgeglichen wurde, wird der Dekonstruktor angewendet und die verschachtelten Muster werden auf die resultierenden Werte angewendet. </p><br><p>  Dekonstruktoren sind nicht immer angemessen.  Sie sollten nur zu Typen hinzugefügt werden, bei denen wirklich klar ist, welcher der Werte welcher ist.  Für eine <code>Point</code> Klasse ist es beispielsweise sicher und intuitiv anzunehmen, dass der erste Wert <code>X</code> und der zweite <code>Y</code> , sodass der obige Schalterausdruck intuitiv und leicht zu lesen ist. </p><br><h2>  Tupelmuster </h2><br><p>  Ein sehr nützlicher Sonderfall von Positionsmustern ist, wenn sie auf Tupel angewendet werden.  Wenn eine switch-Anweisung direkt auf einen Tupelausdruck angewendet wird, können wir sogar zulassen, dass der zusätzliche Satz von Klammern weggelassen wird, wie in <code>switch (x, y, z)</code> anstelle von <code>switch ((x, y, z))</code> . </p><br><p>  Tupelmuster eignen sich hervorragend zum gleichzeitigen Testen mehrerer Eingabeteile.  Hier ist eine einfache Implementierung einer Zustandsmaschine: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State current, Transition transition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasKey)</span></span></span><span class="hljs-function"> </span></span>=&gt; (current, transition) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { (Opened, Close) =&gt; Closed, (Closed, Open) =&gt; Opened, (Closed, Lock) when hasKey =&gt; Locked, (Locked, Unlock) when hasKey =&gt; Closed, _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException($<span class="hljs-string"><span class="hljs-string">"Invalid transition"</span></span>) };</code> </pre><br><p>  Natürlich könnten wir uns dafür entscheiden, <code>hasKey</code> in das eingeschaltete Tupel aufzunehmen, anstatt <code>when</code> Klauseln zu verwenden - es ist wirklich Geschmackssache: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State current, Transition transition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasKey)</span></span></span><span class="hljs-function"> </span></span>=&gt; (current, transition, hasKey) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { (Opened, Close, _) =&gt; Closed, (Closed, Open, _) =&gt; Opened, (Closed, Lock, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) =&gt; Locked, (Locked, Unlock, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) =&gt; Closed, _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException($<span class="hljs-string"><span class="hljs-string">"Invalid transition"</span></span>) };</code> </pre><br><p>  Alles in allem hoffe ich, dass Sie sehen können, dass rekursive Muster und Schalterausdrücke zu einer klareren und deklarativeren Programmlogik führen können. </p><br><h1>  Weitere C # 8.0-Funktionen in Vorschau 2 </h1><br><p>  Während die Musterfunktionen die wichtigsten sind, die in VS 2019 Preview 2 online gehen, gibt es einige kleinere, von denen ich hoffe, dass Sie sie auch nützlich und unterhaltsam finden.  Ich werde hier nicht auf Details eingehen, sondern Ihnen nur eine kurze Beschreibung von jedem geben. </p><br><h2>  Deklarationen verwenden </h2><br><p>  In C # führt die <code>using</code> Anweisungen immer zu einer Verschachtelung, die sehr ärgerlich sein und die Lesbarkeit beeinträchtigen kann.  Für die einfachen Fälle, in denen nur eine Ressource am Ende eines Bereichs bereinigt werden soll, müssen Sie jetzt <em>stattdessen Deklarationen</em> verwenden.  Verwenden von Deklarationen sind einfach lokale Variablendeklarationen mit einem <code>using</code> Schlüsselwort im Vordergrund, und ihr Inhalt wird am Ende des aktuellen Anweisungsblocks angeordnet.  Also statt: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (var options = Parse(args)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (options[<span class="hljs-string"><span class="hljs-string">"verbose"</span></span>]) { WriteLine(<span class="hljs-string"><span class="hljs-string">"Logging..."</span></span>); } ... } <span class="hljs-comment"><span class="hljs-comment">// options disposed here }</span></span></code> </pre><br><p>  Sie können einfach schreiben </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> var options = Parse(args); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (options[<span class="hljs-string"><span class="hljs-string">"verbose"</span></span>]) { WriteLine(<span class="hljs-string"><span class="hljs-string">"Logging..."</span></span>); } } <span class="hljs-comment"><span class="hljs-comment">// options disposed here</span></span></code> </pre><br><h2>  Einweg-Ref-Strukturen </h2><br><p>  Ref-Strukturen wurden in C # 7.2 eingeführt, und dies ist nicht der Ort, um ihre Nützlichkeit zu wiederholen, aber im Gegenzug weisen sie einige schwerwiegende Einschränkungen auf, z. B. die Unfähigkeit, Schnittstellen zu implementieren.  Ref-Strukturen können jetzt ohne Implementierung der <code>IDisposable</code> Schnittstelle verfügbar <code>IDisposable</code> werden, indem einfach eine <code>Dispose</code> Methode enthalten ist. </p><br><h2>  Statische lokale Funktionen </h2><br><p>  Wenn Sie sicherstellen möchten, dass Ihre lokale Funktion nicht die Laufzeitkosten verursacht, die mit dem "Erfassen" (Referenzieren) von Variablen aus dem umschließenden Bereich verbunden sind, können Sie sie als <code>static</code> deklarieren.  Dann verhindert der Compiler die Referenzierung von Elementen, die in umschließenden Funktionen deklariert sind - mit Ausnahme anderer statischer lokaler Funktionen! </p><br><h1>  Änderungen seit Vorschau 1 </h1><br><p>  Die Hauptmerkmale von Vorschau 1 waren nullfähige Referenztypen und asynchrone Streams.  Beide haben sich in Vorschau 2 etwas weiterentwickelt. Wenn Sie sie also verwenden, sollten Sie Folgendes beachten. </p><br><h2>  Nullable Referenztypen </h2><br><p>  Wir haben weitere Optionen hinzugefügt, um nullfähige Warnungen sowohl in der Quelle (über die <code>#nullable</code> und <code>#pragma warning</code> ) als auch auf Projektebene zu steuern.  Wir haben auch das Opt-In für die Projektdatei in <code>&lt;NullableContextOptions&gt;enable&lt;/NullableContextOptions&gt;</code> . </p><br><h2>  Asynchrone Streams </h2><br><p>  Wir haben die Form der <code>IAsyncEnumerable&lt;T&gt;</code> -Schnittstelle geändert, die der Compiler erwartet!  Dies führt dazu, dass der Compiler nicht mehr mit der in .NET Core 3.0 Preview 1 bereitgestellten Schnittstelle synchronisiert ist, was zu Problemen führen kann.  .NET Core 3.0 Preview 2 ist jedoch in Kürze verfügbar, wodurch die Schnittstellen wieder synchronisiert werden. </p><br><h1>  Haben Sie es! </h1><br><p>  Wie immer freuen wir uns über Ihr Feedback!  Bitte spielen Sie insbesondere mit den neuen Musterfunktionen herum.  Stoßen Sie auf Backsteinmauern?  Ist etwas nervig?  Welche coolen und nützlichen Szenarien finden Sie für sie?  Klicken Sie auf den Feedback-Button und lassen Sie es uns wissen! </p><br><p>  Viel Spaß beim Hacken </p><br><p>  Mads Torgersen, Designleiter für C # </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438256/">https://habr.com/ru/post/de438256/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438244/index.html">Wir beschäftigen uns mit russischen kryptografischen Vorschriften ... am Beispiel der Verhaftung eines Drogenherren</a></li>
<li><a href="../de438248/index.html">GitHub Action Life</a></li>
<li><a href="../de438250/index.html">Die Unkenntnis der Grundsätze der Informationssicherheit ist nicht ausgenommen</a></li>
<li><a href="../de438252/index.html">Warum nicht das Immobilienportal abgenommen. Teil 1</a></li>
<li><a href="../de438254/index.html">Eclipse startet GlassFish 5.1 für Java EE 8</a></li>
<li><a href="../de438260/index.html">"Modern" C ++: eine Wehklagesitzung mit Wehklagen</a></li>
<li><a href="../de438262/index.html">Cyber-physikalische Systeme in der modernen Welt</a></li>
<li><a href="../de438264/index.html">Verkehrsverschlüsselung in Direct Connect, Teil 1</a></li>
<li><a href="../de438266/index.html">Warum ist Pentesting für Ihr Unternehmen wichtig?</a></li>
<li><a href="../de438270/index.html">Liebe Kubernetes bei Mail.ru Gruppe: 14. Februar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>