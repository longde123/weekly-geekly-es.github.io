<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😀 😮 😨 Perubahan terbaru dalam Linux IO stack dari sudut pandang DBA 🛑 🤘🏾 😖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Masalah utama bekerja dengan database terkait dengan fitur perangkat dari sistem operasi tempat database bekerja. Linux sekarang menjadi sistem operas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perubahan terbaru dalam Linux IO stack dari sudut pandang DBA</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/459444/">  Masalah utama bekerja dengan database terkait dengan fitur perangkat dari sistem operasi tempat database bekerja.  Linux sekarang menjadi sistem operasi utama untuk basis data.  Solaris, Microsoft dan bahkan HPUX masih digunakan di perusahaan, tetapi mereka tidak akan pernah menempati posisi pertama, bahkan ketika digabungkan.  Linux dengan percaya diri mendapatkan dukungan karena semakin banyak basis data open source.  Oleh karena itu, masalah interaksi database dengan OS jelas tentang database Linux.  Ini ditumpangkan pada masalah DB abadi - kinerja IO.  Adalah baik bahwa dalam beberapa tahun terakhir Linux telah mengalami perombakan besar dari tumpukan IO dan ada harapan untuk pencerahan. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/0o7uNUOS-Ho" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Ilya Kosmodemyansky ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">hydrobiont</a> ) bekerja untuk Data Egret, sebuah perusahaan yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">berkonsultasi</a> dan mendukung PostgreSQL, dan tahu banyak tentang interaksi antara OS dan basis data.  Dalam sebuah laporan tentang HighLoad ++, Ilya berbicara tentang interaksi IO dan basis data menggunakan contoh PostgreSQL, tetapi juga menunjukkan bagaimana basis data lainnya bekerja dengan IO.  Saya melihat tumpukan IO Linux, hal-hal baru dan bagus muncul di dalamnya dan mengapa semuanya tidak seperti beberapa tahun yang lalu.  Sebagai pengingat yang berguna - daftar periksa pengaturan PostgreSQL dan Linux untuk kinerja maksimum subsistem IO di kernel baru. <br><a name="habracut"></a><br>  <i>Video laporan berisi banyak bahasa Inggris, yang sebagian besar kami terjemahkan dalam artikel.</i> <br><br><h2>  Mengapa berbicara tentang IO? </h2><br>  <strong>I / O yang cepat adalah hal yang paling penting bagi administrator database</strong> .  Semua orang tahu apa yang bisa diubah dalam bekerja dengan CPU, bahwa memori dapat diperluas, tetapi I / O dapat merusak segalanya.  Jika buruk dengan disk, dan terlalu banyak I / O, maka database akan mengerang.  IO akan menjadi hambatan. <br><br><blockquote>  Agar semuanya berfungsi dengan baik, Anda perlu mengkonfigurasi semuanya. </blockquote><br>  Bukan hanya database atau hanya perangkat keras - itu saja.  Bahkan Oracle tingkat tinggi, yang merupakan sistem operasi di beberapa tempat, memerlukan konfigurasi.  Kami membaca instruksi di "Panduan Instalasi" dari Oracle: ubah parameter kernel seperti itu, ubah yang lain - ada banyak pengaturan.  Selain fakta bahwa di Unbreakable Kernel, banyak sudah secara default kabel ke Oracle Linux. <br><br>  Untuk PostgreSQL dan MySQL, diperlukan lebih banyak perubahan.  Ini karena teknologi ini bergantung pada mekanisme OS.  DBA yang bekerja dengan PostgreSQL, MySQL, atau NoSQL modern haruslah seorang insinyur operasi Linux dan memuntir kacang OS yang berbeda. <br><br>  Setiap orang yang ingin berurusan dengan pengaturan kernel, beralih ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LWN</a> .  Sumber daya cerdik, minimalis, berisi banyak informasi berguna, tetapi <strong>ditulis oleh pengembang kernel untuk pengembang kernel</strong> .  Apa yang ditulis dengan baik oleh pengembang kernel?  Intinya, bukan artikelnya, bagaimana menggunakannya.  Karena itu, saya akan mencoba menjelaskan semuanya kepada Anda untuk para pengembang, dan biarkan mereka menulis kernel. <br><br>  Semuanya menjadi rumit berkali-kali oleh kenyataan bahwa pada awalnya pengembangan kernel Linux dan pemrosesan stacknya tertinggal, dan dalam beberapa tahun terakhir ini telah berjalan sangat cepat.  Baik besi maupun pengembang dengan artikel di belakangnya mengikuti. <br><br><h2>  Basis data tipikal </h2><br>  Mari kita mulai dengan contoh untuk PostgreSQL - ini buffered I / O.  Ini memiliki memori bersama, yang dialokasikan di <strong>ruang pengguna</strong> dari sudut pandang OS, dan memiliki cache yang sama di cache kernel di <strong>ruang Kernel</strong> . <br><br><img src="https://habrastorage.org/webt/jd/dh/d2/jddhd25l97pocaqtqqf6ccygcxi.jpeg"><br><br>  <strong>Tugas utama dari database modern</strong> : <br><br><ul><li>  mengambil halaman dari disk di memori; </li><li>  ketika perubahan terjadi, tandai halaman sebagai kotor; </li><li>  tulis ke Write-Ahead Log; </li><li>  kemudian sinkronkan memori sehingga konsisten dengan disk. </li></ul><br>  Dalam situasi PostgreSQL, ini adalah perjalanan pulang-pergi yang konstan: dari memori bersama yang dikendalikan PostgreSQL di kernel Halaman Cache, dan kemudian ke disk melalui seluruh tumpukan Linux.  Jika Anda menggunakan database pada sistem file, itu akan bekerja pada algoritma ini dengan sistem seperti UNIX dan dengan database apa pun.  Perbedaan itu, tetapi tidak signifikan. <br><br>  Menggunakan Oracle ASM akan berbeda - Oracle sendiri berinteraksi dengan disk.  Tetapi prinsipnya sama: dengan Direct IO atau dengan Page Cache, tetapi tugasnya adalah <strong>menggambar halaman melalui seluruh tumpukan I / O secepat mungkin</strong> , apa pun itu.  Dan masalah bisa muncul di setiap tahap. <br><br><h3>  Dua masalah IO </h3><br>  Sementara semuanya <strong>hanya dibaca</strong> , tidak ada masalah.  Mereka membaca dan, jika ada cukup memori, semua data yang perlu dibaca ditempatkan dalam RAM.  Fakta bahwa dalam kasus PostgreSQL di <strong>Buffer Cache</strong> adalah sama, kami tidak terlalu khawatir. <br><br><img src="https://habrastorage.org/webt/mh/0j/sm/mh0jsmmdrh5bosmamuaiko9l-jw.jpeg"><br><br>  <strong>Masalah pertama dengan IO adalah sinkronisasi cache.</strong>  Terjadi saat perekaman diperlukan.  Dalam hal ini, Anda harus bolak-balik lebih banyak memori. <br><br><img src="https://habrastorage.org/webt/tq/mw/u7/tqmwu7fy-wlwqjx6nxec6jfcyrk.jpeg"><br><br>  Oleh karena itu, Anda perlu mengonfigurasi PostgreSQL atau MySQL agar semuanya dapat disk dari memori bersama.  Dalam kasus PostgreSQL - Anda masih perlu memperbaiki kecurangan latar belakang halaman-halaman kotor di Linux untuk mengirim semuanya ke disk. <br><br>  <strong>Masalah umum kedua adalah kegagalan tulis Write-Ahead Log</strong> .  Itu muncul ketika beban sangat kuat sehingga bahkan log yang direkam berurutan bersandar pada disk.  Dalam situasi ini, itu juga perlu direkam dengan cepat. <br><br>  Situasinya tidak jauh berbeda dari <strong>sinkronisasi cache</strong> .  Dalam PostgreSQL, kami bekerja dengan sejumlah besar buffer bersama, database memiliki mekanisme untuk perekaman Write-Ahead Log yang efisien, dioptimalkan hingga batasnya.  Satu-satunya hal yang dapat dilakukan untuk membuat log itu sendiri lebih efisien adalah mengubah pengaturan Linux. <br><br><h2>  Masalah utama bekerja dengan database </h2><br>  <strong>Segmen memori bersama bisa sangat besar</strong> .  Saya mulai membicarakan hal ini di konferensi pada tahun 2012.  Lalu saya mengatakan bahwa memori telah jatuh harga, bahkan ada server dengan 32 GB RAM.  Pada 2019, mungkin sudah ada lebih banyak di laptop, lebih dan lebih sering di server 128, 256, dll. <br><br>  <strong>Benar-benar banyak memori</strong> .  Rekaman banal membutuhkan waktu dan sumber daya, dan <strong>teknologi yang kami gunakan untuk ini konservatif</strong> .  Database sudah tua, mereka telah dikembangkan untuk waktu yang lama, mereka perlahan berkembang.  Mekanisme dalam database tidak sepenuhnya tepat dengan teknologi terbaru. <br><br>  <strong>Menyinkronkan halaman dalam memori dengan hasil disk dalam operasi IO besar</strong> .  Ketika kami menyinkronkan cache, aliran besar IO muncul, dan masalah lain muncul - <strong>kami tidak dapat memutar sesuatu dan melihat efeknya.</strong>  Dalam eksperimen ilmiah, para peneliti mengubah satu parameter - dapatkan efeknya, yang kedua - dapatkan efeknya, yang ketiga.  Kami tidak akan berhasil.  Kami memutar beberapa parameter di PostgreSQL, mengkonfigurasi pos pemeriksaan - kami tidak melihat efeknya.  Kemudian konfigurasikan kembali seluruh tumpukan untuk mendapatkan setidaknya beberapa hasil.  Memutar satu parameter tidak berfungsi - kita dipaksa untuk mengkonfigurasi semuanya sekaligus. <br><br>  Kebanyakan IO PostgreSQL menghasilkan sinkronisasi halaman: pos-pos pemeriksaan dan mekanisme sinkronisasi lainnya.  Jika Anda bekerja dengan PostgreSQL, Anda mungkin telah melihat titik-titik pemeriksaan melonjak ketika "gergaji" muncul secara berkala di grafik.  Sebelumnya, banyak yang menghadapi masalah ini, tetapi sekarang ada manual tentang cara memperbaikinya, menjadi lebih mudah. <br><br>  SSD saat ini sangat menghemat situasi.  Di PostgreSQL, sesuatu jarang bersandar langsung pada catatan nilai.  Semuanya tergantung pada sinkronisasi: ketika sebuah pos pemeriksaan terjadi, fsync dipanggil dan ada semacam “pemukulan” terhadap satu pos pemeriksaan yang lain.  Terlalu banyak IO.  Satu pos pemeriksaan belum berakhir, belum menyelesaikan semua fsync-nya, tetapi sudah mendapatkan pos pemeriksaan lain, dan sudah dimulai! <br><br>  PostgreSQL memiliki fitur unik - <strong>autovacuum</strong> .  Ini adalah sejarah panjang kruk untuk arsitektur basis data.  Jika autovacuum gagal, mereka biasanya mengaturnya sehingga bekerja secara agresif dan tidak mengganggu sisanya: ada banyak pekerja autovacuum, sering tersandung sedikit, memproses tabel dengan cepat.  Kalau tidak, akan ada masalah dengan DDL dan dengan kunci. <br><br><blockquote>  Tetapi ketika Autovacuum agresif, ia mulai mengunyah IO. </blockquote><br>  Jika autovacuum ditumpangkan pada pos pemeriksaan, maka sebagian besar disk waktu hampir 100% didaur ulang, dan ini adalah sumber masalahnya. <br><br>  Anehnya, ada masalah <strong>isi ulang Cache</strong> .  Dia biasanya kurang dikenal untuk DBA.  Contoh khas: basis data dimulai, dan untuk beberapa saat semuanya melambat dengan sedih.  Oleh karena itu, bahkan jika Anda memiliki banyak RAM, beli disk yang bagus sehingga tumpukan menghangatkan cache. <br><br>  Semua ini sangat memengaruhi kinerja.  Masalah mulai tidak segera setelah me-restart database, tetapi kemudian.  Misalnya, pos pemeriksaan lulus, dan banyak halaman kotor di seluruh basis data.  Mereka disalin ke disk karena Anda perlu menyinkronkannya.  Kemudian permintaan meminta versi halaman baru dari disk, dan basis data melorot.  Grafik akan menunjukkan bagaimana isi ulang Cache setelah setiap pos pemeriksaan menyumbangkan persentase tertentu ke beban. <br><br>  Hal yang paling tidak menyenangkan dalam input / output dari database adalah <strong>Worker IO.</strong>  Ketika setiap pekerja yang Anda minta, mulai menghasilkan IO-nya.  Di Oracle, lebih mudah dengan itu, tetapi di PostgreSQL itu masalah. <br><br>  Ada banyak alasan untuk masalah dengan <strong>Worker IO</strong> : tidak ada cukup cache untuk "memposting" halaman baru dari disk.  Misalnya, semua buffer dibagi, semuanya kotor, pos pemeriksaan belum.  Agar pekerja dapat melakukan pemilihan yang paling sederhana, Anda perlu mengambil cache dari suatu tempat.  Untuk melakukan ini, pertama-tama Anda harus menyimpan semuanya ke disk.  Anda tidak memiliki proses checkpointer khusus, dan pekerja mulai fsync untuk membebaskan dan mengisinya dengan sesuatu yang baru. <br><br>  Ini menimbulkan masalah yang lebih besar: pekerja adalah hal yang tidak terspesialisasi, dan seluruh proses tidak dioptimalkan sama sekali.  Dimungkinkan untuk mengoptimalkan di suatu tempat di tingkat Linux, tetapi di PostgreSQL ini adalah tindakan darurat. <br><br><h2>  Masalah IO utama untuk DB </h2><br>  <strong>Masalah apa yang kita pecahkan ketika kita mengatur sesuatu?</strong>  Kami ingin memaksimalkan perjalanan halaman kotor antara disk dan memori. <br><br>  Tetapi sering terjadi hal-hal ini tidak menyentuh disk secara langsung.  Kasus khas - Anda melihat rata-rata beban yang sangat besar.  Kenapa begitu  Karena seseorang sedang menunggu disk, dan semua proses lain juga menunggu.  Tampaknya tidak ada pemanfaatan disk yang eksplisit dari disk, hanya sesuatu yang memblokir disk di sana, dan masalahnya adalah dengan input / output. <br><br><blockquote>  Masalah I / O basis data tidak selalu hanya menyangkut disk. </blockquote><br>  Semuanya terlibat dalam masalah ini: disk, memori, CPU, Penjadwal IO, sistem file, dan pengaturan basis data.  Sekarang mari kita melihat tumpukan, melihat apa yang harus dilakukan dengannya, dan hal-hal baik apa yang telah ditemukan di Linux sehingga semuanya bekerja lebih baik. <br><br><h3>  Disk </h3><br>  Selama bertahun-tahun, disk sangat lambat dan tidak ada yang terlibat dalam latensi atau optimalisasi tahap transisi.  Mengoptimalkan fsyncs tidak masuk akal.  Disk berputar, kepala bergerak seperti catatan fonograf, dan fsyncs begitu lama sehingga masalah tidak muncul. <br><br><h3>  Memori </h3><br>  Percuma untuk melihat kueri teratas tanpa menyetel basis data.  Anda akan mengonfigurasi jumlah memori bersama yang memadai, dll., Dan Anda akan memiliki kueri teratas baru - Anda harus mengonfigurasinya lagi.  Ini kisah yang sama.  Seluruh tumpukan Linux dibuat dari perhitungan ini. <br><br><h3>  Bandwidth dan latensi </h3><br>  <strong>Memaksimalkan kinerja IO dengan memaksimalkan throughput mudah sampai titik tertentu.</strong>  Proses PageWriter tambahan ditemukan di PostgreSQL yang menurunkan pos pemeriksaan.  Pekerjaan telah menjadi paralel, tetapi masih ada dasar untuk penambahan paralelisme.  Dan untuk meminimalkan latensi adalah tugas dari mil terakhir, yang membutuhkan teknologi super. <br><br>  Teknologi super ini adalah SSD.  Ketika mereka muncul, latensi turun tajam.  Tetapi pada semua tahap tumpukan lainnya, muncul masalah: baik dari sisi pabrikan basis data maupun dari pabrikan Linux.  Masalah perlu diatasi. <br><br>  Pengembangan basis data berpusat pada memaksimalkan throughput, seperti halnya pengembangan kernel Linux.  Banyak metode untuk mengoptimalkan era I / O disk berputar tidak begitu baik untuk SSD. <br><br>  Di antaranya, kami terpaksa membuat cadangan untuk infrastruktur Linux saat ini, tetapi dengan disk baru.  Kami menyaksikan pengujian kinerja dari pabrikan dengan sejumlah besar IOPS berbeda, dan basis data tidak membaik, karena basis data tidak hanya dan tidak begitu banyak tentang IOPS.  Sering terjadi bahwa kita dapat melewati 50.000 IOPS per detik, itu bagus.  Tetapi jika kita tidak tahu latensi, tidak tahu distribusinya, maka kita tidak bisa mengatakan apa-apa tentang kinerja.  Pada titik tertentu, database akan mulai memeriksa, dan latensi akan meningkat secara dramatis. <br><br>  Untuk waktu yang lama, seperti sekarang, ini telah menjadi masalah kinerja besar pada database virtuala.  Virtual IO ditandai dengan latensi yang tidak merata, yang tentu saja juga menimbulkan masalah. <br><br><h2>  Tumpukan IO.  Seperti sebelumnya </h2><br><img src="https://habrastorage.org/webt/yl/3v/oz/yl3vozgbt2ltrkqo8lbey-wzdfo.jpeg"><br><br>  Ada ruang pengguna - memori itu, yang dikelola oleh database itu sendiri.  Dalam DB dikonfigurasi sehingga semuanya berfungsi sebagaimana mestinya.  Ini dapat dilakukan dalam laporan terpisah, dan bahkan tidak satu.  Kemudian semuanya pasti akan melalui Page Cache atau melalui antarmuka IO langsung itu memasuki lapisan <strong>Input / Output Block</strong> . <br><br>  Bayangkan sebuah antarmuka sistem file.  Halaman-halaman yang ada di Buffer Cache, karena mereka awalnya di database, yaitu, blok, keluar melaluinya.  Blok IO berurusan dengan layer berikut.  Ada struktur C yang menggambarkan blok di kernel.  Struktur mengambil blok ini dan mengumpulkan dari mereka vektor (array) dari permintaan input atau output.  Di bawah lapisan BIO adalah lapisan pemohon.  Vektor dikumpulkan pada layer ini dan akan melangkah lebih jauh. <br><br>  Untuk waktu yang lama, dua lapisan ini di Linux dipertajam untuk perekaman yang efisien pada disk magnetik.  Itu tidak mungkin dilakukan tanpa transisi.  Ada beberapa blok yang nyaman untuk dikelola dari basis data.  Hal ini diperlukan untuk merakit blok-blok ini menjadi vektor yang mudah ditulis ke disk sehingga mereka berada di suatu tempat di dekatnya.  Agar ini berfungsi secara efektif, mereka datang dengan Elevators, atau Schedulers IO. <br><br><h2>  Elevator </h2><br>  Elevators terutama terlibat dalam menggabungkan dan menyortir vektor.  Semua agar driver blok SD - driver quasidisk - blok rekaman untuk tiba dalam urutan yang nyaman baginya.  Pengemudi menerjemahkan dari blok ke sektornya dan menulis ke disk. <br><br>  Masalahnya adalah bahwa perlu untuk melakukan beberapa transisi, dan pada masing-masing menerapkan logika mereka sendiri dari proses optimal. <br><br><h3>  Elevators: hingga kernel 2.6 </h3><br>  <strong>Sebelum kernel 2.6, ada Linus Elevator</strong> - Penjadwal IO paling primitif, yang ditulis oleh Anda menebak siapa.  Untuk waktu yang lama ia dianggap benar-benar tak tergoyahkan dan baik, sampai mereka mengembangkan sesuatu yang baru. <br><br>  Linus Elevator punya banyak masalah.  <strong>Dia menggabungkan dan mengurutkan</strong> <strong>berdasarkan cara merekam dengan lebih efisien</strong> .  Dalam hal memutar disk mekanis, ini menyebabkan munculnya " <strong>kelaparan"</strong> : situasi di mana efisiensi perekaman tergantung pada rotasi disk.  Jika Anda tiba-tiba perlu membaca secara efektif pada saat yang sama, tetapi sudah diputar salah, buruk dibaca dari disk seperti itu. <br><br>  Secara bertahap, menjadi jelas bahwa ini adalah cara yang tidak efisien.  Oleh karena itu, dimulai dengan kernel 2.6, seluruh kebun binatang penjadwal mulai muncul, yang dimaksudkan untuk tugas yang berbeda. <br><br><h3>  Elevator: antara 2,6 dan 3 </h3><br>  Banyak orang mengacaukan penjadwal ini dengan penjadwal sistem operasi karena mereka memiliki nama yang mirip.  <strong>CFQ - Antrian Sepenuhnya Adil</strong> tidak sama dengan penjadwal OS.  Hanya namanya saja yang mirip.  Itu diciptakan sebagai penjadwal universal. <br><br>  <strong>Apa itu penjadwal universal?</strong>  Apakah Anda pikir Anda memiliki beban rata-rata atau, sebaliknya, beban yang unik?  Database memiliki fleksibilitas yang sangat buruk.  Beban universal dapat dibayangkan sebagai laptop biasa.  Segala sesuatu terjadi di sana: kita mendengarkan musik, memutar, mengetik teks.  Untuk ini, hanya penjadwal universal yang ditulis. <br><br>  <strong>Tugas utama dari penjadwal universal:</strong> dalam kasus Linux, untuk setiap terminal dan proses virtual, buat antrian permintaan.  Ketika kami ingin mendengarkan musik di pemutar audio, IO untuk pemain akan mengantre.  Jika kita ingin mencadangkan sesuatu menggunakan perintah cp, ada sesuatu yang lain yang terlibat. <br><br>  Dalam kasus database, terjadi masalah.  Sebagai aturan, database adalah proses yang dimulai, dan selama operasi, proses paralel muncul yang selalu berakhir dalam antrian I / O yang sama.  Alasannya adalah bahwa ini adalah aplikasi yang sama, proses induk yang sama.  Untuk muatan yang sangat kecil, penjadwalan seperti itu cocok, untuk yang lain tidak masuk akal.  Lebih mudah untuk mematikan dan tidak digunakan jika memungkinkan. <br><br>  Secara bertahap, <strong>deadline scheduler</strong> muncul - ia bekerja lebih licik, tetapi pada dasarnya itu adalah penggabungan dan pengurutan untuk disk yang berputar.  Mengingat desain subsistem disk tertentu, kami mengumpulkan vektor blok untuk menuliskannya secara optimal.  Dia memiliki lebih sedikit masalah dengan <strong>kelaparan</strong> , tetapi mereka ada di sana. <br><br>  Oleh karena itu, lebih dekat ke kernel Linux ketiga muncul <strong>noop</strong> or <strong>none</strong> , yang bekerja lebih baik dengan penyebaran SSD.  Termasuk penjadwal noop, kami sebenarnya menonaktifkan penjadwalan: tidak ada penyortiran, penggabungan, dan hal serupa yang dilakukan CFQ dan tenggat waktu. <br><br>  Ini berfungsi lebih baik dengan SSD, karena SSD secara inheren paralel: ia memiliki sel memori.  Semakin banyak elemen ini dijejalkan pada satu papan PCIe, semakin efisien itu akan bekerja. <br><br>  Penjadwal dari beberapa dunia lain, dari sudut pandang SSD, pertimbangan, mengumpulkan beberapa vektor dan mengirimkannya ke suatu tempat.  Semuanya berakhir dengan corong.  Jadi kita membunuh konkurensi SSD, jangan menggunakannya secara maksimal.  Oleh karena itu, shutdown sederhana, ketika vektor berjalan secara acak tanpa penyortiran, bekerja lebih baik dalam hal kinerja.  Karena itu, diyakini bahwa pembacaan acak, penulisan acak lebih baik pada SSD. <br><br><h3>  Elevator: 3,13 dan seterusnya </h3><br>  Dimulai dengan kernel 3.13, <strong>blk-mq muncul</strong> .  Sedikit sebelumnya ada prototipe, tetapi pada 3.13 versi yang berfungsi pertama kali muncul. <br><br>  <strong>Blk-mq dimulai</strong> sebagai penjadwal, tetapi sulit untuk menyebutnya penjadwal - itu berdiri sendiri secara arsitektur.  Ini adalah pengganti untuk lapisan permintaan di kernel.  Perlahan-lahan, pengembangan blk-mq menyebabkan perombakan besar-besaran dari seluruh tumpukan I / O Linux. <br><br>  Idenya adalah ini: mari kita gunakan kemampuan asli SSD untuk melakukan konkurensi yang efisien untuk I / O.  Bergantung pada berapa banyak aliran I / O paralel yang dapat Anda gunakan, ada antrian yang jujur ​​di mana kami cukup menulis seperti pada SSD.  Setiap CPU memiliki antrian sendiri untuk merekam. <br><br>  Saat ini <strong>blk-mq sedang</strong> aktif mengembangkan dan bekerja.  Tidak ada alasan untuk tidak menggunakannya.  Dalam core modern, dari 4 ke atas, dari <strong>blk-mq,</strong> keuntungannya terlihat - bukan 5-10%, tetapi lebih signifikan. <br><br><blockquote>  blk-mq mungkin merupakan opsi terbaik untuk bekerja dengan SSD. </blockquote><br>  Dalam bentuknya saat ini, <strong>blk-mq</strong> secara langsung terkait dengan driver <strong>NVMe</strong> Linux.  Tidak hanya driver untuk Linux, tetapi juga driver untuk Microsoft.  Tetapi ide untuk membuat <strong>blk-mq</strong> dan driver NVMe adalah sangat pemrosesan tumpukan Linux, dari mana database sangat diuntungkan. <br><br>  Konsorsium beberapa perusahaan memutuskan untuk membuat spesifikasi, protokol ini.  Sekarang sudah dalam versi produksi berfungsi dengan baik untuk SSD PCIe lokal.  Solusi yang hampir siap untuk array disk yang terhubung melalui optik. <br><br><blockquote>  Driver blk-mq dan NVMe lebih dari sekadar penjadwal.  Sistem ini bertujuan untuk mengganti seluruh tingkat permintaan. </blockquote><br>  Mari selami itu untuk memahami apa itu.  Spesifikasi NVMe besar, jadi kami tidak akan mempertimbangkan semua detail, tetapi hanya membahasnya. <br><br><h3>  Pendekatan lama untuk elevator </h3><br><img src="https://habrastorage.org/webt/ya/82/ou/ya82oun8cusxylg0bsuz5y0e1la.jpeg"><br><br>  Kasus paling sederhana: ada CPU, ada gilirannya, dan entah bagaimana kita pergi ke disk. <br><br>  Elevators yang lebih maju bekerja secara berbeda.  Ada beberapa CPU dan beberapa antrian.  Entah bagaimana, misalnya, tergantung pada proses induk mana pekerja basis data berputar, IO akan antri pada disk. <br><br><h3>  Pendekatan baru untuk lift </h3><br>  blk-mq adalah pendekatan yang sama sekali baru.  Setiap CPU, setiap zona NUMA menambahkan input / output sendiri pada gilirannya.  Lebih lanjut, data jatuh pada disk, tidak peduli seberapa terhubung, karena driver baru.  Tidak ada driver SD yang beroperasi dengan konsep silinder, balok. <br><br><img src="https://habrastorage.org/webt/zf/12/7n/zf127n1eqhli2qioregzrsiftp8.jpeg"><br><br>  Ada masa transisi.  Pada titik tertentu, semua vendor array RAID mulai menjual add-on yang memungkinkan mereka untuk mem-bypass cache RAID.  Jika SSD terhubung, tulis langsung di sana.  Mereka mematikan penggunaan driver SD untuk produk mereka, seperti blq-mq. <br><br><h2>  Tumpukan baru dengan blk-mq </h2><br>  Beginilah tampilan tumpukan dalam formulir baru. <br><br><img src="https://habrastorage.org/webt/me/ma/3e/mema3e595wllaoub6thn61q8kvu.jpeg"><br><br>  Dari atas semuanya tetap ada juga.  Sebagai contoh, basis data jauh di belakang.  I / O dari database sama seperti sebelumnya, jatuh ke dalam lapisan Block IO.  Ada sangat <strong>blk-mq</strong> yang menggantikan lapisan kueri, bukan penjadwal. <br><br>  Di kernel 3.13, seluruh optimisasi berakhir pada saat itu, tetapi teknologi baru digunakan dalam kernel modern.  Penjadwal khusus untuk <strong>blk-mq</strong> mulai muncul, yang dirancang untuk paralelisme yang lebih kuat.     Linux    schedulers IO —  Kyber  BFQ.         <strong>blk-mq</strong> . <br><br> <strong>BFQ</strong> <strong>— Budget Fair Queueing — </strong> <strong></strong> <strong></strong> <strong>FQ</strong> .   ,     . BFQ —  scheduler   .         IO.     IO,  / .       ,   .     —  .   BFQ,   ,    . <br><br> <strong>Kyber —  </strong> .   BFQ,   .  Kyber  scheduler   .    —   CPU  . Kyber    . <br><br>      — <strong>blk-mq    SD-</strong> .      ,    ,  ,    IO-.  blk-mq  NVMe driver      .     . <br><br>        —   latency,      .   SSD,    —     .      -, ,    NVMe-,   blk-mq    ,    .    . <br><br><h2>   Linux IO </h2><br>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> / Linux. <br><br><img src="https://habrastorage.org/webt/ak/05/qb/ak05qbritsgbiaeybq3dmz2mpyi.png"><br><br>   ,    ,   ,  Elevators,   . <br><br>   ,           ,    . <br><br><h2>  NVM Express </h2><br> <strong>NVM Express  NVMe —  ,  ,     SSD.</strong>     Linux. Linux —     . <br><br>     .          20 /   SSD ,  NVMe  ,   , — <strong> 32 /</strong> .  SD    ,   ,     . <br><br><blockquote>    ,  ,   . </blockquote><br>  Begitu database ditulis untuk memutar disk dan berorientasi padanya - mereka memiliki indeks dalam bentuk B-tree, misalnya.  <strong>Muncul</strong> pertanyaan: <strong>apakah basis data siap untuk NVMe</strong> ?  Apakah database mampu mengunyah beban seperti itu? <br><br>  Belum, tetapi mereka beradaptasi.  Milis PostgreSQL baru-baru ini memiliki beberapa <code>pwrite()</code> dan hal-hal serupa.  Pengembang PostgreSQL dan MySQL berinteraksi dengan pengembang kernel.  Tentu saja, saya ingin lebih banyak interaksi. <br><br><h2>  Perkembangan Terkini </h2><br>  Selama satu setengah tahun terakhir, NVMe telah menambahkan <strong>polling IO</strong> . <br><br>  Pada awalnya ada cakram berputar dengan latensi tinggi.  Kemudian muncul SSD, yang jauh lebih cepat.  Tetapi ada masalah: fsync berlanjut, rekaman dimulai, dan pada tingkat yang sangat rendah - jauh di dalam pengemudi, permintaan dikirim langsung ke perangkat keras - tuliskan. <br><br>  Mekanismenya sederhana - mereka mengirimkannya dan kami menunggu sampai interupsi diproses.  Menunggu pemrosesan interupsi bukanlah masalah dibandingkan dengan menulis ke disk pemintalan.  Butuh waktu lama untuk menunggu sehingga segera setelah rekaman berakhir, interupsi itu bekerja. <br><br>  Karena SSD menulis dengan sangat cepat, mekanisme untuk polling perangkat keras tentang rekaman telah muncul dengan paksa.  Pada versi pertama, peningkatan kecepatan I / O mencapai 50% karena fakta bahwa kami tidak menunggu gangguan, tetapi kami secara aktif bertanya pada besi tentang catatan tersebut.  <strong>Mekanisme ini disebut polling IO</strong> . <br><br>  Itu diperkenalkan dalam versi terbaru.  Dalam versi 4.12, <strong>penjadwal IO</strong> muncul, khusus dipertajam untuk bekerja dengan <strong>blk-mq</strong> dan NVMe, tentang yang saya katakan <strong>Kyber dan BFQ</strong> .  Mereka sudah resmi di kernel, mereka bisa digunakan. <br><br>  Sekarang dalam bentuk yang dapat digunakan ada yang disebut <strong>penandaan IO</strong> .  Sebagian besar produsen cloud dan mesin virtual akan berkontribusi pada pengembangan ini.  Secara kasar, masukan dari aplikasi tertentu dapat diatasi dan memberikan prioritas.  Basis data belum siap untuk ini, tetapi tetap disini.  Saya pikir ini akan menjadi mainstream segera. <br><br><h2>  Catatan IO Langsung </h2><br>  <strong>PostgreSQL tidak mendukung Direct IO, dan ada sejumlah masalah yang membuatnya sulit untuk mengaktifkan dukungan</strong> .  Sekarang ini hanya didukung untuk nilai, dan hanya jika replikasi tidak diaktifkan.  Diperlukan <strong>untuk menulis banyak kode khusus OS</strong> , dan untuk saat ini semua orang tidak melakukan hal ini. <br><br>  Terlepas dari kenyataan bahwa Linux sangat bergantung pada gagasan Direct IO dan bagaimana implementasinya, semua database masuk ke sana.  Di Oracle dan MySQL, Direct IO banyak digunakan.  PostgreSQL adalah satu-satunya basis data yang tidak dapat ditoleransi oleh IO Langsung. <br><br><h2>  Periksa daftar </h2><br>  Cara melindungi diri Anda dari kejutan fsync di PostgreSQL: <br><br><ul><li>  Atur pos pemeriksaan agar lebih jarang dan lebih besar. </li><li>  Atur penulis latar belakang untuk membantu pos pemeriksaan. </li><li>  Tarik Autovacuum sehingga tidak ada I / O palsu yang tidak perlu. </li></ul><br><blockquote>  Menurut tradisi, pada bulan November kami menunggu pengembang profesional dari layanan yang sangat dimuat di Skolkovo di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HighLoad ++</a> .  Masih ada satu bulan untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengajukan</a> laporan, tetapi kami telah menerima laporan pertama ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">program</a> .  Mendaftar untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buletin</a> kami dan belajar tentang topik baru secara langsung. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459444/">https://habr.com/ru/post/id459444/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459430/index.html">Aplikasi seluler dengan pembuatan formulir otomatis: kasus kami</a></li>
<li><a href="../id459432/index.html">RD-180: bisakah AS membuat mesin roket?</a></li>
<li><a href="../id459434/index.html">React Hook Router Alternatif Modern React Router</a></li>
<li><a href="../id459438/index.html">Data masih lebih penting</a></li>
<li><a href="../id459442/index.html">5 sistem manajemen acara keamanan sumber terbuka</a></li>
<li><a href="../id459446/index.html">Lima tren desain modern yang menakutkan</a></li>
<li><a href="../id459450/index.html">Zoom kerentanan perangkat lunak telekonferensi memungkinkan setiap situs web memata-matai pengguna melalui webcam</a></li>
<li><a href="../id459452/index.html">Agro-robot dengan AI belajar untuk hati-hati mengumpulkan hanya salad matang dari kebun</a></li>
<li><a href="../id459454/index.html">Bagaimana hackathon pertama di The Standoff</a></li>
<li><a href="../id459456/index.html">Dagaz: Episode (Bagian 1)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>