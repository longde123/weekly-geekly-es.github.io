<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✌🏾 👨🏿‍💼 💗 Game NES modern ditulis dalam bahasa mirip Lisp 🤡 🏕️ 👇🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What Remains adalah game petualangan naratif untuk konsol video game NES 8-bit, dirilis pada Maret 2019 sebagai ROM gratis yang berjalan di emulator. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Game NES modern ditulis dalam bahasa mirip Lisp</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467125/">  What Remains adalah game petualangan naratif untuk konsol video game NES 8-bit, dirilis pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Maret 2019</a> sebagai ROM gratis yang berjalan di emulator.  Itu dibuat oleh tim kecil Iodine Dynamics selama dua tahun secara intermiten.  Saat ini, permainan sedang dalam tahap implementasi di perangkat keras: kami sedang membuat sejumlah kartrid terbatas dari bagian daur ulang. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db4/d1a/663/db4d1a6633208845a7e7ce5d670d82ac.jpg"></div><br>  Gim ini memiliki 6 level di mana pemain berjalan di sepanjang beberapa adegan dengan kartu gulir empat arah, berkomunikasi dengan NPC, mengumpulkan petunjuk, mengenal dunia mereka, memainkan mini-game dan menyelesaikan teka-teki sederhana.  Saya adalah insinyur kepala proyek, jadi saya menemui banyak kesulitan dalam mewujudkan visi tim.  Mengingat keterbatasan serius peralatan NES, cukup sulit untuk membuat game apa pun untuknya, belum lagi proyek dengan konten sebanyak di What Remains.  Hanya berkat subsistem berguna yang dibuat yang memungkinkan kami menyembunyikan kompleksitas ini dan mengelolanya, kami dapat bekerja sebagai tim dan menyelesaikan permainan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/956/a4d/921/956a4d9217a209643bb35b68e25694b5.png"></div><br>  Pada artikel ini saya akan berbicara tentang beberapa detail teknis dari setiap bagian dari mesin game.  Saya harap pengembang lain akan menemukan mereka berguna atau paling tidak ingin tahu. <br><a name="habracut"></a><br><h2>  Peralatan NES </h2><br>  Sebelum memulai kode, saya akan memberi tahu Anda sedikit tentang spesifikasi peralatan yang kami gunakan.  NES adalah konsol game yang dirilis pada tahun 1983 (Jepang, 1985 - Amerika).  Di dalamnya ada 8-bit CPU 6502 [1] dengan frekuensi 1,79 MHz.  Karena konsol menghasilkan 60 frame per detik, ada sekitar 30 ribu siklus CPU per frame, dan ini cukup kecil untuk menghitung semua yang terjadi dalam siklus gameplay utama. <br><br>  Selain itu, konsol memiliki total 2048 byte RAM (yang dapat diperluas menjadi 10.240 byte menggunakan RAM tambahan, yang tidak kami lakukan).  Itu juga dapat mengatasi 32 KB ROM pada suatu waktu, yang dapat diperluas dengan berpindah bank (Apa yang Tetap menggunakan ROM 512 KB).  Switching bank adalah topik kompleks [2] yang tidak ditangani oleh programmer modern.  Singkatnya, ruang alamat yang tersedia untuk CPU kurang dari data yang terkandung dalam ROM, yaitu, ketika diaktifkan secara manual, seluruh blok memori tetap tidak dapat diakses.  Apakah Anda ingin memanggil beberapa fungsi?  Tidak sampai Anda mengganti bank dengan memanggil perintah switching bank.  Jika ini tidak dilakukan, maka ketika fungsi dipanggil, program akan macet. <br><br>  Bahkan, hal yang paling sulit ketika mengembangkan game untuk NES adalah untuk mempertimbangkan semua ini pada saat yang sama.  Mengoptimalkan satu aspek dari kode, seperti penggunaan memori, seringkali dapat memengaruhi sesuatu yang lain, seperti kinerja CPU.  Kode harus efektif dan pada saat yang sama nyaman dalam dukungan.  Biasanya game diprogram dalam bahasa assembly. <br><br><h2>  Co2 </h2><br>  Tetapi dalam kasus kami, tidak demikian.  Sebaliknya, tandem dengan game akan mengembangkan bahasanya sendiri.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Co2</a> adalah bahasa mirip Lisp yang dibangun di atas Racket Scheme dan dikompilasi menjadi assembler 6502. Awalnya, bahasa tersebut diciptakan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dave Griffiths</a> untuk membangun demo What Remains, dan saya memutuskan untuk menggunakannya untuk seluruh proyek. <br><br>  Co2 memungkinkan Anda untuk menulis kode assembler bawaan jika perlu, tetapi juga memiliki kemampuan tingkat tinggi yang menyederhanakan beberapa tugas.  Ini mengimplementasikan variabel lokal yang efektif baik dalam hal konsumsi RAM dan kecepatan akses [2].  Ini memiliki sistem makro yang sangat sederhana yang memungkinkan Anda untuk menulis yang mudah dibaca dan pada saat yang sama kode efisien [3].  Yang paling penting, karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">homo-conicity dari</a> Lisp, sangat menyederhanakan tampilan data secara langsung di sumbernya. <br><br>  Menulis alat Anda sendiri cukup luas dalam pengembangan game, tetapi membuat seluruh bahasa pemrograman jauh lebih umum.  Namun, kami berhasil.  Tidak terlalu jelas apakah kerumitan pengembangan dan dukungan Co2 terbukti dengan sendirinya, tetapi pasti memiliki kelebihan yang membantu kami.  Dalam posting saya tidak akan berbicara secara rinci tentang karya Co2 (ini pantas artikel terpisah), tetapi saya akan terus-menerus menyebutkannya, karena penggunaannya agak terkait erat dengan proses pengembangan. <br><br>  Berikut adalah contoh kode Co2 yang menggambarkan latar belakang untuk adegan yang baru saja dimuat sebelum meredupkannya: <br><br><pre><code class="lisp hljs"><span class="hljs-comment"><span class="hljs-comment">; Render the nametable for the scene at the camera position (defsub (create-initial-world) (camera-assign-cursor) (set! camera-cursor (+ camera-cursor 60)) (let ((preserve-camera-v)) (set! preserve-camera-v camera-v) (set! camera-v 0) (loop i 0 60 (set! delta-v #xff) (update-world-graphics) (when render-nt-span-has (set! render-nt-span-has #f) (apply-render-nt-span-buffer)) (when render-attr-span-has (set! render-attr-span-has #f) (apply-render-attr-span-buffer))) (set! camera-v preserve-camera-v)) (camera-assign-cursor))</span></span></code> </pre> <br><h2>  Sistem Entitas </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee6/d87/ad4/ee6d87ad406879dbc9433c61fa4e3a5b.png"></div><br>  Gim real-time apa pun yang lebih kompleks daripada Tetris pada dasarnya adalah "sistem entitas".  Ini adalah fungsi yang memungkinkan berbagai aktor independen untuk bertindak secara bersamaan dan bertanggung jawab atas kondisi mereka sendiri.  Meskipun What Remains tidak berarti permainan aktif, ia masih memiliki banyak aktor independen dengan perilaku kompleks: mereka menghidupkan dan membuat sendiri, memeriksa tabrakan, dan menyebabkan dialog. <br><br>  Implementasinya cukup khas: array besar berisi daftar entitas dalam adegan, setiap catatan berisi data terkait entitas bersama dengan label tipe.  Fungsi pembaruan dalam siklus gameplay utama memotong semua entitas dan mengimplementasikan perilaku yang sesuai tergantung pada jenisnya. <br><br><pre> <code class="lisp hljs"><span class="hljs-comment"><span class="hljs-comment">; Called once per frame, to update each entity (defsub (update-entities) (when (not entity-npc-num) (return)) (loop k 0 entity-npc-num (let ((type)) (set! type (peek entity-npc-data (+ k entity-field-type))) (when (not (eq? type #xff)) (update-single-entity k type)))))</span></span></code> </pre> <br>  Cara menyimpan data entitas lebih menarik.  Secara umum, gim ini memiliki begitu banyak entitas unik sehingga penggunaan sejumlah besar ROM dapat menjadi masalah.  Di sini Co2 menunjukkan kekuatannya, memungkinkan kami untuk menyajikan setiap esensi adegan dalam bentuk yang ringkas namun mudah dibaca - sebagai aliran pasangan nilai kunci.  Selain data seperti posisi awal, hampir setiap kunci adalah opsional, yang memungkinkan mereka untuk dideklarasikan kepada entitas hanya jika diperlukan. <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">bytes</span></span> npc-diner-a <span class="hljs-number"><span class="hljs-number">172</span></span> <span class="hljs-number"><span class="hljs-number">108</span></span> prop-palette <span class="hljs-number"><span class="hljs-number">1</span></span> prop-hflip prop-picture picture-smoker-c prop-animation simple-cycle-animation prop-anim-limit <span class="hljs-number"><span class="hljs-number">6</span></span> prop-head hair-flip-head-tile <span class="hljs-number"><span class="hljs-number">2</span></span> prop-dont-turn-around prop-dialog-a (<span class="hljs-number"><span class="hljs-number">2</span></span> progress-stage-4 on-my-third my-dietician) prop-dialog-a (<span class="hljs-number"><span class="hljs-number">2</span></span> progress-stage-3 have-you-tried-the-pasta the-real-deal) prop-dialog-a (<span class="hljs-number"><span class="hljs-number">2</span></span> progress-diner-is-clean omg-this-cherry-pie its-like-a-party) prop-dialog-a (<span class="hljs-number"><span class="hljs-number">2</span></span> progress-stage-1 cant-taste-food puff-poof) prop-dialog-b (<span class="hljs-number"><span class="hljs-number">1</span></span> progress-stage-4 tea-party-is-not) prop-dialog-b (<span class="hljs-number"><span class="hljs-number">1</span></span> progress-stage-3 newspaper-owned-by-dnycorp) prop-dialog-b (<span class="hljs-number"><span class="hljs-number">1</span></span> progress-stage-2 they-paid-a-pr-guy) prop-dialog-b (<span class="hljs-number"><span class="hljs-number">1</span></span> progress-stage-1 it-seems-difficult) prop-customize (<span class="hljs-name"><span class="hljs-name">progress-stage-2</span></span> stop-smoking) <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Dalam kode ini, <code>prop-palette</code> mengatur <code>prop-palette</code> warna yang digunakan untuk entitas, <code>prop-anim-limit</code> menetapkan jumlah frame animasi, dan <code>prop-dont-turn-around</code> mencegah NPC berputar jika pemain mencoba untuk berbicara dengannya dari sisi lain.  Ini juga menetapkan beberapa tanda kondisi yang mengubah perilaku entitas dalam proses melewati permainan oleh pemain. <br><br>  Presentasi semacam ini sangat efektif untuk penyimpanan dalam ROM, tetapi sangat lambat saat diakses pada saat run time, dan akan terlalu tidak efisien untuk gameplay.  Oleh karena itu, ketika pemain memasuki adegan baru, semua entitas dalam adegan ini dimuat ke dalam RAM dan memproses semua kondisi yang dapat mempengaruhi keadaan awal mereka.  Tetapi Anda tidak dapat mengunduh detail apa pun untuk setiap entitas, karena akan memakan lebih banyak RAM daripada yang tersedia.  Mesin memuat hanya yang paling diperlukan untuk masing-masing entitas, ditambah pointer ke struktur penuhnya dalam ROM, yang direferensikan dalam situasi seperti menangani dialog.  Serangkaian kompromi khusus ini memungkinkan kami untuk memberikan tingkat kinerja yang memadai. <br><br><h2>  Portal </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c41/9dd/b90/c419ddb90349fbfb890c935e15bdfb95.png"></div><br>  Permainan What Remains memiliki banyak lokasi berbeda, beberapa adegan di jalan dengan peta bergulir dan banyak adegan di ruangan yang tetap statis.  Untuk berpindah dari satu ke yang lain, Anda perlu menentukan bahwa pemain telah mencapai pintu keluar, memuat adegan baru, dan kemudian menempatkan pemain pada titik yang diinginkan.  Pada tahap awal pengembangan, transisi tersebut digambarkan dengan cara yang unik sebagai dua adegan yang terhubung, misalnya, "kota pertama" dan "kafe" dan data dalam pernyataan if tentang lokasi pintu di setiap adegan.  Untuk menentukan di mana menempatkan pemain setelah mengubah adegan, Anda hanya perlu memeriksa di mana dia pergi dan ke mana, dan menempatkannya di sebelah pintu keluar yang sesuai. <br><br>  Namun, ketika kami mulai mengisi adegan "kota kedua", yang menghubungkan ke kota pertama di dua tempat yang berbeda, sistem seperti itu mulai berantakan.  Tiba-tiba, pasangan <code>(_, _)</code> tidak lagi cocok.  Setelah memikirkan hal ini, kami menyadari bahwa koneksi itu sendiri sangat penting, yang di dalam kode permainan disebut "portal".  Untuk menjelaskan perubahan ini, mesin telah ditulis ulang.  yang membawa kami ke situasi seperti entitas.  Portal dapat menyimpan daftar pasangan nilai kunci dan memuat di awal adegan.  Saat memasuki portal, Anda dapat menggunakan informasi posisi yang sama seperti ketika pergi.  Selain itu, penambahan kondisi disederhanakan, mirip dengan apa yang dimiliki entitas: pada titik-titik tertentu dalam permainan, kita dapat memodifikasi portal, misalnya, membuka atau menutup pintu. <br><br><pre> <code class="lisp hljs"><span class="hljs-comment"><span class="hljs-comment">; City A (bytes city-a-scene #x50 #x68 look-up portal-customize (progress-stage-5 remove-self) ; to Diner diner-scene #xc0 #xa0 look-down portal-width #x20 0)</span></span></code> </pre> <br>  Ini juga menyederhanakan proses menambahkan "titik teleportasi," yang sering digunakan dalam sisipan sinematik, di mana pemain harus pindah ke yang lain dalam adegan, tergantung pada apa yang terjadi dalam plot. <br><br>  Beginilah bentuk teleportasi di awal level 3: <br><br><pre> <code class="lisp hljs"><span class="hljs-comment"><span class="hljs-comment">; Jenny's home (bytes jenny-home-scene #x60 #xc0 look-up portal-teleport-only jenny-back-at-home-teleport 0)</span></span></code> </pre> <br>  Perhatikan nilai pencarian, yang menunjukkan arah untuk "pintu masuk" ke portal ini.  Saat meninggalkan portal, pemain akan melihat ke arah lain;  dalam hal ini, Jenny (karakter utama permainan) ada di rumah, sambil melihat ke bawah. <br><br><h2>  Blok teks </h2><br>  Rendering blok teks ternyata menjadi salah satu bagian kode paling kompleks di seluruh proyek.  Keterbatasan grafis NES terpaksa diakali.  Untuk mulai dengan, NES hanya memiliki satu lapisan untuk data grafik, yaitu, untuk membebaskan ruang untuk blok teks, Anda perlu menghapus bagian dari peta dengan latar belakang, dan kemudian mengembalikannya setelah menutup blok teks. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b8/7a5/d6f/6b87a5d6f4f44f8eb4fa9cf3b3242392.png"></div><br>  Selain itu, palet untuk setiap adegan individual harus berisi warna hitam dan putih untuk rendering teks, yang memberlakukan batasan tambahan pada artis.  Untuk menghindari konflik warna dengan latar belakang lainnya, blok teks harus disejajarkan dengan kisi 16 × 16 [5].  Menggambar blok teks dalam adegan dengan ruangan jauh lebih sederhana daripada di jalan di mana kamera dapat bergerak, karena dalam hal ini Anda harus mempertimbangkan buffer grafis yang bergulir secara vertikal dan horizontal.  Akhirnya, pesan layar jeda adalah kotak dialog standar yang sedikit dimodifikasi, karena menampilkan informasi yang berbeda, tetapi menggunakan kode yang hampir sama. <br><br>  Setelah sejumlah versi kereta kode, saya akhirnya berhasil menemukan solusi di mana pekerjaan dibagi menjadi dua tahap.  Pertama, semua perhitungan dilakukan yang menentukan di mana dan bagaimana cara menggambar blok teks, termasuk kode pemrosesan untuk semua kasus perbatasan.  Dengan demikian, semua kesulitan ini dibawa ke satu tempat. <br><br>  Kemudian, blok teks dengan pelestarian negara ditarik garis demi garis dan perhitungan dari tahap pertama digunakan agar tidak menyulitkan kode. <br><br><pre> <code class="lisp hljs"><span class="hljs-comment"><span class="hljs-comment">; Called once per frame as the text box is being rendered (defsub (text-box-update) (when (or (eq? tb-text-mode 0) (eq? tb-text-mode #xff)) (return #f)) (cond [(in-range tb-text-mode 1 4) (if (not is-paused) ; Draw text box for dialog. (text-box-draw-opening (- tb-text-mode 1)) ; Draw text box for pause. (text-box-draw-pausing (- tb-text-mode 1))) (inc tb-text-mode)] [(eq? tb-text-mode 4) ; Remove sprites in the way. (remove-sprites-in-the-way) (inc tb-text-mode)] [(eq? tb-text-mode 5) (if (not is-paused) ; Display dialog text. (when (not (crawl-text-update)) (inc tb-text-mode) (inc tb-text-mode)) ; Display paused text. (do (create-pause-message) (inc tb-text-mode)))] [(eq? tb-text-mode 6) ; This state is only used when paused. Nothing happens, and the caller ; has to invoke `text-box-try-exiting-pause` to continue. #t] [(and (&gt;= tb-text-mode 7) (&lt; tb-text-mode 10)) ; Erase text box. (if (is-scene-outside scene-id) (text-box-draw-closing (- tb-text-mode 7)) (text-box-draw-restoring (- tb-text-mode 7))) (inc tb-text-mode)] [(eq? tb-text-mode 10) ; Reset state to return to game. (set! text-displaying #f) (set! tb-text-mode 0)]) (return #t))</span></span></code> </pre> <br>  Jika Anda terbiasa dengan gaya Lisp, maka kode tersebut dibaca dengan cukup nyaman. <br><br><h2>  Sprite z-layers </h2><br>  Pada akhirnya, saya akan berbicara tentang detail kecil yang tidak terlalu mempengaruhi gameplay, tetapi menambahkan sentuhan yang bagus yang saya banggakan.  NES hanya memiliki dua komponen grafis: tabel nama (nametable), yang digunakan untuk latar belakang statis dan grid-aligned, dan sprite - objek berukuran 8x8 piksel, yang dapat ditempatkan di tempat sewenang-wenang.  Elemen-elemen seperti karakter pemain dan NPC biasanya dibuat sebagai sprite jika harus di atas grafik tabel nama. <br><br>  Namun, peralatan NES juga menyediakan kemampuan untuk menentukan sebagian sprite yang dapat sepenuhnya ditempatkan di bawah tabel nama.  Ini dengan mudah memungkinkan Anda untuk mewujudkan efek 3D yang keren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c6/4e0/c48/1c64e0c481f82d2b6569aa6326ea00a1.png"></div><br>  Ini berfungsi sebagai berikut: palet yang digunakan untuk adegan saat ini menangani warna pada posisi 0 dengan cara khusus: itu adalah warna latar belakang global.  Tabel nama digambar di atasnya, dan sprite dengan z-layer digambar di antara dua layer lainnya. <br><br>  Inilah palet dari adegan ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/23c/2c6/391/23c2c6391ae6301f9b527259250ee0e5.png"></div><br>  Jadi, warna abu-abu gelap di sudut paling kiri digunakan sebagai warna latar belakang global. <br><br>  Efek lapisan berfungsi sebagai berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d30/0ae/f89/d300aef890a928421a48d94968a263f9.png"></div><br>  Di sebagian besar gim lain, ini semua berakhir, Namun, What Remains telah mengambil satu langkah lebih maju.  Permainan tidak menempatkan Jenny sepenuhnya di depan atau di bawah grafik tabel nama - karakternya dibagi di antara mereka dengan cara yang benar.  Seperti yang dapat Anda lihat, sprite berukuran 8x8 unit, dan grafik seluruh karakter terdiri dari beberapa sprite (dari 3 hingga 6, tergantung pada frame animasi).  Setiap sprite dapat mengatur z-layer sendiri, yaitu, beberapa sprite akan berada di depan tabel nama, dan lainnya di belakangnya. <br><br>  Berikut adalah contoh efek ini dalam aksi: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/86b/3a3/ae5/86b3a3ae58931ef34d44640d7ff4c449.png"></div><br>  Algoritma untuk menerapkan efek ini cukup rumit.  Pertama, data tabrakan yang mengelilingi pemain diperiksa, pada ubin tertentu, yang mungkin membutuhkan seluruh karakter untuk menggambar.  Dalam diagram ini, ubin padat ditampilkan dalam kotak merah, dan ubin kuning menunjukkan bagian dengan z-layer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/10d/162/38c/10d16238cc137b14b8719479624f7245.png"></div><br>  Menggunakan berbagai heuristik, mereka digabungkan untuk membuat "titik referensi" dan topeng bit empat bit.  Empat kuadran relatif terhadap titik referensi sesuai dengan empat bit: 0 berarti bahwa pemain harus berada di depan daftar nama, 1 - yang ada di belakangnya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ccb/3a4/ff9/ccb3a4ff911243e0e771c3bd64e10134.png"></div><br>  Ketika menempatkan masing-masing sprite untuk menampilkan pemain, posisinya dibandingkan dengan titik referensi untuk menentukan z-layer sprite khusus ini.  Beberapa dari mereka berada di lapisan depan, yang lain di belakang. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ee/f36/273/0eef362737679bb6483465264ada9ba4.png"></div><br><h2>  Kesimpulan </h2><br>  Secara singkat saya berbicara tentang aspek-aspek berbeda dari cara kerja dalam game retro modern baru kami.  Ada jauh lebih menarik dalam basis kode, tetapi saya telah menguraikan bagian penting dari apa yang membuat permainan bekerja. <br><br>  Pelajaran paling penting yang saya pelajari dari proyek ini adalah manfaat yang bisa diperoleh dari mesin data driven.  Beberapa kali saya berhasil mengganti beberapa logika unik dengan sebuah tabel dan mini-interpreter, dan berkat ini, kode menjadi lebih sederhana dan lebih mudah dibaca. <br><br>  Saya harap Anda menikmati artikel ini! <br><br><hr><br><h3>  Catatan </h3><br>  [1] Sebenarnya, semacam CPU 6502 yang disebut Ricoh 2A03 dipasang di NES. <br><br>  [2] Faktanya, proyek ini meyakinkan saya bahwa menukar bank / mengelola ROM adalah batasan utama untuk setiap proyek SPN yang melebihi ukuran tertentu. <br><br>  [3] Untuk ini, orang harus berterima kasih kepada "tumpukan yang dikompilasi" - sebuah konsep yang digunakan dalam pemrograman embedded system, walaupun saya hampir tidak berhasil menemukan literatur tentangnya.  Singkatnya, Anda perlu membuat grafik lengkap panggilan proyek, mengurutkannya dari node daun ke root, dan kemudian menetapkan setiap node memori sama dengan kebutuhan + jumlah maksimum node anak. <br><br>  [4] Makro ditambahkan pada tahap perkembangan agak terlambat, dan, terus terang, kami tidak dapat mengambil keuntungan khusus dari mereka. <br><br>  [5] Anda dapat membaca lebih lanjut tentang grafik NES di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">seri artikel saya</a> .  Konflik warna disebabkan oleh atribut yang dijelaskan di bagian pertama. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467125/">https://habr.com/ru/post/id467125/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467111/index.html">Kiat radikal tentang cara menggantung lebih sedikit di ponsel Anda</a></li>
<li><a href="../id467113/index.html">Bagaimana cara menjaga pengguna di situs? Rahasia kegunaan</a></li>
<li><a href="../id467115/index.html">“Ls” atipikal - Edisi Habr</a></li>
<li><a href="../id467117/index.html">Naskah tidak terbakar: rahasia umur panjang gulungan Laut Mati kembali ke 250 SM</a></li>
<li><a href="../id467119/index.html">Mainkan IT-Alias ​​dengan Badoo Engineers</a></li>
<li><a href="../id467127/index.html">Menguji API menggunakan Postman dan Excel</a></li>
<li><a href="../id467129/index.html">Penegakan Kognitif 2: Mempelajari Ilusi dan Distorsi</a></li>
<li><a href="../id467131/index.html">CLRium # 6: Pasangkan laporan tentang Lock-Free, banyak teori dan pengetahuan praktis</a></li>
<li><a href="../id467135/index.html">Pedal USB untuk beralih antar komputer</a></li>
<li><a href="../id467137/index.html">Memastikan operasi Tim Zextras yang andal dalam jaringan perusahaan yang kompleks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>