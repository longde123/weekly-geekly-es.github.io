<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçüíª üôåüèª ‚èÆÔ∏è ClickHouse Product Analytics VKontakte üßòüèº üëÉ üôéüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Al desarrollar cualquier producto, ya sea un servicio de video o una cinta, historias o art√≠culos, quiero poder medir la "felicidad" condicional del u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ClickHouse Product Analytics VKontakte</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/vk/blog/445284/"><img src="https://habrastorage.org/webt/0f/oi/nf/0foinfaynjgjrh11h6w55fr5510.jpeg"><br><br>  Al desarrollar cualquier producto, ya sea un servicio de video o una cinta, historias o art√≠culos, quiero poder medir la "felicidad" condicional del usuario.  Para comprender si estamos haciendo nuestros cambios mejores o peores, para ajustar la direcci√≥n del desarrollo del producto, confiando no en la intuici√≥n y nuestros propios sentimientos, sino en m√©tricas y n√∫meros en los que puede creer. <br><br>  En este art√≠culo, le contar√© c√≥mo logramos lanzar estad√≠sticas y an√°lisis de productos en un servicio con una audiencia mensual de 97 millones, mientras recibimos consultas anal√≠ticas de rendimiento extremadamente alto.  Hablaremos sobre ClickHouse, los motores utilizados y las caracter√≠sticas de las consultas.  Describir√© un enfoque para la agregaci√≥n de datos, que nos permite obtener m√©tricas complejas en una fracci√≥n de segundo y hablar sobre la conversi√≥n y las pruebas de datos. <br><br>  Ahora tenemos alrededor de 6 mil millones de eventos alimenticios por d√≠a, en un futuro cercano alcanzaremos 20-25 mil millones.  Y luego, no a un ritmo tan r√°pido, aumentaremos a 40-50 mil millones para fin de a√±o, cuando describamos todos los eventos de alimentos que nos interesan. <br><br>  <b>1 filas en conjunto.</b>  <b>Transcurrido: 0.287 seg.</b>  <b>Procesado 59.85 mil millones de filas, 59.85 GB (208.16 mil millones de filas / s., 208.16 GB / s.)</b> <br><br>  Detalles debajo del corte. <br><a name="habracut"></a><br><h1>  Pr√≥logo </h1><br>  Las herramientas anal√≠ticas fueron VKontakte antes.  Se consideraron usuarios √∫nicos, fue posible construir cronogramas de eventos por sectores y, por lo tanto, caer en las profundidades del servicio.  Sin embargo, se trataba de cortes fijos por adelantado, de datos agregados, de HLL para los √∫nicos, de cierta rigidez e incapacidad para responder r√°pidamente preguntas un poco m√°s complicadas que "¬øcu√°nto?" <br><br>  Por supuesto, hubo, hay y habr√° hadoop, tambi√©n fue escrito, escrito y se escribir√° mucho, muchos registros de uso de servicios.  Desafortunadamente, hdfs fue utilizado solo por algunos equipos para implementar sus propias tareas.  A√∫n m√°s triste, hdfs no se trata de consultas anal√≠ticas r√°pidas: hubo preguntas en muchos campos, las respuestas se tuvieron que encontrar en el c√≥digo y no en la documentaci√≥n accesible para todos. <br><br>  Llegamos a la conclusi√≥n de que ya no es posible vivir as√≠.  Cada equipo debe tener datos, las consultas sobre ellos deben ser r√°pidas y los datos en s√≠ mismos deben ser precisos y ricos en par√°metros √∫tiles. <br><br>  Por lo tanto, formulamos requisitos claros para el nuevo sistema de estad√≠sticas / an√°lisis: <br><br><ul><li>  las consultas anal√≠ticas deben ser r√°pidas; </li><li>  los datos son bastante precisos, idealmente estos son eventos de interacci√≥n del usuario sin procesar con el servicio; </li><li>  la estructura de los eventos debe ser descrita, entendida y accesible; </li><li>  almacenamiento de datos confiable, garant√≠a de entrega √∫nica; </li><li>  es posible contar los √∫nicos, la audiencia (diaria, semanal, mensual), las m√©tricas de retenci√≥n, el tiempo que el usuario pasa en el servicio, las acciones cuantificadas en m√©tricas √∫nicas y otras por el conjunto de sectores; </li><li>  Las pruebas, la conversi√≥n de datos y la visualizaci√≥n est√°n en progreso. </li></ul><br><h1>  En la cocina </h1><br>  La experiencia sugiri√≥ que necesit√°bamos dos bases de datos: una lenta, donde agregar√≠amos y enriquecer√≠amos los datos, y una r√°pida, donde podr√≠amos trabajar con estos datos y construir gr√°ficos sobre ellos.  Este es uno de los enfoques m√°s comunes, en el que, en una base de datos lenta, por ejemplo, en hdfs, se construyen diferentes proyecciones, sobre las √∫nicas y sobre el n√∫mero de eventos por sectores durante un cierto per√≠odo de tiempo. <br><br>  En un c√°lido d√≠a de septiembre, mientras hablamos con una taza de t√© en la cocina con vista a la Catedral de Kazan, tuvimos la idea de probar ClickHouse como base r√°pida; en ese momento ya lo us√°bamos para almacenar registros t√©cnicos.  Hubo muchas dudas asociadas principalmente con la velocidad y la confiabilidad: las pruebas de rendimiento declaradas parec√≠an poco realistas, y las nuevas versiones de la base de datos romp√≠an peri√≥dicamente la funcionalidad existente.  Por lo tanto, la propuesta era simple: probar. <br><br><h1>  Primeras muestras </h1><br>  Implementamos un cl√∫ster de dos m√°quinas con esta configuraci√≥n: <br>  2xE5-2620 v4 (32 n√∫cleos en total), 256G ram, 28T lugares (raid10 con ext4). <br><br>  Inicialmente, estaba cerca del dise√±o, pero luego cambiamos a lejos.  ClickHouse tiene muchos motores de mesa diferentes, pero los principales son de la familia MergeTree.  Elegimos ReplicatedReplacingMergeTree con aproximadamente la siguiente configuraci√≥n: <br><br><pre><code class="sql hljs">PARTITION BY dt ORDER BY (toStartOfHour(time), cityHash64(user_id), event_microsec, event_id) SAMPLE BY cityHash64(user_id) SETTINGS index_granularity = 8192;</code> </pre> <br>  <b>Replicado</b> : significa que la tabla se replica y esto resuelve uno de nuestros requisitos de confiabilidad. <br><br>  <b>Reemplazo</b> : la tabla admite la deduplicaci√≥n por la clave primaria: de forma predeterminada, la clave primaria coincide con la clave de clasificaci√≥n, por lo que la secci√≥n ORDER BY simplemente le indica cu√°l es la clave primaria. <br><br>  <b>SAMPLE BY</b> - Tambi√©n quer√≠a probar el muestreo: la muestra devuelve una muestra pseudoaleatoria uniforme. <br><br>  <b>index_granularity = 8192</b> es el n√∫mero m√°gico de filas de datos entre serif de √≠ndice (s√≠, es escaso), que se usa por defecto.  No lo cambiamos. <br><br>  El particionamiento se realiz√≥ por d√≠a (aunque por defecto, por mes).  Se supon√≠a que muchas solicitudes de datos eran intrad√≠a, por ejemplo, crear un gr√°fico de minutos de vistas de video para un d√≠a determinado. <br><br>  Luego, tomamos un trozo de registros t√©cnicos y llenamos la mesa con aproximadamente mil millones de filas.  Excelente compresi√≥n, agrupaci√≥n por tipo de columna Int *, contando valores √∫nicos: ¬°todo funcion√≥ incre√≠blemente r√°pido! <br><br>  Hablando de velocidad, quiero decir que ni una sola solicitud dur√≥ m√°s de 500 ms, y la mayor√≠a de ellos se ajustan a 50-100 ms.  Y esto est√° en dos m√°quinas, y, de hecho, solo una estuvo involucrada en los c√°lculos. <br><br>  Analizamos todo esto e imaginamos que en lugar de la columna UInt8 habr√° una identificaci√≥n del pa√≠s, y la columna Int8 ser√° reemplazada por datos, por ejemplo, sobre la edad del usuario.  Y se dieron cuenta de que ClickHouse es completamente adecuado para nosotros, si todo se hace correctamente. <br><br><h1>  Fuerte tipificaci√≥n de datos </h1><br>  El beneficio de ClickHouse comienza exactamente cuando se forma el esquema de datos correcto.  Ejemplo: plataforma String - mala, plataforma Int8 + diccionario - buena, LowCardinality (String) - conveniente y buena (hablar√© de LowCardinality un poco m√°s adelante). <br><br>  Creamos una clase de generador especial en php, que, a pedido, crea clases de envoltura sobre eventos basados ‚Äã‚Äãen tablas en ClickHouse, y un √∫nico punto de entrada al registro.  Explicar√© el ejemplo del esquema que result√≥: <br><br><ol><li>  El analista / ingeniero de datos / desarrollador describe la documentaci√≥n: qu√© campos, posibles valores, eventos deben registrarse. </li><li>  Se crea una tabla en ClickHouse de acuerdo con la estructura de datos del p√°rrafo anterior. </li><li>  Se generan clases de envoltura para eventos basados ‚Äã‚Äãen una tabla. </li><li>  El equipo de producto implementa rellenando los campos de un objeto de esta clase, enviando. </li></ol><br>  Cambiar el esquema a nivel de php y el tipo de datos registrados no funcionar√° sin cambiar primero la tabla en ClickHouse.  Y esto, a su vez, no puede hacerse sin coordinaci√≥n con el equipo, cambios en la documentaci√≥n y descripci√≥n de los eventos. <br><br>  Para cada evento, puede establecer dos configuraciones que controlan el porcentaje de eventos enviados a ClickHouse y hadoop, respectivamente.  La configuraci√≥n es necesaria principalmente para un avance gradual con la capacidad de reducir el registro si algo sale mal.  Antes de hadoop, los datos se entregan de manera est√°ndar utilizando Kafka.  Y en ClickHouse, vuelan a trav√©s de un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esquema con KittenHouse</a> en modo persistente, lo que garantiza al menos la entrega de un solo evento. <br><br>  El evento se entrega a la tabla de b√∫fer en el fragmento deseado, en funci√≥n del resto de dividir alg√∫n hash de user_id por el n√∫mero de fragmentos en el cl√∫ster.  A continuaci√≥n, la tabla de b√∫fer vac√≠a los datos al ReplicatedReplacingMergeTree local.  Y encima de las tablas locales, se extrae una tabla distribuida con el motor Distribuido, que le permite acceder a los datos de todos los fragmentos. <br><br><h1>  Desnormalizaci√≥n </h1><br>  ClickHouse es un DBMS columnar.  No se trata de formas normales, lo que significa que es mejor tener toda la informaci√≥n correcta en el evento que unirse.  Tambi√©n hay Join, pero si la tabla correcta no cabe en la memoria, comienza el dolor.  Por lo tanto, tomamos una decisi√≥n decidida: toda la informaci√≥n que nos interesa debe almacenarse en el evento en s√≠.  Por ejemplo, g√©nero, edad del usuario, pa√≠s, ciudad, fecha de nacimiento: toda esa informaci√≥n p√∫blica puede ser √∫til para el an√°lisis de la audiencia, as√≠ como toda la informaci√≥n √∫til sobre el objeto de interacci√≥n.  Si, por ejemplo, estamos hablando de video, es video_id, video_owner_id, fecha de carga del video, duraci√≥n, calidad en el momento del evento, calidad m√°xima, etc. <br><br>  En total, en cada tabla tenemos de 50 a 200 columnas, mientras que en todas las tablas hay campos de servicio.  Por ejemplo, el registro de errores es error_log; de hecho, llamamos a un error fuera del rango del tipo.  En caso de que los valores extra√±os vayan m√°s all√° del tama√±o del tipo en el campo con la edad. <br><br><h2>  Tipo de baja cardinalidad (T) </h2><br>  ClickHouse tiene la capacidad de usar diccionarios externos.  Se almacenan en la memoria, se actualizan peri√≥dicamente, se pueden usar de manera efectiva en varios escenarios, incluso como libros de referencia cl√°sicos.  Por ejemplo, desea registrar el sistema operativo y tiene dos alternativas: una cadena o un n√∫mero + un directorio.  Por supuesto, en grandes cantidades de datos y para consultas anal√≠ticas de alto rendimiento, es l√≥gico escribir un n√∫mero y obtener una representaci√≥n de cadena del diccionario cuando necesite: <br><br><pre> <code class="sql hljs">dictGetString('os', 'os_name', toUInt64(os_id))</code> </pre> <br>  Pero hay una forma mucho m√°s conveniente: usar el tipo LowCardinality (String), que crea autom√°ticamente un diccionario.  El rendimiento con LowCardinality bajo la condici√≥n de baja cardinalidad del conjunto de valores es radicalmente mayor que con String. <br><br>  Por ejemplo, usamos LowCardinality (String) para los tipos de evento 'play', 'pause', 'rewind'.  O para la plataforma: 'web', 'android', 'iphone': <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> vk_platform, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> dt = yesterday() <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> vk_platform Elapsed: <span class="hljs-number"><span class="hljs-number">0.145</span></span> sec. Processed <span class="hljs-number"><span class="hljs-number">1.98</span></span> billion <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>, <span class="hljs-number"><span class="hljs-number">5.96</span></span> GB (<span class="hljs-number"><span class="hljs-number">13.65</span></span> billion <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>/s., <span class="hljs-number"><span class="hljs-number">41.04</span></span> GB/s.)</code> </pre> <br>  La caracter√≠stica a√∫n es experimental, por lo que para usarla debe realizar: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> allow_experimental_low_cardinality_type = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Pero existe la sensaci√≥n de que despu√©s de un tiempo ya no estar√° en el entorno. <br><br><h1>  Agregaci√≥n de datos de VKontakte </h1><br>  Dado que hay muchas columnas, y hay muchos eventos, el deseo natural es cortar las particiones "viejas", pero primero, ensamblar las unidades.  Ocasionalmente, es necesario analizar eventos sin procesar (hace un mes o un a√±o), por lo que no recortamos los datos en hdf; cualquier analista puede comunicarse con el parquet deseado para cualquier fecha. <br><br>  Como regla general, cuando se agrega en un intervalo de tiempo, siempre descansamos en el hecho de que el n√∫mero de filas por unidad de tiempo es igual al producto de la potencia de corte.  Esto impone restricciones: los pa√≠ses comienzan a agruparse en grupos como 'Rusia', 'Asia', 'Europa', 'El resto del mundo' y edades, a intervalos, para reducir la dimensi√≥n a un mill√≥n condicional de l√≠neas por fecha. <br><br><h2>  Agregaci√≥n por <b>dt, user_id</b> </h2><br>  ¬°Pero tenemos un ClickHouse reactivo!  ¬øPodemos acelerar a 50-100 millones de l√≠neas en una fecha? <br>  Las pruebas r√°pidas demostraron que podemos, y en ese momento surgi√≥ una idea simple: dejar al usuario en la m√°quina.  Es decir, agregar no por "fecha, cortes" usando herramientas de chispa, sino por "fecha, usuario" significa por ClickHouse, mientras se hace una "transposici√≥n" de datos. <br><br>  Con este enfoque, almacenamos a los usuarios en datos agregados, lo que significa que a√∫n podemos considerar indicadores de audiencia, retenci√≥n y m√©tricas de frecuencia.  Podemos conectar unidades, contando las audiencias comunes de varios servicios hasta toda la audiencia de VKontakte.  Todo esto puede hacerse por cualquier segmento que est√© presente en la tabla condicionalmente al mismo tiempo. <br><br>  Ilustrar√© con un ejemplo: <br><br><img src="https://habrastorage.org/webt/1n/zq/23/1nzq23ia7micv91mecw0kqzxgrm.jpeg"><br><br>  Despu√©s de la agregaci√≥n (muchas m√°s columnas a la derecha): <br><br><img src="https://habrastorage.org/webt/nx/ol/xl/nxolxl2vmnnlsxlx6svuaklh9go.jpeg"><br><br>  En este caso, la agregaci√≥n ocurre precisamente por (dt, user_id).  Para los campos con informaci√≥n del usuario, con dicha agregaci√≥n, puede usar las funciones any, anyHeavy (selecciona un valor frecuente).  Puede, por ejemplo, recopilar anyHeavy (plataforma) en conjunto para saber qu√© plataforma est√° utilizando el usuario en su mayor parte de los eventos de video.  Si lo desea, puede usar groupUniqArray (plataforma) y almacenar una matriz de todas las plataformas desde las cuales el usuario gener√≥ el evento.  Si esto no es suficiente, puede crear columnas separadas para la plataforma y almacenar, por ejemplo, la cantidad de videos √∫nicos proyectados a la mitad desde una plataforma espec√≠fica: <br><br><pre> <code class="sql hljs">uniqCombinedIf(cityHash64(video_owner_id, video_id), (platform = 'android') AND (event = '50p')) as uniq_videos_50p_android</code> </pre> <br>  Con este enfoque, se obtiene un agregado bastante amplio en el que cada fila es un usuario √∫nico y cada columna contiene informaci√≥n sobre el usuario o sobre su interacci√≥n con el servicio. <br><br>  Resulta que para calcular la DAU de un servicio, es suficiente ejecutar dicha solicitud adem√°s de su agregado: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> dt, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> DAU <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> agg <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> dt Elapsed: <span class="hljs-number"><span class="hljs-number">0.078</span></span> sec.</code> </pre> <br>  O calcule cu√°ntos d√≠as los usuarios estuvieron en el servicio durante la semana: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> days_in_service, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> uniques <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> uniqUpTo(<span class="hljs-number"><span class="hljs-number">7</span></span>)(dt) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> days_in_service <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> agg2 <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> dt &gt; (yesterday() - <span class="hljs-number"><span class="hljs-number">7</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> user_id ) <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> days_in_service <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> days_in_service <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> set. Elapsed: <span class="hljs-number"><span class="hljs-number">2.922</span></span> sec.</code> </pre> <br>  Podemos acelerar por muestreo, mientras casi sin perder precisi√≥n: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> days_in_service, <span class="hljs-number"><span class="hljs-number">10</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> uniques <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> uniqUpTo(<span class="hljs-number"><span class="hljs-number">7</span></span>)(dt) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> days_in_service <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> agg2 <span class="hljs-keyword"><span class="hljs-keyword">SAMPLE</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> dt &gt; (yesterday() - <span class="hljs-number"><span class="hljs-number">7</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> user_id ) <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> days_in_service <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> days_in_service <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> set. Elapsed: <span class="hljs-number"><span class="hljs-number">0.454</span></span> sec.</code> </pre> <br>  Cabe se√±alar de inmediato que el muestreo no es por el porcentaje de eventos, sino por el porcentaje de usuarios, y como resultado se convierte en una herramienta incre√≠blemente poderosa. <br><br>  O lo mismo durante 4 semanas con 1/100 de muestreo: se obtienen resultados 1% menos precisos. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> days_in_service, <span class="hljs-number"><span class="hljs-number">100</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> uniques <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> uniqUpTo(<span class="hljs-number"><span class="hljs-number">7</span></span>)(dt) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> days_in_service <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> agg2 <span class="hljs-keyword"><span class="hljs-keyword">SAMPLE</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> dt &gt; (yesterday() - <span class="hljs-number"><span class="hljs-number">28</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> user_id ) <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> days_in_service <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> days_in_service <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span> <span class="hljs-number"><span class="hljs-number">28</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> set. Elapsed: <span class="hljs-number"><span class="hljs-number">0.287</span></span> sec.</code> </pre> <br><h2>  Agregaci√≥n por otro lado </h2><br>  Al agregar por (dt, user_id), no perdemos al usuario, no perdemos informaci√≥n sobre su interacci√≥n con el servicio, pero, por supuesto, perdemos las m√©tricas sobre un objeto de interacci√≥n espec√≠fico.  Pero tampoco puedes perder esto: construyamos la unidad <br>  (dt, video_owner_id, video_id), adhiri√©ndose a las mismas ideas.  Mantenemos la informaci√≥n sobre el video tanto como sea posible, no nos perdemos los datos sobre la interacci√≥n del video con el usuario, y extra√±amos por completo la informaci√≥n sobre el usuario espec√≠fico. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> starts <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> agg3 <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> (dt = yesterday()) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> (video_id = ...) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> (video_owner_id = ...) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> set. Elapsed: <span class="hljs-number"><span class="hljs-number">0.030</span></span> sec</code> </pre> <br>  O las 10 mejores vistas de video de ayer: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> video_id, video_owner_id, watches <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> video_agg_video_d1 <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> dt = yesterday() <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> watches <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> set. Elapsed: <span class="hljs-number"><span class="hljs-number">0.035</span></span> sec.</code> </pre> <br>  Como resultado, tenemos un esquema de unidades de la forma: <br><br><ul><li>  agregaci√≥n por "fecha, usuario" dentro del producto; </li><li>  agregaci√≥n por "fecha, objeto de interacci√≥n" dentro del producto; </li><li>  a veces surgen otras proyecciones. </li></ul><br><h1>  Azkaban y TeamCity </h1><br>  Finalmente, algunas palabras sobre la infraestructura.  Nuestra colecci√≥n agregada comienza por la noche, comenzando con OPTIMIZE en cada una de las tablas con datos sin procesar para desencadenar una fusi√≥n de datos extraordinaria en ReplicatedReplacingMergeTree.  La operaci√≥n puede durar lo suficiente, sin embargo, si es necesario, es necesario eliminar las tomas.  Vale la pena se√±alar que hasta ahora nunca he encontrado duplicados, pero no hay garant√≠as de que no aparezcan en el futuro. <br><br>  El siguiente paso es la creaci√≥n de agregados.  Estos son scripts de bash en los que ocurre lo siguiente: <br><br><ul><li>  primero obtenemos el n√∫mero de fragmentos y alg√∫n host del fragmento: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> shard_num, <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>(host_name) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> host <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> system.clusters <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> shard_num</code> </pre> </li><li>  entonces el script ejecuta secuencialmente para cada fragmento (clickhouse-client -h $ host) una solicitud del formulario (para agregados de usuarios): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">SAMPLE</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>/$shards_count <span class="hljs-keyword"><span class="hljs-keyword">OFFSET</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>/$shard_num</code> </pre> </li></ul><br>  Esto no es del todo √≥ptimo y puede generar mucha interacci√≥n de red entre hosts.  Sin embargo, al agregar nuevos fragmentos, todo sigue funcionando de forma inmediata, se mantiene la localidad de los datos de las unidades, por lo que decidimos no preocuparnos mucho por eso. <br><br>  Tenemos a Azkaban como el programador de tareas.  No dir√≠a que esta es una herramienta s√∫per conveniente, pero hace frente a su tarea perfectamente, incluso cuando se trata de construir tuber√≠as un poco m√°s complejas y cuando un script necesita esperar a que se completen varios otros. <br><br>  El tiempo total que se dedica a convertir los eventos que ahora existen en agregados es de 15 minutos. <br><br><h2>  Prueba </h2><br>  Todas las ma√±anas realizamos pruebas automatizadas que responden preguntas sobre datos sin procesar, as√≠ como la disponibilidad y la calidad de los agregados: "Compruebe que para ayer no hab√≠a m√°s de medio por ciento menos de datos o datos √∫nicos sobre datos sin procesar o en agregados en comparaci√≥n con el mismo d√≠a hace una semana ". <br><br>  Tecnol√≥gicamente, estas son pruebas unitarias comunes que usan JUnit e implementan el controlador jdbc para ClickHouse.  La ejecuci√≥n de todas las pruebas se inicia en TeamCity y dura aproximadamente 30 segundos en 1 subproceso, y en caso de fallas, recibimos notificaciones VKontakte de nuestro maravilloso bot TeamCity. <br><br><h1>  Conclusi√≥n </h1><br>  Use solo versiones estables de ClickHouse y su cabello ser√° suave y sedoso.  Vale la pena agregar que <b><i>ClickHouse no se ralentiza</i></b> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/445284/">https://habr.com/ru/post/445284/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../445272/index.html">JavaScript es el mejor lenguaje de programaci√≥n para principiantes. Entonces, ¬øes o no?</a></li>
<li><a href="../445274/index.html">Cuando "Zo√´"! == "Zo√´", o por qu√© necesita normalizar cadenas Unicode</a></li>
<li><a href="../445276/index.html">Gu√≠a completa de efectos de uso</a></li>
<li><a href="../445278/index.html">C√≥mo crear un juego si nunca eres un artista</a></li>
<li><a href="../445280/index.html">Rentabilidad de sitios y servicios.</a></li>
<li><a href="../445286/index.html">Reposapi√©s para el cerebro: plataforma de registro distribuido Hedera Hashgraph</a></li>
<li><a href="../445288/index.html">Todos sus pr√©stamos de consumo y datos personales "en un solo lugar" ...</a></li>
<li><a href="../445290/index.html">¬øC√≥mo implementar procesos unificados teniendo en cuenta todas las caracter√≠sticas de la empresa?</a></li>
<li><a href="../445292/index.html">Lo que nunca me han contado sobre CSS</a></li>
<li><a href="../445294/index.html">Y nuevamente sobre el segundo monitor de la tableta ...</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>