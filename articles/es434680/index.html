<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüíº üó∫Ô∏è üôáüèø Evoluci√≥n del programador de tareas üë®üèæ‚Äçüîß üí§ üßùüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La aplicaci√≥n iFunny en la que estamos trabajando ha estado disponible en las tiendas por m√°s de cinco a√±os. Durante este tiempo, el equipo m√≥vil tuvo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Evoluci√≥n del programador de tareas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/434680/"><img src="https://habrastorage.org/webt/bv/mr/ps/bvmrpspwu-kyhojb5tiu4lqbdi8.jpeg"><br><br>  La aplicaci√≥n iFunny en la que estamos trabajando ha estado disponible en las tiendas por m√°s de cinco a√±os.  Durante este tiempo, el equipo m√≥vil tuvo que pasar por diferentes enfoques y migraciones entre herramientas, y hace un a√±o hubo un momento para cambiar de una soluci√≥n autoescrita y buscar algo m√°s "de moda" y generalizado.  Este art√≠culo es un peque√±o resumen sobre lo que se ha estudiado, qu√© soluciones se han analizado y con qu√© han terminado. <a name="habracut"></a><br><br>  <b>¬øPor qu√© necesitamos todo esto?</b> <br><br>  Decidamos inmediatamente en honor de qu√© es este art√≠culo y por qu√© este tema result√≥ ser importante para el equipo de desarrollo de Android: <br><br><ol><li>  Hay muchos escenarios en los que necesita ejecutar tareas fuera del marco de la interfaz de usuario activa; </li><li>  el sistema impone una gran cantidad de restricciones al lanzamiento de tales tareas; </li><li>  Result√≥ ser bastante dif√≠cil elegir entre las soluciones existentes, ya que cada herramienta tiene sus ventajas y desventajas. </li></ol><br><h3>  <b>Cronolog√≠a del desarrollo de eventos.</b> </h3><br>  <b>Android 0</b> <b><br></b> <h3>  AlarmManager, Handler, Servicio </h3><br>  Inicialmente, sus soluciones se implementaron para lanzar tareas en segundo plano basadas en servicios.  Tambi√©n hab√≠a un mecanismo que vinculaba las tareas con el ciclo de vida y pod√≠a cancelarlas y restaurarlas.  Esto fue adecuado para el equipo durante mucho tiempo, ya que la plataforma no impuso ninguna restricci√≥n en tales tareas. <br>  Google aconsej√≥ hacer esto seg√∫n el siguiente diagrama: <br><br><img src="https://habrastorage.org/webt/e-/46/zn/e-46znleyxvynpm35pbebgrkdhk.png"><br><br>  A finales de 2018, no tiene sentido entender esto, es suficiente para evaluar la magnitud del desastre. <br>  De hecho, a nadie le importaba cu√°nto trabajo est√° sucediendo en el fondo.  Las aplicaciones hicieron lo que quisieron y cuando quisieron. <br><br>  <i><b>Pros</b> :</i> <i><br></i>  <i>disponible en todas partes;</i> <i><br></i>  <i>accesible a todos.</i> <i><br><br></i>  <i><b>Contras</b> :</i> <i><br></i>  <i>el sistema restringe el trabajo en todos los sentidos;</i> <i><br></i>  <i>sin lanzamientos por condici√≥n;</i> <i><br></i>  <i>La API es m√≠nima y necesita escribir mucho c√≥digo.</i> <i><br></i> <br>  <b>Android 5. Lollipop</b> <b><br></b> <h3>  Jobcheduler </h3><br>  Despu√©s de 5 (!) A√±os, m√°s cerca de 2015, Google not√≥ que las tareas se inician de manera ineficiente.  Los usuarios comenzaron a quejarse regularmente de que sus tel√©fonos se estaban agotando simplemente acostados en una mesa o en su bolsillo. <br><br>  Con el lanzamiento de Android 5, apareci√≥ una herramienta como JobScheduler.  Este es un mecanismo con cuya ayuda es posible llevar a cabo varios trabajos en segundo plano, cuyo comienzo se optimiz√≥ y simplific√≥ debido al sistema centralizado para iniciar estas tareas y la capacidad de establecer condiciones para este mismo lanzamiento. <br><br>  En el c√≥digo, todo esto parece bastante simple: se anuncia un servicio en el que llegan los eventos de inicio y finalizaci√≥n. <br>  Desde los matices: si desea realizar el trabajo de forma asincr√≥nica, desde onStartJob debe iniciar la secuencia;  lo principal es no olvidar llamar al trabajo M√©todo terminado al final del trabajo, de lo contrario el sistema no soltar√° WakeLock, su tarea no se considerar√° completada y se perder√°. <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobSchedulerService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStartJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobParameters params)</span></span></span><span class="hljs-function"> </span></span>{ doWork(params); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStopJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobParameters params)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre> <br>  Desde cualquier lugar de la aplicaci√≥n, puede iniciar este trabajo.  Las tareas se realizan en nuestro proceso, pero se inician a nivel de IPC.  Existe un mecanismo centralizado que controla su ejecuci√≥n y activa la aplicaci√≥n solo en los momentos necesarios para esto.  Tambi√©n puede establecer varias condiciones de activaci√≥n y transferir datos a trav√©s del paquete. <br><br><pre> <code class="java hljs">JobInfo task = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JobInfo.Builder(JOB_ID, serviceName) .setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED) .setRequiresDeviceIdle(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .setRequiresCharging(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .build(); JobScheduler scheduler = (JobScheduler) context.getSystemService(JOB_SCHEDULER_SERVICE); scheduler.schedule(task);</code> </pre> <br>  En general, comparado con nada, esto ya era algo.  Pero este mecanismo solo est√° disponible con API 21, y en el momento del lanzamiento de Android 5.0 ser√≠a extra√±o dejar de admitir todos los dispositivos antiguos (han pasado 3 a√±os y todav√≠a admitimos cuatro). <br><br>  <i><b>Pros</b> :</i> <i><br></i>  <i>La API es simple;</i> <i><br></i>  <i>condiciones para el lanzamiento.</i> <i><br></i> <br>  <b><i>Contras</i></b> : <br>  <s>Disponible a partir de API 21</s> <br>  de hecho, solo con API 23; <br>  Es f√°cil cometer un error. <br><br>  <b>Android 5. Lollipop</b> <b><br></b> <h3>  <b>Administrador de red de gcm</b> </h3><br>  Tambi√©n se present√≥ un an√°logo de JobScheduler: GCM Network Manager.  Esta es una biblioteca que proporcionaba una funcionalidad similar, pero que ya funcionaba con la API 9. Es cierto que a cambio requer√≠a los servicios de Google Play.  Aparentemente, la funcionalidad necesaria para que JobScheduler funcione, comenz√≥ a entregarse no solo a trav√©s de la versi√≥n de Android, sino tambi√©n a nivel de GPS.  Cabe se√±alar que los desarrolladores del marco cambiaron de opini√≥n muy r√°pidamente y decidieron no conectar su futuro con el GPS.  Gracias a ellos por eso. <br><br>  Todo se ve absolutamente id√©ntico.  Mismo servicio: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GcmNetworkManagerService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GcmTaskService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onRunTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TaskParams taskParams)</span></span></span><span class="hljs-function"> </span></span>{ doWork(taskParams); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre><br>  El mismo inicio de tarea: <br><br><pre> <code class="java hljs">OneoffTask task = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OneoffTask.Builder() .setService(GcmNetworkManagerService.class) .setTag(TAG) .setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED) .setRequiresCharging(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .build(); GcmNetworkManager mGcmNetworkManager = GcmNetworkManager.getInstance(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); mGcmNetworkManager.schedule(task);</code> </pre> <br>  Esta similitud de la arquitectura fue dictada por la funcionalidad heredada y el deseo de obtener una migraci√≥n simple entre herramientas. <br><br>  <i><b>Pros</b> :</i> <i><br></i>  <i>API similar a JobScheduler;</i> <i><br></i>  <i>Disponible a partir de API 9.</i> <i><br><br></i>  <i><b>Contras</b> :</i> <i><br></i>  <i>Debes tener los servicios de Google Play</i> <i><br></i>  <i>Es f√°cil cometer un error.</i> <br><br>  <b>Android 5. Lollipop</b> <b><br></b> <h3>  <b>WakefulBroadcastReceiver</b> </h3><br>  A continuaci√≥n, escribir√© algunas palabras sobre uno de los mecanismos b√°sicos que se utiliza en JobScheduler y que est√° disponible directamente para los desarrolladores.  Este es WakeLock y su WakefulBroadcastReceiver basado. <br><br>  Con WakeLock, puede evitar que el sistema se suspenda, es decir, mantenga el dispositivo en un estado activo.  Esto es necesario si queremos hacer un trabajo importante. <br>  Al crear WakeLock, puede especificar su configuraci√≥n: mantenga la CPU, la pantalla o el teclado. <br><br><pre> <code class="java hljs">PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE) PowerManager.WakeLock wl = pm.newWakeLock(PARTIAL_WAKE_LOCK, <span class="hljs-string"><span class="hljs-string">"name"</span></span>) wl.acquire(timeout);</code> </pre> <br>  Basado en este mecanismo, funciona el WakefulBroadcastReceiver.  Iniciamos el servicio y mantenemos WakeLock. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleWakefulReceiver</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WakefulBroadcastReceiver</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onReceive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context, Intent intent)</span></span></span><span class="hljs-function"> </span></span>{ Intent service = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Intent(context, SimpleWakefulService.class); startWakefulService(context, service); } }</code> </pre> <br>  Una vez que el servicio ha completado el trabajo necesario, lo liberamos a trav√©s de m√©todos similares. <br><br>  A trav√©s de 4 versiones, este BroadcastReceiver quedar√° obsoleto, y las siguientes alternativas se describir√°n en developer.android.com: <br><br><ul><li>  JobScheduler; </li><li>  Syncadapter </li><li>  DownloadManager </li><li>  FLAG_KEEP_SCREEN_ON para Window. </li></ul><br>  <b>Android 6. Marshmallow</b> <b><br></b> <h3>  <b>DozeMode: dormir sobre la marcha</b> </h3><br>  Luego, Google comenz√≥ a aplicar varias optimizaciones para las aplicaciones que se ejecutan en el dispositivo.  Pero lo que es la optimizaci√≥n para el usuario es una limitaci√≥n para el desarrollador. <br><br>  El primer paso fue DozeMode, que pone el dispositivo en modo de suspensi√≥n si permanece inactivo durante un tiempo determinado.  En las primeras versiones, dur√≥ una hora, en versiones posteriores, la duraci√≥n del sue√±o se redujo a 30 minutos.  Peri√≥dicamente, el tel√©fono se despierta, realiza todas las tareas pendientes y se duerme nuevamente.  La ventana DozeMode se expande exponencialmente.  Todas las transiciones entre modos se pueden rastrear a trav√©s de adb. <br><br>  Cuando se produce DozeMode, se imponen las siguientes restricciones a la aplicaci√≥n: <br><br><ul><li>  el sistema ignora todos los WakeLock; </li><li>  AlarmManager se retrasa; </li><li>  JobScheduler no funciona; </li><li>  SyncAdapter no funciona; </li><li>  El acceso a la red es limitado. </li></ul><br>  Tambi√©n puede agregar su aplicaci√≥n a la lista blanca para que no se encuentre bajo las limitaciones de DozeMode, pero al menos Samsung ignor√≥ por completo esta lista. <br><br>  <b>Android 6. Marshmallow</b> <b><br></b> <h3>  <b>AppStandby: aplicaciones inactivas</b> </h3><br>  El sistema identifica las aplicaciones que est√°n inactivas y les impone las mismas restricciones que en DozeMode. <br>  Una aplicaci√≥n se env√≠a al aislamiento si: <br><br><ul><li>  no tiene un proceso en primer plano; </li><li>  no tiene una notificaci√≥n activa; </li><li>  no agregado a la lista de exclusi√≥n. </li></ul><br>  <b>Android 7. Turr√≥n</b> <b><br></b> <h3>  <b>Optimizaciones de fondo.</b>  <b>Esbelto</b> </h3><br>  Svelte es un proyecto en el que Google est√° tratando de optimizar el consumo de RAM por las aplicaciones y el sistema en s√≠. <br>  En Android 7, en el marco de este proyecto, se decidi√≥ que las transmisiones impl√≠citas no son muy efectivas, ya que son escuchadas por una gran cantidad de aplicaciones y el sistema gasta una gran cantidad de recursos cuando ocurren estos eventos.  Por lo tanto, se prohibieron los siguientes tipos de eventos para la declaraci√≥n en el manifiesto: <br><br><ul><li>  CONECTIVIDAD_ACCI√ìN; </li><li>  ACTION_NEW_PICTURE; </li><li>  ACTION_NEW_VIDEO. </li></ul><br>  <b>Android 7. Turr√≥n</b> <b><br></b> <h3>  <b>FirebaseJobDispatcher</b> </h3><br>  Al mismo tiempo, se public√≥ una nueva versi√≥n del marco de inicio de tareas: FirebaseJobDispatcher.  De hecho, fue el GCM NetworkManager completo, que se orden√≥ un poco y se hizo un poco m√°s flexible. <br><br>  Visualmente, todo se ve√≠a exactamente igual.  Mismo servicio: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobSchedulerService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStartJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobParameters params)</span></span></span><span class="hljs-function"> </span></span>{ doWork(params); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStopJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobParameters params)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre> <br>  La √∫nica diferencia entre √©l era la capacidad de instalar su controlador.  Un controlador es la clase responsable de la estrategia de inicio de la tarea. <br><br>  El inicio de las tareas en s√≠ no ha cambiado con el tiempo. <br><br><pre> <code class="java hljs">FirebaseJobDispatcher dispatcher = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FirebaseJobDispatcher(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GooglePlayDriver(context)); Job task = dispatcher.newJobBuilder() .setService(FirebaseJobDispatcherService.class) .setTag(TAG) .setConstraints(Constraint.ON_UNMETERED_NETWORK, Constraint.DEVICE_IDLE) .build(); dispatcher.mustSchedule(task);</code> </pre><br>  <i><b>Pros</b> :</i> <i><br></i>  <i>API similar a JobScheduler;</i> <i><br></i>  <i>Disponible a partir de API 9.</i> <i><br><br></i>  <i><b>Contras</b> :</i> <i><br></i>  <i>Debes tener los servicios de Google Play</i> <i><br></i>  <i>Es f√°cil cometer un error.</i> <i><br></i> <br>  Fue alentador instalar mi controlador para deshacerme del GPS.  Incluso buscamos, pero finalmente encontramos lo siguiente: <br><br><img src="https://habrastorage.org/webt/3n/39/ua/3n39uanajermu--vb5qrzgfl8jq.png"><br><br><img src="https://habrastorage.org/webt/zm/rq/i3/zmrqi3pnt_0hx8lcspdy8k6xio8.png"><br><br>  Google lo sabe, pero estas tareas permanecen abiertas durante varios a√±os. <br><br>  <b>Android 7. Turr√≥n</b> <b><br></b> <h3>  <b>Android Job por Evernote</b> </h3><br>  Como resultado, la comunidad no pudo soportarlo, y apareci√≥ una soluci√≥n hecha a s√≠ misma en forma de una biblioteca de Evernote.  No fue el √∫nico, pero fue la soluci√≥n de Evernote que pudo establecerse y "entrar en la gente". <br><br>  En t√©rminos arquitect√≥nicos, esta biblioteca era m√°s conveniente que sus predecesoras. <br>  Ha aparecido la entidad responsable de crear tareas.  En el caso de JobScheduler, se crearon a trav√©s de la reflexi√≥n. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SendLogsJobCreator</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobCreator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tag: String)</span></span></span><span class="hljs-function">: Job? </span></span>{ when (tag) { SendLogsJob.TAG -&gt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SendLogsJob() } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> } }</code> </pre> <br>  Hay una clase separada, que es la tarea misma.  En JobScheduler, todo esto se volc√≥ en un interruptor dentro de OnStartJob. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SendLogsJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class">() </span></span>{ <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onRunJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(params: Params)</span></span></span><span class="hljs-function">: Result </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> doWork(params) } }</code> </pre> <br>  El inicio de las tareas es id√©ntico, pero adem√°s de los eventos heredados, Evernote tambi√©n agreg√≥ los suyos, como el inicio de tareas diarias, tareas √∫nicas y el lanzamiento dentro de la ventana. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JobRequest.Builder(JOB_ID) .setRequiresDeviceIdle(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .setRequiresCharging(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .setRequiredNetworkType(JobRequest.NetworkType.UNMETERED) .build() .scheduleAsync();</code> </pre> <br>  <i><b>Pros</b> :</i> <i><br></i>  <i>API conveniente;</i> <i><br></i>  <i>compatible con todas las versiones;</i> <i><br></i>  <i>No necesita los servicios de Google Play.</i> <i><br><br></i>  <i><b>Contras</b> :</i> <i><br></i>  <i>Soluci√≥n de terceros.</i> <i><br></i> <br>  Los chicos apoyaron activamente su biblioteca.  Aunque hubo bastantes problemas cr√≠ticos, funcion√≥ en todas las versiones y en todos los dispositivos.  Como resultado, el a√±o pasado nuestro equipo de Android eligi√≥ una soluci√≥n de Evernote, ya que las bibliotecas de Google cortaron una gran capa de dispositivos que no pueden admitir. <br>  En el interior, trabaj√≥ en soluciones de Google, en casos extremos, con AlarmManager. <br><br>  <b>Android 8. Oreo</b> <b><br></b> <h3>  <b>L√≠mites de ejecuci√≥n en segundo plano</b> </h3><br>  Volvamos a nuestras limitaciones.  Con el advenimiento del nuevo Android, han llegado nuevas optimizaciones.  Los chicos de Google encontraron otro problema.  Esta vez todo result√≥ en servicios y transmisiones (s√≠, nada nuevo). <br><br><ul><li>  <s>startService si las aplicaciones est√°n en segundo plano</s> </li><li>  <s>transmisi√≥n impl√≠cita en manifiesto</s> </li></ul><br>  En primer lugar, estaba prohibido iniciar servicios desde el fondo.  En el "marco de la ley" quedaron solo los servicios en primer plano.  Ahora se puede decir que los servicios est√°n en desuso. <br>  La segunda limitaci√≥n es la misma transmisi√≥n.  Esta vez se prohibi√≥ registrar TODAS las transmisiones impl√≠citas en el manifiesto.  La transmisi√≥n impl√≠cita es una transmisi√≥n que est√° destinada no solo a nuestra aplicaci√≥n.  Por ejemplo, hay Acci√≥n ACTION_PACKAGE_REPLACED, y hay ACTION_MY_PACKAGE_REPLACED.  Entonces, el primero es impl√≠cito. <br><br>  Pero cualquier transmisi√≥n a√∫n puede registrarse a trav√©s de Context.registerBroadcast. <br><br>  <b>Android 9. Pie</b> <b><br></b> <h3>  <b>Gerente de trabajo</b> </h3><br>  En esta optimizaci√≥n se ha detenido todav√≠a.  Quiz√°s los dispositivos comenzaron a funcionar r√°pida y cuidadosamente en t√©rminos de consumo de energ√≠a;  quiz√°s los usuarios se han quejado menos al respecto. <br>  En Android 9, los desarrolladores del marco se acercaron a la herramienta para iniciar tareas.  En un intento por resolver todos los problemas apremiantes, se introdujo una biblioteca en Google I / O para iniciar las tareas en segundo plano de WorkManager. <br><br>  Google recientemente ha estado tratando de dar forma a su visi√≥n de la arquitectura de la aplicaci√≥n de Android y ofrece a los desarrolladores las herramientas necesarias para ello.  As√≠ que hab√≠a componentes arquitect√≥nicos con LiveData, ViewModel y Room.  WorkManager parece un complemento razonable para su enfoque y paradigma. <br><br>  Si hablamos de c√≥mo est√° organizado el WorkManager en el interior, entonces no hay ning√∫n avance tecnol√≥gico en √©l.  De hecho, este es un contenedor de soluciones existentes: JobScheduler, FirebaseJobDispatcher y AlarmManager. <br><br><div class="spoiler">  <b class="spoiler_title">createBestAvailableBackgroundScheduler</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Scheduler </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createBestAvailableBackgroundScheduler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context, WorkManager)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Build.VERSION.SDK_INT &gt;= MIN_JOB_SCHEDULER_API_LEVEL) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SystemJobScheduler(context, workManager); } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tryCreateFirebaseJobScheduler(context); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SystemAlarmScheduler(context); } }</code> </pre> <br></div></div><br>  El c√≥digo de selecci√≥n es bastante simple.  Pero debe tenerse en cuenta que JobScheduler est√° disponible a partir de API 21, pero lo usan solo con API 23, ya que las primeras versiones eran bastante inestables. <br><br>  Si la versi√≥n es inferior a 23, entonces a trav√©s de la reflexi√≥n tratamos de encontrar FirebaseJobDispatcher, de lo contrario, utilizamos AlarmManager. <br><br>  Vale la pena se√±alar que el envoltorio sali√≥ bastante flexible.  Esta vez, los desarrolladores dividieron todo en entidades separadas, y arquitect√≥nicamente parece conveniente: <br><br><ul><li>  Trabajador - l√≥gica de trabajo; </li><li>  WorkRequest: l√≥gica del inicio de la tarea; </li><li>  WorkRequest.Builder - par√°metros; </li><li>  Restricciones - condiciones; </li><li>  WorkManager: un gerente que administra las tareas; </li><li>  WorkStatus: estado de la tarea. </li></ul><br><br><img src="https://habrastorage.org/webt/n_/ts/xi/n_tsxiw0wsxv6a5abotzdzokcba.png"><br><br>  Las condiciones de lanzamiento se heredaron de JobScheduler. <br>  Se puede observar que el desencadenante para cambiar el URI apareci√≥ solo con la API 23. Adem√°s, puede suscribirse al cambio no solo de un URI espec√≠fico, sino tambi√©n de todos los anidados utilizando el indicador en el m√©todo. <br><br>  Si hablamos de nosotros, entonces, en la etapa alfa, se decidi√≥ cambiar a WorkManager. <br>  Hay varias razones para esto.  Evernote tiene un par de errores cr√≠ticos que los desarrolladores de la biblioteca prometen solucionar con la transici√≥n a una versi√≥n con WorkManager integrado.  Y ellos mismos est√°n de acuerdo en que la decisi√≥n de Google niega las ventajas de Evernote.  Adem√°s, esta soluci√≥n se adapta bien a nuestra arquitectura, ya que usamos componentes de arquitectura. <br><br>  Adem√°s, me gustar√≠a mostrar con un simple ejemplo c√≥mo estamos tratando de usar este enfoque.  Al mismo tiempo, no es muy cr√≠tico si tiene un WorkManager o JobScheduler. <br><br><img src="https://habrastorage.org/webt/ox/yd/0p/oxyd0pizr6h8tx4egaz_kub5wqy.png" width="300" height="430"><img src="https://habrastorage.org/webt/6m/ec/hd/6mechdqawzamahgaij7df-isocg.png" width="300" height="430"><br><br>  Veamos un ejemplo con un caso muy simple: haciendo clic en volver a publicar o en Me gusta. <br><br>  Ahora todas las aplicaciones est√°n tratando de escapar de las solicitudes de bloqueo a la red, ya que esto pone nervioso al usuario y lo hace esperar, aunque en este momento puede realizar compras dentro de la aplicaci√≥n o mirar anuncios. <br><br>  En tales casos, los datos locales cambian primero: el usuario ve inmediatamente el resultado de su acci√≥n.  Luego, en segundo plano, hay una solicitud al servidor, si falla, los datos se restablecen a su estado inicial. <br><br>  A continuaci√≥n, mostrar√© un ejemplo de c√≥mo se ve con nosotros. <br><br>  JobRunner contiene la l√≥gica para iniciar tareas.  Sus m√©todos describen la configuraci√≥n de tareas y par√°metros de paso. <br><br><div class="spoiler">  <b class="spoiler_title">JobRunner.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">likePost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(content: IFunnyContent)</span></span></span><span class="hljs-function"> </span></span>{ val constraints = Constraints.Builder() .setRequiredNetworkType(NetworkType.CONNECTED) .build() val input = Data.Builder() .putString(LikeContentJob.ID, content.id) .build() val request = OneTimeWorkRequest.Builder(LikeContentJob::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setInputData</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">input</span></span></span><span class="hljs-class">) .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setConstraints</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constraints</span></span></span><span class="hljs-class">) .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">build</span></span></span><span class="hljs-class">() </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkManager</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">getInstance</span></span></span><span class="hljs-class">().</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">enqueue</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class">) }</span></span></code> </pre><br></div></div><br>  La tarea en s√≠ dentro del WorkManager es la siguiente: tomamos la identificaci√≥n de los par√°metros y llamamos al m√©todo en el servidor para que me guste este contenido. <br><br>  Tenemos una clase base que contiene la siguiente l√≥gica: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Worker</span></span></span><span class="hljs-class">() </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: Result </span></span>{ val workerInjector = WorkerInjectorProvider.injector() workerInjector.inject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> performJob(inputData) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">performJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(params: Data)</span></span></span><span class="hljs-function">: Result }</span></span></code> </pre><br>  En primer lugar, le permite alejarse un poco del conocimiento expl√≠cito de Worker.  Tambi√©n contiene la l√≥gica de inyecci√≥n de dependencia a trav√©s de WorkerInjector. <br><br><div class="spoiler">  <b class="spoiler_title">WorkerInjectorImpl.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Singleton</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkerInjectorImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkerInjector</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WorkerInjectorImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-meta"><span class="hljs-meta">@Ovierride</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Worker job)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (worker <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> AppCrashedEventSendJob) { Injector.getAppComponent().inject((AppCrashedEventSendJob) job); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (worker <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> CheckNativeCrashesJob) { Injector.getAppComponent().inject((CheckNativeCrashesJob) job); } } }</code> </pre><br></div></div><br>  Simplemente representa las llamadas a Dagger, pero nos ayuda en las pruebas: reemplazamos las implementaciones de inyectores e implementamos el entorno necesario en las tareas. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testRegisterPushProvider</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ WorkManagerTestInitHelper.initializeTestWorkManager(context) val testDriver = WorkManagerTestInitHelper.getTestDriver() WorkerInjectorProvider.setInjector(TestInjector()) <span class="hljs-comment"><span class="hljs-comment">// mock dependencies val id = jobRunner.runPushRegisterJob() testDriver.setAllConstraintsMet(id) Assert.assertTrue(‚Ä¶) }</span></span></code> </pre><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LikePostInteractor</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constructor</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iFunnyContentDao</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFunnyContentDao</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">jobRunner</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobRunner</span></span></span><span class="hljs-class">) : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Interactor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ iFunnyContentDao.like(getContent().id) jobRunner.likePost(getContent()) } }</code> </pre> <br>  Interactor es la entidad que el ViewController extrae para iniciar el paso del script (en este caso, me gusta).  Marcamos el contenido localmente como "cargado" y enviamos la tarea para su ejecuci√≥n.  Si la tarea falla, se elimina lo similar. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFunnyContentViewModel</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iFunnyContentDao</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFunnyContentDao</span></span></span><span class="hljs-class">) : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewModel</span></span></span><span class="hljs-class">() </span></span>{ val likeState = MediatorLiveData&lt;Boolean&gt;() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> iFunnyContentId = MutableLiveData&lt;String&gt;() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> iFunnyContentState: LiveData&lt;IFunnyContent&gt; = attachLiveDataToContentId(); init { likeState.addSource(iFunnyContentState) { likeState.postValue(it!!.hasLike) } } }</code> </pre> <br>  Utilizamos los componentes de arquitectura de Google: ViewModel y LiveData.  As√≠ es como se ve nuestro ViewModel.  Aqu√≠ conectamos la actualizaci√≥n del objeto en el DAO con el estado de me gusta. <br><br><div class="spoiler">  <b class="spoiler_title">IFunnyContentViewController.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFunnyContentViewController</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constructor</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">private</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">likePostInteractor</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LikePostInteractor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">viewModel</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFunnyContentViewModel</span></span></span><span class="hljs-class">) : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: View)</span></span></span><span class="hljs-function"> </span></span>{ viewModel.likeState.observe(lifecycleOwner, { updateLikeView(it!!) }) } <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onLikePost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ likePostInteractor.setContent(getContent()) likePostInteractor.execute() } }</code> </pre> <br></div></div><br>  ViewController, por un lado, se suscribe a cambiar el estado de los me gusta, por otro lado, inicia el paso del script que necesitamos. <br><br>  Y eso es pr√°cticamente todo el c√≥digo que necesitamos.  Queda por agregar el comportamiento de la Vista en s√≠ con el me gusta y la implementaci√≥n de su DAO;  si usa Room, simplemente registre los campos en el objeto.  Se ve bastante simple y efectivo. <br><br><h3>  <b>Para resumir</b> </h3><br>  <b>JobScheduler, GCM Network Manager, FirebaseJobDispatcher:</b> <br><br><ul><li>  no los uses </li><li>  no lea m√°s art√≠culos sobre ellos </li><li>  no mires informes </li><li>  No pienses cu√°l elegir. </li></ul><br>  <b>Trabajo de Android por Evernote:</b> <br><br><ul><li>  Dentro usar√°n el WorkManager; </li><li>  Los errores cr√≠ticos se difuminan entre las soluciones. </li></ul><br>  <b>WorkManager:</b> <br><br><ul><li>  API LEVEL 9+; </li><li>  independiente de los servicios de Google Play; </li><li>  Encadenamiento / InputMergers; </li><li>  enfoque reactivo; </li><li>  soporte de Google (quiero creerlo). </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es434680/">https://habr.com/ru/post/es434680/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es434670/index.html">Informe anual Habrapost - 2018</a></li>
<li><a href="../es434672/index.html">Fintech Digest: los productos m√°s populares de 2018, duplicando el volumen de transferencias de tarjeta a tarjeta, impuestos sobre la criptomoneda</a></li>
<li><a href="../es434674/index.html">Respondemos al vandalismo por cable r√°pidamente, en todas partes y sin trampas f√≠sicas</a></li>
<li><a href="../es434676/index.html">TOP-10: qu√© aprender en 2019</a></li>
<li><a href="../es434678/index.html">Administrador ma√±ana: agregue espacio en docenas de servidores para caf√©</a></li>
<li><a href="../es434682/index.html">Teletransportador personal de la ciudad</a></li>
<li><a href="../es434684/index.html">Rust 2019 y m√°s all√°: restricciones de crecimiento</a></li>
<li><a href="../es434686/index.html">Conferencia sobre JavaScript y Node.js en KPI</a></li>
<li><a href="../es434688/index.html">FreeBSD planea cambiar a ZFSonLinux</a></li>
<li><a href="../es434690/index.html">Sistema operativo Haiku: portar aplicaciones y crear paquetes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>