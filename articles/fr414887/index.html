<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë±üèø ü¶Ä üí™üèø Cr√©ation d'un crochet pour chat dans Unity. Partie 1 üïµüèª üçû ‚ñ™Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les crochets pour chats ajoutent des m√©caniques amusantes et int√©ressantes au jeu. Vous pouvez les utiliser pour vous d√©placer dans les niveaux, comba...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cr√©ation d'un crochet pour chat dans Unity. Partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414887/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/348/a3e/e5d/348a3ee5d95a10273c8bc644e3dbc7d9.gif" alt="image"></div><br>  Les crochets pour chats ajoutent des m√©caniques amusantes et int√©ressantes au jeu.  Vous pouvez les utiliser pour vous d√©placer dans les niveaux, combattre dans les ar√®nes et obtenir des objets.  Mais malgr√© l'apparente simplicit√©, la physique de la gestion des cordes et la cr√©ation d'un comportement r√©aliste peuvent √™tre difficiles! <br><br>  Dans la premi√®re partie de ce tutoriel, nous impl√©mentons notre propre syst√®me crochet-chat bidimensionnel et apprenons ce qui suit: <br><br><ul><li>  Cr√©ez un syst√®me de vis√©e. </li><li>  Utilisez le rendu de ligne et le joint de distance pour cr√©er la corde. </li><li>  Nous apprendrons √† la corde √† enrouler les objets du jeu. </li><li>  Calculez l'angle de swing sur la corde et ajoutez de la force dans cette direction. </li></ul><br><blockquote>  <em>Remarque</em> : ce didacticiel est destin√© aux utilisateurs avanc√©s et exp√©riment√©s, et il ne couvre pas des sujets tels que l'ajout de composants, la cr√©ation de nouveaux scripts GameObject et la syntaxe C #.  Si vous avez besoin d'am√©liorer vos comp√©tences Unity, consultez nos didacticiels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Prise en main de Unity</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Introduction √† Unity Scripting</a> .  √âtant donn√© que <em>DistanceJoint2D est</em> utilis√© dans ce didacticiel, vous devez √©galement parcourir les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">joints physiques dans Unity 2D</a> , puis revenir √† ce didacticiel. </blockquote><a name="habracut"></a><br><h2>  Se rendre au travail </h2><br>  T√©l√©chargez le <a href="">brouillon</a> de ce didacticiel, puis ouvrez-le dans l'√©diteur Unity.  Unity 2017.1 ou sup√©rieur est requis pour le fonctionnement. <br><br>  Ouvrez la sc√®ne du <em>jeu √†</em> partir du dossier <em>Sc√®nes</em> et voyez par o√π commencer: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/973/819/22f/97381922f527deb0b338346d13083c13.png"></div><br>  Pour l'instant, nous avons un personnage joueur simple (limace) et des pierres suspendues dans les airs. <br><br>  Les composants importants de GameObject <em>Player</em> jusqu'√† pr√©sent sont le collisionneur de capsules et le corps rigide, qui lui permettent d'interagir avec des objets physiques au niveau.  En outre, un script de mouvement simple ( <em>PlayerMovement</em> ) est attach√© au personnage, lui permettant de glisser sur le sol et d'effectuer des sauts simples. <br><br>  Appuyez sur le bouton <em>Lecture</em> pour d√©marrer le jeu et essayez de contr√¥ler le personnage.  <em>A</em> et <em>D le</em> d√©placent vers la gauche / droite, et lorsque vous appuyez sur la <em>barre d'espace,</em> il saute.  Essayez de ne pas glisser et de tomber de la falaise, sinon vous mourrez! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69a/8b5/841/69a8b58415940671c3519ceccfcf6ed7.png"></div><br>  Nous avons d√©j√† les bases de la gestion, mais le plus gros probl√®me est le manque d'hame√ßons. <br><br><h2>  Cr√©ation de crochets et de cordes </h2><br>  Au d√©but, le syst√®me de crochet de chat semble assez simple, mais pour sa mise en ≈ìuvre de haute qualit√©, il est n√©cessaire de prendre en compte de nombreux aspects.  Voici quelques-unes des exigences pour la m√©canique du crochet √† deux dimensions: <br><br><ul><li>  Rendu de ligne pour afficher la corde.  Lorsque la corde s'enroule autour d'objets, nous pouvons ajouter plus de segments au rendu de ligne et placer les sommets aux points correspondant aux ruptures de la corde. </li><li>  DistanceJoint2D.  Il peut √™tre utilis√© pour fixer le point d'ancrage actuel du crochet pour chat afin que notre limace puisse se balancer.  Cela nous permet √©galement d'ajuster la distance qui peut √™tre utilis√©e pour allonger et r√©duire la corde. </li><li>  GameObject enfant avec RigidBody2D, qui peut √™tre d√©plac√© en fonction de l'emplacement actuel du point d'ancrage du crochet.  En substance, ce sera le point de suspension / d'ancrage de la corde. </li><li>  Raycast pour lancer un crochet et attacher √† des objets. </li></ul><br>  S√©lectionnez l'objet <em>Player</em> dans la hi√©rarchie et ajoutez-lui un nouvel GameObject enfant nomm√© <em>RopeHingeAnchor</em> .  Ce GameObject sera utilis√© pour positionner le point de suspension / d'ancrage du crochet pour chat. <br><br>  Ajoutez des composants <em>SpriteRenderer</em> et <em>RigidBody2D</em> √† <em>RopeHingeAnchor</em> . <br><br>  Pour SpriteRenderer, d√©finissez la propri√©t√© <em>Sprite</em> pour utiliser la valeur <em>UISprite</em> et remplacez <em>Order in Layer</em> par <em>2</em> .  D√©sactivez le composant en <em>d√©cochant la case √†</em> c√¥t√© de son nom. <br><br>  Pour le composant <em>RigidBody2D,</em> d√©finissez la propri√©t√© Type de corps sur <em>Cin√©matique</em> .  Ce point sera d√©plac√© non pas par le moteur physique, mais par le code. <br><br>  S√©lectionnez le calque <em>Corde</em> et d√©finissez les valeurs d'√©chelle X et Y du composant Transformer sur <em>4</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e18/4aa/8e4/e184aa8e457a1e1d3928966b2ae3bca7.png"></div><br>  S√©lectionnez √† nouveau <em>Player</em> et attachez le nouveau composant <em>DistanceJoint2D</em> . <br><br>  Faites glisser le <em>RopeHingeAnchor</em> de la hi√©rarchie sur la propri√©t√© <em>Corps rigide connect√©</em> du composant <em>DistanceJoint2D</em> et d√©sactivez la <em>configuration automatique de la distance</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e46/25b/b80/e4625bb804bb2ed2a0c5bee2aed0eade.gif"></div><br>  Cr√©ez un nouveau script C # appel√© <em>RopeSystem</em> dans le dossier du projet <em>Scripts</em> et ouvrez-le dans l'√©diteur de code. <br><br>  Supprimez la m√©thode <code>Update</code> . <br><br>  En haut du script √† l'int√©rieur de la <code>RopeSystem</code> classe <code>RopeSystem</code> ajoutez de nouvelles variables, la m√©thode <code>Awake()</code> et la nouvelle m√©thode <code>Update</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 public GameObject ropeHingeAnchor; public DistanceJoint2D ropeJoint; public Transform crosshair; public SpriteRenderer crosshairSprite; public PlayerMovement playerMovement; private bool ropeAttached; private Vector2 playerPosition; private Rigidbody2D ropeHingeAnchorRb; private SpriteRenderer ropeHingeAnchorSprite; void Awake() { // 2 ropeJoint.enabled = false; playerPosition = transform.position; ropeHingeAnchorRb = ropeHingeAnchor.GetComponent&lt;Rigidbody2D&gt;(); ropeHingeAnchorSprite = ropeHingeAnchor.GetComponent&lt;SpriteRenderer&gt;(); } void Update() { // 3 var worldMousePosition = Camera.main.ScreenToWorldPoint(new Vector3(Input.mousePosition.x, Input.mousePosition.y, 0f)); var facingDirection = worldMousePosition - transform.position; var aimAngle = Mathf.Atan2(facingDirection.y, facingDirection.x); if (aimAngle &lt; 0f) { aimAngle = Mathf.PI * 2 + aimAngle; } // 4 var aimDirection = Quaternion.Euler(0, 0, aimAngle * Mathf.Rad2Deg) * Vector2.right; // 5 playerPosition = transform.position; // 6 if (!ropeAttached) { } else { } }</span></span></code> </pre> <br>  Analysons chaque partie dans l'ordre: <br><br><ol><li>  Nous utilisons ces variables pour suivre les diff√©rents composants avec lesquels le script RopeSystem interagira. </li><li>  La m√©thode <code>Awake</code> d√©marre au d√©but du jeu et d√©sactive <code>ropeJoint</code> (composant DistanceJoint2D).  Il d√©finit √©galement <code>playerPosition</code> √† la position actuelle du lecteur. </li><li>  C'est la partie la plus importante de la boucle principale <code>Update()</code> .  Tout d'abord, nous obtenons la position du curseur de la souris dans le monde en utilisant la <code>ScreenToWorldPoint</code> cam√©ra <code>ScreenToWorldPoint</code> .  Ensuite, nous calculons la direction de notre regard en soustrayant la position du joueur de la position de la souris dans le monde.  Ensuite, nous l'utilisons pour cr√©er <code>aimAngle</code> , qui est une repr√©sentation de l'angle de vis√©e du curseur.  La valeur stocke une valeur positive dans la construction if. </li><li>  <code>aimDirection</code> est une touche qui sera utile plus tard.  Nous ne sommes int√©ress√©s que par la valeur Z, car nous utilisons une cam√©ra 2D, et c'est le seul OS correspondant.  Nous passons <code>aimAngle * Mathf.Rad2Deg</code> , qui convertit l'angle radian en angle en degr√©s. </li><li>  La position du joueur est surveill√©e √† l'aide d'une variable pratique qui vous permet de ne pas vous r√©f√©rer constamment √† <code>transform.Position</code> . </li><li>  Enfin, nous avons la construction <code>if..else</code> , que nous utiliserons bient√¥t pour d√©terminer si la corde est attach√©e au point d'ancrage. </li></ol><br>  Enregistrez le script et revenez √† l'√©diteur. <br><br>  Attachez le composant <em>RopeSystem</em> √† l'objet Player et accrochez les diff√©rents composants dans les champs publics que nous avons cr√©√©s dans le script <em>RopeSystem</em> .  Faites glisser <em>Player</em> , <em>Crosshair</em> et <em>RopeHingeAnchor</em> dans les champs appropri√©s: <br><br><ul><li>  <em>Ancre de charni√®re de corde</em> : <em>Ancrage de</em> corde </li><li>  <em>Joint de corde</em> : Joueur </li><li>  <em>R√©ticule</em> : R√©ticule </li><li>  <em>Crosshair Sprite</em> : Crosshair </li><li>  <em>Mouvement du</em> joueur: Joueur </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e97/9ca/d2e/e979cad2e2690cc65e9fe237a9f6c47a.gif"></div><br>  Maintenant, nous faisons juste tous ces calculs complexes, mais jusqu'√† pr√©sent, il n'y a aucune visualisation qui pourrait les montrer en action.  Mais ne vous inqui√©tez pas, nous le ferons bient√¥t. <br><br>  Ouvrez le script <em>RopeSystem</em> et ajoutez-y une nouvelle m√©thode: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetCrosshairPosition</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aimAngle</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!crosshairSprite.enabled) { crosshairSprite.enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = transform.position.x + <span class="hljs-number"><span class="hljs-number">1f</span></span> * Mathf.Cos(aimAngle); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = transform.position.y + <span class="hljs-number"><span class="hljs-number">1f</span></span> * Mathf.Sin(aimAngle); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> crossHairPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(x, y, <span class="hljs-number"><span class="hljs-number">0</span></span>); crosshair.transform.position = crossHairPosition; }</code> </pre> <br>  Cette m√©thode positionne le viseur en fonction de l' <code>aimAngle</code> transmis (la valeur flottante que nous avons calcul√©e dans <code>Update()</code> ) afin qu'il tourne autour du joueur avec un rayon de 1 unit√©.  Nous incluons √©galement une port√©e de sprite au cas o√π cela ne serait pas d√©j√† fait. <br><p>  Dans <code>Update()</code> nous modifions la construction <code>!ropeAttached</code> pour v√©rifier <code>!ropeAttached</code> afin qu'il ressemble √† ceci: <br><br></p><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ropeAttached) { SetCrosshairPosition(aimAngle); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { crosshairSprite.enabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Enregistrez le script et lancez le jeu.  Maintenant, notre limace devrait pouvoir viser avec une vue. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffe/b1f/8ca/ffeb1f8ca53fbc0463aad677677fb837.gif"></div><br>  Le prochain morceau de logique qui doit √™tre impl√©ment√© est un coup de crochet.  Nous avons d√©j√† d√©termin√© la direction de la vis√©e, nous avons donc besoin d'une m√©thode qui la recevra en param√®tre. <br><br>  Ajoutez les variables suivantes sous les variables du script <em>RopeSystem</em> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> LineRenderer ropeRenderer; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> LayerMask ropeLayerMask; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> ropeMaxCastDistance = <span class="hljs-number"><span class="hljs-number">20f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Vector2&gt; ropePositions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Vector2&gt;();</code> </pre> <br>  <em>LineRenderer</em> contiendra un lien vers un rendu de ligne qui dessine la corde.  <em>LayerMask</em> vous permet de personnaliser les couches physiques avec lesquelles le crochet peut interagir.  La valeur <code>ropeMaxCastDistance</code> d√©finit la distance maximale que raycast peut "tirer". <br><br>  Enfin, la liste des positions de Vector2 sera utilis√©e pour suivre les points d'enroulement de la corde, dont nous discuterons plus tard. <br><br>  Ajoutez les nouvelles m√©thodes suivantes: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 private void HandleInput(Vector2 aimDirection) { if (Input.GetMouseButton(0)) { // 2 if (ropeAttached) return; ropeRenderer.enabled = true; var hit = Physics2D.Raycast(playerPosition, aimDirection, ropeMaxCastDistance, ropeLayerMask); // 3 if (hit.collider != null) { ropeAttached = true; if (!ropePositions.Contains(hit.point)) { // 4 //    ,    -  . transform.GetComponent&lt;Rigidbody2D&gt;().AddForce(new Vector2(0f, 2f), ForceMode2D.Impulse); ropePositions.Add(hit.point); ropeJoint.distance = Vector2.Distance(playerPosition, hit.point); ropeJoint.enabled = true; ropeHingeAnchorSprite.enabled = true; } } // 5 else { ropeRenderer.enabled = false; ropeAttached = false; ropeJoint.enabled = false; } } if (Input.GetMouseButton(1)) { ResetRope(); } } // 6 private void ResetRope() { ropeJoint.enabled = false; ropeAttached = false; playerMovement.isSwinging = false; ropeRenderer.positionCount = 2; ropeRenderer.SetPosition(0, transform.position); ropeRenderer.SetPosition(1, transform.position); ropePositions.Clear(); ropeHingeAnchorSprite.enabled = false; }</span></span></code> </pre> <br>  Voici ce que fait le code ci-dessus: <br><br><ol><li>  HandleInput est appel√© √† partir de la boucle <code>Update()</code> et interroge simplement l'entr√©e des boutons gauche et droit de la souris. </li><li>  Lorsqu'un clic gauche est enregistr√©, la ligne de corde est activ√©e et un lancer de rayons 2D est tir√© depuis la position du joueur dans la direction de vis√©e.  La distance maximale est d√©finie de sorte que le chat crochet ne puisse pas √™tre abattu √† une distance infinie, et un masque est appliqu√© afin qu'il soit possible de s√©lectionner les couches de physique avec lesquelles raycast peut entrer en collision. </li><li>  Si un coup de rayon est d√©tect√©, alors <code>ropeAttached</code> est <code>true</code> , et une liste des positions des sommets de la corde est v√©rifi√©e pour s'assurer qu'il n'y a pas de point l√†. </li><li>  Si la v√©rification est vraie, alors une petite impulsion de force est ajout√©e au limace pour qu'il rebondisse au-dessus du sol, le <code>ropeJoint</code> (DistanceJoint2D) est activ√©, qui est r√©gl√© sur une distance √©gale √† la distance entre le limace et le point d'impact Raycast.  Un sprite de point d'ancrage est √©galement inclus. </li><li>  Si raycast ne touche rien, le rendu de ligne et ropeJoint sont d√©sactiv√©s et l'indicateur <code>ropeAttached</code> est faux. </li><li>  Si le bouton droit de la souris est enfonc√©, la m√©thode <code>ResetRope()</code> est <code>ResetRope()</code> , ce qui d√©sactive et r√©initialise tous les param√®tres li√©s √† la corde / crochet aux valeurs qui devraient √™tre si le crochet n'est pas utilis√©. </li></ol><br>  Tout en bas de notre m√©thode <code>Update</code> , ajoutez un appel √† la nouvelle m√©thode <code>HandleInput()</code> et transmettez-lui la valeur <code>aimDirection</code> : <br><br><pre> <code class="cs hljs">HandleInput(aimDirection);</code> </pre> <br>  Enregistrez les modifications apport√©es √† <em>RopeSystem.cs</em> et revenez √† l'√©diteur. <br><br><h2>  Ajout d'une corde </h2><br>  Notre limace ne pourra pas voler dans les airs sans corde, il est donc temps de lui donner quelque chose qui sera une repr√©sentation visuelle de la corde et aura la capacit√© de "tourner" dans les coins. <br><br>  Le rendu de ligne est id√©al pour cela, car il nous permet de transf√©rer le nombre de points et leur position dans l'espace du monde. <br><br>  L'id√©e ici est que nous stockons toujours le premier sommet de la corde (0) √† la position du joueur, et tous les autres sommets sont positionn√©s dynamiquement lorsque la corde doit s'enrouler autour de quelque chose, y compris la position actuelle de la charni√®re, qui est le prochain point le long de la corde du joueur. <br><br>  S√©lectionnez <em>Player</em> et ajoutez-y le composant <em>LineRenderer</em> .  D√©finissez la <em>largeur</em> sur <em>0,075</em> .  D√©veloppez la liste des <em>mat√©riaux</em> et, en tant <em>qu'√©l√©ment</em> <em>0,</em> s√©lectionnez le mat√©riau <em>RopeMaterial</em> situ√© dans le dossier <em>Mat√©riaux</em> du projet.  Enfin, pour le rendu de ligne, pour le <em>mode Texture,</em> s√©lectionnez <em>Distribuer par segment</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c80/6aa/59f/c806aa59f875ac106babef5a8b57a6fc.png"></div><br>  Faites glisser le composant Line Renderer dans le champ <em>Rope Renderer</em> du composant <em>Rope System</em> . <br><br>  Cliquez sur la liste d√©roulante du <em>masque de calque</em> de <em>corde</em> et s√©lectionnez comme calques avec lesquels raycast <em>Default, Rope et Pivot</em> peuvent interagir.  Pour cette raison, lors de la prise de vue d'un raycast, il n'entrera en collision qu'avec ces couches, mais pas avec d'autres objets, comme un lecteur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9f/eab/2c3/f9feab2c30cc84b83c94d39ce74acdea.gif"></div><br>  Si vous d√©marrez le jeu maintenant, vous remarquerez un comportement √©trange.  Lorsque nous visons une pierre au-dessus de la t√™te de la limace et tirons avec un crochet, nous obtenons un petit saut vers le haut, apr√®s quoi notre ami commence √† se comporter de mani√®re plut√¥t al√©atoire. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/815/abd/ae6/815abdae693911ed0ba56f14775e5488.gif"></div><br>  Nous n'avons pas encore d√©fini la distance pour le joint de distance, de plus, les sommets du rendu de ligne ne sont pas configur√©s.  Par cons√©quent, nous ne voyons pas la corde, et puisque le joint de distance est directement au-dessus de la position de la limace, la valeur actuelle de la distance du joint de distance le pousse vers le bas jusqu'aux pierres en dessous. <br><br>  Mais ne vous inqui√©tez pas, nous allons maintenant r√©soudre ce probl√®me. <br><br>  Dans le script <em>RopeSystem.cs,</em> ajoutez un nouvel op√©rateur au d√©but de la classe: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq;</code> </pre> <br>  Cela nous permet d'utiliser des requ√™tes LINQ, qui dans notre cas nous permettent simplement de trouver facilement le premier ou le dernier √©l√©ment de la liste <code>ropePositions</code> . <br><br><blockquote>  <em>Remarque</em> : Language-Integrated Query (LINQ) est le nom d'un ensemble de technologies bas√©es sur l'incorporation de capacit√©s de requ√™te directement en C #.  Vous pouvez en lire plus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </blockquote><br>  Ajoutez une nouvelle variable priv√©e bool appel√©e <code>distanceSet</code> sous les autres variables: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> distanceSet;</code> </pre> <br>  Nous utiliserons cette variable comme un indicateur afin que le script puisse reconna√Ætre que la distance de la corde (pour le point entre le joueur et le point de r√©f√©rence actuel o√π le crochet de chat est attach√©) est correctement d√©finie. <br><br>  Ajoutez maintenant une nouvelle m√©thode que nous utiliserons pour d√©finir les positions des sommets de la corde pour rendre la ligne et d√©finir la distance du joint dans la liste des positions stock√©es avec la corde ( <code>ropePositions</code> ): <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateRopePositions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 if (!ropeAttached) { return; } // 2 ropeRenderer.positionCount = ropePositions.Count + 1; // 3 for (var i = ropeRenderer.positionCount - 1; i &gt;= 0; i--) { if (i != ropeRenderer.positionCount - 1) // if not the Last point of line renderer { ropeRenderer.SetPosition(i, ropePositions[i]); // 4 if (i == ropePositions.Count - 1 || ropePositions.Count == 1) { var ropePosition = ropePositions[ropePositions.Count - 1]; if (ropePositions.Count == 1) { ropeHingeAnchorRb.transform.position = ropePosition; if (!distanceSet) { ropeJoint.distance = Vector2.Distance(transform.position, ropePosition); distanceSet = true; } } else { ropeHingeAnchorRb.transform.position = ropePosition; if (!distanceSet) { ropeJoint.distance = Vector2.Distance(transform.position, ropePosition); distanceSet = true; } } } // 5 else if (i - 1 == ropePositions.IndexOf(ropePositions.Last())) { var ropePosition = ropePositions.Last(); ropeHingeAnchorRb.transform.position = ropePosition; if (!distanceSet) { ropeJoint.distance = Vector2.Distance(transform.position, ropePosition); distanceSet = true; } } } else { // 6 ropeRenderer.SetPosition(i, transform.position); } } }</span></span></code> </pre> <br>  Expliquez le code ci-dessus: <br><br><ol><li>  Quittez la m√©thode si la corde n'est pas attach√©e. </li><li>  Nous attribuons la valeur des points de rendu de la ligne de corde au nombre de positions stock√©es dans <code>ropePositions</code> , plus 1 de plus (pour la position du joueur). </li><li>  Nous <code>ropePositions</code> autour de la liste <code>ropePositions</code> et <code>ropePositions</code> pour chaque position (sauf la derni√®re), affectons la position du sommet du rendu de ligne √† la valeur de la position Vector2 stock√©e par l'index de boucle dans la liste <code>ropePositions</code> . </li><li>  Attribuez au point d'ancrage de la corde la seconde √† partir de la position finale de la corde, dans laquelle le point d'articulation / d'ancrage actuel devrait √™tre, ou si nous n'avons qu'une seule position de la corde, faites-en le point d'ancrage.  Nous d√©finissons donc la distance <code>ropeJoint</code> √©gale √† la distance entre le joueur et la position actuelle de la corde, que nous <code>ropeJoint</code> dans la boucle. </li><li>  La construction if g√®re le cas o√π la position actuelle de la corde dans la boucle est la deuxi√®me √† partir de la fin;  c'est-√†-dire le point auquel la corde se connecte √† l'objet, c'est-√†-dire  charni√®re / point d'ancrage actuel. </li><li>  Ce bloc <code>else</code> g√®re l'attribution de la position du dernier sommet de la corde √† la valeur de la position actuelle du joueur. </li></ol><br>  N'oubliez pas d'ajouter l'appel <code>UpdateRopePositions()</code> √† la fin de <code>Update()</code> <code>UpdateRopePositions()</code> : <br><br><pre> <code class="cs hljs">UpdateRopePositions();</code> </pre> <br>  Enregistrez les modifications apport√©es au script et relancez le jeu.  Faites un "petit espace" un petit saut en visant et en tirant avec un crochet sur une pierre au-dessus du personnage.  Vous pouvez maintenant profiter des fruits de votre travail - la limace se balance calmement sur les pierres. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b94/f87/d7c/b94f87d7c533fdae336e3818f7cf3908.gif"></div><br>  Vous pouvez maintenant aller √† la fen√™tre de la sc√®ne, s√©lectionner Joueur, utiliser l'outil de d√©placement (par d√©faut, la touche <em>W</em> ) pour le d√©placer et regarder comment les deux sommets de la ligne de corde rendent la position du crochet et la position du joueur pour tirer la corde.  Apr√®s avoir rel√¢ch√© le lecteur, DistanceJoint2D calcule correctement la distance et la limace continuera de se balancer sur la charni√®re connect√©e. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e1/66e/18c/5e166e18ca7ff821025a920b1eaf849a.gif"></div><br><h2>  Gestion des points de bouclage </h2><br>  Jouer avec une limace balan√ßante n'est jusqu'√† pr√©sent pas plus utile qu'une serviette hydrofuge, nous devons donc absolument la compl√©ter. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e9/3bd/43e/6e93bd43eb1ebff2241cb89af3b09f0a.png"></div><br>  La bonne nouvelle est que la m√©thode nouvellement ajout√©e pour le traitement des positions de corde peut √™tre utilis√©e √† l'avenir.  Jusqu'√† pr√©sent, nous n'utilisons que deux positions de corde.  L'un est li√© √† la position du joueur, et le second √† la position actuelle du point d'ancrage du crochet lors du tir. <br><br>  Le seul probl√®me est que m√™me si nous ne suivons pas toutes les positions potentielles de la corde, cela n√©cessite un peu de travail. <br><br>  Pour reconna√Ætre les positions sur les pierres autour desquelles la corde doit √™tre enroul√©e, en ajoutant une nouvelle position de sommet au rendu de ligne, nous avons besoin d'un syst√®me qui d√©termine si le point de sommet du collisionneur se situe entre la ligne droite entre la position actuelle du limace et le point d'articulation / d'ancrage actuel de la corde. <br><br>  On dirait que cela fonctionne √† nouveau pour le bon vieux raycast! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/47a/52b/abe/47a52babe8fb16ef57a365b287dceb12.png"></div><br>  Tout d'abord, nous devons cr√©er une m√©thode qui peut trouver le point le plus proche dans le collisionneur en fonction du point d'impact du raycast et des bords du collisionneur. <br><br>  Ajoutez une nouvelle m√©thode au script <em>RopeSystem.cs</em> : <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 private Vector2 GetClosestColliderPointFromRaycastHit(RaycastHit2D hit, PolygonCollider2D polyCollider) { // 2 var distanceDictionary = polyCollider.points.ToDictionary&lt;Vector2, float, Vector2&gt;( position =&gt; Vector2.Distance(hit.point, polyCollider.transform.TransformPoint(position)), position =&gt; polyCollider.transform.TransformPoint(position)); // 3 var orderedDictionary = distanceDictionary.OrderBy(e =&gt; e.Key); return orderedDictionary.Any() ? orderedDictionary.First().Value : Vector2.zero; }</span></span></code> </pre><br>  Si vous n'√™tes pas familier avec les requ√™tes LINQ, ce code peut sembler √™tre une sorte de magie C # compliqu√©e. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e8/0d6/c88/9e80d6c88df7182190a87a8ca54dcb70.png"></div><br>  Si oui, alors n'ayez pas peur.  LINQ fait beaucoup de travail pour nous: <br><br><ol><li>  Cette m√©thode prend deux param√®tres - l'objet <em>RaycastHit2D</em> et l' <em>objet PolygonCollider2D</em> .  Toutes les pierres du niveau ont des collisionneurs PolygonCollider2D, donc si nous utilisons toujours des formes PolygonCollider2D, cela fonctionnera bien. </li><li>  C'est l√† que la magie des requ√™tes LINQ commence!  Ici, nous transformons la collection de points du collisionneur polygonal en <em>dictionnaire de</em> position <em>Vector2</em> (la valeur de chaque √©l√©ment du dictionnaire est la position elle-m√™me), et la cl√© de chaque √©l√©ment est affect√©e de la distance entre ce point et la position du joueur (valeur flottante).  Parfois, quelque chose d'autre se passe ici: la position r√©sultante est convertie en espace mondial (par d√©faut, les positions des sommets du collisionneur sont stock√©es dans l'espace local, c'est-√†-dire local par rapport √† l'objet auquel appartient le collisionneur, et nous avons besoin de positions dans l'espace mondial). </li><li>  Le dictionnaire est tri√© par cl√©.  En d'autres termes, par la distance la plus proche de la position actuelle du joueur.  La distance la plus proche est renvoy√©e, c'est-√†-dire que tout point renvoy√© par cette m√©thode est le point de collision entre le joueur et le point actuel de la charni√®re de corde! </li></ol><br>  Revenons au script <em>RopeSystem.cs</em> et ajoutons une nouvelle variable de champ priv√© en haut: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Dictionary&lt;Vector2, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; wrapPointsLookup = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;Vector2, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;();</code> </pre> <br>  Nous l'utilisons pour suivre les positions autour desquelles la corde peut s'enrouler. <br><br>  √Ä la fin de la m√©thode <code>Update()</code> , recherchez la construction <code>else</code> qui contient <code>crosshairSprite.enabled = false;</code>  et ajoutez ce qui suit: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 if (ropePositions.Count &gt; 0) { // 2 var lastRopePoint = ropePositions.Last(); var playerToCurrentNextHit = Physics2D.Raycast(playerPosition, (lastRopePoint - playerPosition).normalized, Vector2.Distance(playerPosition, lastRopePoint) - 0.1f, ropeLayerMask); // 3 if (playerToCurrentNextHit) { var colliderWithVertices = playerToCurrentNextHit.collider as PolygonCollider2D; if (colliderWithVertices != null) { var closestPointToHit = GetClosestColliderPointFromRaycastHit(playerToCurrentNextHit, colliderWithVertices); // 4 if (wrapPointsLookup.ContainsKey(closestPointToHit)) { ResetRope(); return; } // 5 ropePositions.Add(closestPointToHit); wrapPointsLookup.Add(closestPointToHit, 0); distanceSet = false; } } }</span></span></code> </pre> <br>  Expliquez ce morceau de code: <br><br><ol><li>  Si certaines positions sont enregistr√©es dans la liste des positions de <code>ropePositions</code> , alors ... </li><li>  Nous tirons depuis la position du joueur en direction du joueur qui regarde la derni√®re position de la corde de la liste - le point d'ancrage auquel le crochet de chat est attach√© √† la pierre - avec une distance de lancer de rayons √©gale √† la distance entre le joueur et la position du point d'ancrage de la corde. </li><li>  Si raycast entre en collision avec quelque chose, le collisionneur de cet objet est <em>converti en</em> toute s√©curit√© au type <em>PolygonCollider2D</em> .  Bien qu'il s'agisse d'un vrai PolygonCollider2D, la position de sommet la plus proche de ce collisionneur est retourn√©e en utilisant la m√©thode que nous avons √©crite plus t√¥t sous le nom de <em>Vector2</em> . </li><li>  Il est v√©rifi√© par <code>wrapPointsLookup</code> pour s'assurer que la m√™me position n'est pas v√©rifi√©e √† nouveau.  Si elle est coch√©e, nous jetons la corde et la coupons, laissant tomber le joueur. </li><li>  Ensuite, la liste des positions de corde est <code>ropePositions</code> : la position est ajout√©e autour de laquelle la corde doit s'enrouler.  Le dictionnaire <code>wrapPointsLookup</code> est √©galement mis √† jour.  Enfin, l'indicateur <code>distanceSet</code> est r√©initialis√© afin que la m√©thode <code>UpdateRopePositions()</code> puisse red√©finir la distance de la corde avec la nouvelle longueur de la corde et des segments. </li></ol><br>  Dans <code>ResetRope()</code> ajoutez la ligne suivante afin que le dictionnaire <code>wrapPointsLookup</code> effac√© √† chaque fois qu'un joueur d√©connecte une corde: <br><br><pre> <code class="cs hljs">wrapPointsLookup.Clear();</code> </pre> <br>  Enregistrez et lancez le jeu.  Tirez sur le crochet du chat dans la pierre au-dessus de la limace et utilisez l'outil D√©placer dans la fen√™tre Sc√®ne pour d√©placer la limace sur plusieurs rebords de pierre. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c62/999/f50/c62999f50094252b3850b8b4c54e2cdc.gif"></div><br>  C'est ainsi que nous avons appris √† la corde √† enrouler des objets! <br><br><h2>  Ajouter une capacit√© de basculement </h2><br>  La limace suspendue √† la corde est assez statique.  Pour r√©soudre ce probl√®me, nous pouvons ajouter une capacit√© de swing. <br><br>  Pour ce faire, nous devons obtenir une position perpendiculaire √† la position de basculement vers l'avant (lat√©ralement), quel que soit l'angle sous lequel il regarde. <br><br>  Ouvrez <em>PlayerMovement.cs</em> et ajoutez les deux variables publiques suivantes en haut du script: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 ropeHook; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> swingForce = <span class="hljs-number"><span class="hljs-number">4f</span></span>;</code> </pre> <br>  La variable <code>ropeHook</code> verra attribuer n'importe quelle position dans laquelle le crochet de corde est actuellement situ√©, et <code>swingForce</code> est la valeur que nous utilisons pour ajouter le mouvement de swing. <br><br>  Remplacez la m√©thode <code>FixedUpdate()</code> nouvelle: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FixedUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (horizontalInput &lt; <span class="hljs-number"><span class="hljs-number">0f</span></span> || horizontalInput &gt; <span class="hljs-number"><span class="hljs-number">0f</span></span>) { animator.SetFloat(<span class="hljs-string"><span class="hljs-string">"Speed"</span></span>, Mathf.Abs(horizontalInput)); playerSprite.flipX = horizontalInput &lt; <span class="hljs-number"><span class="hljs-number">0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isSwinging) { animator.SetBool(<span class="hljs-string"><span class="hljs-string">"IsSwinging"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 1 -          var playerToHookDirection = (ropeHook - (Vector2)transform.position).normalized; // 2 -  ,     Vector2 perpendicularDirection; if (horizontalInput &lt; 0) { perpendicularDirection = new Vector2(-playerToHookDirection.y, playerToHookDirection.x); var leftPerpPos = (Vector2)transform.position - perpendicularDirection * -2f; Debug.DrawLine(transform.position, leftPerpPos, Color.green, 0f); } else { perpendicularDirection = new Vector2(playerToHookDirection.y, -playerToHookDirection.x); var rightPerpPos = (Vector2)transform.position + perpendicularDirection * 2f; Debug.DrawLine(transform.position, rightPerpPos, Color.green, 0f); } var force = perpendicularDirection * swingForce; rBody.AddForce(force, ForceMode2D.Force); } else { animator.SetBool("IsSwinging", false); if (groundCheck) { var groundForce = speed * 2f; rBody.AddForce(new Vector2((horizontalInput * groundForce - rBody.velocity.x) * groundForce, 0)); rBody.velocity = new Vector2(rBody.velocity.x, rBody.velocity.y); } } } else { animator.SetBool("IsSwinging", false); animator.SetFloat("Speed", 0f); } if (!isSwinging) { if (!groundCheck) return; isJumping = jumpInput &gt; 0f; if (isJumping) { rBody.velocity = new Vector2(rBody.velocity.x, jumpSpeed); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les principaux changements ici sont que le drapeau est v√©rifi√© en premier </font></font><code>isSwinging</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">afin que les actions ne soient effectu√©es que lorsque la limace est suspendue √† la corde, et nous ajoutons √©galement une perpendiculaire au coin de la limace, indiquant son point d'ancrage actuel en haut de la corde, mais perpendiculaire √† la direction de son swing.</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous obtenons le vecteur de direction normalis√© du joueur au point d'attache du crochet. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selon que le slug oscille √† gauche ou √† droite, la direction perpendiculaire est calcul√©e √† l'aide de </font></font><code>playerToHookDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Un appel de d√©bogage a √©galement √©t√© ajout√© afin que vous puissiez le voir dans l'√©diteur si vous le souhaitez.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ouvrez </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RopeSystem.cs</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font><font style="vertical-align: inherit;">ajoutez ce qui suit </font><font style="vertical-align: inherit;">en haut du </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloc else</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √† l'int√©rieur de la </font></font><code>if(!ropeAttached)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©thode </font></font><code>Update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cs hljs">playerMovement.isSwinging = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; playerMovement.ropeHook = ropePositions.Last();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le bloc if de</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> m√™me conception, </font></font><code>if(!ropeAttached)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ajoutez ce qui suit:</font></font><br><br><pre> <code class="cs hljs">playerMovement.isSwinging = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous informons donc le script PlayerMovement que le joueur se balance, et d√©terminons √©galement la derni√®re position (√† l'exception de la position du joueur) de la corde - en d'autres termes, le point d'ancrage de la corde. </font><font style="vertical-align: inherit;">Ceci est n√©cessaire pour calculer l'angle perpendiculaire que nous venons d'ajouter au script PlayerMovement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici √† quoi cela ressemble si vous activez les gadgets dans un jeu de course et appuyez sur A ou D pour vous d√©placer vers la gauche / droite:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5bd/6a5/4ed/5bd6a54ed3c8661e61b3bf765e50acfb.png"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ajout d'une descente sur corde </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que nous n'ayons pas la possibilit√© de monter et descendre la corde. </font><font style="vertical-align: inherit;">Bien que dans la vraie vie, la limace ne puisse pas facilement monter et descendre le long de la corde, mais c'est un jeu dans lequel tout peut arriver, non? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En haut du script </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RopeSystem,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ajoutez deux nouvelles variables de champ:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> climbSpeed = <span class="hljs-number"><span class="hljs-number">3f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isColliding;</code> </pre> <br> <code>climbSpeed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©finira la vitesse √† laquelle la balle peut se d√©placer de haut en bas sur la corde et </font></font><code>isColliding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sera utilis√©e comme indicateur pour d√©terminer si la propri√©t√© de joint de distance de la corde de joint de distance peut √™tre augment√©e ou diminu√©e. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez cette nouvelle m√©thode:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleRopeLength</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 if (Input.GetAxis("Vertical") &gt;= 1f &amp;&amp; ropeAttached &amp;&amp; !isColliding) { ropeJoint.distance -= Time.deltaTime * climbSpeed; } else if (Input.GetAxis("Vertical") &lt; 0f &amp;&amp; ropeAttached) { ropeJoint.distance += Time.deltaTime * climbSpeed; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce bloc </font></font><code>if..elseif</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lit l'entr√©e le long de l'axe vertical (haut / bas ou W / S sur le clavier) et, en tenant compte des drapeaux, </font></font><code>ropeAttached iscColliding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">augmente ou diminue la distance </font></font><code>ropeJoint</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, cr√©ant l'effet d'allonger ou de raccourcir la corde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous accrochons cette m√©thode, en ajoutant son appel √† la fin </font></font><code>Update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cs hljs">HandleRopeLength();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons √©galement besoin d'un moyen de mettre le drapeau </font></font><code>isColliding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez les deux m√©thodes suivantes au bas du script:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTriggerStay2D</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Collider2D colliderStay</span></span></span><span class="hljs-function">)</span></span> { isColliding = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTriggerExit2D</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Collider2D colliderOnExit</span></span></span><span class="hljs-function">)</span></span> { isColliding = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ces deux m√©thodes sont des m√©thodes natives de la classe de base des scripts MonoBehaviour. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si le collisionneur touche actuellement un autre objet physique dans le jeu, la m√©thode se d√©clenchera constamment </font></font><code>OnTriggerStay2D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en attribuant une </font></font><code>isColliding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valeur </font><font style="vertical-align: inherit;">au drapeau </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cela signifie que lorsque la limace touche la pierre, le drapeau isColliding se voit attribuer une valeur </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La m√©thode est </font></font><code>OnTriggerExit2D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©clench√©e lorsqu'un collisionneur quitte la zone d'un autre collisionneur, d√©finissant le drapeau sur faux. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gardez √† l'esprit: la m√©thode </font></font><code>OnTriggerStay2D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut √™tre tr√®s co√ªteuse en calcul, alors utilisez-la avec pr√©caution.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O√π aller ensuite? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Red√©marrez le jeu et cette fois, appuyez sur les touches fl√©ch√©es ou W / S pour monter et descendre la corde. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/348/a3e/e5d/348a3ee5d95a10273c8bc644e3dbc7d9.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le projet termin√© de cette partie du tutoriel peut √™tre t√©l√©charg√© </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons parcouru un long chemin - de la limace-limace non balanc√©e au mollusque acrobatique sans coquille de gast√©ropode! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous avez appris √† cr√©er un syst√®me de vis√©e qui peut tirer un hame√ßon sur n'importe quel objet qui a un collisionneur, s'y accrocher et se balancer simultan√©ment dessus, se retournant sur une corde dynamique autour des bords des objets! </font><font style="vertical-align: inherit;">Excellent travail.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4dd/bb5/29d/4ddbb529d88b62441d7b2d91424bf906.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, une fonction importante manque ici - la corde ne peut pas se "d√©rouler" si n√©cessaire. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deuxi√®me partie du</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tutoriel, nous allons r√©soudre ce probl√®me. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais si vous √™tes pr√™t √† tenter votre chance, pourquoi ne pas essayer de le faire vous-m√™me? </font><font style="vertical-align: inherit;">Vous pouvez utiliser un dictionnaire pour cela </font></font><code>wrapPointsLookup</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr414887/">https://habr.com/ru/post/fr414887/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr414877/index.html">Un objectif inhabituel pour un appareil photo ordinaire ou comment arr√™ter de penser √† la mise au point</a></li>
<li><a href="../fr414879/index.html">Pourquoi 2 extrudeuses dans une imprimante 3D?</a></li>
<li><a href="../fr414881/index.html">Un peu de VK dans les coulisses</a></li>
<li><a href="../fr414883/index.html">Les souvenirs r√©sonnaient d'une mani√®re nouvelle: la BBC a mis √† jour les archives sonores du projet RemArc</a></li>
<li><a href="../fr414885/index.html">Nous traitons les erreurs et les ¬´b√©quilles¬ª dans le Registre d'√âtat unifi√© des entit√©s juridiques - le registre d'√âtat des entit√©s juridiques</a></li>
<li><a href="../fr414889/index.html">Quand les agences num√©riques ont besoin de l'IaaS</a></li>
<li><a href="../fr414891/index.html">Habitudes des d√©veloppeurs</a></li>
<li><a href="../fr414893/index.html">Viber, WhatsApp, Telegram - quel est le meilleur?</a></li>
<li><a href="../fr414895/index.html">Et pour nous, tout est ¬´droit¬ª - SGBD Vertica</a></li>
<li><a href="../fr414897/index.html">Acc√®s aux donn√©es dans les applications multi-utilisateurs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>