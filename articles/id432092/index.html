<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â˜ï¸ ğŸ‘¨ğŸ½â€âš–ï¸ âœ‹ğŸ¿ Kesalahan tidak menyenangkan saat menulis unit test ğŸ‘¨ğŸ¼ ğŸ‘©ğŸ½â€ğŸ¤â€ğŸ‘¨ğŸ¿ ğŸšˆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Suatu hari, saya akan membuat laporan internal di mana saya akan memberi tahu pengembang kami tentang kesalahan tidak menyenangkan yang dapat terjadi ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kesalahan tidak menyenangkan saat menulis unit test</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432092/">  Suatu hari, saya akan membuat laporan internal di mana saya akan memberi tahu pengembang kami tentang kesalahan tidak menyenangkan yang dapat terjadi ketika menulis unit test.  Kesalahan yang paling tidak menyenangkan dari sudut pandang saya adalah ketika tes lulus, tetapi pada saat yang sama mereka melakukannya dengan salah sehingga lebih baik tidak lulus.  Dan saya memutuskan untuk membagikan contoh kesalahan tersebut kepada semua orang.  Tentunya sesuatu yang lain untuk diceritakan dari daerah ini.  Contoh ditulis untuk Node.JS dan Mocha, tetapi secara umum kesalahan ini berlaku untuk ekosistem lainnya. <br><br>  Untuk membuatnya lebih menarik, beberapa dari mereka dibingkai dalam bentuk kode masalah dan spoiler, yang membuka, Anda akan melihat apa masalahnya.  Jadi saya sarankan Anda pertama kali melihat kode, menemukan kesalahan di dalamnya, dan kemudian buka spoiler.  Tidak ada solusi untuk masalah yang akan ditunjukkan - Saya mengusulkan untuk memikirkannya sendiri.  Hanya karena aku malas.  Urutan daftar itu tidak masuk akal - itu hanya urutan di mana saya mengingat semua jenis masalah nyata yang membuat kami menangis.  Tentunya banyak hal akan tampak jelas bagi Anda - tetapi bahkan pengembang yang berpengalaman dapat secara tidak sengaja menulis kode seperti itu. <br><br><a name="habracut"></a><br>  Jadi ayo pergi. <br><br>
<h3>  0. Kurang tes </h3><br>  Anehnya, banyak yang masih percaya bahwa tes menulis memperlambat kecepatan pengembangan.  Tentu saja, jelas bahwa lebih banyak waktu harus dihabiskan untuk menulis tes dan menulis kode yang dapat diuji.  Tetapi setelah debugging dan mundur setelah itu Anda harus menghabiskan waktu lebih banyak kali ... <br><br><h3>  1. Kurangnya menjalankan tes </h3><br>  Jika Anda memiliki tes yang tidak Anda jalankan, atau jalankan dari waktu ke waktu, maka ini seperti tidak adanya tes.  Dan bahkan lebih buruk lagi - Anda memiliki kode tes yang ketinggalan jaman dan rasa aman yang salah.  Tes setidaknya harus berjalan dalam proses CI saat mendorong kode ke cabang.  Dan lebih baik - secara lokal sebelum menekan.  Maka pengembang tidak harus kembali ke bangunan dalam beberapa hari, yang, ternyata, tidak lulus. <br><br><h3>  2. Kurangnya cakupan </h3><br>  Jika Anda masih tidak tahu apa cakupan dalam tes, maka saatnya untuk pergi dan membaca sekarang.  Setidaknya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wikipedia</a> .  Kalau tidak, ada kemungkinan bagus bahwa tes Anda akan memeriksa 10% dari kode yang Anda pikir akan diperiksa.  Cepat atau lambat Anda pasti akan menginjaknya.  Tentu saja, bahkan cakupan 100% dari kode tidak menjamin kebenaran lengkapnya dengan cara apa pun - tetapi ini jauh lebih baik daripada kurangnya cakupan karena akan menunjukkan Anda lebih banyak kesalahan potensial.  Tidak heran versi terbaru Node.JS bahkan memiliki alat bawaan untuk membacanya.  Secara umum, topik liputannya dalam dan sangat holistik, tetapi saya tidak akan terlalu mendalam ke dalamnya - saya ingin mengatakan sedikit tentang banyak hal. <br><br><h3>  3. </h3><br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {assert} = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'chai'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'bluebird'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sinon = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'sinon'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MightyLibrary</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> someLongFunction() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// just imagine a really complex and long function here } } async function doItQuickOrFail() { let res; try { res = await MightyLibrary.someLongFunction().timeout(1000); } catch (err) { if (err instanceof Promise.TimeoutError) { return false; } throw err; } return res; } describe('using Timeouts', ()=&gt;{ it('should return false if waited too much', async ()=&gt;{ // stub function to emulate looong work sinon.stub(MightyLibrary, 'someLongFunction').callsFake(()=&gt;Promise.delay(10000).then(()=&gt;true)); const res = await doItQuickOrFail(); assert.equal(res, false); }); });</span></span></code> </pre> <br><br><div class="spoiler">  <b class="spoiler_title">Ada apa di sini</b> <div class="spoiler_text"><blockquote>  Waktu habis dalam tes unit. <br><br>  Di sini mereka ingin memeriksa bahwa pengaturan waktu tunggu untuk operasi yang lama benar-benar berfungsi.  Secara umum, ini sedikit masuk akal - Anda tidak harus memeriksa perpustakaan standar - tetapi juga kode ini mengarah ke masalah lain - untuk meningkatkan waktu pelaksanaan tes selama satu detik.  Tampaknya ini tidak terlalu banyak ... Tapi gandakan yang kedua ini dengan jumlah tes yang sama, dengan jumlah pengembang, dengan jumlah peluncuran per hari ... Dan Anda akan mengerti bahwa karena timeout seperti itu Anda dapat kehilangan banyak jam kerja setiap minggu, jika tidak setiap hari. </blockquote><br></div></div><br><br><h3>  4. </h3><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testData = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(fs.readFileSync(<span class="hljs-string"><span class="hljs-string">'./testData.json'</span></span>, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>)); describe(<span class="hljs-string"><span class="hljs-string">'some block'</span></span>, ()=&gt;{ it(<span class="hljs-string"><span class="hljs-string">'should do something'</span></span>, ()=&gt;{ someTest(testData); }) })</code> </pre> <br><br><div class="spoiler">  <b class="spoiler_title">Ada apa di sini</b> <div class="spoiler_text"><blockquote>  Memuat data uji di luar blok uji. <br><br>  Sekilas, tampaknya tidak masalah di mana harus membaca data uji - dalam uraian, blokir atau dalam modul itu sendiri.  Yang kedua juga.  Tetapi bayangkan Anda memiliki ratusan tes, dan banyak dari mereka menggunakan data berat.  Jika Anda memuatnya di luar tes, ini akan mengarah pada kenyataan bahwa semua data uji akan tetap dalam memori sampai akhir pelaksanaan tes, dan seiring waktu, peluncuran akan mengkonsumsi lebih banyak dan lebih banyak RAM - sampai ternyata tes tidak lagi berjalan sama sekali mesin kerja standar. </blockquote><br></div></div><br><br><h3>  5. </h3><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {assert} = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'chai'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sinon = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'sinon'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// eslint-disable-next-line class-methods-use-this say() { return 'Wow'; } } describe('stubsEverywhere', ()=&gt;{ before(()=&gt;{ sinon.stub(Dog.prototype, 'say').callsFake(()=&gt;{ return 'meow'; }); }); it('should say meow', ()=&gt;{ const dog = new Dog(); assert.equal(dog.say(), 'meow', 'dog should say "meow!"'); }); });</span></span></code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">Ada apa di sini</b> <div class="spoiler_text"><blockquote>  Kode sebenarnya diganti oleh bertopik. <br><br>  Tentunya Anda langsung melihat kesalahan konyol ini.  Dalam kode asli, ini, tentu saja, tidak begitu jelas - tetapi saya melihat kode yang sangat tergantung dengan bertopik sehingga saya tidak menguji apa pun sama sekali. </blockquote><br></div></div><br><br><h3>  6. </h3><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sinon = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'sinon'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {assert} = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'chai'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> </span></span>{ fetch() {} loadData() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fetch(); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!sinon.sandbox || !sinon.sandbox.stub) { sinon.sandbox = sinon.createSandbox(); } describe(<span class="hljs-string"><span class="hljs-string">'My widget'</span></span>, () =&gt; { it(<span class="hljs-string"><span class="hljs-string">'is awesome'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> widget = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Widget(); widget.fetch = sinon.sandbox.stub().returns({ <span class="hljs-attr"><span class="hljs-attr">one</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">two</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }); widget.loadData(); assert.isTrue(widget.fetch.called); }); });</code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">Ada apa di sini</b> <div class="spoiler_text"><blockquote>  Ketergantungan antara tes. <br><br>  Sepintas jelas mereka lupa menulis di sini <br><br><pre> <code class="javascript hljs"> afterEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { sinon.sandbox.restore(); });</code> </pre> <br><br>  Tapi masalahnya bukan hanya ini, tetapi kotak pasir yang sama digunakan untuk semua tes.  Dan sangat mudah untuk membingungkan lingkungan pelaksanaan tes sedemikian rupa sehingga mereka mulai saling bergantung.  Setelah itu, tes akan mulai dilakukan hanya dalam urutan tertentu, dan secara umum tidak jelas apa yang harus diuji. <br><br>  Untungnya, di beberapa titik sinon.sandbox dinyatakan usang dan terputus, sehingga Anda hanya dapat menemukan masalah seperti itu pada proyek lawas - tetapi ada begitu banyak cara lain untuk membingungkan lingkungan pelaksanaan pengujian sedemikian rupa sehingga menyakitkan untuk diselidiki kemudian. kode mana yang bersalah karena perilaku yang salah.  Ngomong-ngomong, baru-baru ini ada posting di hub tentang beberapa jenis templat seperti "Pabrik Es" - ini bukan obat mujarab, tapi kadang-kadang membantu dalam kasus seperti itu. </blockquote><br><br></div></div><br><br><h3>  7. Data uji besar dalam file uji </h3><br><br>  Sangat sering saya melihat seberapa besar file JSON, dan bahkan XML, langsung berada dalam pengujian.  Saya pikir jelas mengapa ini tidak layak dilakukan - menjadi menyakitkan untuk menonton, mengedit, dan setiap IDE tidak akan berterima kasih untuk itu.  Jika Anda memiliki data uji yang besar, keluarkan dari file uji. <br><br><h3>  8. </h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {assert} = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'chai'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> crypto = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'crypto'</span></span>); describe(<span class="hljs-string"><span class="hljs-string">'extraTests'</span></span>, ()=&gt;{ it(<span class="hljs-string"><span class="hljs-string">'should generate unique bytes'</span></span>, ()=&gt;{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value = crypto.randomBytes(<span class="hljs-number"><span class="hljs-number">256</span></span>); arr.push(value); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> unique = arr.filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el, index</span></span></span><span class="hljs-function">)=&gt;</span></span>arr.indexOf(el) === index); assert.equal(arr.length, unique.length, <span class="hljs-string"><span class="hljs-string">'Data is not random enough!'</span></span>); }); });</code> </pre> <br><br><div class="spoiler">  <b class="spoiler_title">Ada apa di sini</b> <div class="spoiler_text"><blockquote>  Tes ekstra. <br><br>  Dalam hal ini, pengembang sangat khawatir bahwa pengidentifikasi uniknya akan unik, jadi ia menulis cek untuk ini.  Secara umum, keinginan yang dapat dipahami - tetapi lebih baik membaca dokumentasi atau menjalankan tes seperti itu beberapa kali tanpa menambahkannya ke proyek.  Menjalankannya di setiap bangunan tidak masuk akal. <br><br>  Nah, ikatan untuk nilai acak dalam tes itu sendiri merupakan cara yang bagus untuk menembak diri sendiri di kaki dengan membuat tes tidak stabil dari awal. </blockquote><br></div></div><br><br><h3>  9. Kekurangan mok </h3><br>  Jauh lebih mudah untuk menjalankan tes dengan database langsung dan layanan 100 persen, dan untuk menjalankan tes pada mereka. <br>  Tetapi cepat atau lambat itu akan kembali membuahkan hasil - tes penghilangan data akan dilakukan pada basis produk, akan mulai jatuh karena layanan mitra yang rusak, atau CI Anda tidak akan memiliki basis untuk menjalankannya.  Secara umum, item tersebut cukup holistik, tetapi sebagai aturan - jika Anda dapat meniru layanan eksternal, maka lebih baik melakukannya. <br><br><h3>  11. </h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {assert} = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'chai'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomError</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Error</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mytestFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomError(<span class="hljs-string"><span class="hljs-string">'important message'</span></span>); } describe(<span class="hljs-string"><span class="hljs-string">'badCompare'</span></span>, ()=&gt;{ it(<span class="hljs-string"><span class="hljs-string">'should throw only my custom errors'</span></span>, ()=&gt;{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> errorHappened = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { mytestFunction(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { errorHappened = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; assert.isTrue(err <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> CustomError); } assert.isTrue(errorHappened); }); });</code> </pre> <br><br><div class="spoiler">  <b class="spoiler_title">Ada apa di sini</b> <div class="spoiler_text"><blockquote>  Kesalahan debugging yang rumit. <br><br>  Semuanya tidak buruk, tetapi ada satu masalah - jika tes tiba-tiba crash, Anda akan melihat kesalahan formulir <br><br> <code>1) badCompare <br> should throw only my custom errors: <br> <br> AssertionError: expected false to be true <br> + expected - actual <br> <br> -false <br> +true <br> <br> at Context.it (test/011_badCompare/test.js:23:14)</code> <br> <br>  Selanjutnya, untuk memahami kesalahan macam apa yang sebenarnya terjadi - Anda harus menulis ulang tes.  Jadi dalam kasus kesalahan yang tidak terduga - coba tes berbicara tentang hal itu, dan bukan hanya fakta bahwa itu terjadi. </blockquote><br></div></div><br><br><h3>  12. </h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {assert} = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'chai'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someVeryBigFunc1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// imagine a tonn of code here } function someVeryBigFunc2() { return 2; // imagine a tonn of code here } describe('all Before Tests', ()=&gt;{ let res1; let res2; before(async ()=&gt;{ res1 = await someVeryBigFunc1(); res2 = await someVeryBigFunc2(); }); it('should return 1', ()=&gt;{ assert.equal(res1, 1); }); it('should return 2', ()=&gt;{ assert.equal(res2, 2); }); });</span></span></code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">Ada apa di sini</b> <div class="spoiler_text"><blockquote>  Semua yang ada di blok sebelumnya. <br><br>  Tampaknya pendekatan yang keren adalah melakukan semua operasi di blok `before`, dan dengan demikian hanya meninggalkan pemeriksaan di dalam` it`. <br>  Tidak juga. <br>  Karena dalam hal ini ada kekacauan di mana Anda tidak dapat memahami waktu pelaksanaan tes yang sebenarnya, atau alasan untuk jatuh, atau apa yang terkait dengan satu tes, dan apa yang lain. <br>  Jadi semua pekerjaan tes (kecuali untuk inisialisasi standar) harus dilakukan di dalam tes itu sendiri. </blockquote><br></div></div><br><br><h3>  13. </h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {assert} = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'chai'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> moment = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'moment'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someDateBasedFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">date</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moment().isAfter(date)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } describe(<span class="hljs-string"><span class="hljs-string">'useFutureDate'</span></span>, ()=&gt;{ it(<span class="hljs-string"><span class="hljs-string">'should return 0 for passed date'</span></span>, ()=&gt;{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pastDate = moment(<span class="hljs-string"><span class="hljs-string">'2010-01-01'</span></span>); assert.equal(someDateBasedFunction(pastDate), <span class="hljs-number"><span class="hljs-number">0</span></span>); }); it(<span class="hljs-string"><span class="hljs-string">'should return 1 for future date'</span></span>, ()=&gt;{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> itWillAlwaysBeInFuture = moment(<span class="hljs-string"><span class="hljs-string">'2030-01-01'</span></span>); assert.equal(someDateBasedFunction(itWillAlwaysBeInFuture), <span class="hljs-number"><span class="hljs-number">1</span></span>); }); });</code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">Ada apa di sini</b> <div class="spoiler_text"><blockquote>  Ikat tanggal. <br><br>  Itu juga akan tampak seperti kesalahan nyata - tetapi juga muncul secara berkala di antara pengembang yang lelah yang sudah percaya bahwa besok tidak akan pernah datang.  Dan bangunan yang berjalan baik kemarin tiba-tiba jatuh hari ini. <br><br>  Ingatlah bahwa tanggal apa pun akan datang cepat atau lambat - jadi gunakan emulasi waktu dengan hal-hal seperti `sinon.fakeTimers`, atau setidaknya atur tanggal jauh seperti 2050 - biarkan keturunan Anda terluka ... </blockquote><br></div></div><br><br><h3>  14. </h3><br><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'dynamicRequires'</span></span>, ()=&gt;{ it(<span class="hljs-string"><span class="hljs-string">'should return english locale'</span></span>, ()=&gt;{ <span class="hljs-comment"><span class="hljs-comment">// HACK : // Some people mutate locale in tests to chinese so I will require moment here // eslint-disable-next-line global-require const moment = require('moment'); const someDate = moment('2010-01-01').format('MMMM'); assert.equal(someDate, 'January'); }); });</span></span></code> </pre> <br><br><div class="spoiler">  <b class="spoiler_title">Ada apa di sini</b> <div class="spoiler_text"><blockquote>  Memuat modul secara dinamis. <br><br>  Jika Anda memiliki Eslint, maka Anda mungkin telah melarang dependensi dinamis.  Atau tidak. <br>  Seringkali saya melihat bahwa pengembang mencoba memuat pustaka atau berbagai modul langsung di dalam tes.  Namun, mereka umumnya tahu bagaimana `mengharuskan` bekerja - tetapi mereka lebih suka ilusi bahwa mereka seharusnya diberikan modul bersih yang tidak ada yang bingung sejauh ini. <br>  Asumsi ini berbahaya karena memuat modul tambahan selama pengujian lebih lambat, dan sekali lagi mengarah pada perilaku yang lebih tidak jelas. </blockquote><br></div></div><br><br><h3>  15. </h3><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someComplexFunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Imagine a piece of really strange code here return 1; } describe('cryptic', ()=&gt;{ it('success', ()=&gt;{ const result = someComplexFunc(); assert.equal(result, 1); }); it('should not fail', ()=&gt;{ const result = someComplexFunc(); assert.equal(result, 1); }); it('is right', ()=&gt;{ const result = someComplexFunc(); assert.equal(result, 1); }); it('makes no difference for solar system', ()=&gt;{ const result = someComplexFunc(); assert.equal(result, 1); }); });</span></span></code> </pre> <br><br><div class="spoiler">  <b class="spoiler_title">Ada apa di sini</b> <div class="spoiler_text"><blockquote>  Nama uji yang tidak dapat dipahami. <br><br>  Anda pasti bosan dengan hal-hal yang jelas, bukan?  Tetapi Anda masih harus mengatakannya karena banyak yang tidak repot-repot menuliskan nama yang dapat dimengerti untuk tes - dan sebagai hasilnya, adalah mungkin untuk memahami apa yang dilakukan tes tertentu hanya setelah banyak penelitian. </blockquote><br></div></div><br><br><h3>  16. </h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {assert} = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'chai'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'bluebird'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someTomeoutingFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.TimeoutError(); } describe(<span class="hljs-string"><span class="hljs-string">'no Error check'</span></span>, ()=&gt;{ it(<span class="hljs-string"><span class="hljs-string">'should throw error'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> ()=&gt;{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timedOut = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> someTomeoutingFunction(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { timedOut = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } assert.equal(timedOut, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); }); });</code> </pre> <br><br><div class="spoiler">  <b class="spoiler_title">Ada apa di sini</b> <div class="spoiler_text"><blockquote>  Kurangnya verifikasi kesalahan yang dilemparkan. <br><br>  Seringkali Anda perlu memeriksa bahwa dalam beberapa kasus fungsi melempar kesalahan.  Tetapi Anda selalu perlu memeriksa apakah ini droid yang kami cari - karena mungkin tiba-tiba muncul kesalahan lain yang dibuang, di tempat lain dan karena alasan lain ... </blockquote><br></div></div><br><br><h3>  17. </h3><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someBadFunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'I am just wrong!'</span></span>); } describe.skip(<span class="hljs-string"><span class="hljs-string">'skipped test'</span></span>, ()=&gt;{ it(<span class="hljs-string"><span class="hljs-string">'should be fine'</span></span>, ()=&gt;{ someBadFunc(); }); });</code> </pre> <br><br><div class="spoiler">  <b class="spoiler_title">Ada apa di sini</b> <div class="spoiler_text"><blockquote>  Tes yang dinonaktifkan. <br><br>  Tentu saja, suatu situasi mungkin selalu muncul ketika kode sudah diuji berkali-kali dengan tangan Anda, Anda perlu segera menggulungnya, dan untuk beberapa alasan tes tidak berfungsi.  Misalnya, karena komplikasi yang tidak jelas dari tes lain, yang saya tulis sebelumnya.  Dan tes dimatikan.  Dan ini normal.  Tidak normal - jangan langsung mengatur tugas untuk menghidupkan kembali tes.  Jika ini tidak dilakukan, maka jumlah tes yang dinonaktifkan akan berlipat ganda, dan kode mereka akan terus menjadi usang.  Sampai satu-satunya pilihan tetap - tunjukkan belas kasihan dan lempar semua tes ini nafig, karena lebih cepat menulisnya lagi daripada memahami kesalahannya. </blockquote><br></div></div><br><br>  Berikut adalah pilihan keluar.  Semua tes ini lulus tes dengan baik, tetapi mereka rusak oleh desain.  Tambahkan opsi Anda di komentar, atau di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori yang</a> saya buat untuk mengumpulkan kesalahan seperti itu. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id432092/">https://habr.com/ru/post/id432092/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id432082/index.html">Microsoft AI Chatbot Meluncurkan Koleksi Pakaian Cina</a></li>
<li><a href="../id432084/index.html">Bagaimana kami mengatur kompetisi shift antara pekerja produksi (seperti dalam USSR)</a></li>
<li><a href="../id432086/index.html">Pencetakan 3D di sekolah internasional dinamai M.V. Lomonosov</a></li>
<li><a href="../id432088/index.html">Ketersediaan Tinggi MySQL di GitHub</a></li>
<li><a href="../id432090/index.html">Magento Meetup Kharkiv No. 4 - laporan video</a></li>
<li><a href="../id432094/index.html">Hackathon online gabungan dari OpenGift dan Credits Blockchain Platform</a></li>
<li><a href="../id432096/index.html">Panduan Lengkap CMake. Bagian Dua: Membangun Sistem</a></li>
<li><a href="../id432098/index.html">Autopilots dalam transportasi jalan, bagaimana berinteraksi dengan spesial. dengan transportasi?</a></li>
<li><a href="../id432100/index.html">Bagaimana Kami Meningkatkan Konversi Penagihan</a></li>
<li><a href="../id432102/index.html">Fitur JavaScript Eksplisit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>