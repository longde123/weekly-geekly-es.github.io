<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¸ğŸ½ ğŸ¯ ğŸ¤œğŸ» Why Go is Bad untuk Pemrogram Bodoh ğŸ‘ŒğŸ¾ ğŸš‚ â¡ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini ditulis sebagai tanggapan terhadap artikel antipode yang diterbitkan sebelumnya. 





 Selama dua tahun terakhir ditambah, saya telah men...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Why Go is Bad untuk Pemrogram Bodoh</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448932/"><p>  Artikel ini ditulis sebagai tanggapan terhadap <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel antipode yang</a> diterbitkan sebelumnya. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ac9/24e/5c8/ac924e5c8c90275379b035cfa5b1f23b.jpg" alt="gambar"></p><br><p>  Selama dua tahun terakhir ditambah, saya telah menggunakan Go untuk mengimplementasikan server RADIUS khusus dengan sistem penagihan yang dikembangkan.  Dalam prosesnya, saya mempelajari seluk-beluk bahasa itu sendiri.  Program-program itu sendiri sangat sederhana dan bukan tujuan menulis artikel, tetapi pengalaman menggunakan Go sendiri layak untuk mengatakan beberapa kata dalam pembelaannya.  Go menjadi bahasa yang semakin populer untuk kode yang serius dan dapat diskalakan.  Bahasa dibuat di Google, di mana ia digunakan secara aktif.  Untuk meringkas, saya dengan tulus percaya bahwa desain bahasa Go buruk untuk programmer bodoh. </p><a name="habracut"></a><br><h1>  Dirancang untuk programmer yang lemah? </h1><br><blockquote>  Lemah bicara tentang masalah.  Pembicaraan yang kuat tentang ide dan impian ... </blockquote><p>  Go sangat sederhana untuk dipelajari, sangat sederhana sehingga Anda dapat membaca kode dengan sedikit atau tanpa persiapan sama sekali.  Fitur bahasa ini digunakan di banyak perusahaan dunia ketika kode dibaca bersama dengan spesialis non-inti (manajer, pelanggan, dll.).  Ini sangat nyaman untuk metodologi seperti Desain Berbasis Pengembangan. </p><br><p>  Bahkan programmer pemula mulai menghasilkan kode yang lumayan setelah satu atau dua minggu.  Buku yang saya pelajari Go disebut â€œGo Programmingâ€ (ditulis oleh Mark Summerfield).  Buku ini sangat bagus, menyentuh banyak nuansa bahasa.  Setelah bahasa rumit yang tidak perlu seperti Java, PHP, kurangnya sihir menyegarkan.  Tetapi cepat atau lambat, banyak programmer terbatas memiliki keinginan untuk menggunakan metode lama di bidang baru.  Apakah ini benar-benar perlu? </p><br><p>  Rob Pike (ahli ideologi utama bahasa) menciptakan Go sebagai bahasa industri yang mudah dibaca, efektif digunakan.  Bahasa ini dirancang untuk produktivitas maksimum dalam tim besar dan tidak ada keraguan tentang hal itu.  Banyak programmer pemula mengeluh bahwa ada banyak fitur yang kurang.  Keinginan untuk kesederhanaan ini adalah keputusan sadar dari pengembang bahasa, dan untuk memahami sepenuhnya untuk apa, kami perlu memahami motivasi pengembang dan apa yang mereka capai di Go. </p><br><p>  Jadi mengapa itu dibuat sangat sederhana?  Berikut beberapa kutipan dari Rob Pike: </p><br><blockquote>  Poin kunci di sini adalah bahwa programmer kami bukan peneliti.  Mereka biasanya masih sangat muda, datang kepada kami sepulang sekolah, mungkin mereka belajar Java, atau C / C ++, atau Python.  Mereka tidak dapat memahami bahasa yang luar biasa, tetapi pada saat yang sama, kami ingin mereka membuat perangkat lunak yang baik.  Itu sebabnya bahasa harus mudah dipahami dan dipelajari. <br><br>  Dia harus terbiasa, secara kasar berbicara seperti C.  Pemrogram Google memulai karier mereka lebih awal dan sebagian besar terbiasa dengan bahasa prosedural, khususnya keluarga C.  Persyaratan untuk produktivitas cepat dalam bahasa pemrograman baru berarti bahasanya tidak boleh terlalu radikal. <br></blockquote><p>  Kata-kata bijak, bukan? </p><br><h1>  Artefak Kesederhanaan </h1><br><blockquote>  Kesederhanaan adalah syarat penting bagi yang cantik.  Leo Tolstoy. </blockquote><p>  Menjadi sederhana adalah salah satu aspirasi terpenting dalam desain apa pun.  Seperti yang Anda ketahui, proyek yang sempurna bukanlah proyek di mana tidak ada yang perlu ditambahkan, tetapi satu - yang darinya tidak ada yang dihapus.  Banyak yang percaya bahwa untuk menyelesaikan (atau bahkan mengekspresikan) tugas yang kompleks, diperlukan alat yang kompleks.  Namun, ini tidak benar.  Ambil contoh bahasa PERL.  Para ahli ideologi bahasa percaya bahwa seorang programmer harus memiliki setidaknya tiga cara berbeda untuk menyelesaikan satu masalah.  Para ahli ideologi bahasa Go pergi dengan cara yang berbeda, mereka memutuskan bahwa untuk mencapai tujuan, satu cara sudah cukup, tetapi sangat bagus.  Pendekatan ini memiliki dasar yang serius: satu-satunya cara adalah lebih mudah untuk dipelajari dan lebih sulit untuk dilupakan. </p><br><p>  Banyak migran mengeluh bahwa bahasa tersebut tidak mengandung abstraksi yang elegan.  Ya, memang, tapi ini adalah salah satu kelebihan utama bahasa tersebut.  Bahasa ini mengandung minimum sihir - oleh karena itu, tidak diperlukan pengetahuan mendalam untuk membaca program ini.  Adapun verbositas kode, ini bukan masalah sama sekali.  Program Golang yang ditulis dengan baik dibaca secara vertikal dengan sedikit atau tanpa penataan.  Selain itu, kecepatan membaca suatu program setidaknya merupakan urutan besarnya lebih cepat daripada tulisannya.  Jika Anda menganggap bahwa semua kode memiliki format seragam (dilakukan dengan menggunakan perintah gofmt bawaan), maka membaca beberapa baris tambahan bukanlah masalah sama sekali. </p><br><h1>  Tidak terlalu ekspresif </h1><br><blockquote>  Seni tidak menoleransi ketika membatasi kebebasannya.  Akurasi bukan tanggung jawabnya. </blockquote><p>  Karena keinginan untuk kesederhanaan, Go tidak memiliki konstruksi yang dalam bahasa lain dianggap sebagai sesuatu yang alami bagi orang yang terbiasa dengan mereka.  Pada awalnya, ini mungkin agak merepotkan, tetapi kemudian Anda perhatikan bahwa program ini dibaca berkali-kali lebih mudah dan lebih pasti. </p><br><p>  Misalnya, utilitas konsol yang membaca stdin atau file dari argumen baris perintah akan terlihat seperti ini: </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"bufio"</span></span> <span class="hljs-string"><span class="hljs-string">"flag"</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"os"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { flag.Parse() scanner := newScanner(flag.Args()) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> text <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> scanner.Scan() { text += scanner.Text() } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := scanner.Err(); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } fmt.Println(text) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newScanner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(flags []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bufio</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Scanner</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(flags) == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bufio.NewScanner(os.Stdin) } file, err := os.Open(flags[<span class="hljs-number"><span class="hljs-number">0</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bufio.NewScanner(file) }</code> </pre> <br><p>  Meskipun solusi untuk masalah yang sama dalam bahasa D terlihat sedikit lebih pendek, bagaimanapun, tidak mudah untuk dibaca </p><br><pre> <code class="plaintext hljs">import std.stdio, std.array, std.conv; void main(string[] args) { try { auto source = args.length &gt; 1 ? File(args[1], "r") : stdin; auto text = source.byLine.join.to!(string); writeln(text); } catch (Exception ex) { writeln(ex.msg); } }</code> </pre> <br><h1>  Salin neraka </h1><br><blockquote>  Manusia membawa neraka dalam dirinya sendiri.  Martin Luther. </blockquote><p>  Para pemula selalu mengeluh tentang Go dalam hal kurangnya obat generik.  Untuk mengatasi masalah ini, kebanyakan dari mereka menggunakan penyalinan kode langsung.  Sebagai contoh, para profesional yang kurang beruntung tersebut percaya bahwa fungsi untuk meringkas daftar bilangan bulat tidak dapat diimplementasikan dengan cara lain selain dengan menyalin-tempel sederhana untuk setiap tipe data. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int64Sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(list []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x := <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(list); x++ { result += list[x] } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span>(result) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int32Sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(list []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">int32</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x := <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(list); x++ { result += list[x] } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span>(result) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { list32 := []<span class="hljs-keyword"><span class="hljs-keyword">int32</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>} list64 := []<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>} fmt.Println(int32Sum(list32)) fmt.Println(int64Sum(list64)) }</code> </pre> <br><p>  Bahasa memiliki sarana yang cukup untuk mengimplementasikan konstruksi tersebut.  Sebagai contoh, pemrograman umum baik-baik saja. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Eval32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(list []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32</span></span></span></span><span class="hljs-function"><span class="hljs-params">, fn </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int32</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int32</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">int32</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, val := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> list { res = fn(res, val) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int32Add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int32</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int32Sub</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int32</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a - b } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Eval64</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(list []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">, fn </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int64</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, val := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> list { res = fn(res, val) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int64Add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int64Sub</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a - b } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { list32 := []<span class="hljs-keyword"><span class="hljs-keyword">int32</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>} list64 := []<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>} fmt.Println(Eval32(list32, int32Add)) fmt.Println(Eval64(list64, int64Add)) fmt.Println(Eval64(list64, int64Sub)) }</code> </pre> <br><p>  Dan, meskipun kode kami ternyata agak lebih panjang dari kasus sebelumnya, itu menjadi umum.  Oleh karena itu, tidak akan sulit bagi kita untuk menerapkan semua operasi aritmatika. </p><br><p>  Banyak yang akan mengatakan bahwa program D terlihat jauh lebih pendek dan benar. </p><br><pre> <code class="plaintext hljs">import std.stdio; import std.algorithm; void main(string[] args) { [1, 2, 3, 4, 5].reduce!((a, b) =&gt; a + b).writeln; }</code> </pre> <br><p>  Namun, ini hanya lebih pendek, tetapi tidak lebih benar, karena masalah penanganan kesalahan sepenuhnya diabaikan dalam implementasi D. </p><br><p>  Dalam kehidupan nyata, ketika kompleksitas logika meningkat, kesenjangannya dengan cepat menyempit.  Bahkan lebih cepat, kesenjangan dipersempit ketika diperlukan tindakan yang tidak dapat dilakukan menggunakan operator bahasa standar. </p><br><p>  Dalam hal dukungan, ekstensibilitas, keterbacaan, menurut pendapat saya, bahasa Go menang, meskipun hilang dalam verbositas. </p><br><p>  Pemrograman umum dalam beberapa kasus memberi kita manfaat yang tidak dapat disangkal.  Ini dengan jelas menggambarkan paket sortir.  Jadi, untuk mengurutkan daftar apa pun, cukup bagi kita untuk mengimplementasikan antarmuka sort.Interface. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"sort"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Names []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ns Names)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Len</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(ns) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ns Names)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Less</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, j </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ns[i] &lt; ns[j] } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ns Names)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, j </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { ns[i], ns[j] = ns[j], ns[i] } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { names := Names{<span class="hljs-string"><span class="hljs-string">"London"</span></span>, <span class="hljs-string"><span class="hljs-string">"Berlin"</span></span>, <span class="hljs-string"><span class="hljs-string">"Rim"</span></span>} sort.Sort(names) }</code> </pre> <br><p>  Jika Anda mengambil proyek open source dan menjalankan perintah grep "interface {}" -R, Anda akan melihat seberapa sering antarmuka bingung digunakan.  Rekan-rekan yang berpikiran sempit akan segera mengatakan bahwa semua ini adalah karena kurangnya obat generik.  Namun, ini jauh dari selalu terjadi.  Ambil contoh bahasa DELPHI.  Meskipun memiliki generik yang sama, ini berisi tipe VARIAN khusus untuk operasi dengan tipe data arbitrer.  Go melakukan hal yang sama. </p><br><h1>  Dari pistol burung pipit </h1><br><blockquote>  Dan jaket harus sesuai dengan ukuran kegilaan.  Stanislav Mari. </blockquote><p>  Banyak penggemar olahraga ekstrim dapat mengatakan bahwa Go memiliki mekanisme lain untuk membuat obat generik - refleksi.  Dan mereka akan benar ... tetapi hanya dalam kasus yang jarang terjadi. </p><br><p>  Rob Pike memperingatkan kita: </p><br><blockquote>  Ini adalah alat yang ampuh yang harus digunakan dengan hati-hati.  Ini harus dihindari sampai benar-benar diperlukan. <br></blockquote><p>  Wikipedia memberi tahu kami hal berikut: </p><br><blockquote>  Refleksi berarti proses di mana suatu program dapat melacak dan memodifikasi struktur dan perilakunya sendiri pada saat runtime.  Refleksi yang mendasari paradigma pemrograman disebut pemrograman refleksif.  Ini adalah jenis metaprogramming. <br></blockquote><p>  Namun, seperti yang Anda tahu, Anda harus membayar semuanya.  Dalam hal ini adalah: </p><br><ul><li>  kesulitan menulis program </li><li>  kecepatan eksekusi program </li></ul><br><p>  Oleh karena itu, refleksi harus digunakan dengan hati-hati, sebagai senjata kaliber besar.  Penggunaan refleksi tanpa berpikir menyebabkan program yang tidak dapat dibaca, kesalahan konstan dan kecepatan rendah.  Persisnya adalah bahwa programmer sombong bisa memamerkan kodenya di depan rekan-rekan lain yang lebih pragmatis dan sederhana. </p><br><h1>  Bagasi budaya dari C?  Tidak, dari sejumlah bahasa! </h1><br><blockquote>  Seiring dengan negara, ahli waris dibiarkan dengan hutang. </blockquote><p>  Terlepas dari kenyataan bahwa banyak yang percaya bahwa bahasa sepenuhnya didasarkan pada warisan C, ini tidak begitu.  Bahasa telah memasukkan banyak aspek dari bahasa pemrograman terbaik. </p><br><h2>  Sintaks </h2><br><p>  Pertama-tama, sintaks konstruksi gramatikal didasarkan pada sintaksis bahasa C.  Namun, bahasa DELPHI juga memiliki dampak yang signifikan.  Jadi, kita melihat bahwa tanda kurung berlebih dihapus sepenuhnya, sehingga sangat mengurangi keterbacaan program.  Juga, bahasa tersebut berisi operator :: =, yang melekat dalam bahasa DELPHI.  Konsep paket dipinjam dari bahasa seperti ADA.  Pernyataan entitas yang tidak digunakan dipinjam dari bahasa PROLOG. </p><br><h2>  Semantik </h2><br><p>  Semantik bahasa DELPHI diambil sebagai dasar paket.  Setiap paket merangkum data dan kode dan berisi entitas swasta dan publik.  Ini memungkinkan Anda untuk mengurangi antarmuka paket ke minimum. </p><br><p>  Operasi implementasi dengan metode delegasi dipinjam dari DELPHI. </p><br><h2>  Kompilasi </h2><br><p>  Tidak heran ada lelucon: Go dikembangkan saat program C disusun.  Salah satu kelebihan bahasa ini adalah kompilasi yang sangat cepat.  Gagasan itu dipinjam dari DELPHI.  Selain itu, setiap paket Go sesuai dengan modul DELPHI.  Paket-paket ini dikompilasi ulang hanya jika diperlukan.  Oleh karena itu, setelah pengeditan berikutnya, tidak perlu mengkompilasi seluruh program, tetapi cukup mengkompilasi ulang hanya paket dan paket yang diubah tergantung pada paket yang diubah ini (dan itu hanya jika antarmuka paket telah berubah). </p><br><h2>  Desain tingkat tinggi </h2><br><p>  Bahasa tersebut mengandung banyak konstruksi tingkat tinggi yang berbeda yang sama sekali tidak terkait dengan bahasa tingkat rendah seperti C. </p><br><ul><li>  Garis </li><li>  Hash meja </li><li>  Irisan </li><li>  Mengetik bebek dipinjam dari bahasa seperti RUBY (yang, sayangnya, banyak yang tidak mengerti dan tidak menggunakan potensi penuh mereka). </li></ul><br><h2>  Manajemen memori </h2><br><p>  Manajemen memori umumnya layak mendapatkan artikel terpisah.  Jika dalam bahasa seperti C ++, kontrol sepenuhnya diserahkan kepada pengembang, maka dalam bahasa selanjutnya seperti DELPHI, model penghitungan referensi digunakan.  Dengan pendekatan ini, tautan siklik tidak diizinkan, karena kluster yang hilang terbentuk, maka deteksi kluster tersebut (seperti dalam C #) adalah bawaan untuk Go.  Selain itu, pengumpul sampah lebih efektif daripada kebanyakan implementasi yang dikenal saat ini dan sudah dapat digunakan untuk banyak tugas waktu nyata.  Bahasa itu sendiri mengenali situasi ketika nilai untuk menyimpan variabel dapat dialokasikan pada stack.  Ini mengurangi beban pada manajer memori dan meningkatkan kecepatan program. </p><br><h2>  Konkurensi dan Persaingan </h2><br><p>  Paralelisme dan daya saing bahasa tidak bisa dipuji.  Tidak ada bahasa tingkat rendah yang dapat bersaing jarak jauh dengan bahasa Go.  Dalam keadilan, perlu dicatat bahwa model itu tidak ditemukan oleh penulis bahasa, tetapi hanya meminjam dari bahasa ADA lama yang baik.  Bahasa ini mampu memproses jutaan koneksi paralel menggunakan semua CPU, sementara pada urutan besarnya kurang umum untuk masalah kompleks kode multithreaded dengan kebuntuan dan kondisi balapan. </p><br><h1>  Manfaat tambahan </h1><br><blockquote>  Jika ini bermanfaat, semua orang akan menjadi tidak mementingkan diri sendiri. </blockquote><p>  Bahasa ini juga memberi kita sejumlah manfaat yang tidak diragukan: </p><br><ul><li>  Satu-satunya file yang dapat dieksekusi setelah membangun proyek sangat menyederhanakan penerapan aplikasi. </li><li>  Pengetikan statis dan jenis inferensi dapat secara signifikan mengurangi jumlah kesalahan dalam kode bahkan tanpa tes menulis.  Saya tahu beberapa programmer yang tidak menulis tes sama sekali dan pada saat yang sama kualitas kode mereka tidak terlalu menderita. </li><li>  Kompilasi silang yang sangat sederhana dan portabilitas yang luar biasa dari perpustakaan standar, yang sangat menyederhanakan pengembangan aplikasi lintas platform. </li><li>  Ekspresi reguler RE2 aman untuk thread dan memiliki runtime yang dapat diprediksi. </li><li>  Pustaka standar yang kuat, yang memungkinkan sebagian besar proyek untuk dilakukan tanpa kerangka kerja pihak ketiga. </li><li>  Bahasa ini cukup kuat untuk berkonsentrasi pada masalah, dan bukan pada metode untuk menyelesaikannya, dan pada saat yang sama cukup rendah sehingga masalah dapat diselesaikan secara efisien. </li><li>  Sistem Go eco sudah berisi alat out-of-the-box untuk semua kesempatan: tes, dokumentasi, manajemen paket, linter kuat, pembuatan kode, detektor kondisi lomba, dll. </li><li>  Go versi 1.11 sekarang memiliki manajemen ketergantungan semantik bawaan yang dibangun di atas host VCS populer.  Semua alat yang membentuk ekosistem Go menggunakan layanan ini untuk mengunduh, mengkompilasi, dan menginstal kode dari mereka dalam satu gerakan.  Dan itu luar biasa.  Dengan munculnya versi 1.11, masalah dengan versi paket juga sepenuhnya terselesaikan. </li><li>  Karena ide utama bahasa adalah untuk mengurangi sihir, bahasa mendorong pengembang untuk secara eksplisit menangani penanganan kesalahan.  Dan ini benar, karena jika tidak, ia akan lupa tentang penanganan kesalahan sama sekali.  Hal lain adalah bahwa sebagian besar pengembang sengaja mengabaikan penanganan kesalahan, lebih memilih alih-alih meneruskan kesalahan daripada memprosesnya. </li><li>  Bahasa tidak menerapkan metodologi OOP klasik, karena tidak ada virtualitas dalam bentuk murni di Go.  Namun, ini bukan masalah saat menggunakan antarmuka.  Tidak adanya OOP secara signifikan mengurangi hambatan masuk untuk pemula. </li></ul><br><h1>  Kemudahan untuk Manfaat Masyarakat </h1><br><blockquote>  Merumitkan itu sederhana, menyederhanakan itu sulit. </blockquote><p>  Go dirancang agar sederhana dan unggul dalam hal itu.  Itu ditulis untuk programmer pintar yang memahami semua kebajikan dari kerja tim dan bosan dengan variabilitas tak berujung dari bahasa tingkat perusahaan.  Memiliki seperangkat konstruksi sintaksis yang relatif kecil dalam arsenalnya, secara praktis tidak mengalami perubahan dari waktu ke waktu, oleh karena itu, pengembang telah meluangkan banyak waktu khusus untuk pengembangan, dan bukan untuk studi inovasi bahasa yang tiada akhir. </p><br><p>  Perusahaan juga mendapatkan sejumlah keuntungan: ambang masuk yang rendah memungkinkan Anda menemukan spesialis dengan cepat, dan ketidakberdayaan bahasa memungkinkan Anda menggunakan kode yang sama setelah 10 tahun. </p><br><h1>  Kesimpulan </h1><br><blockquote>  Ukuran otak yang besar belum membuat seekor gajah pun menjadi penerima Hadiah Nobel. </blockquote><p>  Bagi para programmer yang egonya lebih unggul daripada semangat tim, juga para teoretikus yang menyukai tugas-tugas akademis dan "peningkatan diri" yang tak ada habisnya, bahasanya sangat buruk, karena itu adalah bahasa pengerjaan serba guna yang tidak memungkinkan untuk menerima kesenangan estetika dari hasil pekerjaan mereka dan menunjukkan diri mereka sendiri seorang profesional di depan rekan kerja (asalkan kita mengukur pikiran secara tepat dengan kriteria ini, dan bukan dengan koefisien IQ).  Seperti segala sesuatu dalam hidup, ini adalah masalah prioritas pribadi.  Seperti semua inovasi berharga, bahasa telah datang jauh dari penolakan universal ke pengakuan massa.  Bahasa itu cerdik dalam kesederhanaannya, tetapi, seperti yang Anda tahu, semua yang cerdik itu sederhana! </p><br><h1>  Ringkasan </h1><br><p>  Di antara semua kritik keras yang ditujukan pada Go, pernyataan-pernyataan berikut sangat menonjol: </p><br><ul><li>  Tidak ada obat generik.  Jika kita melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">statistik dari bahasa yang</a> paling populer, kita perhatikan bahwa setengah dari sepuluh bahasa teratas tidak memiliki generik.  Sebagian besar, obat generik hanya diperlukan dalam wadah.  Karena itu, keuntungan dari mereka tidak terlalu besar. </li><li>  Bahasa lain seperti Rust jauh lebih baik (setidaknya dalam kategori situs XXX).  Sekali lagi, jika kita melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">statistik dari bahasa yang</a> paling populer, maka kita tidak akan menemukan Karat dalam daftar sama sekali, atau itu akan berada di suatu tempat di bawah peringkat.  Secara pribadi, saya suka Rust, tetapi saya memilih Go. </li><li>  XXX memiliki roti seperti itu.  Ini adalah sisi lain dari koin kesederhanaan.  Apakah itu merugikan atau tidak, semua orang harus memutuskan.  Namun, pengembang proyek memberikan preferensi mereka demi kesederhanaan. </li><li>  Mereka akan merilis Go 2.0, maka kita akan lihat.  Posisi ini diambil oleh pengamat, bukan praktisi. </li><li>  Tidak cukup ekspresif.  Saya setuju, di beberapa bidang ekspresif timpang, tetapi secara umum itu adalah bahasa yang sederhana dan konsisten.  Selain itu, karena kemiskinan bahasa, kami terpaksa lebih memperhatikan arsitektur aplikasi yang dikembangkan, yang secara positif mempengaruhi fleksibilitasnya. </li></ul><br><p>  Sebenarnya, artikel itu tidak memikirkan keuntungan sintaksis dari bahasa Go, melainkan sebagai tinjauan singkat tentang kelebihannya untuk kerja tim dan evolusi efektif proyek yang sedang dikembangkan.  Dipahami bahwa artikel itu akan berlanjut, sehubungan dengan masalah yang lebih spesifik.  Namun, karena kurangnya minat pada topik, kemungkinan besar tidak akan ada kelanjutan. </p><br><h1>  Eksperimen </h1><br><blockquote>  Jangan percaya kata-kata - baik milik Anda maupun orang asing, tetapi percayalah pada perbuatan - baik milik Anda maupun orang asing. </blockquote><p>  <em>Bagian terakhir dimaksudkan secara eksklusif untuk kategori orang yang menganggap diri mereka optimis yang berpikiran konstruktif dan yang dapat mengkonfirmasi hal ini dengan urusan mereka sendiri.</em>  <em>Sisa audiens, silakan lewati bagian ini.</em> </p><br><p>  Eksperimen ini diinspirasi oleh teman-teman yang mengklaim bahwa semua optimis yang berpikiran konstruktif telah lama meninggalkan (setidaknya secara virtual) hamparan negara kita dan menetap, misalnya, di Stack Overflow, dan di sini sebagian besar orang sok tetap.  Untuk waktu yang lama saya tidak mempercayai mereka, jadi saya memutuskan untuk melakukan percobaan ini. <br>  Beberapa artikel dipasang di hub, hasil analisis dari komentar yang saya kutip. </p><br><ul><li>  Memang, hipotesis teman saya dikonfirmasi, namun, orang yang memadai masih ditemukan di antara pedagang asongan, meskipun persentase mereka turun dengan cepat.  Yuri Bykov menyebut orang-orang seperti itu " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bodoh</a> " yang menjadi sandaran seluruh negara.  Menurutnya, persentasenya kecil (sekitar 2%).  Saya tidak terlalu pesimis dan saya pikir ada lebih banyak dari mereka. </li><li>  Hukum media.  Informasi yang merusak jauh lebih menarik daripada informasi yang membangun. </li><li>  Psikologi orang banyak.  Ini adalah hal yang mengerikan, bahkan membuat domba yang kasar keluar dari orang yang memadai.  Seorang pria di tengah kerumunan bukan lagi seorang pria.  Tidak ada pembicaraan tentang obyektivitas.  Tidak ada argumen logis, tidak ada sumber otoritatif atau preseden tidak lagi memengaruhinya. </li><li>  Tanggung jawab dan impunitas.  Orang-orang mau mempermalukan orang lain untuk meninggikan diri mereka sendiri (setidaknya di mata mereka sendiri).  Terutama jika Anda tidak harus menjawabnya (yang bisa lebih mudah - mengklik tanda minus dan Anda bahkan tidak perlu menulis komentar).  Ada banyak kesamaan antara kata dan perbuatan seperti halnya antara saluran dan saluran pembuangan. </li><li>  Kesombongan.  Sebagian besar orang sombong siap tampil menonjol dengan cara apa pun.  Mereka tidak takut akan hambatan moral. </li><li>  Pesimisme  Tidak seperti negara-negara Barat (dan terutama Amerika), sentimen pesimistis berlaku di negara itu.  Seperti yang Anda tahu, seorang optimis mencari peluang di tengah kesulitan, dan pesimis mencari kesulitan di tengah peluang.  Di negara kita, hampir tidak ada yang memperhatikan kualitas positif dari apa pun. </li><li>  Profesionalisme dan pandangan dunia.  Kebanyakan orang memilih alat sebagai tujuan dalam diri mereka sendiri, dan bukan sebagai alat untuk mencapai tujuan.  Orang-orang lupa bagaimana bekerja dengan informasi.  Orang tidak melihat hutan di belakang pohon.  Dari berbagai informasi, mereka tidak dapat mengekstraksi pemikiran utama.  Tidak seorang pun ingin melihat dari sudut pandang yang berbeda, bukan standar untuk diri mereka sendiri.  Perbedaan pendapat ditekan.  Itu tidak diterima di sini. </li><li>  Keramahan dan hormat.  Kelompok ramah yang dipuji hanya ada dalam kata-kata.  Nilai pengembangan lincah hanya di atas kertas. </li><li>  Kemunafikan.  Anda dapat menulis artikel terpisah tentang ini secara umum. </li><li>  Prinsip  Ada orang yang mengajukan pertanyaan yang tepat: â€œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa yang saya lakukan?</a>  Namun, tidak semua orang mengerti bahwa, karena kurangnya prinsip, bagi kita, kepentingan diri sendiri yang sesaat lebih penting daripada semua prinsip kita digabungkan.  Paling mudah untuk menyalahkan segala sesuatu pada keadaan dan mengatakan bahwa tidak ada yang tergantung pada kita. </li></ul><br><p>  <strong>Dengan rasa hormat dan simpati yang mendalam kepada semua optimis yang berpikiran konstruktif.</strong> </p><br><p>  Adverax </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id448932/">https://habr.com/ru/post/id448932/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id448916/index.html">Kisi atau Flexbox?</a></li>
<li><a href="../id448918/index.html">Komponen Web: 9 proyek yang perlu diketahui pada tahun 2019</a></li>
<li><a href="../id448920/index.html">Menggunakan konsol JavaScript di browser</a></li>
<li><a href="../id448922/index.html">Kecerdasan buatan meningkatkan kualitas grafis dari video game lama dan melakukannya dengan sangat baik</a></li>
<li><a href="../id448926/index.html">10 cara untuk menghemat infrastruktur TI untuk semua orang</a></li>
<li><a href="../id448934/index.html">Tautan gratis, atau hal-hal yang dapat dilakukan sesuka Anda kepada pemilik situs</a></li>
<li><a href="../id448936/index.html">Formalisasi pidato. Beberapa pertimbangan</a></li>
<li><a href="../id448938/index.html">Di bangun dari hackathon di Nizhny Novgorod</a></li>
<li><a href="../id448940/index.html">Dell Latitude 5491: laptop perusahaan yang kokoh dengan prosesor yang kuat</a></li>
<li><a href="../id448942/index.html">Cryptocurrency: hidup atau mati?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>