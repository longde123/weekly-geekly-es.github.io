<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õπüèæ üöã üõÑ Perspektive: MultiClet S1 üßëüèø‚Äçü§ù‚Äçüßëüèæ üèæ ‚ñ´Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es ist also Zeit, √ºber die n√§chste Generation mehrzelliger Prozessoren zu sprechen: MultiClet S1. Wenn Sie zum ersten Mal davon h√∂ren, lesen Sie unbed...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perspektive: MultiClet S1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434982/"><img src="https://habrastorage.org/webt/fx/3k/yv/fx3kyvqsb8hquivzhowomntx-xe.jpeg"><br><br>  Es ist also Zeit, √ºber die n√§chste Generation mehrzelliger Prozessoren zu sprechen: MultiClet S1.  Wenn Sie zum ersten Mal davon h√∂ren, lesen Sie unbedingt die Geschichte und Ideologie der Architektur in diesen Artikeln: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Ein mehrzelliger Prozessor ist was?"</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Multiclet R1 - die ersten Tests"</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"LLVM-basierter C / C ++ - Compiler f√ºr mehrzellige Prozessoren: sein oder nicht sein?"</a> </li></ul><br>  Im Moment befindet sich der neue Prozessor in der Entwicklung, aber die ersten Ergebnisse sind bereits erschienen und Sie k√∂nnen bewerten, wozu er in der Lage sein wird. <br><a name="habracut"></a><br>  Beginnen wir mit den gr√∂√üten √Ñnderungen: Grundfunktionen. <br><br><h2>  Eigenschaften </h2><br>  Folgende Indikatoren sollen erreicht werden: <br><br><ol><li>  Anzahl der Zellen: 64 </li><li>  Technischer Prozess: 28 nm </li><li>  Taktfrequenz: 1,6 GHz </li><li>  Die Gr√∂√üe des Speichers auf dem Chip: 8 MB </li><li>  Kristallfl√§che: 40 mm <sup>2</sup> </li><li>  Leistungsaufnahme: 6 W. </li></ol><br>  Die tats√§chlichen Zahlen werden auf der Grundlage der Ergebnisse der Tests der hergestellten Muster im Jahr 2019 bekannt gegeben.  Zus√§tzlich zu den Eigenschaften des Chips selbst unterst√ºtzt der Prozessor bis zu 16 GB DDR4 3200 MHz Standard-RAM, PCI Express-Bus und PLL. <br><br>  Es sollte beachtet werden, dass der 28-nm-Herstellungsprozess der niedrigste Haushaltsbereich ist, f√ºr dessen Verwendung keine besonderen Berechtigungen erforderlich sind. Daher wurde er ausgew√§hlt.  Durch die Anzahl der Zellen wurden verschiedene Optionen in Betracht gezogen: 128 und 256, aber mit zunehmender Fl√§che des Kristalls nimmt der Prozentsatz der Ausschussprodukte zu.  Wir haben uns auf 64 Zellen und dementsprechend auf eine relativ kleine Fl√§che niedergelassen, was eine gr√∂√üere Ausbeute an geeigneten Kristallen auf der Platte ergibt.  Eine Weiterentwicklung ist im Rahmen des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ICS (System im Fall) m√∂glich</a> , wo es m√∂glich sein wird, mehrere 64-Zell-Kristalle in einem Fall zu kombinieren. <br><br>  Es muss gesagt werden, dass sich der Zweck und die Verwendung des Prozessors radikal √§ndern.  S1 wird kein Mikroprozessor sein, der wie P1 und R1 zum Einbetten ausgelegt ist, sondern ein Beschleuniger f√ºr Berechnungen.  Genau wie bei der GPGPU kann eine S1-basierte Karte in die PCI Express-Hauptplatine eines normalen PCs eingesetzt und f√ºr die Datenverarbeitung verwendet werden. <br><br><h2>  Architektur </h2><br>  In S1 ist die "Mehrfachzelle" jetzt die minimale Recheneinheit: ein Satz von 4 Zellen, die eine bestimmte Folge von Befehlen ausf√ºhren.  Zun√§chst war geplant, Multizellen zu Gruppen zu kombinieren, die als Cluster f√ºr die gemeinsame Ausf√ºhrung von Befehlen bezeichnet werden: Ein Cluster musste 4 Multizellen enthalten, insgesamt befanden sich 4 separate Cluster auf einem Kristall.  Jede Zelle hat jedoch eine vollst√§ndige Verbindung mit allen anderen Zellen im Cluster, und mit einer Zunahme der Bindungsgruppe wird sie zu stark, was das topologische Design der Mikroschaltung erheblich kompliziert und ihre Eigenschaften verringert.  Daher beschlossen sie, die Clusterteilung aufzugeben, da Komplikationen die Ergebnisse nicht rechtfertigen.  Dar√ºber hinaus ist es f√ºr maximale Leistung am vorteilhaftesten, Code auf jeder Multizelle parallel auszuf√ºhren.  Insgesamt enth√§lt der Prozessor jetzt 16 separate Mehrzellen. <br><br>  Eine Mehrzelle, obwohl sie aus 4 Zellen besteht, unterscheidet sich von einer 4-Zellen-R1, in der jede Zelle ihren eigenen Speicher, ihren eigenen Block von Beispielbefehlen und ihre eigene ALU hatte.  S1 ist etwas anders angeordnet.  ALU besteht aus 2 Teilen: einem Gleitkomma-Arithmetikblock und einem Ganzzahl-Arithmetikblock.  Jede Zelle hat einen separaten ganzzahligen Block, aber es gibt nur zwei Bl√∂cke mit einem Gleitkomma in einer Mehrzelle, und daher teilen zwei Zellenpaare sie unter sich auf.  Dies geschah haupts√§chlich, um die Fl√§che des Kristalls zu verkleinern: Die 64-Bit-Gleitkomma-Arithmetik nimmt im Gegensatz zur Ganzzahl-Arithmetik viel Platz ein.  Eine solche ALU in jeder Zelle zu haben, stellte sich als redundant heraus: Durch das Abrufen von Befehlen wird keine ALU geladen, und sie sind inaktiv.  W√§hrend die Anzahl der ALU-Bl√∂cke reduziert und das Tempo beim Abrufen von Befehlen und Daten beibehalten wird, √§ndert sich, wie die Praxis gezeigt hat, die Gesamtzeit zum L√∂sen von Problemen praktisch nicht oder nur geringf√ºgig, und ALU-Bl√∂cke sind vollst√§ndig geladen.  Au√üerdem wird Gleitkomma-Arithmetik nicht so oft verwendet wie bei Ganzzahlen. <br><br>  Eine schematische Ansicht der Prozessorbl√∂cke R1 und S1 ist in der folgenden Abbildung dargestellt.  Hier: <br><br><ul><li>  CU (Control Unit) - Befehlsabrufeinheit </li><li>  ALU <sub>FX</sub> - arithmetische Logikeinheit der Ganzzahlarithmetik </li><li>  ALU <sub>FP</sub> - Arithmetische Logikeinheit der Gleitkomma-Arithmetik </li><li>  DMS (Data Memory Scheduler) - Datenspeicher-Steuereinheit </li><li>  DM - Datenspeicher </li><li>  PMS (Program Memory Scheduler) - Programmspeichersteuerger√§t </li><li>  PM - Programmspeicher </li></ul><br><img src="https://habrastorage.org/webt/6t/4n/dp/6t4ndpu7d_koh8rpn8dmx0-b7ho.png"><br><br>  Architektonische Unterschiede S1: <br><br><ol><li>  Teams k√∂nnen jetzt auf Teamergebnisse aus vorherigen Abs√§tzen zugreifen.  Dies ist eine sehr wichtige √Ñnderung, mit der Sie die √úberg√§nge beim Verzweigen des Codes erheblich beschleunigen k√∂nnen.  Die Prozessoren P1 und R1 hatten keine andere Wahl, als die gew√ºnschten Ergebnisse in den Speicher zu schreiben und sie sofort mit den ersten Befehlen im neuen Absatz zur√ºckzulesen.  Selbst wenn Speicher auf einem Chip verwendet wird, dauern Schreib- und Lesevorg√§nge jeweils 2 bis 5 Zyklen, die durch einfaches Verweisen auf das Ergebnis des Befehls aus dem vorherigen Absatz gespeichert werden k√∂nnen </li><li>  Das Schreiben in den Speicher und in die Register erfolgt jetzt sofort und nicht mehr am Ende eines Absatzes, sodass Sie vor dem Ende des Absatzes mit dem Schreiben von Befehlen beginnen k√∂nnen.  Dadurch wird die potenzielle Ausfallzeit zwischen Abs√§tzen reduziert. </li><li>  Das Befehlssystem wurde optimiert, n√§mlich: <br><ul><li>  64-Bit-Ganzzahlarithmetik hinzugef√ºgt: Addition, Subtraktion, Multiplikation von 32-Bit-Zahlen, wodurch ein 64-Bit-Ergebnis zur√ºckgegeben wird. </li><li>  Die Methode zum Lesen aus dem Speicher wurde ge√§ndert: Jetzt k√∂nnen Sie f√ºr <b>jeden</b> Befehl einfach die Adresse angeben, von der Sie Daten als Argument lesen m√∂chten, w√§hrend die Reihenfolge der Lese- und Schreibbefehle beibehalten wird. <br><br>  Au√üerdem wurde ein separater Speicherlesebefehl √ºberfl√ºssig.  Stattdessen wird der Befehl load value im Ladeschalter verwendet (zuvor <b>get</b> ), wobei die Adresse im Speicher als Argument angegeben wird: <br><br><pre><code class="plaintext hljs">.data foo: .long 0x1234 .text habr: load_l foo ;      foo load_l [foo] ;    0x1234 add_l [foo], 0xABCD ;       ;   complete</code> </pre> <br></li><li>  Es wurde ein Befehlsformat hinzugef√ºgt, das die Verwendung von 2 konstanten Argumenten erm√∂glicht. <br>  Bisher konnten Sie eine Konstante nur als zweites Argument angeben. Das erste Argument sollte immer eine Verkn√ºpfung zum Ergebnis im Switch sein.  Die √Ñnderung gilt f√ºr alle Teams mit zwei Argumenten.  Das Konstantenfeld ist immer 32 Bit, so dass dieses Format beispielsweise das Generieren von 64-Bit-Konstanten mit einem Befehl erm√∂glicht. <br><br>  Es war: <br><br><pre> <code class="plaintext hljs">load_l 0x12345678 patch_q @1, 0xDEADBEEF</code> </pre><br>  Es wurde: <br><br><pre> <code class="plaintext hljs">patch_q 0x12345678, 0xDEADBEEF</code> </pre> <br></li><li>  Ge√§nderte und erg√§nzte Vektordatentypen. <br>  Was fr√ºher als "gepackte" Datentypen bezeichnet wurde, kann jetzt sicher als vektoriell bezeichnet werden.  In P1 und R1 nahmen Operationen an gepackten Zahlen nur eine Konstante als zweites Argument an, d. H. Zum Beispiel wurde beim Hinzuf√ºgen jedes Element des Vektors mit derselben Zahl hinzugef√ºgt, und dies konnte nicht intelligent angewendet werden.  Nun k√∂nnen √§hnliche Operationen auf zwei vollst√§ndige Vektoren angewendet werden.  Dar√ºber hinaus stimmt diese Art der Arbeit mit Vektoren vollst√§ndig mit dem Mechanismus der Vektoren in LLVM √ºberein, der es dem Compiler nun erm√∂glicht, Code unter Verwendung von Vektortypen zu generieren. <br><br><pre> <code class="plaintext hljs">patch_q 0x00010002, 0x00030004 patch_q 0x00020003, 0x00040005 mul_ps @1, @2 ;  - 00020006000C0014</code> </pre><br></li></ul><br></li><li>  Prozessorflags entfernt. <br><br>  Infolgedessen wurden ungef√§hr 40 Teams entfernt, die ausschlie√ülich auf den Werten der Flaggen basierten.  Dies hat die Anzahl der Teams und dementsprechend die Fl√§che des Kristalls erheblich reduziert.  Und alle notwendigen Informationen werden jetzt direkt in der Schaltzelle gespeichert. <br><br><ul><li>  Beim Vergleich mit Null wird anstelle des Null-Flags nur noch der Wert im Schalter verwendet </li><li>  Anstelle des Vorzeichen-Flags wird jetzt ein Bit verwendet, das dem Befehlstyp entspricht: 7. f√ºr Byte, 15. f√ºr kurz, 31. f√ºr lang, 63. f√ºr Quad.  Aufgrund der Tatsache, dass das Zeichen unabh√§ngig vom Typ bis zum 63. Bit multipliziert wird, k√∂nnen Sie Zahlen verschiedener Typen vergleichen: <br><br><pre> <code class="plaintext hljs">.data long: .long -0x1000 byte: .byte -0x10 .text habr: a := load_b [byte] ;     0xFFFFFFFFFFFFFFF0, ;   byte 7    63. b := loadu_b [byte] ;     0x00000000000000F0, ; ..  loadu_b    c := load_l [long] ;     0xFFFFFFFFFFFFF000. ge_l @a, @c ;   "  "  1: ;   31 ,   . lt_s @a, @b ; 1, .. b     complete</code> </pre><br></li><li>  Das √úbertragsflag wird nicht mehr ben√∂tigt, da es eine 64-Bit-Arithmetik gibt </li></ul><br></li><li>  Die √úbergangszeit von Absatz zu Absatz wurde auf 1 Takt reduziert (anstelle von 2-3 in R1). </li></ol><br><h2>  LLVM-basierter Compiler </h2><br>  Der C-Sprach-Compiler f√ºr S1 √§hnelt R1, und da sich die Architektur nicht grundlegend ge√§ndert hat, sind die im vorherigen Artikel beschriebenen Probleme leider nicht verschwunden. <br><br>  Bei der Implementierung des neuen Befehlssystems verringerte sich jedoch die Menge des Ausgabecodes von selbst, einfach aufgrund der Aktualisierung des Befehlssystems.  Dar√ºber hinaus gibt es viele weitere kleinere Optimierungen, die die Anzahl der Befehle im Code verringern, von denen einige bereits ausgef√ºhrt wurden (z. B. Generieren von 64-Bit-Konstanten mit einem einzigen Befehl).  Es m√ºssen jedoch noch ernsthaftere Optimierungen vorgenommen werden, die in aufsteigender Reihenfolge sowohl hinsichtlich der Effizienz als auch der Komplexit√§t der Implementierung erstellt werden k√∂nnen: <br><br><ol><li>  Die F√§higkeit, alle Befehle mit zwei Argumenten mit zwei Konstanten zu generieren. <br><br>  Das Generieren einer 64-Bit-Konstante √ºber patch_q ist nur ein Sonderfall, aber wir brauchen einen allgemeinen.  Tats√§chlich besteht der Zweck dieser Optimierung darin, den Teams zu erm√∂glichen, nur das erste Argument als Konstante zu ersetzen, da das zweite Argument immer eine Konstante sein kann, und dies ist seit langem implementiert.  Dies ist kein sehr h√§ufiger Fall, aber wenn Sie beispielsweise eine Funktion aufrufen und die R√ºcksprungadresse von dort oben in den Stapel schreiben m√ºssen, k√∂nnen Sie dies tun <br><br><pre> <code class="plaintext hljs">load_l func wr_l @1, #SP</code> </pre><br>  optimieren auf <br><br><pre> <code class="plaintext hljs">wr_l func, #SP</code> </pre><br></li><li>  Die M√∂glichkeit, den Speicherzugriff durch ein Argument in einem beliebigen Befehl zu ersetzen. <br>  Wenn Sie beispielsweise zwei Zahlen aus dem Speicher hinzuf√ºgen m√ºssen, k√∂nnen Sie dies tun <br><br><pre> <code class="plaintext hljs">load_l [foo] load_l [bar] add_l @1, @2</code> </pre><br>  optimieren auf <br><br><pre> <code class="plaintext hljs">add_l [foo], [bar]</code> </pre><br>  Diese Optimierung ist eine Erweiterung der vorherigen, hier ist jedoch bereits eine Analyse erforderlich: Ein solcher Austausch kann nur durchgef√ºhrt werden, wenn die geladenen Werte in diesem Additionsbefehl nur einmal und nirgendwo anders verwendet werden.  Wenn das Leseergebnis auch nur in zwei Befehlen verwendet wird, ist es rentabler, einmal als separaten Befehl aus dem Speicher zu lesen und in den anderen beiden √ºber den Schalter darauf zu verweisen. <br></li><li>  Optimierung der √úbertragung virtueller Register zwischen Basiseinheiten. <br>  F√ºr R1 erfolgte die √úbertragung aller virtuellen Register √ºber den Speicher, was zu einer sehr gro√üen Anzahl von Lese- und Schreibvorg√§ngen im Speicher f√ºhrt, aber es gab einfach keine andere M√∂glichkeit, Daten zwischen Abs√§tzen zu √ºbertragen.  Mit S1 k√∂nnen Sie auf die Ergebnisse der Befehle der vorherigen Abs√§tze zugreifen. Daher k√∂nnen theoretisch viele Speicheroperationen entfernt werden, was den gr√∂√üten Effekt unter allen Optimierungen erzielen w√ºrde.  Dieser Ansatz ist jedoch immer noch durch den Wechsel begrenzt: Es k√∂nnen bisher nicht mehr als 63 vorherige Ergebnisse von jeder √úbertragung des virtuellen Registers auf diese Weise implementiert werden.  Wie dies zu tun ist, ist keine triviale Aufgabe, und eine Analyse der L√∂sungsm√∂glichkeiten muss noch durchgef√ºhrt werden.  Die Compilerquellen werden m√∂glicherweise gemeinfrei angezeigt. Wenn also jemand Ideen hat und Sie sich an der Entwicklung beteiligen m√∂chten, k√∂nnen Sie dies tun. <br></li></ol><br><h2>  Benchmarks </h2><br>  Da der Prozessor noch nicht auf dem Chip freigegeben wurde, ist es schwierig, seine tats√§chliche Leistung zu beurteilen.  Der RTL-Kernel-Code ist jedoch bereits bereit, sodass Sie eine Bewertung mithilfe von Simulation oder FPGA vornehmen k√∂nnen.  Um die folgenden Benchmarks auszuf√ºhren, haben wir eine Simulation mit dem ModelSim-Programm verwendet, um die genaue Ausf√ºhrungszeit (in Ma√üen) zu berechnen.  Da es schwierig ist, den gesamten Kristall zu simulieren, und dies sehr lange dauert, wurde eine Mehrfachzelle simuliert und das Ergebnis mit 16 multipliziert (wenn die Aufgabe f√ºr Multithreading ausgelegt ist), da jede Mehrfachzelle v√∂llig unabh√§ngig von den anderen arbeiten kann. <br><br>  Gleichzeitig wurde auf Xilinx Virtex-6 eine Mehrzellenmodellierung durchgef√ºhrt, um die Leistung von Prozessorcode auf realer Hardware zu testen. <br><br><h4>  Coremark </h4><br>  CoreMark - eine Reihe von Tests zur umfassenden Bewertung der Leistung von Mikrocontrollern und Zentralprozessoren sowie deren C-Compilern.  Wie Sie sehen k√∂nnen, ist der S1-Prozessor weder der eine noch der andere.  Es ist jedoch beabsichtigt, absolut Arbitrierungscode auszuf√ºhren, d.h.  Jeder, der auf dem Zentralprozessor ausgef√ºhrt werden k√∂nnte.  CoreMark eignet sich also zur Bewertung der Leistung von S1 nicht schlechter. <br><br>  CoreMark enth√§lt Arbeiten mit verkn√ºpften Listen, Matrizen, einer Zustandsmaschine und einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CRC-</a> Summenberechnung.  Im Allgemeinen stellt sich heraus, dass der gr√∂√üte Teil des Codes streng sequentiell ist (wodurch die mehrzellige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hardware-Parallelit√§t</a> auf St√§rke getestet wird) und viele Zweige aufweist, weshalb die Compiler-Funktionen eine wichtige Rolle f√ºr die endg√ºltige Leistung spielen.  Der kompilierte Code enth√§lt einige kurze Abs√§tze, und trotz der Tatsache, dass die √úbergangsgeschwindigkeit zwischen ihnen zugenommen hat, umfasst die Verzweigung die Arbeit mit dem Speicher, die wir maximal vermeiden m√∂chten. <br><br>  CoreMark-Scorecard: <br><table><tbody><tr><th></th><th>  Multiclet R1 (llvm-Compiler) </th><th>  <b>Multiclet S1 (llvm-Compiler)</b> </th><th>  Elbrus-4C (R500 / E) </th><th>  Texas Inst.  AM5728 ARM Cortex-A15 </th><th>  Baikal-t1 </th><th>  Intel Core i7 7700K </th></tr><tr><td>  Baujahr </td><td>  2015 </td><td>  <b>2019</b> </td><td>  2014 </td><td>  2018 </td><td>  2016 </td><td>  2017 </td></tr><tr><td>  Taktfrequenz, MHz </td><td>  100 </td><td>  <b>1600</b> </td><td>  700 </td><td>  1500 </td><td>  1200 </td><td>  4500 </td></tr><tr><td>  CoreMark Gesamtpunktzahl </td><td>  59 </td><td>  <b>18356</b> </td><td>  1214 </td><td>  15789 </td><td>  13142 </td><td>  182128 </td></tr><tr><td>  Coremark / MHz </td><td>  0,59 </td><td>  <b>11.47</b> </td><td>  5.05 </td><td>  10.53 </td><td>  10,95 </td><td>  40,47 </td></tr></tbody></table><br>  Das Ergebnis einer Mehrfachzelle ist 1147 oder 0,72 / MHz, was h√∂her als das von R1 ist.  Dies spricht f√ºr die Vorteile der Entwicklung einer mehrzelligen Architektur im neuen Prozessor. <br><br><h4>  Weizenstein </h4><br>  Schleifstein - eine Reihe von Tests zur Messung der Prozessorleistung bei der Arbeit mit Gleitkommazahlen.  Hier ist die Situation viel besser: Der Code ist ebenfalls sequentiell, jedoch ohne gro√üe Anzahl von Zweigen und mit guter interner Parallelit√§t. <br><br>  Whetstone besteht aus vielen Modulen, mit denen Sie nicht nur das Gesamtergebnis, sondern auch die Leistung f√ºr jedes einzelne Modul messen k√∂nnen: <br><br><ol><li>  Array-Elemente </li><li>  Array als Parameter </li><li>  Bedingte Spr√ºnge </li><li>  Ganzzahlige Arithmetik </li><li>  Trigonometrische Funktionen (tan, sin, cos) </li><li>  Prozeduraufrufe </li><li>  Array-Referenzen </li><li>  Standardfunktionen (sqrt, exp, log) </li></ol><br>  Sie sind in Kategorien unterteilt: Die Module 1, 2 und 6 messen die Leistung von Gleitkommaoperationen (Zeilen MFLOPS1-3);  Module 5 und 8 - mathematische Funktionen (COS MOPS, EXP MOPS);  Module 4 und 7 - Ganzzahlarithmetik (FIXPT MOPS, EQUAL MOPS);  Modul 3 - Bedingte Spr√ºnge (IF MOPS).  In der folgenden Tabelle ist die zweite Zeile von MWIPS ein allgemeiner Indikator. <br><br>  Im Gegensatz zu CoreMark wird Whetstone auf einem Kern oder, wie in unserem Fall, auf einer Mehrzelle verglichen.  Da die Anzahl der Kerne in verschiedenen Prozessoren sehr unterschiedlich ist, betrachten wir f√ºr die Reinheit des Experiments die Indikatoren pro Megahertz. <br><br>  Wetzstein-Scorecard: <br><table><tbody><tr><th>  CPU </th><th>  MultiClet R1 </th><th>  <b>MultiClet S1</b> </th><th>  Core i7 4820K </th><th>  ARM v8-A53 </th></tr><tr><td>  Frequenz, MHz </td><td>  100 </td><td>  <b>1600</b> </td><td>  3900 </td><td>  1300 </td></tr><tr><td>  MWIPS / MHz </td><td>  0,311 </td><td>  <b>0,343</b> </td><td>  0,887 </td><td>  0,642 </td></tr><tr><td>  MFLOPS1 / MHz </td><td>  0,157 </td><td>  <b>0,156</b> </td><td>  0,341 </td><td>  0,268 </td></tr><tr><td>  MFLOPS2 / MHz </td><td>  0,153 </td><td>  <b>0,111</b> </td><td>  0,308 </td><td>  0,241 </td></tr><tr><td>  MFLOPS3 / MHz </td><td>  0,029 </td><td>  <b>0,124</b> </td><td>  0,167 </td><td>  0,239 </td></tr><tr><td>  COS MOPS / MHz </td><td>  0,018 </td><td>  <b>0,008</b> </td><td>  0,023 </td><td>  0,028 </td></tr><tr><td>  EXP MOPS / MHz </td><td>  0,008 </td><td>  <b>0,005</b> </td><td>  0,014 </td><td>  0,004 </td></tr><tr><td>  FIXPT MOPS / MHz </td><td>  0,714 </td><td>  <b>0,116</b> </td><td>  0,998 </td><td>  1.197 </td></tr><tr><td>  WENN MOPS / MHz </td><td>  0,081 </td><td>  <b>0,196</b> </td><td>  1,504 </td><td>  1.436 </td></tr><tr><td>  GLEICHE MOPS / MHz </td><td>  0,143 </td><td>  <b>0,149</b> </td><td>  0,251 </td><td>  0,439 </td></tr></tbody></table><br>  Whetstone enth√§lt viel direktere Rechenoperationen als CoreMark (was sich im folgenden Code sehr bemerkbar macht). Daher ist es wichtig, sich hier daran zu erinnern: Die Anzahl der Gleitkomma-ALUs wird halbiert.  Die Rechengeschwindigkeit wurde jedoch im Vergleich zu R1 fast nicht beeinflusst. <br><br>  Einige Module passen sehr gut zu einer mehrzelligen Architektur.  Zum Beispiel z√§hlt Modul 2 viele Werte in einem Zyklus, und dank der vollst√§ndigen Unterst√ºtzung von Gleitkommazahlen mit doppelter Genauigkeit durch den Prozessor und den Compiler erhalten wir nach der Kompilierung gro√üe und sch√∂ne Abs√§tze, die die Rechenf√§higkeiten einer mehrzelligen Architektur wirklich offenbaren: <br><br><div class="spoiler">  <b class="spoiler_title">Gro√üer und sch√∂ner Absatz f√ºr 120 Teams</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">pa: SR4 := loadu_q [#SP + 16] SR5 := loadu_q [#SP + 8] SR6 := loadu_l [#SP + 4] SR7 := loadu_l [#SP] setjf_l @0, @SR7 SR8 := add_l @SR6, 0x8 SR9 := add_l @SR6, 0x10 SR10 := add_l @SR6, 0x18 SR11 := loadu_q [@SR6] SR12 := loadu_q [@SR8] SR13 := loadu_q [@SR9] SR14 := loadu_q [@SR10] SR15 := add_d @SR11, @SR12 SR11 := add_d @SR15, @SR13 SR15 := sub_d @SR11, @SR14 SR11 := mul_d @SR15, @SR5 SR15 := add_d @SR12, @SR11 SR12 := sub_d @SR15, @SR13 SR15 := add_d @SR14, @SR12 SR12 := mul_d @SR15, @SR5 SR15 := sub_d @SR11, @SR12 SR16 := sub_d @SR12, @SR11 SR17 := add_d @SR11, @SR12 SR11 := add_d @SR13, @SR15 SR13 := add_d @SR14, @SR11 SR11 := mul_d @SR13, @SR5 SR13 := add_d @SR16, @SR11 SR15 := add_d @SR17, @SR11 SR16 := add_d @SR14, @SR13 SR13 := div_d @SR16, @SR4 SR14 := sub_d @SR15, @SR13 SR15 := mul_d @SR14, @SR5 SR14 := add_d @SR12, @SR15 SR12 := sub_d @SR14, @SR11 SR14 := add_d @SR13, @SR12 SR12 := mul_d @SR14, @SR5 SR14 := sub_d @SR15, @SR12 SR16 := sub_d @SR12, @SR15 SR17 := add_d @SR15, @SR12 SR15 := add_d @SR11, @SR14 SR11 := add_d @SR13, @SR15 SR14 := mul_d @SR11, @SR5 SR11 := add_d @SR16, @SR14 SR15 := add_d @SR17, @SR14 SR16 := add_d @SR13, @SR11 SR11 := div_d @SR16, @SR4 SR13 := sub_d @SR15, @SR11 SR15 := mul_d @SR13, @SR5 SR13 := add_d @SR12, @SR15 SR12 := sub_d @SR13, @SR14 SR13 := add_d @SR11, @SR12 SR12 := mul_d @SR13, @SR5 SR13 := sub_d @SR15, @SR12 SR16 := sub_d @SR12, @SR15 SR17 := add_d @SR15, @SR12 SR15 := add_d @SR14, @SR13 SR13 := add_d @SR11, @SR15 SR14 := mul_d @SR13, @SR5 SR13 := add_d @SR16, @SR14 SR15 := add_d @SR17, @SR14 SR16 := add_d @SR11, @SR13 SR11 := div_d @SR16, @SR4 SR13 := sub_d @SR15, @SR11 SR4 := loadu_q @SR4 SR5 := loadu_q @SR5 SR6 := loadu_q @SR6 SR7 := loadu_q @SR7 SR15 := mul_d @SR13, @SR5 SR8 := loadu_q @SR8 SR9 := loadu_q @SR9 SR10 := loadu_q @SR10 SR13 := add_d @SR12, @SR15 SR12 := sub_d @SR13, @SR14 SR13 := add_d @SR11, @SR12 SR12 := mul_d @SR13, @SR5 SR13 := sub_d @SR15, @SR12 SR16 := sub_d @SR12, @SR15 SR17 := add_d @SR15, @SR12 SR15 := add_d @SR14, @SR13 SR13 := add_d @SR11, @SR15 SR14 := mul_d @SR13, @SR5 SR13 := add_d @SR16, @SR14 SR15 := add_d @SR17, @SR14 SR16 := add_d @SR11, @SR13 SR11 := div_d @SR16, @SR4 SR13 := sub_d @SR15, @SR11 SR15 := mul_d @SR13, @SR5 SR13 := add_d @SR12, @SR15 SR12 := sub_d @SR13, @SR14 SR13 := add_d @SR11, @SR12 SR12 := mul_d @SR13, @SR5 SR13 := sub_d @SR15, @SR12 SR16 := sub_d @SR12, @SR15 SR17 := add_d @SR15, @SR12 SR15 := add_d @SR14, @SR13 SR13 := add_d @SR11, @SR15 SR14 := mul_d @SR13, @SR5 SR13 := add_d @SR16, @SR14 SR15 := add_d @SR17, @SR14 SR16 := add_d @SR11, @SR13 SR11 := div_d @SR16, @SR4 SR13 := sub_d @SR15, @SR11 SR15 := mul_d @SR13, @SR5 SR13 := add_d @SR12, @SR15 SR12 := sub_d @SR13, @SR14 SR13 := add_d @SR11, @SR12 SR12 := mul_d @SR13, @SR5 SR13 := sub_d @SR15, @SR12 SR16 := sub_d @SR12, @SR15 SR17 := add_d @SR14, @SR13 SR13 := add_d @SR11, @SR17 SR14 := mul_d @SR13, @SR5 SR5 := add_d @SR16, @SR14 SR13 := add_d @SR11, @SR5 SR5 := div_d @SR13, @SR4 wr_q @SR15, @SR6 wr_q @SR12, @SR8 wr_q @SR14, @SR9 wr_q @SR5, @SR10 complete</code> </pre><br></div></div><br><h4>  popcnt </h4><br>  Um die Eigenschaften der Architektur selbst (unabh√§ngig vom Compiler) widerzuspiegeln, messen wir etwas, das in Assembler geschrieben wurde, unter Ber√ºcksichtigung aller Merkmale der Architektur.  Zum Beispiel das Z√§hlen von Einheitsbits in einer 512-Bit-Zahl (popcnt).  Zur Verdeutlichung werden wir die Ergebnisse einer Mehrzelle nehmen, damit sie mit R1 verglichen werden k√∂nnen. <br><br>  Vergleichstabelle, Anzahl der Taktzyklen pro 32-Bit-Berechnungszyklus: <br><table><tbody><tr><th>  Algorithmus </th><th>  Multiclet r1 </th><th>  Multiclet S1 (eine Multizelle) </th></tr><tr><td>  Bithacks </td><td>  5.0 </td><td>  2,625 </td></tr></tbody></table><br>  Hier wurden neue aktualisierte Vektoranweisungen verwendet, die es uns erm√∂glichten, die Anzahl der Anweisungen im Vergleich zu demselben in R1-Assembler implementierten Algorithmus zu halbieren.  Die Arbeitsgeschwindigkeit erh√∂hte sich jeweils um fast das Zweifache. <br><br><div class="spoiler">  <b class="spoiler_title">popcnt</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">bithacks: b0 := patch_q 0x1, 0x1 v0 := loadu_q [v] v1 := loadu_q [v+8] v2 := loadu_q [v+16] v3 := loadu_q [v+24] v4 := loadu_q [v+32] v5 := loadu_q [v+40] v6 := loadu_q [v+48] v7 := loadu_q [v+56] b1 := patch_q 0x55555555, 0x55555555 i00 := slr_pl @v0, @b0 i01 := slr_pl @v1, @b0 i02 := slr_pl @v2, @b0 i03 := slr_pl @v3, @b0 i04 := slr_pl @v4, @b0 i05 := slr_pl @v5, @b0 i06 := slr_pl @v6, @b0 i07 := slr_pl @v7, @b0 b2 := patch_q 0x33333333, 0x33333333 i10 := and_q @i00, @b1 i11 := and_q @i01, @b1 i12 := and_q @i02, @b1 i13 := and_q @i03, @b1 i14 := and_q @i04, @b1 i15 := and_q @i05, @b1 i16 := and_q @i06, @b1 i17 := and_q @i07, @b1 b3 := patch_q 0x2, 0x2 i20 := sub_pl @v0, @i10 i21 := sub_pl @v1, @i11 i22 := sub_pl @v2, @i12 i23 := sub_pl @v3, @i13 i24 := sub_pl @v4, @i14 i25 := sub_pl @v5, @i15 i26 := sub_pl @v6, @i16 i27 := sub_pl @v7, @i17 i30 := and_q @i20, @b2 i31 := and_q @i21, @b2 i32 := and_q @i22, @b2 i33 := and_q @i23, @b2 i34 := and_q @i24, @b2 i35 := and_q @i25, @b2 i36 := and_q @i26, @b2 i37 := and_q @i27, @b2 i40 := slr_pl @i20, @b3 i41 := slr_pl @i21, @b3 i42 := slr_pl @i22, @b3 i43 := slr_pl @i23, @b3 i44 := slr_pl @i24, @b3 i45 := slr_pl @i25, @b3 i46 := slr_pl @i26, @b3 i47 := slr_pl @i27, @b3 b4 := patch_q 0x4, 0x4 i50 := and_q @i40, @b2 i51 := and_q @i41, @b2 i52 := and_q @i42, @b2 i53 := and_q @i43, @b2 i54 := and_q @i44, @b2 i55 := and_q @i45, @b2 i56 := and_q @i46, @b2 i57 := and_q @i47, @b2 i60 := add_pl @i50, @i30 i61 := add_pl @i51, @i31 i62 := add_pl @i52, @i32 i63 := add_pl @i53, @i33 i64 := add_pl @i54, @i34 i65 := add_pl @i55, @i35 i66 := add_pl @i56, @i36 i67 := add_pl @i57, @i37 b5 := patch_q 0xf0f0f0f, 0xf0f0f0f i70 := slr_pl @i60, @b4 i71 := slr_pl @i61, @b4 i72 := slr_pl @i62, @b4 i73 := slr_pl @i63, @b4 i74 := slr_pl @i64, @b4 i75 := slr_pl @i65, @b4 i76 := slr_pl @i66, @b4 i77 := slr_pl @i67, @b4 b6 := patch_q 0x1010101, 0x1010101 i80 := add_pl @i70, @i60 i81 := add_pl @i71, @i61 i82 := add_pl @i72, @i62 i83 := add_pl @i73, @i63 i84 := add_pl @i74, @i64 i85 := add_pl @i75, @i65 i86 := add_pl @i76, @i66 i87 := add_pl @i77, @i67 b7 := patch_q 0x18, 0x18 i90 := and_q @i80, @b5 i91 := and_q @i81, @b5 i92 := and_q @i82, @b5 i93 := and_q @i83, @b5 i94 := and_q @i84, @b5 i95 := and_q @i85, @b5 i96 := and_q @i86, @b5 i97 := and_q @i87, @b5 iA0 := mul_pl @i90, @b6 iA1 := mul_pl @i91, @b6 iA2 := mul_pl @i92, @b6 iA3 := mul_pl @i93, @b6 iA4 := mul_pl @i94, @b6 iA5 := mul_pl @i95, @b6 iA6 := mul_pl @i96, @b6 iA7 := mul_pl @i97, @b6 iB0 := slr_pl @iA0, @b7 iB1 := slr_pl @iA1, @b7 iB2 := slr_pl @iA2, @b7 iB3 := slr_pl @iA3, @b7 iB4 := slr_pl @iA4, @b7 iB5 := slr_pl @iA5, @b7 iB6 := slr_pl @iA6, @b7 iB7 := slr_pl @iA7, @b7 wr_q @iB0, c wr_q @iB1, c+8 wr_q @iB2, c+16 wr_q @iB3, c+24 wr_q @iB4, c+32 wr_q @iB5, c+40 wr_q @iB6, c+48 wr_q @iB7, c+56 complete</code> </pre><br></div></div><br><h4>  Ethereum </h4><br>  Benchmarks sind nat√ºrlich gut, aber wir haben eine bestimmte Aufgabe: einen Berechnungsbeschleuniger zu erstellen, und es w√§re sch√∂n zu wissen, wie er mit realen Aufgaben umgeht.  Moderne Kryptow√§hrungen eignen sich am besten f√ºr eine solche √úberpr√ºfung, da Mining-Algorithmen auf vielen verschiedenen Ger√§ten ausgef√ºhrt werden und daher als Vergleichsma√üstab dienen k√∂nnen.  Wir haben mit Ethereum und dem Ethash-Algorithmus begonnen, der direkt auf dem Mining-Ger√§t ausgef√ºhrt wird. <br><br>  Ethereum wurde aus folgenden Gr√ºnden ausgew√§hlt.  Wie Sie wissen, werden Algorithmen wie Bitcoin von spezialisierten ASIC-Chips sehr effizient implementiert, sodass die Verwendung von Prozessoren oder Grafikkarten zum Mining von Bitcoin und seinen Klonen aufgrund der geringen Leistung und des hohen Stromverbrauchs wirtschaftlich nachteilig wird.  Um dieser Situation zu entkommen, entwickelt die Bergarbeitergemeinschaft Kryptow√§hrungen nach anderen algorithmischen Prinzipien, wobei der Schwerpunkt auf der Entwicklung von Algorithmen liegt, die Allzweckprozessoren oder Grafikkarten f√ºr das Bergbau verwenden.  Dieser Trend d√ºrfte sich auch in Zukunft fortsetzen.  Ethereum ist die bekannteste Kryptow√§hrung, die auf diesem Ansatz basiert.  Das Hauptwerkzeug f√ºr den Abbau von Ethereum sind Grafikkarten, die in Bezug auf die Effizienz (Hashrate / TDP) den Mehrzweckprozessoren deutlich (mehrmals) voraus sind. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ethash</a> ist ein sogenannter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">speichergebundener</a> Algorithmus, d.h.  Die Berechnungszeit wird haupts√§chlich durch die Gr√∂√üe und Geschwindigkeit des Speichers und nicht durch die Geschwindigkeit der Berechnungen selbst begrenzt.  F√ºr das Ethereum-Mining sind Grafikkarten am besten geeignet, aber ihre F√§higkeit, viele Vorg√§nge gleichzeitig auszuf√ºhren, hilft nicht viel, und sie beruhen immer noch auf der Geschwindigkeit des Arbeitsspeichers, die in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Artikel</a> deutlich gezeigt wird.  Von dort aus k√∂nnen Sie ein Bild aufnehmen, das die Funktionsweise des Algorithmus veranschaulicht, um zu erkl√§ren, warum dies geschieht. <br><br><img src="https://habrastorage.org/webt/y-/gg/t5/y-ggt5p2hd3w2vn1hzddmhwmq3u.png"><br><br>  Der Artikel unterteilt den Algorithmus in 6 Punkte, aber 3 Stufen k√∂nnen f√ºr noch mehr Klarheit unterschieden werden: <br><br><ol><li>  Start: SHA-3 (512) zur Berechnung des urspr√ºnglichen 128-Byte-Mix 0 (Punkt 1) </li><li>  64-fache Neuberechnung des Mix-Arrays durch Lesen der n√§chsten 128 Bytes und Mischen mit den vorherigen √ºber die Mischfunktion f√ºr insgesamt 8 Kilobyte (Abs√§tze 2-4) </li><li>  Finalisierung und √úberpr√ºfung des Ergebnisses </li></ol><br>  Das Lesen von zuf√§lligen 128 Bytes aus dem RAM dauert viel l√§nger als es scheint.  Wenn Sie die MSI RX 470-Grafikkarte mit 2048 Computerger√§ten und einer maximalen Speicherbandbreite von 211,2 GB / s verwenden, ben√∂tigen Sie f√ºr die Ausstattung jedes Ger√§ts 1 / (211,2 GB / (128 b * 2048)) = 1241 ns oder etwa 1496 Zyklen mit einer bestimmten Frequenz.  Angesichts der Gr√∂√üe der Mischfunktion k√∂nnen wir davon ausgehen, dass das Lesen des Speichers von einer Grafikkarte um ein Vielfaches l√§nger dauert als das Neuberechnen der empfangenen Informationen.  Infolgedessen nimmt Stufe 2 des Algorithmus viel Zeit in Anspruch, viel l√§nger als die Stufen 1 und 3, die letztendlich nur geringe Auswirkungen auf die Leistung haben, obwohl sie mehr Berechnungen enthalten (haupts√§chlich in SHA-3).  Sie k√∂nnen sich nur die Hashrate dieser Grafikkarte ansehen: 26.375 Megaschritzen / s theoretisch (nur durch die Speicherbandbreite begrenzt) gegen√ºber 24 Megachehes / s tats√§chlich, dh die Stufen 1 und 3 ben√∂tigen nur 10% der Zeit. <br><br>  Auf S1 k√∂nnen alle 16 Multizellen parallel und mit unterschiedlichem Code arbeiten.  Zus√§tzlich wird Zweikanal-RAM entlang eines Kanals f√ºr 8 Mehrzellen installiert.  In Stufe 2 des Ethash-Algorithmus sieht unser Plan wie folgt aus: Eine Mehrfachzelle liest 128 Bytes aus dem Speicher und beginnt, sie neu zu z√§hlen, dann liest die n√§chste den Speicher und z√§hlt neu und so weiter bis zum 8., d. H.  Eine Mehrfachzelle hat nach dem Lesen von 128 Byte Speicher 7 * [Lesezeit von 128 Byte], um das Array neu zu berechnen.  Es wird angenommen, dass ein solcher Messwert 16 Zyklen dauert, d.h.  112 Ma√ünahmen werden zur Nachz√§hlung angegeben.  Die Berechnung der Mischfunktion dauert ungef√§hr den gleichen Taktzyklus, sodass S1 nahe am idealen Verh√§ltnis von Speicherbandbreite zu Prozessorleistung liegt.  Da in der zweiten Stufe keine Zeit verschwendet wird, sollten die verbleibenden Teile des Algorithmus so weit wie m√∂glich optimiert werden, da sie sich dann wirklich auf die Leistung auswirken. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Rechengeschwindigkeit SHA-3 (Keccak) zu bewerten, wurde ein C-Programm entwickelt und getestet, auf dessen Grundlage derzeit die optimale Version im Assembler erstellt wird. </font><font style="vertical-align: inherit;">Die Auswertungsprogrammierung zeigt, dass eine Mehrzelle eine SHA-3 (Keccak) -Berechnung in 1550 Taktzyklen durchf√ºhrt. </font><font style="vertical-align: inherit;">Daher betr√§gt die Gesamtzeit f√ºr die Berechnung eines Hashs pro Multizelle 1550 + 64 * (16 + 112) = 9742 Zyklen. </font><font style="vertical-align: inherit;">Bei einer Frequenz von 1,6 GHz und 16 parallelen Mehrfachzellen betr√§gt die Hash-Rate des Prozessors 2,6 MHash / s.</font></font><br><br><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beschleuniger </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MultiClet S1 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NVIDIA GeForce GTX 980 Ti </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Radeon RX 470 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Radeon RX Vega 64 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NVIDIA GeForce GTX 1060 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NVIDIA GeForce GTX 1080 Ti </font></font></th></tr><tr><td>  Preis </td><td></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> $ 650 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> $ 180 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 500 Dollar </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 300 Dollar </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> $ 700 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hash-Rate </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2,6 MHash / s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 21,6 MHash / s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 25,8 MHash / s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 43,5 MHash / s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 25 MHash / s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 55 MHash / s </font></font></td></tr><tr><td>  TDP </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6 W. </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 250 W. </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 120 W. </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 295 W. </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 120 W. </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 250 W. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hashrate / TDP </font></font></td><td>  0,43 </td><td>  0,09 </td><td>  0,22 </td><td>  0,15 </td><td>  0,22 </td><td>  0,21 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Prozesstechnik </font></font></td><td>  28 nm </td><td>  28 nm </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14 nm </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14 nm </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 16 nm </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 16 nm </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei Verwendung von MultiClet S1 als Mining-Tool k√∂nnen tats√§chlich 20 oder mehr Prozessoren auf den Platinen installiert werden. In diesem Fall ist die Hashrate einer solchen Karte gleich oder h√∂her als die Hashraten vorhandener Grafikkarten, w√§hrend der Stromverbrauch einer Karte mit S1 halb so hoch ist wie der von Grafikkarten mit topografischen Standards von 16 und 14 nm. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abschlie√üend muss ich sagen, dass die Hauptaufgabe jetzt die Herstellung einer Multiprozessor-Karte f√ºr einen mehrzelligen Cryptocurrency Miner und Supercomputing Miner ist. Die Wettbewerbsf√§higkeit soll aufgrund des geringen Stromverbrauchs und der Architektur erreicht werden, die sich gut f√ºr beliebiges Computing eignen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Prozessor befindet sich noch in der Entwicklung, aber Sie k√∂nnen bereits mit der Programmierung in Assemblersprache beginnen und die aktuelle Version des Compilers auswerten. </font><font style="vertical-align: inherit;">Es gibt bereits ein minimales SDK mit Assembler, Linker, Compiler und Funktionsmodell, auf dem Sie Ihre Programme starten und testen k√∂nnen.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de434982/">https://habr.com/ru/post/de434982/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de434970/index.html">√úber IT-Business und mehr</a></li>
<li><a href="../de434972/index.html">Wie schreibe ich Unit-Tests, wenn Sie √ºberhaupt keine Lust dazu haben?</a></li>
<li><a href="../de434974/index.html">Arbeiten Sie mit einem Konfigurationsformat 1C: Enterprise</a></li>
<li><a href="../de434976/index.html">ITMO University Fablab: DIY-Coworking f√ºr kreative Menschen - zeigen Sie, was drin ist</a></li>
<li><a href="../de434978/index.html">Einf√ºhrung in HealthKit</a></li>
<li><a href="../de434984/index.html">Warum ich Eloquent ORM hasse</a></li>
<li><a href="../de434986/index.html">Grundlegende Konzepte der Standard-C ++ - Bibliothek</a></li>
<li><a href="../de434992/index.html">IDA Pro aktualisieren. Debugger f√ºr Sega Mega Drive (Teil 1)</a></li>
<li><a href="../de434994/index.html">Android: Erstellen dynamischer Produktaromen und Signieren von Konfigurationen</a></li>
<li><a href="../de434996/index.html">Wie ich den Standort √ºber die VK-API freigegeben habe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>