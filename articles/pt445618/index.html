<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçüíª ‚óªÔ∏è üê† N√≥s escrevemos um sistema operacional no Rust. Implementando a mem√≥ria da p√°gina (nova) üë©üèø‚Äçüîß üêè ‚õ∏Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Neste artigo, descobriremos como implementar o suporte √† mem√≥ria da p√°gina em nosso n√∫cleo. Primeiro, estudaremos v√°rios m√©todos para que os quadros d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>N√≥s escrevemos um sistema operacional no Rust. Implementando a mem√≥ria da p√°gina (nova)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445618/">  Neste artigo, descobriremos como implementar o suporte √† mem√≥ria da p√°gina em nosso n√∫cleo.  Primeiro, estudaremos v√°rios m√©todos para que os quadros da tabela de p√°ginas f√≠sicas fiquem dispon√≠veis para o kernel e discutiremos suas vantagens e desvantagens.  Em seguida, implementamos a fun√ß√£o de convers√£o de endere√ßo e a fun√ß√£o de criar um novo mapeamento. <br><br>  Esta s√©rie de artigos publicados no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> .  Se voc√™ tiver alguma d√∫vida ou problema, abra o ticket correspondente l√°.  Todas as fontes para o artigo est√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste segmento</a> . <br><br>  <i><b>Outro artigo sobre pagina√ß√£o?</b></i> <i><br></i>  <i>Se voc√™ seguir esse ciclo, ver√° o artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">‚ÄúMem√≥ria da p√°gina: n√≠vel avan√ßado‚Äù</a> no final de janeiro.</i>  <i>Mas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fui criticado</a> por tabelas de p√°ginas recursivas.</i>  <i>Portanto, decidi reescrever o artigo, usando uma abordagem diferente para acessar quadros.</i> <br><a name="habracut"></a><br>  <i>Aqui est√° uma nova op√ß√£o.</i>  <i>O artigo ainda explica como as tabelas de p√°ginas recursivas funcionam, mas usamos uma implementa√ß√£o mais simples e poderosa.</i>  <i>N√£o excluiremos o artigo anterior, mas marcaremos como desatualizado e n√£o o atualizaremos.</i> <i><br><br></i>  <i>Espero que voc√™ goste da nova op√ß√£o!</i> <br><br><h1>  Conte√∫do </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1. Introdu√ß√£o</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Atualiza√ß√µes de depend√™ncia</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Acesso a tabelas de p√°ginas</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapeamento de identidade</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapa de deslocamento fixo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapeamento completo da mem√≥ria f√≠sica</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Exibi√ß√£o tempor√°ria</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tabelas de p√°ginas recursivas</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Suporte ao carregador de inicializa√ß√£o</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Informa√ß√µes de inicializa√ß√£o</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Macro do ponto de entrada</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Implementa√ß√£o</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Acesso a tabelas de p√°ginas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tradu√ß√£o de endere√ßos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Usando MappedPageTable</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Crie um novo mapeamento</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sele√ß√£o de quadro</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sum√°rio</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O que vem a seguir?</a> </li></ul><br><a name="1"></a><h1>  1. Introdu√ß√£o </h1><br>  No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√∫ltimo artigo,</a> aprendemos sobre os princ√≠pios da mem√≥ria de pagina√ß√£o e como funcionam as tabelas de p√°gina de quatro n√≠veis no <code>x86_64</code> .  Tamb√©m descobrimos que o carregador j√° configurou a hierarquia da tabela de p√°ginas para nosso kernel, portanto, o kernel √© executado em endere√ßos virtuais.  Isso aumenta a seguran√ßa porque o acesso n√£o autorizado √† mem√≥ria causa uma falha na p√°gina em vez de alterar aleatoriamente a mem√≥ria f√≠sica. <br><br>  O artigo acabou n√£o conseguindo acessar as tabelas de p√°ginas do nosso kernel, porque elas s√£o armazenadas na mem√≥ria f√≠sica e o kernel j√° est√° sendo executado em endere√ßos virtuais.  Aqui continuamos o t√≥pico e exploramos diferentes op√ß√µes para acessar os quadros da tabela de p√°ginas no kernel.  Discutiremos as vantagens e desvantagens de cada um deles e, em seguida, escolheremos a op√ß√£o apropriada para nosso n√∫cleo. <br><br>  O suporte ao carregador de inicializa√ß√£o √© necess√°rio, portanto, vamos configur√°-lo primeiro.  Em seguida, implementamos uma fun√ß√£o que percorre toda a hierarquia de tabelas de p√°ginas, a fim de converter endere√ßos virtuais em f√≠sicos.  Por fim, aprenderemos como criar novos mapeamentos em tabelas de p√°ginas e como encontrar quadros de mem√≥ria n√£o utilizados para criar novas tabelas. <br><br><a name="1_1"></a><h3>  Atualiza√ß√µes de depend√™ncia </h3><br>  Este artigo requer que voc√™ registre o <code>bootloader</code> vers√£o 0.4.0 ou superior e <code>x86_64</code> vers√£o 0.5.2 ou superior nas depend√™ncias.  Voc√™ pode atualizar as depend√™ncias no <code>Cargo.toml</code> : <br><br><pre> <code class="plaintext hljs">[dependencies] bootloader = "0.4.0" x86_64 = "0.5.2"</code> </pre> <br>  Para altera√ß√µes nessas vers√µes, consulte <a href="">o log do carregador de inicializa√ß√£o</a> e o <a href="">log x86_64</a> . <br><br><a name="2"></a><h1>  Acesso a tabelas de p√°ginas </h1><br>  Acessar tabelas de p√°ginas do kernel n√£o √© t√£o f√°cil quanto parece.  Para entender o problema, d√™ uma olhada na hierarquia de tabela de quatro n√≠veis do artigo anterior: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c8/5e8/a14/9c85e8a145a9078cfcfd92e204f69a5b.svg"></div><br><br>  O importante √© que cada entrada da p√°gina armazene o endere√ßo <i>f√≠sico</i> da pr√≥xima tabela.  Isso evita a tradu√ß√£o desses endere√ßos, o que reduz o desempenho e leva facilmente a loops sem fim. <br><br>  O problema √© que n√£o podemos acessar diretamente endere√ßos f√≠sicos do kernel, pois ele tamb√©m funciona em endere√ßos virtuais.  Por exemplo, quando vamos para o endere√ßo <code>4 KiB</code> , obtemos acesso ao endere√ßo <i>virtual</i> <code>4 KiB</code> , e n√£o ao endere√ßo <i>f√≠sico</i> onde a tabela de p√°ginas do 4¬∫ n√≠vel est√° armazenada.  Se queremos acessar o endere√ßo f√≠sico de <code>4 KiB</code> , precisamos usar um endere√ßo virtual, que √© traduzido para ele. <br><br>  Portanto, para acessar os quadros das tabelas de p√°ginas, √© necess√°rio mapear algumas p√°ginas virtuais para esses quadros.  Existem diferentes maneiras de criar esses mapeamentos. <br><br><a name="2_1"></a><h3>  Mapeamento de identidade </h3><br>  Uma solu√ß√£o simples √© a <b>exibi√ß√£o id√™ntica de todas as tabelas de p√°ginas</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/813/916/8f3813916cd0a5b5174c8d14dabedb7a.svg"></div><br><br>  Neste exemplo, vemos a exibi√ß√£o id√™ntica de quadros.  Os endere√ßos f√≠sicos das tabelas de p√°ginas s√£o ao mesmo tempo endere√ßos virtuais v√°lidos, para que possamos acessar facilmente as tabelas de p√°ginas de todos os n√≠veis, come√ßando com o registro CR3. <br><br>  No entanto, essa abordagem confunde o espa√ßo de endere√ßo virtual e dificulta a descoberta de grandes √°reas cont√≠guas de mem√≥ria livre.  Digamos que queremos criar uma √°rea de mem√≥ria virtual de 1000 KiB na figura acima, por exemplo, para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">exibir um arquivo na mem√≥ria</a> .  N√£o podemos come√ßar com a regi√£o de <code>28 KiB</code> , porque ela fica em uma p√°gina j√° ocupada em <code>1004  KiB</code> .  Portanto, voc√™ precisar√° procurar mais at√© encontrarmos um fragmento grande e adequado, por exemplo, com <code>1008  KiB</code> .  H√° o mesmo problema de fragmenta√ß√£o da mem√≥ria segmentada. <br><br>  Al√©m disso, a cria√ß√£o de novas tabelas de p√°ginas √© muito mais complicada, pois precisamos encontrar quadros f√≠sicos cujas p√°ginas correspondentes ainda n√£o foram usadas.  Por exemplo, para o nosso arquivo, reservamos uma √°rea de 1000 KiB de mem√≥ria <i>virtual</i> , come√ßando no endere√ßo <code>1008  KiB</code> .  Agora n√£o podemos mais usar nenhum quadro com um endere√ßo f√≠sico entre <code>1000  KiB</code> e <code>2008  KiB</code> , porque ele n√£o pode ser exibido de forma id√™ntica. <br><br><a name="2_2"></a><h3>  Mapa de deslocamento fixo </h3><br>  Para evitar sobrecarregar o espa√ßo de endere√ßo virtual, voc√™ pode exibir as tabelas de p√°ginas em uma <b>√°rea de mem√≥ria separada</b> .  Portanto, em vez de identificar o mapeamento, mapeamos quadros com um deslocamento fixo no espa√ßo de endere√ßo virtual.  Por exemplo, o deslocamento pode ser 10 TiB: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f4a/c8a/5ea/f4ac8a5ea64fd215de176248b5f74e20.svg"><br><br>  Ao alocar esse intervalo de mem√≥ria virtual exclusivamente para a exibi√ß√£o de tabelas de p√°ginas, evitamos os problemas de exibi√ß√£o id√™ntica.  A reserva de uma √°rea t√£o grande do espa√ßo de endere√ßo virtual s√≥ √© poss√≠vel se o espa√ßo de endere√ßo virtual for muito maior que o tamanho da mem√≥ria f√≠sica.  No <code>x86_64</code> isso n√£o √© um problema, porque o espa√ßo de endere√ßo de 48 bits √© de 256 TiB. <br><br>  Mas essa abordagem tem a desvantagem de que, ao criar cada tabela de p√°ginas, voc√™ precisa criar um novo mapeamento.  Al√©m disso, ele n√£o permite o acesso a tabelas em outros espa√ßos de endere√ßo, o que seria √∫til ao criar um novo processo. <br><br><a name="2_3"></a><h3>  Mapeamento completo da mem√≥ria f√≠sica </h3><br>  Podemos resolver esses problemas <b>exibindo toda a mem√≥ria f√≠sica</b> , e n√£o apenas os quadros da tabela de p√°gina: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c39/3cf/7df/c393cf7df76515739e1d9274160c4b5d.svg"><br><br>  Essa abordagem permite que o kernel acesse mem√≥ria f√≠sica arbitr√°ria, incluindo quadros de tabela de p√°gina de outros espa√ßos de endere√ßo.  Um intervalo de mem√≥ria virtual est√° reservado com o mesmo tamanho de antes, mas somente n√£o h√° p√°ginas sem correspond√™ncia nele. <br><br>  A desvantagem dessa abordagem √© que s√£o necess√°rias tabelas de p√°ginas adicionais para exibir a mem√≥ria f√≠sica.  Essas tabelas de p√°ginas devem ser armazenadas em algum lugar, para que elas usem parte da mem√≥ria f√≠sica, o que pode ser um problema em dispositivos com uma pequena quantidade de RAM. <br><br>  No entanto, no x86_64, podemos usar 2 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">p√°ginas</a> MiB <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">enormes</a> para exibir, em vez do tamanho padr√£o de 4 KiB.  Portanto, para exibir 32 GiB de mem√≥ria f√≠sica, apenas 132 KiB por tabela de p√°gina s√£o necess√°rias: apenas uma tabela de terceiro n√≠vel e 32 tabelas de segundo n√≠vel.  P√°ginas enormes tamb√©m s√£o armazenadas em cache de maneira mais eficiente, porque usam menos entradas no buffer de tradu√ß√£o din√¢mico (TLB). <br><br><a name="2_4"></a><h3>  Exibi√ß√£o tempor√°ria </h3><br>  Para dispositivos com muito pouca mem√≥ria f√≠sica, voc√™ s√≥ pode <b>exibir tabelas de p√°ginas temporariamente</b> quando precisar acess√°-las.  Para compara√ß√µes tempor√°rias, √© necess√°ria uma exibi√ß√£o id√™ntica apenas da tabela de primeiro n√≠vel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00a/3ab/5ce/00a3ab5ce85057d3679a48379d3d2297.svg"></div><br><br>  Nesta figura, uma tabela de n√≠vel 1 gerencia os 2 primeiros MiB de espa√ßo de endere√ßo virtual.  Isso √© poss√≠vel porque o acesso a partir do registro CR3 √© feito atrav√©s de zero entradas nas tabelas dos n√≠veis 4, 3 e 2. O registro com o √≠ndice <code>8</code> converte a p√°gina virtual em <code>32 KiB</code> em um quadro f√≠sico em <code>32 KiB</code> , identificando a pr√≥pria tabela de n√≠vel 1. Na figura, isso √© mostrado por uma seta horizontal. <br><br>  Ao escrever na tabela de n√≠vel 1 mapeada de forma id√™ntica, nosso kernel pode criar at√© 511 compara√ß√µes de tempo (512 menos o registro necess√°rio para o mapeamento de identidade).  No exemplo acima, o kernel cria duas compara√ß√µes de tempo: <br><br><ul><li>  Mapeando uma entrada nula em uma tabela de n√≠vel 1 para um quadro em <code>24 KiB</code> .  Isso cria um mapeamento tempor√°rio da p√°gina virtual em <code>0 KiB</code> para o quadro f√≠sico da tabela de n√≠vel 2 da p√°gina indicado pela seta pontilhada. </li><li>  Combine o nono registro de uma tabela de n√≠vel 1 com um quadro em <code>4 KiB</code> .  Isso cria um mapeamento tempor√°rio da p√°gina virtual em <code>36 KiB</code> para o quadro f√≠sico da tabela de n√≠vel 4 da p√°gina indicada pela seta pontilhada. </li></ul><br>  Agora o kernel pode acessar uma tabela de n√≠vel 2 gravando em uma p√°gina que come√ßa em <code>0 KiB</code> e uma tabela de n√≠vel 4 gravando em uma p√°gina que come√ßa em <code>33 KiB</code> . <br><br>  Portanto, o acesso a um quadro arbitr√°rio da tabela de p√°ginas com mapeamentos tempor√°rios consiste nas seguintes a√ß√µes: <br><br><ul><li>  Encontre uma entrada gratuita na tabela de n√≠vel 1 exibida de forma id√™ntica. <br></li><li>  Mapeie essa entrada para o quadro f√≠sico da tabela de p√°ginas que queremos acessar. <br></li><li>  Acesse esse quadro atrav√©s da p√°gina virtual associada √† entrada. <br></li><li>  Defina o registro novamente como n√£o utilizado, removendo o mapeamento tempor√°rio. </li></ul><br>  Com essa abordagem, o espa√ßo de endere√ßo virtual permanece limpo, pois as mesmas 512 p√°ginas virtuais s√£o usadas constantemente.  A desvantagem √© uma certa dificuldade, especialmente porque uma nova compara√ß√£o pode exigir a altera√ß√£o de v√°rios n√≠veis da tabela, ou seja, precisamos repetir o processo descrito v√°rias vezes. <br><br><a name="2_5"></a><h3>  Tabelas de p√°ginas recursivas </h3><br>  Outra abordagem interessante que n√£o requer tabelas de p√°ginas adicionais √© <b>a correspond√™ncia recursiva</b> . <br><br>  A id√©ia √© traduzir alguns registros da tabela de quarto n√≠vel para ela mesma.  Assim, reservamos uma parte do espa√ßo de endere√ßo virtual e mapeamos todos os quadros de tabela atuais e futuros para esse espa√ßo. <br><br>  Vejamos um exemplo para entender como tudo isso funciona: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/779/ee6/d9b/779ee6d9bf771dec8e6d22c0440e503d.png"></div><br><br>  A √∫nica diferen√ßa do exemplo no in√≠cio do artigo √© um registro adicional com o √≠ndice <code>511</code> na tabela de n√≠vel 4, que √© mapeado para o quadro f√≠sico <code>4 KiB</code> , localizado nesta tabela em si. <br><br>  Quando a CPU entra nesse registro, ela n√£o se refere √† tabela de n√≠vel 3, mas novamente √† tabela de n√≠vel 4. Isso √© semelhante a uma fun√ß√£o recursiva que se chama.  √â importante que o processador assuma que cada entrada na tabela de n√≠vel 4 aponta para uma tabela de n√≠vel 3. Portanto, agora ela trata a tabela de n√≠vel 4 como uma tabela de n√≠vel 3. Isso funciona porque as tabelas de todos os n√≠veis em x86_64 t√™m a mesma estrutura. <br><br>  Seguindo um registro recursivo uma ou mais vezes antes de iniciar a convers√£o real, podemos reduzir efetivamente o n√∫mero de n√≠veis pelos quais o processador passa.  Por exemplo, se seguirmos o registro recursivo uma vez e depois formos para a tabela de n√≠vel 3, o processador achar√° que a tabela de n√≠vel 3 √© uma tabela de n√≠vel 2. Seguindo em frente, ele considera a tabela de n√≠vel 2 como uma tabela de n√≠vel 1 e a tabela de n√≠vel 1 como mapeada quadro na mem√≥ria f√≠sica.  Isso significa que agora podemos ler e gravar na tabela de n√≠vel 1 da p√°gina, porque o processador pensa que esse √© um quadro mapeado.  A figura abaixo mostra as cinco etapas dessa tradu√ß√£o: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/ac7/191/bdaac719103c574c655efa3604d0b842.png"></div><br><br>  Da mesma forma, podemos seguir uma entrada recursiva duas vezes antes de iniciar a convers√£o para reduzir o n√∫mero de n√≠veis passados ‚Äã‚Äãpara dois: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f4/b9a/c47/7f4b9ac47fce9552dead4e551b804256.png"></div><br><br>  Vamos seguir este procedimento passo a passo.  Primeiro, a CPU segue uma entrada recursiva na tabela de n√≠vel 4 e pensa que alcan√ßou a tabela de n√≠vel 3. Em seguida, segue o registro recursivo novamente e pensa que alcan√ßou o n√≠vel 2. Mas, na realidade, ainda est√° no n√≠vel 4. Em seguida, a CPU vai para o novo endere√ßo e entra na tabela de n√≠vel 3, mas acha que j√° est√° na tabela de n√≠vel 1. Por fim, no pr√≥ximo ponto de entrada da tabela de n√≠vel 2, o processador acha que acessou o quadro de mem√≥ria f√≠sica.  Isso nos permite ler e gravar em uma tabela de n√≠vel 2. <br><br>  Tamb√©m s√£o acessadas as tabelas dos n√≠veis 3 e 4. Para acessar a tabela do n√≠vel 3, seguimos um registro recursivo tr√™s vezes: o processador pensa que j√° est√° na tabela do n√≠vel 1 e, na pr√≥xima etapa, atingimos o n√≠vel 3, que a CPU considera como um quadro mapeado.  Para acessar a tabela de n√≠vel 4, basta seguir o registro recursivo quatro vezes at√© que o processador processe a tabela de n√≠vel 4 como um quadro mapeado (em azul na figura abaixo). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/487/a82/92c/487a8292cf8fe673f1914f5f198c0956.png"></div><br><br>  O conceito √© dif√≠cil de entender a princ√≠pio, mas, na pr√°tica, funciona muito bem. <br><br><h4>  C√°lculo de endere√ßo </h4><br>  Assim, podemos acessar tabelas de todos os n√≠veis seguindo um registro recursivo uma ou mais vezes.  Como os √≠ndices em tabelas de quatro n√≠veis s√£o derivados diretamente do endere√ßo virtual, endere√ßos virtuais especiais devem ser criados para esse m√©todo.  Como lembramos, os √≠ndices da tabela de p√°ginas s√£o extra√≠dos do endere√ßo da seguinte maneira: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c44/33c/8f9/c4433c8f99b6fcb54d4b79983ca35dbc.svg"></div><br><br>  Suponha que desejamos acessar uma tabela de n√≠vel 1 que exibe uma p√°gina espec√≠fica.  Como aprendemos acima, voc√™ precisa passar por um registro recursivo uma vez e depois pelos √≠ndices do 4¬∫, 3¬∫ e 2¬∫ n√≠veis.  Para fazer isso, movemos todos os blocos de endere√ßo um bloco para a direita e configuramos o √≠ndice do registro recursivo para o local do √≠ndice inicial do n√≠vel 4: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62a/d82/b54/62ad82b54b233a37e40b964953a16bf8.svg"></div><br><br>  Para acessar a tabela de n√≠vel 2 desta p√°gina, movemos todos os blocos de √≠ndice dois blocos para a direita e configuramos o √≠ndice recursivo para o local dos dois blocos de origem: n√≠vel 4 e n√≠vel 3: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d9/ae5/7c8/1d9ae57c8c68a0b239e5b37397a4d0f7.svg"></div><br><br>  Para acessar a tabela de n√≠vel 3, fazemos o mesmo, apenas mudamos para a direita, j√° com tr√™s blocos de endere√ßos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b8/6ee/c9f/4b86eec9fd1df3445718ed8246fd4473.svg"></div><br><br>  Finalmente, para acessar a tabela de n√≠vel 4, mova todos os quatro blocos para a direita. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36b/6b0/29b/36b6b029b31578b143ff1e7605e358fb.svg"></div><br><br>  Agora voc√™ pode calcular endere√ßos virtuais para tabelas de p√°ginas dos quatro n√≠veis.  Podemos at√© calcular um endere√ßo que aponte exatamente para uma entrada espec√≠fica da tabela de p√°ginas multiplicando seu √≠ndice por 8, o tamanho da entrada da tabela de p√°ginas. <br><br>  A tabela abaixo mostra a estrutura de endere√ßos para acessar v√°rios tipos de quadros: <br><br><table><thead><tr><th>  Endere√ßo virtual para </th><th>  Estrutura de endere√ßo ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">octal</a> ) </th></tr></thead><tbody><tr><td>  Page </td><td> <code>0o_SSSSSS_AAA_BBB_CCC_DDD_EEEE</code> </td> </tr><tr><td>  Entrada na tabela de n√≠vel 1 </td><td> <code>0o_SSSSSS_RRR_AAA_BBB_CCC_DDDD</code> </td> </tr><tr><td>  Entrada em uma tabela de n√≠vel 2 </td><td> <code>0o_SSSSSS_RRR_RRR_AAA_BBB_CCCC</code> </td> </tr><tr><td>  Entrada em uma tabela de n√≠vel 3 </td><td> <code>0o_SSSSSS_RRR_RRR_RRR_AAA_BBBB</code> </td> </tr><tr><td>  Entrada na tabela de n√≠vel 4 </td><td> <code>0o_SSSSSS_RRR_RRR_RRR_RRR_AAAA</code> </td> </tr></tbody></table><br>  Aqui, <code></code> √© o √≠ndice de n√≠vel 4, <code></code> √© o n√≠vel 3, <code></code> √© o n√≠vel 2 e <code>DDD</code> √© o √≠ndice de n√≠vel 1 para o quadro exibido, <code>EEEE</code> √© o seu deslocamento.  <code>RRR</code> √© o √≠ndice do registro recursivo.  Um √≠ndice (tr√™s d√≠gitos) √© convertido em um deslocamento (quatro d√≠gitos) multiplicando por 8 (o tamanho da entrada da tabela da p√°gina).  Com esse deslocamento, o endere√ßo resultante aponta diretamente para a entrada da tabela de p√°ginas correspondente. <br><br>  <code>SSSS</code> s√£o bits de expans√£o do d√≠gito assinado, ou seja, s√£o c√≥pias do bit 47. Esse √© um requisito especial para endere√ßos v√°lidos na arquitetura x86_64, que discutimos em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo anterior</a> . <br><br>  Os endere√ßos s√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">octais</a> , pois cada caractere octal representa tr√™s bits, o que permite separar claramente os √≠ndices de 9 bits das tabelas em diferentes n√≠veis.  Isso n√£o √© poss√≠vel no sistema hexadecimal, onde cada caractere representa quatro bits. <br><br><h4>  C√≥digo de ferrugem </h4><br>  Voc√™ pode construir esses endere√ßos no c√≥digo Rust usando opera√ß√µes bit a bit: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// the virtual address whose corresponding page tables you want to access let addr: usize = [‚Ä¶]; let r = 0o777; // recursive index let sign = 0o177777 &lt;&lt; 48; // sign extension // retrieve the page table indices of the address that we want to translate let l4_idx = (addr &gt;&gt; 39) &amp; 0o777; // level 4 index let l3_idx = (addr &gt;&gt; 30) &amp; 0o777; // level 3 index let l2_idx = (addr &gt;&gt; 21) &amp; 0o777; // level 2 index let l1_idx = (addr &gt;&gt; 12) &amp; 0o777; // level 1 index let page_offset = addr &amp; 0o7777; // calculate the table addresses let level_4_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (r &lt;&lt; 21) | (r &lt;&lt; 12); let level_3_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (r &lt;&lt; 21) | (l4_idx &lt;&lt; 12); let level_2_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (l4_idx &lt;&lt; 21) | (l3_idx &lt;&lt; 12); let level_1_table_addr = sign | (r &lt;&lt; 39) | (l4_idx &lt;&lt; 30) | (l3_idx &lt;&lt; 21) | (l2_idx &lt;&lt; 12);</span></span></code> </pre> <br>  Esse c√≥digo pressup√µe que um mapeamento recursivo do √∫ltimo registro de n√≠vel 4 com o √≠ndice <code>0o777</code> (511) seja correspondido recursivamente.  Atualmente n√£o √© o caso, portanto o c√≥digo ainda n√£o funcionar√°.  Veja abaixo como instruir o carregador a configurar um mapeamento recursivo. <br><br>  Como alternativa √† execu√ß√£o manual de opera√ß√µes bit a bit, voc√™ pode usar o tipo <code>RecursivePageTable</code> da caixa <code>x86_64</code> , que fornece abstra√ß√µes seguras para v√°rias opera√ß√µes da tabela.  Por exemplo, o c√≥digo abaixo mostra como converter um endere√ßo virtual em seu endere√ßo f√≠sico correspondente: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::{Mapper, Page, PageTable, RecursivePageTable}; use x86_64::{VirtAddr, PhysAddr}; /// Creates a RecursivePageTable instance from the level 4 address. let level_4_table_addr = [‚Ä¶]; let level_4_table_ptr = level_4_table_addr as *mut PageTable; let recursive_page_table = unsafe { let level_4_table = &amp;mut *level_4_table_ptr; RecursivePageTable::new(level_4_table).unwrap(); } /// Retrieve the physical address for the given virtual address let addr: u64 = [‚Ä¶] let addr = VirtAddr::new(addr); let page: Page = Page::containing_address(addr); // perform the translation let frame = recursive_page_table.translate_page(page); frame.map(|frame| frame.start_address() + u64::from(addr.page_offset()))</span></span></code> </pre> <br>  Novamente, esse c√≥digo requer um mapeamento recursivo correto.  Com esse mapeamento, o <code>level_4_table_addr</code> ausente <code>level_4_table_addr</code> calculado como no primeiro exemplo de c√≥digo. <br><br><hr><br>  O mapeamento recursivo √© um m√©todo interessante que mostra o qu√£o poderosa pode ser a correspond√™ncia atrav√©s de uma √∫nica tabela.  √â relativamente f√°cil de implementar e requer apenas configura√ß√£o m√≠nima (apenas uma entrada recursiva), portanto, essa √© uma boa op√ß√£o para as primeiras experi√™ncias. <br><br>  Mas tem algumas desvantagens: <br><br><ul><li>  Uma grande quantidade de mem√≥ria virtual (512 GiB).  Isso n√£o √© um problema em um espa√ßo de endere√ßo grande de 48 bits, mas pode levar a um comportamento de cache abaixo do ideal. <br></li><li>  Facilmente, d√° acesso apenas ao espa√ßo de endere√ßo atualmente ativo.  O acesso a outros espa√ßos de endere√ßo ainda √© poss√≠vel alterando a entrada recursiva, mas a correspond√™ncia tempor√°ria √© necess√°ria para a altern√¢ncia.  Descrevemos como fazer isso em um artigo anterior (obsoleto). <br></li><li>  Depende muito do formato da tabela de p√°ginas x86 e pode n√£o funcionar em outras arquiteturas. </li></ul><br><a name="3"></a><h1>  Suporte ao carregador de inicializa√ß√£o </h1><br>  Todas as abordagens descritas acima requerem altera√ß√µes nas tabelas de p√°ginas e nas configura√ß√µes correspondentes.  Por exemplo, para mapear a mem√≥ria f√≠sica de forma id√™ntica ou recursiva, mapeie registros de uma tabela de quarto n√≠vel.  O problema √© que n√£o podemos fazer essas configura√ß√µes sem acessar as tabelas de p√°ginas. <br><br>  Ent√£o, preciso de ajuda do gerenciador de inicializa√ß√£o.  Ele tem acesso a tabelas de p√°ginas, para que ele possa criar qualquer exibi√ß√£o necess√°ria.  Na sua implementa√ß√£o atual, o caixote do <code>bootloader</code> suporta as duas abordagens acima usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fun√ß√µes de carga</a> : <br><br><ul><li>  A fun√ß√£o <code>map_physical_memory</code> mapeia a mem√≥ria f√≠sica completa em algum lugar do espa√ßo de endere√ßo virtual.  Assim, o kernel obt√©m acesso a toda a mem√≥ria f√≠sica e pode aplicar uma abordagem com a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">exibi√ß√£o da mem√≥ria f√≠sica completa</a> . <br></li><li>  Usando a fun√ß√£o <code>recursive_page_table</code> , o carregador exibe recursivamente uma entrada da tabela de p√°gina de quarto n√≠vel.  Isso permite que o kernel funcione de acordo com o m√©todo descrito na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">se√ß√£o "Tabelas de p√°ginas recursivas"</a> . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para o nosso kernel, escolhemos a primeira op√ß√£o, porque √© uma abordagem simples, independente de plataforma e mais poderosa (tamb√©m d√° acesso a outros quadros, n√£o apenas a tabelas de p√°ginas). </font><font style="vertical-align: inherit;">Para suporte do gerenciador de inicializa√ß√£o, inclua a fun√ß√£o em suas depend√™ncias </font></font><code>map_physical_memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="plaintext hljs">[dependencies] bootloader = { version = "0.4.0", features = ["map_physical_memory"]}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se esse recurso estiver ativado, o carregador de inicializa√ß√£o mapeia a mem√≥ria f√≠sica completa para algum intervalo n√£o utilizado de endere√ßos virtuais. </font><font style="vertical-align: inherit;">Para passar um intervalo de endere√ßos virtuais para o kernel, o carregador de inicializa√ß√£o passa a estrutura das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">informa√ß√µes de inicializa√ß√£o</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><a name="3_1"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Informa√ß√µes de inicializa√ß√£o </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O engradado </font></font><code>bootloader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">define a estrutura do </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BootInfo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> com todas as informa√ß√µes passadas ao kernel. </font><font style="vertical-align: inherit;">A estrutura ainda est√° sendo finalizada, portanto, pode haver algumas falhas ao atualizar para vers√µes futuras </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">incompat√≠veis com o semver</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Atualmente, a estrutura possui dois campos: </font></font><code>memory_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O campo </font></font><code>memory_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fornece uma vis√£o geral da mem√≥ria f√≠sica dispon√≠vel. </font><font style="vertical-align: inherit;">Ele informa ao kernel quanta mem√≥ria f√≠sica est√° dispon√≠vel no sistema e quais √°reas de mem√≥ria est√£o reservadas para dispositivos como o VGA. </font><font style="vertical-align: inherit;">Um cart√£o de mem√≥ria pode ser solicitado no firmware do BIOS ou UEFI, mas apenas no in√≠cio do processo de inicializa√ß√£o. </font><font style="vertical-align: inherit;">Por esse motivo, o carregador deve fornec√™-lo, porque o kernel n√£o poder√° mais receber essas informa√ß√µes. </font><font style="vertical-align: inherit;">Um cart√£o de mem√≥ria ser√° √∫til mais adiante neste artigo.</font></font><br></li><li> <code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">relata o endere√ßo inicial virtual do mapeamento de mem√≥ria f√≠sica. </font><font style="vertical-align: inherit;">Adicionando esse deslocamento ao endere√ßo f√≠sico, obtemos o endere√ßo virtual correspondente. </font><font style="vertical-align: inherit;">Isso d√° acesso do kernel √† mem√≥ria f√≠sica arbitr√°ria.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O carregador passa a estrutura </font></font><code>BootInfo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para o </font><font style="vertical-align: inherit;">kernel </font><font style="vertical-align: inherit;">como um argumento </font></font><code>&amp;'static BootInfo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para a fun√ß√£o </font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Adicione:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs use bootloader::BootInfo; #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start(boot_info: &amp;'static BootInfo) -&gt; ! { // new argument [‚Ä¶] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √â importante especificar o tipo de argumento correto, pois o compilador n√£o conhece o tipo de assinatura correto da nossa fun√ß√£o de ponto de entrada. </font></font><br><br><a name="3_2"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Macro do ponto de entrada </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como a fun√ß√£o </font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© chamada externamente a partir do carregador, a assinatura da fun√ß√£o n√£o √© verificada. Isso significa que podemos aceitar argumentos arbitr√°rios sem erros de compila√ß√£o, mas isso trava ou causa um comportamento indefinido do tempo de execu√ß√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para garantir que a fun√ß√£o do ponto de entrada sempre tenha a assinatura correta, a caixa </font></font><code>bootloader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fornece uma macro </font></font><code>entry_point</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Reescrevemos nossa fun√ß√£o usando esta macro:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs use bootloader::{BootInfo, entry_point}; entry_point!(kernel_main); #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ n√£o precisa mais usar o ponto de entrada </font></font><code>extern "C"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>no_mangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, j√° que a macro define para n√≥s o ponto de entrada real do n√≠vel inferior </font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. A fun√ß√£o </font></font><code>kernel_main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agora se tornou uma fun√ß√£o Rust completamente normal, para que possamos escolher um nome arbitr√°rio para ela. O importante √© que ele seja verificado por tipo; portanto, se voc√™ usar a assinatura errada, por exemplo, adicionando um argumento ou alterando seu tipo, ocorrer√° um erro de compila√ß√£o</font></font><br><br><a name="4"></a><h1>  Implementa√ß√£o </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora temos acesso √† mem√≥ria f√≠sica e podemos finalmente come√ßar a implementa√ß√£o do sistema. </font><font style="vertical-align: inherit;">Primeiro, considere as tabelas de p√°ginas ativas atuais nas quais o kernel √© executado. </font><font style="vertical-align: inherit;">Na segunda etapa, crie uma fun√ß√£o de convers√£o que retorne o endere√ßo f√≠sico para o qual esse endere√ßo virtual est√° mapeado. </font><font style="vertical-align: inherit;">Na √∫ltima etapa, tentaremos modificar as tabelas de p√°ginas para criar um novo mapeamento. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro, crie um novo m√≥dulo no c√≥digo </font></font><code>memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/lib.rs pub mod memory;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para o m√≥dulo, crie um arquivo vazio </font></font><code>src/memory.rs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><a name="4_1"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Acesso a tabelas de p√°ginas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No final do </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artigo anterior,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tentamos examinar a tabela de p√°ginas em que o kernel funciona, mas n√£o conseguimos acessar o quadro f√≠sico apontado pelo registro </font></font><code>CR3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Agora podemos continuar trabalhando a partir deste local: a fun√ß√£o </font></font><code>active_level_4_table</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retornar√° um link para a tabela ativa de p√°ginas do quarto n√≠vel:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::PageTable; /// Returns a mutable reference to the active level 4 table. /// /// This function is unsafe because the caller must guarantee that the /// complete physical memory is mapped to virtual memory at the passed /// `physical_memory_offset`. Also, this function must be only called once /// to avoid aliasing `&amp;mut` references (which is undefined behavior). pub unsafe fn active_level_4_table(physical_memory_offset: u64) -&gt; &amp;'static mut PageTable { use x86_64::{registers::control::Cr3, VirtAddr}; let (level_4_table_frame, _) = Cr3::read(); let phys = level_4_table_frame.start_address(); let virt = VirtAddr::new(phys.as_u64() + physical_memory_offset); let page_table_ptr: *mut PageTable = virt.as_mut_ptr(); &amp;mut *page_table_ptr // unsafe }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro, lemos o quadro f√≠sico da tabela ativa do 4¬∫ n√≠vel no registro </font></font><code>CR3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Em seguida, pegamos seu endere√ßo f√≠sico inicial e o convertemos em um endere√ßo virtual adicionando </font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Por fim, converta o endere√ßo em um ponteiro bruto </font></font><code>*mut PageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pelo m√©todo </font></font><code>as_mut_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e, em seguida, crie um link com seguran√ßa </font></font><code>&amp;mut PageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Em </font></font><code>&amp;mut</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vez disso </font></font><code>&amp;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">criamos o link </font><font style="vertical-align: inherit;">, porque mais adiante neste artigo modificaremos essas tabelas de p√°ginas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o h√° necessidade de inserir um bloco n√£o seguro aqui, porque Rust considera todo o corpo </font></font><code>unsafe fn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como um bloco grande e n√£o seguro. Isso aumenta os riscos, porque √© poss√≠vel introduzir acidentalmente uma opera√ß√£o insegura nas linhas anteriores. Tamb√©m dificulta a detec√ß√£o de opera√ß√µes n√£o seguras. Um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> j√° foi criado </font><font style="vertical-align: inherit;">para modificar esse comportamento do Rust.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos usar esta fun√ß√£o para gerar os registros da tabela do quarto n√≠vel:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS use blog_os::memory::active_level_4_table; let l4_table = unsafe { active_level_4_table(boot_info.physical_memory_offset) }; for (i, entry) in l4_table.iter().enumerate() { if !entry.is_unused() { println!("L4 Entry {}: {:?}", i, entry); } } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Passamos </font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no campo correspondente da estrutura </font></font><code>BootInfo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Em seguida, usamos uma fun√ß√£o </font></font><code>iter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para percorrer as entradas da tabela de p√°ginas e um combinador </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">enumerate</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para adicionar um √≠ndice </font></font><code>i</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a cada elemento. Somente entradas n√£o vazias s√£o exibidas, porque todas as 512 entradas n√£o cabem na tela. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando executamos o c√≥digo, vemos o resultado: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a33/def/50d/a33def50db528880395b665882aabe75.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vemos v√°rios registros n√£o vazios que s√£o mapeados para v√°rias tabelas de terceiro n√≠vel. Muitas √°reas de mem√≥ria s√£o usadas porque s√£o necess√°rias √°reas separadas para c√≥digo do kernel, pilha do kernel, tradu√ß√£o da mem√≥ria f√≠sica e informa√ß√µes de inicializa√ß√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para percorrer as tabelas de p√°ginas e olhar para a tabela de terceiro n√≠vel, podemos converter novamente o quadro exibido em um endere√ßo virtual:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in the for loop in src/main.rs use x86_64::{structures::paging::PageTable, VirtAddr}; if !entry.is_unused() { println!("L4 Entry {}: {:?}", i, entry); // get the physical address from the entry and convert it let phys = entry.frame().unwrap().start_address(); let virt = phys.as_u64() + boot_info.physical_memory_offset; let ptr = VirtAddr::new(virt).as_mut_ptr(); let l3_table: &amp;PageTable = unsafe { &amp;*ptr }; // print non-empty entries of the level 3 table for (i, entry) in l3_table.iter().enumerate() { if !entry.is_unused() { println!(" L3 Entry {}: {:?}", i, entry); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para visualizar as tabelas do segundo e primeiro n√≠veis, repita esse processo, respectivamente, para registros do terceiro e do segundo n√≠veis. </font><font style="vertical-align: inherit;">Como voc√™ pode imaginar, a quantidade de c√≥digo est√° crescendo muito rapidamente, portanto n√£o publicaremos a lista completa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A travessia manual de tabelas √© interessante porque ajuda a entender como o processador converte endere√ßos. </font><font style="vertical-align: inherit;">Mas geralmente s√≥ estamos interessados ‚Äã‚Äãem exibir um endere√ßo f√≠sico para um endere√ßo virtual espec√≠fico, ent√£o vamos criar uma fun√ß√£o para isso.</font></font><br><br><a name="4_2"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tradu√ß√£o de endere√ßos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para converter um endere√ßo virtual em um endere√ßo f√≠sico, precisamos passar por uma tabela de p√°gina de quatro n√≠veis at√© atingir o quadro mapeado. </font><font style="vertical-align: inherit;">Vamos criar uma fun√ß√£o que execute esta tradu√ß√£o de endere√ßo:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::{PhysAddr, VirtAddr}; /// Translates the given virtual address to the mapped physical address, or /// `None` if the address is not mapped. /// /// This function is unsafe because the caller must guarantee that the /// complete physical memory is mapped to virtual memory at the passed /// `physical_memory_offset`. pub unsafe fn translate_addr(addr: VirtAddr, physical_memory_offset: u64) -&gt; Option&lt;PhysAddr&gt; { translate_addr_inner(addr, physical_memory_offset) }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√≥s nos referimos a uma fun√ß√£o segura </font></font><code>translate_addr_inner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para limitar a quantidade de c√≥digo n√£o seguro. Como observado acima, Rust considera todo o corpo </font></font><code>unsafe fn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como um grande bloco inseguro. Invocando uma fun√ß√£o segura, tornamos expl√≠citas novamente cada opera√ß√£o </font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma fun√ß√£o interna especial possui funcionalidade real:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs /// Private function that is called by `translate_addr`. /// /// This function is safe to limit the scope of `unsafe` because Rust treats /// the whole body of unsafe functions as an unsafe block. This function must /// only be reachable through `unsafe fn` from outside of this module. fn translate_addr_inner(addr: VirtAddr, physical_memory_offset: u64) -&gt; Option&lt;PhysAddr&gt; { use x86_64::structures::paging::page_table::FrameError; use x86_64::registers::control::Cr3; // read the active level 4 frame from the CR3 register let (level_4_table_frame, _) = Cr3::read(); let table_indexes = [ addr.p4_index(), addr.p3_index(), addr.p2_index(), addr.p1_index() ]; let mut frame = level_4_table_frame; // traverse the multi-level page table for &amp;index in &amp;table_indexes { // convert the frame into a page table reference let virt = frame.start_address().as_u64() + physical_memory_offset; let table_ptr: *const PageTable = VirtAddr::new(virt).as_ptr(); let table = unsafe {&amp;*table_ptr}; // read the page table entry and update `frame` let entry = &amp;table[index]; frame = match entry.frame() { Ok(frame) =&gt; frame, Err(FrameError::FrameNotPresent) =&gt; return None, Err(FrameError::HugeFrame) =&gt; panic!("huge pages not supported"), }; } // calculate the physical address by adding the page offset Some(frame.start_address() + u64::from(addr.page_offset())) }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em vez de reutilizar a fun√ß√£o, relemos o </font></font><code>active_level_4_table</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quadro de quarto n√≠vel do registro </font></font><code>CR3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, porque isso simplifica a implementa√ß√£o do prot√≥tipo. N√£o se preocupe, melhoraremos a solu√ß√£o em breve. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A estrutura </font></font><code>VirtAddr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j√° fornece m√©todos para calcular √≠ndices em tabelas de p√°ginas de quatro n√≠veis. Armazenamos esses √≠ndices em uma pequena matriz, porque permite percorrer todas as tabelas </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Fora do loop, lembramos do √∫ltimo quadro visitado para calcular o endere√ßo f√≠sico posteriormente. </font></font><code>frame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aponta para os quadros da tabela de p√°ginas durante a itera√ß√£o e para o quadro associado ap√≥s a √∫ltima itera√ß√£o, ou seja, ap√≥s passar o registro de n√≠vel 1. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dentro do loop, aplicamos novamente</font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para converter um quadro em um link da tabela da p√°gina. Em seguida, lemos o registro da tabela de p√°ginas atual e usamos a fun√ß√£o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>PageTableEntry::frame</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para recuperar o quadro correspondente. Se o registro n√£o estiver mapeado para um quadro, retorne </font></font><code>None</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Se o registro exibir uma p√°gina enorme de 2 MiB ou 1 GiB, at√© agora teremos p√¢nico. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ent√£o, vamos verificar a fun√ß√£o de tradu√ß√£o em alguns endere√ßos:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS use blog_os::memory::translate_addr; use x86_64::VirtAddr; let addresses = [ // the identity-mapped vga buffer page 0xb8000, // some code page 0x20010a, // some stack page 0x57ac_001f_fe48, // virtual address mapped to physical address 0 boot_info.physical_memory_offset, ]; for &amp;address in &amp;addresses { let virt = VirtAddr::new(address); let phys = unsafe { translate_addr(virt, boot_info.physical_memory_offset) }; println!("{:?} -&gt; {:?}", virt, phys); } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando executamos o c√≥digo, obtemos o seguinte resultado: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a0b/e32/db8/a0be32db8b6353452f9d40d7b1d350ad.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como esperado, com um mapeamento id√™ntico, o endere√ßo √© </font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">convertido no mesmo endere√ßo f√≠sico. </font><font style="vertical-align: inherit;">A p√°gina de c√≥digo e a pilha s√£o convertidas em endere√ßos f√≠sicos arbitr√°rios, que dependem de como o carregador criou o mapeamento inicial para o nosso kernel. </font><font style="vertical-align: inherit;">O mapeamento </font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deve apontar para o endere√ßo f√≠sico </font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas falha, porque a tradu√ß√£o usa p√°ginas enormes para efici√™ncia. </font><font style="vertical-align: inherit;">Uma vers√£o futura do gerenciador de inicializa√ß√£o pode aplicar a mesma otimiza√ß√£o para as p√°ginas do kernel e da pilha.</font></font><br><br><a name="4_3"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Usando MappedPageTable </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A tradu√ß√£o de endere√ßos virtuais em endere√ßos f√≠sicos √© uma tarefa t√≠pica do kernel do SO, portanto, o engradado </font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fornece uma abstra√ß√£o para ele. </font><font style="vertical-align: inherit;">Ele j√° suporta p√°ginas enormes e v√°rias outras fun√ß√µes, exceto </font></font><code>translate_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, portanto, a usamos em vez de adicionar suporte a p√°ginas grandes em nossa pr√≥pria implementa√ß√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A base da abstra√ß√£o s√£o duas caracter√≠sticas que definem v√°rias fun√ß√µes de tradu√ß√£o da tabela de p√°ginas:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A caracter√≠stica </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>Mapper</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fornece fun√ß√µes que funcionam nas p√°ginas. </font><font style="vertical-align: inherit;">Por exemplo, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>translate_page</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para converter esta p√°gina em um quadro do mesmo tamanho, bem como </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>map_to</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para criar um novo mapeamento na tabela.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A caracter√≠stica </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>MapperAllSizes</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implica aplica√ß√£o </font></font><code>Mapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para todos os tamanhos de p√°gina. </font><font style="vertical-align: inherit;">Al√©m disso, fornece fun√ß√µes que funcionam com p√°ginas de tamanhos diferentes, incluindo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>translate_addr</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">geral ou </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>translate</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os tra√ßos definem apenas a interface, mas n√£o fornecem nenhuma implementa√ß√£o. </font><font style="vertical-align: inherit;">Agora, a caixa </font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fornece dois tipos que implementam caracter√≠sticas: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>MappedPageTable</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>RecursivePageTable</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">A primeira exige que cada quadro da tabela da p√°gina seja exibido em algum lugar (por exemplo, com um deslocamento). </font><font style="vertical-align: inherit;">O segundo tipo pode ser usado se a tabela do quarto n√≠vel for exibida recursivamente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temos toda a mem√≥ria f√≠sica mapeada para </font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que voc√™ possa usar o tipo MappedPageTable. </font><font style="vertical-align: inherit;">Para inicializ√°-lo, crie uma nova fun√ß√£o </font></font><code>init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no m√≥dulo </font></font><code>memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> x86_64::structures::paging::{PhysFrame, MapperAllSizes, MappedPageTable}; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> x86_64::PhysAddr; <span class="hljs-comment"><span class="hljs-comment">/// Initialize a new MappedPageTable. /// /// This function is unsafe because the caller must guarantee that the /// complete physical memory is mapped to virtual memory at the passed /// `physical_memory_offset`. Also, this function must be only called once /// to avoid aliasing `&amp;mut` references (which is undefined behavior). pub unsafe fn init(physical_memory_offset: u64) -&gt; impl MapperAllSizes { let level_4_table = active_level_4_table(physical_memory_offset); let phys_to_virt = move |frame: PhysFrame| -&gt; *mut PageTable { let phys = frame.start_address().as_u64(); let virt = VirtAddr::new(phys + physical_memory_offset); virt.as_mut_ptr() }; MappedPageTable::new(level_4_table, phys_to_virt) } // make private unsafe fn active_level_4_table(physical_memory_offset: u64) -&gt; &amp;'static mut PageTable {‚Ä¶}</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o podemos retornar diretamente </font></font><code>MappedPageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de uma fun√ß√£o porque √© comum a um tipo de fechamento. Vamos contornar esse problema com uma constru√ß√£o de sintaxe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>impl Trait</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Uma vantagem adicional √© que voc√™ pode mudar o kernel para </font></font><code>RecursivePageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sem alterar a assinatura da fun√ß√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A fun√ß√£o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>MappedPageTable::new</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">espera dois par√¢metros: um link mut√°vel para a tabela de p√°ginas do n√≠vel 4 e um fechamento </font></font><code>phys_to_virt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que converte o quadro f√≠sico em um ponteiro da tabela de p√°ginas </font></font><code>*mut PageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Para o primeiro par√¢metro, podemos reutilizar a fun√ß√£o </font></font><code>active_level_4_table</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Para o segundo, criamos um fechamento que √© usado </font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para realizar a convers√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tamb√©m a tornamos uma </font></font><code>active_level_4_table</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fun√ß√£o privada, porque a partir de agora ser√° chamada apenas de </font></font><code>init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para usar o m√©todo</font></font><code>MapperAllSizes::translate_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em vez de nossa pr√≥pria fun√ß√£o </font></font><code>memory::translate_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, precisamos alterar apenas algumas linhas em </font></font><code>kernel_main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS // new: different imports use blog_os::memory; use x86_64::{structures::paging::MapperAllSizes, VirtAddr}; // new: initialize a mapper let mapper = unsafe { memory::init(boot_info.physical_memory_offset) }; let addresses = [‚Ä¶]; // same as before for &amp;address in &amp;addresses { let virt = VirtAddr::new(address); // new: use the `mapper.translate_addr` method let phys = mapper.translate_addr(virt); println!("{:?} -&gt; {:?}", virt, phys); } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ap√≥s o in√≠cio, vemos os mesmos resultados de tradu√ß√£o de antes, mas agora apenas p√°ginas grandes tamb√©m funcionam: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/51d/5ed/d9c/51d5edd9c004e1238b321dee51fdf8b3.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como esperado, o endere√ßo virtual √© </font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">convertido em um endere√ßo f√≠sico </font></font><code>0x0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Usando a fun√ß√£o de tradu√ß√£o para o tipo </font></font><code>MappedPageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, eliminamos a necessidade de implementar o suporte para p√°ginas enormes. </font><font style="vertical-align: inherit;">Tamb√©m temos acesso a outras fun√ß√µes da p√°gina, como as </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que ser√£o usadas na pr√≥xima se√ß√£o. </font><font style="vertical-align: inherit;">Nesta fase, n√£o precisamos mais da fun√ß√£o </font></font><code>memory::translate_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, voc√™ pode exclu√≠-la, se desejar.</font></font><br><br><a name="4_4"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crie um novo mapeamento </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At√© agora, analisamos apenas as tabelas de p√°ginas, mas n√£o mudamos nada. </font><font style="vertical-align: inherit;">Vamos criar um novo mapeamento para uma p√°gina n√£o exibida anteriormente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usaremos a fun√ß√£o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>map_to</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">da caracter√≠stica </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>Mapper</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, portanto, primeiro consideraremos essa fun√ß√£o. </font><font style="vertical-align: inherit;">A documenta√ß√£o diz que requer quatro argumentos: a p√°gina que queremos exibir; </font><font style="vertical-align: inherit;">O quadro para o qual a p√°gina deve ser mapeada. </font><font style="vertical-align: inherit;">conjunto de sinalizadores para escrever o distribuidor de quadro e tabela de p√°ginas </font></font><code>frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Um alocador de quadros √© necess√°rio porque o mapeamento desta p√°gina pode exigir a cria√ß√£o de tabelas adicionais que precisam de quadros n√£o utilizados como armazenamento de backup.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fun√ß√£o </font></font><code>create_example_mapping</code> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O primeiro passo em nossa implementa√ß√£o √© criar uma nova fun√ß√£o </font></font><code>create_example_mapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que mapeie esta p√°gina para o </font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quadro f√≠sico do buffer de texto VGA. Selecionamos esse quadro porque facilita verificar se a exibi√ß√£o foi criada corretamente: basta escrever na p√°gina exibida recentemente e ver se ela aparece na tela. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A fun√ß√£o </font></font><code>create_example_mapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fica assim:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::{Page, Size4KiB, Mapper, FrameAllocator}; /// Creates an example mapping for the given page to frame `0xb8000`. pub fn create_example_mapping( page: Page, mapper: &amp;mut impl Mapper&lt;Size4KiB&gt;, frame_allocator: &amp;mut impl FrameAllocator&lt;Size4KiB&gt;, ) { use x86_64::structures::paging::PageTableFlags as Flags; let frame = PhysFrame::containing_address(PhysAddr::new(0xb8000)); let flags = Flags::PRESENT | Flags::WRITABLE; let map_to_result = unsafe { mapper.map_to(page, frame, flags, frame_allocator) }; map_to_result.expect("map_to failed").flush(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m da p√°gina que </font></font><code>page</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">voc√™ deseja mapear, a fun√ß√£o espera uma inst√¢ncia de </font></font><code>mapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. O tipo </font></font><code>mapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementa a caracter√≠stica </font></font><code>Mapper&lt;Size4KiB&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que o m√©todo fornece </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. √â </font></font><code>Size4KiB</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">necess√°rio </font><font style="vertical-align: inherit;">um par√¢metro geral </font><font style="vertical-align: inherit;">, pois a caracter√≠stica </font></font><code>Mapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comum</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para a caracter√≠stica </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PageSize</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, trabalhando com p√°ginas padr√£o de 4 KiB e p√°ginas enormes de 2 MiB e 1 GiB. Queremos criar apenas 4 p√°ginas KiB, para que possamos us√°-lo em </font></font><code>Mapper&lt;Size4KiB&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vez do requisito </font></font><code>MapperAllSizes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para compara√ß√£o, defina o sinalizador </font></font><code>PRESENT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pois √© necess√°rio para todas as entradas v√°lidas e o sinalizador </font></font><code>WRITABLE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para tornar a p√°gina exibida grav√°vel. Desafio</font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inseguro: voc√™ pode violar a seguran√ßa da mem√≥ria com argumentos inv√°lidos; portanto, voc√™ deve usar um bloco </font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para obter uma lista de todos os sinalizadores poss√≠veis, consulte a se√ß√£o ‚ÄúFormato da tabela de p√°ginas‚Äù do </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artigo anterior</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A fun√ß√£o </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode falhar e, portanto, retorna </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Result</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Como este √© apenas um exemplo de c√≥digo que n√£o deve ser confi√°vel, simplesmente o usamos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>expect</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para entrar em p√¢nico no caso de um erro. </font><font style="vertical-align: inherit;">Se for bem sucedido, a fun√ß√£o retorna do tipo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>MapperFlush</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que proporciona um m√©todo simples de limpeza recentemente foi apresentado no buffer de p√°gina da tradu√ß√£o din√¢mica (TLB) pelo m√©todo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>flush</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Assim </font></font><code>Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, esse tipo aplica o atributo [ </font></font><code>#[must_use]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">] a</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">emitir um aviso se esquecermos acidentalmente de us√°-lo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fict√≠cio </font></font><code>FrameAllocator</code> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para ligar </font></font><code>create_example_mapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, voc√™ deve primeiro criar </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Como observado acima, a complexidade de criar uma nova exibi√ß√£o depende da p√°gina virtual que queremos exibir. </font><font style="vertical-align: inherit;">No caso mais simples, j√° existe uma tabela de n√≠vel 1 para a p√°gina e precisamos apenas fazer um registro. </font><font style="vertical-align: inherit;">No caso mais dif√≠cil, a p√°gina est√° em uma √°rea de mem√≥ria para a qual o n√≠vel 3 ainda n√£o foi criado, portanto, primeiro voc√™ ter√° que criar tabelas de n√≠veis 3, 2 e 1. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos come√ßar com um caso simples e supor que voc√™ n√£o precisa criar novas tabelas de p√°ginas. </font><font style="vertical-align: inherit;">Um distribuidor de quadros que sempre retorna √© suficiente para isso </font></font><code>None</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Criamos uma </font></font><code>EmptyFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fun√ß√£o de exibi√ß√£o para teste:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs /// A FrameAllocator that always returns `None`. pub struct EmptyFrameAllocator; impl FrameAllocator&lt;Size4KiB&gt; for EmptyFrameAllocator { fn allocate_frame(&amp;mut self) -&gt; Option&lt;PhysFrame&gt; { None } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora voc√™ precisa encontrar uma p√°gina que possa ser exibida sem criar novas tabelas de p√°ginas. O carregador √© carregado no primeiro megabyte do espa√ßo de endere√ßo virtual, portanto, sabemos que para esta regi√£o h√° uma tabela v√°lida de n√≠vel 1. No nosso exemplo, podemos selecionar qualquer p√°gina n√£o utilizada nesta √°rea de mem√≥ria, por exemplo, a p√°gina no endere√ßo </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para testar a fun√ß√£o, primeiro exibimos a p√°gina </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e, em seguida, exibimos o conte√∫do da mem√≥ria:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS use blog_os::memory; use x86_64::{structures::paging::Page, VirtAddr}; let mut mapper = unsafe { memory::init(boot_info.physical_memory_offset) }; let mut frame_allocator = memory::EmptyFrameAllocator; // map a previously unmapped page let page = Page::containing_address(VirtAddr::new(0x1000)); memory::create_example_mapping(page, &amp;mut mapper, &amp;mut frame_allocator); // write the string `New!` to the screen through the new mapping let page_ptr: *mut u64 = page.start_address().as_mut_ptr(); unsafe { page_ptr.offset(400).write_volatile(0x_f021_f077_f065_f04e)}; println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro, criamos um mapeamento para a p√°gina </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, chamando uma fun√ß√£o </font></font><code>create_example_mapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com um link mut√°vel para inst√¢ncias </font></font><code>mapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Isso mapeia a p√°gina </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para o quadro de buffer de texto VGA, portanto, devemos ver o que est√° escrito na tela. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, converta a p√°gina em um ponteiro bruto e escreva o valor no deslocamento </font></font><code>400</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. N√£o escrevemos no topo da p√°gina porque a linha superior do buffer VGA √© diretamente deslocada da tela da seguinte maneira </font></font><code>println</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Escreva o valor </font></font><code>0x_f021_f077_f065_f04e</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que corresponde √† string </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"New!"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sobre um fundo branco Como aprendemos no artigo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Modo de texto VGA"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a grava√ß√£o no buffer VGA deve ser vol√°til, por isso usamos o m√©todo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>write_volatile</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando executamos o c√≥digo no QEMU, vemos o seguinte resultado: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4cf/248/1a0/4cf2481a07f40c681954ff4954dce866.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de escrever na p√°gina </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a inscri√ß√£o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Novo!"</font></font></i>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, criamos com sucesso um novo mapeamento nas tabelas de p√°ginas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esse agrupamento funcionou porque j√° havia uma tabela de n√≠vel 1 para agrupamento </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Quando tentamos mapear uma p√°gina para a qual ainda n√£o existe uma tabela de n√≠vel 1, a fun√ß√£o </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falha porque tenta alocar quadros </font></font><code>EmptyFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para criar novas tabelas. </font><font style="vertical-align: inherit;">Vemos que isso acontece quando tentamos exibir a p√°gina em </font></font><code>0xdeadbeaf000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vez de </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] let page = Page::containing_address(VirtAddr::new(0xdeadbeaf000)); [‚Ä¶] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se isso for iniciado, ocorrer√° um p√¢nico com a seguinte mensagem de erro: </font></font><br><br><pre> <code class="plaintext hljs">panicked at 'map_to failed: FrameAllocationFailed', /‚Ä¶/result.rs:999:5</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para exibir p√°ginas que ainda n√£o possuem uma tabela de n√≠vel 1, √© necess√°rio criar a correta </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mas como voc√™ sabe quais quadros s√£o gratuitos e quanta mem√≥ria f√≠sica est√° dispon√≠vel?</font></font><br><br><a name="4_5"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sele√ß√£o de quadro </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para novas tabelas de p√°ginas, voc√™ precisa criar o distribuidor de quadros correto. </font><font style="vertical-align: inherit;">Vamos come√ßar com o esqueleto geral:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs pub struct BootInfoFrameAllocator&lt;I&gt; where I: Iterator&lt;Item = PhysFrame&gt; { frames: I, } impl&lt;I&gt; FrameAllocator&lt;Size4KiB&gt; for BootInfoFrameAllocator&lt;I&gt; where I: Iterator&lt;Item = PhysFrame&gt; { fn allocate_frame(&amp;mut self) -&gt; Option&lt;PhysFrame&gt; { self.frames.next() } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O campo </font></font><code>frames</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode ser inicializado com um iterador de quadro arbitr√°rio. Isso permite que voc√™ simplesmente delegue chamadas ao </font></font><code>alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>Iterator::next</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para a inicializa√ß√£o, </font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usamos o cart√£o de mem√≥ria </font></font><code>memory_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que o gerenciador de inicializa√ß√£o transfere como parte da estrutura </font></font><code>BootInfo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Conforme explicado na </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se√ß√£o Informa√ß√µes de inicializa√ß√£o</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o cart√£o de mem√≥ria √© fornecido pelo firmware BIOS / UEFI. Ele pode ser solicitado apenas no in√≠cio do processo de inicializa√ß√£o, portanto, o carregador de inicializa√ß√£o j√° chamou as fun√ß√µes necess√°rias. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um cart√£o de mem√≥ria consiste em uma lista de estruturas </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>MemoryRegion</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que cont√™m o endere√ßo inicial, comprimento e tipo (por exemplo, n√£o utilizados, reservados, etc.) de cada √°rea de mem√≥ria. Criando um iterador que produz quadros de √°reas n√£o utilizadas, podemos criar um v√°lido </font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A inicializa√ß√£o </font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ocorre em uma nova fun√ß√£o </font></font><code>init_frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use bootloader::bootinfo::{MemoryMap, MemoryRegionType}; /// Create a FrameAllocator from the passed memory map pub fn init_frame_allocator( memory_map: &amp;'static MemoryMap, ) -&gt; BootInfoFrameAllocator&lt;impl Iterator&lt;Item = PhysFrame&gt;&gt; { // get usable regions from memory map let regions = memory_map .iter() .filter(|r| r.region_type == MemoryRegionType::Usable); // map each region to its address range let addr_ranges = regions.map(|r| r.range.start_addr()..r.range.end_addr()); // transform to an iterator of frame start addresses let frame_addresses = addr_ranges.flat_map(|r| r.step_by(4096)); // create `PhysFrame` types from the start addresses let frames = frame_addresses.map(|addr| { PhysFrame::containing_address(PhysAddr::new(addr)) }); BootInfoFrameAllocator { frames } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta fun√ß√£o usa um combinador para converter o mapa inicial </font></font><code>MemoryMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em um iterador dos quadros f√≠sicos usados:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro, chamamos o m√©todo </font></font><code>iter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para converter o cart√£o de mem√≥ria em um iterador </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>MemoryRegion</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Em seguida, usamos o m√©todo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>filter</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para pular regi√µes reservadas ou inacess√≠veis. </font><font style="vertical-align: inherit;">O carregador atualiza o cart√£o de mem√≥ria para todos os mapeamentos criados, para que os quadros usados ‚Äã‚Äãpelo kernel (c√≥digo, dados ou pilha) ou para armazenar informa√ß√µes sobre a inicializa√ß√£o j√° estejam marcados como </font></font><code>InUse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou de forma semelhante. </font><font style="vertical-align: inherit;">Assim, podemos ter certeza de que os quadros </font></font><code>Usable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o </font><font style="vertical-align: inherit;">s√£o </font><font style="vertical-align: inherit;">usados ‚Äã‚Äãem </font><font style="vertical-align: inherit;">outros lugares </font><font style="vertical-align: inherit;">.</font></font><br></li><li>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>map</code></a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">range</a>  Rust         . <br></li><li>    :         <code>into_iter</code> ,     4096-    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>step_by</code></a> .  4096  (= 4 ) ‚Äî   ,      .      ,         .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>flat_map</code></a>  <code>map</code> ,   <code>Iterator&lt;Item = u64&gt;</code>  <code>Iterator&lt;Item = Iterator&lt;Item = u64&gt;&gt;</code> . <br></li><li>         <code>PhysFrame</code> ,    <code>Iterator&lt;Item = PhysFrame&gt;</code> .          <code>BootInfoFrameAllocator</code> . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora voc√™ pode alterar a nossa fun√ß√£o </font></font><code>kernel_main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para transmitir uma c√≥pia </font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ao inv√©s </font></font><code>EmptyFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] let mut frame_allocator = memory::init_frame_allocator(&amp;boot_info.memory_map); [‚Ä¶] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dessa vez, o mapeamento de endere√ßos foi bem-sucedido e novamente vemos o preto e branco </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Novo!"</font></font></i>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nos bastidores, o m√©todo </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cria tabelas de p√°ginas ausentes da seguinte maneira:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selecione um quadro n√£o utilizado do quadro transmitido </font></font><code>frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zero quadro para criar uma nova tabela de p√°gina vazia. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mapeie uma entrada da tabela de n√≠vel superior para esse quadro. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V√° para o pr√≥ximo n√≠vel da tabela. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora nossa fun√ß√£o </font></font><code>create_example_mapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seja apenas um exemplo de c√≥digo, agora podemos criar novos mapeamentos para p√°ginas arbitr√°rias. </font><font style="vertical-align: inherit;">Isso ser√° necess√°rio para alocar mem√≥ria e implementar multithreading em artigos futuros.</font></font><br><br><a name="5"></a><h1>  Sum√°rio </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neste artigo, aprendemos sobre v√°rios m√©todos de acesso aos quadros f√≠sicos das tabelas de p√°ginas, incluindo mapeamento de identidade, mapeamento de mem√≥ria f√≠sica completa, mapeamento tempor√°rio e tabelas de p√°ginas recursivas. Optamos por exibir a mem√≥ria f√≠sica completa como um m√©todo simples e poderoso. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o podemos mapear a mem√≥ria f√≠sica do kernel sem acesso √† tabela de p√°ginas, portanto, o suporte ao carregador de inicializa√ß√£o √© necess√°rio. O rack </font></font><code>bootloader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cria os mapeamentos necess√°rios por meio de fun√ß√µes adicionais de carga. Ele passa as informa√ß√µes necess√°rias para o kernel como um argumento </font></font><code>&amp;BootInfo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para a fun√ß√£o de ponto de entrada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para nossa implementa√ß√£o, primeiro examinamos manualmente as tabelas de p√°ginas, fizemos uma fun√ß√£o de tradu√ß√£o e depois usamos o tipo de </font></font><code>MappedPageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">caixa</font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tamb√©m aprendemos como criar novos mapeamentos na tabela de p√°ginas e como faz√™-los </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em um cart√£o de mem√≥ria transmitido pelo gerenciador de inicializa√ß√£o.</font></font><br><br><a name="6"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O que vem a seguir? </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No pr√≥ximo artigo, criaremos uma √°rea de mem√≥ria heap para o nosso kernel, que permitir√° </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alocar mem√≥ria</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e usar diferentes </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tipos de cole√ß√µes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt445618/">https://habr.com/ru/post/pt445618/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt445596/index.html">Dicas e truques do Kubernetes: p√°ginas de erro personalizadas no NGINX Ingress</a></li>
<li><a href="../pt445600/index.html">[Poll e evil] Hostings, estejam eles errados</a></li>
<li><a href="../pt445602/index.html">PHP Russia 2019: seu ‚Äúest√°dio‚Äù para o idioma da primeira liga</a></li>
<li><a href="../pt445608/index.html">Fim do jogo: analistas relatam um aumento no n√∫mero de ataques DDoS no segmento de jogos</a></li>
<li><a href="../pt445612/index.html">Armazenamento de cluster para pequenos clusters da Web com base em drbd + ocfs2</a></li>
<li><a href="../pt445620/index.html">O que um escritor de UX faz?</a></li>
<li><a href="../pt445622/index.html">Novo no Java 12: O Teeing Collector</a></li>
<li><a href="../pt445626/index.html">Qual a profundidade da toca do coelho? CLRium # 5: Coletor de Lixo</a></li>
<li><a href="../pt445632/index.html">Do analisador do p√¥ster do teatro Python ao bot do Telegram. Parte 2</a></li>
<li><a href="../pt445638/index.html">Est√°gio cego no Garage Museum of Modern Art</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>