<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍💻 ◻️ 🐠 Nós escrevemos um sistema operacional no Rust. Implementando a memória da página (nova) 👩🏿‍🔧 🐏 ⛸️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Neste artigo, descobriremos como implementar o suporte à memória da página em nosso núcleo. Primeiro, estudaremos vários métodos para que os quadros d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nós escrevemos um sistema operacional no Rust. Implementando a memória da página (nova)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445618/">  Neste artigo, descobriremos como implementar o suporte à memória da página em nosso núcleo.  Primeiro, estudaremos vários métodos para que os quadros da tabela de páginas físicas fiquem disponíveis para o kernel e discutiremos suas vantagens e desvantagens.  Em seguida, implementamos a função de conversão de endereço e a função de criar um novo mapeamento. <br><br>  Esta série de artigos publicados no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> .  Se você tiver alguma dúvida ou problema, abra o ticket correspondente lá.  Todas as fontes para o artigo estão <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste segmento</a> . <br><br>  <i><b>Outro artigo sobre paginação?</b></i> <i><br></i>  <i>Se você seguir esse ciclo, verá o artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">“Memória da página: nível avançado”</a> no final de janeiro.</i>  <i>Mas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fui criticado</a> por tabelas de páginas recursivas.</i>  <i>Portanto, decidi reescrever o artigo, usando uma abordagem diferente para acessar quadros.</i> <br><a name="habracut"></a><br>  <i>Aqui está uma nova opção.</i>  <i>O artigo ainda explica como as tabelas de páginas recursivas funcionam, mas usamos uma implementação mais simples e poderosa.</i>  <i>Não excluiremos o artigo anterior, mas marcaremos como desatualizado e não o atualizaremos.</i> <i><br><br></i>  <i>Espero que você goste da nova opção!</i> <br><br><h1>  Conteúdo </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1. Introdução</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Atualizações de dependência</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Acesso a tabelas de páginas</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapeamento de identidade</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapa de deslocamento fixo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapeamento completo da memória física</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Exibição temporária</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tabelas de páginas recursivas</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Suporte ao carregador de inicialização</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Informações de inicialização</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Macro do ponto de entrada</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Implementação</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Acesso a tabelas de páginas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tradução de endereços</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Usando MappedPageTable</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Crie um novo mapeamento</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Seleção de quadro</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sumário</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O que vem a seguir?</a> </li></ul><br><a name="1"></a><h1>  1. Introdução </h1><br>  No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">último artigo,</a> aprendemos sobre os princípios da memória de paginação e como funcionam as tabelas de página de quatro níveis no <code>x86_64</code> .  Também descobrimos que o carregador já configurou a hierarquia da tabela de páginas para nosso kernel, portanto, o kernel é executado em endereços virtuais.  Isso aumenta a segurança porque o acesso não autorizado à memória causa uma falha na página em vez de alterar aleatoriamente a memória física. <br><br>  O artigo acabou não conseguindo acessar as tabelas de páginas do nosso kernel, porque elas são armazenadas na memória física e o kernel já está sendo executado em endereços virtuais.  Aqui continuamos o tópico e exploramos diferentes opções para acessar os quadros da tabela de páginas no kernel.  Discutiremos as vantagens e desvantagens de cada um deles e, em seguida, escolheremos a opção apropriada para nosso núcleo. <br><br>  O suporte ao carregador de inicialização é necessário, portanto, vamos configurá-lo primeiro.  Em seguida, implementamos uma função que percorre toda a hierarquia de tabelas de páginas, a fim de converter endereços virtuais em físicos.  Por fim, aprenderemos como criar novos mapeamentos em tabelas de páginas e como encontrar quadros de memória não utilizados para criar novas tabelas. <br><br><a name="1_1"></a><h3>  Atualizações de dependência </h3><br>  Este artigo requer que você registre o <code>bootloader</code> versão 0.4.0 ou superior e <code>x86_64</code> versão 0.5.2 ou superior nas dependências.  Você pode atualizar as dependências no <code>Cargo.toml</code> : <br><br><pre> <code class="plaintext hljs">[dependencies] bootloader = "0.4.0" x86_64 = "0.5.2"</code> </pre> <br>  Para alterações nessas versões, consulte <a href="">o log do carregador de inicialização</a> e o <a href="">log x86_64</a> . <br><br><a name="2"></a><h1>  Acesso a tabelas de páginas </h1><br>  Acessar tabelas de páginas do kernel não é tão fácil quanto parece.  Para entender o problema, dê uma olhada na hierarquia de tabela de quatro níveis do artigo anterior: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c8/5e8/a14/9c85e8a145a9078cfcfd92e204f69a5b.svg"></div><br><br>  O importante é que cada entrada da página armazene o endereço <i>físico</i> da próxima tabela.  Isso evita a tradução desses endereços, o que reduz o desempenho e leva facilmente a loops sem fim. <br><br>  O problema é que não podemos acessar diretamente endereços físicos do kernel, pois ele também funciona em endereços virtuais.  Por exemplo, quando vamos para o endereço <code>4 KiB</code> , obtemos acesso ao endereço <i>virtual</i> <code>4 KiB</code> , e não ao endereço <i>físico</i> onde a tabela de páginas do 4º nível está armazenada.  Se queremos acessar o endereço físico de <code>4 KiB</code> , precisamos usar um endereço virtual, que é traduzido para ele. <br><br>  Portanto, para acessar os quadros das tabelas de páginas, é necessário mapear algumas páginas virtuais para esses quadros.  Existem diferentes maneiras de criar esses mapeamentos. <br><br><a name="2_1"></a><h3>  Mapeamento de identidade </h3><br>  Uma solução simples é a <b>exibição idêntica de todas as tabelas de páginas</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/813/916/8f3813916cd0a5b5174c8d14dabedb7a.svg"></div><br><br>  Neste exemplo, vemos a exibição idêntica de quadros.  Os endereços físicos das tabelas de páginas são ao mesmo tempo endereços virtuais válidos, para que possamos acessar facilmente as tabelas de páginas de todos os níveis, começando com o registro CR3. <br><br>  No entanto, essa abordagem confunde o espaço de endereço virtual e dificulta a descoberta de grandes áreas contíguas de memória livre.  Digamos que queremos criar uma área de memória virtual de 1000 KiB na figura acima, por exemplo, para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">exibir um arquivo na memória</a> .  Não podemos começar com a região de <code>28 KiB</code> , porque ela fica em uma página já ocupada em <code>1004  KiB</code> .  Portanto, você precisará procurar mais até encontrarmos um fragmento grande e adequado, por exemplo, com <code>1008  KiB</code> .  Há o mesmo problema de fragmentação da memória segmentada. <br><br>  Além disso, a criação de novas tabelas de páginas é muito mais complicada, pois precisamos encontrar quadros físicos cujas páginas correspondentes ainda não foram usadas.  Por exemplo, para o nosso arquivo, reservamos uma área de 1000 KiB de memória <i>virtual</i> , começando no endereço <code>1008  KiB</code> .  Agora não podemos mais usar nenhum quadro com um endereço físico entre <code>1000  KiB</code> e <code>2008  KiB</code> , porque ele não pode ser exibido de forma idêntica. <br><br><a name="2_2"></a><h3>  Mapa de deslocamento fixo </h3><br>  Para evitar sobrecarregar o espaço de endereço virtual, você pode exibir as tabelas de páginas em uma <b>área de memória separada</b> .  Portanto, em vez de identificar o mapeamento, mapeamos quadros com um deslocamento fixo no espaço de endereço virtual.  Por exemplo, o deslocamento pode ser 10 TiB: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f4a/c8a/5ea/f4ac8a5ea64fd215de176248b5f74e20.svg"><br><br>  Ao alocar esse intervalo de memória virtual exclusivamente para a exibição de tabelas de páginas, evitamos os problemas de exibição idêntica.  A reserva de uma área tão grande do espaço de endereço virtual só é possível se o espaço de endereço virtual for muito maior que o tamanho da memória física.  No <code>x86_64</code> isso não é um problema, porque o espaço de endereço de 48 bits é de 256 TiB. <br><br>  Mas essa abordagem tem a desvantagem de que, ao criar cada tabela de páginas, você precisa criar um novo mapeamento.  Além disso, ele não permite o acesso a tabelas em outros espaços de endereço, o que seria útil ao criar um novo processo. <br><br><a name="2_3"></a><h3>  Mapeamento completo da memória física </h3><br>  Podemos resolver esses problemas <b>exibindo toda a memória física</b> , e não apenas os quadros da tabela de página: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c39/3cf/7df/c393cf7df76515739e1d9274160c4b5d.svg"><br><br>  Essa abordagem permite que o kernel acesse memória física arbitrária, incluindo quadros de tabela de página de outros espaços de endereço.  Um intervalo de memória virtual está reservado com o mesmo tamanho de antes, mas somente não há páginas sem correspondência nele. <br><br>  A desvantagem dessa abordagem é que são necessárias tabelas de páginas adicionais para exibir a memória física.  Essas tabelas de páginas devem ser armazenadas em algum lugar, para que elas usem parte da memória física, o que pode ser um problema em dispositivos com uma pequena quantidade de RAM. <br><br>  No entanto, no x86_64, podemos usar 2 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">páginas</a> MiB <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">enormes</a> para exibir, em vez do tamanho padrão de 4 KiB.  Portanto, para exibir 32 GiB de memória física, apenas 132 KiB por tabela de página são necessárias: apenas uma tabela de terceiro nível e 32 tabelas de segundo nível.  Páginas enormes também são armazenadas em cache de maneira mais eficiente, porque usam menos entradas no buffer de tradução dinâmico (TLB). <br><br><a name="2_4"></a><h3>  Exibição temporária </h3><br>  Para dispositivos com muito pouca memória física, você só pode <b>exibir tabelas de páginas temporariamente</b> quando precisar acessá-las.  Para comparações temporárias, é necessária uma exibição idêntica apenas da tabela de primeiro nível: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00a/3ab/5ce/00a3ab5ce85057d3679a48379d3d2297.svg"></div><br><br>  Nesta figura, uma tabela de nível 1 gerencia os 2 primeiros MiB de espaço de endereço virtual.  Isso é possível porque o acesso a partir do registro CR3 é feito através de zero entradas nas tabelas dos níveis 4, 3 e 2. O registro com o índice <code>8</code> converte a página virtual em <code>32 KiB</code> em um quadro físico em <code>32 KiB</code> , identificando a própria tabela de nível 1. Na figura, isso é mostrado por uma seta horizontal. <br><br>  Ao escrever na tabela de nível 1 mapeada de forma idêntica, nosso kernel pode criar até 511 comparações de tempo (512 menos o registro necessário para o mapeamento de identidade).  No exemplo acima, o kernel cria duas comparações de tempo: <br><br><ul><li>  Mapeando uma entrada nula em uma tabela de nível 1 para um quadro em <code>24 KiB</code> .  Isso cria um mapeamento temporário da página virtual em <code>0 KiB</code> para o quadro físico da tabela de nível 2 da página indicado pela seta pontilhada. </li><li>  Combine o nono registro de uma tabela de nível 1 com um quadro em <code>4 KiB</code> .  Isso cria um mapeamento temporário da página virtual em <code>36 KiB</code> para o quadro físico da tabela de nível 4 da página indicada pela seta pontilhada. </li></ul><br>  Agora o kernel pode acessar uma tabela de nível 2 gravando em uma página que começa em <code>0 KiB</code> e uma tabela de nível 4 gravando em uma página que começa em <code>33 KiB</code> . <br><br>  Portanto, o acesso a um quadro arbitrário da tabela de páginas com mapeamentos temporários consiste nas seguintes ações: <br><br><ul><li>  Encontre uma entrada gratuita na tabela de nível 1 exibida de forma idêntica. <br></li><li>  Mapeie essa entrada para o quadro físico da tabela de páginas que queremos acessar. <br></li><li>  Acesse esse quadro através da página virtual associada à entrada. <br></li><li>  Defina o registro novamente como não utilizado, removendo o mapeamento temporário. </li></ul><br>  Com essa abordagem, o espaço de endereço virtual permanece limpo, pois as mesmas 512 páginas virtuais são usadas constantemente.  A desvantagem é uma certa dificuldade, especialmente porque uma nova comparação pode exigir a alteração de vários níveis da tabela, ou seja, precisamos repetir o processo descrito várias vezes. <br><br><a name="2_5"></a><h3>  Tabelas de páginas recursivas </h3><br>  Outra abordagem interessante que não requer tabelas de páginas adicionais é <b>a correspondência recursiva</b> . <br><br>  A idéia é traduzir alguns registros da tabela de quarto nível para ela mesma.  Assim, reservamos uma parte do espaço de endereço virtual e mapeamos todos os quadros de tabela atuais e futuros para esse espaço. <br><br>  Vejamos um exemplo para entender como tudo isso funciona: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/779/ee6/d9b/779ee6d9bf771dec8e6d22c0440e503d.png"></div><br><br>  A única diferença do exemplo no início do artigo é um registro adicional com o índice <code>511</code> na tabela de nível 4, que é mapeado para o quadro físico <code>4 KiB</code> , localizado nesta tabela em si. <br><br>  Quando a CPU entra nesse registro, ela não se refere à tabela de nível 3, mas novamente à tabela de nível 4. Isso é semelhante a uma função recursiva que se chama.  É importante que o processador assuma que cada entrada na tabela de nível 4 aponta para uma tabela de nível 3. Portanto, agora ela trata a tabela de nível 4 como uma tabela de nível 3. Isso funciona porque as tabelas de todos os níveis em x86_64 têm a mesma estrutura. <br><br>  Seguindo um registro recursivo uma ou mais vezes antes de iniciar a conversão real, podemos reduzir efetivamente o número de níveis pelos quais o processador passa.  Por exemplo, se seguirmos o registro recursivo uma vez e depois formos para a tabela de nível 3, o processador achará que a tabela de nível 3 é uma tabela de nível 2. Seguindo em frente, ele considera a tabela de nível 2 como uma tabela de nível 1 e a tabela de nível 1 como mapeada quadro na memória física.  Isso significa que agora podemos ler e gravar na tabela de nível 1 da página, porque o processador pensa que esse é um quadro mapeado.  A figura abaixo mostra as cinco etapas dessa tradução: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/ac7/191/bdaac719103c574c655efa3604d0b842.png"></div><br><br>  Da mesma forma, podemos seguir uma entrada recursiva duas vezes antes de iniciar a conversão para reduzir o número de níveis passados ​​para dois: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f4/b9a/c47/7f4b9ac47fce9552dead4e551b804256.png"></div><br><br>  Vamos seguir este procedimento passo a passo.  Primeiro, a CPU segue uma entrada recursiva na tabela de nível 4 e pensa que alcançou a tabela de nível 3. Em seguida, segue o registro recursivo novamente e pensa que alcançou o nível 2. Mas, na realidade, ainda está no nível 4. Em seguida, a CPU vai para o novo endereço e entra na tabela de nível 3, mas acha que já está na tabela de nível 1. Por fim, no próximo ponto de entrada da tabela de nível 2, o processador acha que acessou o quadro de memória física.  Isso nos permite ler e gravar em uma tabela de nível 2. <br><br>  Também são acessadas as tabelas dos níveis 3 e 4. Para acessar a tabela do nível 3, seguimos um registro recursivo três vezes: o processador pensa que já está na tabela do nível 1 e, na próxima etapa, atingimos o nível 3, que a CPU considera como um quadro mapeado.  Para acessar a tabela de nível 4, basta seguir o registro recursivo quatro vezes até que o processador processe a tabela de nível 4 como um quadro mapeado (em azul na figura abaixo). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/487/a82/92c/487a8292cf8fe673f1914f5f198c0956.png"></div><br><br>  O conceito é difícil de entender a princípio, mas, na prática, funciona muito bem. <br><br><h4>  Cálculo de endereço </h4><br>  Assim, podemos acessar tabelas de todos os níveis seguindo um registro recursivo uma ou mais vezes.  Como os índices em tabelas de quatro níveis são derivados diretamente do endereço virtual, endereços virtuais especiais devem ser criados para esse método.  Como lembramos, os índices da tabela de páginas são extraídos do endereço da seguinte maneira: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c44/33c/8f9/c4433c8f99b6fcb54d4b79983ca35dbc.svg"></div><br><br>  Suponha que desejamos acessar uma tabela de nível 1 que exibe uma página específica.  Como aprendemos acima, você precisa passar por um registro recursivo uma vez e depois pelos índices do 4º, 3º e 2º níveis.  Para fazer isso, movemos todos os blocos de endereço um bloco para a direita e configuramos o índice do registro recursivo para o local do índice inicial do nível 4: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62a/d82/b54/62ad82b54b233a37e40b964953a16bf8.svg"></div><br><br>  Para acessar a tabela de nível 2 desta página, movemos todos os blocos de índice dois blocos para a direita e configuramos o índice recursivo para o local dos dois blocos de origem: nível 4 e nível 3: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d9/ae5/7c8/1d9ae57c8c68a0b239e5b37397a4d0f7.svg"></div><br><br>  Para acessar a tabela de nível 3, fazemos o mesmo, apenas mudamos para a direita, já com três blocos de endereços. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b8/6ee/c9f/4b86eec9fd1df3445718ed8246fd4473.svg"></div><br><br>  Finalmente, para acessar a tabela de nível 4, mova todos os quatro blocos para a direita. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36b/6b0/29b/36b6b029b31578b143ff1e7605e358fb.svg"></div><br><br>  Agora você pode calcular endereços virtuais para tabelas de páginas dos quatro níveis.  Podemos até calcular um endereço que aponte exatamente para uma entrada específica da tabela de páginas multiplicando seu índice por 8, o tamanho da entrada da tabela de páginas. <br><br>  A tabela abaixo mostra a estrutura de endereços para acessar vários tipos de quadros: <br><br><table><thead><tr><th>  Endereço virtual para </th><th>  Estrutura de endereço ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">octal</a> ) </th></tr></thead><tbody><tr><td>  Page </td><td> <code>0o_SSSSSS_AAA_BBB_CCC_DDD_EEEE</code> </td> </tr><tr><td>  Entrada na tabela de nível 1 </td><td> <code>0o_SSSSSS_RRR_AAA_BBB_CCC_DDDD</code> </td> </tr><tr><td>  Entrada em uma tabela de nível 2 </td><td> <code>0o_SSSSSS_RRR_RRR_AAA_BBB_CCCC</code> </td> </tr><tr><td>  Entrada em uma tabela de nível 3 </td><td> <code>0o_SSSSSS_RRR_RRR_RRR_AAA_BBBB</code> </td> </tr><tr><td>  Entrada na tabela de nível 4 </td><td> <code>0o_SSSSSS_RRR_RRR_RRR_RRR_AAAA</code> </td> </tr></tbody></table><br>  Aqui, <code></code> é o índice de nível 4, <code></code> é o nível 3, <code></code> é o nível 2 e <code>DDD</code> é o índice de nível 1 para o quadro exibido, <code>EEEE</code> é o seu deslocamento.  <code>RRR</code> é o índice do registro recursivo.  Um índice (três dígitos) é convertido em um deslocamento (quatro dígitos) multiplicando por 8 (o tamanho da entrada da tabela da página).  Com esse deslocamento, o endereço resultante aponta diretamente para a entrada da tabela de páginas correspondente. <br><br>  <code>SSSS</code> são bits de expansão do dígito assinado, ou seja, são cópias do bit 47. Esse é um requisito especial para endereços válidos na arquitetura x86_64, que discutimos em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo anterior</a> . <br><br>  Os endereços são <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">octais</a> , pois cada caractere octal representa três bits, o que permite separar claramente os índices de 9 bits das tabelas em diferentes níveis.  Isso não é possível no sistema hexadecimal, onde cada caractere representa quatro bits. <br><br><h4>  Código de ferrugem </h4><br>  Você pode construir esses endereços no código Rust usando operações bit a bit: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// the virtual address whose corresponding page tables you want to access let addr: usize = […]; let r = 0o777; // recursive index let sign = 0o177777 &lt;&lt; 48; // sign extension // retrieve the page table indices of the address that we want to translate let l4_idx = (addr &gt;&gt; 39) &amp; 0o777; // level 4 index let l3_idx = (addr &gt;&gt; 30) &amp; 0o777; // level 3 index let l2_idx = (addr &gt;&gt; 21) &amp; 0o777; // level 2 index let l1_idx = (addr &gt;&gt; 12) &amp; 0o777; // level 1 index let page_offset = addr &amp; 0o7777; // calculate the table addresses let level_4_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (r &lt;&lt; 21) | (r &lt;&lt; 12); let level_3_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (r &lt;&lt; 21) | (l4_idx &lt;&lt; 12); let level_2_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (l4_idx &lt;&lt; 21) | (l3_idx &lt;&lt; 12); let level_1_table_addr = sign | (r &lt;&lt; 39) | (l4_idx &lt;&lt; 30) | (l3_idx &lt;&lt; 21) | (l2_idx &lt;&lt; 12);</span></span></code> </pre> <br>  Esse código pressupõe que um mapeamento recursivo do último registro de nível 4 com o índice <code>0o777</code> (511) seja correspondido recursivamente.  Atualmente não é o caso, portanto o código ainda não funcionará.  Veja abaixo como instruir o carregador a configurar um mapeamento recursivo. <br><br>  Como alternativa à execução manual de operações bit a bit, você pode usar o tipo <code>RecursivePageTable</code> da caixa <code>x86_64</code> , que fornece abstrações seguras para várias operações da tabela.  Por exemplo, o código abaixo mostra como converter um endereço virtual em seu endereço físico correspondente: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::{Mapper, Page, PageTable, RecursivePageTable}; use x86_64::{VirtAddr, PhysAddr}; /// Creates a RecursivePageTable instance from the level 4 address. let level_4_table_addr = […]; let level_4_table_ptr = level_4_table_addr as *mut PageTable; let recursive_page_table = unsafe { let level_4_table = &amp;mut *level_4_table_ptr; RecursivePageTable::new(level_4_table).unwrap(); } /// Retrieve the physical address for the given virtual address let addr: u64 = […] let addr = VirtAddr::new(addr); let page: Page = Page::containing_address(addr); // perform the translation let frame = recursive_page_table.translate_page(page); frame.map(|frame| frame.start_address() + u64::from(addr.page_offset()))</span></span></code> </pre> <br>  Novamente, esse código requer um mapeamento recursivo correto.  Com esse mapeamento, o <code>level_4_table_addr</code> ausente <code>level_4_table_addr</code> calculado como no primeiro exemplo de código. <br><br><hr><br>  O mapeamento recursivo é um método interessante que mostra o quão poderosa pode ser a correspondência através de uma única tabela.  É relativamente fácil de implementar e requer apenas configuração mínima (apenas uma entrada recursiva), portanto, essa é uma boa opção para as primeiras experiências. <br><br>  Mas tem algumas desvantagens: <br><br><ul><li>  Uma grande quantidade de memória virtual (512 GiB).  Isso não é um problema em um espaço de endereço grande de 48 bits, mas pode levar a um comportamento de cache abaixo do ideal. <br></li><li>  Facilmente, dá acesso apenas ao espaço de endereço atualmente ativo.  O acesso a outros espaços de endereço ainda é possível alterando a entrada recursiva, mas a correspondência temporária é necessária para a alternância.  Descrevemos como fazer isso em um artigo anterior (obsoleto). <br></li><li>  Depende muito do formato da tabela de páginas x86 e pode não funcionar em outras arquiteturas. </li></ul><br><a name="3"></a><h1>  Suporte ao carregador de inicialização </h1><br>  Todas as abordagens descritas acima requerem alterações nas tabelas de páginas e nas configurações correspondentes.  Por exemplo, para mapear a memória física de forma idêntica ou recursiva, mapeie registros de uma tabela de quarto nível.  O problema é que não podemos fazer essas configurações sem acessar as tabelas de páginas. <br><br>  Então, preciso de ajuda do gerenciador de inicialização.  Ele tem acesso a tabelas de páginas, para que ele possa criar qualquer exibição necessária.  Na sua implementação atual, o caixote do <code>bootloader</code> suporta as duas abordagens acima usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">funções de carga</a> : <br><br><ul><li>  A função <code>map_physical_memory</code> mapeia a memória física completa em algum lugar do espaço de endereço virtual.  Assim, o kernel obtém acesso a toda a memória física e pode aplicar uma abordagem com a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">exibição da memória física completa</a> . <br></li><li>  Usando a função <code>recursive_page_table</code> , o carregador exibe recursivamente uma entrada da tabela de página de quarto nível.  Isso permite que o kernel funcione de acordo com o método descrito na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">seção "Tabelas de páginas recursivas"</a> . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para o nosso kernel, escolhemos a primeira opção, porque é uma abordagem simples, independente de plataforma e mais poderosa (também dá acesso a outros quadros, não apenas a tabelas de páginas). </font><font style="vertical-align: inherit;">Para suporte do gerenciador de inicialização, inclua a função em suas dependências </font></font><code>map_physical_memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="plaintext hljs">[dependencies] bootloader = { version = "0.4.0", features = ["map_physical_memory"]}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se esse recurso estiver ativado, o carregador de inicialização mapeia a memória física completa para algum intervalo não utilizado de endereços virtuais. </font><font style="vertical-align: inherit;">Para passar um intervalo de endereços virtuais para o kernel, o carregador de inicialização passa a estrutura das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">informações de inicialização</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><a name="3_1"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Informações de inicialização </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O engradado </font></font><code>bootloader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">define a estrutura do </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BootInfo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> com todas as informações passadas ao kernel. </font><font style="vertical-align: inherit;">A estrutura ainda está sendo finalizada, portanto, pode haver algumas falhas ao atualizar para versões futuras </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">incompatíveis com o semver</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Atualmente, a estrutura possui dois campos: </font></font><code>memory_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O campo </font></font><code>memory_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fornece uma visão geral da memória física disponível. </font><font style="vertical-align: inherit;">Ele informa ao kernel quanta memória física está disponível no sistema e quais áreas de memória estão reservadas para dispositivos como o VGA. </font><font style="vertical-align: inherit;">Um cartão de memória pode ser solicitado no firmware do BIOS ou UEFI, mas apenas no início do processo de inicialização. </font><font style="vertical-align: inherit;">Por esse motivo, o carregador deve fornecê-lo, porque o kernel não poderá mais receber essas informações. </font><font style="vertical-align: inherit;">Um cartão de memória será útil mais adiante neste artigo.</font></font><br></li><li> <code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">relata o endereço inicial virtual do mapeamento de memória física. </font><font style="vertical-align: inherit;">Adicionando esse deslocamento ao endereço físico, obtemos o endereço virtual correspondente. </font><font style="vertical-align: inherit;">Isso dá acesso do kernel à memória física arbitrária.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O carregador passa a estrutura </font></font><code>BootInfo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para o </font><font style="vertical-align: inherit;">kernel </font><font style="vertical-align: inherit;">como um argumento </font></font><code>&amp;'static BootInfo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para a função </font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Adicione:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs use bootloader::BootInfo; #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start(boot_info: &amp;'static BootInfo) -&gt; ! { // new argument […] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> É importante especificar o tipo de argumento correto, pois o compilador não conhece o tipo de assinatura correto da nossa função de ponto de entrada. </font></font><br><br><a name="3_2"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Macro do ponto de entrada </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como a função </font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é chamada externamente a partir do carregador, a assinatura da função não é verificada. Isso significa que podemos aceitar argumentos arbitrários sem erros de compilação, mas isso trava ou causa um comportamento indefinido do tempo de execução. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para garantir que a função do ponto de entrada sempre tenha a assinatura correta, a caixa </font></font><code>bootloader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fornece uma macro </font></font><code>entry_point</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Reescrevemos nossa função usando esta macro:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs use bootloader::{BootInfo, entry_point}; entry_point!(kernel_main); #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Você não precisa mais usar o ponto de entrada </font></font><code>extern "C"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>no_mangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, já que a macro define para nós o ponto de entrada real do nível inferior </font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. A função </font></font><code>kernel_main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agora se tornou uma função Rust completamente normal, para que possamos escolher um nome arbitrário para ela. O importante é que ele seja verificado por tipo; portanto, se você usar a assinatura errada, por exemplo, adicionando um argumento ou alterando seu tipo, ocorrerá um erro de compilação</font></font><br><br><a name="4"></a><h1>  Implementação </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora temos acesso à memória física e podemos finalmente começar a implementação do sistema. </font><font style="vertical-align: inherit;">Primeiro, considere as tabelas de páginas ativas atuais nas quais o kernel é executado. </font><font style="vertical-align: inherit;">Na segunda etapa, crie uma função de conversão que retorne o endereço físico para o qual esse endereço virtual está mapeado. </font><font style="vertical-align: inherit;">Na última etapa, tentaremos modificar as tabelas de páginas para criar um novo mapeamento. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro, crie um novo módulo no código </font></font><code>memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/lib.rs pub mod memory;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para o módulo, crie um arquivo vazio </font></font><code>src/memory.rs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><a name="4_1"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Acesso a tabelas de páginas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No final do </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artigo anterior,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tentamos examinar a tabela de páginas em que o kernel funciona, mas não conseguimos acessar o quadro físico apontado pelo registro </font></font><code>CR3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Agora podemos continuar trabalhando a partir deste local: a função </font></font><code>active_level_4_table</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retornará um link para a tabela ativa de páginas do quarto nível:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::PageTable; /// Returns a mutable reference to the active level 4 table. /// /// This function is unsafe because the caller must guarantee that the /// complete physical memory is mapped to virtual memory at the passed /// `physical_memory_offset`. Also, this function must be only called once /// to avoid aliasing `&amp;mut` references (which is undefined behavior). pub unsafe fn active_level_4_table(physical_memory_offset: u64) -&gt; &amp;'static mut PageTable { use x86_64::{registers::control::Cr3, VirtAddr}; let (level_4_table_frame, _) = Cr3::read(); let phys = level_4_table_frame.start_address(); let virt = VirtAddr::new(phys.as_u64() + physical_memory_offset); let page_table_ptr: *mut PageTable = virt.as_mut_ptr(); &amp;mut *page_table_ptr // unsafe }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro, lemos o quadro físico da tabela ativa do 4º nível no registro </font></font><code>CR3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Em seguida, pegamos seu endereço físico inicial e o convertemos em um endereço virtual adicionando </font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Por fim, converta o endereço em um ponteiro bruto </font></font><code>*mut PageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pelo método </font></font><code>as_mut_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e, em seguida, crie um link com segurança </font></font><code>&amp;mut PageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Em </font></font><code>&amp;mut</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vez disso </font></font><code>&amp;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">criamos o link </font><font style="vertical-align: inherit;">, porque mais adiante neste artigo modificaremos essas tabelas de páginas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não há necessidade de inserir um bloco não seguro aqui, porque Rust considera todo o corpo </font></font><code>unsafe fn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como um bloco grande e não seguro. Isso aumenta os riscos, porque é possível introduzir acidentalmente uma operação insegura nas linhas anteriores. Também dificulta a detecção de operações não seguras. Um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> já foi criado </font><font style="vertical-align: inherit;">para modificar esse comportamento do Rust.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos usar esta função para gerar os registros da tabela do quarto nível:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] // initialize GDT, IDT, PICS use blog_os::memory::active_level_4_table; let l4_table = unsafe { active_level_4_table(boot_info.physical_memory_offset) }; for (i, entry) in l4_table.iter().enumerate() { if !entry.is_unused() { println!("L4 Entry {}: {:?}", i, entry); } } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Passamos </font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no campo correspondente da estrutura </font></font><code>BootInfo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Em seguida, usamos uma função </font></font><code>iter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para percorrer as entradas da tabela de páginas e um combinador </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">enumerate</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para adicionar um índice </font></font><code>i</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a cada elemento. Somente entradas não vazias são exibidas, porque todas as 512 entradas não cabem na tela. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando executamos o código, vemos o resultado: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a33/def/50d/a33def50db528880395b665882aabe75.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vemos vários registros não vazios que são mapeados para várias tabelas de terceiro nível. Muitas áreas de memória são usadas porque são necessárias áreas separadas para código do kernel, pilha do kernel, tradução da memória física e informações de inicialização. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para percorrer as tabelas de páginas e olhar para a tabela de terceiro nível, podemos converter novamente o quadro exibido em um endereço virtual:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in the for loop in src/main.rs use x86_64::{structures::paging::PageTable, VirtAddr}; if !entry.is_unused() { println!("L4 Entry {}: {:?}", i, entry); // get the physical address from the entry and convert it let phys = entry.frame().unwrap().start_address(); let virt = phys.as_u64() + boot_info.physical_memory_offset; let ptr = VirtAddr::new(virt).as_mut_ptr(); let l3_table: &amp;PageTable = unsafe { &amp;*ptr }; // print non-empty entries of the level 3 table for (i, entry) in l3_table.iter().enumerate() { if !entry.is_unused() { println!(" L3 Entry {}: {:?}", i, entry); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para visualizar as tabelas do segundo e primeiro níveis, repita esse processo, respectivamente, para registros do terceiro e do segundo níveis. </font><font style="vertical-align: inherit;">Como você pode imaginar, a quantidade de código está crescendo muito rapidamente, portanto não publicaremos a lista completa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A travessia manual de tabelas é interessante porque ajuda a entender como o processador converte endereços. </font><font style="vertical-align: inherit;">Mas geralmente só estamos interessados ​​em exibir um endereço físico para um endereço virtual específico, então vamos criar uma função para isso.</font></font><br><br><a name="4_2"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tradução de endereços </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para converter um endereço virtual em um endereço físico, precisamos passar por uma tabela de página de quatro níveis até atingir o quadro mapeado. </font><font style="vertical-align: inherit;">Vamos criar uma função que execute esta tradução de endereço:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::{PhysAddr, VirtAddr}; /// Translates the given virtual address to the mapped physical address, or /// `None` if the address is not mapped. /// /// This function is unsafe because the caller must guarantee that the /// complete physical memory is mapped to virtual memory at the passed /// `physical_memory_offset`. pub unsafe fn translate_addr(addr: VirtAddr, physical_memory_offset: u64) -&gt; Option&lt;PhysAddr&gt; { translate_addr_inner(addr, physical_memory_offset) }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nós nos referimos a uma função segura </font></font><code>translate_addr_inner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para limitar a quantidade de código não seguro. Como observado acima, Rust considera todo o corpo </font></font><code>unsafe fn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como um grande bloco inseguro. Invocando uma função segura, tornamos explícitas novamente cada operação </font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma função interna especial possui funcionalidade real:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs /// Private function that is called by `translate_addr`. /// /// This function is safe to limit the scope of `unsafe` because Rust treats /// the whole body of unsafe functions as an unsafe block. This function must /// only be reachable through `unsafe fn` from outside of this module. fn translate_addr_inner(addr: VirtAddr, physical_memory_offset: u64) -&gt; Option&lt;PhysAddr&gt; { use x86_64::structures::paging::page_table::FrameError; use x86_64::registers::control::Cr3; // read the active level 4 frame from the CR3 register let (level_4_table_frame, _) = Cr3::read(); let table_indexes = [ addr.p4_index(), addr.p3_index(), addr.p2_index(), addr.p1_index() ]; let mut frame = level_4_table_frame; // traverse the multi-level page table for &amp;index in &amp;table_indexes { // convert the frame into a page table reference let virt = frame.start_address().as_u64() + physical_memory_offset; let table_ptr: *const PageTable = VirtAddr::new(virt).as_ptr(); let table = unsafe {&amp;*table_ptr}; // read the page table entry and update `frame` let entry = &amp;table[index]; frame = match entry.frame() { Ok(frame) =&gt; frame, Err(FrameError::FrameNotPresent) =&gt; return None, Err(FrameError::HugeFrame) =&gt; panic!("huge pages not supported"), }; } // calculate the physical address by adding the page offset Some(frame.start_address() + u64::from(addr.page_offset())) }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em vez de reutilizar a função, relemos o </font></font><code>active_level_4_table</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quadro de quarto nível do registro </font></font><code>CR3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, porque isso simplifica a implementação do protótipo. Não se preocupe, melhoraremos a solução em breve. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A estrutura </font></font><code>VirtAddr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">já fornece métodos para calcular índices em tabelas de páginas de quatro níveis. Armazenamos esses índices em uma pequena matriz, porque permite percorrer todas as tabelas </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Fora do loop, lembramos do último quadro visitado para calcular o endereço físico posteriormente. </font></font><code>frame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aponta para os quadros da tabela de páginas durante a iteração e para o quadro associado após a última iteração, ou seja, após passar o registro de nível 1. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dentro do loop, aplicamos novamente</font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para converter um quadro em um link da tabela da página. Em seguida, lemos o registro da tabela de páginas atual e usamos a função </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>PageTableEntry::frame</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para recuperar o quadro correspondente. Se o registro não estiver mapeado para um quadro, retorne </font></font><code>None</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Se o registro exibir uma página enorme de 2 MiB ou 1 GiB, até agora teremos pânico. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Então, vamos verificar a função de tradução em alguns endereços:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] // initialize GDT, IDT, PICS use blog_os::memory::translate_addr; use x86_64::VirtAddr; let addresses = [ // the identity-mapped vga buffer page 0xb8000, // some code page 0x20010a, // some stack page 0x57ac_001f_fe48, // virtual address mapped to physical address 0 boot_info.physical_memory_offset, ]; for &amp;address in &amp;addresses { let virt = VirtAddr::new(address); let phys = unsafe { translate_addr(virt, boot_info.physical_memory_offset) }; println!("{:?} -&gt; {:?}", virt, phys); } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando executamos o código, obtemos o seguinte resultado: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a0b/e32/db8/a0be32db8b6353452f9d40d7b1d350ad.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como esperado, com um mapeamento idêntico, o endereço é </font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">convertido no mesmo endereço físico. </font><font style="vertical-align: inherit;">A página de código e a pilha são convertidas em endereços físicos arbitrários, que dependem de como o carregador criou o mapeamento inicial para o nosso kernel. </font><font style="vertical-align: inherit;">O mapeamento </font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deve apontar para o endereço físico </font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas falha, porque a tradução usa páginas enormes para eficiência. </font><font style="vertical-align: inherit;">Uma versão futura do gerenciador de inicialização pode aplicar a mesma otimização para as páginas do kernel e da pilha.</font></font><br><br><a name="4_3"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Usando MappedPageTable </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A tradução de endereços virtuais em endereços físicos é uma tarefa típica do kernel do SO, portanto, o engradado </font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fornece uma abstração para ele. </font><font style="vertical-align: inherit;">Ele já suporta páginas enormes e várias outras funções, exceto </font></font><code>translate_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, portanto, a usamos em vez de adicionar suporte a páginas grandes em nossa própria implementação. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A base da abstração são duas características que definem várias funções de tradução da tabela de páginas:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A característica </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>Mapper</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fornece funções que funcionam nas páginas. </font><font style="vertical-align: inherit;">Por exemplo, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>translate_page</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para converter esta página em um quadro do mesmo tamanho, bem como </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>map_to</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para criar um novo mapeamento na tabela.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A característica </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>MapperAllSizes</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implica aplicação </font></font><code>Mapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para todos os tamanhos de página. </font><font style="vertical-align: inherit;">Além disso, fornece funções que funcionam com páginas de tamanhos diferentes, incluindo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>translate_addr</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">geral ou </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>translate</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os traços definem apenas a interface, mas não fornecem nenhuma implementação. </font><font style="vertical-align: inherit;">Agora, a caixa </font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fornece dois tipos que implementam características: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>MappedPageTable</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>RecursivePageTable</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">A primeira exige que cada quadro da tabela da página seja exibido em algum lugar (por exemplo, com um deslocamento). </font><font style="vertical-align: inherit;">O segundo tipo pode ser usado se a tabela do quarto nível for exibida recursivamente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temos toda a memória física mapeada para </font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que você possa usar o tipo MappedPageTable. </font><font style="vertical-align: inherit;">Para inicializá-lo, crie uma nova função </font></font><code>init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no módulo </font></font><code>memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> x86_64::structures::paging::{PhysFrame, MapperAllSizes, MappedPageTable}; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> x86_64::PhysAddr; <span class="hljs-comment"><span class="hljs-comment">/// Initialize a new MappedPageTable. /// /// This function is unsafe because the caller must guarantee that the /// complete physical memory is mapped to virtual memory at the passed /// `physical_memory_offset`. Also, this function must be only called once /// to avoid aliasing `&amp;mut` references (which is undefined behavior). pub unsafe fn init(physical_memory_offset: u64) -&gt; impl MapperAllSizes { let level_4_table = active_level_4_table(physical_memory_offset); let phys_to_virt = move |frame: PhysFrame| -&gt; *mut PageTable { let phys = frame.start_address().as_u64(); let virt = VirtAddr::new(phys + physical_memory_offset); virt.as_mut_ptr() }; MappedPageTable::new(level_4_table, phys_to_virt) } // make private unsafe fn active_level_4_table(physical_memory_offset: u64) -&gt; &amp;'static mut PageTable {…}</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não podemos retornar diretamente </font></font><code>MappedPageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de uma função porque é comum a um tipo de fechamento. Vamos contornar esse problema com uma construção de sintaxe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>impl Trait</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Uma vantagem adicional é que você pode mudar o kernel para </font></font><code>RecursivePageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sem alterar a assinatura da função. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A função </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>MappedPageTable::new</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">espera dois parâmetros: um link mutável para a tabela de páginas do nível 4 e um fechamento </font></font><code>phys_to_virt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que converte o quadro físico em um ponteiro da tabela de páginas </font></font><code>*mut PageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Para o primeiro parâmetro, podemos reutilizar a função </font></font><code>active_level_4_table</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Para o segundo, criamos um fechamento que é usado </font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para realizar a conversão. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Também a tornamos uma </font></font><code>active_level_4_table</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">função privada, porque a partir de agora será chamada apenas de </font></font><code>init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para usar o método</font></font><code>MapperAllSizes::translate_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em vez de nossa própria função </font></font><code>memory::translate_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, precisamos alterar apenas algumas linhas em </font></font><code>kernel_main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] // initialize GDT, IDT, PICS // new: different imports use blog_os::memory; use x86_64::{structures::paging::MapperAllSizes, VirtAddr}; // new: initialize a mapper let mapper = unsafe { memory::init(boot_info.physical_memory_offset) }; let addresses = […]; // same as before for &amp;address in &amp;addresses { let virt = VirtAddr::new(address); // new: use the `mapper.translate_addr` method let phys = mapper.translate_addr(virt); println!("{:?} -&gt; {:?}", virt, phys); } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Após o início, vemos os mesmos resultados de tradução de antes, mas agora apenas páginas grandes também funcionam: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/51d/5ed/d9c/51d5edd9c004e1238b321dee51fdf8b3.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como esperado, o endereço virtual é </font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">convertido em um endereço físico </font></font><code>0x0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Usando a função de tradução para o tipo </font></font><code>MappedPageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, eliminamos a necessidade de implementar o suporte para páginas enormes. </font><font style="vertical-align: inherit;">Também temos acesso a outras funções da página, como as </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que serão usadas na próxima seção. </font><font style="vertical-align: inherit;">Nesta fase, não precisamos mais da função </font></font><code>memory::translate_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, você pode excluí-la, se desejar.</font></font><br><br><a name="4_4"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crie um novo mapeamento </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Até agora, analisamos apenas as tabelas de páginas, mas não mudamos nada. </font><font style="vertical-align: inherit;">Vamos criar um novo mapeamento para uma página não exibida anteriormente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usaremos a função </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>map_to</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">da característica </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>Mapper</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, portanto, primeiro consideraremos essa função. </font><font style="vertical-align: inherit;">A documentação diz que requer quatro argumentos: a página que queremos exibir; </font><font style="vertical-align: inherit;">O quadro para o qual a página deve ser mapeada. </font><font style="vertical-align: inherit;">conjunto de sinalizadores para escrever o distribuidor de quadro e tabela de páginas </font></font><code>frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Um alocador de quadros é necessário porque o mapeamento desta página pode exigir a criação de tabelas adicionais que precisam de quadros não utilizados como armazenamento de backup.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Função </font></font><code>create_example_mapping</code> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O primeiro passo em nossa implementação é criar uma nova função </font></font><code>create_example_mapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que mapeie esta página para o </font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quadro físico do buffer de texto VGA. Selecionamos esse quadro porque facilita verificar se a exibição foi criada corretamente: basta escrever na página exibida recentemente e ver se ela aparece na tela. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A função </font></font><code>create_example_mapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fica assim:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::{Page, Size4KiB, Mapper, FrameAllocator}; /// Creates an example mapping for the given page to frame `0xb8000`. pub fn create_example_mapping( page: Page, mapper: &amp;mut impl Mapper&lt;Size4KiB&gt;, frame_allocator: &amp;mut impl FrameAllocator&lt;Size4KiB&gt;, ) { use x86_64::structures::paging::PageTableFlags as Flags; let frame = PhysFrame::containing_address(PhysAddr::new(0xb8000)); let flags = Flags::PRESENT | Flags::WRITABLE; let map_to_result = unsafe { mapper.map_to(page, frame, flags, frame_allocator) }; map_to_result.expect("map_to failed").flush(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Além da página que </font></font><code>page</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">você deseja mapear, a função espera uma instância de </font></font><code>mapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. O tipo </font></font><code>mapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementa a característica </font></font><code>Mapper&lt;Size4KiB&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que o método fornece </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. É </font></font><code>Size4KiB</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">necessário </font><font style="vertical-align: inherit;">um parâmetro geral </font><font style="vertical-align: inherit;">, pois a característica </font></font><code>Mapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comum</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para a característica </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PageSize</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, trabalhando com páginas padrão de 4 KiB e páginas enormes de 2 MiB e 1 GiB. Queremos criar apenas 4 páginas KiB, para que possamos usá-lo em </font></font><code>Mapper&lt;Size4KiB&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vez do requisito </font></font><code>MapperAllSizes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para comparação, defina o sinalizador </font></font><code>PRESENT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pois é necessário para todas as entradas válidas e o sinalizador </font></font><code>WRITABLE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para tornar a página exibida gravável. Desafio</font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inseguro: você pode violar a segurança da memória com argumentos inválidos; portanto, você deve usar um bloco </font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para obter uma lista de todos os sinalizadores possíveis, consulte a seção “Formato da tabela de páginas” do </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artigo anterior</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A função </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode falhar e, portanto, retorna </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Result</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Como este é apenas um exemplo de código que não deve ser confiável, simplesmente o usamos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>expect</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para entrar em pânico no caso de um erro. </font><font style="vertical-align: inherit;">Se for bem sucedido, a função retorna do tipo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>MapperFlush</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que proporciona um método simples de limpeza recentemente foi apresentado no buffer de página da tradução dinâmica (TLB) pelo método </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>flush</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Assim </font></font><code>Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, esse tipo aplica o atributo [ </font></font><code>#[must_use]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">] a</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">emitir um aviso se esquecermos acidentalmente de usá-lo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fictício </font></font><code>FrameAllocator</code> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para ligar </font></font><code>create_example_mapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, você deve primeiro criar </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Como observado acima, a complexidade de criar uma nova exibição depende da página virtual que queremos exibir. </font><font style="vertical-align: inherit;">No caso mais simples, já existe uma tabela de nível 1 para a página e precisamos apenas fazer um registro. </font><font style="vertical-align: inherit;">No caso mais difícil, a página está em uma área de memória para a qual o nível 3 ainda não foi criado, portanto, primeiro você terá que criar tabelas de níveis 3, 2 e 1. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos começar com um caso simples e supor que você não precisa criar novas tabelas de páginas. </font><font style="vertical-align: inherit;">Um distribuidor de quadros que sempre retorna é suficiente para isso </font></font><code>None</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Criamos uma </font></font><code>EmptyFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">função de exibição para teste:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs /// A FrameAllocator that always returns `None`. pub struct EmptyFrameAllocator; impl FrameAllocator&lt;Size4KiB&gt; for EmptyFrameAllocator { fn allocate_frame(&amp;mut self) -&gt; Option&lt;PhysFrame&gt; { None } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora você precisa encontrar uma página que possa ser exibida sem criar novas tabelas de páginas. O carregador é carregado no primeiro megabyte do espaço de endereço virtual, portanto, sabemos que para esta região há uma tabela válida de nível 1. No nosso exemplo, podemos selecionar qualquer página não utilizada nesta área de memória, por exemplo, a página no endereço </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para testar a função, primeiro exibimos a página </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e, em seguida, exibimos o conteúdo da memória:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] // initialize GDT, IDT, PICS use blog_os::memory; use x86_64::{structures::paging::Page, VirtAddr}; let mut mapper = unsafe { memory::init(boot_info.physical_memory_offset) }; let mut frame_allocator = memory::EmptyFrameAllocator; // map a previously unmapped page let page = Page::containing_address(VirtAddr::new(0x1000)); memory::create_example_mapping(page, &amp;mut mapper, &amp;mut frame_allocator); // write the string `New!` to the screen through the new mapping let page_ptr: *mut u64 = page.start_address().as_mut_ptr(); unsafe { page_ptr.offset(400).write_volatile(0x_f021_f077_f065_f04e)}; println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro, criamos um mapeamento para a página </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, chamando uma função </font></font><code>create_example_mapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com um link mutável para instâncias </font></font><code>mapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Isso mapeia a página </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para o quadro de buffer de texto VGA, portanto, devemos ver o que está escrito na tela. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, converta a página em um ponteiro bruto e escreva o valor no deslocamento </font></font><code>400</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Não escrevemos no topo da página porque a linha superior do buffer VGA é diretamente deslocada da tela da seguinte maneira </font></font><code>println</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Escreva o valor </font></font><code>0x_f021_f077_f065_f04e</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que corresponde à string </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"New!"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sobre um fundo branco Como aprendemos no artigo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Modo de texto VGA"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a gravação no buffer VGA deve ser volátil, por isso usamos o método </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>write_volatile</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando executamos o código no QEMU, vemos o seguinte resultado: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4cf/248/1a0/4cf2481a07f40c681954ff4954dce866.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de escrever na página </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a inscrição </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Novo!"</font></font></i>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, criamos com sucesso um novo mapeamento nas tabelas de páginas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esse agrupamento funcionou porque já havia uma tabela de nível 1 para agrupamento </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Quando tentamos mapear uma página para a qual ainda não existe uma tabela de nível 1, a função </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falha porque tenta alocar quadros </font></font><code>EmptyFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para criar novas tabelas. </font><font style="vertical-align: inherit;">Vemos que isso acontece quando tentamos exibir a página em </font></font><code>0xdeadbeaf000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vez de </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] let page = Page::containing_address(VirtAddr::new(0xdeadbeaf000)); […] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se isso for iniciado, ocorrerá um pânico com a seguinte mensagem de erro: </font></font><br><br><pre> <code class="plaintext hljs">panicked at 'map_to failed: FrameAllocationFailed', /…/result.rs:999:5</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para exibir páginas que ainda não possuem uma tabela de nível 1, é necessário criar a correta </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mas como você sabe quais quadros são gratuitos e quanta memória física está disponível?</font></font><br><br><a name="4_5"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seleção de quadro </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para novas tabelas de páginas, você precisa criar o distribuidor de quadros correto. </font><font style="vertical-align: inherit;">Vamos começar com o esqueleto geral:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs pub struct BootInfoFrameAllocator&lt;I&gt; where I: Iterator&lt;Item = PhysFrame&gt; { frames: I, } impl&lt;I&gt; FrameAllocator&lt;Size4KiB&gt; for BootInfoFrameAllocator&lt;I&gt; where I: Iterator&lt;Item = PhysFrame&gt; { fn allocate_frame(&amp;mut self) -&gt; Option&lt;PhysFrame&gt; { self.frames.next() } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O campo </font></font><code>frames</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode ser inicializado com um iterador de quadro arbitrário. Isso permite que você simplesmente delegue chamadas ao </font></font><code>alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">método </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>Iterator::next</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para a inicialização, </font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usamos o cartão de memória </font></font><code>memory_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que o gerenciador de inicialização transfere como parte da estrutura </font></font><code>BootInfo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Conforme explicado na </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seção Informações de inicialização</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o cartão de memória é fornecido pelo firmware BIOS / UEFI. Ele pode ser solicitado apenas no início do processo de inicialização, portanto, o carregador de inicialização já chamou as funções necessárias. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um cartão de memória consiste em uma lista de estruturas </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>MemoryRegion</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que contêm o endereço inicial, comprimento e tipo (por exemplo, não utilizados, reservados, etc.) de cada área de memória. Criando um iterador que produz quadros de áreas não utilizadas, podemos criar um válido </font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A inicialização </font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ocorre em uma nova função </font></font><code>init_frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use bootloader::bootinfo::{MemoryMap, MemoryRegionType}; /// Create a FrameAllocator from the passed memory map pub fn init_frame_allocator( memory_map: &amp;'static MemoryMap, ) -&gt; BootInfoFrameAllocator&lt;impl Iterator&lt;Item = PhysFrame&gt;&gt; { // get usable regions from memory map let regions = memory_map .iter() .filter(|r| r.region_type == MemoryRegionType::Usable); // map each region to its address range let addr_ranges = regions.map(|r| r.range.start_addr()..r.range.end_addr()); // transform to an iterator of frame start addresses let frame_addresses = addr_ranges.flat_map(|r| r.step_by(4096)); // create `PhysFrame` types from the start addresses let frames = frame_addresses.map(|addr| { PhysFrame::containing_address(PhysAddr::new(addr)) }); BootInfoFrameAllocator { frames } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta função usa um combinador para converter o mapa inicial </font></font><code>MemoryMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em um iterador dos quadros físicos usados:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro, chamamos o método </font></font><code>iter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para converter o cartão de memória em um iterador </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>MemoryRegion</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Em seguida, usamos o método </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>filter</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para pular regiões reservadas ou inacessíveis. </font><font style="vertical-align: inherit;">O carregador atualiza o cartão de memória para todos os mapeamentos criados, para que os quadros usados ​​pelo kernel (código, dados ou pilha) ou para armazenar informações sobre a inicialização já estejam marcados como </font></font><code>InUse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou de forma semelhante. </font><font style="vertical-align: inherit;">Assim, podemos ter certeza de que os quadros </font></font><code>Usable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">não </font><font style="vertical-align: inherit;">são </font><font style="vertical-align: inherit;">usados ​​em </font><font style="vertical-align: inherit;">outros lugares </font><font style="vertical-align: inherit;">.</font></font><br></li><li>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>map</code></a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">range</a>  Rust         . <br></li><li>    :         <code>into_iter</code> ,     4096-    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>step_by</code></a> .  4096  (= 4 ) —   ,      .      ,         .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>flat_map</code></a>  <code>map</code> ,   <code>Iterator&lt;Item = u64&gt;</code>  <code>Iterator&lt;Item = Iterator&lt;Item = u64&gt;&gt;</code> . <br></li><li>         <code>PhysFrame</code> ,    <code>Iterator&lt;Item = PhysFrame&gt;</code> .          <code>BootInfoFrameAllocator</code> . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora você pode alterar a nossa função </font></font><code>kernel_main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para transmitir uma cópia </font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ao invés </font></font><code>EmptyFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] let mut frame_allocator = memory::init_frame_allocator(&amp;boot_info.memory_map); […] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dessa vez, o mapeamento de endereços foi bem-sucedido e novamente vemos o preto e branco </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Novo!"</font></font></i>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nos bastidores, o método </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cria tabelas de páginas ausentes da seguinte maneira:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selecione um quadro não utilizado do quadro transmitido </font></font><code>frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zero quadro para criar uma nova tabela de página vazia. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mapeie uma entrada da tabela de nível superior para esse quadro. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vá para o próximo nível da tabela. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora nossa função </font></font><code>create_example_mapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seja apenas um exemplo de código, agora podemos criar novos mapeamentos para páginas arbitrárias. </font><font style="vertical-align: inherit;">Isso será necessário para alocar memória e implementar multithreading em artigos futuros.</font></font><br><br><a name="5"></a><h1>  Sumário </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neste artigo, aprendemos sobre vários métodos de acesso aos quadros físicos das tabelas de páginas, incluindo mapeamento de identidade, mapeamento de memória física completa, mapeamento temporário e tabelas de páginas recursivas. Optamos por exibir a memória física completa como um método simples e poderoso. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não podemos mapear a memória física do kernel sem acesso à tabela de páginas, portanto, o suporte ao carregador de inicialização é necessário. O rack </font></font><code>bootloader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cria os mapeamentos necessários por meio de funções adicionais de carga. Ele passa as informações necessárias para o kernel como um argumento </font></font><code>&amp;BootInfo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para a função de ponto de entrada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para nossa implementação, primeiro examinamos manualmente as tabelas de páginas, fizemos uma função de tradução e depois usamos o tipo de </font></font><code>MappedPageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">caixa</font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Também aprendemos como criar novos mapeamentos na tabela de páginas e como fazê-los </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em um cartão de memória transmitido pelo gerenciador de inicialização.</font></font><br><br><a name="6"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O que vem a seguir? </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No próximo artigo, criaremos uma área de memória heap para o nosso kernel, que permitirá </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alocar memória</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e usar diferentes </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tipos de coleções</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt445618/">https://habr.com/ru/post/pt445618/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt445596/index.html">Dicas e truques do Kubernetes: páginas de erro personalizadas no NGINX Ingress</a></li>
<li><a href="../pt445600/index.html">[Poll e evil] Hostings, estejam eles errados</a></li>
<li><a href="../pt445602/index.html">PHP Russia 2019: seu “estádio” para o idioma da primeira liga</a></li>
<li><a href="../pt445608/index.html">Fim do jogo: analistas relatam um aumento no número de ataques DDoS no segmento de jogos</a></li>
<li><a href="../pt445612/index.html">Armazenamento de cluster para pequenos clusters da Web com base em drbd + ocfs2</a></li>
<li><a href="../pt445620/index.html">O que um escritor de UX faz?</a></li>
<li><a href="../pt445622/index.html">Novo no Java 12: O Teeing Collector</a></li>
<li><a href="../pt445626/index.html">Qual a profundidade da toca do coelho? CLRium # 5: Coletor de Lixo</a></li>
<li><a href="../pt445632/index.html">Do analisador do pôster do teatro Python ao bot do Telegram. Parte 2</a></li>
<li><a href="../pt445638/index.html">Estágio cego no Garage Museum of Modern Art</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>