<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§šğŸ¿ ğŸ‘©ğŸ¾â€ğŸŒ¾ ğŸš¶ğŸ¿ Bagaimana Kami Menemukan Ekspresi Lambda di IntelliJ IDEA ğŸ‘´ğŸ» ğŸ”Ÿ ğŸ’¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pencarian dan navigasi kode adalah fitur penting dari setiap IDE. Di Jawa, salah satu opsi pencarian yang umum digunakan adalah mencari semua implemen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana Kami Menemukan Ekspresi Lambda di IntelliJ IDEA</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/JetBrains/blog/451754/"><p><img alt="Ketik Hirarki di IntelliJ IDEA" src="https://habrastorage.org/webt/ff/js/7m/ffjs7m9ycsved2ciyrqdvb4uiwe.png" align="right" width="300">  Pencarian dan navigasi kode adalah fitur penting dari setiap IDE.  Di Jawa, salah satu opsi pencarian yang umum digunakan adalah mencari semua implementasi antarmuka.  Fitur ini sering disebut Type Hierarchy, dan tampilannya persis seperti gambar di sebelah kanan. </p><br><p>  Tidak efisien untuk mengulangi semua kelas proyek ketika fitur ini dipanggil.  Salah satu opsi adalah untuk menyimpan hierarki kelas yang lengkap dalam indeks selama kompilasi karena kompiler tetap membuatnya.  Kami melakukan ini ketika kompilasi dijalankan oleh IDE dan tidak didelegasikan, misalnya, ke Gradle.  Tetapi ini hanya berfungsi jika tidak ada yang berubah dalam modul setelah kompilasi.  Secara umum, kode sumber adalah penyedia informasi terbaru, dan indeks didasarkan pada kode sumber. </p><br><p> Menemukan anak langsung adalah tugas sederhana jika kita tidak berurusan dengan antarmuka fungsional.  Saat mencari implementasi dari antarmuka <code>Foo</code> , kita perlu menemukan semua kelas yang <code>implements Foo</code> dan antarmuka yang telah <code>extends Foo</code> , serta kelas anonim <code>new Foo(...) {...}</code> .  Untuk melakukan ini, cukup membangun pohon sintaksis dari setiap file proyek terlebih dahulu, menemukan konstruk yang sesuai, dan menambahkannya ke indeks. <a name="habracut"></a>  Namun, ada kerumitan di sini: Anda mungkin mencari antarmuka <code>com.example.goodcompany.Foo</code> , sedangkan <code>org.example.evilcompany.Foo</code> sebenarnya digunakan.  Bisakah kita memasukkan nama lengkap antarmuka induk ke dalam indeks terlebih dahulu?  Ini bisa rumit.  Misalnya, file tempat antarmuka digunakan mungkin terlihat seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// MyFoo.java import org.example.foo.*; import org.example.bar.*; import org.example.evilcompany.*; class MyFoo implements Foo {...}</span></span></code> </pre> <br><p>  Dengan melihat file itu sendiri, tidak mungkin untuk mengetahui apa nama <code>Foo</code> benar-benar memenuhi syarat.  Kami harus melihat isi beberapa paket.  Dan setiap paket dapat didefinisikan di beberapa tempat dalam proyek (misalnya, dalam beberapa file JAR).  Jika kami melakukan resolusi simbol yang tepat saat menganalisis file ini, pengindeksan akan membutuhkan banyak waktu.  Tetapi masalah utama adalah bahwa indeks yang dibangun di atas <code>MyFoo.java</code> akan tergantung pada file lain juga.  Kita dapat memindahkan deklarasi antarmuka <code>Foo</code> , misalnya, dari paket <code>org.example.foo</code> ke paket <code>org.example.bar</code> , tanpa mengubah apa pun di file <code>MyFoo.java</code> , tetapi nama <code>Foo</code> sepenuhnya memenuhi syarat akan berubah. </p><br><p>  Di IntelliJ IDEA, indeks hanya bergantung pada konten dari satu file.  Di satu sisi, itu sangat nyaman: indeks yang terkait dengan file tertentu menjadi tidak valid ketika file diubah.  Di sisi lain, itu memberlakukan batasan besar pada apa yang dapat dimasukkan ke dalam indeks.  Misalnya, itu tidak memungkinkan nama kelas induk yang memenuhi syarat untuk disimpan secara andal dalam indeks.  Tapi, secara umum, itu tidak terlalu buruk.  Saat meminta hierarki jenis, kami dapat menemukan semua yang cocok dengan permintaan kami dengan nama pendek, dan kemudian melakukan resolusi simbol yang tepat untuk file-file ini dan menentukan apakah itu yang kami cari.  Dalam kebanyakan kasus, tidak akan ada terlalu banyak simbol yang berlebihan dan pemeriksaan tidak akan lama. </p><br><p><img alt="Hirarki antarmuka fungsional di IntelliJ IDEA" src="https://habrastorage.org/webt/e-/nn/0y/e-nn0ynvtojiydboaco5uiyzwms.png" align="right" width="300">  Namun, banyak hal berubah ketika kelas yang anak-anaknya kita cari adalah antarmuka fungsional.  Kemudian, selain subclass eksplisit dan anonim, akan ada ekspresi lambda dan referensi metode.  Apa yang kita masukkan ke dalam indeks sekarang, dan apa yang harus dievaluasi selama pencarian? </p><br><p>  Mari kita asumsikan kita memiliki antarmuka fungsional: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@FunctionalInterface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringConsumer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span></span>; }</code> </pre> <br><p>  Kode berisi berbagai ekspresi lambda.  Misalnya: </p><br><pre> <code class="java hljs">() -&gt; {} <span class="hljs-comment"><span class="hljs-comment">// a certain mismatch: no parameters (a, b) -&gt; a + b // a certain mismatch: two parameters s -&gt; { return list.add(s); // a certain mismatch: a value is returned } s -&gt; list.add(s); // a potential match</span></span></code> </pre> <br><p>  Ini berarti kita dapat dengan cepat menyaring lambdas yang memiliki jumlah parameter yang tidak sesuai atau jenis pengembalian yang jelas tidak tepat, misalnya, batal bukannya tidak batal.  Biasanya tidak mungkin untuk menentukan jenis pengembalian lebih tepat.  Misalnya, dalam <code>s -&gt; list.add(s)</code> Anda harus menyelesaikan <code>list</code> dan <code>add</code> , dan, mungkin, menjalankan prosedur inferensi tipe biasa.  Butuh waktu dan tergantung pada konten file lain. </p><br><p>  Kami beruntung jika antarmuka fungsional membutuhkan lima argumen.  Tetapi jika hanya membutuhkan satu, filter akan menyimpan sejumlah besar lambda yang tidak perlu.  Ini bahkan lebih buruk ketika sampai ke referensi metode.  Ngomong-ngomong, orang tidak bisa memastikan apakah referensi metode cocok atau tidak. </p><br><p>  Untuk memperbaikinya, mungkin ada baiknya melihat apa yang mengelilingi lambda.  Terkadang berhasil.  Misalnya: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// declaration of a local variable or a field of different type Predicate&lt;String&gt; p = s -&gt; list.add(s); // a different return type IntPredicate getPredicate() { return s -&gt; list.add(s); } // assignment to a variable of a different type SomeType fn; fn = s -&gt; list.add(s); // cast to a different type foo((SomeFunctionalType)(s -&gt; list.add(s))); // declaration of a different type array Foo[] myLambdas = {s -&gt; list.add(s), s -&gt; list.remove(s)};</span></span></code> </pre> <br><p>  Dalam semua kasus ini, nama pendek dari antarmuka fungsional yang sesuai dapat ditentukan dari file saat ini dan dapat dimasukkan ke dalam indeks di sebelah ekspresi fungsional, baik itu lambda atau referensi metode.  Sayangnya, dalam proyek kehidupan nyata, kasus-kasus ini mencakup persentase yang sangat kecil dari semua lambda.  Dalam kebanyakan kasus, lambdas digunakan sebagai argumen metode: </p><br><pre> <code class="java hljs">list.stream() .filter(s -&gt; StringUtil.isNonEmpty(s)) .map(s -&gt; s.trim()) .forEach(s -&gt; list.add(s));</code> </pre> <br><p>  Manakah dari tiga lambda yang dapat berisi <code>StringConsumer</code> ?  Jelas, tidak ada.  Di sini kami memiliki rantai Stream API yang hanya menampilkan antarmuka fungsional dari pustaka standar, itu tidak dapat memiliki jenis kustom. </p><br><p>  Namun, IDE harus dapat melihat triknya dan memberi kami jawaban yang tepat.  Bagaimana jika <code>list</code> tidak sepenuhnya <code>java.util.List</code> , dan <code>list.stream()</code> mengembalikan sesuatu yang berbeda dari <code>java.util.stream.Stream</code> ?  Maka kita harus menyelesaikan <code>list</code> , yang, seperti yang kita ketahui, tidak dapat dilakukan hanya berdasarkan pada konten file saat ini.  Dan bahkan jika kita melakukannya, pencarian tidak harus bergantung pada implementasi perpustakaan standar.  Bagaimana jika dalam proyek khusus ini kita telah mengganti <code>java.util.List</code> dengan kelas kita sendiri?  Pencarian harus memperhitungkan ini.  Dan, tentu saja, lambda digunakan tidak hanya dalam aliran standar: ada banyak metode lain yang dilewati. </p><br><p>  Akibatnya, kami dapat meminta indeks untuk daftar semua file Java yang menggunakan lambdas dengan jumlah parameter yang diperlukan dan jenis pengembalian yang valid (pada kenyataannya, kami hanya mencari empat opsi: void, non-void, boolean, dan ada).  Dan selanjutnya apa?  Apakah kita perlu membangun pohon PSI lengkap (semacam pohon parse dengan resolusi simbol, tipe inferensi, dan fitur pintar lainnya) untuk masing-masing file ini dan melakukan inferensi tipe yang tepat untuk lambda?  Untuk proyek besar, perlu waktu lama untuk mendapatkan daftar semua implementasi antarmuka, meskipun hanya ada dua. </p><br><p>  Jadi, kita perlu mengambil langkah-langkah berikut: </p><br><ul><li>  Tanyakan indeks (tidak mahal) </li><li>  Bangun PSI (mahal) </li><li>  Jenis Infer lambda (sangat mahal) </li></ul><br><p>  Untuk Java 8 dan yang lebih baru, ketik inferensi adalah operasi yang sangat mahal.  Dalam rantai panggilan yang kompleks, mungkin ada banyak parameter generik pengganti, nilai-nilai yang harus ditentukan menggunakan prosedur memukul keras yang dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 18</a> dari spesifikasi.  Untuk file saat ini, ini dapat dilakukan di latar belakang, tetapi memproses ribuan file yang belum dibuka dengan cara ini akan menjadi tugas yang mahal. </p><br><p>  Namun, di sini dimungkinkan untuk sedikit memotong sudut: dalam banyak kasus, kita tidak memerlukan jenis beton.  Kecuali suatu metode menerima parameter generik di mana lambda diteruskan ke sana, langkah substitusi parameter akhir dapat dihindari.  Jika kami telah menyimpulkan fungsi <code>java.util.function.Function&lt;T, R&gt;</code> lambda, kami tidak perlu mengevaluasi nilai-nilai parameter substitusi <code>T</code> dan <code>R</code> : sudah jelas apakah akan menyertakan lambda ke dalam hasil pencarian atau tidak.  Namun, itu tidak akan berfungsi untuk metode seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Class&lt;T&gt; aClass, T value)</span></span></span><span class="hljs-function"> </span></span>{}</code> </pre> <br><p>  Metode ini dapat dipanggil dengan <code>doSmth(Runnable.class, () -&gt; {})</code> .  Maka jenis lambda akan disimpulkan sebagai <code>T</code> , masih diperlukan penggantian.  Namun, ini adalah kasus yang jarang terjadi.  Kita sebenarnya dapat menghemat waktu CPU di sini, tetapi hanya sekitar 10%, jadi ini tidak menyelesaikan masalah pada intinya. </p><br><p>  Atau, ketika inferensi tipe yang tepat terlalu rumit, dapat dibuat perkiraan.  Berbeda dengan spesifikasi yang disarankan, biarkan itu bekerja hanya pada tipe kelas yang terhapus dan tidak mengurangi set kendala, tetapi cukup ikuti rantai panggilan.  Selama tipe yang dihapus tidak menyertakan parameter generik, semuanya baik-baik saja.  Mari pertimbangkan aliran dari contoh di atas dan tentukan apakah lambda terakhir mengimplementasikan <code>StringConsumer</code> : </p><br><ul><li>  <code>list</code> variabel -&gt; tipe <code>java.util.List</code> </li><li>  <code>List.stream()</code> â†’ tipe <code>java.util.stream.Stream</code> </li><li>  <code>Stream.filter(...)</code> -&gt; tipe <code>java.util.stream.Stream</code> , kita tidak perlu mempertimbangkan argumen <code>filter</code> </li><li>  demikian pula, <code>Stream.map(...)</code> â†’ tipe <code>java.util.stream.Stream</code> </li><li>  <code>Stream.forEach(...)</code> â†’ metode seperti itu ada, parameternya memiliki tipe <code>Consumer</code> , yang jelas bukan <code>StringConsumer</code> . </li></ul><br><p>  Dan itulah yang bisa kami lakukan tanpa inferensi tipe biasa.  Namun, dengan pendekatan sederhana ini, mudah untuk mengalami metode kelebihan beban.  Jika kami tidak melakukan inferensi jenis yang tepat, kami tidak dapat memilih metode kelebihan beban yang benar.  Namun terkadang itu mungkin: jika metode memiliki jumlah parameter yang berbeda.  Sebagai contoh: </p><br><pre> <code class="java hljs">CompletableFuture.supplyAsync(Foo::bar, myExecutor).thenRunAsync(s -&gt; list.add(s));</code> </pre> <br><p>  Di sini kita dapat melihat bahwa: </p><br><ul><li>  Ada dua metode <code>CompletableFuture.supplyAsync</code> ;  yang pertama mengambil satu argumen dan yang kedua mengambil dua, jadi kami memilih yang kedua.  Ini mengembalikan <code>CompletableFuture</code> . </li><li>  Ada dua metode <code>thenRunAsync</code> juga, dan kita juga bisa memilih salah satu yang mengambil satu argumen.  Parameter yang sesuai memiliki tipe <code>Runnable</code> , yang berarti bukan <code>StringConsumer</code> . </li></ul><br><p>  Jika beberapa metode mengambil jumlah parameter yang sama atau memiliki jumlah parameter yang bervariasi tetapi terlihat sesuai, kita harus mencari semua opsi.  Seringkali itu tidak menakutkan: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder().append(foo).append(bar).chars().forEach(s -&gt; list.add(s));</code> </pre> <br><ul><li>  <code>new StringBuilder()</code> jelas menciptakan <code>java.lang.StringBuilder</code> .  Untuk konstruktor, kami masih menyelesaikan referensi, tetapi inferensi tipe kompleks tidak diperlukan di sini.  Bahkan jika ada <code>new Foo&lt;&gt;(x, y, z)</code> , kami tidak akan menyimpulkan nilai-nilai parameter tipe karena hanya <code>Foo</code> yang menarik bagi kami. </li><li>  Ada banyak metode <code>StringBuilder.append</code> yang mengambil satu argumen, tetapi mereka semua mengembalikan tipe <code>java.lang.StringBuilder</code> , jadi kami tidak peduli tentang jenis <code>foo</code> dan <code>bar</code> . </li><li>  Ada satu metode <code>StringBuilder.chars</code> , dan ia mengembalikan <code>java.util.stream.IntStream</code> . </li><li>  Ada metode <code>IntStream.forEach</code> tunggal, dan dibutuhkan tipe <code>IntConsumer</code> . </li></ul><br><p>  Bahkan jika beberapa opsi tetap ada, Anda masih dapat melacak semuanya.  Misalnya, tipe lambda yang diteruskan ke <code>ForkJoinPool.getInstance().submit(...)</code> mungkin <code>Runnable</code> atau <code>Callable</code> , dan jika kami mencari opsi lain, kami masih dapat membuang lambda ini. </p><br><p>  Hal-hal menjadi lebih buruk ketika metode mengembalikan parameter generik.  Maka prosedur gagal dan Anda harus melakukan inferensi jenis yang tepat.  Namun, kami mendukung satu kasus.  Itu ditampilkan dengan baik di perpustakaan StreamEx saya, yang memiliki <code>AbstractStreamEx&lt;T, S extends AbstractStreamEx&lt;T, S&gt;&gt;</code> kelas abstrak yang berisi metode seperti <code>S filter(Predicate&lt;? super T&gt; predicate)</code> .  Biasanya orang bekerja dengan kelas <code>StreamEx&lt;T&gt; extends AbstractStreamEx&lt;T, StreamEx&lt;T&gt;&gt;</code> konkret <code>StreamEx&lt;T&gt; extends AbstractStreamEx&lt;T, StreamEx&lt;T&gt;&gt;</code> .  Dalam hal ini, Anda dapat mengganti parameter tipe dan mengetahui bahwa <code>S = StreamEx</code> . </p><br><p>  Begitulah cara kami menghilangkan inferensi tipe mahal untuk banyak kasus.  Tapi kami belum melakukan apa pun dengan pembangunan PSI.  Mengecewakan karena mengurai file dengan 500 baris kode hanya untuk mengetahui bahwa lambda on line 480 tidak cocok dengan kueri kami.  Mari kita kembali ke aliran kita: </p><br><pre> <code class="java hljs">list.stream() .filter(s -&gt; StringUtil.isNonEmpty(s)) .map(s -&gt; s.trim()) .forEach(s -&gt; list.add(s));</code> </pre> <br><p>  Jika <code>list</code> adalah variabel lokal, parameter metode, atau bidang dalam kelas saat ini, sudah pada tahap pengindeksan, kita dapat menemukan deklarasi dan menetapkan bahwa nama tipe pendek adalah <code>List</code> .  Dengan demikian, kita dapat memasukkan informasi berikut ke dalam indeks untuk lambda terakhir: </p><br><blockquote>  Tipe lambda ini adalah tipe parameter dari metode <code>forEach</code> yang mengambil satu argumen, dipanggil pada hasil metode <code>map</code> yang mengambil satu argumen, dipanggil pada hasil metode <code>filter</code> yang mengambil satu argumen, dipanggil pada hasil dari metode <code>stream</code> yang mengambil nol argumen, dipanggil pada objek <code>List</code> . </blockquote><p>  Semua informasi ini tersedia dari file saat ini dan, oleh karena itu, dapat ditempatkan dalam indeks.  Saat mencari, kami meminta informasi tersebut tentang semua lambda dari indeks dan mencoba untuk mengembalikan jenis lambda tanpa membangun PSI.  Pertama, kita harus melakukan pencarian global untuk kelas dengan nama <code>List</code> pendek.  Jelas, kita akan menemukan tidak hanya <code>java.util.List</code> tetapi juga <code>java.awt.List</code> atau sesuatu dari kode proyek.  Selanjutnya, semua kelas ini akan melalui prosedur inferensi tipe perkiraan yang sama yang kami gunakan sebelumnya.  Kelas redundan seringkali dengan cepat disaring.  Sebagai contoh, <code>java.awt.List</code> tidak memiliki metode <code>stream</code> , oleh karena itu akan dikecualikan.  Tetapi bahkan jika sesuatu yang berlebihan tetap ada dan kami menemukan beberapa kandidat untuk jenis lambda, kemungkinan tidak satupun dari mereka akan cocok dengan permintaan pencarian, dan kami masih akan menghindari membangun PSI lengkap. </p><br><p>  Pencarian global bisa menjadi terlalu mahal (ketika sebuah proyek mengandung terlalu banyak kelas <code>List</code> ), atau awal rantai tidak dapat diselesaikan dalam konteks satu file (katakanlah, itu adalah bidang kelas induk), atau rantai bisa pecah ketika metode mengembalikan parameter generik.  Kami tidak akan menyerah dan akan mencoba memulai kembali dengan pencarian global pada metode rantai berikutnya.  Misalnya, untuk <code>map.get(key).updateAndGet(a -&gt; a * 2)</code> , instruksi berikut masuk ke indeks: </p><br><blockquote>  Tipe lambda ini adalah tipe parameter tunggal dari metode <code>updateAndGet</code> , dipanggil pada hasil metode <code>get</code> dengan satu parameter, dipanggil pada objek <code>Map</code> . </blockquote><p>  Bayangkan kita beruntung, dan proyek ini hanya memiliki satu tipe <code>Map</code> <code>java.util.Map</code> .  Itu memang memiliki metode <code>get(Object)</code> , tetapi, sayangnya, ia mengembalikan parameter generik <code>V</code>  Kemudian kita akan membuang rantai dan mencari metode <code>updateAndGet</code> dengan satu parameter secara global (tentu saja menggunakan indeks).  Dan kami senang mengetahui bahwa hanya ada tiga metode dalam proyek ini: di kelas <code>AtomicInteger</code> , <code>AtomicLong</code> , dan <code>AtomicReference</code> dengan tipe parameter <code>IntUnaryOperator</code> , <code>LongUnaryOperator</code> , dan <code>UnaryOperator</code> .  Jika kami mencari jenis lain, kami telah menemukan bahwa lambda ini tidak cocok dengan permintaan, dan kami tidak harus membuat PSI. </p><br><p>  Anehnya, ini adalah contoh yang bagus dari fitur yang bekerja lebih lambat dengan waktu.  Misalnya, ketika Anda mencari implementasi antarmuka fungsional dan hanya memiliki tiga di antaranya dalam proyek Anda, dibutuhkan sepuluh detik bagi IntelliJ IDEA untuk menemukannya.  Anda ingat bahwa tiga tahun lalu jumlah mereka sama, tetapi IDE memberi Anda hasil pencarian hanya dalam dua detik pada mesin yang sama.  Dan meskipun proyek Anda sangat besar, hanya tumbuh lima persen selama bertahun-tahun ini.  Masuk akal untuk mulai menggerutu tentang kesalahan yang dilakukan pengembang IDE untuk membuatnya sangat lambat. </p><br><p>  Meskipun kita mungkin tidak mengubah apa pun.  Pencarian berfungsi seperti dulu tiga tahun lalu.  Masalahnya adalah bahwa tiga tahun yang lalu, Anda baru saja beralih ke Java 8 dan hanya memiliki seratus lambda di proyek Anda.  Sekarang, kolega Anda telah mengubah kelas anonim menjadi lambdas, sudah mulai menggunakan stream atau perpustakaan reaktif.  Hasilnya, alih-alih seratus lambda, ada sepuluh ribu.  Dan sekarang, untuk menemukan tiga yang diperlukan, IDE harus mencari opsi seratus kali lebih banyak. </p><br><p>  Saya berkata "kami mungkin" karena, tentu saja, kami kembali ke pencarian ini dari waktu ke waktu dan mencoba mempercepatnya.  Tapi itu seperti mendayung di sungai, atau lebih tepatnya di air terjun.  Kami berusaha keras, tetapi jumlah lambda dalam proyek terus tumbuh sangat cepat. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id451754/">https://habr.com/ru/post/id451754/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id451742/index.html">Satu hari sebelum DotNext 2019 Piter. Pengumuman Siaran Gratis</a></li>
<li><a href="../id451746/index.html">MegaSlerm untuk insinyur dan arsitek Kubernetes</a></li>
<li><a href="../id451748/index.html">Memantau Status SSD di Array Qsan</a></li>
<li><a href="../id451750/index.html">Buku "Elasticsearch, Kibana, Logstash, dan Mesin Pencari Generasi Selanjutnya"</a></li>
<li><a href="../id451752/index.html">Peringatan 30 tahun ketidakamanan yang merajalela</a></li>
<li><a href="../id451758/index.html">Uplink Tambahan dalam Arsitektur Logika Sistem Intel C620</a></li>
<li><a href="../id451760/index.html">Menggunakan Golang untuk Membuat Layanan Mikro di The Economist: A Retrospective</a></li>
<li><a href="../id451766/index.html">Heisenbug 2019 Piter: apa yang akan terjadi dalam siaran gratis, dan apa yang hanya ada di acara itu</a></li>
<li><a href="../id451768/index.html">Meningkatkan kerja Wi-Fi. Prinsip umum dan hal-hal berguna</a></li>
<li><a href="../id451770/index.html">Veeam Backup & Replication: Kiat Berguna untuk Membuat Cadangan dan Replika Dapat Digunakan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>