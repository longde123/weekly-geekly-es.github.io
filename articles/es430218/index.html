<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚öíÔ∏è üö∂üèæ ü•Ä Optimizaci√≥n de energ√≠a STM32: una gu√≠a pr√°ctica üêÉ üò™ üå¶Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! 

 Hay muchos art√≠culos en la red sobre el funcionamiento de los microcontroladores STM32 en dispositivos de eficiencia energ√©tica, general...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimizaci√≥n de energ√≠a STM32: una gu√≠a pr√°ctica</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430218/"> Hola Habr! <br><br>  Hay muchos art√≠culos en la red sobre el funcionamiento de los microcontroladores STM32 en dispositivos de eficiencia energ√©tica, generalmente dispositivos alimentados por bater√≠a, sin embargo, entre ellos es lamentable que no entiendan este tema fuera de la lista de modos de ahorro de energ√≠a y comandos SPL / HAL que los incluyen (sin embargo, se aplica el mismo reclamo) a la gran mayor√≠a de art√≠culos sobre c√≥mo trabajar con STM32). <br><br>  Mientras tanto, debido al r√°pido desarrollo de hogares inteligentes y todo tipo de IoT, el tema se est√° volviendo cada vez m√°s relevante: en tales sistemas, muchos componentes funcionan con bater√≠as y se esperan a√±os de operaci√≥n continua de ellos. <br><br>  Llenaremos este vac√≠o con el ejemplo de STM32L1, un controlador muy popular, bastante econ√≥mico y al mismo tiempo que tiene algunos problemas espec√≠ficos de esta serie.  Casi todo lo anterior tambi√©n se aplicar√° a STM32L0 y STM32L4, y en t√©rminos de problemas y enfoques comunes, a otros controladores basados ‚Äã‚Äãen n√∫cleos Cortex-M. <br><br><img src="https://habrastorage.org/webt/-r/az/lt/-razltjud_qdbwtc74aaopi69la.jpeg"><br><br>  El resultado pr√°ctico deber√≠a parecerse a la foto de arriba (y s√≠, tambi√©n hablaremos sobre la aplicabilidad de mult√≠metros y otros instrumentos de medici√≥n a tareas similares). <br><a name="habracut"></a><br><h3>  Modos de ahorro de energ√≠a en STM32L1 </h3><br>  Los conceptos b√°sicos del ahorro de bater√≠a son los principales modos de ahorro de energ√≠a del procesador.  Cada fabricante y cada serie de controladores tienen los suyos (un conjunto espec√≠fico es una extensi√≥n del proveedor de los modos de n√∫cleo Cortex-M est√°ndar con varios matices con respecto a la periferia, los voltajes de suministro, etc.). <br><br>  Espec√≠ficamente, el STM32L1, que pertenece a la serie econ√≥mica de controladores, y en relaci√≥n con esto, entre otras cosas, recibi√≥ un conjunto ampliado de configuraciones de energ√≠a, tenemos lo siguiente: <br><br><ul><li>  <b>Ejecutar</b> - modo normal.  Todo incluido, todos los perif√©ricos disponibles, frecuencia de hasta 32 MHz. </li><li>  <b>Low Power Run (LP Run)</b> : un modo especial con una frecuencia de funcionamiento dentro de 131 kHz y un consumo m√°ximo, <i>considerando toda la periferia</i> , 200 ŒºA.  En el modo LP Run, el regulador de potencia del procesador entra en un modo econ√≥mico especial, que ahorra hasta cincuenta microamperios en comparaci√≥n con el funcionamiento a la misma frecuencia en el modo Run. </li><li>  <b>Suspender</b> : suspensi√≥n del n√∫cleo, pero con la preservaci√≥n de todas las frecuencias de reloj.  Los perif√©ricos del procesador pueden continuar funcionando si el n√∫cleo no lo necesita, pero se puede apagar autom√°ticamente. </li><li>  <b>Low Power Sleep (LP Sleep)</b> : una combinaci√≥n de Sleep con la transici√≥n del estabilizador al modo econ√≥mico.  La frecuencia del reloj no es superior a 131 kHz, el consumo total no es superior a 200 ŒºA. </li><li>  <b>Parar</b> : una parada completa de todas las frecuencias de reloj, excepto el generador de "reloj" 32768 Hz, externo o interno.  En el caso de STM32L1, solo el reloj en tiempo real contin√∫a funcionando en este modo, todo lo dem√°s se detiene por completo;  En los procesadores m√°s nuevos, algunos perif√©ricos pueden sincronizarse a bajas frecuencias.  <i>Casi</i> todas las patas del procesador conservan su estado.  El contenido de la RAM se guarda, las interrupciones externas contin√∫an funcionando. </li><li>  <b>En espera</b> : un apagado completo del n√∫cleo del procesador, la RAM y todos los perif√©ricos, excepto los relojes en tiempo real.  La RAM no se guarda (es decir, desde el punto de vista del software, dejarlo en modo de espera es casi lo mismo que la distorsi√≥n de potencia; comience de nuevo), el RTC contin√∫a marcando.  Las interrupciones externas no funcionan, excepto por tres patas especiales WKUPx, cuyo cambio de 0 a 1 despierta el procesador. </li></ul><br>  Ingresar a cada uno de los modos es bastante simple: debe configurar los indicadores en tres a cinco registros, despu√©s de lo cual (para los modos de suspensi√≥n) llame a la instrucci√≥n WFI o WFE, esta es la instrucci√≥n est√°ndar de Cortex-M, significa "Esperar interrupci√≥n" y "Esperar evento" .  Dependiendo de los indicadores (se describen en el Manual de referencia del procesador, para STM32L1 es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RM0038</a> ), el procesador mismo entrar√° en este modo con este comando. <br><br>  Adem√°s, ser√≠a bueno prohibir las interrupciones (esto no afectar√° la capacidad de los eventos externos e internos para despertar al procesador del modo de suspensi√≥n) y esperar a que los datos se guarden de los registros a la memoria si sucede de repente, usando el comando DSB. <br><br>  Por ejemplo, as√≠ es como se ve el modo de parada: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*  PDDS    Stop  Standby,    */</span></span> PWR-&gt;CR &amp;= ~(PWR_CR_PDDS); <span class="hljs-comment"><span class="hljs-comment">/*  Wakeup   ,      */</span></span> PWR-&gt;CR |= PWR_CR_CWUF; <span class="hljs-comment"><span class="hljs-comment">/*    low-power ,    Stop -    */</span></span> PWR-&gt;CR |= PWR_CR_LPSDSR; <span class="hljs-comment"><span class="hljs-comment">/*    Vref   */</span></span> PWR-&gt;CR |= PWR_CR_ULP; <span class="hljs-comment"><span class="hljs-comment">/*     Cortex-M,  Stop,  Standby -   Deep Sleep */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      Deep Sleep */</span></span> SCB-&gt;SCR |= (SCB_SCR_SLEEPDEEP_Msk); <span class="hljs-comment"><span class="hljs-comment">/*  ;       */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> state = irq_disable(); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> __DSB(); <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> __WFI(); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> init_clk(); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> irq_restore(state);</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WFI</a> es una instrucci√≥n de bloqueo, en √©l el procesador entrar√° en suspensi√≥n profunda y no saldr√° hasta que ocurra alg√∫n tipo de interrupci√≥n.  S√≠, repito, a pesar de que desactivamos expl√≠citamente las interrupciones, el procesador responder√° a ellas y se despertar√°, pero solo comenzar√° a procesarse despu√©s de que las volvamos a encender.  Y esto tiene un significado profundo. <br><br>  En el c√≥digo anterior, despu√©s de WFI, alg√∫n tipo de reinicializaci√≥n de las frecuencias de operaci√≥n no es as√≠: el hecho es que L1 <i>siempre</i> deja el sue√±o profundo a la frecuencia de 4.2 MHz y con el generador interno MSI como fuente de esta frecuencia.  En muchas situaciones, obviamente no desea que el controlador de interrupciones que activa el procesador comience a funcionar a esta frecuencia, por ejemplo, porque las frecuencias de todos los temporizadores, UART y otros buses se volar√°n;  por lo tanto, primero restauramos las frecuencias de operaci√≥n (o, si queremos permanecer en MSI, recalculamos los buses necesarios por debajo de 4.2 MHz), y luego nos sumergimos en las interrupciones. <br><br>  En la pr√°ctica, los dos modos m√°s utilizados son Run y ‚Äã‚ÄãStop.  El hecho es que LP Run es dolorosamente lento y no tiene sentido si el procesador necesita realizar algunos c√°lculos y no solo esperar eventos externos, y Sleep y LP Sleep no son demasiado econ√≥micos (consumo de hasta 2 mA) y son necesarios si lo necesita ahorre al menos un poco, pero al mismo tiempo deje los perif√©ricos en funcionamiento y / o proporcione la reacci√≥n m√°s r√°pida posible del procesador a los eventos.  Tales requisitos existen, pero en general no muy a menudo. <br><br>  El modo de espera generalmente no se usa, porque despu√©s de que es imposible continuar desde donde lo dej√≥ debido a la puesta a cero de RAM, tambi√©n hay algunos problemas con dispositivos externos, que analizaremos a continuaci√≥n, que requieren soluciones de hardware.  Sin embargo, si el dispositivo se dise√±√≥ teniendo esto en cuenta, el modo de espera se puede utilizar como modo "apagado", por ejemplo, durante el almacenamiento a largo plazo de este dispositivo. <br><br>  En realidad, en la presentaci√≥n de esto, la mayor√≠a de los manuales generalmente se rompen triunfalmente. <br><br>  El problema es que, sigui√©ndolos, obtendr√° triste 100-200 ŒºA de consumo real en lugar de los prometidos 1.4 ŒºA en Stop con las horas de trabajo, incluso en la depuraci√≥n de referencia de Nucleo, que no tiene chips externos, sensores, etc. a lo que podr√≠a atribuirse. <br><br>  Y no, su procesador est√° funcionando, no hay nada en las erratas, e hizo todo bien. <br><br>  Simplemente no hasta el final. <br><br><h3>  S√≠ndrome de piernas inquietas </h3><br>  El primer problema STM32L1, sobre el cual <i>algunos</i> art√≠culos mencionan, pero que con mayor frecuencia solo se recuerdan en foros, cuando en el tercer d√≠a de discusi√≥n, de d√≥nde provienen los 100-200 ŒºA, alguien recuerda la existencia de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AN3430</a> y llega a la p√°gina 19 en √©l. estado de las piernas por defecto. <br><br>  Observo que incluso STMicro se refiere al problema a trav√©s de las fundas, y en la mayor√≠a de los documentos donde se considera la optimizaci√≥n del consumo de energ√≠a, se limita a una o dos frases con el consejo de tirar las piernas no utilizadas al suelo o ponerlas en modo de entrada anal√≥gica, sin explicar las razones. <br><br>  Lo triste es que, por defecto, todas las patas est√°n configuradas como entradas digitales (0x00 en el registro GPIOx_MODER).  Un disparador Schmitt siempre est√° en la entrada digital, lo que mejora la inmunidad al ruido de esta entrada, y es completamente independiente: es un elemento l√≥gico simple, un b√∫fer con hist√©resis que no requiere reloj externo. <br><br>  En nuestro caso, esto significa que apagamos el reloj en modo Stop, y los disparadores Schmitt continuaron funcionando como si nada hubiera sucedido; dependiendo del nivel de la se√±al de entrada, cambian sus salidas a 0 y 1. <br><br>  Al mismo tiempo, parte de las patas del procesador en un circuito t√≠pico cuelga en el aire, es decir, no hay se√±al inteligible en ellas.  Ser√≠a un error pensar que la ausencia de una se√±al clara significa que en estos tramos 0 no es, en estos tramos debido a su alta impedancia de entrada, hay alg√∫n ruido aleatorio de un valor indeterminado, desde las pastillas y la corriente que fluye desde las pistas vecinas hasta el primer canal de televisi√≥n, si el pie es lo suficientemente largo como para servir como antena (sin embargo, los televisores anal√≥gicos en Rusia pronto se apagar√°n, lo que deber√≠a conducir a una disminuci√≥n en el consumo de energ√≠a de los microcontroladores configurados incorrectamente). <br><br>  De acuerdo con estas fluctuaciones, el tramo de alguna manera aleatoria cambia entre 0 y 1. La l√≥gica CMOS consume corriente al cambiar.  Es decir, una <i>pata de procesador suspendida en el aire, configurada en modo de entrada digital, consume una corriente notable en s√≠ misma</i> . <br><br>  La soluci√≥n a esto es simple: cuando inicia el programa, debe configurar todas las patas para el estado de la entrada anal√≥gica;  STM32 lo tiene formalmente para todas las patas sin excepci√≥n, independientemente de si est√°n conectadas al ADC o no, y difiere de la entrada digital solo en ausencia de un disparador Schmitt en la entrada. <br><br><img src="https://habrastorage.org/webt/nm/k2/py/nmk2py-r1zqa2rgltekzx69bmy8.png"><br><br>  Para hacer esto, es suficiente escribir el valor 0xFF ... FF en todos los registros GPIOx_MODER, es m√°s f√°cil hacer esto, como se mencion√≥ anteriormente, justo al comienzo, y luego durante el transcurso de la reproducci√≥n, reconfigurar las piernas individuales seg√∫n sea necesario en este dispositivo. <br><br>  Aqu√≠, sin embargo, surge un problema de segundo orden: es bueno si su firmware funciona en un controlador espec√≠fico y, por lo tanto, siempre sabe qu√© es <i>x</i> en GPIOx.  Peor a√∫n si el firmware es universal: el STM32 puede tener <i>hasta</i> 8 puertos, pero puede ser m√°s peque√±o;  cuando intente escribir en un puerto que no existe en este modelo del controlador, obtendr√° una falla grave, es decir  ca√≠da del n√∫cleo <br><br>  Sin embargo, incluso este caso se puede eludir: Cortex-M le permite verificar la validez de las direcciones, adem√°s, en el caso de M3 y M4, el cheque generalmente es bastante trivial, pero en M0 requiere algo de magia, pero es realizable (los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">detalles se pueden leer aqu√≠</a> , no veremos este art√≠culo). ) <br><br>  Es decir, en general, el procesador inici√≥, sintoniz√≥ las frecuencias e inmediatamente pas√≥ por todos los puertos GPIO disponibles, escribi√©ndolos en los MODEROS (el c√≥digo a continuaci√≥n est√° escrito para RIOT OS, pero en general es claro sin comentarios y puede transferirse a tres minutos cualquier otra plataforma). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(CPU_FAM_STM32L1) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* switch all GPIOs to AIN mode to minimize power consumption */</span></span></span><span class="hljs-meta"> GPIO_TypeDef *port; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* enable GPIO clock */</span></span></span><span class="hljs-meta"> uint32_t ahb_gpio_clocks = RCC-&gt;AHBENR &amp; 0xFF; periph_clk_en(AHB, 0xFF); for (uint8_t i = 0; i </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; 8; i++) { port = (GPIO_TypeDef *)(GPIOA_BASE + i*(GPIOB_BASE - GPIOA_BASE)); if (cpu_check_address((char *)port)) { port-&gt;MODER = 0xffffffff; } else { break; } } /* restore GPIO clock */ uint32_t tmpreg = RCC-&gt;AHBENR; tmpreg &amp;= ~((uint32_t)0xFF); tmpreg |= ahb_gpio_clocks; periph_clk_en(AHB, tmpreg); #endif</span></span></span></span></code> </pre><br>  Observo que esto solo se aplica a la serie L1, en L0 y L4 se tuvo en cuenta la experiencia y, de forma predeterminada, configuran todos los puertos como entradas anal√≥gicas al inicio. <br><br>  Despu√©s de haber realizado todos estos procedimientos cuidadosamente, llene el firmware en el dispositivo terminado ... y obtenga 150 uA en modo Stop en el procesador y todos los chips externos apagados, a pesar de que sus estimaciones son las m√°s pesimistas, provenientes de las hojas de datos de todo lo que ha soldado en la placa dar no m√°s de 10 ŒºA. <br><br>  Adem√°s, intenta llevar el procesador al modo de espera en lugar de detenerlo, es decir  simplemente ap√°guelo casi por completo, y en lugar de caerse, el consumo de energ√≠a aumenta tres veces, ¬°acerc√°ndose a casi medio miliamperio! <br><br>  No hay necesidad de entrar en p√°nico.  Como habr√°s adivinado, hiciste todo bien.  Pero no hasta el final. <br><br><h3>  S√≠ndrome de piernas inquietas - 2 </h3><br>  El siguiente problema tiene dos partes. <br><br>  La primera es bastante obvia: si su dispositivo no consta de un microcontrolador, entonces es importante no olvidar que los chips externos tambi√©n tienen se√±ales de entrada en las que los activadores Schmitt se cuelgan y que, adem√°s, pueden despertar la l√≥gica interna del chip.  Por ejemplo, un chip que es retirado y retirado de su sue√±o por el equipo de UART intentar√° leer datos de √©l con cualquier movimiento en este autob√∫s. <br><br>  En consecuencia, si todas estas patas est√°n colgadas en el aire, no obtendremos nada bueno. <br><br>  ¬øEn qu√© condiciones terminan en el aire? <br><br>  En primer lugar, cuando el controlador entra en modo de espera, todos los GPIO se transfieren al estado High-Z, con alta resistencia, es decir, de hecho, los chips externos conectados a ellos est√°n en el aire.  Es imposible arreglar esto mediante programaci√≥n en STM32L1 (en otras series y otros controladores ocurre de diferentes maneras), por lo tanto, la √∫nica salida es en un sistema que usa el modo de espera, las entradas de chips externos deben ser puestas a tierra o alimentadas por resistencias externas. <br><br>  Se elige un nivel espec√≠fico para que la l√≠nea est√© inactiva desde el punto de vista del chip: <br><br><ul><li>  1 para UART TX </li><li>  0 para SPI MOSI </li><li>  0 para SPI CLK en el modo SPI 0 o 1 </li><li>  1 para SPI CLK con SPI Mode 2 o 3 </li><li>  1 para SPI CS </li></ul><br>  En segundo lugar, en STM32 <i>cuando se utiliza el modo Stop</i> (sic!) <i>, El</i> estado de los GPIO conectados a los bloques de hardware internos de las interfaces puede ser ... diferente.  Es decir, la misma interfaz SPI, cuando est√° configurada, en Stop de repente resulta ser una entrada digital o, en general, High-Z, con las consecuencias correspondientes para los chips externos que la cuelgan.  Si bien la documentaci√≥n establece que las patas est√°n en buenas condiciones, a priori puede confiar en ellas solo si las usa como GPIO normales. <br><br>  No puede entenderlo y perdonarlo, pero puede recordarlo y solucionarlo: para las interfaces que se comportan de esta manera, debe agregar el cambio forzado a GPIO normal con niveles correspondientes a niveles inactivos de esta interfaz en la funci√≥n de cuidado del sue√±o.  Despu√©s de salir del sue√±o, las interfaces se pueden restaurar. <br><br>  Por ejemplo, el mismo SPI antes de ir a dormir (por simplicidad, tomo el c√≥digo del sistema operativo RIOT, est√° claro que lo mismo es f√°cil de implementar en los registros): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* specifically set GPIOs used for external SPI devices */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* MOSI = 0, SCK = 0, MISO = AIN for SPI Mode 0 &amp; 1 (CPOL = 0) */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* MOSI = 0, SCK = 1, MISO = AIN for SPI Mode 2 &amp; 3 (CPOL = 1) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; SPI_NUMOF; i++) { <span class="hljs-comment"><span class="hljs-comment">/* check if SPI is in use */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_periph_clk(spi_config[i].apbbus, spi_config[i].rccmask) == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* SPI CLK polarity */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spi_config[i].dev-&gt;CR1 &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>)) { gpio_init(spi_config[i].sclk_pin, GPIO_IN_PU); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { gpio_init(spi_config[i].sclk_pin, GPIO_IN_PD); } gpio_init(spi_config[i].mosi_pin, GPIO_IN_PD); gpio_init(spi_config[i].miso_pin, GPIO_AIN); } }</code> </pre><br>  Tenga en cuenta que las salidas aqu√≠ est√°n configuradas no como GPIO_OUT con un nivel de 0 o 1, sino como entradas con un pull-up a 0 o 1; este no es un punto fundamental, pero proporciona seguridad adicional si comete un error e intenta jugar pull-push con alg√∫n tipo de un chip externo tirando de esta pata hacia el otro lado.  Con GPIO_OUT puede organizar un cortocircuito, con GPIO_IN con un pull-up, nunca. <br><br>  Adem√°s, la se√±al SPI CS no se ve afectada; en este caso, se genera mediante programaci√≥n, es decir, por un GPIO normal, y mantiene su estado en un sue√±o con confianza. <br><br>  Para restaurar el estado de la pierna al salir del sue√±o, es suficiente escribir los valores de los registros que se cambiar√°n (MODER, PUPDR, OTYPER, OSPEEDR - vea la situaci√≥n en un caso particular) en la entrada, en variables, y vuelva a colocarlos en los registros al salir del sue√±o de las variables . <br><br>  Y ahora ... ta daaam!  Imagen del t√≠tulo  Uno y medio microamperios. <br><br>  Pero es muy temprano para celebrar.  En esto hemos terminado la optimizaci√≥n <i>est√°tica</i> del consumo de energ√≠a, y por delante tenemos una <i>din√°mica</i> . <br><br><h3>  Aquiles vs tortuga </h3><br>  ¬øQu√© es mejor: comer m√°s y correr m√°s r√°pido o comer menos, pero correr m√°s lento?  En el caso de los microcontroladores, la respuesta a esta pregunta es dos veces no trivial. <br><br>  En primer lugar, las frecuencias de funcionamiento se pueden cambiar en un rango muy amplio: de 65 kHz (LP Run) a 32 MHz en modo normal.  Como cualquier chip CMOS, STM32 tiene dos componentes en el consumo de energ√≠a: est√°tico y din√°mico;  el segundo depende de la frecuencia, el primero es constante.  Como resultado, el consumo de energ√≠a no disminuir√° tan r√°pido como la frecuencia de operaci√≥n y la productividad, y dependiendo de la tarea, la frecuencia √≥ptima desde el punto de vista de la eficiencia energ√©tica puede ser diferente, donde debe esperar alg√∫n evento, pero por alguna raz√≥n no puede ir a dormir, habr√° las frecuencias bajas son efectivas, donde solo necesita trillar los n√∫meros: altos.  En las tareas t√≠picas de "promedio hospitalario", generalmente no tiene sentido ir por debajo de 2-4 MHz. <br><br>  En segundo lugar, y este es un momento menos trivial, la tasa de sue√±o depende de la frecuencia de trabajo y la forma en que se recibe. <br><br>  El peor de los casos es salir del sue√±o a una frecuencia de 32 MHz de un cuarzo externo (perm√≠tame recordarle que STM32L1 se despierta en un oscilador interno de 4 MHz), porque consta de tres etapas: <br><br><ul><li>  en realidad el procesador se despierta del sue√±o </li><li>  estabilizaci√≥n de generaci√≥n de cuarzo (1-24 MHz) </li><li>  Estabilizaci√≥n de generaci√≥n PLL (32 MHz) </li></ul><br>  En realidad, sacar el procesador del modo inactivo aqu√≠ es el problema m√°s peque√±o, a una frecuencia de 4.2 MHz se necesitan unos 10 Œºs.  Pero la estabilizaci√≥n del cuarzo puede tomar hasta 1 ms (aunque generalmente para resonadores de alta velocidad a√∫n es m√°s r√°pido, del orden de varios cientos de microsegundos), el acceso al modo PLL es de otros 160 Œºs. <br><br>  Estas demoras pueden no ser significativas desde el punto de vista del consumo de energ√≠a para un sistema que rara vez se despierta (no m√°s de una vez por segundo), pero donde el per√≠odo entre las activaciones es de decenas de milisegundos y menos, y las activaciones en s√≠ son cortas, la sobrecarga comienza a hacer una adici√≥n ya medible incluso teniendo en cuenta que durante la activaci√≥n, el procesador consume una corriente relativamente peque√±a. <br><br>  ¬øQu√© se puede hacer con esto?  En general, la respuesta es obvia: trate de evitar el uso de cuarzo externo.  Por ejemplo, un programa en el que hay subtareas pesadas raras que requieren un reloj preciso (por ejemplo, de las triviales: intercambio de datos UART) y subtareas simples frecuentes, puede decidir dentro de s√≠ mismo cada vez que se despierte si es necesario irse por ahora cuarzo externo, o ser√° m√°s f√°cil (¬°y m√°s r√°pido!) realizar la tarea actual en el generador MSI, en el que el procesador ya se ha despertado sin perder mucho tiempo inicializando las frecuencias. <br><br>  En este caso, sin embargo, puede ser necesario ajustar las frecuencias de reloj de la periferia, as√≠ como ajustar los modos de acceso a la memoria flash (el n√∫mero de ciclos de retraso), el voltaje del n√∫cleo del procesador (en STM32L1 se selecciona entre tres valores posibles), etc.  Sin embargo, con respecto a los modos de funcionamiento del n√∫cleo y la memoria, a menudo es posible ajustarlos eligiendo los recomendados para la frecuencia m√°xima utilizada, ya que el funcionamiento no √≥ptimo del n√∫cleo a frecuencias m√°s bajas no dar√° un cambio significativo en el rendimiento pr√°ctico y el consumo de energ√≠a debido al peque√±o volumen de tareas en estas frecuencias. realizado. <br><br>  Aunque todas estas medidas ya se aplican al ajuste de modos (y, por ejemplo, la mayor√≠a de los sistemas operativos y las bibliotecas ni siquiera saben nada parecido), en algunos casos pueden reducir el consumo promedio en una escala de unidades de porcentaje, y a veces incluso m√°s.  Imagine, por ejemplo, un medidor de agua que sondea los contactos de un interruptor de l√°minas cada 50 ms, mientras que la encuesta real toma varias decenas de microsegundos: ¬ødesea agregar ~ 500 Œºs en este momento para activar el controlador? <br><br><h3>  Segundo insoportablemente largo </h3><br>  Otro problema que no est√° directamente relacionado con la conservaci√≥n de energ√≠a, sino que surge inevitablemente en relaci√≥n con √©l: ¬øc√≥mo contar los intervalos de tiempo de menos de 1 segundo? <br><br>  El hecho es que en STM32L1 solo hay un temporizador que funciona en el modo Stop: este es RTC, la unidad de tiempo est√°ndar para la cual es 1 segundo.  Al mismo tiempo, en los programas hay intervalos de tiempo constantes de unidades, decenas y cientos de milisegundos, para tomar al menos el mismo medidor de agua. <br><br>  Como ser  ¬øFunciona en procesadores con temporizadores LPTIM, con reloj a 32768 Hz?  Una buena opci√≥n, de hecho, pero no siempre necesaria.  Es posible sin ella. <br><br>  No en todos los STM32L1, pero comenzando con Cat.  2 (estos son los procesadores STM32L151CB-A, STM32L151CC y m√°s nuevos), el bloque RTC se complement√≥ con un nuevo registro: SSR, SubSeconds Register.  M√°s precisamente, no se complement√≥ tanto como lo hizo visible para el usuario, adem√°s de que se agregaron las alarmas de segundos ALRMASSR y ALRMBSSR. <br><br>  Este registro no contiene unidades de tiempo claras; fue creado desde un contador t√©cnico interno.  En STM32L1, un reloj que marca a 32768 Hz pasa a trav√©s de dos contadores divisores, as√≠ncronos y sincr√≥nicos, que en total normalmente lo dividen por 32768 para obtener un tic de 1 segundo para el reloj.  Entonces, SSR es solo el valor actual del segundo contador. <br><br>  Aunque el SSR no cuenta en milisegundos, sino en sus unidades, la dimensi√≥n de estas unidades se puede cambiar cambiando la relaci√≥n de los divisores del contador s√≠ncrono y as√≠ncrono, manteniendo su coeficiente total igual a 32768 para obtener el est√°ndar de 1 segundo en la entrada RTC.  Conociendo estos coeficientes, podemos calcular el precio de una divisi√≥n de SSR en milisegundos, y desde aqu√≠ podemos proceder a programar alarmas de segundos. <br><br>  Cabe se√±alar que un contador previo as√≠ncrono es m√°s econ√≥mico que un SSR s√≠ncrono y, por lo tanto, establecerlo en 1 y dividir la frecuencia de entrada en SSR por 32768, habiendo recibido un recuento de solo 30 Œºs, es energ√©ticamente desventajoso.  Para nosotros, determinamos el valor √≥ptimo para el divisor preliminar 7, para s√≠ncrono - 4095 ((7 + 1) * (4095 + 1) = 32768).  Con una disminuci√≥n adicional en el divisor preliminar, el consumo de energ√≠a de RTC comienza a crecer de manera medible, en una fracci√≥n de una microamperia, pero dado que comparamos esto con la "referencia" 1.4 ŒºA en modo Stop, incluso las fracciones son importantes.  Por defecto, para STM32L1 estos valores son 127 y 255, es decir  el precio de referencia es de aproximadamente 4 ms, lo cual es un poco aproximado. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si desea profundizar en el c√≥digo, a su debido tiempo </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">finalizamos el controlador RTC est√°ndar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de RIOT OS para admitir RTC_SSR e intervalos de milisegundos. </font><font style="vertical-align: inherit;">Desde entonces, lo hemos estado usando literalmente en cada paso (y desde que trabajamos en el sistema operativo, un servicio tambi√©n se cuelga encima de √©l, lo que le permite colgar casi cualquier n√∫mero de tareas con per√≠odos arbitrarios en un temporizador de hardware con un simple movimiento de la mu√±eca). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El mismo enfoque se transfiere a los controladores STM32L0 y STM32L4, todos los modelos tienen el registro RTC_SSR; </font><font style="vertical-align: inherit;">Esto elimina la necesidad de temporizadores LPTIM y unifica el c√≥digo para diferentes plataformas.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C√≥mo entender que un mult√≠metro miente </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por supuesto, despu√©s de todas las optimizaciones, surge la pregunta leg√≠tima: ¬øqu√©, de hecho, hemos logrado? Sin saber la respuesta, uno podr√≠a limitarse por completo a un WFE con indicadores configurados correctamente, ir a dormir y obtener su 200-500 ŒºA. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La forma m√°s tradicional de medir la corriente es, por supuesto, un mult√≠metro. Comprender que est√° acostado sobre una carga como un microcontrolador con su consumo din√°mico es muy simple: si est√° encendido, est√° mintiendo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto, sin embargo, no significa que el mult√≠metro sea in√∫til en este asunto. Solo necesita poder aplicarlo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En primer lugar, un mult√≠metro es algo muy lento, un tiempo t√≠pico para un recuento en √©l es una segunda escala, un tiempo t√≠pico para cambiar el estado de un microcontrolador es una escala de microsegundos. En un sistema que cambia su consumo a ese ritmo, el mult√≠metro simplemente mostrar√° valores aleatorios. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, una de las variables no aleatorias de inter√©s para nosotros es el consumo del microcontrolador en modo de suspensi√≥n; Si excede significativamente el valor que estimamos en las hojas de datos, entonces algo est√° claramente mal. Este es el consumo de un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sistema est√°tico</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , es decir, se puede medir con un mult√≠metro.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El m√©todo m√°s trivial que se muestra en la foto del t√≠tulo es un mult√≠metro en modo microamper√≠metro, que ahora se encuentra en la mayor√≠a de los modelos de rango medio, y tiene buena precisi√≥n y excelente resoluci√≥n. </font><font style="vertical-align: inherit;">UT120C tiene una resoluci√≥n de 0.1 ŒºA con una precisi√≥n certificada de ¬± 1% ¬± 3 descargas, lo cual es suficiente para nosotros.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solo hay un problema con este modo: los mult√≠metros tienen una gran resistencia en serie, una escala de cientos de ohmios, por lo que en modo normal, un microcontrolador con un mult√≠metro de este tipo en el circuito de alimentaci√≥n simplemente no se iniciar√°. </font><font style="vertical-align: inherit;">Afortunadamente, las posiciones de "mA" y "uA" en casi todos los instrumentos de la b√°scula est√°n cercanas, los z√≥calos para medir en ambos rangos son los mismos, por lo que puede iniciar el controlador de forma segura en el l√≠mite de "mA", y cuando se vaya a dormir, haga clic en "uA" "- esto sucede lo suficientemente r√°pido como para que el controlador no tenga tiempo de perder energ√≠a y reiniciar.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta que si el controlador experimenta picos en la actividad, este m√©todo no es aplicable. Por ejemplo, el temporizador de vigilancia se reinicia cada 15 segundos en el firmware del dispositivo; en estos momentos, el mult√≠metro logra mostrar algo en la regi√≥n de 27 ŒºA, que, por supuesto, no tiene nada que ver con el clima en Marte. Si ocurre algo arbitrariamente corto en su sistema con m√°s frecuencia que una vez cada 5-10 segundos, el mult√≠metro simplemente mentir√°. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otra forma de medir la </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est√°tica.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Estoy destacando directamente esta palabra) el consumo por un mult√≠metro es una medida de la ca√≠da en una derivaci√≥n externa. Si desea medir corrientes ultrapeque√±as en la escala de unas pocas decenas de microamperios, debe colocar una derivaci√≥n grande (por ejemplo, 1 kOhm) y, en paralelo, un diodo Schottky en conexi√≥n directa. Si la derivaci√≥n cae m√°s de 0.3 V, el diodo se abrir√° y limitar√° la ca√≠da de voltaje, y hasta 0.3 V puede medir la ca√≠da con seguridad con un mult√≠metro en el rango de milivoltios, 1 mV = 1 ŒºA. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por desgracia, no funcionar√° medir la ca√≠da en una derivaci√≥n de baja impedancia con un mult√≠metro t√≠pico: los dispositivos de clase media, incluso si muestran algo por debajo de 100 ŒºV, la precisi√≥n en este rango es lamentable. Si tiene un buen dispositivo de escritorio que puede mostrar 1 uV, ya no necesita mi consejo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, las estad√≠sticas son buenas, pero ¬øqu√© pasa con la din√°mica? </font><font style="vertical-align: inherit;">¬øC√≥mo evaluar el mismo efecto de diferentes frecuencias en el consumo de energ√≠a promedio? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ todo es complicado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anotemos los requisitos b√°sicos:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rango de corriente de al menos 1 ŒºA - 100 mA (10 ^ 5) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> per√≠odo de medici√≥n no m√°s de 10 Œºs </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ca√≠da de tensi√≥n no superior a 100 mV </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> duraci√≥n de la medici√≥n: ilimitada </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si simplemente traducimos esto directamente a n√∫meros, obtenemos un ADC relativamente r√°pido y no menor de 18 bits con un sesgo de entrada de menos de 30 ŒºV, un extremo frontal anal√≥gico capaz de medir voltajes de 1 ŒºV y una interfaz r√°pida a la computadora que nos permitir√° transferir todo esto y guardar </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y todo esto para un solo uso. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ya ves, s√≠, ¬øpor qu√© esas cosas no se encuentran en cada esquina de diez d√≥lares? Keysight N6705C en la primera aproximaci√≥n cumple con nuestros requisitos, solo cuesta $ 7960.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entre las soluciones de presupuesto, por ejemplo, SiLabs integra la medici√≥n actual en sus depuraciones: las caracter√≠sticas de su Sistema de monitoreo de energ√≠a avanzado (AEM) dependen del modelo de depuraci√≥n espec√≠fico y tienen el mayor problema con la velocidad de medici√≥n. En los antiguos "kits de inicio", el STK3300 / 3400 es solo de 100 Hz, en los nuevos debugs el STK3700 / 3800 (f√°cilmente reconocible por textolite negro) - 6.25 kHz, y en los modelos m√°s antiguos de la serie DK puede alcanzar hasta 10 kHz, pero tambi√©n cuesta ya son $ 300 +. Para tareas serias, SiLabs recomienda oficialmente el mencionado Keysight.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En principio, dicho dispositivo puede ser dise√±ado por usted mismo: en primer lugar, necesita amplificadores operacionales muy buenos con un sesgo de entrada m√≠nimo, como OPA2335. Dichos amplificadores operacionales se colocan en la misma derivaci√≥n de 2-3 piezas con diferentes factores de amplificaci√≥n, todos ellos est√°n conectados a diferentes entradas de ADC (con este enfoque, es muy posible usar el microcontrolador incorporado), luego cada adquisici√≥n de datos determina program√°ticamente cu√°l de los amplificadores operacionales en este el momento no est√° sobrecargado, se cuentan las lecturas del mismo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El problema de la velocidad de transferencia de datos a una computadora se resuelve de manera bastante simple, ya que para fines pr√°cticos estamos interesados ‚Äã‚Äãprincipalmente en el consumo promedio del sistema en la vida real, las lecturas de microsegundos se pueden recopilar en el microcontrolador incorporado del medidor y el promedio aritm√©tico para una escala razonable de milisegundos se puede enviar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s, como muestra la pr√°ctica, es muy √∫til tener un medidor-registrador, aunque simple y no demasiado preciso, pero siempre a mano, para no tener sorpresas con alg√∫n tipo de cambio de firmware interrumpido por el ahorro de energ√≠a.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por ejemplo, incorporamos uno en nuestro adaptador USB est√°ndar UMDK-RF, que se usa constantemente para depurar firmware: ya tiene un programador SWD con soporte para el protocolo DAPLink, un puente USB-UART y l√≥gica de administraci√≥n de energ√≠a, respectivamente, tiene un medidor de consumo Casi gratis. El medidor en s√≠ es un shunt de 1 Ohm y un amplificador INA213 (ganancia 50 veces, compensaci√≥n cero t√≠pica de 5 ŒºV): el </font></font><br><br><img src="https://habrastorage.org/webt/me/l_/dr/mel_drvu6rqzwr1bebtbtayfiiw.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">amplificador est√° conectado directamente a la entrada del ADC del microcontrolador (STM32F042F6P6), el ADC procesa con un per√≠odo de 10 Œºs usando un temporizador de hardware, y hasta a trav√©s de USB los datos promediados se emiten para un intervalo de 100 ms. Como resultado, al cambiar algo en la l√≥gica del firmware, puede simplemente fumar o tomar un caf√©, dejar el dispositivo sobre la mesa y regresar, ver un horario como este:</font></font><br><br><img src="https://habrastorage.org/webt/qp/e2/h1/qpe2h1zrmci58iozay_rmag-lsm.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La precisi√≥n de un dispositivo "libre" de este tipo, por supuesto, no es alta: con un ADC de 12 bits y un amplificador, la cantidad m√≠nima es de 16 ŒºA, pero es extremadamente √∫til para evaluar de forma r√°pida y regular el comportamiento de los dispositivos depurados desde el punto de vista del consumo de energ√≠a. Al final, si haces algo mal en el firmware o dispositivo, entonces con una garant√≠a muy alta podr√°s salir de unidades de microamperios al menos cientos, y esto ser√° claramente visible. </font></font><br><br><img src="https://habrastorage.org/webt/np/kb/ko/npkbkoxcwb3xsmoyshtkjtc3-jq.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otra ventaja adicional es que, dado que los datos se env√≠an al puerto COM virtual en forma de texto (valores en microamperios), puede colocar la ventana del terminal junto a la ventana que muestra la consola del dispositivo y ver el consumo de energ√≠a al mismo tiempo que los mensajes de depuraci√≥n.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Me jacto de esto por una raz√≥n, pero para ofrecer a todos los que quieran usar este programador de depuraci√≥n m√≠nimo (¬°y muy barato!) En sus propios proyectos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede dibujar el diagrama </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fuente en DipTrace</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), arrastrar el firmware </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (brunch umdk-rf, al construir el objetivo es UMDK-RF, basado en el proyecto </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dap42</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). El diagrama se dibuja desordenado, pero espero que los puntos principales est√©n claros, el firmware est√° escrito en C usando libopencm3 y se ensambla con el arm-none-eabi-gcc habitual. Como funciones adicionales, el firmware tiene administraci√≥n de energ√≠a, captura se√±ales de sobrecarga de las teclas de control e ingresa el controlador conectado a √©l en su cargador de arranque nativo con solo presionar un bot√≥n.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NB: si desea que el bot√≥n de arranque incorpore el controlador del programador en su gestor de arranque de manera regular, debe cambiar la polaridad de la conexi√≥n, la edici√≥n de bytes de opci√≥n del controlador en el primer arranque y la entrada del programa en el cargador de arranque eliminado, y la polaridad de interrupci√≥n para regular funciones de este bot√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede ver c√≥mo se realiza la medici√≥n actual en un par de amplificadores operacionales con diferentes factores de ganancia (por ejemplo, para mejorar el depurador descrito anteriormente para sus tareas), </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (p. 9), una alternativa m√°s tradicional, con un amplificador operacional y un costoso ADC de 24 bits - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TI lo tiene</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (EnergyTrace en la p√°gina 5).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PD Tenga en cuenta que durante la depuraci√≥n con un UART o JTAG / SWD conectado, una peque√±a corriente puede filtrarse a trav√©s de sus patas, lo que no suceder√° durante el funcionamiento real del dispositivo. </font><font style="vertical-align: inherit;">Entonces, en UMDK-RF, se filtran aproximadamente 15 ŒºA en el SWD (y, por lo tanto, en la foto del encabezado, las mediciones con un mult√≠metro se realizan en la versi√≥n anterior de la placa, sin SWD), y en el STM32 Nucleo hubo casos con flujo espurio a trav√©s del SWD de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aproximadamente 200 ŒºA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Las placas de depuraci√≥n utilizadas para la medici√≥n deben verificarse para tales caracter√≠sticas, ya sea desconectando sus l√≠neas de interfaz, si existe esa posibilidad, o comparando los resultados con el consumo medido del dispositivo sin instalarlo para la depuraci√≥n, por ejemplo, con un mult√≠metro en modo est√°tico.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En lugar de una conclusi√≥n </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Espero que ya haya entendido qu√© error cometi√≥ al elegir la programaci√≥n de microcontroladores como su especialidad principal. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es430218/">https://habr.com/ru/post/es430218/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es430206/index.html">Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 18: Navegaci√≥n privada en Internet, Parte 2</a></li>
<li><a href="../es430208/index.html">Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 18: "Navegaci√≥n privada en Internet", parte 3</a></li>
<li><a href="../es430210/index.html">Pon a prueba mi paciencia por Check Point Security Academy</a></li>
<li><a href="../es430212/index.html">OpenSceneGraph: conceptos b√°sicos de la geometr√≠a de la escena</a></li>
<li><a href="../es430216/index.html">Seg√∫n tengo entendido, como muchos dulces, o la clasificaci√≥n de los productos por cheque en la solicitud</a></li>
<li><a href="../es430220/index.html">C√≥mo convertir un hub usb "centenario" en un dispositivo inteligente administrado y ahorrar $ 300</a></li>
<li><a href="../es430222/index.html">Ingeniero Senior en busca de trabajo. C√≥mo pas√© por 20 entrevistas con RRHH y lo que pienso al respecto</a></li>
<li><a href="../es430224/index.html">Trastorno esquizot√≠pico: una mirada al interior</a></li>
<li><a href="../es430226/index.html">De var b a entrevista</a></li>
<li><a href="../es430228/index.html">Marcas en forma de X como m√©todo de identificaci√≥n por radar utilizando an√°lisis de datos abiertos de dos sat√©lites cient√≠ficos SENTINEL-1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>