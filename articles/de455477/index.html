<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§´ ü§≥üèª üåµ Singleton platziert Objekte im ROM und statische Variablen (C ++ am Beispiel des Cortex M4-Mikrocontrollers) ‚ô¶Ô∏è üëßüèª üèÜ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In einem fr√ºheren Artikel, Wo sind Ihre Konstanten auf einem CortexM-Mikrocontroller gespeichert (am Beispiel des C ++ IAR-Compilers) , wurde die Frag...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Singleton platziert Objekte im ROM und statische Variablen (C ++ am Beispiel des Cortex M4-Mikrocontrollers)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455477/"><img src="https://habrastorage.org/webt/4e/6g/sw/4e6gswsjjz0liihmy5ptbivomuu.jpeg" alt="Bild"><br><br>  In einem fr√ºheren Artikel, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wo sind Ihre Konstanten auf einem CortexM-Mikrocontroller gespeichert (am Beispiel des C ++ IAR-Compilers)</a> , wurde die Frage diskutiert, wie konstante Objekte im ROM platziert werden.  Jetzt m√∂chte ich Ihnen sagen, wie Sie das Einzelgeneratormuster verwenden k√∂nnen, um Objekte im ROM zu erstellen. <br><a name="habracut"></a><br><br><h3>  Einf√ºhrung </h3><br>  Es wurde bereits viel √ºber Singleton (im Folgenden als Singleton bezeichnet), seine positiven und negativen Seiten, geschrieben.  Trotz seiner M√§ngel weist es viele n√ºtzliche Eigenschaften auf, insbesondere im Zusammenhang mit der Firmware f√ºr Mikrocontroller. <br><br>  F√ºr eine zuverl√§ssige Mikrocontroller-Software wird zun√§chst nicht empfohlen, Objekte dynamisch zu erstellen, sodass sie nicht gel√∂scht werden m√ºssen.  Oft werden Objekte einmal erstellt und leben vom Start des Ger√§ts bis zum Ausschalten.  Ein solches Objekt kann sogar ein Port-Leg sein, an das eine LED angeschlossen ist, es wird einmal erstellt und es wird sicherlich nirgendwo hingehen, w√§hrend die Anwendung ausgef√ºhrt wird, und es kann offensichtlich Singleton sein.  Jemand sollte solche Objekte erstellen und es k√∂nnte Singleton sein. <br><br>  Singleton gibt Ihnen auch die Garantie, dass dasselbe Objekt, das den Portabschnitt beschreibt, nicht zweimal erstellt wird, wenn es pl√∂tzlich an mehreren Stellen verwendet wird. <br><br>  Eine weitere meiner Meinung nach bemerkenswerte Eigenschaft von Singleton ist die einfache Bedienung.  Zum Beispiel, wie im Fall des Interrupt-Handlers, ein Beispiel, mit dem am Ende des Artikels steht.  Aber im Moment werden wir uns selbst um Singleton k√ºmmern. <br><br><h3>  Singleton erstellt Objekte im RAM </h3><br>  Im Allgemeinen wurden bereits ziemlich viele Artikel dar√ºber geschrieben, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Singleton (Loner) oder eine statische Klasse?</a>  oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Drei Zeitalter des Singleton-Musters</a> .  Daher werde ich mich nicht auf Singleton konzentrieren und all die vielen Optionen f√ºr seine Implementierung beschreiben.  Stattdessen werde ich mich auf zwei Optionen konzentrieren, die in der Firmware verwendet werden k√∂nnen. <br>  Zun√§chst werde ich klarstellen, was der Unterschied zwischen der Firmware f√ºr den Mikrocontroller und der √ºblichen ist und warum einige Singleton-Implementierungen f√ºr diese Software ‚Äûbesser‚Äú sind als andere.  Einige Kriterien ergeben sich aus den Anforderungen an die Firmware, andere nur aus meiner Erfahrung: <br><br><ul><li>  In der Firmware wird nicht empfohlen, Objekte dynamisch zu erstellen </li><li>  In der Firmware wird ein Objekt h√§ufig statisch erstellt und niemals zerst√∂rt. </li><li>  Nun, wenn der Ort des Objekts in der Kompilierungsphase bekannt ist </li></ul><br>  Basierend auf diesen Annahmen betrachten wir zwei Varianten von Singleton mit statisch erstellten Objekten, und die wahrscheinlich bekannteste und h√§ufigste ist Meyers Singleton. Obwohl es nach dem C ++ - Standard threadsicher sein sollte, machen es Compiler f√ºr Firmware so (z. B. IAR). Nur wenn die Sonderoption aktiviert ist: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> T &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T instance ; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance ; } Singleton() = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; Singleton(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; } ;</code> </pre> <br>  Es verwendet eine verz√∂gerte Initialisierung, d.h.  Die Initialisierung eines Objekts erfolgt nur beim ersten <code>GetInstance()</code> . Betrachten Sie dies als dynamische Initialisierung. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   Timer1      auto&amp; objRef = Singleton&lt;Timer1&gt;::GetInstance(); //  ,      auto&amp; objRef1 = Singleton&lt;Timer1&gt;::GetInstance(); return 0; }</span></span></code> </pre> <br>  Und Singleton ohne verz√∂gerte Initialisierung: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> T &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance ; } Singleton() = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; Singleton(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T instance ; <span class="hljs-comment"><span class="hljs-comment">//      } ;</span></span></code> </pre> <br>  Beide Singleton erstellen Objekte im RAM. Der Unterschied besteht darin, dass die Initialisierung f√ºr die zweite unmittelbar nach dem Start des Programms erfolgt und die erste beim ersten Aufruf initialisiert wird. <br><br>  Wie k√∂nnen sie im wirklichen Leben eingesetzt werden?  Nach alter Tradition werde ich versuchen, dies am Beispiel einer LED zu zeigen.  Angenommen, wir m√ºssen ein Objekt der Klasse <code>Led1</code> , das eigentlich nur ein Alias ‚Äã‚Äãder Klasse <code>Pin&lt;PortA, 5&gt;</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PortA = Port&lt;GpioaBaseAddr&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Led1 = Pin&lt;PortA, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GreenLed = Pin&lt;PortA, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ; Led1 myLed ; <span class="hljs-comment"><span class="hljs-comment">//        RAM constexpr GreenLed greenLed ; //        ROM int main() { static GreenLed myGreenLed ; //     RAM Led1 led1; //     myGreenLed.Toggle(); led1.Toggle() ; }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Nur f√ºr den Fall, dass die Klassen Port und Pin ungef√§hr so ‚Äã‚Äãaussehen</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> OdrAddrShift = <span class="hljs-number"><span class="hljs-number">20U</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Port</span></span></span><span class="hljs-class"> {</span></span> __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toggle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bit)</span></span></span><span class="hljs-function"> </span></span>{ *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>*&gt;(addr ) ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; bit) ; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pinNum&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pin</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// Singleton   ,     friend class Singleton&lt;Pin&gt; ; public: __forceinline inline void Toggle() const { T::Toggle(pinNum) ; } //  = const Pin &amp; operator=(const Pin &amp;) = delete ; private: // ,      constexpr Pin() {} ; //  ,      //   ,      constexpr Pin(const Pin &amp;) = default ; } ;</span></span></code> </pre> <br></div></div><br>  Im Beispiel habe ich bis zu 4 verschiedene Objekte desselben Typs in RAM und ROM erstellt, die tats√§chlich mit derselben Ausgabe von Port A arbeiten. Was hier nicht sehr gut ist: <br>  Nun, das erste ist, dass ich anscheinend vergessen habe, dass <code>GreenLed</code> und <code>Led1</code> vom gleichen Typ sind, und mehrere identische Objekte erstellt habe, die an verschiedenen Adressen Platz <code>Led1</code> .  Tats√§chlich habe ich sogar vergessen, dass ich bereits globale Objekte der <code>GreenLed</code> <code>Led1</code> und <code>GreenLed</code> erstellt und auch lokal erstellt habe. <br><br>  Zweitens ist es im Allgemeinen nicht erw√ºnscht, globale Objekte zu deklarieren. <br><br><div class="spoiler">  <b class="spoiler_title">Programmierrichtlinien f√ºr eine bessere Compileroptimierung</b> <div class="spoiler_text">  <i>Modullokale Variablen - Variablen, die als statisch deklariert sind - werden bevorzugt</i> <i><br></i>  <i>globale Variablen (nicht statisch).</i>  <i>Vermeiden Sie es auch, die Adresse h√§ufig aufgerufener statischer Variablen zu verwenden.</i> <i><br></i> </div></div><br>  und lokale Objekte sind nur im Rahmen der Funktion main () verf√ºgbar. <br><br>  Daher schreiben wir dieses Beispiel mit Singleton neu: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PortA = Port&lt;GpioaBaseAddr&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Led1 = Pin&lt;PortA, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GreenLed = Pin&lt;PortA, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//        GreenLed //   GreenLed&amp; myGreenLed = Singleton&lt;GreenLed&gt;::GetInstance(); //            Led1&amp; led1 = Singleton&lt;Led1&gt;::GetInstance(); myGreenLed.Toggle() ; led1.Toggle() ; //  , Singleton&lt;Led1&gt;::GetInstance().Toggle() }</span></span></code> </pre> <br>  In diesem Fall verweisen meine Links, egal was ich vergesse, immer auf dasselbe Objekt.  Und ich kann diesen Link √ºberall im Programm erhalten, in jeder Methode, einschlie√ülich zum Beispiel in der statischen Methode des Interrupt-Handlers, aber dazu sp√§ter mehr.  Fairerweise muss ich sagen, dass der Code nichts tut und der Fehler in der Programmlogik nicht verschwunden ist.  Okay, lassen Sie uns herausfinden, wo und wie sich dieses von Singleton erstellte statische Objekt im Allgemeinen befand und wie es initialisiert wurde. <br><br><h3>  Statisches Objekt </h3><br>  Bevor Sie es herausfinden, w√§re es sch√∂n zu verstehen, was ein statisches Objekt ist. <br><br>  Wenn Sie Klassenmitglieder mit dem Schl√ºsselwort static deklarieren, bedeutet dies, dass Klassenmitglieder einfach nicht an Klasseninstanzen gebunden sind, sondern unabh√§ngige Variablen sind und Sie auf solche Felder zugreifen k√∂nnen, ohne ein Klassenobjekt zu erstellen.  Nichts bedroht ihr Leben vom Moment ihrer Geburt bis zur Ver√∂ffentlichung des Programms. <br><br>  Bei Verwendung in einer Objektdeklaration bestimmt der statische Bezeichner nur die Lebensdauer des Objekts.  Grob gesagt wird der Speicher f√ºr ein solches Objekt beim Start des Programms zugewiesen und beim Beenden des Programms freigegeben. Beim Start werden sie ebenfalls initialisiert.  Ausnahmen sind nur lokale statische Objekte, die, obwohl sie erst am Ende des Programms "sterben", im Wesentlichen "geboren" sind oder vielmehr beim ersten Durchlaufen ihrer Deklaration initialisiert werden. <br><br><blockquote>  Die dynamische Initialisierung einer lokalen Variablen mit statischem Speicher wird zum ersten Mal zum Zeitpunkt des ersten Durchlaufs ihrer Deklaration durchgef√ºhrt.  Eine solche Variable gilt nach Abschluss ihrer Initialisierung als initialisiert.  Wenn ein Thread zum Zeitpunkt seiner Initialisierung durch einen anderen Thread eine Variablendeklaration durchl√§uft, muss er warten, bis die Initialisierung abgeschlossen ist. </blockquote><br>  In den folgenden Aufrufen erfolgt keine Initialisierung.  All dies kann auf eine Phrase reduziert werden, es kann <u>nur eine Instanz eines statischen Objekts existieren.</u> <br><br>  Solche Schwierigkeiten f√ºhren dazu, dass die Verwendung lokaler statischer Variablen und Objekte in der Firmware zu zus√§tzlichem Overhead f√ºhrt.  Sie k√∂nnen dies anhand eines einfachen Beispiels √ºberpr√ºfen: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test1</span></span></span><span class="hljs-class">{</span></span> Test1(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value): j(value) {} <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; } ; <span class="hljs-function"><span class="hljs-function">Test1 &amp;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Test1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> test; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; ++i) { foo().j ++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Hier muss der Compiler beim ersten Aufruf der Funktion <code>foo()</code> √ºberpr√ºfen, ob das lokale statische Objekt <code>test1</code> noch nicht initialisiert wurde, und den Konstruktor des Objekts <code>Test1(10)</code> In der zweiten und den folgenden Durchg√§ngen muss er sicherstellen, dass das Objekt bereits initialisiert ist, und diesen Schritt √ºberspringen. direkt zum <code>return test</code> . <br><br>  Zu diesem <code>foo()::static guard for test 0x00100004 0x1 Data Lc main.o</code> f√ºgt der Compiler einfach ein zus√§tzliches Schutzflag <code>foo()::static guard for test 0x00100004 0x1 Data Lc main.o</code> und f√ºgt den Best√§tigungscode ein.  Bei der ersten Deklaration einer statischen Variablen wird dieses Schutzflag nicht gesetzt, und daher muss das Objekt durch Aufrufen des Konstruktors initialisiert werden. W√§hrend des n√§chsten Durchlaufs ist dieses Flag bereits gesetzt, sodass keine Initialisierung mehr erforderlich ist und der Konstruktoraufruf √ºbersprungen wird.  Dar√ºber hinaus wird diese Pr√ºfung kontinuierlich in der for-Schleife durchgef√ºhrt. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/gb/aq/r1/gbaqr1fpbmihpghun28epsnvoou.png"></a> <br><br>  Wenn Sie die Option aktivieren, die Ihnen die Initialisierung in Multithread-Anwendungen garantiert, wird noch mehr Code angezeigt ... (Der Aufruf zum Erfassen und Freigeben der Ressource w√§hrend der Initialisierung ist orange unterstrichen.) <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/rq/5y/ko/rq5ykodk6pngj1esrz8bgx5-79u.png" alt="Bild"></a> <br><br>  Somit steigt der Preis f√ºr die Verwendung einer statischen Variablen oder eines statischen Objekts in der Firmware sowohl in der RAM-Gr√∂√üe als auch in der Codegr√∂√üe.  Und diese Tatsache w√§re sch√∂n zu ber√ºcksichtigen und bei der Entwicklung zu ber√ºcksichtigen. <br><br>  Ein weiterer Nachteil ist die Tatsache, dass das Schutzflag zusammen mit der statischen Variablen erstellt wird, seine Lebensdauer der Lebensdauer des statischen Objekts entspricht, vom Compiler selbst erstellt wird und Sie w√§hrend der Entwicklung keinen Zugriff darauf haben.  Das hei√üt,  wenn pl√∂tzlich aus irgendeinem Grund <br><br><div class="spoiler">  <b class="spoiler_title">siehe zuf√§lliger Absturz</b> <div class="spoiler_text">  Die Ursachen f√ºr zuf√§llige Fehler sind: (1) Alpha-Teilchen, die aus dem Zerfallsprozess resultieren, (2) Neutronen, (3) eine externe Quelle elektromagnetischer Strahlung und (4) internes √úbersprechen. <br></div></div><br>  Wenn das Flag von 1 auf 0 geht, wird die Initialisierung mit dem Anfangswert erneut aufgerufen.  Das ist nicht gut und man muss auch bedenken.  So fassen Sie die statischen Variablen zusammen: <br><blockquote>  F√ºr jedes statische Objekt (sei es eine lokale Variable oder ein Klassenattribut) wird der Speicher einmal zugewiesen und √§ndert sich nicht in der gesamten Anwendung. <br><br>  Lokale statische Variablen werden beim ersten Durchlauf durch eine Variablendeklaration initialisiert. <br><br>  Statische Klassenattribute sowie statische globale Variablen werden unmittelbar nach dem Start der Anwendung initialisiert.  Dar√ºber hinaus ist diese Reihenfolge nicht definiert </blockquote>  Nun zur√ºck zu Singleton. <br><br><h3>  Singleton platziert Objekt im ROM </h3><br>  Aus all dem k√∂nnen wir schlie√üen, dass Singleton Mayers f√ºr uns die folgenden Nachteile haben kann: zus√§tzliche RAM- und ROM-Kosten, ein unkontrolliertes Sicherheitsflag und die Unf√§higkeit, ein Objekt aufgrund dynamischer Initialisierung im ROM zu platzieren. <br><br>  Aber er hat ein wunderbares Plus: Sie steuern die Initialisierungszeit des Objekts.  Nur der Entwickler selbst ruft <code>GetInstance()</code> ersten Mal auf, wenn er es ben√∂tigt. <br><br>  Um die ersten drei M√§ngel zu beseitigen, reicht es aus, sie zu verwenden <br><br><div class="spoiler">  <b class="spoiler_title">Singleton ohne verz√∂gerte Initialisierung</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enable</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Singleton(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; Singleton&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; Singleton() = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T instance ; } ; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enable</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class">&lt;T,Enable&gt;:</span></span>:instance ;</code> </pre><br></div></div><br>  Hier gibt es nat√ºrlich ein anderes Problem: Wir k√∂nnen die Initialisierungszeit des Instanzobjekts nicht steuern und m√ºssen irgendwie eine sehr transparente Initialisierung bereitstellen.  Dies ist jedoch ein separates Problem, auf das wir jetzt nicht n√§her eingehen werden. <br><br>  Dieser Singleton kann so umgestaltet werden, dass die Initialisierung des Objekts zur Kompilierungszeit vollst√§ndig statisch ist und eine Instanz von <code>T</code> im ROM unter Verwendung einer <code>static constexpr T instance</code> anstelle einer <code>static T instance</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> T &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance ; } Singleton() = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; Singleton(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">// constexpr  constexpr   //           T static constexpr T instance{T()}; } ; template&lt;typename T&gt; constexpr T Singleton&lt;T&gt;::instance ;</span></span></code> </pre><br>  Hier wird die Erstellung und Initialisierung des Objekts vom Compiler in der Kompilierungsphase durchgef√ºhrt und das Objekt f√§llt in das Segment .readonly.  Die Klasse selbst muss die folgenden Regeln erf√ºllen: <br><blockquote><ul><li>  Die Initialisierung eines Objekts dieser Klasse muss statisch sein.  (Der Konstruktor muss constexpr sein) </li><li>  Die Klasse muss √ºber einen constexpr-Kopierkonstruktor verf√ºgen </li><li>  Klassenmethoden eines Klassenobjekts sollten die Daten eines Klassenobjekts nicht √§ndern (alle const-Methoden) </li></ul></blockquote><br>  Zum Beispiel ist diese Option durchaus m√∂glich: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class">&lt;A&gt;;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> A &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> A &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> test2.Get(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ test.SetB(v); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: B&amp; test; <span class="hljs-comment"><span class="hljs-comment">//    RAM const C&amp; test2; //    ROM //      constexpr A(const A &amp;) = default ; //     RAM  ROM,  Singleton constexpr A() : test(Singleton&lt;B&gt;::GetInstance()), test2(Singleton&lt;C&gt;::GetInstance()) { } }; int main() { //      ROM auto&amp; myObject = Singleton&lt;A&gt;::GetInstance() ; //           myObject.Set(myObject.Get()) ; cout&lt;&lt;"Singleton&lt;A&gt; - address: "&lt;&lt; &amp;myObject &lt;&lt;std::endl; }</span></span></code> </pre><br>  Gro√üartig, Sie k√∂nnen Singleton verwenden, um Objekte im ROM zu erstellen, aber was ist, wenn sich einige Objekte im RAM befinden sollten?  Nat√ºrlich m√ºssen Sie zwei Spezialisierungen f√ºr Singleton beibehalten, eine f√ºr RAM-Objekte und eine f√ºr Objekte im ROM.  Sie k√∂nnen dies tun, indem Sie beispielsweise f√ºr alle Objekte eingeben, die in die ROM-Basisklasse eingef√ºgt werden sollen: <br><br><div class="spoiler">  <b class="spoiler_title">Spezialisierung f√ºr Singleton beim Erstellen von Objekten in ROM und RAM</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,     ROM class RomObject{}; //  ROM  template&lt;typename T&gt; class Singleton&lt;T, typename std::enable_if_t&lt;std::is_base_of&lt;RomObject, T&gt;::value&gt;&gt; { public: Singleton(const Singleton&amp;) = delete; Singleton&amp; operator = (const Singleton&amp;) = delete; Singleton() = delete; static constexpr const T&amp; GetInstance() { return instance; } private: static constexpr T instance{T()}; }; template&lt;typename T&gt; constexpr T Singleton&lt;T, typename std::enable_if_t&lt;std::is_base_of&lt;RomObject, T&gt;::value&gt;&gt;::instance ; //  RAM  template&lt;typename T, class Enable = void&gt; class Singleton { public: Singleton(const Singleton&amp;) = delete; Singleton&amp; operator = (const Singleton&amp;) = delete; Singleton() = delete; constexpr static T&amp; GetInstance() { return instance; } private: static T instance ; }; template&lt;typename T, class Enable&gt; T Singleton&lt;T,Enable&gt;::instance ;</span></span></code> </pre><br></div></div><br>  In diesem Fall k√∂nnen Sie sie folgenderma√üen verwenden: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      RAM,   SetB()    (j) class B { friend class Singleton&lt;B&gt;; public: const B &amp; operator=(const B &amp;) = delete ; void SetB(int value) { j = value ; } private: // ,        B(const B &amp;) = default ; B() = default; int j = 0; } //      ROM class A: public RomObject{ friend class Singleton&lt;A&gt;; public: const A &amp; operator=(const A &amp;) = delete ; int Get() const { return test2.Get(); } //     B,    void Set(int v) const { test.SetB(v); } private: B&amp; test; //    RAM const C&amp; test2; //    ROM //        A(const A &amp;) = default ; //     RAM  ROM,  Singleton constexpr A() : test(Singleton&lt;B&gt;::GetInstance()), test2(Singleton&lt;C&gt;::GetInstance()) { } }; int main() { //      ROM auto&amp; romObject = Singleton&lt;A&gt;::GetInstance() ; //    B  RAM auto&amp; ramObject = Singleton&lt;B&gt;::GetInstance() ; //           ramObject.SetB(romObject.Get()) ; cout&lt;&lt;"Singleton&lt;A&gt; - address: "&lt;&lt; &amp;romObject &lt;&lt;std::endl; cout&lt;&lt;"Singleton&lt;B&gt; - address: "&lt;&lt; &amp;ramObject &lt;&lt;std::endl; }</span></span></code> </pre> <br>  Wie k√∂nnen Sie einen solchen Singleton im wirklichen Leben verwenden? <br><br><h3>  Singleton Beispiel </h3><br>  Ich werde versuchen, dies am Beispiel der Funktionsweise des Timers und der LED zu zeigen.  Die Aufgabe ist einfach, blinken Sie die LED am Timer.  Der Timer kann eingestellt werden. <br><br>  Das Funktionsprinzip lautet wie folgt: Wenn der Interrupt aufgerufen wird, wird die <code>OnInterrupt()</code> -Methode des Timers aufgerufen, die wiederum die LED-Schaltmethode √ºber die Teilnehmerschnittstelle aufruft. <br><br>  Offensichtlich muss sich das LED-Objekt im ROM befinden, da es keinen Sinn macht, es im RAM zu erstellen, es sind nicht einmal Daten darin.  Im Prinzip habe ich es bereits oben beschrieben. <code>RomObject</code> also einfach die Vererbung von <code>RomObject</code> einen constexpr-Konstruktor und erben Sie auch die Schnittstelle zum Verarbeiten von Ereignissen vom Timer. <br><br><div class="spoiler">  <b class="spoiler_title">LED-Objekt</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      class ITimerSubscriber { public: virtual void OnTimeOut() const = 0; } ; template &lt;typename T, std::uint8_t pinNum&gt; class Pin: public RomOject, public ITimerSubscriber { // Singleton   ,     friend class Singleton&lt;Pin&gt; ; public: __forceinline inline void Toggle() const { T::Toggle(pinNum) ; } //       __forceinline inline void OnTimeOut() const override { Toggle() ; } //  = const Pin &amp; operator=(const Pin &amp;) = delete ; private: // ,      constexpr Pin() = default ; Pin(const Pin &amp;) = default ; } ;</span></span></code> </pre> </div></div><br>  Aber ich werde den Timer mit einem kleinen Frachtbrief speziell im RAM <code>TIM_TypeDef</code> , einen Link zur <code>TIM_TypeDef</code> Struktur, einen Punkt und einen Abonnentenlink speichern und den Timer im Konstruktor konfigurieren (obwohl es m√∂glich w√§re, den Timer auch in den ROM zu verschieben): <br><br><div class="spoiler">  <b class="spoiler_title">Klassen-Timer</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Timer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Timer &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Timer &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetPeriod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ period = value ; timer.PSC = TimerClockSpeed / <span class="hljs-number"><span class="hljs-number">1000U</span></span> - <span class="hljs-number"><span class="hljs-number">1U</span></span> ; timer.ARR = value ; } <span class="hljs-comment"><span class="hljs-comment">//      __forceinline inline void OnInterrupt() { if ((timer.SR &amp; TIM_SR_UIF) &amp;&amp; (timer.DIER &amp; TIM_DIER_UIE)) { //   ,     OnTimeOut //       Toggle() subscriber-&gt;OnTimeOut() ; timer.SR &amp;=~ TIM_SR_UIF ; } } //    TimeOut  ,   ITimerSubscriber,   __forceinline inline void Subscribe(const ITimerSubscriber&amp; obj) { subscriber = &amp;obj ; } inline void Start() { timer.CR1 |= TIM_CR1_URS ; timer.DIER |= TIM_DIER_UIE ; SetPeriod(period) ; timer.CR1 &amp;=~TIM_CR1_OPM ; timer.EGR |= TIM_EGR_UG ; timer.CR1 |= TIM_CR1_CEN ; } protected: // ,         explicit Timer(TIM_TypeDef&amp; tim): timer{tim} {}; const ITimerSubscriber * subscriber = nullptr ; TIM_TypeDef&amp; timer ; std::uint16_t period = 1000; } ;</span></span></code> </pre> <br></div></div><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//       class BlinkTimer: public Timer { friend class Singleton&lt;BlinkTimer&gt; ; public: const BlinkTimer &amp; operator=(const BlinkTimer &amp;) = delete ; private: BlinkTimer(const BlinkTimer &amp;) = default ; inline BlinkTimer(): Timer{*TIM2} { } } ; int main() { BlinkTimer &amp; blinker = Singleton&lt;BlinkTimer&gt;::GetInstance() ; using Led1 = Pin&lt;PortA, 5&gt; ; // Led1,   ROM,      blinker.Subscribe(Singleton&lt;Led1&gt;::GetInstance()) ; blinker.Start() ; }</span></span></code> </pre><br>  In diesem Beispiel befand sich ein Objekt der Klasse <code>BlinkTimer</code> im RAM und ein Objekt der Klasse <code>Led1</code> im ROM.  Keine zus√§tzlichen globalen Objekte im Code.  An der Stelle, an der die Klasseninstanz ben√∂tigt wird, rufen wir einfach <code>GetInstance()</code> f√ºr diese Klasse auf <br><br>  Es bleibt noch ein Interrupt-Handler zur Interrupt-Vektortabelle hinzuzuf√ºgen.  Und hier ist es sehr bequem, Singleton zu verwenden.  In der statischen Methode der Klasse, die f√ºr die Behandlung von Interrupts verantwortlich ist, k√∂nnen Sie die Methode des in Singleton eingeschlossenen Objekts aufrufen. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __iar_program_start(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) ; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InterruptHandler</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DummyHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) {} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Timer2Handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   BlinkTimer Singleton&lt;BlinkTimer&gt;::GetInstance().OnInterrupt(); } }; using tIntFunct = void(*)(); using tIntVectItem = union {tIntFunct __fun; void * __ptr;}; #pragma segment = "CSTACK" #pragma location = ".intvec" const tIntVectItem __vector_table[] = { { .__ptr = __sfe( "CSTACK" ) }, //    __iar_program_start, //      InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, 0, 0, 0, 0, InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, 0, InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, //External Interrupts InterruptHandler::DummyHandler, //Window Watchdog InterruptHandler::DummyHandler, //PVD through EXTI Line detect/EXTI16 .... InterruptHandler::Timer2Handler, //      BlinkTimer InterruptHandler::DummyHandler, //TIM3 ... InterruptHandler::DummyHandler, //SPI 5 global interrupt }; extern "C" void __cmain(void) ; extern "C" __weak void __iar_init_core(void) ; extern "C" __weak void __iar_init_vfp(void) ; #pragma required = __vector_table void __iar_program_start(void) { __iar_init_core() ; __iar_init_vfp() ; __cmain() ; }</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Ein wenig √ºber den Tisch selbst, wie alles funktioniert:</b> <div class="spoiler_text">  Unmittelbar nach dem Einschalten oder nach einem Zur√ºcksetzen wird ein Zur√ºcksetzen mit der <i>Zahl -8</i> unterbrochen. In der Tabelle handelt es sich um ein Nullelement. Gem√§√ü dem R√ºcksetzsignal wechselt das Programm zum Nullelementvektor, wobei der Zeiger auf die Oberseite des Stapels zuerst initialisiert wird.  Diese Adresse wird vom Speicherort des STACK-Segments √ºbernommen, das Sie in den Linker-Einstellungen konfiguriert haben.  Gehen Sie unmittelbar nach der Initialisierung des Zeigers zum Programmeintrittspunkt, in diesem Fall unter der Adresse der Funktion <code>__iar_program_start</code> .  Als N√§chstes wird der Code initialisiert, um Ihre globalen und statischen Variablen zu initialisieren, den Coprozessor mit einem Gleitkomma zu initialisieren, sofern er in den Einstellungen enthalten war, und so weiter.  Wenn ein Interrupt auftritt, geht der Interrupt-Controller anhand der Interrupt-Nummer in der Tabelle an die Adresse des Interrupt-Handlers.  In unserem Fall ist dies <code>InterruptHandler::Timer2Handler</code> , der √ºber Singleton die <code>OnInterrupt()</code> -Methode unseres Blink-Timers <code>OnTimeOut()</code> , die wiederum die <code>OnTimeOut()</code> -Methode des <code>OnTimeOut()</code> . <br></div></div><br>  Eigentlich ist das alles, Sie k√∂nnen das Programm ausf√ºhren.  Ein Arbeitsbeispiel f√ºr IAR 8.40 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">liegt hier</a> . <br>  Ein detaillierteres Beispiel f√ºr die Verwendung von Singleton f√ºr Objekte in ROM und RAM finden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie hier</a> . <br><br>  Dokumentationslinks: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GOST R mek61508-7‚Äî2012</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C / C ++ - Entwicklungshandbuch f√ºr EWARM</a> </li></ul><br>  PS Auf dem Bild am Anfang des Artikels ist Singleton trotzdem kein ROM, sondern WHISKY. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455477/">https://habr.com/ru/post/de455477/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455467/index.html">Wenn Sie kein Programm schreiben, verwenden Sie keine Programmiersprache</a></li>
<li><a href="../de455469/index.html">Ein voller Stapel sein und nicht sein</a></li>
<li><a href="../de455471/index.html">√úbersetzung der Verwendung von Google Analytics mit R (Michal Brys)</a></li>
<li><a href="../de455473/index.html">Generika in TypeScript: Zusammenkommen</a></li>
<li><a href="../de455475/index.html">Food Design Digest, Mai 2019</a></li>
<li><a href="../de455479/index.html">Wie wir die Navigation von Jetpack in eine Kampfanwendung implementiert haben. Yandex.Food Report</a></li>
<li><a href="../de455481/index.html">Drei Geschichten √ºber wilde Jagd</a></li>
<li><a href="../de455483/index.html">Ai-Da-K√ºnstler: Humanoider Roboter bereitet sich auf seine erste Einzelausstellung vor</a></li>
<li><a href="../de455485/index.html">Pr√ºfpunktskripte - F√ºhren Sie Skripte direkt von der Smart Console aus</a></li>
<li><a href="../de455487/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 10. Betriebsarten des Ports wechseln</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>