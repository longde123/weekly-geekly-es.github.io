<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ù§Ô∏è ü•´ üíáüèæ Dritter Qt 5 Test mit PVS-Studio üëõ üå¶Ô∏è üëäüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Von Zeit zu Zeit √ºberpr√ºft unser Team erneut Projekte, √ºber die wir bereits Artikel geschrieben haben. Ein weiteres solches erneut gepr√ºftes Projekt w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dritter Qt 5 Test mit PVS-Studio</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/426485/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd9/87d/907/dd987d90784865f850555bc198a97b81.png" alt="PVS-Studio &amp; Qt"></div><br>  Von Zeit zu Zeit √ºberpr√ºft unser Team erneut Projekte, √ºber die wir bereits Artikel geschrieben haben.  Ein weiteres solches erneut gepr√ºftes Projekt war Qt.  Das letzte Mal haben wir es 2014 mit PVS-Studio getestet.  Seit 2014 wird das Projekt regelm√§√üig mit Hilfe von Coverity √ºberpr√ºft.  Das ist interessant.  Mal sehen, ob wir jetzt mit PVS-Studio interessante Fehler finden k√∂nnen. <br><a name="habracut"></a><br><h2>  Qt </h2><br>  Vorherige Artikel: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie man die Wahrscheinlichkeit von Fehlern beim Schreiben von Code verringert</a> ", Juli 2011. </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Qt 5 Framework Check</a> ", April 2014. </li></ul><br>  Diesmal wurden <a href="">Qt Base</a> (Core, Gui, Widgets, Network, ...) und <a href="">Qt5 Super Module getestet</a> .  √úber Qt Creator planen wir, sp√§ter einen separaten Artikel zu schreiben.  Zur √úberpr√ºfung haben wir den statischen Analysator PVS-Studio verwendet, dessen Testversion Sie von der Website <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">herunterladen</a> k√∂nnen. <br><br>  Meiner subjektiven Meinung nach ist der Qt-Code besser geworden.  Im Laufe der Jahre seit dem letzten Test sind im PVS-Studio-Analyseger√§t viele neue Diagnosen erschienen.  Trotzdem habe ich bei der √úberpr√ºfung der Warnungen nicht so viele Fehler f√ºr ein Projekt dieser Gr√∂√üe gefunden.  Ich wiederhole noch einmal, dass dies mein individueller Eindruck ist.  Ich habe damals oder heute keine speziellen Untersuchungen zur Fehlerdichte durchgef√ºhrt. <br><br>  H√∂chstwahrscheinlich wirkten sich regelm√§√üige √úberpr√ºfungen mit dem statischen Analyseger√§t Coverity h√∂chstwahrscheinlich auf die Qualit√§t des Codes aus.  2014 wurde mit Hilfe von Coverity das Qt-Projekt ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">qt-project</a> ) und 2016 der Qt Creator ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">qt-creator</a> ) √ºberpr√ºft.  Meine Meinung: Wenn Sie ein Open Source-Projekt entwickeln, kann <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Coverity Scan</a> eine gute kostenlose L√∂sung sein, die die Qualit√§t und Zuverl√§ssigkeit Ihrer Projekte erheblich verbessert. <br><br>  Wie der Leser jedoch erraten kann, h√§tte es keinen Artikel gegeben, wenn ich im PVS-Studio-Bericht nichts Interessantes bemerkt h√§tte :).  Und da es einen Artikel gibt, also M√§ngel.  Schauen wir sie uns an.  Insgesamt habe ich 96 Fehler ausgeschrieben. <br><br><h2>  Erfolgloses Kopieren, Einf√ºgen und Tippfehler </h2><br>  Beginnen wir mit den Klassikern des Genres, wenn die Ursache des Fehlers Unaufmerksamkeit ist.  Diese Fehler werden von Programmierern untersch√§tzt.  F√ºr diejenigen, die noch nicht gelesen haben, empfehle ich, dass Sie sich diese beiden Artikel ansehen: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Effekt der letzten Zeile</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das B√∂se lebt in Vergleichsfunktionen</a> </li></ul><br>  Diese Fehler sind interlanguage.  Zum Beispiel enth√§lt der zweite Artikel viele Beispiele f√ºr Fehler in Vergleichsfunktionen, die in C, C ++ und C # geschrieben wurden.  Bei der Implementierung der Java-Sprachunterst√ºtzung in PVS-Studio treten dieselben Fehlermuster auf.  Hier ist zum Beispiel ein Fehler, den wir k√ºrzlich in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hibernate-</a> Bibliothek gefunden haben: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object other)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (other instanceof Id) { Id that = (Id) other; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> purchaseSequence.equals(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.purchaseSequence) &amp;&amp; that.purchaseNumber == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.purchaseNumber; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  Wenn Sie genau hinschauen, stellt sich heraus, dass das Feld <i>purchaseSequence</i> mit sich selbst verglichen wird.  Die richtige Option: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> that.purchaseSequence.equals(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.purchaseSequence) &amp;&amp; that.purchaseNumber == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.purchaseNumber;</code> </pre> <br>  Im Allgemeinen ist alles wie immer, und der PVS-Studio-Analysator muss die Augean-St√§lle in Java-Projekten "harken".  √úbrigens laden wir alle ein, am Testen der Beta-Version von PVS-Studio f√ºr Java teilzunehmen, die in naher Zukunft erscheinen wird.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schreiben Sie uns dazu</a> (w√§hlen Sie "Ich m√∂chte den Analysator f√ºr Java"). <br><br>  Nun zur√ºck zu den Fehlern im Qt-Projekt. <br><br>  <b>Defekt N1</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">windowDpiAwareness</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HWND hwnd)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QWindowsContext::user32dll.getWindowDpiAwarenessContext &amp;&amp; QWindowsContext::user32dll.getWindowDpiAwarenessContext ? QWindowsContext::user32dll.getAwarenessFromDpiAwarenessContext( QWindowsContext::user32dll.getWindowDpiAwarenessContext(hwnd)) : <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre> <br>  PVS-Studio Warnung: V501 CWE-571 Links und rechts vom Operator '&amp;&amp;' befinden sich identische Unterausdr√ºcke 'QWindowsContext :: user32dll.getWindowDpiAwarenessContext'.  qwindowscontext.cpp 150 <br><br>  Eine spezielle Erkl√§rung neben der Analysatormeldung ist hier nicht erforderlich.  Es scheint mir, dass der Ausdruck so h√§tte sein sollen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QWindowsContext::user32dll.getAwarenessFromDpiAwarenessContext &amp;&amp; QWindowsContext::user32dll.getWindowDpiAwarenessContext ? QWindowsContext::user32dll.getAwarenessFromDpiAwarenessContext( QWindowsContext::user32dll.getWindowDpiAwarenessContext(hwnd)) : <span class="hljs-number"><span class="hljs-number">-1</span></span>;</code> </pre> <br>  <b>Defekt N2, N3</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QReadWriteLockPrivate::release() { Q_ASSERT(!recursive); Q_ASSERT(!waitingReaders &amp;&amp; !waitingReaders &amp;&amp; !readerCount &amp;&amp; !writerCount); freelist-&gt;release(id); }</code> </pre> <br>  PVS-Studio Warnung: V501 CWE-571 Links und rechts vom Operator '&amp;&amp;' befinden sich identische Unterausdr√ºcke:! WaitingReaders &amp;&amp;! WaitingReaders qreadwritelock.cpp 632 <br><br>  Der Fehler befindet sich innerhalb der <i>Makrobedingung Q_ASSERT</i> und ist daher nicht signifikant.  Trotzdem ist dies ein Fehler.  Die Variable <i>waitReaders</i> ist doppelt gepr√ºft.  Und anscheinend haben sie vergessen, eine andere Variable zu √ºberpr√ºfen. <br><br>  Ein identischer Fehler wird in der Zeile 625 der Datei qreadwritelock.cpp gefunden.  Es lebe das Kopieren und Einf√ºgen!  :) :) <br><br>  <b>Defekt N4</b> <br><br><pre> <code class="cpp hljs">QString QGraphicsSceneBspTree::debug(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node-&gt;type == Node::Horizontal) { tmp += debug(firstChildIndex(index)); tmp += debug(firstChildIndex(index) + <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tmp += debug(firstChildIndex(index)); tmp += debug(firstChildIndex(index) + <span class="hljs-number"><span class="hljs-number">1</span></span>); } .... }</code> </pre> <br>  PVS-Studio Warnung: V523 CWE-691 Die Anweisung 'then' entspricht der Anweisung 'else'.  qgraphicsscene_bsp.cpp 179 <br><br>  H√∂chstwahrscheinlich wurde der Textblock kopiert, aber sie haben vergessen, ihn zu korrigieren. <br><br>  <b>Defekt N5</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> FillRule { OddEvenFill, WindingFill }; QDataStream &amp;<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;&gt;(QDataStream &amp;s, QPainterPath &amp;p) { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fillRule; s &gt;&gt; fillRule; Q_ASSERT(fillRule == Qt::OddEvenFill || Qt::WindingFill); .... }</code> </pre> <br>  PVS-Studio Warnung: V768 CWE-571 Die Aufz√§hlungskonstante 'WindingFill' wird als Variable eines Booleschen Typs verwendet.  qpainterpath.cpp 2479 <br><br>  Stimmen Sie zu, das ist ein wundersch√∂ner Blooper!  <i>Q_ASSERT</i> √ºberpr√ºft nichts, da die Bedingung immer wahr ist.  Die Bedingung ist wahr, da die benannte Konstante <i>Qt :: WindingFill</i> 1 ist. <br><br>  <b>Defekt N6</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QVariant::canConvert(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetTypeId) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentType == QMetaType::SChar || currentType == QMetaType::Char) currentType = QMetaType::UInt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (targetTypeId == QMetaType::SChar || currentType == QMetaType::Char) targetTypeId = QMetaType::UInt; .... }</code> </pre> <br>  Versuchen Sie vor dem Lesen der Warnung, selbst einen Tippfehler zu erkennen.  Durch Hinzuf√ºgen eines Bildes helfe ich Ihnen, die Analysatormeldung nicht sofort zu lesen :). <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/86f/f1d/7c5/86ff1d7c55cdc0fb71cbce45f2f84f05.png" alt="Zeit zum Nachdenken"></div><br><br>  PVS-Studio Warnung: V560 CWE-570 Ein Teil des bedingten Ausdrucks ist immer falsch: currentType == QMetaType :: Char.  qvariant.cpp 3529 <br><br>  Die Bedingung "currentType == QMetaType :: Char" wird im ersten <i>if</i> √ºberpr√ºft.  Wenn die Bedingung erf√ºllt ist, wird die Variable <i>currentType</i> auf <i>QMetaType :: UInt gesetzt</i> .  Daher kann die Variable <i>currentType</i> nicht mehr gleich <i>QMetaType :: Char sein</i> .  Daher meldet der Analysator, dass im zweiten <i>if der</i> Unterausdruck "currentType == QMetaType :: Char" immer falsch ist. <br><br>  In der Tat sollte das zweite <i>if</i> so sein: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (targetTypeId == QMetaType::SChar || targetTypeId == QMetaType::Char) targetTypeId = QMetaType::UInt;</code> </pre> <br><br>  <b>V560 Diagnosehinweis</b> <br><br>  Der Bericht fand viele V560-Warnungen.  Ich habe sie mir jedoch nicht mehr angesehen, sobald ich einen interessanten Fall f√ºr den Artikel gefunden habe, der oben als Defekt N6 angesehen wurde. <br><br>  Die √ºberwiegende Mehrheit der Nachrichten V560 kann nicht als falsch bezeichnet werden, sie werden jedoch nicht verwendet.  Mit anderen Worten, es ist nicht interessant, sie in einem Artikel zu beschreiben.  Um klar zu machen, was ich genau meine, betrachten Sie einen solchen Fall. <br><br><pre> <code class="cpp hljs">QString QTextHtmlExporter::findUrlForImage(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QTextDocument *doc, ....) { QString url; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!doc) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> url; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (QTextDocument *parent = qobject_cast&lt;QTextDocument *&gt;(doc-&gt;parent())) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> findUrlForImage(parent, cacheKey, isPixmap); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (doc &amp;&amp; doc-&gt;docHandle()) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }</span></span></code> </pre> <br>  Warnung PVS-Stuidio: V560 CWE-571 Ein Teil des bedingten Ausdrucks ist immer wahr: doc.  qtextdocument.cpp 2992 <br><br>  Der Analysator ist absolut korrekt, dass der <i>doc-</i> Zeiger nicht immer <i>nullptr ist,</i> wenn er erneut √ºberpr√ºft wird.  Dies ist jedoch kein Fehler, nur der Programmierer war in Sicherheit.  Sie k√∂nnen den Code vereinfachen, indem Sie Folgendes schreiben: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (doc-&gt;docHandle()) {</code> </pre> <br>  <b>Defekt N7</b> <br><br>  Und der letzte Fall, der als Tippfehler eingestuft werden kann.  Der Fehler tritt aufgrund von Verwechslungen in den Namen der Konstanten auf, die sich nur im Fall des ersten Buchstabens unterscheiden. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QWindowsCursor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QPlatformCursor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CursorState { CursorShowing, CursorHidden, CursorSuppressed }; .... } QWindowsCursor::CursorState QWindowsCursor::cursorState() { <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { cursorShowing = <span class="hljs-number"><span class="hljs-number">0x1</span></span>, cursorSuppressed = <span class="hljs-number"><span class="hljs-number">0x2</span></span> }; CURSORINFO cursorInfo; cursorInfo.cbSize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(CURSORINFO); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GetCursorInfo(&amp;cursorInfo)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cursorInfo.flags &amp; CursorShowing) .... }</code> </pre> <br>  PVS-Studio Warnung: V616 CWE-480 Die benannte Konstante 'CursorShowing' mit dem Wert 0 wird in der bitweisen Operation verwendet.  qwindowscursor.cpp 669 <br><br>  Im Detail habe ich diesen Fehler bereits in einem separaten kleinen Hinweis analysiert: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der PVS-Studio-Analysator erwies sich erneut als aufmerksamer</a> als eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Person</a> ." <br><br><h2>  Sicherheitsl√ºcken </h2><br>  Tats√§chlich k√∂nnen alle in diesem Artikel beschriebenen Fehler als Sicherheitsm√§ngel bezeichnet werden.  Alle von ihnen sind nach der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Common Weakness Enumeration</a> klassifiziert (siehe CWE ID in den Analysatormeldungen).  Wenn Fehler als CWEs klassifiziert werden, stellen sie m√∂glicherweise ein Sicherheitsrisiko dar.  Dies wird auf der Seite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PVS-Studio SAST</a> n√§her erl√§utert. <br><br>  Ich m√∂chte jedoch einige Fehler in einer separaten Gruppe zusammenfassen.  Schauen wir sie uns an. <br><br>  <b>Defekt N8, N9</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QLocalServerPrivate::addListener() { .... SetSecurityDescriptorOwner(pSD.data(), pTokenUser-&gt;User.Sid, FALSE); SetSecurityDescriptorGroup(pSD.data(), pTokenGroup-&gt;PrimaryGroup, FALSE); .... }</code> </pre> <br>  PVS-Studio-Warnungen: <br><br><ul><li>  V530 CWE-252 Der R√ºckgabewert der Funktion 'SetSecurityDescriptorOwner' muss verwendet werden.  qlocalserver_win.cpp 167 </li><li>  V530 CWE-252 Der R√ºckgabewert der Funktion 'SetSecurityDescriptorGroup' muss verwendet werden.  qlocalserver_win.cpp 168 </li></ul><br>  Es gibt verschiedene Funktionen in Bezug auf die Zugangskontrolle.  <i>Dazu</i> geh√∂ren die Funktionen <i>SetSecurityDescriptorOwner</i> und <i>SetSecurityDescriptorGroup</i> . <br><br>  Mit solchen Funktionen m√ºssen Sie sehr sorgf√§ltig arbeiten.  Sie m√ºssen beispielsweise den Status √ºberpr√ºfen, den sie zur√ºckgeben.  Was passiert, wenn der Aufruf dieser Funktionen fehlschl√§gt?  Raten ist nicht erforderlich, es ist erforderlich, Code zu schreiben, um diesen Fall zu behandeln. <br><br>  Es ist nicht erforderlich, den Mangel an √úberpr√ºfung auszunutzen und solche Fehler in Schwachstellen umzuwandeln.  Dies ist jedoch in keinem Fall ein Ort f√ºr Risiken, und Sie m√ºssen sichereren Code schreiben. <br><br>  <b>Defekt N10</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QLocalServerPrivate::addListener() { .... InitializeAcl(acl, aclSize, ACL_REVISION_DS); .... }</code> </pre> <br>  PVS-Studio Warnung: V530 CWE-252 Der R√ºckgabewert der Funktion 'InitializeAcl' muss verwendet werden.  qlocalserver_win.cpp 144 <br><br>  Die Situation ist √§hnlich wie oben beschrieben. <br><br>  <b>Defekt N11, N12</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sha1ProcessChunk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... quint8 chunkBuffer[<span class="hljs-number"><span class="hljs-number">64</span></span>]; .... <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> SHA1_WIPE_VARIABLES .... memset(chunkBuffer, 0, 64); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br>  PVS-Studio Warnung: V597 CWE-14 Der Compiler k√∂nnte den Funktionsaufruf 'memset' l√∂schen, mit dem der 'chunkBuffer'-Puffer geleert wird.  Die Funktion RtlSecureZeroMemory () sollte verwendet werden, um die privaten Daten zu l√∂schen.  sha1.cpp 189 <br><br>  Der Compiler entfernt den <i>Memset-</i> Funktionsaufruf.  Bereits oft in Artikeln habe ich diese Situation analysiert.  Ich habe keine Lust, mich zu wiederholen.  Ich verweise auf den Artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sichere Bereinigung privater Daten</a> ". <br><br>  Ein weiterer Fehler befindet sich in derselben Datei sha1.cpp in Zeile 247. <br><br><h2>  Nullzeiger </h2><br>  Es ist Zeit, √ºber Hinweise zu sprechen.  Es gab viele Fehler zu diesem Thema. <br><br>  <b>Defekt N13</b> <br><br><pre> <code class="cpp hljs">QByteArray &amp;QByteArray::append(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *str, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) len = qstrlen(str); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str &amp;&amp; len) { .... }</code> </pre> <br>  PVS-Studio Warnung: V595 CWE-476 Der Zeiger 'str' wurde verwendet, bevor er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 2118, 2119. qbytearray.cpp 2118 <br><br>  Die klassische Situation ist, wenn am Anfang ein Zeiger verwendet und dann auf <i>Nullptr-</i> Gleichheit √ºberpr√ºft wird.  Dies ist ein sehr h√§ufiges Fehlermuster, das wir regelm√§√üig in fast allen Projekten sehen. <br><br>  <b>Defekt N14, N15</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> QMetaObjectPrivate *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">priv</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint* data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QMetaObjectPrivate*&gt;(data); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QMetaEnum::isFlag() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset = priv(mobj-&gt;d.data)-&gt;revision &gt;= <span class="hljs-number"><span class="hljs-number">8</span></span> ? <span class="hljs-number"><span class="hljs-number">2</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mobj &amp;&amp; mobj-&gt;d.data[handle + offset] &amp; EnumIsFlag; }</code> </pre> <br>  PVS-Studio Warnung: V595 CWE-476 Der 'mobj'-Zeiger wurde verwendet, bevor er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 2671, 2672. qmetaobject.cpp 2671 <br><br>  Nur f√ºr den Fall, ich bringe den K√∂rper der <i>Priv-</i> Funktion.  Aus irgendeinem Grund kommen Leser manchmal auf Situationen, in denen der Code funktioniert.  Ich verstehe nicht, woher dieses Misstrauen kommt und der Wunsch, eine knifflige Funktion irrt√ºmlich zu sehen :).  Zum Beispiel kann jemand in den Kommentaren vorschlagen, dass <i>priv</i> ein Makro des Formulars ist: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> priv(A) foo(sizeof(A))</span></span></code> </pre> <br>  Dann wird alles funktionieren. <br><br>  Um solche Diskussionen zu vermeiden, versuche ich, Codefragmente zu zitieren, in denen alle Informationen enthalten sind, die das Vorhandensein eines Fehlers best√§tigen. <br><br>  Der <i>modj-</i> Zeiger <i>wird also</i> dereferenziert und dann √ºberpr√ºft. <br><br>  Weiter auf der B√ºhne kommt die "m√§chtige und schreckliche" Copy-Paste.  Aufgrund dessen, was genau der gleiche Fehler in der <i>isScoped-</i> Funktion <i>erkannt</i> wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QMetaEnum::isScoped() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset = priv(mobj-&gt;d.data)-&gt;revision &gt;= <span class="hljs-number"><span class="hljs-number">8</span></span> ? <span class="hljs-number"><span class="hljs-number">2</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mobj &amp;&amp; mobj-&gt;d.data[handle + offset] &amp; EnumIsScoped; }</code> </pre> <br>  PVS-Studio Warnung: V595 CWE-476 Der 'mobj'-Zeiger wurde verwendet, bevor er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 2683, 2684. qmetaobject.cpp 2683 <br><br>  <b>Defekt N16-N21</b> <br><br>  Betrachten Sie ein anderes Beispiel und ich denke genug. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QTextCursor::insertFragment(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QTextDocumentFragment &amp;fragment) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!d || !d-&gt;priv || fragment.isEmpty()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; d-&gt;priv-&gt;beginEditBlock(); d-&gt;remove(); fragment.d-&gt;insert(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); d-&gt;priv-&gt;endEditBlock(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fragment.d &amp;&amp; fragment.d-&gt;doc) d-&gt;priv-&gt;mergeCachedResources(fragment.d-&gt;doc-&gt;docHandle()); }</code> </pre> <br>  PVS-Studio Warnung: V595 CWE-476 Der Zeiger 'fragment.d' wurde verwendet, bevor er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 2238, 2241. qtextcursor.cpp 2238 <br><br>  Trotzdem.  Achten Sie auf die Reihenfolge der Arbeit mit dem in der Variablen <i>fragment.d</i> gespeicherten Zeiger. <br><br>  Andere Fehler dieses Typs: <br><br><ul><li>  V595 CWE-476 Der 'Fenster'-Zeiger wurde verwendet, bevor er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 1846, 1848. qapplication.cpp 1846 </li><li>  V595 CWE-476 Der 'Fenster'-Zeiger wurde verwendet, bevor er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 1858, 1860. qapplication.cpp 1858 </li><li>  V595 CWE-476 Der 'Antwort'-Zeiger wurde verwendet, bevor er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 492, 502. qhttpnetworkconnectionchannel.cpp 492 </li><li>  V595 CWE-476 Der Zeiger 'newHandle' wurde verwendet, bevor er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 877, 883. qsplitter.cpp 877 </li><li>  V595 CWE-476 Der 'Widget'-Zeiger wurde verwendet, bevor er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 2320, 2322. qwindowsvistastyle.cpp 2320 </li><li>  In der Tat gibt es mehr Fehler.  Ich hatte es schnell satt, die V595-Warnungen zu lernen, und f√ºr den Artikel habe ich bereits genug Codefragmente geschrieben. </li></ul><br>  <b>Defekt N22-N33</b> <br><br>  Es gibt Code, in dem ein Zeiger √ºberpr√ºft wird, den der <i>neue</i> Operator zur√ºckgibt.  Dies ist besonders lustig, da es viele Stellen gibt, an denen das Ergebnis der <i>Malloc-</i> Funktion nicht √ºberpr√ºft wird (siehe folgende Fehlergruppe). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QTranslatorPrivate::do_load(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;realname, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;directory) { .... d-&gt;unmapPointer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[d-&gt;unmapLength]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d-&gt;unmapPointer) { file.seek(<span class="hljs-number"><span class="hljs-number">0</span></span>); qint64 readResult = file.read(d-&gt;unmapPointer, d-&gt;unmapLength); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (readResult == qint64(unmapLength)) ok = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } .... }</code> </pre> <br>  PVS-Studio Warnung: V668 CWE-571 Es macht keinen Sinn, den Zeiger 'd-&gt; unmap Pointer' gegen Null zu testen, da der Speicher mit dem Operator 'new' zugewiesen wurde.  Die Ausnahme wird bei einem Speicherzuordnungsfehler generiert.  qtranslator.cpp 596 <br><br>  Das √úberpr√ºfen des Zeigers ist nicht sinnvoll, da im Falle eines Speicherzuordnungsfehlers eine Ausnahme <i>std :: bad_alloc ausgel√∂st wird</i> .  Wenn der <i>neue</i> Operator <i>nullptr zur√ºckgeben soll,</i> wenn nicht gen√ºgend Speicher vorhanden ist, sollten Sie <i>Folgendes</i> schreiben: <br><br><pre> <code class="cpp hljs">d-&gt;unmapPointer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::nothrow) <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[d-&gt;unmapLength];</code> </pre> <br>  Der Analysator kennt diese Verwendung des <i>neuen</i> Operators und w√ºrde in diesem Fall keine Warnung geben. <br><br>  Andere Fehler: Ich werde ihnen die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datei qt-V668.txt geben</a> . <br><br>  <b>Defekt N34-N70</b> <br><br>  Wie versprochen sind jetzt Fehler an der Reihe, wenn sie das Ergebnis des Aufrufs der Funktionen <i>malloc</i> , <i>calloc</i> , <i>strdup</i> usw. nicht √ºberpr√ºfen.  Diese Fehler sind schwerwiegender, als es auf den ersten Blick scheint.  Weitere Details: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warum ist es wichtig zu √ºberpr√ºfen, was die Malloc-Funktion zur√ºckgegeben hat?</a> " <br><br><pre> <code class="cpp hljs">SourceFiles::SourceFiles() { nodes = (SourceFileNode**)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SourceFileNode*)*(num_nodes=<span class="hljs-number"><span class="hljs-number">3037</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = <span class="hljs-number"><span class="hljs-number">0</span></span>; n &lt; num_nodes; n++) nodes[n] = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; }</code> </pre> <br>  PVS-Studio Warnung: V522 CWE-690 M√∂glicherweise wird ein potenzieller Nullzeiger 'Knoten' dereferenziert.  √úberpr√ºfen Sie die Zeilen: 138, 136. makefiledeps.cpp 138 <br><br>  Der Zeiger wird ohne vorherige √úberpr√ºfung verwendet. <br><br>  Alle diese Fehler sind vom gleichen Typ, daher werde ich nicht n√§her darauf eingehen.  Ich werde den Rest der Warnliste geben: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">qt-V522-V575.txt</a> . <br><br><h2>  Logische Fehler in Bedingungen </h2><br>  <b>Defekt N71</b> <br><br><pre> <code class="cpp hljs">QString QEdidParser::parseEdidString(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> quint8 *data) { <span class="hljs-function"><span class="hljs-function">QByteArray </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">reinterpret_cast</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *&gt;(data), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">13</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// Erase carriage return and line feed buffer = buffer.replace('\r', '\0').replace('\n', '\0'); // Replace non-printable characters with dash for (int i = 0; i &lt; buffer.count(); ++i) { if (buffer[i] &lt; '\040' &amp;&amp; buffer[i] &gt; '\176') buffer[i] = '-'; } return QString::fromLatin1(buffer.trimmed()); }</span></span></code> </pre> <br>  PVS-Studio-Warnung: V547 CWE-570 Ausdruck 'buffer [i] &lt;' \ 040 '&amp;&amp; buffer [i]&gt;' \ 176 '' ist immer falsch.  qedidparser.cpp 169 <br><br>  Die Funktion muss die folgende Aktion ausf√ºhren: "Nicht druckbare Zeichen durch Bindestrich ersetzen".  Sie tut es jedoch nicht.  Schauen wir uns diesen Zustand genauer an: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer[i] &lt; <span class="hljs-string"><span class="hljs-string">'\040'</span></span> &amp;&amp; buffer[i] &gt; <span class="hljs-string"><span class="hljs-string">'\176'</span></span>)</code> </pre> <br>  Es macht keinen Sinn.  Ein Zeichen darf nicht kleiner als '\ 040' und gleichzeitig gr√∂√üer als '\ 176' sein.  In der Bedingung m√ºssen Sie den Operator '||' verwenden.  Der richtige Code lautet: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer[i] &lt; <span class="hljs-string"><span class="hljs-string">'\040'</span></span> || buffer[i] &gt; <span class="hljs-string"><span class="hljs-string">'\176'</span></span>)</code> </pre> <br>  <b>Defekt N72</b> <br><br>  Ein √§hnlicher Fehler, aufgrund dessen Windows-Benutzer kein Gl√ºck haben. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(Q_OS_WIN) static QString driveSpec(const QString &amp;path) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (path.size() </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; 2) return QString(); char c = path.at(0).toLatin1(); if (c &lt; 'a' &amp;&amp; c &gt; 'z' &amp;&amp; c &lt; 'A' &amp;&amp; c &gt; 'Z') return QString(); if (path.at(1).toLatin1() != ':') return QString(); return path.mid(0, 2); } #endif</span></span></span></span></code> </pre> <br>  Der Analysator generiert zwei Warnungen gleichzeitig: <br><br><ul><li>  V590 CWE-571 √úberpr√ºfen Sie den Ausdruck 'c &lt;' a '&amp;&amp; c&gt;' z '&amp;&amp; c &lt;' A '&amp;&amp; c&gt;' Z ''.  Der Ausdruck ist √ºbertrieben oder enth√§lt einen Druckfehler.  qdir.cpp 77 </li><li>  V560 CWE-570 Ein Teil des bedingten Ausdrucks ist immer falsch: c&gt; 'z'.  qdir.cpp 77 </li></ul><br>  Ein logischer Fehler ist in der Bedingung: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &lt; <span class="hljs-string"><span class="hljs-string">'a'</span></span> &amp;&amp; c &gt; <span class="hljs-string"><span class="hljs-string">'z'</span></span> &amp;&amp; c &lt; <span class="hljs-string"><span class="hljs-string">'A'</span></span> &amp;&amp; c &gt; <span class="hljs-string"><span class="hljs-string">'Z'</span></span>)</code> </pre> <br>  So wie ich es verstehe, wollte der Programmierer ein Zeichen finden, das kein Buchstabe des lateinischen Alphabets ist.  In diesem Fall sollte die Bedingung folgenderma√üen aussehen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((c &lt; <span class="hljs-string"><span class="hljs-string">'a'</span></span> || c &gt; <span class="hljs-string"><span class="hljs-string">'z'</span></span>) &amp;&amp; (c &lt; <span class="hljs-string"><span class="hljs-string">'A'</span></span> || c &gt; <span class="hljs-string"><span class="hljs-string">'Z'</span></span>))</code> </pre> <br>  <b>Defekt N73</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> SelectionMode { NoSelection, SingleSelection, MultiSelection, ExtendedSelection, ContiguousSelection }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QAccessibleTableCell::unselectCell() { QAbstractItemView::SelectionMode selectionMode = view-&gt;selectionMode(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_index.isValid() || (selectionMode &amp; QAbstractItemView::NoSelection)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; .... }</code> </pre> <br>  PVS-Studio Warnung: V616 CWE-480 Die benannte Konstante 'QAbstractItemView :: NoSelection' mit dem Wert 0 wird in der bitweisen Operation verwendet.  itemviews.cpp 976 <br><br>  Die benannte Konstante <i>QAbstractItemView :: NoSelection</i> ist Null.  Daher ist der Unterausdruck <i>(selectionMode &amp; QAbstractItemView :: NoSelection)</i> nicht sinnvoll.  Es wird immer 0 sein. <br><br>  Ich denke, es sollte hier geschrieben werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_index.isValid() || (selectionMode == QAbstractItemView::NoSelection))</code> </pre> <br>  <b>Defekt N74</b> <br><br>  Der folgende Code ist f√ºr mich schwer zu verstehen.  Er liegt falsch, aber ich wei√ü nicht, was er sein soll.  Das Kommentieren einer Funktion hilft mir auch nicht. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Re-engineered from the inline function _com_error::ErrorMessage(). // We cannot use it directly since it uses swprintf_s(), which is not // present in the MSVCRT.DLL found on Windows XP (QTBUG-35617). static inline QString errorMessageFromComError(const _com_error &amp;comError) { TCHAR *message = nullptr; FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, DWORD(comError.Error()), MAKELANGID(LANG_NEUTRAL,SUBLANG_DEFAULT), message, 0, NULL); if (message) { const QString result = QString::fromWCharArray(message).trimmed(); LocalFree(static_cast&lt;HLOCAL&gt;(message)); return result; } if (const WORD wCode = comError.WCode()) return QString::asprintf("IDispatch error #%u", uint(wCode)); return QString::asprintf("Unknown error 0x0%x", uint(comError.Error())); }</span></span></code> </pre> <br>  PVS-Studio Warnung: V547 CWE-570 Der Ausdruck 'message' ist immer falsch.  qwindowscontext.cpp 802 <br><br>  Der Programmierer geht wahrscheinlich davon aus, dass die <i>FormatMessage-</i> Funktion den Wert des <i>Nachrichtenzeigers</i> √§ndert.  Aber das ist nicht so.  Die <i>FormatMessage-Funktion</i> kann den Wert eines Zeigers nicht √§ndern, da er als Wert an die Funktion √ºbergeben wird.  Hier ist ein Prototyp dieser Funktion: <br><br><pre> <code class="cpp hljs">DWORD __<span class="hljs-function"><span class="hljs-function">stdcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormatMessageW</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments )</span></span></span></span>;</code> </pre> <br><br><h2>  M√∂gliche Speicherlecks </h2><br>  <b>Defekt N75-N92</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SourceDependChildren</span></span></span><span class="hljs-class"> {</span></span> SourceFile **children; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num_nodes, used_nodes; SourceDependChildren() : children(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>), num_nodes(<span class="hljs-number"><span class="hljs-number">0</span></span>), used_nodes(<span class="hljs-number"><span class="hljs-number">0</span></span>) { } ~SourceDependChildren() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (children) <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(children); children = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addChild</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SourceFile *s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(num_nodes &lt;= used_nodes) { num_nodes += <span class="hljs-number"><span class="hljs-number">200</span></span>; children = (SourceFile**)<span class="hljs-built_in"><span class="hljs-built_in">realloc</span></span>(children, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SourceFile*)*(num_nodes)); } children[used_nodes++] = s; } };</code> </pre> <br>  PVS-Studio-Warnung: V701 CWE-401 realloc () m√∂gliches Leck: Wenn realloc () beim Zuweisen von Speicher fehlschl√§gt, geht der urspr√ºngliche Zeiger 'Kinder' verloren.  Ziehen Sie in Betracht, einem tempor√§ren Zeiger realloc () zuzuweisen.  makefiledeps.cpp 103 <br><br>  Die Puffererweiterung wird auf gef√§hrliche Weise implementiert.  Wenn die <i>Realloc-</i> Funktion keinen Speicher zuweisen kann, wird <i>NULL zur√ºckgegeben</i> .  Dieser <i>NULL-</i> Wert wird sofort in die <i>untergeordnete</i> Variable eingef√ºgt, und es besteht keine M√∂glichkeit, den zuvor zugewiesenen Puffer irgendwie freizugeben.  Ein Speicherverlust tritt auf. <br><br>  √Ñhnliche Fehler: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">qt-701.txt</a> . <br><br><h2>  Verschiedenes </h2><br>  <b>Defekt N93</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GradientBase</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BlendType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inline</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BlendType</span></span></span><span class="hljs-class"> * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QT_FASTCALL</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">qt_fetch_linear_gradient_template</span></span></span><span class="hljs-class">(....) {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t+inc*length &lt; qreal(INT_MAX &gt;&gt; (FIXPT_BITS + <span class="hljs-number"><span class="hljs-number">1</span></span>)) &amp;&amp; t+inc*length &gt; qreal(INT_MIN &gt;&gt; (FIXPT_BITS + <span class="hljs-number"><span class="hljs-number">1</span></span>))) { .... }</code> </pre> <br>  PVS-Studio Warnung: V610 CWE-758 Nicht angegebenes Verhalten.  √úberpr√ºfen Sie den Schaltoperator '&gt;&gt;'.  Der linke Operand '(- 2147483647 - 1)' ist negativ.  qdrawhelper.cpp 4015 <br><br>  Der negative Wert von <i>INT_MIN</i> kann nicht verschoben werden.  Dies ist ein nicht angegebenes Verhalten, und Sie k√∂nnen sich nicht auf das Ergebnis einer solchen Operation verlassen.  Die h√∂chstwertigen Bits k√∂nnen gleich 0 oder 1 sein. <br><br>  <b>Defekt N94</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QObjectPrivate::addConnection(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> signal, Connection *c) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (signal &gt;= connectionLists-&gt;count()) connectionLists-&gt;resize(signal + <span class="hljs-number"><span class="hljs-number">1</span></span>); ConnectionList &amp;connectionList = (*connectionLists)[signal]; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (signal &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... }</code> </pre> <br>  PVS-Studio Warnung: V781 CWE-129 Der Wert der Variablen 'signal' wird nach ihrer Verwendung √ºberpr√ºft.  M√∂glicherweise liegt ein Fehler in der Programmlogik vor.  √úberpr√ºfen Sie die Zeilen: 397, 413. qobject.cpp 397 <br><br>  Eine Pr√ºfung <i>(Signal &lt;0)</i> zeigt an, dass der Wert des <i>Signalarguments</i> negativ sein kann.  Dieses Argument wurde jedoch zuvor zum Indizieren des Arrays verwendet.  Es stellt sich heraus, dass die Pr√ºfung zu sp√§t durchgef√ºhrt wird.  Das Programm wird bereits unterbrochen. <br><br>  <b>Defekt N95</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QXmlStreamWriterPrivate::finishStartElement(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> contents) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inEmptyElement) { write(<span class="hljs-string"><span class="hljs-string">"/&gt;"</span></span>); QXmlStreamWriterPrivate::Tag &amp;tag = tagStack_pop(); lastNamespaceDeclaration = tag.namespaceDeclarationsSize; lastWasStartElement = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { write(<span class="hljs-string"><span class="hljs-string">"&gt;"</span></span>); } inStartElement = inEmptyElement = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; lastNamespaceDeclaration = namespaceDeclarations.size(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hadSomethingWritten; }</code> </pre> <br>  PVS-Studio Warnung: V519 CWE-563 Der Variablen 'lastNamespaceDeclaration' werden zweimal nacheinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 3188, 3194. qxmlstream.cpp 3194 <br><br>  Ich werde das Wesentliche des Fehlers hervorheben: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inEmptyElement) { lastNamespaceDeclaration = tag.namespaceDeclarationsSize; } lastNamespaceDeclaration = namespaceDeclarations.size();</code> </pre> <br>  <b>Defekt N96</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QRollEffect::scroll() { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentHeight != totalHeight) { currentHeight = totalHeight * (elapsed/duration) + (<span class="hljs-number"><span class="hljs-number">2</span></span> * totalHeight * (elapsed%duration) + duration) / (<span class="hljs-number"><span class="hljs-number">2</span></span> * duration); <span class="hljs-comment"><span class="hljs-comment">// equiv. to int((totalHeight*elapsed) / duration + 0.5) done = (currentHeight &gt;= totalHeight); } done = (currentHeight &gt;= totalHeight) &amp;&amp; (currentWidth &gt;= totalWidth); .... }</span></span></code> </pre> <br>  V519 CWE-563 Der Variablen 'done' werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 509, 511. qeffects.cpp 511 <br><br>  Alles ist das gleiche wie im vorherigen Fall.  Beachten Sie die Variable <i>done</i> . <br><br><h2>  Fazit </h2><br>  Selbst wenn ich den Bericht oberfl√§chlich durchgesehen habe, habe ich fast 100 Fehler geschrieben.  Ich bin mit den Ergebnissen von PVS-Studio zufrieden. <br><br>  Nat√ºrlich haben solche seltenen Codepr√ºfungen nichts mit der Verbesserung der Qualit√§t und Zuverl√§ssigkeit des Codes zu tun.  Sie demonstrieren nur die F√§higkeiten des Code-Analysators.  Statische Analysewerkzeuge sollten regelm√§√üig angewendet werden.  In diesem Fall reduzieren sie die Kosten f√ºr die Behebung von Fehlern und sch√ºtzen Anwendungen vor vielen potenziellen Schwachstellen. <br><br>  Vielen Dank f√ºr Ihre Aufmerksamkeit.  Um √ºber unsere neuen Ver√∂ffentlichungen auf dem Laufenden zu bleiben, lade ich Sie ein, einen unserer Kan√§le zu abonnieren: <ol><li>  VK.com: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pvsstudio_rus</a> </li><li>  "Old School" RSS: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">viva64-blog-ru</a> </li><li>  Twitter: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@pvsstudio_rus</a> </li><li>  Instagram: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@pvsstudio_rus</a> </li><li>  Telegramm: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@pvsstudio_rus</a> </li></ol><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br>  Wenn Sie diesen Artikel einem englischsprachigen Publikum zug√§nglich machen m√∂chten, verwenden Sie bitte den Link zur √úbersetzung: Andrey Karpov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eine dritte √úberpr√ºfung von Qt 5 mit PVS-Studio</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426485/">https://habr.com/ru/post/de426485/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426475/index.html">Miya - Assistent vom Smartphone</a></li>
<li><a href="../de426477/index.html">Die ganze Wahrheit √ºber RTOS. Artikel Nr. 15. Speicherpartitionen: Dienste und Datenstrukturen</a></li>
<li><a href="../de426479/index.html">Selbst gemachter Pr√ºfstand f√ºr Motherboards</a></li>
<li><a href="../de426481/index.html">Hexagon Maps in Unity: Pfadfinder, Spielertrupps, Animationen</a></li>
<li><a href="../de426483/index.html">Einer, der Tesla √ºberholt. F√ºr profitabler</a></li>
<li><a href="../de426487/index.html">Testen Sie die Automatisierung von Grund auf neu. Teil 1</a></li>
<li><a href="../de426489/index.html">√úber das Verh√§ltnis von Primzahlen und irrationalen Zahlen</a></li>
<li><a href="../de426491/index.html">Sicherheitswoche 39: Zum Tod von Google+</a></li>
<li><a href="../de426493/index.html">St√§ndige Rabatte von Hostern f√ºr Besucher von VPS und VPS.today Search</a></li>
<li><a href="../de426495/index.html">Solo Designer. Wie man eine Karriere aufbaut, wenn man alleine arbeitet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>