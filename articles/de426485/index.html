<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>❤️ 🥫 💇🏾 Dritter Qt 5 Test mit PVS-Studio 👛 🌦️ 👊🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Von Zeit zu Zeit überprüft unser Team erneut Projekte, über die wir bereits Artikel geschrieben haben. Ein weiteres solches erneut geprüftes Projekt w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dritter Qt 5 Test mit PVS-Studio</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/426485/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd9/87d/907/dd987d90784865f850555bc198a97b81.png" alt="PVS-Studio &amp; Qt"></div><br>  Von Zeit zu Zeit überprüft unser Team erneut Projekte, über die wir bereits Artikel geschrieben haben.  Ein weiteres solches erneut geprüftes Projekt war Qt.  Das letzte Mal haben wir es 2014 mit PVS-Studio getestet.  Seit 2014 wird das Projekt regelmäßig mit Hilfe von Coverity überprüft.  Das ist interessant.  Mal sehen, ob wir jetzt mit PVS-Studio interessante Fehler finden können. <br><a name="habracut"></a><br><h2>  Qt </h2><br>  Vorherige Artikel: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie man die Wahrscheinlichkeit von Fehlern beim Schreiben von Code verringert</a> ", Juli 2011. </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Qt 5 Framework Check</a> ", April 2014. </li></ul><br>  Diesmal wurden <a href="">Qt Base</a> (Core, Gui, Widgets, Network, ...) und <a href="">Qt5 Super Module getestet</a> .  Über Qt Creator planen wir, später einen separaten Artikel zu schreiben.  Zur Überprüfung haben wir den statischen Analysator PVS-Studio verwendet, dessen Testversion Sie von der Website <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">herunterladen</a> können. <br><br>  Meiner subjektiven Meinung nach ist der Qt-Code besser geworden.  Im Laufe der Jahre seit dem letzten Test sind im PVS-Studio-Analysegerät viele neue Diagnosen erschienen.  Trotzdem habe ich bei der Überprüfung der Warnungen nicht so viele Fehler für ein Projekt dieser Größe gefunden.  Ich wiederhole noch einmal, dass dies mein individueller Eindruck ist.  Ich habe damals oder heute keine speziellen Untersuchungen zur Fehlerdichte durchgeführt. <br><br>  Höchstwahrscheinlich wirkten sich regelmäßige Überprüfungen mit dem statischen Analysegerät Coverity höchstwahrscheinlich auf die Qualität des Codes aus.  2014 wurde mit Hilfe von Coverity das Qt-Projekt ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">qt-project</a> ) und 2016 der Qt Creator ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">qt-creator</a> ) überprüft.  Meine Meinung: Wenn Sie ein Open Source-Projekt entwickeln, kann <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Coverity Scan</a> eine gute kostenlose Lösung sein, die die Qualität und Zuverlässigkeit Ihrer Projekte erheblich verbessert. <br><br>  Wie der Leser jedoch erraten kann, hätte es keinen Artikel gegeben, wenn ich im PVS-Studio-Bericht nichts Interessantes bemerkt hätte :).  Und da es einen Artikel gibt, also Mängel.  Schauen wir sie uns an.  Insgesamt habe ich 96 Fehler ausgeschrieben. <br><br><h2>  Erfolgloses Kopieren, Einfügen und Tippfehler </h2><br>  Beginnen wir mit den Klassikern des Genres, wenn die Ursache des Fehlers Unaufmerksamkeit ist.  Diese Fehler werden von Programmierern unterschätzt.  Für diejenigen, die noch nicht gelesen haben, empfehle ich, dass Sie sich diese beiden Artikel ansehen: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Effekt der letzten Zeile</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Böse lebt in Vergleichsfunktionen</a> </li></ul><br>  Diese Fehler sind interlanguage.  Zum Beispiel enthält der zweite Artikel viele Beispiele für Fehler in Vergleichsfunktionen, die in C, C ++ und C # geschrieben wurden.  Bei der Implementierung der Java-Sprachunterstützung in PVS-Studio treten dieselben Fehlermuster auf.  Hier ist zum Beispiel ein Fehler, den wir kürzlich in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hibernate-</a> Bibliothek gefunden haben: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object other)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (other instanceof Id) { Id that = (Id) other; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> purchaseSequence.equals(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.purchaseSequence) &amp;&amp; that.purchaseNumber == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.purchaseNumber; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  Wenn Sie genau hinschauen, stellt sich heraus, dass das Feld <i>purchaseSequence</i> mit sich selbst verglichen wird.  Die richtige Option: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> that.purchaseSequence.equals(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.purchaseSequence) &amp;&amp; that.purchaseNumber == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.purchaseNumber;</code> </pre> <br>  Im Allgemeinen ist alles wie immer, und der PVS-Studio-Analysator muss die Augean-Ställe in Java-Projekten "harken".  Übrigens laden wir alle ein, am Testen der Beta-Version von PVS-Studio für Java teilzunehmen, die in naher Zukunft erscheinen wird.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schreiben Sie uns dazu</a> (wählen Sie "Ich möchte den Analysator für Java"). <br><br>  Nun zurück zu den Fehlern im Qt-Projekt. <br><br>  <b>Defekt N1</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">windowDpiAwareness</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HWND hwnd)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QWindowsContext::user32dll.getWindowDpiAwarenessContext &amp;&amp; QWindowsContext::user32dll.getWindowDpiAwarenessContext ? QWindowsContext::user32dll.getAwarenessFromDpiAwarenessContext( QWindowsContext::user32dll.getWindowDpiAwarenessContext(hwnd)) : <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre> <br>  PVS-Studio Warnung: V501 CWE-571 Links und rechts vom Operator '&amp;&amp;' befinden sich identische Unterausdrücke 'QWindowsContext :: user32dll.getWindowDpiAwarenessContext'.  qwindowscontext.cpp 150 <br><br>  Eine spezielle Erklärung neben der Analysatormeldung ist hier nicht erforderlich.  Es scheint mir, dass der Ausdruck so hätte sein sollen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QWindowsContext::user32dll.getAwarenessFromDpiAwarenessContext &amp;&amp; QWindowsContext::user32dll.getWindowDpiAwarenessContext ? QWindowsContext::user32dll.getAwarenessFromDpiAwarenessContext( QWindowsContext::user32dll.getWindowDpiAwarenessContext(hwnd)) : <span class="hljs-number"><span class="hljs-number">-1</span></span>;</code> </pre> <br>  <b>Defekt N2, N3</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QReadWriteLockPrivate::release() { Q_ASSERT(!recursive); Q_ASSERT(!waitingReaders &amp;&amp; !waitingReaders &amp;&amp; !readerCount &amp;&amp; !writerCount); freelist-&gt;release(id); }</code> </pre> <br>  PVS-Studio Warnung: V501 CWE-571 Links und rechts vom Operator '&amp;&amp;' befinden sich identische Unterausdrücke:! WaitingReaders &amp;&amp;! WaitingReaders qreadwritelock.cpp 632 <br><br>  Der Fehler befindet sich innerhalb der <i>Makrobedingung Q_ASSERT</i> und ist daher nicht signifikant.  Trotzdem ist dies ein Fehler.  Die Variable <i>waitReaders</i> ist doppelt geprüft.  Und anscheinend haben sie vergessen, eine andere Variable zu überprüfen. <br><br>  Ein identischer Fehler wird in der Zeile 625 der Datei qreadwritelock.cpp gefunden.  Es lebe das Kopieren und Einfügen!  :) :) <br><br>  <b>Defekt N4</b> <br><br><pre> <code class="cpp hljs">QString QGraphicsSceneBspTree::debug(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node-&gt;type == Node::Horizontal) { tmp += debug(firstChildIndex(index)); tmp += debug(firstChildIndex(index) + <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tmp += debug(firstChildIndex(index)); tmp += debug(firstChildIndex(index) + <span class="hljs-number"><span class="hljs-number">1</span></span>); } .... }</code> </pre> <br>  PVS-Studio Warnung: V523 CWE-691 Die Anweisung 'then' entspricht der Anweisung 'else'.  qgraphicsscene_bsp.cpp 179 <br><br>  Höchstwahrscheinlich wurde der Textblock kopiert, aber sie haben vergessen, ihn zu korrigieren. <br><br>  <b>Defekt N5</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> FillRule { OddEvenFill, WindingFill }; QDataStream &amp;<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;&gt;(QDataStream &amp;s, QPainterPath &amp;p) { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fillRule; s &gt;&gt; fillRule; Q_ASSERT(fillRule == Qt::OddEvenFill || Qt::WindingFill); .... }</code> </pre> <br>  PVS-Studio Warnung: V768 CWE-571 Die Aufzählungskonstante 'WindingFill' wird als Variable eines Booleschen Typs verwendet.  qpainterpath.cpp 2479 <br><br>  Stimmen Sie zu, das ist ein wunderschöner Blooper!  <i>Q_ASSERT</i> überprüft nichts, da die Bedingung immer wahr ist.  Die Bedingung ist wahr, da die benannte Konstante <i>Qt :: WindingFill</i> 1 ist. <br><br>  <b>Defekt N6</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QVariant::canConvert(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetTypeId) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentType == QMetaType::SChar || currentType == QMetaType::Char) currentType = QMetaType::UInt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (targetTypeId == QMetaType::SChar || currentType == QMetaType::Char) targetTypeId = QMetaType::UInt; .... }</code> </pre> <br>  Versuchen Sie vor dem Lesen der Warnung, selbst einen Tippfehler zu erkennen.  Durch Hinzufügen eines Bildes helfe ich Ihnen, die Analysatormeldung nicht sofort zu lesen :). <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/86f/f1d/7c5/86ff1d7c55cdc0fb71cbce45f2f84f05.png" alt="Zeit zum Nachdenken"></div><br><br>  PVS-Studio Warnung: V560 CWE-570 Ein Teil des bedingten Ausdrucks ist immer falsch: currentType == QMetaType :: Char.  qvariant.cpp 3529 <br><br>  Die Bedingung "currentType == QMetaType :: Char" wird im ersten <i>if</i> überprüft.  Wenn die Bedingung erfüllt ist, wird die Variable <i>currentType</i> auf <i>QMetaType :: UInt gesetzt</i> .  Daher kann die Variable <i>currentType</i> nicht mehr gleich <i>QMetaType :: Char sein</i> .  Daher meldet der Analysator, dass im zweiten <i>if der</i> Unterausdruck "currentType == QMetaType :: Char" immer falsch ist. <br><br>  In der Tat sollte das zweite <i>if</i> so sein: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (targetTypeId == QMetaType::SChar || targetTypeId == QMetaType::Char) targetTypeId = QMetaType::UInt;</code> </pre> <br><br>  <b>V560 Diagnosehinweis</b> <br><br>  Der Bericht fand viele V560-Warnungen.  Ich habe sie mir jedoch nicht mehr angesehen, sobald ich einen interessanten Fall für den Artikel gefunden habe, der oben als Defekt N6 angesehen wurde. <br><br>  Die überwiegende Mehrheit der Nachrichten V560 kann nicht als falsch bezeichnet werden, sie werden jedoch nicht verwendet.  Mit anderen Worten, es ist nicht interessant, sie in einem Artikel zu beschreiben.  Um klar zu machen, was ich genau meine, betrachten Sie einen solchen Fall. <br><br><pre> <code class="cpp hljs">QString QTextHtmlExporter::findUrlForImage(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QTextDocument *doc, ....) { QString url; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!doc) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> url; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (QTextDocument *parent = qobject_cast&lt;QTextDocument *&gt;(doc-&gt;parent())) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> findUrlForImage(parent, cacheKey, isPixmap); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (doc &amp;&amp; doc-&gt;docHandle()) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }</span></span></code> </pre> <br>  Warnung PVS-Stuidio: V560 CWE-571 Ein Teil des bedingten Ausdrucks ist immer wahr: doc.  qtextdocument.cpp 2992 <br><br>  Der Analysator ist absolut korrekt, dass der <i>doc-</i> Zeiger nicht immer <i>nullptr ist,</i> wenn er erneut überprüft wird.  Dies ist jedoch kein Fehler, nur der Programmierer war in Sicherheit.  Sie können den Code vereinfachen, indem Sie Folgendes schreiben: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (doc-&gt;docHandle()) {</code> </pre> <br>  <b>Defekt N7</b> <br><br>  Und der letzte Fall, der als Tippfehler eingestuft werden kann.  Der Fehler tritt aufgrund von Verwechslungen in den Namen der Konstanten auf, die sich nur im Fall des ersten Buchstabens unterscheiden. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QWindowsCursor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QPlatformCursor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CursorState { CursorShowing, CursorHidden, CursorSuppressed }; .... } QWindowsCursor::CursorState QWindowsCursor::cursorState() { <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { cursorShowing = <span class="hljs-number"><span class="hljs-number">0x1</span></span>, cursorSuppressed = <span class="hljs-number"><span class="hljs-number">0x2</span></span> }; CURSORINFO cursorInfo; cursorInfo.cbSize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(CURSORINFO); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GetCursorInfo(&amp;cursorInfo)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cursorInfo.flags &amp; CursorShowing) .... }</code> </pre> <br>  PVS-Studio Warnung: V616 CWE-480 Die benannte Konstante 'CursorShowing' mit dem Wert 0 wird in der bitweisen Operation verwendet.  qwindowscursor.cpp 669 <br><br>  Im Detail habe ich diesen Fehler bereits in einem separaten kleinen Hinweis analysiert: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der PVS-Studio-Analysator erwies sich erneut als aufmerksamer</a> als eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Person</a> ." <br><br><h2>  Sicherheitslücken </h2><br>  Tatsächlich können alle in diesem Artikel beschriebenen Fehler als Sicherheitsmängel bezeichnet werden.  Alle von ihnen sind nach der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Common Weakness Enumeration</a> klassifiziert (siehe CWE ID in den Analysatormeldungen).  Wenn Fehler als CWEs klassifiziert werden, stellen sie möglicherweise ein Sicherheitsrisiko dar.  Dies wird auf der Seite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PVS-Studio SAST</a> näher erläutert. <br><br>  Ich möchte jedoch einige Fehler in einer separaten Gruppe zusammenfassen.  Schauen wir sie uns an. <br><br>  <b>Defekt N8, N9</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QLocalServerPrivate::addListener() { .... SetSecurityDescriptorOwner(pSD.data(), pTokenUser-&gt;User.Sid, FALSE); SetSecurityDescriptorGroup(pSD.data(), pTokenGroup-&gt;PrimaryGroup, FALSE); .... }</code> </pre> <br>  PVS-Studio-Warnungen: <br><br><ul><li>  V530 CWE-252 Der Rückgabewert der Funktion 'SetSecurityDescriptorOwner' muss verwendet werden.  qlocalserver_win.cpp 167 </li><li>  V530 CWE-252 Der Rückgabewert der Funktion 'SetSecurityDescriptorGroup' muss verwendet werden.  qlocalserver_win.cpp 168 </li></ul><br>  Es gibt verschiedene Funktionen in Bezug auf die Zugangskontrolle.  <i>Dazu</i> gehören die Funktionen <i>SetSecurityDescriptorOwner</i> und <i>SetSecurityDescriptorGroup</i> . <br><br>  Mit solchen Funktionen müssen Sie sehr sorgfältig arbeiten.  Sie müssen beispielsweise den Status überprüfen, den sie zurückgeben.  Was passiert, wenn der Aufruf dieser Funktionen fehlschlägt?  Raten ist nicht erforderlich, es ist erforderlich, Code zu schreiben, um diesen Fall zu behandeln. <br><br>  Es ist nicht erforderlich, den Mangel an Überprüfung auszunutzen und solche Fehler in Schwachstellen umzuwandeln.  Dies ist jedoch in keinem Fall ein Ort für Risiken, und Sie müssen sichereren Code schreiben. <br><br>  <b>Defekt N10</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QLocalServerPrivate::addListener() { .... InitializeAcl(acl, aclSize, ACL_REVISION_DS); .... }</code> </pre> <br>  PVS-Studio Warnung: V530 CWE-252 Der Rückgabewert der Funktion 'InitializeAcl' muss verwendet werden.  qlocalserver_win.cpp 144 <br><br>  Die Situation ist ähnlich wie oben beschrieben. <br><br>  <b>Defekt N11, N12</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sha1ProcessChunk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... quint8 chunkBuffer[<span class="hljs-number"><span class="hljs-number">64</span></span>]; .... <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> SHA1_WIPE_VARIABLES .... memset(chunkBuffer, 0, 64); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br>  PVS-Studio Warnung: V597 CWE-14 Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem der 'chunkBuffer'-Puffer geleert wird.  Die Funktion RtlSecureZeroMemory () sollte verwendet werden, um die privaten Daten zu löschen.  sha1.cpp 189 <br><br>  Der Compiler entfernt den <i>Memset-</i> Funktionsaufruf.  Bereits oft in Artikeln habe ich diese Situation analysiert.  Ich habe keine Lust, mich zu wiederholen.  Ich verweise auf den Artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sichere Bereinigung privater Daten</a> ". <br><br>  Ein weiterer Fehler befindet sich in derselben Datei sha1.cpp in Zeile 247. <br><br><h2>  Nullzeiger </h2><br>  Es ist Zeit, über Hinweise zu sprechen.  Es gab viele Fehler zu diesem Thema. <br><br>  <b>Defekt N13</b> <br><br><pre> <code class="cpp hljs">QByteArray &amp;QByteArray::append(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *str, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) len = qstrlen(str); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str &amp;&amp; len) { .... }</code> </pre> <br>  PVS-Studio Warnung: V595 CWE-476 Der Zeiger 'str' wurde verwendet, bevor er gegen nullptr verifiziert wurde.  Überprüfen Sie die Zeilen: 2118, 2119. qbytearray.cpp 2118 <br><br>  Die klassische Situation ist, wenn am Anfang ein Zeiger verwendet und dann auf <i>Nullptr-</i> Gleichheit überprüft wird.  Dies ist ein sehr häufiges Fehlermuster, das wir regelmäßig in fast allen Projekten sehen. <br><br>  <b>Defekt N14, N15</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> QMetaObjectPrivate *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">priv</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint* data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QMetaObjectPrivate*&gt;(data); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QMetaEnum::isFlag() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset = priv(mobj-&gt;d.data)-&gt;revision &gt;= <span class="hljs-number"><span class="hljs-number">8</span></span> ? <span class="hljs-number"><span class="hljs-number">2</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mobj &amp;&amp; mobj-&gt;d.data[handle + offset] &amp; EnumIsFlag; }</code> </pre> <br>  PVS-Studio Warnung: V595 CWE-476 Der 'mobj'-Zeiger wurde verwendet, bevor er gegen nullptr verifiziert wurde.  Überprüfen Sie die Zeilen: 2671, 2672. qmetaobject.cpp 2671 <br><br>  Nur für den Fall, ich bringe den Körper der <i>Priv-</i> Funktion.  Aus irgendeinem Grund kommen Leser manchmal auf Situationen, in denen der Code funktioniert.  Ich verstehe nicht, woher dieses Misstrauen kommt und der Wunsch, eine knifflige Funktion irrtümlich zu sehen :).  Zum Beispiel kann jemand in den Kommentaren vorschlagen, dass <i>priv</i> ein Makro des Formulars ist: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> priv(A) foo(sizeof(A))</span></span></code> </pre> <br>  Dann wird alles funktionieren. <br><br>  Um solche Diskussionen zu vermeiden, versuche ich, Codefragmente zu zitieren, in denen alle Informationen enthalten sind, die das Vorhandensein eines Fehlers bestätigen. <br><br>  Der <i>modj-</i> Zeiger <i>wird also</i> dereferenziert und dann überprüft. <br><br>  Weiter auf der Bühne kommt die "mächtige und schreckliche" Copy-Paste.  Aufgrund dessen, was genau der gleiche Fehler in der <i>isScoped-</i> Funktion <i>erkannt</i> wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QMetaEnum::isScoped() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset = priv(mobj-&gt;d.data)-&gt;revision &gt;= <span class="hljs-number"><span class="hljs-number">8</span></span> ? <span class="hljs-number"><span class="hljs-number">2</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mobj &amp;&amp; mobj-&gt;d.data[handle + offset] &amp; EnumIsScoped; }</code> </pre> <br>  PVS-Studio Warnung: V595 CWE-476 Der 'mobj'-Zeiger wurde verwendet, bevor er gegen nullptr verifiziert wurde.  Überprüfen Sie die Zeilen: 2683, 2684. qmetaobject.cpp 2683 <br><br>  <b>Defekt N16-N21</b> <br><br>  Betrachten Sie ein anderes Beispiel und ich denke genug. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QTextCursor::insertFragment(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QTextDocumentFragment &amp;fragment) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!d || !d-&gt;priv || fragment.isEmpty()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; d-&gt;priv-&gt;beginEditBlock(); d-&gt;remove(); fragment.d-&gt;insert(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); d-&gt;priv-&gt;endEditBlock(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fragment.d &amp;&amp; fragment.d-&gt;doc) d-&gt;priv-&gt;mergeCachedResources(fragment.d-&gt;doc-&gt;docHandle()); }</code> </pre> <br>  PVS-Studio Warnung: V595 CWE-476 Der Zeiger 'fragment.d' wurde verwendet, bevor er gegen nullptr verifiziert wurde.  Überprüfen Sie die Zeilen: 2238, 2241. qtextcursor.cpp 2238 <br><br>  Trotzdem.  Achten Sie auf die Reihenfolge der Arbeit mit dem in der Variablen <i>fragment.d</i> gespeicherten Zeiger. <br><br>  Andere Fehler dieses Typs: <br><br><ul><li>  V595 CWE-476 Der 'Fenster'-Zeiger wurde verwendet, bevor er gegen nullptr verifiziert wurde.  Überprüfen Sie die Zeilen: 1846, 1848. qapplication.cpp 1846 </li><li>  V595 CWE-476 Der 'Fenster'-Zeiger wurde verwendet, bevor er gegen nullptr verifiziert wurde.  Überprüfen Sie die Zeilen: 1858, 1860. qapplication.cpp 1858 </li><li>  V595 CWE-476 Der 'Antwort'-Zeiger wurde verwendet, bevor er gegen nullptr verifiziert wurde.  Überprüfen Sie die Zeilen: 492, 502. qhttpnetworkconnectionchannel.cpp 492 </li><li>  V595 CWE-476 Der Zeiger 'newHandle' wurde verwendet, bevor er gegen nullptr verifiziert wurde.  Überprüfen Sie die Zeilen: 877, 883. qsplitter.cpp 877 </li><li>  V595 CWE-476 Der 'Widget'-Zeiger wurde verwendet, bevor er gegen nullptr verifiziert wurde.  Überprüfen Sie die Zeilen: 2320, 2322. qwindowsvistastyle.cpp 2320 </li><li>  In der Tat gibt es mehr Fehler.  Ich hatte es schnell satt, die V595-Warnungen zu lernen, und für den Artikel habe ich bereits genug Codefragmente geschrieben. </li></ul><br>  <b>Defekt N22-N33</b> <br><br>  Es gibt Code, in dem ein Zeiger überprüft wird, den der <i>neue</i> Operator zurückgibt.  Dies ist besonders lustig, da es viele Stellen gibt, an denen das Ergebnis der <i>Malloc-</i> Funktion nicht überprüft wird (siehe folgende Fehlergruppe). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QTranslatorPrivate::do_load(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;realname, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;directory) { .... d-&gt;unmapPointer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[d-&gt;unmapLength]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d-&gt;unmapPointer) { file.seek(<span class="hljs-number"><span class="hljs-number">0</span></span>); qint64 readResult = file.read(d-&gt;unmapPointer, d-&gt;unmapLength); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (readResult == qint64(unmapLength)) ok = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } .... }</code> </pre> <br>  PVS-Studio Warnung: V668 CWE-571 Es macht keinen Sinn, den Zeiger 'd-&gt; unmap Pointer' gegen Null zu testen, da der Speicher mit dem Operator 'new' zugewiesen wurde.  Die Ausnahme wird bei einem Speicherzuordnungsfehler generiert.  qtranslator.cpp 596 <br><br>  Das Überprüfen des Zeigers ist nicht sinnvoll, da im Falle eines Speicherzuordnungsfehlers eine Ausnahme <i>std :: bad_alloc ausgelöst wird</i> .  Wenn der <i>neue</i> Operator <i>nullptr zurückgeben soll,</i> wenn nicht genügend Speicher vorhanden ist, sollten Sie <i>Folgendes</i> schreiben: <br><br><pre> <code class="cpp hljs">d-&gt;unmapPointer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::nothrow) <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[d-&gt;unmapLength];</code> </pre> <br>  Der Analysator kennt diese Verwendung des <i>neuen</i> Operators und würde in diesem Fall keine Warnung geben. <br><br>  Andere Fehler: Ich werde ihnen die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datei qt-V668.txt geben</a> . <br><br>  <b>Defekt N34-N70</b> <br><br>  Wie versprochen sind jetzt Fehler an der Reihe, wenn sie das Ergebnis des Aufrufs der Funktionen <i>malloc</i> , <i>calloc</i> , <i>strdup</i> usw. nicht überprüfen.  Diese Fehler sind schwerwiegender, als es auf den ersten Blick scheint.  Weitere Details: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warum ist es wichtig zu überprüfen, was die Malloc-Funktion zurückgegeben hat?</a> " <br><br><pre> <code class="cpp hljs">SourceFiles::SourceFiles() { nodes = (SourceFileNode**)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SourceFileNode*)*(num_nodes=<span class="hljs-number"><span class="hljs-number">3037</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = <span class="hljs-number"><span class="hljs-number">0</span></span>; n &lt; num_nodes; n++) nodes[n] = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; }</code> </pre> <br>  PVS-Studio Warnung: V522 CWE-690 Möglicherweise wird ein potenzieller Nullzeiger 'Knoten' dereferenziert.  Überprüfen Sie die Zeilen: 138, 136. makefiledeps.cpp 138 <br><br>  Der Zeiger wird ohne vorherige Überprüfung verwendet. <br><br>  Alle diese Fehler sind vom gleichen Typ, daher werde ich nicht näher darauf eingehen.  Ich werde den Rest der Warnliste geben: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">qt-V522-V575.txt</a> . <br><br><h2>  Logische Fehler in Bedingungen </h2><br>  <b>Defekt N71</b> <br><br><pre> <code class="cpp hljs">QString QEdidParser::parseEdidString(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> quint8 *data) { <span class="hljs-function"><span class="hljs-function">QByteArray </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">reinterpret_cast</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *&gt;(data), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">13</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// Erase carriage return and line feed buffer = buffer.replace('\r', '\0').replace('\n', '\0'); // Replace non-printable characters with dash for (int i = 0; i &lt; buffer.count(); ++i) { if (buffer[i] &lt; '\040' &amp;&amp; buffer[i] &gt; '\176') buffer[i] = '-'; } return QString::fromLatin1(buffer.trimmed()); }</span></span></code> </pre> <br>  PVS-Studio-Warnung: V547 CWE-570 Ausdruck 'buffer [i] &lt;' \ 040 '&amp;&amp; buffer [i]&gt;' \ 176 '' ist immer falsch.  qedidparser.cpp 169 <br><br>  Die Funktion muss die folgende Aktion ausführen: "Nicht druckbare Zeichen durch Bindestrich ersetzen".  Sie tut es jedoch nicht.  Schauen wir uns diesen Zustand genauer an: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer[i] &lt; <span class="hljs-string"><span class="hljs-string">'\040'</span></span> &amp;&amp; buffer[i] &gt; <span class="hljs-string"><span class="hljs-string">'\176'</span></span>)</code> </pre> <br>  Es macht keinen Sinn.  Ein Zeichen darf nicht kleiner als '\ 040' und gleichzeitig größer als '\ 176' sein.  In der Bedingung müssen Sie den Operator '||' verwenden.  Der richtige Code lautet: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer[i] &lt; <span class="hljs-string"><span class="hljs-string">'\040'</span></span> || buffer[i] &gt; <span class="hljs-string"><span class="hljs-string">'\176'</span></span>)</code> </pre> <br>  <b>Defekt N72</b> <br><br>  Ein ähnlicher Fehler, aufgrund dessen Windows-Benutzer kein Glück haben. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(Q_OS_WIN) static QString driveSpec(const QString &amp;path) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (path.size() </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; 2) return QString(); char c = path.at(0).toLatin1(); if (c &lt; 'a' &amp;&amp; c &gt; 'z' &amp;&amp; c &lt; 'A' &amp;&amp; c &gt; 'Z') return QString(); if (path.at(1).toLatin1() != ':') return QString(); return path.mid(0, 2); } #endif</span></span></span></span></code> </pre> <br>  Der Analysator generiert zwei Warnungen gleichzeitig: <br><br><ul><li>  V590 CWE-571 Überprüfen Sie den Ausdruck 'c &lt;' a '&amp;&amp; c&gt;' z '&amp;&amp; c &lt;' A '&amp;&amp; c&gt;' Z ''.  Der Ausdruck ist übertrieben oder enthält einen Druckfehler.  qdir.cpp 77 </li><li>  V560 CWE-570 Ein Teil des bedingten Ausdrucks ist immer falsch: c&gt; 'z'.  qdir.cpp 77 </li></ul><br>  Ein logischer Fehler ist in der Bedingung: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &lt; <span class="hljs-string"><span class="hljs-string">'a'</span></span> &amp;&amp; c &gt; <span class="hljs-string"><span class="hljs-string">'z'</span></span> &amp;&amp; c &lt; <span class="hljs-string"><span class="hljs-string">'A'</span></span> &amp;&amp; c &gt; <span class="hljs-string"><span class="hljs-string">'Z'</span></span>)</code> </pre> <br>  So wie ich es verstehe, wollte der Programmierer ein Zeichen finden, das kein Buchstabe des lateinischen Alphabets ist.  In diesem Fall sollte die Bedingung folgendermaßen aussehen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((c &lt; <span class="hljs-string"><span class="hljs-string">'a'</span></span> || c &gt; <span class="hljs-string"><span class="hljs-string">'z'</span></span>) &amp;&amp; (c &lt; <span class="hljs-string"><span class="hljs-string">'A'</span></span> || c &gt; <span class="hljs-string"><span class="hljs-string">'Z'</span></span>))</code> </pre> <br>  <b>Defekt N73</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> SelectionMode { NoSelection, SingleSelection, MultiSelection, ExtendedSelection, ContiguousSelection }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QAccessibleTableCell::unselectCell() { QAbstractItemView::SelectionMode selectionMode = view-&gt;selectionMode(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_index.isValid() || (selectionMode &amp; QAbstractItemView::NoSelection)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; .... }</code> </pre> <br>  PVS-Studio Warnung: V616 CWE-480 Die benannte Konstante 'QAbstractItemView :: NoSelection' mit dem Wert 0 wird in der bitweisen Operation verwendet.  itemviews.cpp 976 <br><br>  Die benannte Konstante <i>QAbstractItemView :: NoSelection</i> ist Null.  Daher ist der Unterausdruck <i>(selectionMode &amp; QAbstractItemView :: NoSelection)</i> nicht sinnvoll.  Es wird immer 0 sein. <br><br>  Ich denke, es sollte hier geschrieben werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_index.isValid() || (selectionMode == QAbstractItemView::NoSelection))</code> </pre> <br>  <b>Defekt N74</b> <br><br>  Der folgende Code ist für mich schwer zu verstehen.  Er liegt falsch, aber ich weiß nicht, was er sein soll.  Das Kommentieren einer Funktion hilft mir auch nicht. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Re-engineered from the inline function _com_error::ErrorMessage(). // We cannot use it directly since it uses swprintf_s(), which is not // present in the MSVCRT.DLL found on Windows XP (QTBUG-35617). static inline QString errorMessageFromComError(const _com_error &amp;comError) { TCHAR *message = nullptr; FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, DWORD(comError.Error()), MAKELANGID(LANG_NEUTRAL,SUBLANG_DEFAULT), message, 0, NULL); if (message) { const QString result = QString::fromWCharArray(message).trimmed(); LocalFree(static_cast&lt;HLOCAL&gt;(message)); return result; } if (const WORD wCode = comError.WCode()) return QString::asprintf("IDispatch error #%u", uint(wCode)); return QString::asprintf("Unknown error 0x0%x", uint(comError.Error())); }</span></span></code> </pre> <br>  PVS-Studio Warnung: V547 CWE-570 Der Ausdruck 'message' ist immer falsch.  qwindowscontext.cpp 802 <br><br>  Der Programmierer geht wahrscheinlich davon aus, dass die <i>FormatMessage-</i> Funktion den Wert des <i>Nachrichtenzeigers</i> ändert.  Aber das ist nicht so.  Die <i>FormatMessage-Funktion</i> kann den Wert eines Zeigers nicht ändern, da er als Wert an die Funktion übergeben wird.  Hier ist ein Prototyp dieser Funktion: <br><br><pre> <code class="cpp hljs">DWORD __<span class="hljs-function"><span class="hljs-function">stdcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormatMessageW</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments )</span></span></span></span>;</code> </pre> <br><br><h2>  Mögliche Speicherlecks </h2><br>  <b>Defekt N75-N92</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SourceDependChildren</span></span></span><span class="hljs-class"> {</span></span> SourceFile **children; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num_nodes, used_nodes; SourceDependChildren() : children(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>), num_nodes(<span class="hljs-number"><span class="hljs-number">0</span></span>), used_nodes(<span class="hljs-number"><span class="hljs-number">0</span></span>) { } ~SourceDependChildren() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (children) <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(children); children = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addChild</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SourceFile *s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(num_nodes &lt;= used_nodes) { num_nodes += <span class="hljs-number"><span class="hljs-number">200</span></span>; children = (SourceFile**)<span class="hljs-built_in"><span class="hljs-built_in">realloc</span></span>(children, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SourceFile*)*(num_nodes)); } children[used_nodes++] = s; } };</code> </pre> <br>  PVS-Studio-Warnung: V701 CWE-401 realloc () mögliches Leck: Wenn realloc () beim Zuweisen von Speicher fehlschlägt, geht der ursprüngliche Zeiger 'Kinder' verloren.  Ziehen Sie in Betracht, einem temporären Zeiger realloc () zuzuweisen.  makefiledeps.cpp 103 <br><br>  Die Puffererweiterung wird auf gefährliche Weise implementiert.  Wenn die <i>Realloc-</i> Funktion keinen Speicher zuweisen kann, wird <i>NULL zurückgegeben</i> .  Dieser <i>NULL-</i> Wert wird sofort in die <i>untergeordnete</i> Variable eingefügt, und es besteht keine Möglichkeit, den zuvor zugewiesenen Puffer irgendwie freizugeben.  Ein Speicherverlust tritt auf. <br><br>  Ähnliche Fehler: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">qt-701.txt</a> . <br><br><h2>  Verschiedenes </h2><br>  <b>Defekt N93</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GradientBase</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BlendType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inline</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BlendType</span></span></span><span class="hljs-class"> * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QT_FASTCALL</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">qt_fetch_linear_gradient_template</span></span></span><span class="hljs-class">(....) {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t+inc*length &lt; qreal(INT_MAX &gt;&gt; (FIXPT_BITS + <span class="hljs-number"><span class="hljs-number">1</span></span>)) &amp;&amp; t+inc*length &gt; qreal(INT_MIN &gt;&gt; (FIXPT_BITS + <span class="hljs-number"><span class="hljs-number">1</span></span>))) { .... }</code> </pre> <br>  PVS-Studio Warnung: V610 CWE-758 Nicht angegebenes Verhalten.  Überprüfen Sie den Schaltoperator '&gt;&gt;'.  Der linke Operand '(- 2147483647 - 1)' ist negativ.  qdrawhelper.cpp 4015 <br><br>  Der negative Wert von <i>INT_MIN</i> kann nicht verschoben werden.  Dies ist ein nicht angegebenes Verhalten, und Sie können sich nicht auf das Ergebnis einer solchen Operation verlassen.  Die höchstwertigen Bits können gleich 0 oder 1 sein. <br><br>  <b>Defekt N94</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QObjectPrivate::addConnection(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> signal, Connection *c) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (signal &gt;= connectionLists-&gt;count()) connectionLists-&gt;resize(signal + <span class="hljs-number"><span class="hljs-number">1</span></span>); ConnectionList &amp;connectionList = (*connectionLists)[signal]; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (signal &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... }</code> </pre> <br>  PVS-Studio Warnung: V781 CWE-129 Der Wert der Variablen 'signal' wird nach ihrer Verwendung überprüft.  Möglicherweise liegt ein Fehler in der Programmlogik vor.  Überprüfen Sie die Zeilen: 397, 413. qobject.cpp 397 <br><br>  Eine Prüfung <i>(Signal &lt;0)</i> zeigt an, dass der Wert des <i>Signalarguments</i> negativ sein kann.  Dieses Argument wurde jedoch zuvor zum Indizieren des Arrays verwendet.  Es stellt sich heraus, dass die Prüfung zu spät durchgeführt wird.  Das Programm wird bereits unterbrochen. <br><br>  <b>Defekt N95</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QXmlStreamWriterPrivate::finishStartElement(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> contents) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inEmptyElement) { write(<span class="hljs-string"><span class="hljs-string">"/&gt;"</span></span>); QXmlStreamWriterPrivate::Tag &amp;tag = tagStack_pop(); lastNamespaceDeclaration = tag.namespaceDeclarationsSize; lastWasStartElement = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { write(<span class="hljs-string"><span class="hljs-string">"&gt;"</span></span>); } inStartElement = inEmptyElement = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; lastNamespaceDeclaration = namespaceDeclarations.size(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hadSomethingWritten; }</code> </pre> <br>  PVS-Studio Warnung: V519 CWE-563 Der Variablen 'lastNamespaceDeclaration' werden zweimal nacheinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  Überprüfen Sie die Zeilen: 3188, 3194. qxmlstream.cpp 3194 <br><br>  Ich werde das Wesentliche des Fehlers hervorheben: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inEmptyElement) { lastNamespaceDeclaration = tag.namespaceDeclarationsSize; } lastNamespaceDeclaration = namespaceDeclarations.size();</code> </pre> <br>  <b>Defekt N96</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QRollEffect::scroll() { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentHeight != totalHeight) { currentHeight = totalHeight * (elapsed/duration) + (<span class="hljs-number"><span class="hljs-number">2</span></span> * totalHeight * (elapsed%duration) + duration) / (<span class="hljs-number"><span class="hljs-number">2</span></span> * duration); <span class="hljs-comment"><span class="hljs-comment">// equiv. to int((totalHeight*elapsed) / duration + 0.5) done = (currentHeight &gt;= totalHeight); } done = (currentHeight &gt;= totalHeight) &amp;&amp; (currentWidth &gt;= totalWidth); .... }</span></span></code> </pre> <br>  V519 CWE-563 Der Variablen 'done' werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  Überprüfen Sie die Zeilen: 509, 511. qeffects.cpp 511 <br><br>  Alles ist das gleiche wie im vorherigen Fall.  Beachten Sie die Variable <i>done</i> . <br><br><h2>  Fazit </h2><br>  Selbst wenn ich den Bericht oberflächlich durchgesehen habe, habe ich fast 100 Fehler geschrieben.  Ich bin mit den Ergebnissen von PVS-Studio zufrieden. <br><br>  Natürlich haben solche seltenen Codeprüfungen nichts mit der Verbesserung der Qualität und Zuverlässigkeit des Codes zu tun.  Sie demonstrieren nur die Fähigkeiten des Code-Analysators.  Statische Analysewerkzeuge sollten regelmäßig angewendet werden.  In diesem Fall reduzieren sie die Kosten für die Behebung von Fehlern und schützen Anwendungen vor vielen potenziellen Schwachstellen. <br><br>  Vielen Dank für Ihre Aufmerksamkeit.  Um über unsere neuen Veröffentlichungen auf dem Laufenden zu bleiben, lade ich Sie ein, einen unserer Kanäle zu abonnieren: <ol><li>  VK.com: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pvsstudio_rus</a> </li><li>  "Old School" RSS: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">viva64-blog-ru</a> </li><li>  Twitter: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@pvsstudio_rus</a> </li><li>  Instagram: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@pvsstudio_rus</a> </li><li>  Telegramm: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@pvsstudio_rus</a> </li></ol><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br>  Wenn Sie diesen Artikel einem englischsprachigen Publikum zugänglich machen möchten, verwenden Sie bitte den Link zur Übersetzung: Andrey Karpov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eine dritte Überprüfung von Qt 5 mit PVS-Studio</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426485/">https://habr.com/ru/post/de426485/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426475/index.html">Miya - Assistent vom Smartphone</a></li>
<li><a href="../de426477/index.html">Die ganze Wahrheit über RTOS. Artikel Nr. 15. Speicherpartitionen: Dienste und Datenstrukturen</a></li>
<li><a href="../de426479/index.html">Selbst gemachter Prüfstand für Motherboards</a></li>
<li><a href="../de426481/index.html">Hexagon Maps in Unity: Pfadfinder, Spielertrupps, Animationen</a></li>
<li><a href="../de426483/index.html">Einer, der Tesla überholt. Für profitabler</a></li>
<li><a href="../de426487/index.html">Testen Sie die Automatisierung von Grund auf neu. Teil 1</a></li>
<li><a href="../de426489/index.html">Über das Verhältnis von Primzahlen und irrationalen Zahlen</a></li>
<li><a href="../de426491/index.html">Sicherheitswoche 39: Zum Tod von Google+</a></li>
<li><a href="../de426493/index.html">Ständige Rabatte von Hostern für Besucher von VPS und VPS.today Search</a></li>
<li><a href="../de426495/index.html">Solo Designer. Wie man eine Karriere aufbaut, wenn man alleine arbeitet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>