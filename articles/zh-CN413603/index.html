<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🎤 🙌🏾 🚵🏾 Uber中的代码生成 🌲 🌈 ☕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我们每个人都做家务。 每个人都编写样板代码。 怎么了 自动化此过程并仅执行有趣的任务不是更好吗？ 如果您希望计算机为您完成此类工作，请阅读本文。 

  

 本文基于Uber移动应用程序开发人员Zack Sweers在2017年MBLT DEV会议上发表的报告的笔录 。 
 
 Uber拥有大约3...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Uber中的代码生成</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/e-Legion/blog/413603/"> 我们每个人都做家务。 每个人都编写样板代码。 怎么了 自动化此过程并仅执行有趣的任务不是更好吗？ 如果您希望计算机为您完成此类工作，请阅读本文。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/144/cb5/052/144cb5052ca1830f2aac609dc3cc93c0.jpg" alt="图片"></a> <br><br>  <i>本文基于Uber移动应用程序开发人员Zack Sweers在2017年<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MBLT DEV</a>会议上发表的报告的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">笔录</a> 。</i> <i><br></i> <br><a name="habracut"></a>  Uber拥有大约300个移动应用程序开发人员。 我在一个称为“移动平台”的团队中工作。 我团队的工作是尽可能简化和改善开发移动应用程序的过程。 我们主要研究内部框架，库，体系结构等。 由于人员众多，我们必须执行工程师将来需要的大型项目。 可能是明天，或者下个月甚至是一年。 <br><br><h3> 自动化代码生成 </h3><br> 我想证明代码生成过程的价值，并考虑一些实际示例。 该过程本身看起来像这样： <br><br><pre><code class="hljs python">FileSpec.builder(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"Presentation"</span></span>) .addComment(<span class="hljs-string"><span class="hljs-string">"Code generating your way to happiness."</span></span>) .addAnnotation(AnnotationSpec.builder(Author::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">) .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">addMember</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-class"><span class="hljs-params"><span class="hljs-string">"name"</span></span></span></span><span class="hljs-class"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-class"><span class="hljs-params"><span class="hljs-string">"%S"</span></span></span></span><span class="hljs-class"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-class"><span class="hljs-params"><span class="hljs-string">"Zac Sweers"</span></span></span></span><span class="hljs-class"><span class="hljs-params">)</span></span></span><span class="hljs-class"> .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">useSiteTarget</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(FILE)</span></span></span><span class="hljs-class"> .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span><span class="hljs-class">) .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span></span></code> </pre> <br> 这是使用Kotlin Poet的示例。  Kotlin Poet是一个具有良好API的库，可以生成Kotlin代码。 那么我们在这里看到什么？ <br><br><ol><li>  <b>FileSpec.builder</b>创建一个名为“ <b>Presentation</b> ”的文件。 </li><li>  <b>.addComment（）</b> -在生成的代码中添加注释。 </li><li>  <b>.addAnnotation（）</b> -添加类型为<b>Author</b>的注释。 </li><li>  <b>.addMember（）</b> -在参数中添加一个变量“ <b>name</b> ”，在我们的例子中是“ <b>Zac Sweers</b> ”。  <b>％S-</b>参数类型。 </li><li>  <b>.useSiteTarget（）</b> -安装SiteTarget。 </li><li>  <b>.build（）</b> -完成将要生成的代码的描述。 </li></ol><br> 代码生成后，将获得以下内容： <br><br><pre> <code class="hljs pgsql">Presentation.kt // Code generating your way <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> happiness. @file:Author(<span class="hljs-type"><span class="hljs-type">name</span></span> = "Zac Sweers")</code> </pre> <br> 代码生成的结果是一个包含名称，注释，注释和作者姓名的文件。 问题立即浮出水面：“如果可以通过几个简单的步骤完成代码，为什么我需要生成此代码？” 是的，您是对的，但是如果我需要一千个具有不同配置选项的文件怎么办？ 如果我们开始更改此代码中的值会怎样？ 如果我们有很多演讲，该怎么办？ 如果我们有很多会议怎么办？ <br><br><pre> <code class="hljs pgsql">conferences .flatMap { it.presentations } .onEach { (presentationName, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>, author) -&gt; FileSpec.builder("", presentationName) .addComment(<span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>) .addAnnotation(AnnotationSpec.builder(Author::<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>) .addMember("name", "%S", author) .useSiteTarget(FILE) .build()) .build() }</code> </pre><br> 结果，我们得出的结论是，根本不可能手动维护这么多文件，而必须实现自动化。 因此，代码生成的第一个优点是摆脱了常规工作。 <br><br><h3> 无错误代码生成 </h3><br> 自动化的第二个重要优点是无错误操作。 所有人都会犯错。 当我们做同样的事情时，这种情况尤其经常发生。 相反，计算机可以完美地完成这项工作。 <br><br> 考虑一个简单的例子。 有一个Person类： <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String)</code> </pre><br> 假设我们要在JSON中为其添加序列化。 我们将使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b>Moshi</b></a>库来执行此操作，因为它非常简单并且非常适合演示。 创建一个PersonJsonAdapter并从Person类型的参数继承自JsonAdapter： <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonJsonAdapter</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">JsonAdapter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Person</span></span></span><span class="hljs-class">&gt;</span></span>() { }</code> </pre><br> 接下来，我们实现fromJson方法。 它为读者提供了阅读信息的方法，这些信息最终将返回给Person。 然后，我们用名字和姓氏填写字段，并获得新值Person： <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonJsonAdapter</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">JsonAdapter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Person</span></span></span><span class="hljs-class">&gt;</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromJson</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reader: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">JsonReader</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Person? { <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstName: String <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastName: String <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Person(firstName, lastName) } }</code> </pre><br> 接下来，我们查看JSON格式的数据，对其进行检查并将其输入必要的字段中： <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonJsonAdapter</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">JsonAdapter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Person</span></span></span><span class="hljs-class">&gt;</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromJson</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reader: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">JsonReader</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Person? { <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstName: String <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastName: String <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (reader.hasNext()) { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (reader.nextName()) { <span class="hljs-string"><span class="hljs-string">"firstName"</span></span> -&gt; firstName = reader.nextString() <span class="hljs-string"><span class="hljs-string">"lastName"</span></span> -&gt; lastName = reader.nextString() } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Person(firstName, lastName) } }</code> </pre><br> 这样行吗？ 是的，但是有一个细微差别：我们读取的对象必须包含在JSON中。 为了过滤掉可能来自服务器的多余数据，请添加另一行代码： <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonJsonAdapter</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">JsonAdapter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Person</span></span></span><span class="hljs-class">&gt;</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromJson</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reader: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">JsonReader</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Person? { <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstName: String <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastName: String <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (reader.hasNext()) { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (reader.nextName()) { <span class="hljs-string"><span class="hljs-string">"firstName"</span></span> -&gt; firstName = reader.nextString() <span class="hljs-string"><span class="hljs-string">"lastName"</span></span> -&gt; lastName = reader.nextString() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; reader.skipValue() } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Person(firstName, lastName) } }</code> </pre><br> 至此，我们成功绕过了常规代码领域。 在此示例中，只有两个值字段。 但是，此代码有很多不同的部分，您可能会在其中突然崩溃。 突然我们在代码中出错了？ <br><br> 考虑另一个示例： <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">City</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> country: String) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vehicle</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> licensePlate: String) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Restaurant</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> type: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> address: Address) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Payment</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardNumber: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> type: String) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TipAmount</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> value: <span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rating</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numStars: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Correctness</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> confidence: <span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>)</code> </pre><br> 如果每10个型号左右至少有一个问题，那么这意味着您肯定会在这方面遇到困难。 在这种情况下，代码生成确实可以为您提供帮助。 如果课程很多，那么没有自动化就无法工作，因为所有人都允许输入错误。 借助代码生成，所有任务将自动执行且没有错误。 <br><br> 代码生成还有其他好处。 例如，它给出有关代码的信息或告诉您是否出了问题。 在测试阶段，代码生成将非常有用。 如果使用生成的代码，则可以看到工作代码的真实外观。 您甚至可以在测试期间运行代码生成，以简化工作。 <br><br> 结论：值得考虑的是代码生成可以解决错误。 <br><br> 现在，让我们看一下有助于代码生成的软件工具。 <br><br><h3> 工具 </h3><br><ol><li> 分别用于Java和Kotlin的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b>JavaPoet</b></a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b>KotlinPoet库</b></a> 。 这些是代码生成的标准。 </li><li> 模式化。 一个流行的Java模板示例是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b>Apache Velocity</b></a>和iOS的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b>Handlebars</b></a> 。 </li><li>  <b>SPI-</b>服务处理器接口。 它内置于Java中，允许您创建和应用接口，然后在JAR中声明它。 执行程序后，您可以获取接口的所有现成实现。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b>编译测试</b></a>是Google提供的一个库，可帮助进行编译测试。 在代码生成方面，这意味着：“这是我所期望的，但是这是我最终得到的。” 编译将在内存中开始，然后系统将告诉您此过程是否已完成或发生了什么错误。 如果编译已完成，将要求您将结果与您的期望进行比较。 比较是基于编译后的代码，因此不必担心诸如代码格式之类的事情。 </li></ol><br><h3> 代码构建工具 </h3><br> 有两个主要的代码构建工具： <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b>注释处理</b></a> -您可以在代码中编写注释，并向程序询问有关它们的其他信息。 编译器甚至会在完成源代码处理之前就给出信息。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b>Gradle</b></a>是一个应用程序组装系统，在其代码组装生命周期中具有许多钩子（钩子-函数调用的拦截）。 它被广泛用于Android开发中。 它还允许您将代码生成应用于源代码，而与当前源代码无关。 </li></ol><br> 现在考虑一些示例。 <br><br><h3> 牛油刀 </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b>黄油刀</b></a>是杰克·沃顿（Jake Wharton）开发的图书馆。 他是开发人员社区中的知名人物。 该库在Android开发人员中非常受欢迎，因为它有助于避免几乎每个人都面临的大量例行工作。 <br><br> 通常我们以这种方式初始化视图： <br><br><pre> <code class="java hljs">TextView title; ImageView icon; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ title = findViewById(R.id.title); icon = findViewById(R.id.icon); }</code> </pre><br> 使用Butterknife，它将看起来像这样： <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.title) TextView title; <span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.icon) ImageView icon; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ ButterKnife.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre><br> 我们可以轻松地添加任意数量的视图，而onCreate方法不会增加样板代码： <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.title) TextView title; <span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.text) TextView text; <span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.icon) ImageView icon; <span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.button) Button button; <span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.next) Button next; <span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.back) Button back; <span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.open) Button open; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ ButterKnife.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre><br> 您不必每次都手动进行绑定，只需将@BindView批注以及为其分配的标识符（ID）添加到这些字段即可。 <br><br>  Butter Knife的有趣之处在于它将分析代码并生成与您相​​似的所有部分。 它还具有出色的新数据可伸缩性。 因此，如果出现新数据，则无需再次应用onCreate或手动跟踪某些内容。 该库也非常适合删除数据。 <br><br> 那么，从内部看，这个系统是什么样的呢？ 通过代码识别搜索视图，然后在注释处理阶段执行此过程。 <br><br> 我们有这个领域： <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.title) TextView title;</code> </pre><br> 从这些数据来看，它们用于特定的FooActivity中： <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// FooActivity @BindView(R.id.title) TextView title;</span></span></code> </pre><br> 她有自己的意思（R.id.title），它是目标。 请注意，在数据处理过程中，该对象在系统内部变为常数： <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// FooActivity @BindView(2131361859) TextView title;</span></span></code> </pre><br> 这很正常。 无论如何，这就是黄油刀应该使用的东西。 有一个TextView组件作为一种类型。 该字段本身称为标题。 例如，如果我们从此数据中创建一个容器类，则会得到如下所示的内容： <br><br><pre> <code class="java hljs">ViewBinding( target = <span class="hljs-string"><span class="hljs-string">"FooActivity"</span></span>, id = <span class="hljs-number"><span class="hljs-number">2131361859</span></span>, name = <span class="hljs-string"><span class="hljs-string">"title"</span></span>, type = <span class="hljs-string"><span class="hljs-string">"field"</span></span>, viewType = TextView.class )</code> </pre><br> 因此，可以在处理过程中轻松获得所有这些数据。 它也与黄油刀在系统内部的操作非常相似。 <br><br> 结果，该类在这里生成： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooActivity_ViewBinding</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Unbinder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FooActivity target; <span class="hljs-meta"><span class="hljs-meta">@UiThread</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FooActivity_ViewBinding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FooActivity target, View source)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.target = target; target.title = Utils.findRequiredViewAsType(source, <span class="hljs-number"><span class="hljs-number">2131361859</span></span>, <span class="hljs-comment"><span class="hljs-comment">// R.id.title "field 'title'", TextView.class); } }</span></span></code> </pre><br> 在这里，我们看到所有这些数据都收集在一起。 结果，我们有了Underscore Java库中的ViewBinding目标类。 在内部，该系统的排列方式是每次创建类的实例时，它将立即对您生成的信息（代码）进行所有绑定。 所有这些都是在注释处理期间以前静态生成的，这意味着它在技术上是正确的。 <br><br> 让我们回到我们的软件管道： <br><br><img src="https://habrastorage.org/webt/t3/d3/jv/t3d3jv5bxgx5q3occc3ldovxfjm.png"><br><br> 在注释处理期间，系统读取这些注释并生成ViewBinding类。 然后在bind方法期间，我们以一种简单的方式对相同的类执行相同的搜索：我们取其名称并在末尾附加ViewBinding。 就其本身而言，使用JavaPoet在指定区域中覆盖在处理过程中具有ViewBinding的部分。 <br><br><h3> 绑定 </h3><br>  RxBindings本身不负责代码生成。 它不处理注释，也不是Gradle插件。 这是一个普通的库。 它为Android API提供了基于反应式编程原理的静态工厂。 这意味着，例如，如果您有setOnClickListener，则将出现一个click方法，该方法将返回（可观察的）事件流。 它充当桥梁（设计模式）。 <br><br> 但是实际上RxBinding中存在代码生成： <br><br><img src="https://habrastorage.org/webt/ju/ty/bv/jutybv1ayxqhcfrs9l4virsivb8.png"><br><br> 在名为buildSrc的目录中，有一个名为KotlinGenTask的Gradle任务。 这意味着所有这些实际上都是通过代码生成来创建的。  RxBinding具有Java实现。 她还拥有Kotlin工件，其中包含所有目标类型的扩展功能。 所有这些都严格遵守规则。 例如，您可以生成所有Kotlin扩展功能，而不必单独控制它们。 <br><br> 它到底是什么样的？ <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Observable&lt;Object&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clicks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(View view)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ViewClickObservable(view); }</code> </pre><br> 这是一个完全经典的RxBinding方法。 此处返回可观察对象。 该方法称为点击。 使用点击事件是在“幕后”进行的。 我们忽略了多余的代码片段，以保持示例的可读性。 在Kotlin中，它看起来像这样： <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clicks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Observable&lt;Object&gt; = RxView.clicks(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)</code> </pre><br> 此扩展函数返回Observable对象。 在程序的内部结构中，它直接为我们调用了通常的Java接口。 在Kotlin中，您必须将其更改为Unit type： <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clicks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Observable&lt;<span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>&gt; = RxView.clicks(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)</code> </pre><br> 也就是说，在Java中，它看起来像这样： <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Observable&lt;Object&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clicks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(View view)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ViewClickObservable(view); }</code> </pre><br>  Kotlin代码也是如此： <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clicks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Observable&lt;<span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>&gt; = RxView.clicks(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)</code> </pre><br> 我们有一个包含此方法的RxView类。 我们可以将目标属性，名称属性中的相应数据替换为方法的名称，所扩展的类型以及返回值的类型。 所有这些信息将足以开始编写以下方法： <br><br><pre> <code class="hljs pgsql">BindingMethod( target = "RxView", <span class="hljs-type"><span class="hljs-type">name</span></span> = "clicks", <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">View</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, returnType = "Observable&lt;Unit&gt;" )</code> </pre><br> 现在，我们可以将这些片段直接替换为程序内部生成的Kotlin代码。 结果如下： <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clicks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Observable&lt;<span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>&gt; = RxView.clicks(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)</code> </pre><br><h3> 服务代 </h3><br> 我们正在Uber开发ServiceGen。 如果您在公司工作并且处理后端和客户端的通用特征和通用软件接口，则无论您是开发Android，iOS还是Web应用程序，手动创建模型和服务都没有意义。团队合作。 <br><br> 我们将Google的<a href=""><b>AutoValue</b></a>库用于对象模型。 它处理注释，分析数据并生成两行哈希码，equals（）方法和其他实现。 她还负责支持扩展。 <br><br> 我们有一个Rider类型的对象： <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@AutoValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uuid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">firstName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lastName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> Address </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br> 我们具有ID，名字，姓氏和地址的行。 为了使用网络，我们使用Retrofit和OkHttp库，以及JSON作为数据格式。 我们还将RxJava用于响应式编程。 这就是我们生成的API服务的样子： <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UberService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@GET(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/rider"</span></span></span><span class="hljs-meta">)</span></span> Rider getRider() }</code> </pre><br> 如果愿意，我们可以手动编写所有这些内容。 长期以来，我们做到了。 但是需要很多时间。 最后，它花费了很多时间和金钱。 <br><br><h3> 优步今天的工作方式 </h3><br> 我团队的最后一个任务是从头开始创建文本编辑器。 我们决定不再手动编写随后进入网络的代码，因此我们使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b>Thrift</b></a> 。 它既像编程语言，又像协议。  Uber使用Thrift作为技术规范的语言。 <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">required</span></span> string uuid; <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">required</span></span> string firstName; <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">required</span></span> string lastName; <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">optional</span></span> <span class="hljs-type"><span class="hljs-type">Address</span></span> address; }</code> </pre><br> 在Thrift中，我们在后端和客户端之间定义API合同，然后简单地生成适当的代码。 我们使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b>Thrifty</b></a>库解析数据，并使用JavaPoet生成代码。 最后，我们使用AutoValue生成实现： <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@AutoValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uuid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">firstName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lastName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> Address </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br> 我们用JSON完成所有工作。 有一个名为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b>AutoValue Moshi</b></a>的扩展，可以使用静态jsonAdapter方法将其添加到AutoValue类中： <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@AutoValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uuid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">firstName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lastName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> Address </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> JsonAdapter&lt;Rider&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jsonAdapter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Moshi moshi)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AutoValue_Rider.JsonAdapter(moshi); } }</code> </pre> <br> 节俭还有助于服务的发展： <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">service</span></span> UberService { <span class="hljs-attribute"><span class="hljs-attribute">Rider</span></span> getRider() }</code> </pre><br> 我们还必须在此处添加一些元数据，以使我们知道想要达到的最终结果： <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">service</span></span> UberService { <span class="hljs-attribute"><span class="hljs-attribute">Rider</span></span> getRider() (path=<span class="hljs-string"><span class="hljs-string">"/rider"</span></span>) }</code> </pre><br> 代码生成后，我们将获得我们的服务： <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UberService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@GET</span></span>(<span class="hljs-string"><span class="hljs-string">"/rider"</span></span>) <span class="hljs-function"><span class="hljs-function">Single&lt;Rider&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRider</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br> 但这只是可能的结果之一。 一种模式。 我们从经验中知道，没有人曾经只使用过一种模型。 我们有许多模型可以为我们的服务生成代码： <br><br><pre> <code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rider</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">City</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vehicle</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Restaurant</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Payment</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TipAmount</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rating</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">// And 6000 more</span></span></code> </pre><br> 目前，我们大约有5-6个应用程序。 他们有很多服务。 每个人都经过相同的软件管道。 用手写下所有这些都是疯狂的。 <br><br> 在JSON序列化中，不需要在Moshi中注册“适配器”，并且如果您使用JSON，则无需在JSON中注册。 建议员工通过DI图重写代码来进行反序列化也是可疑的。 <br><br> 但是我们使用Java，所以我们可以使用通过<b>Fractory</b>库生成的Factory模式。 之所以可以生成它，是因为在编译发生之前我们已经知道了这些类型。  Fractory生成这样的适配器： <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModelsAdapterFactory</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonAdapter</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Factory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> JsonAdapter&lt;?&gt; create(Type type, Set&lt;? extends Annotation&gt; annotations, Moshi moshi) { Class&lt;?&gt; rawType = Types.getRawType(type); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rawType.isAssignableFrom(Rider.class)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Rider.adapter(moshi); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rawType.isAssignableFrom(City.class)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> City.adapter(moshi); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rawType.isAssignableFrom(Vehicle.class)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vehicle.adapter(moshi); } <span class="hljs-comment"><span class="hljs-comment">// Etc etc return null; } }</span></span></code> </pre><br> 生成的代码看起来不太好。 如果伤到眼睛，可以手动重写。 <br><br> 在这里，您可以看到前面提到的带有服务名称的类型。 系统将自动确定要选择并调用的适配器。 但是这里我们面临另一个问题。 我们有6000个这些适配器。 即使您在同一模板中将它们分开，“ Eats”或“ Driver”模型也将属于“ Rider”模型或将在其应用程序中使用。 代码将伸展。 经过一定时间后，它甚至无法放入.dex文件中。 因此，您需要以某种方式分离适配器： <br><br><img src="https://habrastorage.org/webt/ds/ul/tg/dsultg8mrgkboye3dvwmfcepdou.png"><br><br> 最终，我们将预先分析代码并为其创建一个工作子项目，如Gradle中所示： <br><br><img src="https://habrastorage.org/webt/-4/pj/fz/-4pjfzwuq-cwmdl8lil_cia4-pi.png"><br><br> 在内部结构中，这些依赖性成为Gradle依赖性。 现在，使用Rider应用程序的元素依赖于它。 有了它，他们将形成所需的模型。 结果，我们的任务将得到解决，所有这些将由程序中的代码汇编系统进行调节。 <br><br> 但是这里我们面临另一个问题：现在我们有n个工厂模型。 它们都被编译成各种对象： <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> RiderModelFactory <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> GiftCardModelFactory <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PricingModelFactory <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> DriverModelFactory <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> EATSModelFactory <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PaymentsModelFactory</code> </pre><br> 在处理批注的过程中，将无法仅读取外部依赖项的批注，而仅对其进行附加代码生成。 <br><br> 解决方案：Fractory库中有一些支持，这以一种棘手的方式为我们提供了帮助。 它包含在数据绑定过程中。 我们使用Java归档文件中的classpath参数引入元数据以进一步存储它们： <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> RiderModelFactory // -&gt; <span class="hljs-type"><span class="hljs-type">json</span></span> // -&gt; ridermodelfactory-fractory.bin <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyAppGlobalFactory // Delegates <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> discovered fractories</code> </pre><br> 现在，每次您需要在应用程序中使用它们时，我们都会使用这些文件进入类路径目录的过滤器，然后以JSON格式从那里提取它们，以找出哪些依赖项可用。 <br><br><h3> 它们如何融合在一起 </h3><br><br><img src="https://habrastorage.org/webt/ih/nj/7i/ihnj7i5j631gcjbkgt-8u64h7l8.jpeg"><br><br> 我们有<b>节俭</b> 。 来自那里的数据进入<b>Thrifty</b>并进行解析。 然后，他们通过一个称为<b>Jenga</b>的代码生成程序。 它产生Java格式的文件。 所有这些都发生在处理的初级阶段或编译之前。 并在编译过程中处理注释。 现在该轮到<b>AutoValue</b>生成一个实现了。 它还调用<b>AutoValue Moshi</b>以提供JSON支持。  <b>分形</b>也<b>参与其中</b> 。 一切都在编译过程中发生。 该过程之前是用于创建项目本身的组件，该组件主要生成<b>Gradle</b>子项目。 <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在您已经看到了全貌，您开始注意到前面提到的工具。</font><font style="vertical-align: inherit;">因此，例如，有Gradle，用于创建代码的模板，AutoValue，JavaPoet。</font><font style="vertical-align: inherit;">所有工具不仅可以单独使用，而且可以相互结合使用。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 代码生成的缺点 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有必要告诉陷阱。</font><font style="vertical-align: inherit;">最明显的减号是使代码膨胀并使它失去控制。</font><font style="vertical-align: inherit;">例如，Dagger占用了应用程序中所有代码的大约10％。</font><font style="vertical-align: inherit;">模型占据了很大的份额-约25％。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Uber，我们尝试通过丢弃不必要的代码来解决问题。</font><font style="vertical-align: inherit;">我们必须对代码进行一些统计分析，并了解工作中真正涉及哪些领域。</font><font style="vertical-align: inherit;">找到答案后，我们可以进行一些转换，看看会发生什么。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们希望将生成的模型数量减少约40％。</font><font style="vertical-align: inherit;">这将有助于加快应用程序的安装和运行，并为我们节省资金。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 代码生成如何影响项目开发时间表 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当然，代码生成可以加快开发速度，但是时间取决于团队使用的工具。</font><font style="vertical-align: inherit;">例如，如果您在Gradle中工作，则很可能您正在以一定的步调进行操作。</font><font style="vertical-align: inherit;">事实是Gradle每天生成一次模型，而不是在开发人员想要的时候生成模型。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 了解有关Uber和其他顶级公司发展的更多信息。 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9月28日，第五届移动开发商</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MBLT DEV</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">国际会议在莫斯科举行</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">800位参与者，顶尖演讲者，测验和拼图，供那些对Android和iOS开发感兴趣的人使用。</font><font style="vertical-align: inherit;">会议的组织者是e-Legion和RAEC。</font><font style="vertical-align: inherit;">您可以</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">在会议网站上</font></a><font style="vertical-align: inherit;">成为MBLT DEV 2018的参与者或合作伙伴</font><font style="vertical-align: inherit;">。</font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=http://"><img src="https://habrastorage.org/webt/yr/u2/x0/yru2x0-bqpghfoa6zqfrkyluuhq.jpeg"></a> <br><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 举报视频 </font></font></h3><br><iframe width="560" height="315" src="https://www.youtube.com/embed/GpMR_Zjnn_Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN413603/">https://habr.com/ru/post/zh-CN413603/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN413591/index.html">工业机器人-57年！ 回顾计数的来源</a></li>
<li><a href="../zh-CN413593/index.html">继续征服海底。 微软及其Natick 2海底数据中心项目</a></li>
<li><a href="../zh-CN413597/index.html">“最后手段”或为什么需要数据库优先设计</a></li>
<li><a href="../zh-CN413599/index.html">部分有S.L.O.N.a。 介绍ITAM而不是扼杀</a></li>
<li><a href="../zh-CN413601/index.html">微软的数据中心会不会给大海带来麻烦</a></li>
<li><a href="../zh-CN413605/index.html">问伊森：当一颗恒星穿过太阳系会发生什么？</a></li>
<li><a href="../zh-CN413607/index.html">金融科技摘要：数字货币不会威胁俄罗斯联邦的金融系统； 贝宝发现游戏玩家在游戏上花费了多少</a></li>
<li><a href="../zh-CN413609/index.html">冒名顶替综合症：这是什么以及如何摆脱它</a></li>
<li><a href="../zh-CN413611/index.html">闭路电视如何攻击正面黑客日：CAMBreaker竞赛</a></li>
<li><a href="../zh-CN413613/index.html">这艘飞船将比太阳之前的任何事物都更靠近太阳，并且不会融化</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>