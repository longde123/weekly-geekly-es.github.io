<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§æ üë©üèº‚Äçüíº üë©üèø‚Äçüíª Historial de parches de Apple üòÜ üëÅ‚Äçüó® üçÉ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este a√±o, a1exdandy y yo hablamos en las conferencias de VolgaCTF y KazHackStan con una charla sobre los programas Patch Diffing escritos en Objective...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Historial de parches de Apple</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/479972/"><p><img src="https://habrastorage.org/webt/wh/kp/c3/whkpc3ybatnoasln45yfqbbvrkc.jpeg" alt="imagen"></p><br><p>  Este a√±o, <a href="https://habr.com/ru/users/a1exdandy/" class="user_link">a1exdandy</a> y <a href="https://habr.com/ru/users/a1exdandy/" class="user_link">yo</a> hablamos en las conferencias de VolgaCTF y KazHackStan con una charla sobre los programas Patch Diffing escritos en Objective-C, y c√≥mo usarlo para buscar y encontrar vulnerabilidades de 0 d√≠as y 1 d√≠a en productos Apple.  Puede ver el video de la presentaci√≥n <a href="https://youtu.be/G1p0CVNxK28%3Ft%3D5191">aqu√≠</a> , y para leer el art√≠culo, bienvenido a cat. </p><a name="habracut"></a><br><p>  La Difusi√≥n Binaria es el proceso de comparar dos archivos ejecutables para encontrar similitudes y diferencias entre ellos.  Patch Diffing es un caso especial de Binary Diffing cuando un archivo con vulnerabilidad se compara con un archivo fijo (archivo con un parche).  Para que pueda averiguar qu√© correcciones ha realizado el desarrollador y comprender cu√°l fue la vulnerabilidad. </p><br><p>  Hace unos a√±os (es decir, en 2013), se <a href="https://xakep.ru/issues/xa/169/">public√≥ un art√≠culo</a> sobre Patch Diffing para programas de Windows, al que tambi√©n echamos una mano.  Le recomendamos que se familiarice con √©l si est√° interesado en este tema en relaci√≥n con el sistema operativo Windows.  En el mismo art√≠culo hablaremos sobre el an√°lisis de programas para Apple OS. </p><br><h2 id="chem-mogut-byt-polezny-binary-diffing-i-patch-diffing">  ¬øC√≥mo pueden ser √∫tiles la Difusi√≥n Binaria y la Difusi√≥n de Parche? </h2><br><p>  La tarea principal de Binary Diffing es rastrear qu√© cambios se han realizado en la aplicaci√≥n.  Para hacer esto, debe tomar la versi√≥n anterior y compararla con la nueva para ver qu√© cambios agreg√≥ el desarrollador y c√≥mo se implementan. </p><br><p>  Veamos situaciones en las que esto puede ser √∫til: </p><br><ul><li>  <strong>An√°lisis del desarrollo del programa</strong> : al comparar las versiones nuevas y antiguas, puede comprender c√≥mo se est√° desarrollando la aplicaci√≥n, qu√© nueva funcionalidad se agrega, qu√© se elimina y qu√© cambios ha sufrido el c√≥digo existente. </li><li>  <strong>Importar el conocimiento existente</strong> : en los programas que no usan informaci√≥n simb√≥lica, los ingenieros inversos tienen que pasar mucho m√°s tiempo estudiando la l√≥gica y buscando vulnerabilidades.  Pero sucede que en alguna versi√≥n del software, los desarrolladores dejan accidental o deliberadamente informaci√≥n simb√≥lica.  Esta informaci√≥n se puede transferir desde all√≠ a la versi√≥n de software que necesita.  <a href="https://googleprojectzero.blogspot.com/2019/10/the-story-of-adobe-reader-symbols.html">Por ejemplo</a> , los empleados de Google Project Zero que utilizaban la Difusi√≥n Binaria pudieron obtener caracteres para versiones nuevas de Windows de Adobe Reader de versiones anteriores para otros sistemas operativos, lo que les ayud√≥ a encontrar vulnerabilidades; </li><li> <strong>Capacitaci√≥n en software real</strong> : en nuestra opini√≥n, Patch Diffing es una excelente manera de pasar sin problemas de estudiar peque√±os problemas de CTF a investigar software real.  Al explorar el parche, puede ver la vulnerabilidad real en un gran producto de software con todas sus caracter√≠sticas (mientras sabe con certeza que la vulnerabilidad est√° presente en el c√≥digo).  Al explorar los errores en un producto, puede pasar gradualmente a encontrar las mismas vulnerabilidades.  Como beneficio adicional, puedes intentar escribir exploits para ellos; </li><li>  <strong>Creaci√≥n de exploits de 1 d√≠a</strong> : cuando un desarrollador ya ha lanzado un parche, puede analizarlo r√°pidamente, escribir un exploit para esta vulnerabilidad y obtener un exploit de 1 d√≠a.  Al mismo tiempo, existe el denominado Patch Gapping, el tiempo entre el lanzamiento del parche y su instalaci√≥n directa por parte de los clientes.  Durante este tiempo, un exploit de 1 d√≠a puede funcionar con √©xito y beneficiar a su autor (¬°instale actualizaciones de manera oportuna!) Hasta que todos instalen el parche lanzado por los desarrolladores.  Hay situaciones en las que se corrige una vulnerabilidad en una biblioteca, pero los programas a√∫n usan una versi√≥n desactualizada de la biblioteca.  Aqu√≠ hay algunos ejemplos interesantes de Patch Gapping para <a href="https://blog.exodusintel.com/2019/09/09/patch-gapping-chrome/">Chrome</a> y <a href="https://googleprojectzero.blogspot.com/2019/08/jsc-exploits.html">WebKit</a> ; </li><li>  <strong>Busque vulnerabilidades de 0 d√≠as</strong> : no importa cu√°n extra√±o pueda sonar esto, al analizar parches, tambi√©n puede encontrar vulnerabilidades previamente desconocidas (vulnerabilidades de 0 d√≠as).  Los desarrolladores tambi√©n se equivocan y, por lo tanto, en el proceso de creaci√≥n de un parche, la vulnerabilidad puede no cerrarse correctamente.  Entonces, al analizar un parche, puede encontrar una forma de evitarlo.  Por ejemplo, los desarrolladores de Apache Struts corrigieron una vulnerabilidad cinco veces, ¬°pero el parche solo funcion√≥ en su sexta versi√≥n!  Adem√°s, a menudo un desarrollador, que cumple claramente la tarea establecida para corregir una cierta vulnerabilidad, puede no darse cuenta de lo que sucede en las secciones vecinas del c√≥digo.  Podr√≠a haber exactamente la misma vulnerabilidad cerca, y en caso de detecci√≥n ser√° de 0 d√≠as.  Es importante estudiar el patr√≥n de un error de desarrollador detectado e intentar encontrar algo similar en el mismo programa.  Si el desarrollador cometi√≥ un error en un lugar, entonces la probabilidad de repetir el mismo error en otro lugar es alta. </li></ul><br><p>  Existe el mito de que ocultar la informaci√≥n del parche de vulnerabilidad aumenta la seguridad.  Sin embargo, los atacantes, como regla, ya han desarrollado infraestructura para analizar parches, por lo que encontrar√°n r√°pidamente los datos que les interesan.  Ocultar las vulnerabilidades complica el trabajo de los responsables de proteger el sistema, porque sin acceso total a la informaci√≥n es imposible comprender la importancia de este parche para la empresa.  Sobre este tema, le recomendamos que lea el art√≠culo <a href="http://addxorrol.blogspot.com/2019/08/rashomon-of-disclosure.html">"Rashomon de divulgaci√≥n"</a> del investigador Halvar Flake, donde se ve la situaci√≥n desde diferentes √°ngulos. </p><br><p>  No siempre se descubren vulnerabilidades ocultas intencionalmente.  Es posible que los desarrolladores no otorguen una importancia particular a algunas de las deficiencias de su producto y las solucionen sin publicidad, como un error com√∫n. </p><br><p>  Estamos seguros de que estas no son todas las situaciones en las que puede utilizar la Difusi√≥n binaria y la Difusi√≥n de parches, y en los comentarios puede escribir sus propios scripts. </p><br><h2 id="instrumentariy">  Kit de herramientas </h2><br><p>  De la teor√≠a pasamos gradualmente a la pr√°ctica.  Naturalmente, hacer Binary Diffing manualmente es una tarea loca.  Se ha desarrollado un extenso kit de herramientas que consta de programas independientes y complementos para analizadores binarios populares: Diaphora, BinDiff, DarunGrim, YaDiff, rizzo, Realyze, Turbodiff, patchdiff2, revancha y otros. </p><br><p><img src="https://habrastorage.org/webt/ek/ou/r0/ekour0t64vi9hsrnpnvpaqzra6e.png" alt="imagen"><br>  <em>Interfaz BinDiff.</em> </p><br><p><img src="https://habrastorage.org/webt/g_/q_/k1/g_q_k1bg4g_x858ps6k24ywuonk.png" alt="imagen"><br>  <em>Interfaz Diaphora</em> </p><br><p>  En la pr√°ctica, utilizamos principalmente solo los dos primeros (se presentan en las capturas de pantalla anteriores).  Lamentablemente, la mayor√≠a de las herramientas actuales no son alentadoras con la calidad del trabajo o est√°n completamente abandonadas.  Ahora hay nuevas herramientas que utilizan ML, pero su calidad deja mucho que desear, aunque tienen ideas interesantes para comparar archivos binarios de diferentes arquitecturas. </p><br><p>  Tambi√©n me gustar√≠a se√±alar por separado las herramientas recientemente aparecidas para comparar c√≥digo de c√≥digo abierto en archivos binarios: Pigaios y Karta.  Esta es una direcci√≥n muy interesante y √∫til.  Recopilan m√©tricas del c√≥digo fuente y luego las usan para comparar funciones en archivos binarios.  Esto es muy √∫til en ausencia de caracteres y enlaces est√°ticos.  La tarea de estas herramientas es asignar funciones en un archivo a funciones en otro. </p><br><h2 id="sravnenie-patchey-dlya-operacionnyh-sistem-apple">  Comparaci√≥n de parches para sistemas operativos Apple </h2><br><p>  Como regla general, las aplicaciones para Apple OS escriben en Objective-C.  Esta es una extensi√≥n orientada a objetos para C, basada en paradigmas de lenguaje Smalltalk con su propio tiempo de ejecuci√≥n. </p><br><p>  Si abrimos el programa en Objective-C en alg√∫n analizador binario (en nuestro caso, esto es un IDA), veremos algo como esto: las funciones en C / C ++ tendr√°n nombres abstractos, y las funciones en Objective-C se llamar√°n muy bien.  (Diremos de inmediato que no consideramos situaciones con ofuscaci√≥n de c√≥digo; esta es una historia separada). Esto facilita la ingenier√≠a inversa: es f√°cil ver qu√© objeto se llama, qu√© m√©todo se usa y qu√© argumentos tiene.  Adem√°s, esta informaci√≥n simb√≥lica simplifica enormemente el trabajo con herramientas para comparar archivos binarios.  Le permite r√°pidamente y con un n√∫mero m√≠nimo de errores asignar funciones. </p><br><p><img src="https://habrastorage.org/webt/nc/dc/ri/ncdcrissgbl_y_deb3fx9qaqd9a.png" alt="imagen"></p><br><p>  Cuando no hay s√≠mbolos, las herramientas tienen que usar algoritmos internos para an√°lisis, heur√≠stica, etc.  Naturalmente, no siempre funcionan correctamente. </p><br><h2 id="use-cases-gde-patch-diffing-byl-ochen-polezen">  Casos de uso donde la diferenciaci√≥n de parches fue muy √∫til </h2><br><p>  Probablemente, esta presentaci√≥n (en el formato de 45 minutos) y este art√≠culo no hubieran nacido si recientemente Apple no hubiera sorprendido a la comunidad mundial de investigaci√≥n varias veces.  Veamos estos casos. </p><br><h3 id="case-1-cve-2019-8606">  Caso 1: CVE-2019-8606 </h3><br><p>  En mayo de 2019, se lanz√≥ iOS 12.3 para iPhone, donde se corrigi√≥ la vulnerabilidad con la que era posible instalar jailbreak.  En julio de ese a√±o, Apple lanz√≥ la versi√≥n 12.4, donde el jailbreak comenz√≥ a funcionar nuevamente: los empleados quitaron accidentalmente el parche protector.  La versi√≥n corregida se lanz√≥ solo despu√©s de un mes: todo este tiempo, cualquier dispositivo en la √∫ltima versi√≥n podr√≠a ser f√°cilmente sometido a operaciones de jailbreak.  Todo esto fue descubierto gracias a la diferencia de parches. </p><br><p><img src="https://habrastorage.org/webt/97/ri/gn/97rign6v9ubqzhnwlo3zgc0shre.png" alt="imagen"></p><br><h3 id="case-2-cve-2019-7278-i-cve-2019-7286">  Caso 2: CVE-2019-7278 y CVE-2019-7286 </h3><br><p>  El investigador de seguridad Stefan Esser describi√≥ la experiencia personal con Patch que difiri√≥ en la conferencia Hack in the Box en su informe La <a href="https://gsec.hitb.org/materials/sg2019/D2%2520-%2520Recreating%2520an%2520iOS%25200day%2520Jailbreak%2520Out%2520of%2520Apple%25E2%2580%2599s%2520Security%2520Updates%2520-%2520Stefan%2520Esser.pdf">recreaci√≥n de un jailbreak iOS de 0 d√≠as a partir de los parches de seguridad de Apple</a> .  Habl√≥ sobre CVE-2019-7278 y CVE-2019-7286: son notables para aquellos que fueron descubiertos gracias al Google Threat Analysis Group durante su uso real por parte de los atacantes (ITW, en la naturaleza).  Apple recibi√≥ informaci√≥n sobre ellos, pero ni ellos ni los chicos de Google revelaron detalles t√©cnicos.  Entonces Stefan se pregunt√≥ qu√© estaban usando los atacantes.  Le recomendamos encarecidamente que lea su informe, ya que tambi√©n habla sobre el proceso de comparaci√≥n de los componentes del n√∫cleo y el espacio del usuario. <br>  Dato interesante: uno o dos d√≠as antes del discurso de Stefan, el Proyecto Cero Ian Beer public√≥ una serie de art√≠culos <a href="https://googleprojectzero.blogspot.com/2019/08/a-very-deep-dive-into-ios-exploit.html">"Una inmersi√≥n muy profunda en las cadenas de exploits iOS que se encuentran en la naturaleza"</a> , que confundieron los mapas para el investigador;) </p><br><h3 id="case-3-checkm8">  Caso 3: checkm8 </h3><br><p>  Los dispositivos Apple usan dos cargadores de arranque: Bootrom e Iboot.  El primero comienza a funcionar tan pronto como se enciende el dispositivo.  Est√° en la memoria de solo lectura y no se puede actualizar.  Iboot es un gestor de arranque de segundo nivel que mejora la autenticaci√≥n que se ejecuta en la cadena de arranque. <br>  La peculiaridad de los cargadores es que comparten el c√≥digo.  A principios del a√±o pasado, los especialistas compararon las actualizaciones de Iboot y descubrieron que Apple solucion√≥ una vulnerabilidad en la pila USB.  Sabiendo que se usa el mismo c√≥digo en la parte no actualizada de Bootrom, se dieron cuenta de que esta vulnerabilidad tambi√©n existe all√≠.  Luego comenz√≥ el desarrollo del exploit checkm8.  Ahora todos los dispositivos basados ‚Äã‚Äãen chips de A5 a A11 (desde iPhone 4s a iPhone X) son completamente vulnerables, y es posible ejecutar su propio c√≥digo en ellos.  Al mismo tiempo, en los dispositivos de las versiones XR y 11, esta vulnerabilidad ya est√° cerrada, y no hubo informes de esto por parte de Apple. <br>  Entonces, sabiendo d√≥nde se parch√≥ y c√≥mo se divide el c√≥digo, ¬°puedes encontrar algunas cosas realmente geniales! </p><br><h2 id="nasha-istoriya-cve-2019-8574">  Nuestra historia: CVE-2019-8574 </h2><br><p><img src="https://habrastorage.org/webt/sb/4a/hj/sb4ahjfaar4slhvzgdhshhe6qye.png" alt="imagen"><br>  En mayo, Apple lanz√≥ una nueva actualizaci√≥n para sus dispositivos.  Observamos la lista de vulnerabilidades reparadas y encontramos la utilidad sysdiagnose.  Este programa recopila informaci√≥n de diagn√≥stico de varias fuentes y la transfiere al usuario en forma de archivo para su posterior an√°lisis, soporte o centro de servicio.  Parec√≠a que era imposible influir en la forma en que recopila informaci√≥n.  La descripci√≥n del parche indic√≥ que la vulnerabilidad podr√≠a usarse para elevar los privilegios y es un error de corrupci√≥n de memoria, lo que nos intrig√≥ a√∫n m√°s.  Y el autor del hallazgo mismo no public√≥ ninguna descripci√≥n de s√≠ mismo ... </p><br><p><img src="https://habrastorage.org/webt/ss/qj/xs/ssqjxs3dnufltlr6qvqkakimzbw.png" alt="imagen"></p><br><p>  Puede llamar a sysdiagnose en macOS presionando Ctrl + Opci√≥n + Shift +., O usando el comando sudo sysdiagnose.  En dispositivos iOS, debe mantener presionada la tecla de encendido y las teclas de volumen hacia arriba y hacia abajo. </p><br><h3 id="patch-diffing-apple-na-praktike">  Patch Diffing Apple en la pr√°ctica </h3><br><p>  Si desea parchear dispositivos Apple de diferenciaci√≥n, necesita obtener dos versiones de la actualizaci√≥n (antigua y nueva).  En macOS, puede analizar archivos en el Cat√°logo de actualizaciones de software.  Este m√©todo no siempre ayuda, ya que Apple elimina algunas actualizaciones.  Las actualizaciones tambi√©n se pueden encontrar en el directorio / Library / Updates.  Puede encontrar firmware para dispositivos iOS en el <a href="https://ipsw.me/">sitio</a> web <a href="https://ipsw.me/">ipsw.me.</a> <br>  Para macOS, debe extraer archivos ejecutables, archivos de biblioteca, marcos y el n√∫cleo utilizando la utilidad Paquete sospechoso. <br>  Para dispositivos iOS, las cosas son un poco m√°s complicadas.  La actualizaci√≥n en s√≠ es un archivo ZIP.  En este archivo debe encontrar el archivo kernelcache: dentro est√° el kernel y su extensi√≥n.  Sin embargo, antes del an√°lisis necesita convertir el archivo al formato Mach-O.  Esto se puede hacer usando las utilidades img4tool, joker, jtool2 y otras. <br>  El firmware del componente de tierra del usuario se puede encontrar en la imagen DMG m√°s grande: contiene el sistema ra√≠z y los archivos ejecutables.  Sin embargo, si observa bibliotecas y marcos compartidos, no estar√°n all√≠.  El hecho es que para optimizar el espacio se colocan en dyld_shared_cache.  Este archivo contiene todas las bibliotecas del iPhone y ocupa m√°s de 1 gigabyte, lo que complica su an√°lisis.  Si necesita descargar una parte separada del archivo ipsw, use la utilidad ipsw ( <a href="https://github.com/blacktop/ipsw">https://github.com/blacktop/ipsw</a> ). </p><br><h3 id="patchdifing-cve-2019-8574">  Patchdifting CVE-2019-8574 </h3><br><p>  Para estudiar el parche CVE-2019-8574, obtenemos un archivo de Library / Updates y extraemos dos archivos ejecutables sysdiagnose (antiguo y nuevo) usando el Paquete sospechoso, y luego buscamos actualizaciones a trav√©s de utilidades para comparar c√≥digos binarios, por ejemplo, Diaphora o BinDiff (son mucho mejor que el editor hexadecimal). </p><br><h3 id="kak-rabotaet-patch">  Como funciona el parche </h3><br><p>  Para la arquitectura x86_64, encontramos solo una funci√≥n modificada.  Hay m√°s cambios en ARM, pero son insignificantes. </p><br><p><img src="https://habrastorage.org/webt/lz/-r/kw/lz-rkw3czadbapcb5bkywgenypo.png" alt="imagen"></p><br><p>  El problema fue con el m√©todo [SDTask start]: agreg√≥ una nueva verificaci√≥n.  En la figura, puede ver c√≥mo se llama a una funci√≥n isAppleInternal de alguna llamada y se verifica la presencia de la subcadena / usr / local en alguna ruta. </p><br><p><img src="https://habrastorage.org/webt/hd/8u/vc/hd8uvcvbusgs1m52yx0xn8ka4ie.png" alt="imagen"></p><br><p>  Como se indic√≥ anteriormente, sysdiagnose recopila informaci√≥n de varias fuentes.  Las fuentes pueden ser archivos (por ejemplo, un registro de eventos) o la salida de algunos comandos de informaci√≥n (por ejemplo, enumerar procesos o subprocesos que usan ps); estas tareas se almacenan en sysdiagnose como objetos SDTask.  El m√©todo [SDTask start] inicia la ejecuci√≥n de tareas.  En la figura a continuaci√≥n puede ver el c√≥digo en el que se forman todas las tareas.  Todas las rutas de los archivos ejecutables y sus argumentos est√°n escritos directamente en el programa, y ‚Äã‚Äãhay tareas de varios directorios, incluido / usr / local. </p><br><p><img src="https://habrastorage.org/webt/5y/kj/uc/5ykjuc8umbymhffj-xo01ohw2oi.png" alt="imagen! [] (./ assets / 8.png)"></p><br><p>  Por lo tanto, antes de instalar el parche, cualquier tarea podr√≠a realizarse independientemente de d√≥nde se encuentre el archivo ejecutable.  Despu√©s de instalar el parche, se llama a la funci√≥n isAppleInternal, que verifica si el dispositivo es un dispositivo de prueba interno de Apple.  Si se trata de un dispositivo interno, la tarea se realiza de forma est√°ndar y, si es del lado del cliente, se verifica la presencia de la subcadena / usr / local / en la ruta del archivo ejecutable de la tarea.  Si se encuentra una subcadena, la tarea no se completar√°. </p><br><p>  Recuerde que en la descripci√≥n de la vulnerabilidad se dijo que se trata de un error de corrupci√≥n de memoria, pero en el parche no notamos nada parecido ... En nuestra opini√≥n, esta es una vulnerabilidad l√≥gica bien explotada y estable. </p><br><h3 id="kak-eto-ekspluatirovat">  C√≥mo explotarlo </h3><br><p>  Para aprovechar la vulnerabilidad, debe realizar los siguientes pasos: <br>  Cree cualquier archivo ejecutable (binario o script de shell) que sysdiagnose se inicie desde / usr / local / bin, y coloque nuestra carga all√≠.  La lista de archivos v√°lidos se da a continuaci√≥n.  Es importante que el administrador de paquetes de caf√© est√© instalado en el sistema: permite al usuario crear archivos en / usr / local / sin elevar los privilegios. </p><br><p>  Es necesario llamar a sysdiagnose.  Al mismo tiempo, nuestra carga √∫til se ejecutar√° con derechos de usuario root, y su salida se colocar√° en el archivo que forma sysdiagnose.  Por lo tanto, tenemos escalada de privilegios.  Sin embargo, ejecutar sysdiagnose requiere privilegios elevados.  Pero, como se mencion√≥ anteriormente, sysdiagnose tambi√©n se puede iniciar utilizando el m√©todo abreviado de teclado, y esto funciona incluso desde la pantalla de bloqueo de macOS. <br>  Esta vulnerabilidad se puede usar para crear varios programas maliciosos. </p><br><pre><code class="plaintext hljs">/usr/local/bin/airplayutil /usr/local/bin/amstool /usr/local/bin/apsclient /usr/local/bin/audioDeviceDump /usr/local/bin/cdcontexttool /usr/local/bin/cddebug /usr/local/bin/cdknowledgetool /usr/local/bin/dastool /usr/local/bin/idstool /usr/local/bin/imtool /usr/local/bin/keystorectl /usr/local/bin/pmtool /usr/local/bin/xcpm /usr/local/efi/bin/efi-perf</code> </pre> <br><p>  Curiosamente, otras vulnerabilidades podr√≠an estar asociadas con el administrador de paquetes de caf√©, o m√°s bien con la capacidad de escribir a / usr / local / sin privilegios. </p><br><h2 id="vyvod">  Conclusi√≥n </h2><br><p>  Con este estudio, nos gustar√≠a mostrar la importancia y la importancia de que los parches difieran no solo para los atacantes, sino tambi√©n para aumentar la seguridad de los productos de software.  Desafortunadamente, el parche no solo puede cerrar la vulnerabilidad, sino tambi√©n jugar en manos del atacante. </p><br><p>  Sin embargo, este enfoque permite no solo estudiar vulnerabilidades conocidas, sino tambi√©n buscar nuevas como ellas.  Por lo tanto, creemos que la diferenciaci√≥n de parches es imprescindible para todos los investigadores. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/479972/">https://habr.com/ru/post/479972/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../479958/index.html">Vulnerabilidades de firmware y procesador</a></li>
<li><a href="../479960/index.html">El modelo de efectividad de la publicidad en medios para tiendas en l√≠nea.</a></li>
<li><a href="../479966/index.html">Playrix CI / CD: c√≥mo construimos y probamos nuestros juegos</a></li>
<li><a href="../479968/index.html">La oficina de Nginx est√° siendo registrada debido a la demanda del Grupo Rambler. El servicio de prensa del demandante confirm√≥ la demanda.</a></li>
<li><a href="../479970/index.html">Mil y un errores de interfaz de usuario, o c√≥mo ayudar a un desarrollador a evitar errores comunes de interfaz de usuario</a></li>
<li><a href="../479974/index.html">Ataques de clic cero: cuando su seguridad no depende de usted</a></li>
<li><a href="../479978/index.html">Como sin dolor, sin captcha y sin cargo para llevar extractos del Fondo de Propiedad del Estado Federal del Registro Estatal Unificado de Derechos Humanos a un humano legible</a></li>
<li><a href="../479982/index.html">Vidos e insectos</a></li>
<li><a href="../479988/index.html">Concursos tecnol√≥gicos Radiofest-2019. Resumen</a></li>
<li><a href="../479992/index.html">C√≥mo ense√±ar a UITextView a destacarse maravillosamente</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>