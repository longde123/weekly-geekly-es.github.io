<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöµüèº üë©‚Äçüë¶ üë©üèø‚Äç‚úàÔ∏è Byte-machine para o forte (e n√£o apenas) no nativo americano (parte 4) üò≤ üíÉüèΩ üë®‚Äçüé§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="E novamente superestimei o volume do artigo! Planejei que este seria o artigo final, onde faremos um compilador e faremos o teste. Mas o volume acabou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Byte-machine para o forte (e n√£o apenas) no nativo americano (parte 4)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437466/"><img src="https://habrastorage.org/getpro/habr/post_images/dbb/a59/e93/dbba59e932ecdb4b0c28896a7e6fc3e3.jpg" alt="Fort Byte Carro (e mais) Nativo Americano"><br><br>  E novamente superestimei o volume do artigo!  Planejei que este seria o artigo final, onde faremos um compilador e faremos o teste.  Mas o volume acabou sendo grande e eu decidi dividir o artigo em dois. <br><br>  Neste artigo, faremos quase todas as fun√ß√µes b√°sicas do compilador.  Ele ganhar√° vida e ser√° poss√≠vel escrever, compilar e executar um c√≥digo bastante s√©rio.  E faremos testes na pr√≥xima parte.  (A prop√≥sito, as partes anteriores: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dois</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tr√™s</a> ). <br><br>  Estou escrevendo pela primeira vez em Habr√©; talvez nem sempre esteja certo.  Na minha opini√£o, os artigos 2, 3 revelaram-se bastante secos, muito c√≥digo, pouca descri√ß√£o.  Desta vez, tentarei fazer algo diferente, enfocando a descri√ß√£o das pr√≥prias id√©ias.  Bem, o c√≥digo ... o c√≥digo, √© claro que sim!  Quem quer entender completamente, essa oportunidade ser√°.  Em muitos casos, colocarei o c√≥digo sob o spoiler.  E, √© claro, voc√™ sempre pode procurar a fonte completa no github. <br><br>  O compilador continuar√° escrevendo por algum tempo no assembler, mas depois v√° para o forte e continuar√° escrevendo o compilador em n√≥s mesmos.  Isso se parecer√° com o bar√£o Munchausen, que se puxou pelos cabelos do p√¢ntano.  Mas, para come√ßar, descreverei como o compilador do forte funciona.  Bem-vindo ao gato! <br><a name="habracut"></a><br><h4>  Como o compilador funciona? </h4><br>  A mem√≥ria no forte consiste em um fragmento cont√≠nuo no qual as entradas do dicion√°rio s√£o organizadas em sequ√™ncia.  Ap√≥s a conclus√£o, √© seguida por uma √°rea de mem√≥ria livre.  O primeiro byte livre √© indicado pela vari√°vel h.  H√° tamb√©m a palavra frequentemente usada aqui, que envia o endere√ßo do primeiro byte livre da pilha, √© determinada de maneira muito simples: <br><br><pre><code class="cpp hljs">: here h @ ;</code> </pre> <br><img src="https://habrastorage.org/webt/bd/eg/sq/bdegsqg7t06egwbvxoib9lqk_nc.png"><br><br>  Vale mencionar a palavra allot, que reserva o n√∫mero especificado de bytes movendo o ponteiro h.  A palavra allot pode ser definida da seguinte maneira: <br><br><pre> <code class="cpp hljs">: allot h +! ;</code> </pre> <br>  De fato, o compilador usa um modo de int√©rprete especial mais algumas palavras especiais.  Assim, com uma frase, voc√™ pode descrever todo o princ√≠pio do compilador no forte.  O modo em que o int√©rprete trabalha √© determinado pela vari√°vel de estado.  Se for zero, o modo de execu√ß√£o √© definido, caso contr√°rio - modo de compila√ß√£o.  J√° estamos familiarizados com o modo de execu√ß√£o, nele as palavras do buffer de entrada s√£o simplesmente executadas uma ap√≥s a outra.  Mas no modo de compila√ß√£o, eles n√£o s√£o executados, mas s√£o compilados na mem√≥ria pelo ponteiro h.  Por conseguinte, o ponteiro avan√ßa. <br><br>  No forte cl√°ssico, a palavra "," √© usada para compilar um valor inteiro, a palavra "c" √© usada para compilar um byte.  Nosso sistema utiliza valores de diferentes profundidades de bits (8, 16, 32, 64); portanto, criaremos adicionalmente as palavras "w" e "i".  Tamb√©m criamos a palavra "str", que ir√° compilar a string, obtendo dois valores da pilha - o endere√ßo e o comprimento da string. <br><br>  Palavras especiais do compilador s√£o usadas para formar estruturas de controle.  Essas s√£o as palavras if, then, do, loop e outras.  Essas palavras s√£o executadas mesmo no modo de compila√ß√£o.  Por exemplo, a palavra se compila um comando condicional de byte de ramifica√ß√£o (? Nbranch) na execu√ß√£o.  Para que o sistema saiba quais palavras precisam ser executadas no modo de compila√ß√£o, e n√£o compiladas, o sinalizador imediato (sinal) √© usado.  J√° o temos no campo sinalizador da entrada do dicion√°rio.  No c√≥digo-fonte do assembler, √© chamado f_immediate.  Para definir esse sinalizador, use a palavra imediato.  N√£o possui par√¢metros, o sinalizador imediato √© definido na √∫ltima palavra do dicion√°rio. <br><br>  Agora vamos passar da teoria para a pr√°tica! <br><br><h4>  Prepara√ß√£o </h4><br>  No come√ßo, precisamos executar alguns comandos simples de byte na linguagem assembly que precisamos.  Aqui est√£o eles: mover (copiar a √°rea de mem√≥ria), preencher (preencher a √°rea de mem√≥ria), opera√ß√µes de bits (e, ou, xor, invert), comandos de troca de bits (rshift, lshift).  Vamos fazer o mesmo rpick (isso √© o mesmo que pick, ele s√≥ funciona com a pilha de retorno, n√£o com a pilha de dados). <br><br><div class="spoiler">  <b class="spoiler_title">Esses comandos s√£o muito simples, aqui est√° o c√≥digo deles</b> <div class="spoiler_text"><pre> <code class="cpp hljs">b_move = <span class="hljs-number"><span class="hljs-number">0x66</span></span> bcmd_move: pop rcx pop rdi pop rsi repz movsb jmp _next b_fill = <span class="hljs-number"><span class="hljs-number">0x67</span></span> bcmd_fill: pop rax pop rcx pop rdi repz stosb jmp _next b_rpick = <span class="hljs-number"><span class="hljs-number">0x63</span></span> bcmd_rpick: pop rcx push [rbp + rcx * <span class="hljs-number"><span class="hljs-number">8</span></span>] jmp _next b_and = <span class="hljs-number"><span class="hljs-number">0x58</span></span> bcmd_and: pop rax <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> [rsp], rax jmp _next b_or = <span class="hljs-number"><span class="hljs-number">0x59</span></span> bcmd_or: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> [rsp], rax jmp _next b_xor = <span class="hljs-number"><span class="hljs-number">0x5A</span></span> bcmd_xor: pop rax xor [rsp], rax jmp _next b_invert = <span class="hljs-number"><span class="hljs-number">0x5B</span></span> bcmd_invert: notq [rsp] jmp _next b_rshift = <span class="hljs-number"><span class="hljs-number">0x5C</span></span> bcmd_rshift: pop rcx <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rcx, rcx jz _next <span class="hljs-number"><span class="hljs-number">1</span></span>: shrq [rsp] dec rcx jnz <span class="hljs-number"><span class="hljs-number">1b</span></span> jmp _next b_lshift = <span class="hljs-number"><span class="hljs-number">0x5D</span></span> bcmd_lshift: pop rcx <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rcx, rcx jz _next <span class="hljs-number"><span class="hljs-number">1</span></span>: shlq [rsp] dec rcx jnz <span class="hljs-number"><span class="hljs-number">1b</span></span> jmp _next</code> </pre> </div></div><br>  Ainda precisa fazer a palavra palavra.  √â o mesmo que blword, mas um delimitador espec√≠fico √© indicado na pilha.  N√£o forne√ßo o c√≥digo, ele pode ser encontrado na fonte.  Fiz copiar / colar as palavras blworld e substitui os comandos de compara√ß√£o. <br><br>  Em conclus√£o, criamos a palavra syscall.  Com ele, ser√° poss√≠vel executar as opera√ß√µes ausentes do sistema, por exemplo, trabalhando com arquivos.  Essa solu√ß√£o n√£o funcionar√° se a independ√™ncia da plataforma for necess√°ria.  Mas esse sistema agora √© usado para testes, ent√£o deixe que seja por enquanto.  Se necess√°rio, todas as opera√ß√µes podem ser convertidas em comandos de byte, n√£o √© nada dif√≠cil.  O comando syscall aceitar√° 6 par√¢metros para a chamada do sistema e o n√∫mero da chamada da pilha.  Ele retornar√° um par√¢metro.  As atribui√ß√µes de par√¢metros e o valor retornado s√£o determinados pelo n√∫mero de chamada do sistema. <br><br><pre> <code class="cpp hljs">b_syscall = <span class="hljs-number"><span class="hljs-number">0xFF</span></span> bcmd_syscall: sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> mov [rbp], r8 pop rax pop r9 pop r8 pop r10 pop rdx pop rsi pop rdi syscall push rax mov r8, [rbp] add rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> jmp _next</code> </pre><br>  E agora vamos prosseguir diretamente para o compilador. <br><br><h4>  Compilador </h4><br>  Vamos criar a vari√°vel h, tudo √© simples aqui. <br><br><pre> <code class="cpp hljs"> item h h: .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre>  Vamos escrever sua inicializa√ß√£o na linha de partida: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta"># forth last_item context @ ! h dup 8 + swap ! quit start: .byte b_call16 .word forth - . - 2 .byte b_call16 .word last_item - . - 2 .byte b_call16 .word context - . - 2 .byte b_get .byte b_set .byte b_call16 .word h - . - 2 .byte b_dup, b_num8, b_add, b_swap, b_set .byte b_quit</span></span></code> </pre><br>  Vamos fazer a palavra aqui: <br><br><pre> <code class="cpp hljs"> item here .byte b_call8, h - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_get .byte b_exit</code> </pre><br><div class="spoiler">  <b class="spoiler_title">E tamb√©m palavras para compilar os valores: "allot" e "c,", "w", "i", ",", "str"</b> <div class="spoiler_text"><pre> <code class="cpp hljs"># : allot h +! ; item allot allot: .byte b_call8, h - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_setp, b_exit # : , here ! <span class="hljs-number"><span class="hljs-number">8</span></span> allot ; item <span class="hljs-string"><span class="hljs-string">","</span></span> .byte b_call8, here - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_set, b_num8, b_call8, allot - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_exit # : i, here i! <span class="hljs-number"><span class="hljs-number">4</span></span> allot ; item <span class="hljs-string"><span class="hljs-string">"i,"</span></span> .byte b_call8, here - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_set32, b_num4, b_call8, allot - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_exit # : w, here w! <span class="hljs-number"><span class="hljs-number">2</span></span> allot ; item <span class="hljs-string"><span class="hljs-string">"w,"</span></span> .byte b_call8, here - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_set16, b_num2, b_call8, allot - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_exit # : c, here c! <span class="hljs-number"><span class="hljs-number">1</span></span> allot ; item <span class="hljs-string"><span class="hljs-string">"c,"</span></span> .byte b_call8, here - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_set8, b_num1, b_call8, allot - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_exit # : str, dup -rot dup c, here swap move <span class="hljs-number"><span class="hljs-number">1</span></span>+ h +!; item <span class="hljs-string"><span class="hljs-string">"str,"</span></span> c_str: .byte b_dup, b_mrot, b_dup callb c_8 callb here .byte b_swap, b_move callb h .byte b_setp .byte b_exit</code> </pre></div></div><br>  Agora vamos fazer a vari√°vel state e duas palavras para controlar seu valor: "[" e "]".  Normalmente, essas palavras s√£o usadas para executar algo no momento da compila√ß√£o.  Portanto, a palavra "[" desativa o modo de compila√ß√£o e a palavra "]" o ativa.  Mas nada impede que eles sejam usados ‚Äã‚Äãem outros casos quando √© necess√°rio ativar ou desativar o modo de compila√ß√£o.  A palavra "[" ser√° a nossa primeira palavra com o sinal imediato.  Caso contr√°rio, ele n√£o poder√° desativar o modo de compila√ß√£o, pois ser√° compilado, n√£o executado. <br><br><pre> <code class="cpp hljs"> item state .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">0</span></span> item <span class="hljs-string"><span class="hljs-string">"]"</span></span> .byte b_num1 callb state .byte b_set, b_exit item <span class="hljs-string"><span class="hljs-string">"["</span></span>, f_immediate .byte b_num0 callb state .byte b_set, b_exit</code> </pre><br>  Chegou a vez da palavra $ compile.  Ele pegar√° o endere√ßo da entrada do dicion√°rio da pilha e compilar√° a palavra especificada.  Para compilar uma palavra nas implementa√ß√µes comuns do Fort, basta aplicar a palavra "," ao endere√ßo de execu√ß√£o.  Tudo √© muito mais complicado aqui.  Primeiramente, existem dois tipos de palavras - bytecode e c√≥digo de m√°quina.  Os primeiros s√£o compilados por byte e os √∫ltimos pelo comando call byte.  E em segundo lugar - temos at√© quatro variantes do comando call: call8, call16, call32 e call64.  Quatro?  N√£o!  Quando escrevi o compilador, adicionei mais 16 a esses quatro!  :) <br><br>  Como isso aconteceu?  Temos que fazer uma pequena digress√£o. <br><br><h4>  Melhorando o Comando de Chamada </h4><br>  Quando o compilador come√ßou a funcionar, descobri que em muitos casos (mas n√£o em todos) o comando call8 √© suficiente.  √â quando a palavra chamada est√° dentro de 128 bytes.  Eu pensei - e como garantir que isso aconte√ßa em quase todos os casos?  Como colocar mais de 256 valores em um byte? <br>  O primeiro ponto que notei foi que, no forte, a liga√ß√£o sempre vai para endere√ßos mais baixos.  Isso significa que voc√™ pode refazer o comando de chamada de forma que ele possa chamar apenas endere√ßos inferiores, mas com 256 bytes, n√£o com 128. √â melhor. <br><br>  Mas se voc√™ colocar alguns bits em algum lugar ... Acontece que √© onde!  Temos dois bytes: um byte √© o comando, o segundo √© o deslocamento.  Mas nada impede que os bits mais baixos do comando coloquem os bits altos do par√¢metro (deslocamento).  Para uma m√°quina de bytes, parece que, em vez de um comando de chamada, existem v√°rios.  Sim, dessa maneira ocupamos v√°rias c√©lulas da tabela de c√≥digos de comando de bytes com um comando, mas √†s vezes vale a pena faz√™-lo.  O comando call √© um dos comandos mais usados, ent√£o decidi colocar 4 bits de deslocamento no comando.  Assim, voc√™ pode fazer uma chamada a uma dist√¢ncia de at√© 4095 bytes!  Isso significa que um comando de chamada curta ser√° usado quase sempre.  Coloquei esses comandos com o c√≥digo 0xA0 e as seguintes linhas apareceram na tabela de comandos: <br><br><pre> <code class="cpp hljs">.quad bcmd_call8b0, bcmd_call8b1, bcmd_call8b2, bcmd_call8b3, bcmd_call8b4, bcmd_call8b5, bcmd_call8b6, bcmd_call8b7 # <span class="hljs-number"><span class="hljs-number">0xA0</span></span> .quad bcmd_call8b8, bcmd_call8b9, bcmd_call8b10, bcmd_call8b11, bcmd_call8b12, bcmd_call8b13, bcmd_call8b14, bcmd_call8b15</code> </pre> <br>  O primeiro desses comandos de byte simplesmente faz uma chamada na dire√ß√£o de endere√ßos inferiores no deslocamento especificado no par√¢metro (at√© 255).  O restante adiciona o deslocamento correspondente ao par√¢metro.  bcmd_call8b1 adiciona 256, bcmd_call8b2 adiciona 512 e assim por diante.  Fiz o primeiro comando de chamada separadamente, o restante com uma macro. <br><br>  Primeiro comando: <br><br><pre> <code class="cpp hljs">b_call8b0 = <span class="hljs-number"><span class="hljs-number">0xA0</span></span> bcmd_call8b0: movzx rax, byte ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> inc r8 mov [rbp], r8 sub r8, rax jmp _next</code> </pre><br>  Macro e criando o restante dos comandos de chamada: <br><br><pre> <code class="cpp hljs">.macro call8b N b_call8b\N = <span class="hljs-number"><span class="hljs-number">0xA</span></span>\N bcmd_call8b\N: movzx rax, byte ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> inc r8 add rax, \N * <span class="hljs-number"><span class="hljs-number">256</span></span> mov [rbp], r8 sub r8, rax jmp _next .endm call8b <span class="hljs-number"><span class="hljs-number">1</span></span> call8b <span class="hljs-number"><span class="hljs-number">2</span></span> call8b <span class="hljs-number"><span class="hljs-number">3</span></span> call8b <span class="hljs-number"><span class="hljs-number">4</span></span> call8b <span class="hljs-number"><span class="hljs-number">5</span></span> call8b <span class="hljs-number"><span class="hljs-number">6</span></span> call8b <span class="hljs-number"><span class="hljs-number">7</span></span> call8b <span class="hljs-number"><span class="hljs-number">8</span></span> call8b <span class="hljs-number"><span class="hljs-number">9</span></span> call8b <span class="hljs-number"><span class="hljs-number">10</span></span> call8b <span class="hljs-number"><span class="hljs-number">11</span></span> call8b <span class="hljs-number"><span class="hljs-number">12</span></span> call8b <span class="hljs-number"><span class="hljs-number">13</span></span> call8b <span class="hljs-number"><span class="hljs-number">14</span></span> call8b <span class="hljs-number"><span class="hljs-number">15</span></span></code> </pre><br>  Bem, refiz o antigo comando call8 para encaminhar chamadas, j√° que j√° temos 16 equipes fazendo uma chamada de volta.  Qualquer que seja a confus√£o, eu a renomei b_call8f: <br><br><pre> <code class="cpp hljs">b_call8f = <span class="hljs-number"><span class="hljs-number">0x0C</span></span> bcmd_call8f: movzx rax, byte ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> inc r8 mov [rbp], r8 add r8, rax jmp _next</code> </pre><br>  A prop√≥sito, por conveni√™ncia, criei uma macro que no assembler compila automaticamente a chamada correspondente de volta em 4095. E ent√£o eu nunca precisei :) <br><br><pre> <code class="cpp hljs">.macro callb adr .<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> \adr &gt; . .error <span class="hljs-string"><span class="hljs-string">"callb do not for forward!"</span></span> .endif .byte b_call8b0 + (. - \adr + <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span> .byte (. - \adr + <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">255</span></span> .endm</code> </pre> <br>  E agora ... <br><br><h4>  Compila√ß√£o da equipe </h4><br>  Portanto, obtemos um algoritmo de compila√ß√£o de comandos bastante complicado.  Se este for um comando byte, compile apenas um byte (c√≥digo de comando do byte).  E se essa palavra j√° estiver escrita em c√≥digo de bytes, voc√™ precisar√° compilar sua chamada com o comando call, escolhendo uma das vinte.  Mais precisamente 19, portanto, n√£o temos encaminhamento de chamada, e o call8f n√£o ser√° usado para o forte. <br><br>  Ent√£o a escolha √© essa.  Se o deslocamento estiver dentro de 0 ...- 4095, selecione o comando bcmd_call8b com o c√≥digo 0xA0, colocando os quatro bits de deslocamento mais significativos nos bits menos significativos do comando.  Ao mesmo tempo, para a m√°quina de bytes, o c√≥digo para um dos comandos bcmd_call8b0 √© bcmd_call8b15. <br><br>  Se o deslocamento para tr√°s for maior ou igual a 4095, determinaremos em qual dimens√£o o deslocamento √© colocado e usaremos o comando apropriado da chamada 16 / 32/64.  Deve-se ter em mente que a compensa√ß√£o para essas equipes √© assinada.  Eles podem causar tanto para a frente quanto para tr√°s.  Por exemplo, call16 pode chamar uma dist√¢ncia de 32767 em ambas as dire√ß√µes. <br><br>  Aqui est√° a implementa√ß√£o como resultado: <br><br>  <b>$ compilar</b> <br><br>  Compila uma palavra.  Como par√¢metro, pega o endere√ßo da entrada de dicion√°rio da palavra compilada.  De fato, ele verifica o sinalizador f_code, calcula o endere√ßo do c√≥digo (cfa) e chama compile_b ou compile_c (se o sinalizador estiver definido). <br><br>  <b>compile_c</b> <br><br>  Compila um comando byte.  A palavra mais simples aqui √© descrita no forte assim: <br><br><pre> <code class="cpp hljs">: compile_c c@ c, ;</code> </pre> <br>  <b>compile_b</b> <br>  Ele pega um endere√ßo de bytecode na pilha e compila sua chamada. <br><br>  <b>test_bv</b> <br><br>  Ele pega um deslocamento da pilha (com um sinal) e determina qual profundidade de bit usar (1, 2, 4 ou 8 bytes).  Retorna o valor 0, 1, 2 ou 3. Usando esta palavra, voc√™ pode determinar qual delas usar nos comandos call16 / 32/64.  Essa palavra ser√° √∫til ao compilar n√∫meros (uma op√ß√£o entre lit8 / 16/32/64). <br><br>  A prop√≥sito, voc√™ pode iniciar o sistema e "brincar" no console do forte com qualquer uma dessas palavras.  Por exemplo: <br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; 222 test_bv ( 2 ): 222 1 &gt; drop drop ( 0 ): &gt; 1000000 test_bv ( 2 ): 1000000 2 &gt; drop drop ( 0 ): &gt; -33 test_bv ( 2 ): -33 0 &gt;</code> </pre> <br>  <b>test_bvc</b> <br><br>  Ele pega um deslocamento (com um sinal) da pilha e determina qual comando de chamada usar.  De fato, ele verifica se o deslocamento est√° entre 0 ... -4095 e retorna 0. Nesse caso, se n√£o houver acerto nesse intervalo, ele chama test_bv. <br><br><div class="spoiler">  <b class="spoiler_title">√â o suficiente para compilar o comando.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"># : test_bvc dup <span class="hljs-number"><span class="hljs-number">0</span></span> &gt;= over FFF &lt;= <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ... item test_bvc test_bvc: .byte b_dup, b_neg .byte b_num0 .byte b_gteq .byte b_over, b_neg .byte b_lit16 .word <span class="hljs-number"><span class="hljs-number">0xFFF</span></span> .byte b_lteq .byte b_and .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_num0 .byte b_exit item test_bv test_bv: .byte b_dup, b_lit8, <span class="hljs-number"><span class="hljs-number">0x80</span></span>, b_gteq, b_over, b_lit8, <span class="hljs-number"><span class="hljs-number">0x7f</span></span>, b_lteq, b_and, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - ., b_num0 .byte b_exit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_dup .byte b_lit16 .word <span class="hljs-number"><span class="hljs-number">0x8001</span></span> .byte b_gteq .byte b_over .byte b_lit16 .word <span class="hljs-number"><span class="hljs-number">0x7ffe</span></span> .byte b_lteq, b_and, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - ., b_num1, b_exit <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_dup .byte b_lit32 .<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80000002</span></span> .byte b_gteq .byte b_over .byte b_lit32 .<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x7ffffffd</span></span> .byte b_lteq, b_and, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - ., b_num2, b_exit <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_num3 .byte b_exit #  - item compile_c compile_c: .byte b_get8 callb c_8 .byte b_exit #   - item compile_b compile_b: callb here .byte b_num2, b_add .byte b_sub callb test_bvc .byte b_dup .byte b_zeq .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_drop .byte b_neg .byte b_dup .byte b_lit8, <span class="hljs-number"><span class="hljs-number">8</span></span> .byte b_rshift .byte b_lit8, b_call8b0 .byte b_or callb c_8 callb c_8 .byte b_exit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_dup, b_num1, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - ., b_drop, b_lit8, b_call16 callb c_8 .byte b_wm callb c_16 .byte b_exit <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_num2, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - ., b_lit8, b_call32 callb c_8 .byte b_num3, b_sub callb c_32 .byte b_exit <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_lit8, b_call64 callb c_8 .byte b_lit8, <span class="hljs-number"><span class="hljs-number">7</span></span>, b_sub callb c_64 .byte b_exit #: $compile dup c@ <span class="hljs-number"><span class="hljs-number">0x80</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cfa compile_c <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> cfa compile_b then ; item <span class="hljs-string"><span class="hljs-string">"$compile"</span></span> _compile: .byte b_dup, b_get8, b_lit8, <span class="hljs-number"><span class="hljs-number">0x80</span></span>, b_and, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - ., b_cfa callb compile_c .byte b_exit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_cfa callb compile_b .byte b_exit</code> </pre><br></div></div><br>  Agora precisamos compilar o n√∫mero. <br><br><h4>  Compilando um n√∫mero (literal) </h4><br>  Escreveu uma legenda inteira, preparada para descrever especificamente a compila√ß√£o do literal, mas acontece que n√£o h√° nada especial para descrever :) <br><br>  J√° fizemos metade do trabalho na palavra test_bv.  Resta apenas chamar test_bv e, dependendo do resultado, compilar lit8 / 16/32/64 e, em seguida, o valor correspondente de 1, 2, 4 ou 8 bytes de tamanho. <br><br><div class="spoiler">  <b class="spoiler_title">Fazemos isso definindo a palavra compile_n</b> <div class="spoiler_text"><pre> <code class="cpp hljs">#   item compile_n compile_n: callb test_bv .byte b_dup .byte b_zeq .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_drop, b_lit8, b_lit8 callb c_8 callb c_8 .byte b_exit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_dup, b_num1, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - ., b_drop, b_lit8, b_lit16 callb c_8 callb c_16 .byte b_exit <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_num2, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - ., b_lit8, b_lit32 callb c_8 callb c_32 .byte b_exit <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_lit8, b_lit64 callb c_8 callb c_64 .byte b_exit</code> </pre></div></div><br><h4>  Modifique o int√©rprete </h4><br>  Tudo est√° pronto para compilar o comando e os literais.  Agora ele precisa ser incorporado ao int√©rprete.  Essa modifica√ß√£o √© simples.  Onde o comando foi executado, adicione a verifica√ß√£o de estado.  Se state n√£o for nulo e a palavra n√£o contiver o sinalizador imediato, em vez da execu√ß√£o, voc√™ precisar√° chamar $ compile.  E quase a mesma coisa a fazer onde o n√∫mero √© obtido a partir do fluxo de entrada.  Se o estado for zero, deixe o n√∫mero na pilha e, se n√£o, chame compile_n. <br><br><div class="spoiler">  <b class="spoiler_title">Aqui est√° o int√©rprete</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> item interpret interpret: .byte b_blword .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . .byte b_over .byte b_over .byte b_find .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_mrot .byte b_drop .byte b_drop callb state .byte b_get .byte b_qnbranch8, irpt_execute - . #  <span class="hljs-number"><span class="hljs-number">0</span></span>,    .byte b_dup, b_get8, b_lit8, f_immediate, b_and #  immediate    .byte b_qbranch8, irpt_execute - . #    -   #   ! callb _compile .byte b_branch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - . irpt_execute: .byte b_cfa #  ,    (state = <span class="hljs-number"><span class="hljs-number">0</span></span>  immediate  ) .byte b_execute .byte b_branch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - . <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_drop .byte b_over, b_over .byte b_numberq # ,    .byte b_qbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - . #     <span class="hljs-number"><span class="hljs-number">0</span></span>, ,      <span class="hljs-number"><span class="hljs-number">3</span></span> .byte b_type #    .byte b_strp #   .byte <span class="hljs-number"><span class="hljs-number">19</span></span> #     .ascii <span class="hljs-string"><span class="hljs-string">" : word not found!\n"</span></span> .byte b_quit #    <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_nip, b_nip #  ,     ( b_over, b_over) #   -   callb state # ,    .byte b_get .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - . #   -     ;   -   #   callb compile_n <span class="hljs-number"><span class="hljs-number">2</span></span>: #       .byte b_depth #    .byte b_zlt # ,   <span class="hljs-number"><span class="hljs-number">0</span></span> ( <span class="hljs-number"><span class="hljs-number">0</span></span>&lt;) .byte b_qnbranch8, interpret_ok - . #   ,    ,   .byte b_strp #    .byte <span class="hljs-number"><span class="hljs-number">14</span></span> .ascii <span class="hljs-string"><span class="hljs-string">"\nstack fault!\n"</span></span> .byte b_quit #    interpret_ok: .byte b_branch8 .byte interpret - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_drop .byte b_exit</code> </pre></div></div><br>  Agora estamos a um passo do compilador ... <br><br><h4>  Defini√ß√£o de novas palavras (palavra ":") </h4><br>  Agora, se definirmos a vari√°vel de estado como um valor diferente de zero, o processo de compila√ß√£o come√ßar√°.  Mas o resultado ser√° in√∫til, n√£o podemos cumpri-lo nem encontr√°-lo na mem√≥ria.  Para possibilitar tudo isso, √© necess√°rio formatar o resultado da compila√ß√£o na forma de um artigo de dicion√°rio.  Para fazer isso, antes de ativar o modo de compila√ß√£o, voc√™ precisa criar um t√≠tulo para a palavra. <br><br>  O cabe√ßalho deve conter bandeiras, um campo de comunica√ß√£o e um nome.  Aqui temos uma hist√≥ria familiar - o campo de comunica√ß√£o pode ser de 1, 2, 4 ou 8 bytes.  Vamos criar a palavra compile_1248, que nos ajudar√° a formar esse campo de comunica√ß√£o.  Ser√£o necess√°rios dois n√∫meros na pilha - o deslocamento e o valor gerado pelo comando test_bv. <br><br><div class="spoiler">  <b class="spoiler_title">compile_1248</b> <div class="spoiler_text"><pre> <code class="cpp hljs">#    , ,     #     ,  test_dv item compile_1248 compile_1248: .byte b_dup .byte b_zeq .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_drop callb c_8 .byte b_exit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_dup, b_num1, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - . .byte b_drop callb c_16 .byte b_exit <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_num2, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - . callb c_32 .byte b_exit <span class="hljs-number"><span class="hljs-number">3</span></span>: callb c_64 .byte b_exit</code> </pre></div></div><br>  Agora fa√ßa a palavra $ create.  Ser√° √∫til para n√≥s mais de uma vez.  Voc√™ pode us√°-lo sempre que precisar criar um t√≠tulo para uma entrada do dicion√°rio.  Ser√£o necess√°rios dois valores da pilha - o endere√ßo do nome da palavra criada e seu comprimento.  Depois de executar esta palavra, o endere√ßo da entrada de dicion√°rio criada aparecer√° na pilha. <br><br><div class="spoiler">  <b class="spoiler_title">$ create</b> <div class="spoiler_text"><pre> <code class="cpp hljs"># : $create here current @ @ here - test_bv dup c, compile_1248 -rot str, current @ ! <span class="hljs-string"><span class="hljs-string">' var0 here c!; item "$create" create: callb here callb current .byte b_get, b_get callb here .byte b_sub callb test_bv .byte b_dup callb c_8 callb compile_1248 .byte b_mrot callb c_str #       callb current .byte b_get, b_set #     - var0,      here #   ,    -    ,    #     ,     #    1 allot   ,   .byte b_lit8, b_var0 callb here .byte b_set8 .byte b_exit</span></span></code> </pre> </div></div><br>  A pr√≥xima palavra selecionar√° o nome da nova palavra no fluxo de entrada usando a palavra blword e chamar√° $ create, criando uma nova palavra com o nome especificado. <br><br><div class="spoiler">  <b class="spoiler_title">create_in</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> item <span class="hljs-string"><span class="hljs-string">"create_in"</span></span> create_in: .byte b_blword .byte b_dup .byte b_qbranch8 .byte <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_strp #   (     ) .byte <span class="hljs-number"><span class="hljs-number">3f</span></span> - <span class="hljs-number"><span class="hljs-number">2f</span></span> #     <span class="hljs-number"><span class="hljs-number">2</span></span>: .ascii <span class="hljs-string"><span class="hljs-string">"\ncreate_in - name not found!\n"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_quit <span class="hljs-number"><span class="hljs-number">1</span></span>: callb create .byte b_exit</code> </pre></div></div><br>  E, finalmente, fa√ßa a palavra ":".  Ele criar√° uma nova palavra usando create_in e definir√° o modo de compila√ß√£o, n√£o est√° instalado.  E se instalado, d√° um erro.  A palavra ":" ter√° o sinal imediato. <br><br><div class="spoiler">  <b class="spoiler_title">a palavra:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"># : : create_in <span class="hljs-number"><span class="hljs-number">1</span></span> state dup @ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .<span class="hljs-string"><span class="hljs-string">" : - no execute state!"</span></span> then ! <span class="hljs-number"><span class="hljs-number">110</span></span> ; immediate item <span class="hljs-string"><span class="hljs-string">":"</span></span>, f_immediate colon: callb create_in .byte b_num1 callb state .byte b_dup .byte b_get .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - . .byte b_strp #   (     ) .byte <span class="hljs-number"><span class="hljs-number">4f</span></span> - <span class="hljs-number"><span class="hljs-number">3f</span></span> #     <span class="hljs-number"><span class="hljs-number">3</span></span>: .ascii <span class="hljs-string"><span class="hljs-string">"\n: - no execute state!\n"</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: .byte b_quit <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_set .byte b_lit8, <span class="hljs-number"><span class="hljs-number">110</span></span> .byte b_exit</code> </pre></div></div><br>  Se algu√©m examinasse o c√≥digo, ele viu que essa palavra faz outra coisa :) <br><br>  E aqui est√° 110 ??? <br><br>  Sim, essa palavra tamb√©m coloca o n√∫mero 110 na pilha, e √© por isso.  Quando compiladas, as v√°rias constru√ß√µes devem ser um √∫nico todo.  Por exemplo, depois de se deve ser ent√£o.  E a palavra criada usando ":" deve terminar com ";".  Para verificar essas condi√ß√µes, palavras especiais do compilador colocam certos valores na pilha e verificam sua presen√ßa.  Por exemplo, a palavra ":" coloca o valor 110 e a palavra ";"  verifica se 110 est√° no topo da pilha.Se esse n√£o for o caso, isso √© um erro.  Portanto, as estruturas de controle n√£o foram emparelhadas. <br><br>  Essa verifica√ß√£o √© realizada em todas as palavras do compilador; portanto, criaremos uma palavra especial para isso - "? Pares".  Ele pega dois valores da pilha e gera um erro se eles n√£o forem iguais. <br><br>  Al√©m disso, em tais palavras, voc√™ geralmente precisa verificar se o modo de compila√ß√£o est√° definido.  Vamos criar a palavra "? State" para isso. <br><br><div class="spoiler">  <b class="spoiler_title">estado dos pares</b> <div class="spoiler_text"><pre> <code class="cpp hljs">#: ?pairs = ifnot <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> then .<span class="hljs-string"><span class="hljs-string">" \nerror: no pairs operators"</span></span> quit then ; item <span class="hljs-string"><span class="hljs-string">"?pairs"</span></span> .byte b_eq, b_qbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_strp .byte <span class="hljs-number"><span class="hljs-number">3f</span></span> - <span class="hljs-number"><span class="hljs-number">2f</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: .ascii <span class="hljs-string"><span class="hljs-string">"\nerror: no pairs operators"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_quit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_exit #: ?state state @ <span class="hljs-number"><span class="hljs-number">0</span></span>= <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">abort</span></span><span class="hljs-string"><span class="hljs-string">" error: no compile state"</span></span> then ; item <span class="hljs-string"><span class="hljs-string">"?state"</span></span> callb state .byte b_get, b_zeq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_strp .byte <span class="hljs-number"><span class="hljs-number">3f</span></span> - <span class="hljs-number"><span class="hljs-number">2f</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: .ascii <span class="hljs-string"><span class="hljs-string">"\nerror: no compile state"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_quit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_exit</code> </pre></div></div><br>  Isso √© tudo!  N√£o vamos compilar mais nada no assembler manualmente :) <br><br>  Mas at√© o final, o compilador ainda n√£o foi escrito, portanto, no come√ßo, voc√™ ter√° que usar alguns m√©todos incomuns ... <br><br><h4>  Vamos nos preparar para compilar o compilador criado com o compilador criado </h4><br>  Para come√ßar, voc√™ pode verificar como a palavra ":" funciona compilando algo simples.  Vamos criar, por exemplo, a palavra: <br><br><pre> <code class="cpp hljs">: ^<span class="hljs-number"><span class="hljs-number">2</span></span> dup * ;</code> </pre> <br>  Esta palavra √© quadrada.  Mas n√£o temos a palavra ";" o que fazer?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em vez disso, escrevemos a palavra exit e ela compila. </font><font style="vertical-align: inherit;">E, em seguida, desative o modo de compila√ß√£o com a palavra "[" e solte o valor 110:</font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; : ^2 dup * exit [ drop ( 0 ): &gt; 4 ^2 ( 1 ): 16 &gt;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso funciona! </font><font style="vertical-align: inherit;">Vamos </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">continuar ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como continuaremos a escrever o forte, precisamos pensar sobre onde estar√° o c√≥digo fonte do forte e quando compilar. </font><font style="vertical-align: inherit;">Vamos fazer a op√ß√£o mais f√°cil. </font><font style="vertical-align: inherit;">O c√≥digo fonte do forte ser√° colocado no c√≥digo fonte no assembler, como uma sequ√™ncia de texto. </font><font style="vertical-align: inherit;">E para que ele n√£o ocupe muito espa√ßo, o colocaremos imediatamente ap√≥s o endere√ßo aqui, na √°rea de mem√≥ria livre. </font><font style="vertical-align: inherit;">Obviamente, precisamos dessa √°rea para compila√ß√£o, mas a velocidade da "fuga" da interpreta√ß√£o ser√° maior que a necessidade de nova mem√≥ria. </font><font style="vertical-align: inherit;">Assim, o c√≥digo compilado come√ßar√° a sobrescrever a fonte no forte, come√ßando do in√≠cio, mas n√£o precisaremos mais dele, pois j√° lemos e usamos esta se√ß√£o.</font></font><br><br><pre> <code class="cpp hljs">fcode: .ascii <span class="hljs-string"><span class="hljs-string">" 2 2 + . quit"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas, no in√≠cio da linha, vale a pena colocar uma d√∫zia de espa√ßos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para fazer isso funcionar, alteramos o c√≥digo de in√≠cio para que tib, #tib aponte para esta linha. </font><font style="vertical-align: inherit;">No final, √© necess√°rio encerrar a entrada na linha de comando normal do sistema.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iniciando bytecode tornou-se assim</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">start: .byte b_call16 .word forth - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word last_item - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word context - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_get .byte b_set .byte b_call16 .word vhere - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_dup .byte b_call16 .word h - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_set .byte b_call16 .word definitions - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word tib - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_set .byte b_lit16 .word fcode_end - fcode .byte b_call16 .word ntib - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_set .byte b_call16 .word interpret - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_quit</code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lan√ßamento! </font></font><br><br><pre> <code class="plaintext hljs">$ ./forth 4 ( 0 ): &gt;</code> </pre><br>  √ìtimo! <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E agora ... </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compile o compilador com o compilador </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, escrevemos o c√≥digo na linha fcode. </font><font style="vertical-align: inherit;">A primeira coisa a fazer, √© claro, √© a palavra ";".</font></font><br><br><pre> <code class="cpp hljs">: ; ?state <span class="hljs-number"><span class="hljs-number">110</span></span> ?pairs lit8 [ blword <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> find cfa c@ c, ] c, <span class="hljs-number"><span class="hljs-number">0</span></span> state ! <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> [ current @ @ dup c@ <span class="hljs-number"><span class="hljs-number">96</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> swap c! drop</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vou fazer algumas explica√ß√µes. </font></font><br><br><pre> <code class="plaintext hljs">?state 110 ?pairs</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aqui, verificamos se o estado de compila√ß√£o est√° realmente definido e se 110 est√° na pilha, caso contr√°rio, haver√° uma interrup√ß√£o por engano. </font></font><br><br><pre> <code class="plaintext hljs">lit8 [ blword exit find cfa c@ c, ]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√≥s compilamos o comando lit com o bytecode do comando exit. </font><font style="vertical-align: inherit;">Eu tive que entrar no modo de execu√ß√£o, encontrar a palavra exit, obter o endere√ßo de execu√ß√£o e obter o c√≥digo de comando a partir da√≠. </font><font style="vertical-align: inherit;">Tudo isso foi necess√°rio porque ainda n√£o temos a palavra compilar. </font><font style="vertical-align: inherit;">Se fosse, em vez de tudo isso, seria suficiente simplesmente escrever ‚Äúcompile exit‚Äù :)</font></font><br><br><pre> <code class="plaintext hljs">c, 0 state !</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso compilar√° o comando exit quando a palavra ";" for executada e, em seguida, o modo de interpreta√ß√£o ser√° definido. </font><font style="vertical-align: inherit;">A palavra "[" n√£o pode ser usada aqui, pois possui o sinal imediato e √© executada </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agora</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mas precisamos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compilar</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> esses comandos na palavra ";" para que eles desativem o modo de compila√ß√£o.</font></font><br><br><pre> <code class="plaintext hljs">exit [</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√≥s j√° experimentamos isso. </font><font style="vertical-align: inherit;">A palavra exit √© compilada e o modo de compila√ß√£o est√° desativado. </font><font style="vertical-align: inherit;">Tudo, a palavra ";" </font><font style="vertical-align: inherit;">compilado. </font><font style="vertical-align: inherit;">E o que mais est√° escrito l√° ainda mais?</font></font><br><br><pre> <code class="plaintext hljs">current @ @ dup c@ 96 or swap c! drop</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ precisa definir o sinalizador imediato para a nova palavra. </font><font style="vertical-align: inherit;">√â exatamente isso que a sequ√™ncia indicada faz, exceto a palavra drop. </font><font style="vertical-align: inherit;">A palavra drop remove os 110 esquecidos que colocavam a palavra ":" no in√≠cio da cria√ß√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora √© tudo! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lan√ßamos e tentamos.</font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; : ^3 dup dup * * ; ( 0 ): &gt; 6 ^3 . 216 ( 0 ): &gt;</code> </pre><br>  Existe!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta √© a primeira palavra que nosso compilador compilou "de verdade". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas ainda n√£o temos condi√ß√µes, loops e muito mais ... Vamos come√ßar com uma palavra pequena, mas muito necess√°ria para criar um compilador: imediato. </font><font style="vertical-align: inherit;">Ele define o atributo imediato na √∫ltima palavra criada:</font></font><br><br><pre> <code class="cpp hljs">: immediate current @ @ dup c@ <span class="hljs-number"><span class="hljs-number">96</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> swap c! ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma sequ√™ncia familiar :) Recentemente, ele foi escrito manualmente, n√£o ser√° mais necess√°rio. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora vamos fazer algumas palavras pequenas, mas √∫teis:</font></font><br><br><pre> <code class="cpp hljs">: hex <span class="hljs-number"><span class="hljs-number">16</span></span> base ! ; : decimal <span class="hljs-number"><span class="hljs-number">10</span></span> base ! ; : bl <span class="hljs-number"><span class="hljs-number">32</span></span> ; : tab <span class="hljs-number"><span class="hljs-number">9</span></span> ; : lf <span class="hljs-number"><span class="hljs-number">10</span></span> ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hex e decimal definem o sistema num√©rico correspondente. </font><font style="vertical-align: inherit;">O restante s√£o constantes para obter os c√≥digos de caracteres correspondentes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tamb√©m </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">criamos </font><font style="vertical-align: inherit;">uma palavra para copiar uma linha com um contador </font><font style="vertical-align: inherit;">:: cmove sobre c @ 1+ move; </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E agora estaremos envolvidos em condi√ß√µes. </font><font style="vertical-align: inherit;">Em geral, se houvesse uma palavra compilar, ficaria assim:</font></font><br><br><pre> <code class="cpp hljs">: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ?state compile ?nbranch8 here <span class="hljs-number"><span class="hljs-number">0</span></span> c, <span class="hljs-number"><span class="hljs-number">111</span></span> ; immediate : then ?state <span class="hljs-number"><span class="hljs-number">111</span></span> ?pairs dup here swap - swap c! ; immediate</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todas essas palavras no in√≠cio verificam se o modo de compila√ß√£o est√° definido e geram um erro se esse n√£o for o caso. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A palavra if compila uma ramifica√ß√£o condicional, reserva um byte para o par√¢metro de comando de ramifica√ß√£o condicional e envia o endere√ßo desse byte para a pilha. Em seguida, ele empurra o valor de controle 111 para a pilha.A </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">palavra verifica a presen√ßa do valor de controle 111 e grava o deslocamento no endere√ßo na pilha.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E imediatamente fa√ßa a palavra mais. </font><font style="vertical-align: inherit;">No in√≠cio, ele compila o comando de salto incondicional para ignorar o ramo else. </font><font style="vertical-align: inherit;">Da mesma maneira como se, o deslocamento da transi√ß√£o ainda n√£o √© conhecido, √© simplesmente reservado e seu endere√ßo √© empurrado para a pilha. </font><font style="vertical-align: inherit;">Bem, depois disso, exatamente o mesmo √© feito como em seguida: o endere√ßo da transi√ß√£o de captura √© definido como o ramo else. </font><font style="vertical-align: inherit;">Algo √© mais dif√≠cil de descrever do que o pr√≥prio c√≥digo :) Se algu√©m quiser descobrir completamente, √© melhor analisar o trabalho de um c√≥digo t√£o simplificado:</font></font><br><br><pre> <code class="cpp hljs">: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> compile ?nbranch8 here <span class="hljs-number"><span class="hljs-number">0</span></span> c, ; immediate : then dup here swap - swap c! ; immediate</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bem, agora n√≥s programamos o c√≥digo real. </font><font style="vertical-align: inherit;">Como n√£o temos a palavra compilar, aplicamos o mesmo truque ao criar a palavra ";":</font></font><br><br><pre> <code class="cpp hljs">: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ?state lit8 [ blword ?nbranch8 find cfa c@ c, ] c, here <span class="hljs-number"><span class="hljs-number">0</span></span> c, <span class="hljs-number"><span class="hljs-number">111</span></span> ; immediate : then ?state <span class="hljs-number"><span class="hljs-number">111</span></span> ?pairs dup here swap - swap c! ; immediate : <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ?state <span class="hljs-number"><span class="hljs-number">111</span></span> ?pairs lit8 [ blword branch8 find cfa c@ c, ] c, here <span class="hljs-number"><span class="hljs-number">0</span></span> c, swap dup here swap - swap c! <span class="hljs-number"><span class="hljs-number">111</span></span> ; immediate</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora voc√™ pode tentar compilar a condi√ß√£o. </font><font style="vertical-align: inherit;">Vamos criar, por exemplo, uma palavra que imprima 1000 se houver 5 na pilha e 0 em outros casos:</font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; : test 5 = if 1000 . else 0 . then ; ( 0 ): &gt; 22 test 0 ( 0 ): &gt; 3 test 0 ( 0 ): &gt; 5 test 1000 ( 0 ): &gt;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â claro que esse resultado n√£o funcionou imediatamente, houve erros, houve depura√ß√£o. </font><font style="vertical-align: inherit;">Mas no final, as condi√ß√µes funcionaram!</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma pequena digress√£o sobre o comprimento dos comandos de transi√ß√£o</font></font></b> <div class="spoiler_text">  ,       ,      127 .       . ,  ,       .     ,   ,        .   8   ,    40  127    .   ,       ? <br><br>   .   ‚Äî    16 . <br><br>      . 16        ‚Äî    . ,      ,     call,      . , 11     ( 1023   ).         300  1000  .      ,        .      3  ,     8    .    :   (?nbranch),    (?branch)   (branch).  ‚Äî 24 . <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temos condi√ß√µes, a vida fica mais f√°cil :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos fazer uma palavra. "(Aspas). Ele exibe o texto especificado quando executado. √â usado desta maneira:</font></font><br><br><pre> <code class="cpp hljs">.<span class="hljs-string"><span class="hljs-string">"    "</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ pode usar esta palavra apenas no modo de compila√ß√£o. </font><font style="vertical-align: inherit;">Isso ficar√° aparente depois de analisarmos o dispositivo desta palavra:</font></font><br><br><pre> <code class="cpp hljs">: .<span class="hljs-string"><span class="hljs-string">" ?state 34 word dup if lit8 [ blword (."</span></span>) find cfa c@ c, ] c, str, <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> drop then ; immediate</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta palavra √© executada no modo de compila√ß√£o. √â preciso uma sequ√™ncia do fluxo de entrada at√© aspas (34 palavras). Se a linha n√£o puder ser obtida, ela n√£o far√° nada. Embora, aqui seria melhor derivar um diagn√≥stico. Mas para a sa√≠da da linha, essa palavra √© exatamente o que estamos fazendo :) Se necess√°rio, voc√™ poder√° redefinir essa palavra novamente, j√° com diagn√≥stico. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se fosse poss√≠vel obter a sequ√™ncia, o comando byte (. ") √â compilado e a sequ√™ncia recebida. Esse comando byte (aspas entre colchetes), quando executado, exibe a sequ√™ncia que foi compilada atr√°s do byte de comando </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; : test ."    " ; ( 0 ): &gt; test     ( 0 ): &gt;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E, finalmente, vamos compilar a palavra. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â claro que, no modo de compila√ß√£o, essa palavra deve pegar o nome da pr√≥xima palavra do fluxo e encontr√°-la no dicion√°rio. E ent√£o haver√° op√ß√µes: pode ser um comando de byte ou uma palavra escrita em c√≥digo de byte. Essas palavras devem ser compiladas de maneiras diferentes. Portanto, criaremos duas palavras auxiliares: "(compile_b)" e "(compile_c)". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(compile_b) ir√° compilar o comando de chamada para chamar o bytecode. O par√¢metro ser√° uma palavra de 64 bits - o endere√ßo do bytecode que est√° sendo chamado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(compile_c) ir√° compilar o comando byte. Assim, o par√¢metro deste comando ser√° um byte - o c√≥digo do comando. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bem, a pr√≥pria palavra compilar compilar√° (compile_b) ou (compile_c) com os par√¢metros correspondentes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos come√ßar com (compile_c),como no mais simples:</font></font><br><br><pre> <code class="cpp hljs">: (compile_c) r&gt; dup c@ swap <span class="hljs-number"><span class="hljs-number">1</span></span>+ &gt;rc, ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apesar de sua simplicidade, primeiro escrevemos uma palavra em bytecode, que por si s√≥ tem par√¢metros. Portanto, vou comentar. Depois de inserir (compile_c), o endere√ßo de retorno est√° localizado na pilha de retorno, pois n√£o √© trivial. Este √© o endere√ßo do pr√≥ximo byte ap√≥s o comando de chamada. A situa√ß√£o no momento da liga√ß√£o √© mostrada abaixo. A0 - c√≥digo de comando de chamada, XX - par√¢metro de comando de chamada - endere√ßo de chamada (deslocamento) do c√≥digo de bytes da palavra (compile_c).</font></font><br><br><img src="https://habrastorage.org/webt/vj/jh/kh/vjjhkhqa7e35ygxdzclv0lf4-pw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O endere√ßo de retorno indica o byte NN. Geralmente, h√° o c√≥digo para o pr√≥ximo byte do comando. Mas nossa palavra tem par√¢metros, ent√£o NN s√£o apenas os par√¢metros da palavra "(compile_c)", ou seja, o c√≥digo de bytes do comando compilado. Voc√™ precisa ler este byte e alterar o endere√ßo de retorno, movendo-o para o pr√≥ximo comando de byte. Isso √© feito pela sequ√™ncia "r&gt; dup c @ swap 1+&gt; r". Essa sequ√™ncia puxa o endere√ßo de retorno da pilha de retorno para a pilha normal, recupera um byte, adiciona um (endere√ßo de retorno) e retorna para a pilha de retorno. O comando restante "c" compila o c√≥digo de comando byte obtido dos par√¢metros. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(compile_b) n√£o √© muito mais complicado:</font></font><br><br><pre> <code class="cpp hljs">: (compile_b) r&gt; dup @ swap <span class="hljs-number"><span class="hljs-number">8</span></span> + &gt;r compile_b ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tudo √© o mesmo aqui, apenas o par√¢metro de 64 bits √© lido e a palavra compile_b √© usada para compilar a palavra, que j√° criamos para o compilador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E agora a palavra compilar. </font><font style="vertical-align: inherit;">Como j√° discutido, ele l√™ o nome da palavra, encontra-o e compila um dos dois comandos anteriores. </font><font style="vertical-align: inherit;">N√£o vou comentar, j√° aplicamos e desmontamos todas as constru√ß√µes usadas.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compila√ß√£o do Word</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">: compile blword over over find dup <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dup c@ <span class="hljs-number"><span class="hljs-number">128</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cfa c@ (compile_b) [ blword (compile_c) find cfa , ] c, <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> cfa (compile_b) [ blword (compile_b) find cfa , ] , then drop drop <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> drop .<span class="hljs-string"><span class="hljs-string">" compile: "</span></span> type .<span class="hljs-string"><span class="hljs-string">" - not found"</span></span> then ; immediate</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para verificar a palavra criada, criamos, com sua ajuda, a palavra se n√£o. </font></font><br><br><pre> <code class="cpp hljs">: ifnot ?state compile ?branch8 here <span class="hljs-number"><span class="hljs-number">0</span></span> c, <span class="hljs-number"><span class="hljs-number">111</span></span> ; immediate</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Confira! </font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; : test 5 = ifnot 1000 . else 0 . then ; ( 0 ): &gt; 22 test 1000 ( 0 ): &gt; 3 test 1000 ( 0 ): &gt; 5 test 0 ( 0 ): &gt;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Est√° tudo bem! E √© hora de fazer ciclos ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neste artigo, faremos ciclos com uma condi√ß√£o. O forte tem duas op√ß√µes para um ciclo com uma condi√ß√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A primeira op√ß√£o √© come√ßar ... at√©. A palavra at√© remove o valor da pilha e, se n√£o for igual a zero, o ciclo termina. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A segunda op√ß√£o √© come√ßar ... enquanto ... repetir. Nesse caso, a verifica√ß√£o ocorre quando a palavra while √© executada. O loop sai se o valor na pilha for zero. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os ciclos no forte s√£o feitos da mesma maneira que as condi√ß√µes - em transi√ß√µes condicionais e incondicionais. Trago o c√≥digo, acho que coment√°rios n√£o s√£o necess√°rios.</font></font><br><br><pre> <code class="cpp hljs">: begin ?state here <span class="hljs-number"><span class="hljs-number">112</span></span> ; immediate : until ?state <span class="hljs-number"><span class="hljs-number">112</span></span> ?pairs compile ?nbranch8 here - c, ; immediate : <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ?state <span class="hljs-number"><span class="hljs-number">112</span></span> ?pairs compile ?nbranch8 here <span class="hljs-number"><span class="hljs-number">0</span></span> c, <span class="hljs-number"><span class="hljs-number">113</span></span> ; immediate : repeat ?state <span class="hljs-number"><span class="hljs-number">113</span></span> ?pairs swap compile branch8 here - c, dup here swap - swap c! ; immediate</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hoje terminamos o compilador. </font><font style="vertical-align: inherit;">Ainda resta muito pouco. </font><font style="vertical-align: inherit;">Das principais fun√ß√µes que ainda n√£o foram implementadas s√£o apenas ciclos com um contador. </font><font style="vertical-align: inherit;">E tamb√©m vale a pena deixar o comando exit loop sair. </font><font style="vertical-align: inherit;">Faremos isso na pr√≥xima vez. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas n√£o experimentamos o comando cycle! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazemos isso escrevendo as palavras padr√£o. </font><font style="vertical-align: inherit;">Finalmente devemos ver o nosso dicion√°rio. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para fazer isso, no in√≠cio, criamos a palavra link @. </font><font style="vertical-align: inherit;">Ele extrair√° o campo de comunica√ß√£o da entrada do dicion√°rio (deslocada para a entrada anterior). </font><font style="vertical-align: inherit;">Como lembramos, o campo de comunica√ß√£o pode ter um tamanho diferente: 1, 2, 4 ou 8 bytes. </font><font style="vertical-align: inherit;">Essa palavra pegar√° na pilha o endere√ßo da entrada do dicion√°rio e retornar√° dois valores: o endere√ßo do campo de nome e o valor do campo de comunica√ß√£o.</font></font><br><br><pre> <code class="cpp hljs">: link@ dup c@ <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> swap <span class="hljs-number"><span class="hljs-number">1</span></span>+ swap dup <span class="hljs-number"><span class="hljs-number">0</span></span>= <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> drop dup <span class="hljs-number"><span class="hljs-number">1</span></span>+ swap c@ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> dup <span class="hljs-number"><span class="hljs-number">1</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> drop dup <span class="hljs-number"><span class="hljs-number">2</span></span> + swap w@ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> drop dup <span class="hljs-number"><span class="hljs-number">4</span></span> + swap i@ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> drop dup <span class="hljs-number"><span class="hljs-number">8</span></span> + swap @ then then then ;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E agora voc√™ pode fazer a palavra palavras: </font></font><br><br><pre> <code class="cpp hljs">: words context @ @ <span class="hljs-number"><span class="hljs-number">0</span></span> begin + dup link@ swap count type tab emit dup <span class="hljs-number"><span class="hljs-number">0</span></span>= until drop drop ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A iniciar ... </font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; words words link@ repeat while until begin ifnot compile (compile_b) (compile_c) ." else then if cmove tab bl decimal hex immediate ; bye ?state ?pairs : str, interpret $compile compile_b compile_n compile_1248 compile_c c, w, i, , allot here h test_bv test_bvc [ ] state .s &gt;in #tib tib . #&gt; #s 60 # hold span holdpoint holdbuf base quit execute cfa find word blword var16 var8 (.") (") count emit expect type lshift rshift invert xor or and &gt;= &lt;= &gt; &lt; = 0&gt; 0&lt; 0= bfind compare syscall fill move rpick r@ r&gt; &gt;r -! +! i! i@ w! w@ c! c@ ! @ depth roll pick over -rot rot swap drop dup abs /mod mod / * - + 1+ 1- exit ?nbranch16 ?nbranch8 ?branch16 ?branch8 branch16 branch8 call8b0 call64 call32 call16 call8f lit64 lit32 lit16 lit8 8 4 3 2 1 0 context definitions current forth ( 0 ): &gt;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui est√°, nossa riqueza :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu queria dizer tudo ... n√£o, no entanto, vamos permitir especificar um arquivo com um programa forte para compila√ß√£o e execu√ß√£o como par√¢metro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Criamos comandos syscall para abrir, fechar e ler o arquivo. </font><font style="vertical-align: inherit;">Definimos as constantes necess√°rias para elas.</font></font><br><br><pre> <code class="cpp hljs">: file_open <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> syscall ; : file_close <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> syscall ; : file_read <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> syscall ; : file_O_RDONLY <span class="hljs-number"><span class="hljs-number">0</span></span> ; : file_O_WRONLY <span class="hljs-number"><span class="hljs-number">1</span></span> ; : file_O_RDWR <span class="hljs-number"><span class="hljs-number">3</span></span> ;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora voc√™ pode fazer a palavra inicial _start: </font></font><br><br><pre> <code class="cpp hljs">: _start <span class="hljs-number"><span class="hljs-number">0</span></span> pick <span class="hljs-number"><span class="hljs-number">1</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> pick file_O_RDONLY <span class="hljs-number"><span class="hljs-number">0</span></span> file_open dup <span class="hljs-number"><span class="hljs-number">0</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .\<span class="hljs-string"><span class="hljs-string">" error: \" . quit then dup here 32 + 32768 file_read dup 0&lt; if .\" error: \" . quit then swap file_close drop #tib ! here 32 + tib ! 0 &gt;in ! interpret then ;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta palavra ser√° carregada do arquivo e executar√° qualquer programa fort. </font><font style="vertical-align: inherit;">Mais precisamente, o int√©rprete executar√° tudo o que estiver neste arquivo. </font><font style="vertical-align: inherit;">E pode haver, por exemplo, uma compila√ß√£o de novas palavras e sua execu√ß√£o. </font><font style="vertical-align: inherit;">O nome do arquivo √© indicado pelo primeiro par√¢metro na inicializa√ß√£o. </font><font style="vertical-align: inherit;">N√£o entrarei em detalhes, mas os par√¢metros de inicializa√ß√£o no Linux s√£o passados ‚Äã‚Äãpela pilha. </font><font style="vertical-align: inherit;">A palavra _start os alcan√ßar√° com os comandos 0 pick (n√∫mero de par√¢metros) e 2 pick (ponteiro para o primeiro par√¢metro). </font><font style="vertical-align: inherit;">Para um sistema forte, esses valores est√£o fora da pilha, mas voc√™ pode obt√™-los com o comando pick. </font><font style="vertical-align: inherit;">O tamanho do arquivo √© limitado a 32 KB, enquanto n√£o h√° gerenciamento de mem√≥ria. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora resta escrever na linha fcode no final:</font></font><br><br><pre> <code class="cpp hljs">_start quit</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crie um arquivo test.f e escreva algo no forte. </font><font style="vertical-align: inherit;">Por exemplo, o algoritmo euclidiano para encontrar o maior fator comum:</font></font><br><br><pre> <code class="cpp hljs">: NOD begin over over &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> over over &gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> swap over - swap <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> over - then repeat drop ; <span class="hljs-number"><span class="hljs-number">23101</span></span> <span class="hljs-number"><span class="hljs-number">44425</span></span> NOD . bye</code> </pre><br>  Come√ßamos. <br><br><pre> <code class="plaintext hljs">$ ./forth test.f 1777 Bye! $</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A resposta est√° correta. </font><font style="vertical-align: inherit;">A palavra foi compilada e depois cumprida. </font><font style="vertical-align: inherit;">O resultado √© exibido e o comando bye foi executado. </font><font style="vertical-align: inherit;">Se voc√™ remover as duas √∫ltimas linhas, a palavra NOD ser√° adicionada ao dicion√°rio e o sistema passar√° √† sua linha de comando. </font><font style="vertical-align: inherit;">Voc√™ j√° pode escrever programas :-)</font></font><br><br>  S√≥ isso.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quem se importa, voc√™ pode baixar o c√≥digo-fonte ou o bin√°rio pronto para Linux no x86-64 no Github: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/hal9000cc/forth64 As</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fontes v√™m com uma licen√ßa </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNU GPL v2</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DCH v1 - Fa√ßa o que voc√™ quiser :-)</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt437466/">https://habr.com/ru/post/pt437466/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt437454/index.html">Revis√£o do aritm√¥metro Felix M</a></li>
<li><a href="../pt437456/index.html">Mais jovem: Revis√£o dos telefones IP Snom D315 e D305</a></li>
<li><a href="../pt437458/index.html">Registro obrigat√≥rio pela oferta do IMEI para efetuar pagamentos</a></li>
<li><a href="../pt437460/index.html">Exemplo de unidade flash falsa de 32 GB</a></li>
<li><a href="../pt437464/index.html">Pre√ßo TypeScript</a></li>
<li><a href="../pt437468/index.html">Retropie Dreamcast</a></li>
<li><a href="../pt437470/index.html">Algumas palavras simples sobre defesa antim√≠sseis</a></li>
<li><a href="../pt437472/index.html">Transi√ß√£o do escrit√≥rio para udalenka: compartilhando experi√™ncias e hacks</a></li>
<li><a href="../pt437474/index.html">Otimize o desempenho do jogo com as op√ß√µes de importa√ß√£o de som do Unity</a></li>
<li><a href="../pt437476/index.html">Ok Yandex! Onde est√£o nossas metas de alcance?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>