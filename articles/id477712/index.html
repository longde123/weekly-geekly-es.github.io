<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧕 ✌🏼 📦 Objek versus Struktur Data 🕷️ 🔻 🐦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel tersebut, terjemahan yang diusulkan di bawah ini, Robert Martin tampaknya mulai dengan pemikiran yang sangat mirip dengan yang dapat dil...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Objek versus Struktur Data</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477712/"><p>  Dalam artikel tersebut, terjemahan yang diusulkan di bawah ini, Robert Martin tampaknya mulai dengan pemikiran yang sangat mirip dengan yang dapat dilihat dalam diskusi Yegor Bugaenko tentang ORM, tetapi yang lain menarik kesimpulan.  Secara pribadi, pendekatan Yegor membuat saya terkesan, tetapi saya pikir Martin mengungkapkan topik itu lebih terinci.  Sepertinya saya perlu berkenalan dengan semua orang yang pernah berpikir tentang tempat ORM mana yang harus diambil dan secara umum, mengapa kita membutuhkan objek di mana semua bidang terbuka.  Artikel ini ditulis dalam genre "Dialog", di mana seorang programmer yang lebih berpengalaman membahas masalah dengan seseorang yang kurang berpengalaman. </p><br><blockquote>  Apa itu kelas? </blockquote><p>  Kelas adalah spesifikasi dari banyak objek serupa. </p><br><blockquote>  Apa itu objek? </blockquote><p>  Objek adalah serangkaian fungsi yang melakukan tindakan dengan data yang dienkapsulasi. </p><br><blockquote>  Atau lebih baik mengatakan bahwa objek adalah serangkaian fungsi yang melakukan tindakan dengan data yang keberadaannya tersirat </blockquote><p>  Dalam arti "tersirat"? </p><a name="habracut"></a><br><blockquote>  Setelah objek memiliki fungsi, dapat diasumsikan bahwa ada juga data di sana, tetapi tidak ada akses langsung ke data dan mereka tidak terlihat sama sekali dari luar. </blockquote><p>  Bukankah data dalam objek? </p><br><blockquote>  Mungkin memang begitu, tetapi aturan yang mengatakan bahwa mereka harus ada adalah tidak.  Dari sudut pandang pengguna, suatu objek tidak lebih dari sekumpulan fungsi.  Data yang berfungsi dengan fungsi ini harus ada, tetapi posisi data ini tidak diketahui pengguna. </blockquote><p>  Baiklah, katakan saja. </p><br><blockquote>  Nah, apa itu struktur data? </blockquote><p>  Struktur data adalah kumpulan item terkait. </p><br><blockquote>  Atau, dengan kata lain, struktur data adalah seperangkat elemen yang berfungsi berfungsi, keberadaannya tersirat secara implisit. </blockquote><p>  Baik, baik.  Saya mengerti.  Fungsi yang bekerja dengan struktur data tidak didefinisikan di dalam struktur ini, tetapi dari keberadaan struktur data kita dapat menyimpulkan bahwa pasti ada sesuatu yang bekerja dengannya. </p><br><blockquote>  Benar  Dan bagaimana dengan dua definisi ini? </blockquote><p>  Dalam arti tertentu, mereka saling bertentangan. </p><br><blockquote>  Sungguh.  Mereka saling melengkapi.  Seperti tangan dan sarung tangan. <br><ul><li>  Objek adalah seperangkat fungsi yang bekerja dengan elemen data yang keberadaannya tersirat secara implisit. </li><li>  Struktur data adalah sekumpulan elemen data yang fungsinya berfungsi, keberadaannya tersirat secara implisit. </li></ul><br></blockquote><p>  Wow!  Jadi ternyata objek dan struktur data bukan hal yang sama! </p><br><blockquote>  Benar  Struktur data adalah DTO. </blockquote><p>  Dan tabel dalam database juga bukan objek, kan? </p><br><blockquote>  Benar lagi.  Database berisi struktur data, bukan objek. </blockquote><p>  Tunggu sebentar.  Bukankah ORM memetakan tabel dari database ke objek? </p><br><blockquote>  Tentu saja tidak.  Anda tidak bisa memetakan tabel database ke objek.  Tabel dalam database adalah struktur data, bukan objek. </blockquote><p>  Lalu apa yang dilakukan ORM? </p><br><blockquote>  Mereka mentransfer data dari satu struktur ke struktur lainnya. </blockquote><p>  Jadi mereka tidak ada hubungannya dengan Objects? </p><br><blockquote>  Tidak ada sama sekali.  Sebenarnya, hal seperti ORM dalam arti teknologi yang memetakan data relasional ke objek tidak ada, karena tabel tidak dapat dipetakan dari database ke objek. </blockquote><p>  Tetapi mereka mengatakan kepada saya bahwa ORM mengumpulkan objek bisnis. </p><br><blockquote>  Tidak, ORM mengambil data dari database yang bekerja dengan objek bisnis </blockquote><p>  Tapi bukankah struktur data ini jatuh ke dalam objek bisnis? </p><br><blockquote>  Mungkin mereka mengerti, atau mungkin juga tidak.  ORM tidak tahu apa-apa tentang ini. </blockquote><p>  Tetapi perbedaannya adalah murni semantik. </p><br><blockquote>  Tidak, tidak  Ada konsekuensi yang jauh jangkauannya. </blockquote><p>  Misalnya? </p><br><blockquote>  Misalnya, desain skema database dan desain objek bisnis.  Objek bisnis menentukan perilaku bisnis.  Skema basis data mendefinisikan struktur data bisnis.  Struktur ini dibatasi oleh kekuatan yang sangat berbeda.  Struktur data bisnis belum tentu merupakan struktur terbaik untuk perilaku bisnis. </blockquote><p>  Eeee.  Ini tidak bisa dipahami. </p><br><blockquote>  Pikirkan seperti itu.  Skema data tidak dirancang untuk satu aplikasi tunggal, ini dimaksudkan untuk digunakan di seluruh perusahaan.  Oleh karena itu, struktur data adalah kompromi antara beberapa aplikasi yang berbeda. </blockquote><p>  Ini bisa dimengerti. </p><br><blockquote>  Bagus  Sekarang pikirkan setiap aplikasi.  Model objek dari setiap aplikasi menjelaskan bagaimana perilaku aplikasi terstruktur.  Setiap aplikasi akan memiliki model objeknya sendiri agar lebih sesuai dengan perilaku aplikasi. </blockquote><p>  Ahh, begitu.  Karena skema data adalah kompromi antara aplikasi yang berbeda, skema tersebut tidak akan jatuh pada model objek dari setiap aplikasi individual. </p><br><blockquote>  Benar!  Objek dan Struktur terbatas pada hal-hal yang berbeda.  Mereka sangat jarang cocok bersama.  Orang-orang menyebut ini ketidakcocokan impedansi objek-relasional. </blockquote><p>  Sesuatu yang saya ingat.  Tetapi tampaknya ketidakcocokan impedansi baru saja diperbaiki menggunakan ORM. </p><br><blockquote>  Dan sekarang Anda tahu bahwa ini tidak benar.  Ketidakcocokan impedansi antara objek dan struktur data saling melengkapi, bukan isomorfik. </blockquote><p>  Apa? </p><br><blockquote>  Mereka bertolak belakang, bukan sesuatu yang serupa. </blockquote><p>  Berlawanan? </p><br><blockquote>  Ya, dalam arti yang sangat menarik.  Anda lihat, objek dan struktur data menyiratkan struktur kontrol yang berlawanan secara diametral. </blockquote><p>  Apa? </p><br><blockquote>  Pikirkan seperangkat kelas yang mengimplementasikan beberapa jenis antarmuka umum.  Misalnya, bayangkan kelas yang mewakili angka dua dimensi, di mana ada fungsi untuk menghitung luas dan keliling gambar. </blockquote><p>  Berapa banyak bentuk mendorong kode dengan objek dalam semua contoh? </p><br><blockquote>  Mari kita lihat dua jenis bentuk: Kotak dan Lingkaran.  Jelas bahwa fungsi untuk menghitung luas dan keliling kelas-kelas ini menggunakan struktur data yang berbeda.  Juga dipahami bahwa operasi ini dipanggil menggunakan polimorfisme dinamis. </blockquote><p>  Tolong pelan-pelan, tidak ada yang jelas. </p><br><blockquote>  Ada dua fungsi berbeda untuk menghitung area, satu untuk Square, yang lain untuk Circle.  Ketika suatu fungsi dipanggil untuk menghitung area objek tertentu, objek inilah yang memutuskan fungsi mana yang akan dipanggil.  Ini disebut polimorfisme dinamis. </blockquote><p>  Baiklah  Tentu saja  Suatu objek tahu bagaimana metodenya diimplementasikan.  Secara alami. </p><br><blockquote>  Sekarang mari kita ubah objek-objek ini menjadi struktur data.  Kami menggunakan Serikat yang Didiskriminasi. </blockquote><p>  Didiskriminasi apa? </p><br><blockquote>  Serikat yang Didiskriminasi.  Nah, C ++, pointer, kata kunci serikat, bendera untuk menentukan jenis struktur, Serikat Diskriminasi.  Dalam kasus kami, ini hanya dua struktur data yang berbeda.  Satu untuk Square dan satu untuk Circle.  Lingkaran memiliki titik pusat dan jari-jari.  Dan kode jenis dari mana dapat dipahami bahwa itu adalah Lingkaran. </blockquote><p>  Kolom dengan kode akan enum? </p><br><blockquote>  Ya benar.  Dan Square akan memiliki titik kiri atas dan panjang sisi.  Dan juga enum untuk menunjukkan jenisnya. </blockquote><p>  Baiklah  Akan ada dua struktur dengan kode jenis. </p><br><blockquote>  Benar  Sekarang mari kita lihat fungsi untuk area tersebut.  Mungkin akan ada saklar, kan? </blockquote><p>  Baik.  Tentu saja untuk dua kelas.  Cabang untuk Alun-alun dan untuk Lingkaran.  Dan untuk perimeter, Anda juga membutuhkan sakelar yang serupa. </p><br><blockquote>  Dan lagi, benar.  Sekarang pikirkan dua skenario ini.  Dalam skenario dengan objek, dua implementasi fungsi untuk suatu area independen satu sama lain dan termasuk (dalam arti tertentu) langsung ke tipe.  Fungsi untuk area Square adalah milik Square, dan fungsi untuk menentukan area Circle adalah milik Circle. </blockquote><p>  Oke, saya mengerti apa yang Anda tuju.  Dalam skenario dengan struktur data, kedua implementasi fungsi untuk area berada dalam fungsi yang sama, mereka tidak "milik" (apa pun kata itu berarti) untuk tipe. </p><br><blockquote>  Lebih jauh lebih baik.  Dalam hal objek, jika Anda perlu menambahkan tipe Segitiga, kode apa yang harus diubah? </blockquote><p>  Jangan mengubah apa pun.  Buat saja kelas Segitiga baru.  Meskipun tidak, Anda mungkin perlu memperbaiki kode yang membuat objek. </p><br><blockquote>  Benar  Jadi, saat menambahkan tipe baru, perubahannya dapat diabaikan.  Sekarang anggaplah Anda perlu menambahkan fungsi baru - misalnya, fungsi untuk menentukan pusat. </blockquote><p>  Maka Anda harus menambahkannya ke ketiga jenis, Lingkaran, Kotak dan Segitiga. </p><br><blockquote>  Bagus  Ternyata menambahkan fungsi baru itu sulit, karena Anda harus membuat perubahan di setiap kelas. </blockquote><p>  Tetapi dengan struktur data, semuanya berbeda.  Untuk menambahkan Segitiga, Anda harus mengubah setiap fungsi untuk menambahkan cabang untuk menangani Segitiga di setiap sakelar. </p><br><blockquote>  Benar  Sulit untuk menambahkan tipe, Anda harus mengedit setiap fungsi. </blockquote><p>  Tetapi untuk menambahkan fungsi untuk pusat, tidak ada yang perlu diubah. </p><br><blockquote>  Ya, menambahkan fitur itu mudah. </blockquote><p>  Wow  Ternyata kedua pendekatan ini bertolak belakang. </p><br><blockquote>  Jelas ya.  Untuk meringkas </blockquote><br><ul><li>  Sulit untuk menambahkan fungsi baru ke kelas, Anda harus membuat perubahan di setiap kelas </li><li>  Menambahkan fungsi baru ke struktur data sederhana, Anda hanya perlu menambahkan fungsi, tidak ada lagi yang perlu diubah </li><li>  Menambahkan tipe baru ke kelas itu sederhana, Anda hanya perlu menambahkan kelas baru </li><li>  Sulit untuk menambahkan tipe baru untuk struktur, Anda perlu memperbaiki setiap fungsi </li></ul><br><p>  Ya  Berlawanan.  Berlawanan dengan rasa ingin tahu.  Artinya, jika diketahui sebelumnya bahwa fungsi baru perlu ditambahkan, akan lebih mudah untuk menggunakan struktur data.  Tetapi jika Anda tahu sebelumnya bahwa Anda harus menambahkan tipe baru, maka Anda perlu menggunakan kelas. </p><br><blockquote>  Pengamatan yang bagus!  Tetapi hari ini kita perlu memikirkan satu hal lagi.  Ada titik lain di mana struktur data dan kelas saling bertentangan.  Ketergantungan. </blockquote><p>  Kecanduan? </p><br><blockquote>  Ya, arah dependensi dalam kode sumber. </blockquote><p>  Oke, saya akan bertanya.  Apa bedanya? </p><br><blockquote>  Mari kita lihat kasus struktur.  Setiap fungsi berisi sakelar yang memilih implementasi yang diinginkan berdasarkan pada kode jenis dalam gabungan. </blockquote><p>  Ya, benar.  Jadi apa </p><br><blockquote>  Mari kita lihat fungsi panggil untuk area tersebut.  Kode panggilan tergantung pada fungsi untuk area tersebut, dan fungsi untuk area tersebut tergantung pada setiap implementasi spesifik. </blockquote><p>  Dan apa yang Anda maksud ketika Anda mengatakan "tergantung"? </p><br><blockquote>  Bayangkan bahwa setiap implementasi fungsi untuk area dialokasikan ke fungsi yang terpisah.  Artinya, akan ada fungsi circleArea, squareArea dan triangleArea. </blockquote><p>  Nah, ternyata di cabang switch hanya akan ada panggilan ke fungsi-fungsi ini. </p><br><blockquote>  Bayangkan bahwa fungsi-fungsi ini ada di file yang berbeda. </blockquote><p>  Kemudian dalam file dengan saklar akan diimpor atau digunakan atau disertakan untuk file dengan fungsi. </p><br><blockquote>  Benar  Ini adalah ketergantungan pada level kode sumber.  Satu sumber tergantung pada sumber lain.  Bagaimana ketergantungan ini diarahkan? </blockquote><p>  Kode sumber dengan sakelar bergantung pada kode sumber tempat implementasi. </p><br><blockquote>  Bagaimana dengan kode yang memanggil fungsi untuk area tersebut? </blockquote><p>  Kode panggilan tergantung pada kode dengan saklar, yang tergantung pada semua implementasi. </p><br><blockquote>  Benar  Di semua sumber, panah diarahkan ke arah panggilan, dari kode panggilan ke implementasi.  Jadi jika Anda ingin membuat perubahan kecil dalam implementasi ini ... </blockquote><p>  Oke, oke, saya mengerti apa yang Anda maksud.  Perubahan dalam salah satu implementasi akan memerlukan kompilasi ulang semua file dengan sakelar, dan ini akan mengarah pada kenyataan bahwa semua yang memanggil sakelar ini akan dikompilasi ulang, misalnya, dalam kasus kami, fungsi untuk area. </p><br><blockquote>  Ya  Setidaknya demikian untuk bahasa yang menggunakan tanggal modifikasi file untuk memahami apa yang perlu dibangun kembali. </blockquote><p>  Dan ini umumnya semua sistem dengan pengetikan statis, bukan? </p><br><blockquote>  Ya, dan beberapa sistem lain tanpa itu </blockquote><p>  Ini harus banyak dibangun kembali. </p><br><blockquote>  Dan banyak yang harus diulang. </blockquote><p>  Oke, tetapi dalam hal kelas sebaliknya? </p><br><blockquote>  Ya, karena kode yang memanggil fungsi untuk area tergantung pada antarmuka, dan implementasinya juga tergantung pada antarmuka ini. </blockquote><p>  Saya melihat.  Kode untuk kelas Square akan mengimpor atau menggunakan atau menyertakan file dengan antarmuka Bentuk. </p><br><blockquote>  Benar  Panah dalam file implementasi menunjuk ke arah yang berlawanan dengan panggilan.  Ini diarahkan dari kode implementasi ke kode panggilan.  Setidaknya ini akan menjadi kasus untuk bahasa yang diketik secara statis.  Untuk bahasa yang diketik secara dinamis, kode yang memanggil fungsi untuk area tersebut tidak bergantung pada apa pun, karena menghubungkan terjadi di runtime. </blockquote><p>  Ya baiklah  Yaitu, jika Anda membuat perubahan pada salah satu implementasi ... </p><br><blockquote>  Anda hanya perlu membangun kembali dan menginstal ulang kode dengan perubahan ini. </blockquote><p>  Ini karena dependensi diarahkan berlawanan dengan arah panggilan. </p><br><blockquote>  Ya, kami menyebutnya inversi ketergantungan. </blockquote><p>  Oke, mari kita simpulkan semuanya.  Kelas dan struktur data saling bertentangan dalam tiga hal. </p><br><ul><li>  Fungsinya ada di kelas secara eksplisit, dan Anda hanya bisa menebak tentang keberadaan data.  Struktur data secara eksplisit hadir dalam struktur data, dan Anda hanya bisa menebak fungsi apa yang tersedia. </li><li>  Dalam kasus kelas, menambahkan tipe itu sederhana, tetapi menambahkan fungsi itu sulit.  Dalam hal struktur, menambahkan fungsi itu mudah, tetapi menambahkan tipe itu sulit. </li><li>  Struktur data mengarah pada kompilasi dan redistribusi kode panggilan.  Kelas mengisolasi kode panggilan dan tidak perlu mengkompilasi ulang dan menggunakan lagi. </li></ul><br><blockquote>  Ya itu benar.  Dan ini harus diingat oleh setiap desainer dan arsitek perangkat lunak. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id477712/">https://habr.com/ru/post/id477712/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id477696/index.html">Domain front-end berdasarkan TLS 1.3. Bagian 2</a></li>
<li><a href="../id477700/index.html">Prinsip Hollywood (IoC)</a></li>
<li><a href="../id477704/index.html">CodeSide. Game baru untuk kompetisi Piala AI Rusia yang terkenal</a></li>
<li><a href="../id477706/index.html">Konten campuran saat mengunduh dari HTTPS: cara menemukan dan mengatasinya</a></li>
<li><a href="../id477710/index.html">Apa yang tidak mereka ajarkan di sekolah: bagaimana kami melatih teknisi pendukung teknis</a></li>
<li><a href="../id477716/index.html">Matematikawan menggunakan contoh "tag" menghitung bagaimana keacakan terjadi</a></li>
<li><a href="../id477718/index.html">Lapisan konvolusional: konvolusi cepat sesuai dengan metode Shmuel Vinograd</a></li>
<li><a href="../id477722/index.html">Panduan Gaya Google di C ++. Bagian 8</a></li>
<li><a href="../id477724/index.html">Habraseminar merek SDM: tentang bakat, perburuan, dan konten</a></li>
<li><a href="../id477728/index.html">Apa yang harus dilakukan memimpin tim sehingga tim tidak kehabisan tenaga</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>