<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ“– ğŸ§‘ğŸ¾â€ğŸ¤â€ğŸ§‘ğŸ¾ ğŸ¤ğŸ» Cara menemukan bug di mikroprosesor yang dirilis tiga puluh lima tahun yang lalu ğŸ‡ ğŸ‘©ğŸ½â€ğŸ”§ ğŸ©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sulit dipercaya, tetapi terkadang kesalahan pada prosesor pada dasarnya hidup lebih lama dari prosesor itu sendiri. Baru-baru ini saya kebetulan diyak...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara menemukan bug di mikroprosesor yang dirilis tiga puluh lima tahun yang lalu</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471020/"><p><img src="https://habrastorage.org/webt/zj/dz/om/zjdzomhyfadpxobr7ok9wppvvve.jpeg" alt="K1801VM1A"></p><br><p>  Sulit dipercaya, tetapi terkadang kesalahan pada prosesor pada dasarnya hidup lebih lama dari prosesor itu sendiri.  Baru-baru ini saya kebetulan diyakinkan tentang hal ini dengan contoh mikroprosesor 16-bit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1801BM1A</a> , yang menjadi dasar pembuatan keluarga komputer rumah tangga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BK-0010 / 11M</a> di USSR pada satu waktu.  Tentang keluarga ini di HabrÃ© berulang kali menulis. </p><a name="habracut"></a><br><p> Periode kehidupan aktif BeKashek jatuh pada akhir 80-an - awal 90-an abad terakhir.  Pada tahun-tahun ini, melalui upaya banyak penggemar tunggal, serta kelompok anggota lingkaran dan kooperator, susunan utama program aplikasi BC dikembangkan: game, utilitas, berbagai "DOS" (sistem operasi disk).  Sejalan dengan pengembangan perangkat lunak, perangkat dibuat di mana perangkat lunak sistem mereka ditulis.  Secara umum, ekosistem dari komputer mirip-PDP 16-bit ini dikembangkan sesuai dengan prinsip-prinsip yang sama, seperti, misalnya, arsitektur terbuka 8-bit awal berbasis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Intel 8080</a> dan bus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">S-100</a> dikembangkan.  Kemudian, ketika kita menjauh dari peran utilitarian BC, fokus dalam pemrograman telah bergeser ke arah demoscene. </p><br><p>  Volume perangkat lunak untuk BC dapat diperkirakan dengan mengunjungi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">umum</a> dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">koleksi</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">program</a> .  Tentu saja, sebagai perbandingan, misalnya, dengan ZX-Spectrum, volume ini jauh lebih sederhana.  Namun demikian, bahkan volume seperti itu, tampaknya, sudah cukup untuk menyiasati semua celah dan celah kode mesin.  Apakah mungkin untuk menemukan sesuatu yang tidak biasa dalam perilaku prosesor, setelah lebih dari tiga puluh tahun berlatih menggunakannya?  Ternyata - ya!  Ini akan dibahas di bawah. </p><br><p>  Mungkin masuk akal untuk menceritakan kisah ini dalam urutan kronologis.  Pertama-tama, saya harus segera mencatat bahwa saya sama sekali bukan "programmer dengan pengalaman", baik oleh pekerjaan, maupun dengan menjadi anggota kelompok penggemar SM, tentang siapa yang saya tulis di atas.  Saya datang ke BC secara tidak langsung, sebagian melalui nostalgia untuk hobi masa kanak-kanak dan remaja (elektronik analog dan digital, majalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Young Technician</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">UT-88</a> dan kerajinan tangan dan ketidaksempurnaan lainnya), dan sebagian lagi karena minat saya pada arsitektur dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sistem komando PDP-11</a> .  Saya tidak punya BK "di perangkat keras" dan saya biasanya menjalankan program untuk BK dan men-debug-nya di emulator <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bkemu</a> di tablet untuk Android. </p><br><p>  Beberapa waktu yang lalu, saya tertarik pada program <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kaleidoskop, yang</a> ditulis oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Li-Chen Wang-a</a> .  Program ini ditulis dalam kode mesin pada tahun 1976, untuk mikroprosesor Intel 8080 sebagai bagian dari komputer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Altair 8800</a> dengan adaptor grafis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cromemco Dazzler</a> .  Saya ingin menganalisis algoritma Li-Chen Wang-a secara rinci dan, pada saat yang sama, port ke BC.  Saya harus mengatakan bahwa keinginan untuk mengirim Kaleidoscope ke BC telah diungkapkan di antara para demoscener sebelumnya, dan bahkan ada upaya untuk menguraikan algoritma, tetapi mereka tidak berhasil. </p><br><p>  Dalam artikel saya berikutnya, saya mungkin akan menganalisis algoritma ini secara rinci (dan untuk yang tidak sabar, saya akan memposting tautan ke sumber lintas-platform Kaleidoscope di bawah libSDL di C).  Untuk masa depan, itu akan cukup untuk menunjukkan bahwa masalah telah terpecahkan, dan Kaleidoscope berhasil diangkut ke BC.  Selain itu, generasi suara ditambahkan ke algoritma pada CD, dan, karena gambar dan suara dihasilkan oleh kode yang sama, kita dapat mengatakan bahwa gambar itu sendiri berbunyi (seluruh demo cocok dengan kurang dari 256 byte kode mesin, dan, Saya berharap ini akan disajikan kepada publik di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CAFe Demoparty 2019</a> di Kazan pada akhir Oktober). </p><br><p>  Setelah selesai menulis dan men-debug program saya di emulator, saya menoleh ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Damir ("Adamych") Nasyrov</a> (dia adalah salah satu penyelenggara CAFe Demoparty dan orang yang sangat terkenal di kalangan pembuat demos) dengan permintaan untuk memeriksa eksekusi program pada BC yang sebenarnya.  Saya terutama tertarik pada reproduksi suara, karena timing di emulator dapat berbeda dari timing pada hardware nyata.  Apa kekecewaan saya ketika Damir memberi tahu saya bahwa ada gambar pada BC nyata, tetapi tidak ada suara! </p><br><p>  Beberapa malam berikutnya dihabiskan dengan mencoba mengurangi dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi sistem</a> pada BK-0011M dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diagram sirkuit</a> , di mana mungkin ada kesalahan dengan suara.  Suara di BC diatur cukup sederhana: bit ke-6 dalam register I / O dengan alamat oktal 177716 (register kontrol perekam kaset) adalah output melalui buffer ke speaker piezoelektrik (pager).  Selain kategori 6, bit 2 dan 5 dari register yang sama terhubung ke konverter digital-ke-analog paling sederhana dengan 4 resistor.  Dari output konverter ini, suara dapat masuk ke tape recorder.  Semuanya sangat jelas dan logis, tetapi tidak ada suara keras kepala pada BK nyata, terlepas dari kombinasi bitmask yang saya coba terapkan pada output data ke register ini.  Secara paralel, semua emulator BK yang saya tahu dipasang dan diuji - dan suaranya bekerja di semua orang! </p><br><p>  Pada titik tertentu, saya bahkan hampir berhasil meyakinkan Damir bahwa BK-nya salah, tetapi perilaku itu diulang pada BK-0011M langsung lainnya, juga pada BK-0010.  Saya kehabisan ide, dan penduduk saluran telegram pada tema BC, juga tidak bisa mengatakan apa-apa ... Namun, insiden itu membantu, seperti biasa.  Dalam perjalanan salah satu percobaan, Damir meluncurkan demo pada emulator untuk memastikan bahwa ada suara di emulator.  Dan di sini dia berhasil memperhatikan bahwa tidak hanya ada suara di emulator, tetapi tidak pada BC, tetapi juga gambar-gambar di emulator dan pada BC live berbeda!  Di sini saya harus mengingatkan Anda bahwa dalam program saya gambar dan suara dihasilkan oleh satu kode.  Oleh karena itu, selama ini saya mencari alasan di tempat yang salah: alasannya adalah dalam kode yang menghasilkan data untuk isi layar. </p><br><p>  Damir mengirimi saya tangkapan layar, dan menjadi jelas bahwa algoritma menghasilkan byte dengan konten nol dari 4 bit tertinggi, dan, secara kebetulan, bit ini adalah output ke suara (mis., Selalu nol).  Namun, alasan mengapa algoritma berperilaku seperti ini tetap tidak jelas.  Ini adalah tempat dalam kode (assembler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">macro11</a> dari PDP-11, register r0-r5 diganti nama!): </p><br><pre><code class="plaintext hljs">; renamed registers a = %0 b = %1 c = %2 d = %3 e = %4 h = %5 ... ... asr b ; sets CF bic #177760, b bis b, c bis (h)+, c ; screen address in c movb (c), a ; get a byte from screen RAM bcc 1$ ; check CF bic #177760, a ; keep bits 0-3, clear rest bisb d, a ; fill bits 4-7 br 2$ 1$: bic #177417, a ; keep bits 4-7, clear rest bisb e, a ; fill bits 0-3 2$: ... ...</code> </pre> <br><p>  Untuk beberapa alasan, pada SM nyata, lompatan bersyarat pada tanda $ 1 selalu dilakukan.  Artinya, instruksi bcc selalu menganggap flag carry sebagai reset, meskipun instruksi shift ASR dapat mengatur flag ini menjadi 0 atau 1. Bagaimana ini bisa terjadi, karena menurut dokumentasi prosesor, bukan BIC, atau BIS, atau MOVB harus mempengaruhi bendera carry ?! </p><br><p>  Selain itu, di semua emulator (yang ditulis sesuai dengan dokumentasi untuk prosesor!) Begitulah: instruksi ini tidak menyentuh bendera C. Menjadi jelas bahwa prosesor nyata 1801BM1A tidak bekerja dalam kasus ini sesuai dengan dokumentasi.  Masih untuk mengkonfirmasi ini. </p><br><p>  Sebagai permulaan, perbaikan cepat yang jelas: </p><br><pre> <code class="plaintext hljs"> ... asr b ; sets CF mfps -(sp) ; store PSW on stack bic #177760, b bis b, c bis (h)+, c ; screen address in c movb (c), a ; get a byte from screen RAM mtps (sp)+ ; restore PSW from stack bcc 1$ ; check CF ...</code> </pre> <br><p>  Menyimpan bendera pada tumpukan segera setelah instruksi shift dan mengembalikannya sebelum lompatan bersyarat segera menyelesaikan masalah, yang menunjukkan bahwa saya berada di jalur yang benar.  Masih mempersempit "lingkaran tersangka."  Untuk menguji hipotesis, tes sintetis semacam itu pertama kali ditulis (register tidak diganti namanya di sini; inisialisasi dihilangkan agar tidak mengacaukan kode; emt 64 adalah program interupsi untuk mencetak baris): </p><br><pre> <code class="plaintext hljs"> ... mov #1, r1 jsr pc, test clr r1 jsr pc, test halt test: mov #40000, r2 ; r2 points to screen RAM mov #dummy, r5 ; r5 points to dummy = 200 ; *** begin *** asr r1 ; affects CF bic #177760, r1 bis r1, r2 bis (r5)+, r2 movb (r2), r0 ; *** end *** jsr pc, prt rts pc prt: mov #msg1, r0 bcs l1 mov #msg2, r0 l1: emt 64 rts pc msg1: .asciz /Flag CF set/ msg2: .asciz /Flag CF clear/ dummy: .word 200 ...</code> </pre> <br><p>  Dan tesnya ... tidak berhasil!  Program dicetak di layar </p><br><p>  Tandai CF set <br>  Tandai CF jelas </p><br><p>  Apa yang terjadi?  Ternyata asumsi awal bahwa fragmen kode antara <strong><em>mulai</em></strong> dan <strong><em>akhir</em></strong> hanya merusak flag C salah dan perlu diklarifikasi.  Apa perbedaan antara tes ini dan kode sumber?  Dan fakta bahwa instruksi lain muncul antara blok perintah "mencurigakan" dan lompatan bersyarat.  Tidak memengaruhi flag C, namun tetap mengubah status internal prosesor.  Oleh karena itu, tes berikut seperti ini: </p><br><pre> <code class="plaintext hljs"> ... mov #1, r1 jsr pc, test clr r1 jsr pc, test halt test: mov #40000, r2 mov #dummy, r5 ; *** begin *** asr r1 ; affects CF bic #177760, r1 bis r1, r2 bis (r5)+, r2 movb (r2), r0 bcc l1 ; *** end *** mov #msg1, r0 emt 64 rts pc l1: mov #msg2, r0 emt 64 rts pc msg1: .asciz /Flag CF set/ msg2: .asciz /Flag CF clear/ dummy: .word 200 ...</code> </pre> <br><p>  Dan sekarang tes ini telah dicetak pada BK-0011M nyata: </p><br><p>  Tandai CF jelas <br>  Tandai CF jelas </p><br><p>  Pada emulator, seperti sebelumnya, </p><br><p>  Tandai CF set <br>  Tandai CF jelas </p><br><p>  Selanjutnya adalah masalah teknologi.  Dengan penyederhanaan bertahap, tes minimal seperti itu diperoleh di mana bug direproduksi (saya kutip seluruh sumber): </p><br><pre> <code class="plaintext hljs"> .title test .psect code .=.+1000 mov #15, r0 emt 63 sec jsr pc, test clc jsr pc, test halt test: movb r0, r0 bcc l1 mov #msg1, r0 emt 64 rts pc l1: mov #msg2, r0 emt 64 rts pc msg1: .asciz /Flag CF set/ msg2: .asciz /Flag CF clear/ .end</code> </pre> <br><p>  Pada BK-0011M nyata, tes ini ditampilkan </p><br><p>  Tandai CF jelas <br>  Tandai CF jelas </p><br><p>  Artinya, instruksi MOVB yang langsung di depan instruksi cabang bersyarat adalah yang harus disalahkan, dan penampilan operan pertama tidak penting.  Jika, misalnya, NOP dimasukkan antara MOVB dan BCC, perilaku tersebut akan kembali ke yang telah didokumentasikan, dan program akan mencetak </p><br><p>  Tandai CF set <br>  Tandai CF jelas </p><br><p>  Itu memungkinkan untuk merumuskan hipotesis yang disempurnakan (saya kutip sendiri dari saluran telegram): </p><br><blockquote>  ... Mengenai bug: perilaku tersebut sepertinya sudah beres.  Seperti yang saya bayangkan, MOVB src, dst (omong-omong, tampaknya operan tidak penting), karena beberapa fitur arsitektur, sementara merusak bendera C di dalam prosesor, tetapi tidak fatal, karena persen sepertinya menyimpan salinan bendera ini.  Akibatnya, jika antara MOVB dan cabang kondisional ada perintah lain (tidak mempengaruhi C), misalnya, NOP, maka perilaku tersebut seperti yang dijelaskan dalam dokumentasi. </blockquote><p>  Apa yang terjadi selanjutnya?  Selanjutnya, rekan-rekan dari saluran membantu membawa Vyacheslav (@ K1801BM1, lelaki legendaris yang sebelumnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membalikkan</a> prosesor ini pada level transistor) ke diskusi.  Reaksi Vyacheslav (Yuot) ketika ia menguji perilaku di atas dudukan dengan 1801BM1A nyata (ejaan dan tanda baca dipertahankan): </p><br><blockquote>  <u>Stanislav Maslovski:</u> <br>  setidaknya diperlukan dua perintah untuk reproduksi <br>  movb dan lompatan bersyarat dalam C <br>  Nah, sebelum itu, atur flag C ke status diketahui <br><br>  <u>Yuot:</u> <br>  Bendera dengan reset selalu diperoleh <br><br>  <u>Stanislav Maslovski:</u> <br>  iya <br>  sekarang masukkan nop <br><br>  <u>Yuot:</u> <br>  Sekarang tidak pernah <br><br>  <u>Yuot:</u> <br>  Bergantian 0 1 <br>  Ini memalukan </blockquote><p>  Dengan bantuan Vyacheslav, perinciannya ditemukan, yaitu, bahwa alasan bug tersebut ada pada prosesor, selain PSW, ada register 4-bit lain, yang biasanya menyimpan salinan bendera dari PSW.  Register ini terhubung dengan firmware otomatis dan transisi bersyarat mengambil nilai bendera darinya.  Ketika menjalankan instruksi MVB, SWAB, MFPS dengan register penerima, karena kekhasan memproses ekstensi tanda dan karena kesalahan dalam mikrokode, salinan flag C dalam register ini dibuang dan transisi kondisional menggunakan flag ini tidak berfungsi dengan benar.  Namun, dengan mengikuti instruksi di bawah ini, nilai register sementara dipulihkan dari PSW.  Itu sebabnya, penyisipan NOP mengembalikan perilaku yang benar. </p><br><p>  Sebagai penutup, saya juga ingin mengucapkan terima kasih kepada pelanggan saluran telegram <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dunia BK0010 / 11M</a> untuk berpartisipasi dalam diskusi bug ini, dan untuk komentar yang dibuat pada teks artikel.  Foto judul untuk artikel ini adalah milik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Manwe_SandS</a> .  Lebih menarik lagi, Manwe hampir menemukan bug yang sama, hampir pada saat yang sama ketika saya dan Damir berjuang untuk menyelesaikan masalah suara! </p><br><p>  Sekarang terserah kecil (hanya bercanda) - bawa semua emulator sejalan dengan perilaku prosesor yang sebenarnya.  Lagi pula, prosesor itu sendiri, sayangnya, tidak bisa lagi diperbaiki. </p><br><p>  <em>Tentang ini saya akan berakhir.</em>  <em>Saya harap itu menarik.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id471020/">https://habr.com/ru/post/id471020/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id471010/index.html">Algoritma Grover dan Pencarian Data</a></li>
<li><a href="../id471012/index.html">Pendekatan teknik untuk pengembangan perangkat lunak. Dari teori ke praktik</a></li>
<li><a href="../id471014/index.html">Kami membuat drone air otonom, atau ketika saya bermimpi membantu Baikal, tapi saya bukan Gazprom. Bagian 1</a></li>
<li><a href="../id471016/index.html">Desain Basis Data. Praktik terbaik</a></li>
<li><a href="../id471018/index.html">Perbandingan kinerja PC dan smartphone, termasuk iPhone 11</a></li>
<li><a href="../id471022/index.html">Mengungkap rahasia fisika berusia 140 tahun</a></li>
<li><a href="../id471024/index.html">Analisis: apa masa depan dan bagaimana menggunakannya untuk investasi pertukaran</a></li>
<li><a href="../id471026/index.html">TypeScript Kekuasaan tidak pernah</a></li>
<li><a href="../id471028/index.html">Troli truk ROS. Bagian 6. Odometri dengan enkoder roda, peta ruang, lidar</a></li>
<li><a href="../id471032/index.html">Foto yang tak terlihat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>