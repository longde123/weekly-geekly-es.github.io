<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😤 🧑🏻 ➡️ C＃8.0中具有模式的更多功能 🍍 👩🏻‍🍳 🌕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="最近，Visual Studio 2019 Preview 2发行了，并提供了一些其他的C＃8.0功能供您试用。 这主要是与样本的比较，尽管最后我将介绍其他新闻和更改。 


 本文为英文。 


 感谢您翻译我们的MSP Lev Bulanov 。 



 在更多地方有更多图案 


 当C＃7...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C＃8.0中具有模式的更多功能</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/440530/"><p> 最近，Visual Studio 2019 Preview 2发行了，并提供了一些其他的C＃8.0功能供您试用。 这主要是与样本的比较，尽管最后我将介绍其他新闻和更改。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本文为英文。</a> </p><br><img src="https://habrastorage.org/webt/_p/dm/49/_pdm493ww_lspasjjtw5abi-eoa.jpeg"><a name="habracut"></a><br><br> 感谢您翻译我们的MSP <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Lev Bulanov</a> 。 <br><br><h2></h2><p> 在更多地方有更多图案 </p><br><p> 当C＃7.0中出现模式匹配时，我们注意到，预计将来更多地方的模式数量会增加。 这次到了！ 我们将添加所谓的递归模式，以及一种更紧凑的<strong>开关</strong>表达式形式（您猜对了）。 </p><br><p> 首先，这是C＃7.0模式的简单示例： </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Point</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Y { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Point</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> =&gt; (X, Y) = (x, y); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Deconstruct</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> =&gt; (x, y) = (X, Y); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (o) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Point p when pX == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pY == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"origin"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Point p: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">$"(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{pX}</span></span></span><span class="hljs-string">, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{pY}</span></span></span><span class="hljs-string">)"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"unknown"</span></span>; } }</code> </pre> <br><p></p><h2> 切换表达式 </h2><br><p> 首先，请注意，实际上，许多<strong>switch</strong>表达式在<strong>case</strong>主体中并没有做很多有趣的工作。 通常，它们都可以简单地创建一个值，方法是将其分配给变量或将其返回（如上所示）。 在所有这些情况下，开关似乎都不合适。 这类似于五十年前的语言功能。 </p><br><p> 我们认为是时候添加一个<strong>switch语句</strong>表单了。 它适用于以下示例： </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point p when pX == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pY == <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point p =&gt; <span class="hljs-string"><span class="hljs-string">$"(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{pX}</span></span></span><span class="hljs-string">, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{pY}</span></span></span><span class="hljs-string">)"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> }; }</code> </pre> <br><p> 与switch语句相比，有些变化。 让我们列出它们： </p><br><ul><li>  <strong>switch</strong>关键字是测试值和<strong>{...}</strong>案例列表之间的“中缀”。 这使得它与其他表达式更加组合，并且更容易从视觉上与switch语句区分开。 </li><li>  <strong>case</strong>关键字和符号：简短地由lambda箭头<strong>=&gt;</strong>代替。 </li><li> 为简洁起见， <strong>默认值</strong>已由<strong>_</strong>重置模式代替。 </li><li> 身体是表情。 所选正文的结果成为switch语句的结果。 </li></ul><br><p> 因为表达式必须重要或引发异常，所以以不匹配结尾的选择表达式将引发异常。 发生这种情况时，编译器会警告您，但不会强制您以catch-all函数结束所有select语句。 </p><br><p> 由于我们的<strong>Display</strong>方法现在由单个return语句组成，因此我们可以简化其表达方式： </p><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> =&gt; o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point p when pX == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pY == <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point p =&gt; <span class="hljs-string"><span class="hljs-string">$"(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{pX}</span></span></span><span class="hljs-string">, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{pY}</span></span></span><span class="hljs-string">)"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> };</code> </pre> <br><p> 无论给出什么格式建议，它们都应该非常清楚和简洁。 如上所述，Briefity允许您以“表格”方式设置开关的格式，将模式和bod放在同一行，而<strong>=&gt;则</strong>在下面对齐。 </p><br><p> 顺便说一句，我们计划根据C＃中的所有其他“大括号括起来的列表”，允许在最后一种情况之后使用逗号，但是在Preview 2中尚不允许这样做。 </p><br><h2></h2><p> 图案属性 </p><br><p> 说起简洁，模式突然成为选择表达中最难的元素。 让我们做些事情。 </p><br><p> 请注意，select表达式使用<strong>Point p</strong>类型（两次）的模式，以及在第一种<strong>情况下</strong> <strong>何时</strong>添加其他条件。 </p><br><p> 在C＃8.0中，我们向模式类型添加了其他可选元素，这允许模式本身更深入地映射到模式。 您可以通过添加包含嵌套模式的<strong>{...}</strong>并将其应用于可用属性或字段来将其设置为属性模式。 这使我们可以如下重写switch表达式： </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> =&gt; o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point { X: <span class="hljs-number"><span class="hljs-number">0</span></span>, Y: <span class="hljs-number"><span class="hljs-number">0</span></span> } p =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point { X: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, Y: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y } p =&gt; <span class="hljs-string"><span class="hljs-string">$"(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{x}</span></span></span><span class="hljs-string">, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{y}</span></span></span><span class="hljs-string">)"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> };</code> </pre> <br><p> 两种情况仍然验证<strong>o</strong>是<strong>Point</strong> 。 在第一种情况下，将常量<strong>0</strong>的模式递归应用于变量<strong>p</strong>的属性<strong>X</strong>和<strong>Y</strong> ，检查它们是否具有此值。 因此，我们可以消除这种情况以及其他类似情况下的<strong>when</strong>条件。 </p><br><p> 在第二种情况下，将<strong>var</strong>模式应用于<strong>X</strong>和<strong>Y中的</strong>每个。 回想一下，C＃7.0中的<strong>var</strong>模式始终会成功，并且只需声明一个新变量即可保存该值。 因此<strong>x</strong>和<strong>y</strong>包含<strong>pX</strong>和<strong>pY的</strong> int值。 </p><br><p> 我们从不使用<strong>p</strong> ，实际上可以在这里跳过它： </p><br><pre> <code class="cs hljs"> Point { X: <span class="hljs-number"><span class="hljs-number">0</span></span>, Y: <span class="hljs-number"><span class="hljs-number">0</span></span> } =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point { X: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, Y: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y } =&gt; <span class="hljs-string"><span class="hljs-string">$"(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{x}</span></span></span><span class="hljs-string">, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{y}</span></span></span><span class="hljs-string">)"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span></code> </pre> <br><p> 对于所有类型的模式（包括属性模式），一件事保持不变，这是要求该值必须为非零的要求。 这提供了将“空”属性<strong>{}</strong>模式用作紧凑的“非零”模式的可能性。 举个例子 我们可以用以下两种情况替换后备： </p><br><pre> <code class="cs hljs"> {} =&gt; o.ToString(), <span class="hljs-literal"><span class="hljs-literal">null</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"null"</span></span></code> </pre> <br><p>  <strong>{}</strong>处理剩余的非零对象，并且<strong>null</strong>获得零，因此切换是详尽的，并且编译器将不会抱怨缺少值。 </p><br><h2></h2><p> 位置模式 </p><br><p> 属性模式不会缩短第二个<strong>Point的</strong>情况<strong>。</strong> 无需担心，您可以做更多。 </p><br><p> 请注意， <strong>Point</strong>类具有<strong>Deconstruct</strong>方法，即所谓的deconstructor。 在C＃7.0中，解构函数允许您在分配值时“解构”一个值，因此您可以编写，例如： </p><br><pre> <code class="cs hljs">(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y) = GetPoint(); <span class="hljs-comment"><span class="hljs-comment">// split up the Point according to its deconstructor</span></span></code> </pre> <br><p>  C＃7.0没有将解构与模式集成在一起。 这随位置模式而变化，这是在C＃8.0中扩展模式类型的另一种方式。 如果匹配类型是元组类型或具有解构函数，则可以使用位置模式作为应用递归模式的紧凑方法，而不必命名属性： </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> =&gt; o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y) =&gt; <span class="hljs-string"><span class="hljs-string">$"(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{x}</span></span></span><span class="hljs-string">, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{y}</span></span></span><span class="hljs-string">)"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> };</code> </pre> <br><p> 在将对象与<strong>Point</strong>匹配之后，将应用解构函数，并将嵌套模式应用于结果值。 </p><br><p> 解构函数并不总是合适的。 仅应将它们添加到那些确实清楚哪个值是哪个值的类型中。 例如，对于<strong>Point</strong>类，您可以假定第一个值为<strong>X</strong> ，第二个值为<strong>Y</strong> ，因此上述开关表达式清晰易懂。 </p><br><h2></h2><p> 元组模式 </p><br><p> 位置模式的一个非常有用的特殊情况是它们在元组中的应用。 如果将switch语句直接应用于元组表达式，我们甚至可以省略括号的附加集合，如<strong>switch（x，y，z）</strong>而不是<strong>switch（（x，y，z））</strong> 。 </p><br><p> 元组模式非常适合同时测试多个输入。 这是状态机的简单实现： </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeState</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">State current, Transition transition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasKey</span></span></span><span class="hljs-function">)</span></span> =&gt; (current, transition) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { (Opened, Close) =&gt; Closed, (Closed, Open) =&gt; Opened, (Closed, Lock) when hasKey =&gt; Locked, (Locked, Unlock) when hasKey =&gt; Closed, _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">$"Invalid transition"</span></span>) };</code> </pre> <br><p> 当然，我们可以在元组中包含<strong>hasKey</strong>而不是使用<strong>when</strong>子句-这是一个问题： </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeState</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">State current, Transition transition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasKey</span></span></span><span class="hljs-function">)</span></span> =&gt; (current, transition, hasKey) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { (Opened, Close, _) =&gt; Closed, (Closed, Open, _) =&gt; Opened, (Closed, Lock, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) =&gt; Locked, (Locked, Unlock, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) =&gt; Closed, _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">$"Invalid transition"</span></span>) };</code> </pre> <br><p> 通常，您会看到递归模式和switch表达式可以导致更清晰和更具声明性的程序逻辑。 </p><br><h2></h2><p> 预览2中C＃8.0的其他功能 </p><br><p> 尽管在VS 2019 Preview 2中使用模式的主要功能是最重要的事实，但我希望有一些较小的功能也会有用且有趣。 我将不做任何详细说明，仅对它们进行简要说明。 </p><br><h4></h4><p> 使用广告 </p><br><p> 在C＃ <strong>使用中，</strong>运算符始终会增加嵌套级别，这可能会很烦人并且可读性很差。 在简单的情况下，当您只需要清除作用域末尾的资源时，可以使用using声明。  using声明只是局部变量的声明，其前面带有<strong>using</strong>关键字，其内容位于当前指令块的末尾。 因此，代替： </p><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> options = Parse(args)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (options[<span class="hljs-string"><span class="hljs-string">"verbose"</span></span>]) { WriteLine(<span class="hljs-string"><span class="hljs-string">"Logging..."</span></span>); } ... } <span class="hljs-comment"><span class="hljs-comment">// options disposed here }</span></span></code> </pre> <br><p> 你可以写 </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> options = Parse(args); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (options[<span class="hljs-string"><span class="hljs-string">"verbose"</span></span>]) { WriteLine(<span class="hljs-string"><span class="hljs-string">"Logging..."</span></span>); } } <span class="hljs-comment"><span class="hljs-comment">// options disposed here</span></span></code> </pre> <br><h4></h4><p> 一次性引用结构 </p><br><p> 引用结构在C＃7.2中引入，在这里似乎没有重复的地方。 但仍然值得注意的是：它们有一些局限性，例如无法实现接口。 现在可以在不实现<strong>IDisposable</strong>接口的情况下使用引用结构，只需在其中使用<strong>Dispose</strong>方法即可。 </p><br><h4></h4><p> 静态局部功能 </p><br><p> 如果要确保您的本地函数不会招致与从范围“捕获”（引用）变量相关的运行时开销，则可以将其声明为静态。 然后，编译器将阻止链接到封闭函数中声明的所有内容-除了其他静态局部函数！ </p><br><h4></h4><p> 对预览版1的更改 </p><br><p> 预览1的主要功能是可为空的引用类型和异步流。 预览2中的这两项功能都有所改变，因此，如果您开始使用它们，了解以下内容将很有用。 </p><br><h4></h4><p> 可空引用类型 </p><br><p> 我们在源头（通过<strong>#nullable</strong>和<strong>#pragma警告</strong>指令）和项目级别添加了更多用于管理可空警告的选项。 我们还将对项目文件的预订更改为<strong>&lt;NullableContextOptions&gt; enable &lt;/ NullableContextOptions&gt;</strong> 。 </p><br><h4></h4><p> 异步线程 </p><br><p> 我们更改了编译器期望的<strong>IAsyncEnumerable &lt;T&gt;</strong>接口的形式。 这导致编译器不与.NET Core 3.0 Preview 1中提供的接口同步的事实，这可能会引起一些问题。 但是，.NET Core 3.0 Preview 2即将发布，它将返回同步。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN440530/">https://habr.com/ru/post/zh-CN440530/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN440520/index.html">如何获得Google Developers认证：移动网络专家</a></li>
<li><a href="../zh-CN440522/index.html">具有实施虚拟PBX的经验。 通讯和软件在不同的篮子里</a></li>
<li><a href="../zh-CN440524/index.html">80级覆盖或简化：从切换用例到类的路径</a></li>
<li><a href="../zh-CN440526/index.html">大雪飘过后，日本城市转向数字技术</a></li>
<li><a href="../zh-CN440528/index.html">“给我看你的运动鞋，我告诉你你是谁”：主题媒体项目上的新播客</a></li>
<li><a href="../zh-CN440534/index.html">将政治上正确的词汇从英语翻译成俄语</a></li>
<li><a href="../zh-CN440536/index.html">Facebook Project Infer如何在部署之前帮助发现移动应用程序中的错误</a></li>
<li><a href="../zh-CN440540/index.html">Reddit的市值在吸引了3亿美元投资后达到了30亿美元</a></li>
<li><a href="../zh-CN440542/index.html">Vuex-在应用程序中过度使用吸气剂。 错误解析</a></li>
<li><a href="../zh-CN440544/index.html">Blazor 0.8.0实验版本现已发布</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>