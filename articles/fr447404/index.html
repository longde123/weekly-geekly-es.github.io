<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚰️ 🖥️ 🍎 Le code est vivant et mort. Première partie Les objets 🥁 🚰 🍮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le code est une pensée. Une tâche apparaît et le développeur pense comment la résoudre, comment exprimer les exigences dans les fonctions et les class...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Le code est vivant et mort. Première partie Les objets</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447404/"><p>  Le code est une pensée.  Une tâche apparaît et le développeur pense comment la résoudre, comment exprimer les exigences dans les fonctions et les classes, comment se faire des amis, comment atteindre la rigueur et l'exactitude, et comment faire fonctionner l'entreprise correctement.  Pratiques, techniques, principes, modèles et approches - tout doit être pris en compte et tout doit être rappelé. </p><br><p>  Et parallèlement à cela, nous voyons une épidémie généralisée de gestionnaires, aides, services, contrôleurs, sélecteurs, adaptateurs, getters, setters et autres mauvais esprits: tout cela est du code mort.  Il encombre et encombre. </p><br><p>  Je propose de lutter de cette façon: vous devez présenter les programmes sous forme de texte dans un langage naturel et les évaluer en conséquence.  Comment cela et ce qui se passe - dans l'article. </p><a name="habracut"></a><br><h2 id="oglavlenie-cikla">  Table des matières du cycle </h2><br><ol><li>  Les objets </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Actions et propriétés</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Code comme texte</a> </li></ol><br><h2 id="prolog">  Prologue </h2><br><p> Mon expérience est modeste (environ quatre ans), mais plus je travaille, plus je comprends: si le programme est illisible, cela n'a aucun sens.  Il est connu depuis longtemps et battu pour le rappeler - le code résout non seulement certains problèmes <em>maintenant</em> , mais aussi <em>plus tard</em> : il est pris en charge, étendu, corrigé.  De plus, il a toujours: lu. </p><br><p>  Après tout, c'est du texte. </p><br><p>  L'esthétique du code en tant que texte est un thème clé du cycle.  L'esthétique ici est un verre à travers lequel on regarde les choses et on dit, oui, c'est bien, oui, c'est beau. </p><br><p>  En matière de beauté et de compréhensibilité, les mots sont d'une grande importance.  Dire: <em>"En ce moment, mes perceptions sont dans un état terne à cause du niveau élevé d'éthanol dans le sang"</em> n'est pas du tout la même chose que: <em>"Je me suis saoulé</em> . <em>"</em> </p><br><p>  Nous sommes chanceux, les programmes sont presque entièrement composés de mots. </p><br><p>  Disons que vous devez faire <em>«un personnage qui a de la santé et du mana, il marche, attaque, utilise des sorts»,</em> et vous pouvez immédiatement voir: il y a des <strong>objets</strong> (personnage, santé, mana, sort), des <strong>actions</strong> (marcher, attaquer, utiliser) et des <strong>propriétés</strong> ( le personnage a la santé, le mana, la vitesse de lancer des sorts) - tout cela sera des noms: classes, fonctions, méthodes, variables, propriétés et champs, en un mot, tout ce que le langage de programmation se divise. </p><br><p> Mais je ne distinguerai pas les classes des structures, les champs des propriétés et les méthodes des fonctions: un personnage dans le cadre d'un récit ne dépend pas de détails techniques (qu'il peut être représenté soit comme une référence soit comme un type significatif).  Une chose essentiellement différente: qu'il s'agit d'un personnage et qu'ils l'appelaient <code>Hero</code> (ou <code>Character</code> ), et non <code>HeroData</code> ou <code>HeroUtils</code> . </p><br><p>  Je vais maintenant prendre le verre même de l'esthétique et montrer comment du code est écrit aujourd'hui et pourquoi il est loin d'être parfait. </p><br><h2 id="obekty">  Les objets </h2><br><p>  En C # (et pas seulement), les objets - des instances de classes qui sont placées sur le tas, y vivent pendant un certain temps, puis le garbage collector les supprime.  Il peut également être créé des structures sur la pile ou des tableaux associatifs, ou autre chose.  Pour nous, ce sont: les noms de classe, les noms. </p><br><p>  Les noms dans le code, comme les noms en général, peuvent prêter à confusion.  Oui, et vous voyez rarement un nom laid, mais un bel objet.  Surtout s'il s'agit d'un <code>Manager</code> . </p><br><h3 id="menedzher-vmesto-obekta">  Manager au lieu d'un objet </h3><br><p>  <code>UserService</code> , <code>UserService</code> , <code>DamageUtils</code> , <code>MathHelper</code> , <code>GraphicsManager</code> , <code>GameManager</code> , <code>VectorUtil</code> . </p><br><p>  Ce n'est pas l'exactitude et la tangibilité qui dominent ici, mais quelque chose de vague, laissant quelque part dans le brouillard.  Pour de tels noms, beaucoup est permis. </p><br><p>  Par exemple, dans n'importe quel <code>GameManager</code> vous pouvez ajouter tout ce qui concerne le <em>jeu</em> et la logique du <em>jeu</em> .  Six mois plus tard, viendra une singularité technologique. </p><br><p>  Ou, cela arrive, vous devez travailler avec Facebook.  Pourquoi ne pas mettre tout le code au même endroit: <code>FacebookManager</code> ou <code>FacebookService</code> ?  Cela semble simple et séduisant, mais une <em>intention</em> aussi vague crée une <em>décision</em> tout aussi vague.  Dans le même temps, nous savons qu'il y a des utilisateurs, des amis, des messages, des groupes, de la musique, des intérêts, etc. sur Facebook.  Assez de mots! </p><br><p>  Non seulement il y a suffisamment de mots: nous les utilisons toujours.  Seulement dans le discours ordinaire, pas parmi les programmes. </p><br><p>  Et ce n'est pas <code>GitUtils</code> , mais <code>IRepository</code> , <code>ICommit</code> , <code>IBranch</code> ;  pas <code>ExcelHelper</code> , mais <code>ExcelDocument</code> , <code>ExcelSheet</code> ;  pas <code>GoogleDocsService</code> , mais <code>GoogleDocs</code> . </p><br><p>  Chaque sujet est rempli d'objets.  <em>«Les objets étaient marqués par des vides énormes»</em> , <em>«Le cœur battait furieusement»</em> , <em>«La maison était debout»</em> - les objets agissent, ils le sentent, ils sont faciles à imaginer;  ils sont quelque part ici, tangibles et denses. </p><br><p>  En même temps, vous voyez parfois ceci: dans le référentiel <code>Microsoft/calculator</code> - <code>CalculatorManager</code> avec les méthodes: <code>SetPrimaryDisplay</code> , <code>MaxDigitsReached</code> , <code>SetParentDisplayText</code> , <code>OnHistoryItemAdded</code> ... </p><br><p>  <em>(Pourtant, je me souviens avoir vu</em> <code>UtilsManager</code> <em>...)</em> </p><br><p>  Cela se produit de cette façon: je veux développer le type <code>List&lt;&gt;</code> avec un nouveau comportement, et <code>ListUtils</code> ou <code>ListHelper</code> sont nés.  Dans ce cas, il est préférable et plus précis d'utiliser <em>uniquement des</em> méthodes d'extension - <code>ListExtensions</code> : elles font partie du concept, et non un vidage des procédures. </p><br><p>  L'une des rares exceptions est <code>OfficeManager</code> tant que publication. </p><br><p>  Pour le reste ... Les programmes ne devraient pas être compilés s'ils contiennent de tels mots. </p><br><h3 id="deystvie-vmesto-obekta">  Action au lieu d'objet </h3><br><p>  <code>IProcessor</code> , <code>ILoader</code> , <code>ISelector</code> , <code>IFilter</code> , <code>IProvider</code> , <code>ISetter</code> , <code>ICreator</code> , <code>IOpener</code> , <code>IHandler</code> ;  <code>IEnableable</code> , <code>IInitializable</code> , <code>IUpdatable</code> , <code>ICloneable</code> , <code>IDrawable</code> , <code>ILoadable</code> , <code>IOpenable</code> , <code>ISettable</code> , <code>IConvertible</code> . </p><br><p>  Ici, l'essence de l'essence est une procédure, pas un concept, et le code perd à nouveau son imagerie et sa lisibilité, et le mot habituel est remplacé par un mot artificiel. </p><br><p>  <code>ISequence</code> est beaucoup plus <code>ISequence</code> , pas <code>IEnumerable</code> ;  <code>IBlueprint</code> , pas <code>ICreator</code> ;  <code>IButton</code> , pas <code>IButtonPainter</code> ;  <code>IPredicate</code> , pas <code>IFilter</code> ;  <code>IGate</code> , non <code>IOpeneable</code> ;  <code>IToggle</code> , pas <code>IEnableable</code> . </p><br><p>  Une bonne histoire raconte les personnages et leur évolution, et non la façon dont le créateur crée, le constructeur construit et le peintre dessine.  Une action ne peut pas représenter complètement un objet.  <code>ListSorter</code> n'est pas une <code>SortedList</code> . </p><br><p>  Prenez <code>DirectoryCleaner</code> , par exemple, un objet qui nettoie les dossiers du système de fichiers.  Est-ce élégant?  Mais nous ne disons jamais: <em>"Demandez au nettoyeur de dossier de nettoyer D: / Test"</em> , toujours: <em>"Nettoyez D: / Test"</em> , de sorte que le <code>Directory</code> avec la méthode <code>Clean</code> semble plus naturel et plus proche. </p><br><p>  Un cas plus vivant est plus intéressant: <code>FileSystemWatcher</code> de .NET est un observateur de système de fichiers qui rapporte les changements.  Mais pourquoi tout l'observateur, si les changements <em>eux</em> - <em>mêmes</em> peuvent signaler qu'ils se sont produits?  De plus, ils doivent être inextricablement liés au fichier ou au dossier, ils doivent donc également être placés dans le <code>Directory</code> ou le <code>File</code> (en utilisant la propriété <code>Changes</code> avec la possibilité d'appeler <code>file.Changes.OnNext(action)</code> ). </p><br><p>  De tels noms verbaux semblent justifier le modèle de conception de la <code>Strategy</code> , demandant <em>«d'encapsuler la famille d'algorithmes»</em> .  Mais si au lieu d'une <em>«famille d'algorithmes» nous</em> trouvons un objet authentique qui existe dans l'histoire, nous verrons que la stratégie n'est qu'une généralisation. </p><br><p>  Pour expliquer ces erreurs et bien d'autres, nous nous tournons vers la philosophie. </p><br><h3 id="suschestvovanie-predshestvuet-suschnosti">  L'existence précède l'essence </h3><br><p>  <code>MethodInfo</code> , <code>ItemData</code> , <code>AttackOutput</code> , <code>CreationStrategy</code> , <code>StringBuilder</code> , <code>SomethingWrapper</code> , <code>LogBehaviour</code> . </p><br><p>  De tels noms sont unis par une chose: leur être est basé sur des détails. </p><br><p>  Il arrive que quelque chose interfère rapidement avec une tâche: quelque chose manque ou est, mais pas quelque chose.  Ensuite, vous pensez: <em>«Une chose qui peut faire X maintenant m'aiderait»</em> - c'est ainsi que l' <em>existence</em> est conçue.  Ensuite, pour «faire» X, <code>XImpl</code> est écrit - c'est ainsi que l' <em>entité</em> apparaît. </p><br><p>  Par conséquent, au lieu de <code>IArrayItem</code> , <code>IIndexedItem</code> ou <code>IItemWithIndex</code> est plus courant, ou, disons, dans l'API Reflection, au lieu de la <em>méthode</em> ( <code>Method</code> ), nous ne voyons que des <em>informations</em> à ce sujet ( <code>MethodInfo</code> ). </p><br><p>  Une manière plus vraie: face au besoin d'existence, <em>trouver une</em> entité qui le met en œuvre, et, puisque c'est sa nature, d'autres. </p><br><p>  Par exemple, ils voulaient changer la valeur du type <code>string</code> sans créer d'instances intermédiaires - cela s'est avéré être une solution simple sous la forme de <code>StringBuilder</code> , alors qu'à mon avis, il est plus approprié - <code>MutableString</code> . </p><br><p>  Rappelez le système de fichiers: <code>DirectoryRenamer</code> pas nécessaire pour renommer les dossiers, car dès que vous acceptez la présence de l'objet <code>Directory</code> , l'action y est <em>déjà</em> , vous n'avez tout simplement pas <em>trouvé la</em> méthode correspondante dans le code. </p><br><p>  Si vous voulez décrire comment prendre un <em>verrou</em> , il n'est pas nécessaire de préciser qu'il s'agit de <code>ILockBehaviour</code> ou <code>ILockStrategy</code> , ce qui est beaucoup plus facile - <code>ILock</code> (avec la méthode <code>Acquire</code> qui retourne <code>IDisposable</code> ) ou <code>ICriticalSection</code> (avec <code>Enter</code> ). </p><br><p>  Cela inclut également toutes sortes de <code>Data</code> , d' <code>Info</code> , de <code>Output</code> , d' <code>Input</code> , d' <code>Args</code> , de <code>Params</code> (moins souvent l' <code>State</code> ) - des objets qui sont complètement dépourvus de comportement, car ils étaient considérés comme unilatéraux. </p><br><p>  Lorsque l'existence est principale, le quotient est mélangé avec le général et les noms des objets prêtent à confusion - vous devez lire chaque ligne et comprendre où le personnage est allé et pourquoi il n'y a que ses <code>Data</code> . </p><br><h3 id="prichudlivaya-taksonomiya">  Taxonomie bizarre </h3><br><p>  <code>CalculatorImpl</code> , <code>AbstractHero</code> , <code>ConcreteThing</code> , <code>CharacterBase</code> . </p><br><p>  Pour les mêmes raisons que celles décrites ci-dessus, nous voyons parfois des objets pour lesquels une place dans la hiérarchie est précisément indiquée.  Encore une fois, l'existence se précipite, nous voyons à nouveau comment le besoin immédiat a été précipité dans le code, sans tenir compte des conséquences. </p><br><p>  Après tout, y a-t-il vraiment une personne ( <code>Human</code> ) - l'héritière de la personne de base ( <code>HumanBase</code> )?  Mais comment se fait-il que <code>Item</code> hérite de <code>AbstractItem</code> ? </p><br><p>  Parfois, ils veulent montrer qu'il n'y a pas de <code>Character</code> , mais une sorte de ressemblance "brute" - <code>CharacterRaw</code> . </p><br><p>  <code>Impl</code> , <code>Abstract</code> , <code>Custom</code> , <code>Base</code> , <code>Concrete</code> , <code>Internal</code> , <code>Raw</code> - un signe d'instabilité, d'imprécision de l'architecture qui, comme le pistolet de la première scène, tirera certainement plus tard. </p><br><h3 id="povtoreniya">  Répétitions </h3><br><p>  Avec les types imbriqués, cela se produit: <code>RepositoryItem</code> dans <code>Repository</code> , <code>WindowState</code> dans <code>Window</code> , <code>HeroBuilder</code> dans <code>Hero</code> . </p><br><p>  La répétition coupe le sens, exacerbe les défauts et ne contribue qu'à la complexité du texte. </p><br><h3 id="izbytochnye-detali">  Pièces redondantes </h3><br><p>  Pour synchroniser les threads, <code>ManualResetEvent</code> est souvent utilisé avec l'API suivante: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ManualResetEvent</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   —  `EventWaitHandle`. void Set(); void Reset(); bool WaitOne(); }</span></span></code> </pre> <br><p>  Chaque fois, personnellement, je dois me rappeler en quoi <code>Set</code> diffère de <code>Reset</code> (grammaire inconfortable) et ce qu'est un <em>«événement de réinitialisation manuelle»</em> en général dans le contexte du travail avec des flux. </p><br><p>  Dans de tels cas, il est plus facile d'utiliser des métaphores loin de la programmation (mais proche de la vie quotidienne): </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ThreadGate</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WaitForOpen</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; }</code> </pre> <br><p>  Il n'y a certainement rien à confondre! </p><br><p>  Parfois, il s'agit du ridicule: spécifiez que les <em>éléments</em> ne sont pas seulement des <code>Items</code> , mais nécessairement des éléments <code>ItemsList</code> ou <code>ItemsDictionary</code> ! </p><br><p>  Cependant, si la <code>ItemsList</code> pas drôle, alors <code>AbstractInterceptorDrivenBeanDefinitionDecorator</code> de <em>Spring</em> est très <code>ItemsList</code> .  Les mots de ce nom sont des chiffons à partir desquels un monstre gigantesque est cousu.  Bien que ... S'il s'agit d'un monstre, qu'est-ce que <code>HasThisTypePatternTriedToSneakInSomeGenericOrParameterizedTypePatternMatchingStuffAnywhereVisitor</code> ?  Espérons l' <em>héritage</em> . </p><br><p>  En plus des noms de classe et d'interface, on rencontre souvent une redondance dans les variables ou les champs. </p><br><p>  Par exemple, un champ de type <code>IOrdersRepository</code> est appelé <code>_ordersRepository</code> .  Mais dans quelle mesure est-il important de signaler que les commandes sont soumises par le référentiel?  Après tout, beaucoup plus facile - <code>_orders</code> . </p><br><p>  Il arrive également que dans les requêtes LINQ, ils écrivent les noms d'argument complets des expressions lambda, par exemple, <code>Player.Items.Where(item =&gt; item.IsWeapon)</code> , bien que nous comprenions déjà cet élément en regardant <code>Player.Items</code> .  Dans de tels cas, j'aime toujours utiliser <em>le même</em> caractère - <code>x</code> : <code>Player.Items.Where(x =&gt; x.IsWeapon)</code> (avec la continuation à <code>y</code> , <code>z</code> si ce sont des fonctions à l'intérieur des fonctions). </p><br><h2 id="itogo">  Total </h2><br><p>  J'avoue qu'avec un tel début, il ne sera pas facile de trouver la vérité objective.  Quelqu'un, par exemple, dira: écrire <code>Service</code> ou ne pas écrire est un point discutable, insignifiant, de bon goût, et quelle différence cela fait-il si cela fonctionne? </p><br><p>  Mais vous pouvez boire dans des gobelets jetables! </p><br><p>  Je suis convaincu que le chemin vers le contenu passe par la forme, et si l'on ne regarde pas la pensée, elle semble avoir disparu.  Dans le texte du programme, tout fonctionne de la même manière: le style, l'atmosphère et le rythme aident à s'exprimer non confus, mais compréhensible et capacitif. </p><br><p>  Le nom de l'objet n'est pas seulement son visage, mais aussi l'être, soi.  Il détermine s'il sera éthéré ou saturé, abstrait ou réel, sec ou animé.  Le nom change - le contenu change. </p><br><p>  Dans le prochain <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article, nous</a> parlerons de ce contenu et de ce qu'il se passe. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr447404/">https://habr.com/ru/post/fr447404/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr447392/index.html">Trois problèmes de services pour vérifier la grammaire anglaise et s'ils peuvent être résolus</a></li>
<li><a href="../fr447394/index.html">Entretien avec Vladimir Likhachev, père de Nikolai Likhachev, mieux connu sous le nom de Chris Kaspersky</a></li>
<li><a href="../fr447396/index.html">Les données de votre entreprise sont-elles précieuses à l'ère de l'IA?</a></li>
<li><a href="../fr447398/index.html">Automatisation robotisée des processus - Un nouveau regard sur les anciennes technologies</a></li>
<li><a href="../fr447402/index.html">Splunk Universal Forwarder dans docker comme enregistreur de système</a></li>
<li><a href="../fr447406/index.html">Comment travailler avec ViewPager2</a></li>
<li><a href="../fr447408/index.html">Apprendre l'anglais de l'élémentaire à intermédiaire: ressources utiles et motivation</a></li>
<li><a href="../fr447410/index.html">Feu de joie provincial ou naissance d'une nation</a></li>
<li><a href="../fr447412/index.html">Surveillance des messages dans RabbitMQ</a></li>
<li><a href="../fr447414/index.html">Sortie de ML.NET 1.0 RC. Quoi de neuf</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>