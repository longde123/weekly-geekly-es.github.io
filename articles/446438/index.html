<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙄 🚈 👋🏽 Nuestra experiencia de creación de API de puerta de enlace 🧕🏾 😑 🤾🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Algunas compañías, incluido nuestro cliente, desarrollan el producto a través de una red de afiliados. Por ejemplo, las grandes tiendas en línea están...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nuestra experiencia de creación de API de puerta de enlace</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/true_engineering/blog/446438/">  Algunas compañías, incluido nuestro cliente, desarrollan el producto a través de una red de afiliados.  Por ejemplo, las grandes tiendas en línea están integradas con un servicio de entrega: usted ordena productos y pronto recibe un número de seguimiento para el paquete.  Otro ejemplo: junto con un boleto aéreo, compra un seguro o un boleto Aeroexpress. <br><br>  Para esto, se utiliza una API, que debe emitirse a los socios a través de la API de Gateway.  Hemos resuelto este problema.  Este artículo proporcionará detalles. <br><br>  Dado: ecosistema y portal API con una interfaz donde los usuarios están registrados, reciben información, etc.  Necesitamos hacer una API de Gateway conveniente y confiable.  En el proceso, necesitábamos proporcionar <br><br><ul><li>  Registro </li><li>  Control de conexión API </li><li>  Monitorear cómo los usuarios usan el sistema final </li><li>  contabilidad de indicadores de negocios. </li></ul><br><img src="https://habrastorage.org/webt/op/f3/aa/opf3aadequfubwpkiu4gci8j9nm.png"><br><br>  En el artículo, hablaremos sobre nuestra experiencia en la creación de la API de Gateway, durante la cual resolvimos las siguientes tareas: <br><br><ul><li>  autenticación de usuario </li><li>  autorización de usuario </li><li>  modificación de la solicitud original, </li><li>  solicitud de representación </li><li>  postprocesamiento de la respuesta. </li></ul><br><a name="habracut"></a><br>  Hay dos tipos de gestión de API: <br><br>  1. Estándar, que funciona de la siguiente manera.  Antes de conectarse, el usuario prueba las posibilidades, luego paga e incrusta en su sitio.  Con mayor frecuencia se usa en pequeñas y medianas empresas. <br><br>  2. Una gran Administración de API B2B, cuando la empresa toma una decisión comercial por primera vez sobre la conexión, se convierte en una empresa asociada con una obligación contractual y luego se conecta a la API.  Y después de resolver todas las formalidades, la empresa obtiene acceso a las pruebas, las aprueba y entra en ventas.  Pero esto no es posible sin una decisión de administración para conectarse. <br><br><img src="https://habrastorage.org/webt/go/qv/oi/goqvoiroiq0yknutwbn9hrt7abe.jpeg"><br><br><h3>  Nuestra decision </h3><br>  En esta parte, hablaremos sobre la creación de la API de Gateway. <br><br>  Los usuarios finales de la puerta de enlace creada a la API son los socios de nuestros clientes.  Para cada uno de ellos, ya tenemos los contratos necesarios.  Solo necesitaremos expandir la funcionalidad, teniendo en cuenta el acceso otorgado a la puerta de enlace.  En consecuencia, se necesita una conexión controlada y un proceso de control. <br><br>  Por supuesto, uno podría tomar una solución lista para resolver la tarea de Administración de API y crear API Gateway en particular.  Por ejemplo, esto podría ser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Azure API Management</a> .  No nos convenía, porque en nuestro caso ya teníamos un portal API y un gran ecosistema construido a su alrededor.  Todos los usuarios ya se han registrado, ya entendieron dónde y cómo pueden obtener la información necesaria.  Las interfaces necesarias ya existían en el portal API, solo necesitábamos API Gateway.  En realidad, comenzamos a desarrollarlo. <br><br>  Lo que llamamos la API de Gateway es un tipo de proxy.  Aquí nuevamente tuvimos una opción: puede escribir su proxy o puede elegir algo listo para usar.  En este caso, fuimos por el segundo camino y elegimos el paquete nginx + Lua.  Por qué  Necesitábamos un software confiable y probado que sea compatible con el escalado.  Después de la implementación, no queríamos verificar la corrección de la lógica de negocios y la corrección del proxy. <br><br>  Cualquier servidor web tiene una canalización de procesamiento de solicitudes.  En el caso de nginx, se ve así: <br><br><img src="https://habrastorage.org/webt/7p/bu/9y/7pbu9y7z9ier1gtfhmu5pccawlu.png"><br><br>  (diagrama de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub Lua Nginx</a> ) <br><br>  Nuestro objetivo era integrarnos en esta tubería en el momento en que podemos modificar la solicitud original. <br><br>  Queremos crear un proxy transparente para que la solicitud permanezca funcionalmente como llegó.  Solo controlamos el acceso a la API final, ayudamos a la solicitud para llegar a ella.  En caso de que la solicitud fuera incorrecta, la API final debería mostrar el error, pero no nosotros.  La única razón por la que podemos rechazar la solicitud es por la falta de acceso al cliente. <br><br>  Para nginx, ya existe una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">extensión</a> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lua</a> .  Lua es un lenguaje de script, es muy ligero y fácil de aprender.  Por lo tanto, implementamos la lógica necesaria usando Lua. <br><br>  La configuración nginx (analogía con la ruta de la aplicación), donde se realiza todo el trabajo, es comprensible.  Cabe destacar aquí la última directiva: post_action. <br><br><pre><code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /middleware { <span class="hljs-attribute"><span class="hljs-attribute">more_clear_input_headers</span></span> Accept-Encoding; <span class="hljs-attribute"><span class="hljs-attribute">lua_need_request_body</span></span> <span class="hljs-literal"><span class="hljs-literal">on</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">rewrite_by_lua_file</span></span> <span class="hljs-string"><span class="hljs-string">'middleware/rewrite.lua'</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">access_by_lua_file</span></span> <span class="hljs-string"><span class="hljs-string">'middleware/access.lua'</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> https://someurl.com; <span class="hljs-attribute"><span class="hljs-attribute">body_filter_by_lua_file</span></span> <span class="hljs-string"><span class="hljs-string">'middleware/body_filter.lua'</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">post_action</span></span> /process_session; }</code> </pre> <br>  Considere lo que sucede en esta configuración: <br>  <b>more_clear_input_headers</b> : borra el valor de los encabezados especificados después de la directiva. <br>  <b>lua_need_request_body</b> : controla si se debe leer el cuerpo de origen de la solicitud antes de ejecutar las directivas rewrite / access / access_by_lua o no.  De forma predeterminada, nginx no lee el cuerpo de la solicitud del cliente y, si necesita acceder a él, esta directiva debe estar activada. <br>  <b>rewrite_by_lua_file</b> : la ruta a los scripts, que describe la lógica para modificar la solicitud <br>  <b>access_by_lua_file</b> : la ruta al script, que describe la lógica que verifica el acceso al recurso. <br>  <b>proxy_pass</b> : url a la que se enviará la solicitud por proxy. <br>  <b>body_filter_by_lua_file</b> : la ruta al script, que describe la lógica para filtrar la solicitud antes de regresar al cliente. <br>  Y finalmente, <b>post_action</b> es una directiva oficialmente indocumentada que se puede usar para realizar cualquier otra acción después de que se da la respuesta al cliente. <br><br>  A continuación, describiremos en orden cómo resolvimos nuestros problemas. <br><br><h3>  Autorización / autenticación y solicitud de modificación </h3><br>  <b>Iniciar sesión</b> <br><br>  Creamos autorización y autenticación mediante accesos de certificados.  Hay un certificado raíz.  Cada nuevo cliente del cliente genera su certificado personal con el que puede acceder a la API.  Este certificado se configura en la sección del servidor de configuración nginx. <br><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">ssl</span></span> <span class="hljs-literal"><span class="hljs-literal">on</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">ssl_certificate</span></span> /usr/local/openresty/nginx/ssl/cert.pem; <span class="hljs-attribute"><span class="hljs-attribute">ssl_certificate_key</span></span> /usr/local/openresty/nginx/ssl/cert.pem; <span class="hljs-attribute"><span class="hljs-attribute">ssl_client_certificate</span></span> /usr/local/openresty/nginx/ssl/ca.crt; <span class="hljs-attribute"><span class="hljs-attribute">ssl_verify_client</span></span> <span class="hljs-literal"><span class="hljs-literal">on</span></span>;</code> </pre> <br>  <b>Modificación</b> <br><br>  Puede surgir una pregunta justa: ¿qué hacer con un cliente certificado si de repente queremos desconectarlo del sistema?  No vuelva a emitir certificados para todos los demás clientes. <br><br>  Así que nos acercamos sin problemas a la siguiente tarea: la modificación de la solicitud original.  La solicitud original del cliente, en términos generales, no es válida para el sistema final.  Una de las tareas es agregar las partes que faltan a la solicitud para que sea válida.  El punto es que los datos que faltan son diferentes para cada cliente.  Sabemos que el cliente nos llega con un certificado del que podemos tomar una huella digital y extraer los datos necesarios del cliente de la base de datos. <br><br>  Si en algún momento necesita desconectar al cliente de nuestro servicio, sus datos desaparecerán de la base de datos y no podrá hacer nada. <br><br><h3>  Trabajar con datos del cliente. </h3><br>  Necesitábamos garantizar una alta disponibilidad de la solución, especialmente cómo obtenemos los datos del cliente.  La dificultad es que la fuente de estos datos es un servicio de terceros que no garantiza una velocidad ininterrumpida y bastante alta. <br><br>  Por lo tanto, necesitábamos garantizar una alta disponibilidad de los datos del cliente.  Como herramienta, elegimos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hazelcast</a> , que nos proporciona: <br><br><ul><li>  acceso rápido a los datos </li><li>  La capacidad de organizar un clúster de varios nodos con datos replicados en diferentes nodos. </li></ul><br>  Fuimos por la estrategia de entrega de caché más simple: <br><br><img src="https://habrastorage.org/webt/u6/f6/72/u6f6729km0g71ge4prl5ww1kes8.png"><br><br>  El trabajo con el sistema final ocurre dentro del marco de las sesiones y hay un límite en el número máximo.  Si el cliente no cerró la sesión, tendremos que hacer esto. <br><br>  Los datos de sesión abierta provienen del sistema de destino y se procesan inicialmente en el lado de Lua.  Decidimos usar Hazelcast para guardar estos datos con un escritor .NET.  Luego, en algunos intervalos, verificamos el derecho a la vida de las sesiones abiertas y cerramos la falta. <br><br><h3>  Acceso a Hazelcast desde Lua y .NET </h3><br>  No hay clientes en Lua para trabajar con Hazelcast, pero Hazelcast tiene una API REST, que decidimos usar.  Para .NET, hay un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cliente a</a> través del cual planeamos acceder a los datos de Hazelcast en el lado .NET.  Pero ahí estaba. <br><br><img src="https://habrastorage.org/webt/qr/xn/ip/qrxnipywarywskcoslishyb8xtm.png"><br><br>  Al guardar datos a través de REST y recuperarlos a través del cliente .NET, se utilizan diferentes serializadores / deserializadores.  Por lo tanto, es imposible poner los datos a través de REST, pero a través del cliente .NET y viceversa. <br><br>  Si está interesado, hablaremos más sobre este problema en un artículo separado.  Spoiler - en el shemka. <br><br><img src="https://habrastorage.org/webt/wh/l8/ra/whl8rayewel52cotktzhfcejmbs.png"><br><br><h3>  Registro y Monitoreo </h3><br>  Nuestro estándar corporativo para iniciar sesión a través de .NET es Serilog, todos los registros terminan en Elasticsearch, los analizamos a través de Kibana.  Quería hacer algo similar en este caso.  El único <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cliente</a> que trabajó con Elastic en Lua que se encontró quebró en el primer requerimiento.  Y usamos Fluentd. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fluentd</a> es una solución de código abierto para proporcionar una sola capa de registro de aplicaciones.  Le permite recopilar registros de diferentes capas de la aplicación y luego traducirlos a una sola fuente. <br><br>  La API de Gateway funciona en K8S, por lo que decidimos agregar el contenedor con fluentd al mismo subtipo para escribir registros en el puerto tcp abierto existente fluentd. <br><br>  También examinamos cómo se comportaría fluentd si no tuviera conexión con Elasticsearch.  Durante dos días, las solicitudes se enviaron continuamente a la puerta de enlace, los registros se enviaron a fluentd, pero se prohibió la fluidez de IP Elastic.  Después de reconectarse, fluentd superó perfectamente todos los registros en Elastic. <br><br><h3>  Conclusión </h3><br>  El enfoque elegido para la implementación nos permitió entregar un producto realmente funcional para el entorno de combate en solo 2.5 meses. <br><br>  Si alguna vez hace tales cosas, le recomendamos primero que comprenda claramente qué problema está resolviendo y cuáles de los recursos que ya tiene.  Tenga en cuenta las complejidades de la integración con los sistemas de gestión de API existentes. <br><br>  Comprenda por sí mismo qué es exactamente lo que va a desarrollar: solo la lógica empresarial del procesamiento de solicitudes o, como podría ser el caso en nuestro caso, el proxy completo.  Recuerde que todo lo que haga usted mismo debe probarse a fondo después. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/446438/">https://habr.com/ru/post/446438/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446428/index.html">Cómo se construyó la planta de abejorros de HR</a></li>
<li><a href="../446430/index.html">Enfriamiento de una nanopartícula levitante por medio de un resonador óptico</a></li>
<li><a href="../446432/index.html">Se celebró un seminario sobre gestión de documentos técnicos en Crimea</a></li>
<li><a href="../446434/index.html">Escala de Zimbra Collaboration Suite</a></li>
<li><a href="../446436/index.html">Cómo generar hipótesis sobre las necesidades de los consumidores potenciales de su producto futuro</a></li>
<li><a href="../446440/index.html">El libro Reacciona rápido. Aplicaciones web en React, JSX, Redux y GraphQL »</a></li>
<li><a href="../446444/index.html">De Skype a WebRTC: cómo organizamos la comunicación de video web</a></li>
<li><a href="../446446/index.html">Conceptos básicos del motor de JavaScript: formularios generales y almacenamiento en caché en línea. Parte 1</a></li>
<li><a href="../446448/index.html">5 reglas básicas para realizar entrevistas problemáticas para identificar las necesidades del consumidor</a></li>
<li><a href="../446452/index.html">Misión lunar "Bereshit": el 4 de abril de 2019, se completó la transición a la órbita lunar, 7 días de vuelo por delante, 6 maniobras y 1 aterrizaje</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>