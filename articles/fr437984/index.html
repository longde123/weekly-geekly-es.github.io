<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí¨ üç† üìë Threading dans Node.js: module worker_threads üë®‚Äçüíª üë©üèΩ‚Äçüåæ üëèüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le 18 janvier, la version 11.7.0 de la plateforme Node.js a √©t√© annonc√©e . Parmi les changements notables de cette version, on peut noter la conclusio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Threading dans Node.js: module worker_threads</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/437984/">  Le 18 janvier, la version <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">11.7.0 de la</a> plateforme Node.js a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©t√© annonc√©e</a> .  Parmi les changements notables de cette version, on peut noter la conclusion de la cat√©gorie du module exp√©rimental worker_threads, apparue dans Node.js <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">10.5.0</a> .  Maintenant, le drapeau --experimental-worker n'est plus n√©cessaire pour l'utiliser.  Ce module, depuis sa cr√©ation, est rest√© assez stable, et donc la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©cision a</a> √©t√© prise, refl√©t√©e dans Node.js 11.7.0. <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/jp/qj/fk/jpqjfkjewyfpm1cbr5yxaubxt-w.png"></a> <br>  L'auteur du document, dont nous publions la traduction, propose de discuter des capacit√©s du module worker_threads, en particulier, il souhaite expliquer pourquoi ce module est n√©cessaire et comment le multithreading est impl√©ment√© dans JavaScript et Node.js pour des raisons historiques.  Nous parlerons ici des probl√®mes associ√©s √† l'√©criture d'applications JS multithread, des moyens existants de les r√©soudre et de l'avenir du traitement parall√®le des donn√©es en utilisant les soi-disant ¬´threads de travail¬ª, parfois appel√©s ¬´threads de travail¬ª ou simplement des ¬´travailleurs¬ª. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">La vie dans un monde √† fil unique</font> </h2><br>  JavaScript a √©t√© con√ßu comme un langage de programmation monothread qui s'ex√©cute dans un navigateur.  ¬´Simple thread¬ª signifie que dans le m√™me processus (dans les navigateurs modernes, nous parlons d'onglets de navigateur s√©par√©s), un seul ensemble d'instructions peut √™tre ex√©cut√© √† la fois. <br><br>  Cela simplifie le d√©veloppement d'applications, facilite le travail des programmeurs.  Initialement, JavaScript √©tait un langage adapt√© uniquement pour ajouter des fonctionnalit√©s interactives aux pages Web, par exemple, quelque chose comme la validation de formulaire.  Parmi les t√¢ches pour lesquelles JS a √©t√© con√ßu, il n‚Äôy avait rien de particuli√®rement compliqu√© n√©cessitant le multithreading. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ryan Dahl</a> , cr√©ateur de Node.js, a vu une opportunit√© int√©ressante dans cette restriction linguistique.  Il voulait impl√©menter une plateforme serveur bas√©e sur un sous-syst√®me d'E / S asynchrone.  Cela signifiait que le programmeur n'avait pas besoin de travailler avec des threads, ce qui simplifie consid√©rablement le d√©veloppement d'une plate-forme similaire.  Lors du d√©veloppement de programmes con√ßus pour l'ex√©cution de code parall√®le, des probl√®mes peuvent survenir et sont tr√®s difficiles √† r√©soudre.  Supposons que si plusieurs threads tentent d'acc√©der √† la m√™me zone de m√©moire, cela peut conduire √† ce que l'on appelle ¬´l'√©tat de course du processus¬ª qui perturbe le programme.  Ces erreurs sont difficiles √† reproduire et √† corriger. <br><br><h2>  <font color="#3AC1EF">La plate-forme Node.js est-elle monothread?</font> </h2><br>  Les applications Node.js sont-elles monothread?  Oui, en quelque sorte.  En fait, Node.js vous permet d'effectuer certaines actions en parall√®le, mais pour cela, le programmeur n'a pas besoin de cr√©er de threads ou de les synchroniser.  La plate-forme Node.js et le syst√®me d'exploitation effectuent des op√©rations d'entr√©e / sortie parall√®les en utilisant leurs propres moyens, et lorsque vient le temps de traiter les donn√©es √† l'aide de notre code JavaScript, cela fonctionne en mode monotrame. <br><br>  En d'autres termes, tout sauf notre code JS fonctionne en parall√®le.  Dans les blocs synchrones de code JavaScript, les commandes sont toujours ex√©cut√©es une par une, dans l'ordre dans lequel elles sont pr√©sent√©es dans le code source: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> flag = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  flag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>  <span class="hljs-comment"><span class="hljs-comment">//    -  (     flag)...  //      ,     flag   true.  // -       ,  //      . }</span></span></code> </pre> <br>  Tout cela est g√©nial - si tout notre code est occup√© √† effectuer des E / S asynchrones.  Le programme se compose de petits blocs de code synchrone qui fonctionnent rapidement sur les donn√©es, par exemple, envoy√©es aux fichiers et aux flux.  Le code des fragments de programme est si rapide qu'il ne bloque pas l'ex√©cution du code de ses autres fragments.  Il faut beaucoup plus de temps que l'ex√©cution du code pour attendre les r√©sultats des E / S asynchrones.  Prenons un petit exemple: <br><br><pre> <code class="javascript hljs">db.findOne(<span class="hljs-string"><span class="hljs-string">'SELECT ... LIMIT 1'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, result</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result) }) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Running query'</span></span>) setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hey there'</span></span>) }, <span class="hljs-number"><span class="hljs-number">1000</span></span>)</code> </pre> <br>  Il est possible que la requ√™te vers la base de donn√©es pr√©sent√©e ici prenne environ une minute, mais le message de <code>Running query</code> sera envoy√© √† la console imm√©diatement apr√®s le lancement de cette requ√™te.  Dans ce cas, le message <code>Hey there</code> sera affich√© une seconde apr√®s l'ex√©cution de la demande, que son ex√©cution soit termin√©e ou non.  Notre application Node.js appelle simplement la fonction qui initie la requ√™te, tandis que l'ex√©cution de son autre code n'est pas bloqu√©e.  Une fois la demande termin√©e, l'application en sera inform√©e √† l'aide de la fonction de rappel, puis elle recevra une r√©ponse √† cette demande. <br><br><h2>  <font color="#3AC1EF">T√¢ches gourmandes en CPU</font> </h2><br>  Que se passe-t-il si nous devons, via JavaScript, faire de l'informatique lourde?  Par exemple - pour traiter un grand ensemble de donn√©es stock√©es en m√©moire?  Cela peut conduire au fait que le programme contiendra un fragment de code synchrone, dont l'ex√©cution prend beaucoup de temps et bloque l'ex√©cution d'un autre code.  Imaginez que ces calculs prennent 10 secondes.  Si nous parlons d'un serveur Web qui traite une certaine demande, cela signifie qu'il ne sera pas en mesure de traiter d'autres demandes pendant au moins 10 secondes.  C'est un gros probl√®me.  En fait, des calculs sup√©rieurs √† 100 millisecondes peuvent d√©j√† provoquer ce probl√®me. <br><br>  JavaScript et la plateforme Node.js n'ont pas √©t√© initialement con√ßus pour r√©soudre des t√¢ches qui utilisent intensivement les ressources du processeur.  Dans le cas de JS ex√©cut√© dans le navigateur, l'ex√©cution de telles t√¢ches signifie ¬´freins¬ª sur l'interface utilisateur.  Dans Node.js, cela peut limiter la possibilit√© de demander √† la plate-forme d'effectuer de nouvelles t√¢ches d'E / S asynchrones et la capacit√© de r√©pondre aux √©v√©nements associ√©s √† leur ex√©cution. <br><br>  Revenons √† notre exemple pr√©c√©dent.  Imaginez qu'en r√©ponse √† une requ√™te dans la base de donn√©es, plusieurs milliers d'enregistrements chiffr√©s sont entr√©s, qui, en code JS synchrone, doivent √™tre d√©chiffr√©s: <br><br><pre> <code class="javascript hljs">db.findAll(<span class="hljs-string"><span class="hljs-string">'SELECT ...'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, results</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) <span class="hljs-comment"><span class="hljs-comment">//      ,    . for (const encrypted of results) {   const plainText = decrypt(encrypted)   console.log(plainText) } })</span></span></code> </pre> <br>  Les r√©sultats, apr√®s les avoir re√ßus, sont dans la fonction de rappel.  Apr√®s cela, jusqu'√† la fin de leur traitement, aucun autre code JS ne peut √™tre ex√©cut√©.  Habituellement, comme d√©j√† mentionn√©, la charge sur le syst√®me cr√©√©e par un tel code est minime, il ex√©cute rapidement les t√¢ches qui lui sont assign√©es.  Mais dans ce cas, le programme a re√ßu les r√©sultats de la requ√™te, qui ont une quantit√© consid√©rable, et nous devons encore les traiter.  Quelque chose comme √ßa peut prendre quelques secondes.  Si nous parlons d'un serveur avec lequel de nombreux utilisateurs travaillent, cela signifie qu'ils ne peuvent continuer √† fonctionner qu'apr√®s la fin d'une op√©ration gourmande en ressources. <br><br><h2>  <font color="#3AC1EF">Pourquoi JavaScript n'aura-t-il jamais de fils?</font> </h2><br>  Compte tenu de ce qui pr√©c√®de, il peut sembler que pour r√©soudre de gros probl√®mes informatiques dans Node.js, vous devez ajouter un nouveau module qui vous permettra de cr√©er des threads et de les g√©rer.  Comment pouvez-vous vous passer de quelque chose comme √ßa?  Il est tr√®s triste que ceux qui utilisent une plate-forme de serveur mature, comme Node.js, n'aient pas les moyens de r√©soudre magnifiquement les probl√®mes li√©s au traitement de grandes quantit√©s de donn√©es. <br><br>  Tout cela est vrai, mais si vous ajoutez la possibilit√© de travailler avec des flux en JavaScript, cela entra√Ænera un changement dans la nature m√™me de ce langage.  Dans JS, vous ne pouvez pas simplement ajouter la possibilit√© de travailler avec des threads, par exemple, sous la forme d'un nouvel ensemble de classes ou de fonctions.  Pour ce faire, vous devez changer la langue elle-m√™me.  Dans les langues qui prennent en charge le multithreading, le concept de synchronisation est largement utilis√©.  Par exemple, en Java, m√™me <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">certains types num√©riques</a> ne sont pas atomiques.  Cela signifie que si les m√©canismes de synchronisation ne sont pas utilis√©s pour travailler avec eux √† partir de diff√©rents threads, tout cela peut entra√Æner, par exemple, apr√®s que quelques threads tentent simultan√©ment de modifier la valeur de la m√™me variable, plusieurs octets d'une telle variable seront d√©finis sur un couler, et quelques autres.  Par cons√©quent, une telle variable contiendra quelque chose d'incompatible avec le fonctionnement normal du programme. <br><br><h2>  <font color="#3AC1EF">Solution primitive au probl√®me: it√©ration de la boucle d'√©v√©nement</font> </h2><br>  Node.js n'ex√©cutera pas le bloc de code suivant dans la file d'attente d'√©v√©nements avant la fin du bloc pr√©c√©dent.  Cela signifie que pour r√©soudre notre probl√®me, nous pouvons le diviser en morceaux repr√©sent√©s par des fragments de code synchrone, puis utiliser une construction de la forme <code>setImmediate(callback)</code> afin de planifier l'ex√©cution de ces fragments.  Le code sp√©cifi√© par la fonction de <code>callback</code> dans cette construction sera ex√©cut√© une fois les t√¢ches de l'it√©ration en cours (tick) de la boucle d'√©v√©nements termin√©es.  Apr√®s cela, la m√™me conception est utilis√©e pour mettre en file d'attente le prochain lot de calculs.  Cela permet de ne pas bloquer le cycle des √©v√©nements et, en m√™me temps, de r√©soudre des probl√®mes volum√©triques. <br><br>  Imaginez que nous ayons un grand tableau qui doit √™tre trait√©, alors que le traitement de chaque √©l√©ment d'un tel tableau n√©cessite des calculs complexes: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-comment"><span class="hljs-comment">/*large array*/</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> arr) { <span class="hljs-comment"><span class="hljs-comment">//         } // ,   ,      .</span></span></code> </pre> <br>  Comme d√©j√† mentionn√©, si nous d√©cidons de traiter l'ensemble du tableau en un seul appel, cela prendra trop de temps et emp√™chera l'ex√©cution d'un autre code d'application.  Par cons√©quent, nous allons diviser cette grande t√¢che en parties et utiliser la construction <code>setImmediate(callback)</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> crypto = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'crypto'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">200</span></span>).fill(<span class="hljs-string"><span class="hljs-string">'something'</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processChunk</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr.length === <span class="hljs-number"><span class="hljs-number">0</span></span>) {   <span class="hljs-comment"><span class="hljs-comment">// ,      } else {   console.log('processing chunk');   //  10         const subarr = arr.splice(0, 10)   for (const item of subarr) {     //           doHeavyStuff(item)   }   //       setImmediate(processChunk) } } processChunk() function doHeavyStuff(item) { crypto.createHmac('sha256', 'secret').update(new Array(10000).fill(item).join('.')).digest('hex') } //       , ,   , //       . let interval = setInterval(() =&gt; { console.log('tick!') if (arr.length === 0) clearInterval(interval) }, 0)</span></span></code> </pre> <br>  Maintenant, en une seule fois, nous traitons dix √©l√©ments du tableau, apr√®s quoi, en utilisant <code>setImmediate()</code> , nous planifions le prochain lot de calculs.  Et cela signifie que si vous avez besoin d'ex√©cuter un peu plus de code dans le programme, il peut √™tre ex√©cut√© entre les op√©rations de traitement des fragments du tableau.  Pour cela, ici, √† la fin de l'exemple, il y a du code qui utilise <code>setInterval()</code> . <br><br>  Comme vous pouvez le voir, un tel code semble beaucoup plus compliqu√© que sa version originale.  Et souvent, l'algorithme peut √™tre beaucoup plus complexe que le n√¥tre, ce qui signifie que, une fois impl√©ment√©, il ne sera pas facile de diviser les calculs en morceaux et de comprendre o√π, afin d'atteindre le bon √©quilibre, vous devez d√©finir <code>setImmediate()</code> , planifier le prochain calcul.  De plus, le code s'est av√©r√© √™tre asynchrone, et si notre projet d√©pend de biblioth√®ques tierces, nous ne pourrons peut-√™tre pas diviser le processus de r√©solution d'une t√¢che difficile en plusieurs parties. <br><br><h2>  <font color="#3AC1EF">Processus d'arri√®re-plan</font> </h2><br>  Peut-√™tre que l'approche ci-dessus avec <code>setImmediate()</code> fonctionnera bien pour les cas simples, mais elle est loin d'√™tre id√©ale.  De plus, les threads ne sont pas utilis√©s ici (pour des raisons √©videntes) et nous n'avons pas non plus l'intention de changer la langue pour cela.  Est-il possible de faire un traitement de donn√©es parall√®le sans utiliser de threads?  Oui, c'est possible, et pour cela, nous avons besoin d'une sorte de m√©canisme pour le traitement des donn√©es en arri√®re-plan.  Il s'agit de d√©marrer une certaine t√¢che, de lui transmettre des donn√©es, et pour que cette t√¢che, sans interf√©rer avec le code principal, utilise tout ce dont elle a besoin, passe autant de temps au travail qu'elle en a besoin, puis renvoie les r√©sultats code principal.  Nous avons besoin de quelque chose de similaire √† l'extrait de code suivant: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  script.js   ,    . const service = createService('script.js') //          service.compute(data, function(err, result) { //      })</span></span></code> </pre> <br>  La r√©alit√© est que dans Node.js, vous pouvez utiliser des processus d'arri√®re-plan.  Le fait est qu'il est possible de cr√©er une fourchette du processus et de mettre en ≈ìuvre le sch√©ma de travail d√©crit ci-dessus en utilisant le m√©canisme de messagerie entre les processus enfant et parent.  Le processus principal peut interagir avec le processus descendant, en lui envoyant des √©v√©nements et en les recevant.  La m√©moire partag√©e n'est pas utilis√©e avec cette approche.  Toutes les donn√©es √©chang√©es par les processus sont ¬´clon√©es¬ª, c'est-√†-dire que lorsque des modifications sont apport√©es √† une instance de ces donn√©es par un processus, ces modifications ne sont pas visibles par un autre processus.  Ceci est similaire √† une requ√™te HTTP - lorsqu'un client l'envoie au serveur, le serveur n'en re√ßoit qu'une copie.  Si les processus n'utilisent pas de m√©moire partag√©e, cela signifie qu'avec leur fonctionnement simultan√©, il est impossible de cr√©er un ¬´√©tat racial¬ª, et que nous n'avons pas besoin de nous encombrer de travailler avec des threads.  Il semble que notre probl√®me soit r√©solu. <br><br>  Certes, en r√©alit√©, ce n'est pas le cas.  Oui - en face de nous est l'une des solutions √† la t√¢che d'effectuer des calculs intensifs, mais elle est encore imparfaite.  La cr√©ation d'un fork d'un processus est une op√©ration gourmande en ressources.  Il faut du temps pour le terminer.  En fait, nous parlons de cr√©er une nouvelle machine virtuelle √† partir de z√©ro et d'augmenter la quantit√© de m√©moire consomm√©e par le programme, ce qui est d√ª au fait que les processus n'utilisent pas de m√©moire partag√©e.  Compte tenu de ce qui pr√©c√®de, il convient de se demander s'il est possible, apr√®s avoir termin√© une t√¢che, de r√©utiliser la fourche du processus.  Vous pouvez donner une r√©ponse positive √† cette question, mais ici, vous devez vous rappeler qu'il est pr√©vu de transf√©rer la fourchette du processus vers diverses t√¢ches gourmandes en ressources qui y seront ex√©cut√©es de mani√®re synchrone.  Deux probl√®mes peuvent √™tre vus ici: <br><br><ul><li>  Bien qu'avec cette approche, le processus principal ne soit pas bloqu√©, le processus descendant ne peut effectuer les t√¢ches qui lui sont transf√©r√©es que s√©quentiellement.  Si nous avons deux t√¢ches, dont l'une prend 10 secondes, et la seconde prend 1 seconde, et nous allons les terminer dans cet ordre, il est peu probable que nous aimions la n√©cessit√© d'attendre que la premi√®re se termine avant la seconde.  Puisque nous cr√©ons des fourches de processus, nous aimerions utiliser les capacit√©s du syst√®me d'exploitation pour planifier des t√¢ches et utiliser les ressources informatiques de tous les c≈ìurs de notre processeur.  Nous avons besoin de quelque chose qui ressemble √† un travail sur ordinateur pour une personne qui √©coute de la musique et qui parcourt les pages Web.  Pour ce faire, vous pouvez cr√©er deux processus fork et organiser l'ex√©cution parall√®le des t√¢ches avec leur aide. </li><li>  En outre, si l'une des t√¢ches entra√Æne la fin du processus avec une erreur, toutes les t√¢ches envoy√©es √† un tel processus ne seront pas trait√©es. </li></ul><br>  Afin de r√©soudre ces probl√®mes, nous avons besoin de plusieurs processus fork, pas un, mais nous devrons limiter leur nombre, car chacun d'eux prend des ressources syst√®me et il faut du temps pour cr√©er chacun d'eux.  Par cons√©quent, suivant le mod√®le de syst√®mes qui prennent en charge les connexions aux bases de donn√©es, nous avons besoin de quelque chose comme un pool de processus pr√™ts √† l'emploi.  Le syst√®me de gestion du pool de processus, √† la r√©ception de nouvelles t√¢ches, utilisera des processus libres pour les ex√©cuter, et lorsqu'un certain processus fera face √† la t√¢che, il pourra lui en assigner un nouveau.  On a le sentiment qu‚Äôun tel sch√©ma de travail n‚Äôest pas facile √† mettre en ≈ìuvre et, en fait, il l‚Äôest.  Nous utiliserons le package de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ferme</a> de travail pour impl√©menter ce sch√©ma: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   const workerFarm = require('worker-farm') const service = workerFarm(require.resolve('./script')) service('hello', function (err, output) { console.log(output) }) // script.js //      - module.exports = (input, callback) =&gt; { callback(null, input + ' ' + world) }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Module Worker_threads</font> </h2><br>  Alors, notre probl√®me est-il r√©solu?  Oui, nous pouvons dire que c'est r√©solu, mais avec cette approche, il faut beaucoup plus de m√©moire que ce qui serait n√©cessaire si nous avions une solution multithread √† notre disposition.  Les threads consomment beaucoup moins de ressources que les fourches de processus.  C'est pourquoi le module <code>worker_threads</code> est apparu dans <code>worker_threads</code> <br><br>  Les threads de travail s'ex√©cutent dans un contexte isol√©.  Ils √©changent des informations avec le processus principal √† l'aide de messages.  Cela nous √©vite le probl√®me de la ¬´condition de concurrence¬ª auquel sont soumis les environnements multithreads.  Dans le m√™me temps, les flux de travailleurs existent dans le m√™me processus que le programme principal, c'est-√†-dire qu'avec cette approche, en comparaison avec l'utilisation des fourches de processus, beaucoup moins de m√©moire est utilis√©e. <br><br>  De plus, en travaillant avec des travailleurs, vous pouvez utiliser la m√©moire partag√©e.  Ainsi, sp√©cifiquement √† cette fin, des objets de type <code>SharedArrayBuffer</code> sont <code>SharedArrayBuffer</code> .  Ils ne doivent √™tre utilis√©s que dans les cas o√π le programme doit effectuer un traitement complexe de grandes quantit√©s de donn√©es.  Ils vous permettent d'√©conomiser les ressources n√©cessaires √† la s√©rialisation et √† la d√©s√©rialisation des donn√©es lors de l'organisation de l'√©change de donn√©es entre les travailleurs et le programme principal via des messages. <br><br><h2>  <font color="#3AC1EF">Flux de travailleur</font> </h2><br>  Si vous utilisez la plate-forme Node.js avant la version 11.7.0, pour activer le travail avec le module <code>worker_threads</code> , vous devez utiliser l' <code>--experimental-worker</code> lors du d√©marrage de <code>--experimental-worker</code> <br><br>  En outre, il convient de se rappeler que la cr√©ation d'un travailleur (ainsi que la cr√©ation d'un flux dans n'importe quelle langue), bien qu'elle n√©cessite beaucoup moins de ressources que la cr√©ation d'une fourchette d'un processus, cr√©e √©galement une certaine charge sur le syst√®me.  Peut-√™tre que dans votre cas, m√™me cette charge peut √™tre excessive.  Dans de tels cas, la documentation recommande de cr√©er un pool de travailleurs.  Si vous en avez besoin, vous pouvez bien s√ªr cr√©er votre propre impl√©mentation d'un tel m√©canisme, mais vous devriez peut-√™tre chercher quelque chose qui convienne dans le registre NPM. <br><br>  Prenons un exemple de travail avec des threads de travail.  Nous aurons un fichier principal, <code>index.js</code> , dans lequel nous allons cr√©er un thread de travail et lui transmettre des donn√©es pour le traitement.  L'API correspondante est bas√©e sur les √©v√©nements, mais je vais utiliser ici une promesse qui se r√©sout lorsque le premier message du travailleur arrive: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// index.js //    Node.js   11.7.0,  //      node --experimental-worker index.js const { Worker } = require('worker_threads') function runService(workerData) { return new Promise((resolve, reject) =&gt; {   const worker = new Worker('./service.js', { workerData });   worker.on('message', resolve);   worker.on('error', reject);   worker.on('exit', (code) =&gt; {     if (code !== 0)       reject(new Error(`Worker stopped with exit code ${code}`));   }) }) } async function run() { const result = await runService('world') console.log(result); } run().catch(err =&gt; console.error(err))</span></span></code> </pre> <br>  Comme vous pouvez le voir, l'utilisation du m√©canisme de flux de travail est assez simple.  √Ä savoir, lors de la cr√©ation d'un travailleur, vous devez transmettre le chemin d'acc√®s au fichier avec le code du travailleur et les donn√©es au concepteur du <code>Worker</code> .  N'oubliez pas que ces donn√©es sont clon√©es et non stock√©es dans la m√©moire partag√©e.  Apr√®s avoir d√©marr√© le travailleur, nous attendons un message de sa part, en √©coutant l'√©v√©nement du <code>message</code> . <br><br>  Ci-dessus, lors de la cr√©ation d'un objet de type <code>Worker</code> , nous avons transmis au constructeur le nom du fichier avec le code de travail - <code>service.js</code> .  Voici le code de ce fichier: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { workerData, parentPort } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'worker_threads'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// , ,    , //    . parentPort.postMessage({ hello: workerData })</span></span></code> </pre> <br>  Il y a deux choses qui nous int√©ressent dans le code des travailleurs.  Tout d'abord, nous avons besoin des donn√©es transmises par l'application principale.  Dans notre cas, ils sont repr√©sent√©s par la variable <code>workerData</code> .  Deuxi√®mement, nous avons besoin d'un m√©canisme pour transmettre des informations √† l'application principale.  Ce m√©canisme est repr√©sent√© par l'objet <code>parentPort</code> , qui a la m√©thode <code>postMessage()</code> , √† l'aide de laquelle nous transmettons les r√©sultats du traitement des donn√©es √† l'application principale.  Voil√† comment tout cela fonctionne. <br><br>  Voici un exemple tr√®s simple, mais en utilisant les m√™mes m√©canismes, vous pouvez construire des structures beaucoup plus complexes.  Par exemple, √† partir d'un flux de travail, vous pouvez envoyer un grand nombre de messages au flux principal qui contiennent des informations sur l'√©tat du traitement des donn√©es au cas o√π notre application aurait besoin d'un m√©canisme similaire.  M√™me du travailleur, les r√©sultats du traitement des donn√©es peuvent √™tre renvoy√©s en plusieurs parties.  Par exemple, quelque chose comme cela peut √™tre utile dans une situation o√π un travailleur est occup√©, par exemple, √† traiter des milliers d'images, et vous, sans attendre que toutes soient trait√©es, souhaitez notifier √† l'application principale l'ach√®vement du traitement de chacune d'entre elles. <br><br>  Les d√©tails sur le module <code>worker_threads</code> peuvent √™tre trouv√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h2>  <font color="#3AC1EF">Travailleurs Web</font> </h2><br>  Vous avez peut-√™tre entendu parler des travailleurs du Web.  Ils sont destin√©s √† √™tre utilis√©s dans un environnement client, cette technologie existe depuis longtemps et b√©n√©ficie d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bon support pour</a> les navigateurs modernes.  L'API pour travailler avec les travailleurs Web est diff√©rente de ce que nous donne le module Node.js <code>worker_threads</code> , c'est tout sur les diff√©rences dans les environnements dans lesquels ils travaillent.  Cependant, ces technologies peuvent r√©soudre des probl√®mes similaires.  Par exemple, les travailleurs Web peuvent √™tre utilis√©s dans les applications clientes pour effectuer le chiffrement et le d√©chiffrement des donn√©es, leur compression et leur d√©compression.  Avec leur aide, vous pouvez traiter des images, mettre en ≈ìuvre des syst√®mes de vision par ordinateur (par exemple, nous parlons de reconnaissance faciale) et r√©soudre d'autres probl√®mes similaires dans un navigateur. <br><br><h2>  <font color="#3AC1EF">R√©sum√©</font> </h2><br>  <code>worker_threads</code> ‚Äî     Node.js.    ,    ,   .       , ,       ,         ¬´ ¬ª.   ,      ? ,    <code>worker_threads</code>      ,        Node.js      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">worker-farm</a> ,    <code>worker_threads</code>  ,   Node.js        . <br><br>  <b>Chers lecteurs!</b>        Node.js-? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr437984/">https://habr.com/ru/post/fr437984/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr437974/index.html">Comment gagner des WorldSkills num√©riques? Sur un exemple pratique</a></li>
<li><a href="../fr437976/index.html">"Vkontakte" autoris√© √† cacher des dossiers individuels √† la police</a></li>
<li><a href="../fr437978/index.html">Bienvenue sur SphinxSearch-meetup SuperJob</a></li>
<li><a href="../fr437980/index.html">Webinaire ouvert ¬´M√©thode de test par paire dans les tests de bo√Æte noire¬ª</a></li>
<li><a href="../fr437982/index.html">La nouvelle attaque par chiffrement de Shade cible les utilisateurs professionnels russes</a></li>
<li><a href="../fr437986/index.html">Pourquoi TypeScript est-il au c≈ìur de chaque nouvelle application Web PayPal?</a></li>
<li><a href="../fr437988/index.html">Tutoriel React, Partie 12: Atelier, Application TODO Phase 3</a></li>
<li><a href="../fr437990/index.html">Tutoriel React Partie 13: Composants bas√©s sur les classes</a></li>
<li><a href="../fr437992/index.html">Microservices. Versioning dans les syst√®mes d'int√©gration et de d√©ploiement continus √âtude de cas CI / CD utilisant TFS</a></li>
<li><a href="../fr437994/index.html">Traite automatique et serres automatiques: comment fonctionne une petite ferme de haute technologie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>