<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧡 🚓 🌌 Bersiap untuk C ++ 20. Studi Kasus Nyata Coroutines TS 🖋️ 👥 🤵🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di C ++ 20, kesempatan untuk bekerja dengan coroutine di luar kotak akan segera muncul. Topik ini dekat dan menarik bagi kami di Yandex.Taxi (untuk ke...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bersiap untuk C ++ 20. Studi Kasus Nyata Coroutines TS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/420861/">  Di C ++ 20, kesempatan untuk bekerja dengan coroutine di luar kotak akan segera muncul.  Topik ini dekat dan menarik bagi kami di Yandex.Taxi (untuk kebutuhan kami sendiri, kami sedang mengembangkan kerangka kerja asinkron).  Oleh karena itu, hari ini kami akan menunjukkan kepada pembaca Habr menggunakan contoh nyata bagaimana bekerja dengan C ++ stackless coroutine. <br><br>  Sebagai contoh, mari kita ambil sesuatu yang sederhana: tanpa bekerja dengan antarmuka jaringan asinkron, timer asinkron, yang terdiri dari satu fungsi.  Misalnya, mari kita coba sadari dan tulis ulang "mie" ini dari callback: <br><br><img align="right" src="https://habrastorage.org/webt/za/0m/kp/za0mkphg8qyitvudyvv-dhunfae.jpeg"><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FuncToDealWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ InCurrentThread(); writerQueue.PushTask([=]() { InWriterThread1(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> finally = [=]() { InWriterThread2(); ShutdownAll(); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NeedNetwork()) { networkQueue.PushTask([=](){ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> v = InNetworkThread(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v) { UIQueue.PushTask([=](){ InUIThread(); writerQueue.PushTask(finally); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { writerQueue.PushTask(finally); } }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { finally(); } }); }</code> </pre> <br><a name="habracut"></a><br><h2>  Pendahuluan </h2><br>  Coroutine atau coroutine adalah kemampuan untuk menghentikan fungsi dari mengeksekusi di lokasi yang telah ditentukan;  melewati suatu tempat seluruh negara dari fungsi berhenti bersama dengan variabel lokal;  jalankan fungsinya dari tempat yang sama tempat kami menghentikannya. <br>  Ada beberapa rasa coroutine: stackless dan stackful.  Kami akan membicarakan ini nanti. <br><br><h2>  Pernyataan masalah </h2><br>  Kami memiliki beberapa antrian tugas.  Setiap tugas berisi tugas-tugas tertentu: ada antrian untuk menggambar grafik, ada antrian untuk interaksi jaringan, dan ada antrian untuk bekerja dengan disk.  Semua antrian adalah instance dari kelas WorkQueue yang memiliki metode PushTask void (std :: function &lt;void ()&gt; task);  Antrian hidup lebih lama dari semua tugas yang ditempatkan di dalamnya (situasi dimana kami menghancurkan antrian ketika ada tugas-tugas luar biasa di dalamnya tidak boleh terjadi). <br><br>  Fungsi FuncToDealWith () dari contoh mengeksekusi beberapa logika dalam antrian yang berbeda dan, tergantung pada hasil eksekusi, menempatkan tugas baru dalam antrian. <br><br>  Kami menulis ulang "mie" dari callback dalam bentuk kode pseudo linier, menandai di mana antrian kode yang mendasarinya harus dijalankan: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CoroToDealWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ InCurrentThread(); <span class="hljs-comment"><span class="hljs-comment">// =&gt;   writerQueue InWriterThread1(); if (NeedNetwork()) { // =&gt;   networkQueue auto v = InNetworkThread(); if (v) { // =&gt;   UIQueue InUIThread(); } } // =&gt;   writerQueue InWriterThread2(); ShutdownAll(); }</span></span></code> </pre> <br>  Kira-kira hasil yang ingin saya capai ini. <br><br>  Ada batasan: <br><br><ul><li>  Antarmuka antrian tidak dapat diubah - mereka digunakan di bagian lain aplikasi oleh pengembang pihak ketiga.  Anda tidak dapat memecahkan kode pengembang atau menambahkan instance antrian baru. </li><li>  Anda tidak dapat mengubah cara Anda menggunakan fungsi FuncToDealWith.  Anda hanya dapat mengubah namanya, tetapi Anda tidak dapat membuatnya mengembalikan objek yang harus disimpan pengguna di rumah. </li><li>  Kode yang dihasilkan harus sama produktifnya dengan yang asli (atau bahkan lebih produktif). </li></ul><br><h2>  Solusi </h2><br><h3>  Menulis Ulang FuncToDealDengan Fungsi </h3><br>  Dalam Coroutines TS, penyetelan coroutine dilakukan dengan mengatur jenis nilai pengembalian fungsi.  Jika jenisnya memenuhi persyaratan tertentu, maka di dalam badan fungsi Anda dapat menggunakan kata kunci baru co_await / co_return / co_yield.  Dalam contoh ini, untuk beralih antar antrian, kami akan menggunakan co_yield: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">CoroTask </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CoroToDealWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ InCurrentThread(); co_yield writerQueue; InWriterThread1(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NeedNetwork()) { co_yield networkQueue; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> v = InNetworkThread(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v) { co_yield UIQueue; InUIThread(); } } co_yield writerQueue; InWriterThread2(); ShutdownAll(); }</code> </pre> <br>  Ternyata sangat mirip dengan pseudocode dari bagian terakhir.  Semua "sihir" untuk bekerja dengan coroutine disembunyikan di kelas CoroTask. <br><br><h3>  CoroTask </h3><br>  Dalam kasus yang paling sederhana (dalam kasus kami), isi kelas "tuner" dari coroutine hanya terdiri dari satu alias: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;experimental/coroutine&gt; struct CoroTask { using promise_type = PromiseType; };</span></span></span></span></code> </pre> <br><br>  tipe janji adalah tipe data yang harus kita tulis sendiri.  Ini berisi logika yang menjelaskan: <br><br><ul><li>  apa yang harus dilakukan ketika keluar dari coroutine </li><li>  apa yang harus dilakukan ketika Anda pertama kali memasukkan corutin </li><li>  siapa yang membebaskan sumber daya </li><li>  apa yang harus dilakukan dengan pengecualian yang keluar dari coroutine </li><li>  Cara membuat objek CoroTask </li><li>  apa yang harus dilakukan jika di dalam corutins disebut co_yield </li></ul><br>  Alias ​​janji_type harus disebut seperti itu.  Jika Anda mengubah nama alias menjadi sesuatu yang lain, kompiler akan bersumpah dan mengatakan bahwa Anda salah mengeja CoroTask.  Nama CoroTask dapat diubah sesuka Anda. <br><br><div class="spoiler">  <b class="spoiler_title">Tetapi mengapa CoroTask ini diperlukan jika semuanya dijelaskan dalam jenis janji?</b> <div class="spoiler_text">  Dalam kasus yang lebih kompleks, Anda dapat membuat CoroTask yang memungkinkan Anda berkomunikasi dengan coroutine yang terhenti, mengirim dan menerima data darinya, membangunkan dan menghancurkannya. <br></div></div><br><h3>  Jenis Janji </h3><br>  Mendapatkan bagian yang menyenangkan.  Kami menggambarkan perilaku corutin: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkQueue</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">// forward declaration class PromiseType { public: //      `co_return;`     , ... void return_void() const { /* ...    :) */ } //        ,  CoroTask, ... auto initial_suspend() const { // ...       . return std::experimental::suspend_never{}; } //      - , ... auto final_suspend() const { // ...        //      . return std::experimental::suspend_never{}; } //     , ... void unhandled_exception() const { // ...   (  ). std::terminate(); } //    CoroTask,    , ... auto get_return_object() const { // ...  CoroTask. return CoroTask{}; } //     co_yield, ... auto yield_value(WorkQueue&amp; wq) const; // ... &lt;  &gt; };</span></span></code> </pre> <br>  Pada kode di atas, Anda dapat melihat tipe data std :: eksperimental :: suspend_never.  Ini adalah tipe data khusus yang mengatakan bahwa corutin tidak perlu dihentikan.  Ada juga kebalikannya - tipe std :: eksperimental :: suspend_always, yang memberitahu Anda untuk menghentikan corutin.  Jenis-jenis ini adalah apa yang dinamakan menunggu.  Jika Anda tertarik dengan struktur internal mereka, maka jangan khawatir, kami akan segera menulis Awaitables kami. <br><br>  Tempat paling non-sepele dalam kode di atas adalah final_suspend ().  Fungsi ini memiliki efek yang tidak terduga.  Jadi, jika kita tidak menghentikan eksekusi dalam fungsi ini, maka sumber daya yang dialokasikan ke coroutine oleh kompiler akan membersihkan kompiler untuk kita.  Tetapi jika dalam fungsi ini kita menghentikan eksekusi coroutine (misalnya, dengan mengembalikan std :: experimental :: suspend_always {}), maka Anda harus secara manual membebaskan sumber daya dari suatu tempat di luar: Anda harus menyimpan pointer pintar ke coroutine di suatu tempat dan secara eksplisit menyebutnya hancurkan ().  Untungnya, ini tidak perlu untuk contoh kita. <br><br><h3>  <b>INCORRECT</b> PromiseType :: yield_value </h3><br>  Tampaknya menulis PromiseType :: yield_value cukup sederhana.  Kami memiliki garis;  coroutine, yang harus ditangguhkan dan pada gilirannya ini menempatkan: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> PromiseType::yield_value(WorkQueue&amp; wq) { <span class="hljs-comment"><span class="hljs-comment">//        std::experimental::coroutine_handle&lt;&gt; this_coro = std::experimental::coroutine_handle&lt;&gt;::from_promise(*this); //    .  this_coro  operator(),    // wq      .   , //     ,  operator(),  //   . wq.PushTask(this_coro); //     . return std::experimental::suspend_always{}; }</span></span></code> </pre> <br>  Dan di sini kita dihadapkan dengan masalah yang sangat besar dan sulit dideteksi.  Faktanya adalah pertama-tama kita meletakkan coroutine dalam antrian dan baru kemudian menangguhkannya.  Mungkin saja coroutine dihapus dari antrian dan mulai dieksekusi bahkan sebelum kita menangguhkannya di utas saat ini.  Ini akan menyebabkan kondisi balapan, perilaku tidak terdefinisi, dan kesalahan runtime yang benar-benar gila. <br><br><h3>  <b>Jenis</b> Promise yang <b>benar</b> :: yield_value </h3><br>  Jadi, pertama-tama kita harus menghentikan corutin dan baru kemudian menambahkannya ke antrian.  Untuk melakukan ini, kami akan menulis Awaitable kami dan menyebutnya schedule_for_execution: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> PromiseType::yield_value(WorkQueue&amp; wq) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">schedule_for_execution</span></span></span><span class="hljs-class"> {</span></span> WorkQueue&amp; wq; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_ready</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_suspend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::experimental::coroutine_handle&lt;&gt; this_coro)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ wq.PushTask(this_coro); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_resume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> schedule_for_execution{wq}; }</code> </pre> <br>  Kelas std :: experimental :: suspend_always, std :: eksperimental :: suspend_never, schedule_for_execution dan Awaitables lainnya harus berisi 3 fungsi.  await_ready dipanggil untuk memeriksa apakah coroutine harus dihentikan.  await_suspend dipanggil setelah program dihentikan, pegangan coroutine yang terhenti diteruskan ke sana.  await_resume dipanggil ketika eksekusi coroutine dilanjutkan. <br><div class="spoiler">  <b class="spoiler_title">Dan apa yang dapat ditulis dalam skrabs segitiga std :: experimental :: coroutine_handle &lt;&gt;?</b> <div class="spoiler_text">  Anda dapat menentukan jenis PromiseType di sana, dan contohnya akan bekerja sama persis :) <br><br>  std :: experimental :: coroutine_handle &lt;&gt; (alias std :: eksperimental :: coroutine_handle &lt;void&gt;) adalah tipe dasar untuk semua std :: experimental :: coroutine_handle &lt;DataType&gt;, di mana DataType harus merupakan jenis janji_tipe dari coroutine saat ini.  Jika Anda tidak perlu mengakses konten internal DataType, Anda dapat menulis std :: eksperimental :: coroutine_handle &lt;&gt;.  Ini bisa berguna di tempat-tempat di mana Anda ingin mengabstraksi dari tipe tertentu dari tipe janji dan gunakan tipe penghapusan. <br></div></div><br><h3>  Selesai </h3><br>  Anda dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengkompilasi, menjalankan contoh online dan bereksperimen dengan segala cara</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Dan jika saya tidak suka co_yield, dapatkah saya menggantinya dengan sesuatu?</b> <div class="spoiler_text">  Dapat diganti dengan co_await.  Untuk melakukan ini, tambahkan fungsi berikut ke PromiseType: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_transform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WorkQueue&amp; wq)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> yield_value(wq); }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Tetapi bagaimana jika saya tidak suka co_await?</b> <div class="spoiler_text">  Masalahnya buruk.  Tidak ada yang berubah. <br></div></div><br></div></div><br><h3>  Lembar curang </h3><br>  CoroTask adalah kelas yang menyesuaikan perilaku coroutine.  Dalam kasus yang lebih kompleks, ini memungkinkan Anda untuk berkomunikasi dengan coroutine yang dihentikan dan mengambil data apa pun darinya. <br><br>  CoroTask :: janji_type menjelaskan bagaimana dan kapan coroutine berhenti, bagaimana membebaskan sumber daya, dan bagaimana membangun CoroTask. <br><br>  Awaitables (std :: eksperimental :: suspend_always, std :: eksperimental :: suspend_never, schedule_for_execution dan lain-lain) memberi tahu kompilator apa yang harus dilakukan dengan coroutine pada titik tertentu (apakah perlu menghentikan corutin, apa yang harus dilakukan dengan menghentikan corutin dan apa yang harus dilakukan ketika corutin bangun) . <br><br><h3>  Optimalisasi </h3><br>  Ada kekurangan dalam PromiseType kami.  Sekalipun saat ini kami sedang menjalankan antrian tugas yang benar, memanggil co_yield masih akan menangguhkan coroutine dan menempatkannya kembali di antrian tugas yang sama.  Akan jauh lebih optimal untuk tidak menghentikan eksekusi coroutine, tetapi untuk melanjutkan eksekusi segera. <br><br>  Mari kita perbaiki cacat ini.  Untuk melakukan ini, tambahkan bidang pribadi ke PromiseType: <br><br><pre> <code class="cpp hljs">WorkQueue* current_queue_ = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>;</code> </pre> <br>  Di dalamnya, kita akan memegang pointer ke antrian di mana kita sedang mengeksekusi. <br><br>  Selanjutnya, tweak PromiseType :: yield_value: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> PromiseType::yield_value(WorkQueue&amp; wq) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">schedule_for_execution</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> do_resume; WorkQueue&amp; wq; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_ready</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_resume; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_suspend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::experimental::coroutine_handle&lt;&gt; this_coro)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ wq.PushTask(this_coro); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_resume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> do_not_suspend = (current_queue_ == &amp;wq); current_queue_ = &amp;wq; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> schedule_for_execution{do_not_suspend, wq}; }</code> </pre> <br>  Di sini kami mengutak-atik schedule_for_execution :: await_ready ().  Sekarang fungsi ini memberi tahu kompiler bahwa coroutine tidak perlu ditangguhkan jika antrian tugas saat ini cocok dengan yang kita coba mulai. <br><br>  Selesai  Anda dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bereksperimen dengan segala cara</a> . <br><br><h2>  Tentang kinerja </h2><br>  Dalam contoh asli, dengan setiap panggilan ke WorkQueue :: PushTask (std :: function &lt;void ()&gt; f), kami membuat instance dari kelas std :: function &lt;void ()&gt; dari lambda.  Dalam kode sebenarnya, lambda ini sering berukuran cukup besar, itulah sebabnya std :: function &lt;void ()&gt; dipaksa mengalokasikan memori secara dinamis untuk menyimpan lambdas. <br><br>  Pada contoh coroutine, kita membuat instance std :: function &lt;void ()&gt; dari std :: experimental :: coroutine_handle &lt;&gt;.  Ukuran std :: eksperimental :: coroutine_handle &lt;&gt; tergantung pada implementasinya, tetapi sebagian besar implementasi mencoba menjaga ukurannya seminimal mungkin.  Jadi pada dentang ukurannya sama dengan sizeof (void *).  Ketika membangun std :: function &lt;void ()&gt;, alokasi dinamis tidak terjadi dari objek kecil. <br>  Total - dengan Coroutines kami menyingkirkan beberapa alokasi dinamis yang tidak perlu. <br><br>  Tapi!  Kompiler seringkali tidak bisa hanya menyimpan semua coroutine di stack.  Karena itu, satu alokasi dinamis tambahan dimungkinkan ketika memasuki CoroToDealWith. <br><br><h2>  Stackless vs stackful </h2><br>  Kami baru saja bekerja dengan coroutine Stackless, yang membutuhkan dukungan dari kompiler untuk bekerja dengannya.  Ada juga Stackful Coroutine yang dapat diimplementasikan sepenuhnya di tingkat perpustakaan. <br><br>  Yang pertama memungkinkan alokasi memori yang lebih ekonomis, berpotensi lebih baik dioptimalkan oleh kompiler.  Yang kedua lebih mudah diimplementasikan dalam proyek-proyek yang ada, karena mereka membutuhkan lebih sedikit modifikasi kode.  Namun, dalam contoh ini Anda tidak dapat merasakan perbedaannya, dibutuhkan contoh yang lebih rumit. <br><br><h2>  Ringkasan </h2><br>  Kami memeriksa contoh dasar dan mendapatkan CoroTask kelas universal, yang dapat digunakan untuk membuat coroutine lainnya. <br><br>  Kode dengannya menjadi lebih mudah dibaca dan sedikit lebih produktif daripada dengan pendekatan naif: <br><table><tbody><tr><th>  Apakah </th><th>  Dengan coroutine </th></tr><tr><td><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FuncToDealWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ InCurrentThread(); writerQueue.PushTask([=]() { InWriterThread1(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> fin = [=]() { InWriterThread2(); ShutdownAll(); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NeedNetwork()) { networkQueue.PushTask([=](){ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> v = InNetThread(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v) { UIQueue.PushTask([=](){ InUIThread(); writerQueue.PushTask(fin); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { writerQueue.PushTask(fin); } }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fin(); } }); }</code> </pre></td><td><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">CoroTask </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CoroToDealWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ InCurrentThread(); co_yield writerQueue; InWriterThread1(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NeedNetwork()) { co_yield networkQueue; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> v = InNetThread(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v) { co_yield UIQueue; InUIThread(); } } co_yield writerQueue; InWriterThread2(); ShutdownAll(); }</code> </pre> </td></tr></tbody></table><br>  Di atas kapal ada saat-saat: <br><br><ul><li>  cara memanggil coroutine lain dari corutin dan menunggu selesainya </li><li>  hal-hal berguna apa yang dapat Anda masukkan di CoroTask </li><li>  contoh yang membuat perbedaan antara Stackless dan Stackful </li></ul><br><h2>  Lainnya </h2><br>  Jika Anda ingin mempelajari tentang hal baru lain dari bahasa C ++ atau berkomunikasi secara pribadi dengan kolega Anda di plus, maka lihat di konferensi C ++ Rusia.  Yang berikutnya akan diadakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pada 6 Oktober di Nizhny Novgorod</a> . <br><br>  Jika Anda memiliki rasa sakit yang terkait dengan C ++ dan ingin meningkatkan sesuatu dalam bahasa tersebut atau hanya ingin mendiskusikan kemungkinan inovasi, maka selamat datang di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://stdcpp.ru/</a> . <br><br>  Nah, jika Anda terkejut bahwa Yandex.Taxi memiliki sejumlah besar tugas yang tidak terkait dengan grafik, maka saya harap ini ternyata menjadi kejutan yang menyenangkan bagi Anda :) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kunjungi kami pada 11 Oktober</a> , kami akan berbicara tentang C ++ dan banyak lagi. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id420861/">https://habr.com/ru/post/id420861/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id420845/index.html">Penjinakan keras kepala dengan menggunakan kruk: lubang adaptor Wi-Fi WF2190 (Realtek8812AU Wireless LAN 802.11ac USB)</a></li>
<li><a href="../id420847/index.html">Pengantar Pemrograman Shader untuk Tata Letak</a></li>
<li><a href="../id420853/index.html">Memenuhi Windows Pseudo Console (ConPTY)</a></li>
<li><a href="../id420857/index.html">Roaming Wi-Fi mulus: teori dalam praktik</a></li>
<li><a href="../id420859/index.html">Untuk pertanyaan Wirth dan rantai</a></li>
<li><a href="../id420863/index.html">Saat kami melakukan smartphone Rusia pertama, melanjutkan</a></li>
<li><a href="../id420865/index.html">Prinsip tindakan paling tidak. Bagian 1</a></li>
<li><a href="../id420867/index.html">Perhitungan integral pasti: algoritma dasar</a></li>
<li><a href="../id420869/index.html">Evakuasi, HAMR dan MAMR - tiga cara untuk memaksimalkan kapasitas HDD modern</a></li>
<li><a href="../id420871/index.html">Bagaimana kami pindah studio web di Bali</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>