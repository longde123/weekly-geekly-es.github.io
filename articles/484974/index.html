<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÖüèø ü•É üöñ Wang Tiles para la simulaci√≥n de m√°quinas de Turing üëµüèΩ üßëüèª ‚¨ÜÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Las fichas de Wang (domin√≥) fueron inventadas por Hao Wang en 1961 por problemas matem√°ticos, pero fueron ampliamente utilizadas en juegos para crear ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wang Tiles para la simulaci√≥n de m√°quinas de Turing</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484974/">  Las fichas de Wang (domin√≥) fueron inventadas por Hao Wang en 1961 por problemas matem√°ticos, pero fueron ampliamente utilizadas en juegos para crear gr√°ficos de fichas.  Gracias a ellos, los resultados no parecen repetitivos, tanto en texturas 2D como en modelos 3D con mosaico. <br><br>  Parece que los mosaicos de Van tambi√©n son capaces de ejecutar m√°quinas de Turing y, por lo tanto, son completos de Turing, lo que significa que pueden ejecutar cualquier programa. <br><br>  Esta es una declaraci√≥n incre√≠ble e incomprensible, por lo que en esta publicaci√≥n explorar√© un poco este tema. <br><br><h2>  Brevemente sobre Van Tiles </h2><br>  Las fichas Van son fichas rectangulares en las que cada una de las caras solo puede corresponder a otras caras espec√≠ficas, pero para cualquier cara en particular hay varias fichas posibles que pueden corresponder a esa cara.  Al hacer coincidir caras, quiero decir que se conectan sin problemas sin crear artefactos visuales o signos de una costura entre las baldosas. <br><br>  Esta propiedad es √∫til para gr√°ficos, ya que le permite crear gr√°ficos de mosaico sin interrupciones, pero la configuraci√≥n de la ubicaci√≥n de los mosaicos puede ser completamente aleatoria, siempre que todas las caras sean compatibles entre s√≠.  El resultado son gr√°ficos en mosaico, que no son como los que se repiten, porque los patrones visuales se vuelven mucho menos perceptibles que los gr√°ficos en mosaico tradicionales. <br><br>  Puede encontrar ejemplos gr√°ficos, informaci√≥n m√°s detallada y enlaces a Shadertoy aqu√≠: <a href="https://blog.demofox.org/2014/08/13/wang-tiling/">Wang Tiling</a> . <br><br>  Aqu√≠ hay un ejemplo que cre√©.  Mis gr√°ficos son "programadores de arte", pero espero que la idea sea clara.  El dibujo se compone de 16 fichas, y para cada cara hay dos tipos diferentes de caras. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1dd/f35/586/1ddf35586684620140e0d28b0118dce1.png"></div><a name="habracut"></a><br><h2>  Brevemente sobre las m√°quinas de Turing </h2><br>  Las m√°quinas de Turing fueron inventadas en 1936 por Alan Turing como una computadora generalizada, para lo cual se demostr√≥ que puede ejecutar cualquier algoritmo. <br><br>  La m√°quina Turing se compone de varios componentes principales: cintas de memoria, cabezales de lectura / escritura y m√°quinas de estado. <br><br>  La cinta de memoria tiene una longitud infinita, es decir, tiene una capacidad de almacenamiento infinita, y al principio se inicializa solo con ceros. <br><br>  El cabezal de lectura / escritura comienza desde una cierta posici√≥n de la cinta y puede leer / escribir valores, y tambi√©n moverse hacia la izquierda y hacia la derecha a lo largo de la cinta. <br><br>  La m√°quina de estado controla el cabezal de lectura / escritura. <br><br>  La m√°quina de estado sabe en qu√© estado se encuentra y tiene reglas sobre qu√© hacer en cada estado cuando lee un valor de la cinta. <br><br>  Por ejemplo, en el estado A, si se lee 0 de la cinta, entonces la regla puede ser escribir 1 en la posici√≥n actual de la cinta, mover el cabezal de lectura / escritura a la derecha o ir al estado B. El estado B puede tener una l√≥gica completamente diferente y puede realizar la transici√≥n volver al estado A, o permanecer en el estado B, o pasar a un estado completamente diferente. <br><br>  Usando una l√≥gica tan simple de transici√≥n entre estados, se puede ejecutar cualquier algoritmo de computadora. <br><br>  La m√°quina de Turing tambi√©n puede tener un "Estado de detenci√≥n", lo que significa que el programa ha completado la ejecuci√≥n y la respuesta ha sido calculada. <br><br>  Buscando algunos programas.  Se puede ver f√°cilmente.  que con el tiempo, terminar√°n o estar√°n en un bucle infinito y nunca se detendr√°n.  Algunos programas est√°n ubicados entre ellos, son complejos y no es tan f√°cil determinar si alguna vez se detendr√°n.  Turing demostr√≥ que no existe una soluci√≥n general para determinar si la m√°quina de Turing se detendr√° (es un programa de computadora), y esto se denomina <a href="https://en.wikipedia.org/wiki/Halting_problem">problema de detenci√≥n</a> .  En general, la √∫nica forma de averiguar si un programa se detiene es esperar.  Es decir, de hecho, en el caso general, las respuestas a esta pregunta son ‚Äús√≠‚Äù o ‚Äútodav√≠a no‚Äù, sin embargo, en el caso de muchos programas espec√≠ficos, puede ver que despu√©s del lanzamiento terminar√°n con el tiempo. <br><br><h2>  Wang Tile Calculations </h2><br>  Resulta que los mosaicos de Wang pueden simular una m√°quina de Turing, es decir, son completos de Turing, lo que significa que pueden ejecutar cualquier algoritmo inform√°tico. <br><br>  Para darnos cuenta de esto, necesitamos una columna de mosaicos Van que indique el estado de la m√°quina Turing en un punto particular en el tiempo, comenzando en el tiempo 0 en la columna m√°s a la izquierda.  Pondremos mosaicos en la columna de la derecha con todas las reglas de las caras, y luego crearemos una columna a la derecha, y as√≠ sucesivamente, hasta que el programa termine (o haremos esto para siempre si no termina).  Si selecciona el conjunto correcto de mosaicos, entonces verificar el cumplimiento de las reglas de las caras en el proceso de organizaci√≥n de los mosaicos ser√° suficiente para completar la m√°quina de Turing. <br><br>  Veamos un ejemplo simple que tiene las siguientes reglas l√≥gicas de m√°quina de estado: <br><br><ol><li>  Cuando la m√°quina est√° en el estado A, en el caso de leer 0, escribimos 1, movemos la cabeza de lectura / escritura hacia abajo y pasamos al estado B. </li><li>  Cuando la m√°quina est√° en el estado A, en el caso de la lectura 1, el programa se detiene (cambia al estado final). </li><li>  Cuando la m√°quina est√° en el estado B, en el caso de leer 0, escribimos 1, movemos la cabeza de lectura-escritura hacia arriba y pasamos al estado A. </li><li>  Cuando la m√°quina est√° en estado B, en el caso de la lectura 1, el programa se detiene (pasa al estado final) </li></ol><br><h3>  Unidad de cinta </h3><br>  En primer lugar, necesitamos un almacenamiento permanente para la cinta.  Para hacer esto, necesitamos los siguientes dos mosaicos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d81/125/5dc/d811255dc542e1d46ff70e7dbeb94123.png"></div><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/adc/bd4/f89/adcbd4f89a80ff7b2dbed991803a2dba.png"></div><br>  Para probar su trabajo, podemos preparar un segmento de la cinta con algunos valores (crear una columna de mosaicos Van) y asegurarnos de que los √∫nicos mosaicos Van adecuados ubicados al lado de la columna inicial sean mosaicos que transfieran los valores 0 y 1 hacia adelante en el tiempo sin cambiar ellos. <br><br>  En el siguiente diagrama, inicializamos la cinta con el valor 0101 en la columna m√°s a la izquierda (tiempo 0).  Al tener solo mosaicos con caras compatibles, vemos que los valores en la memoria se almacenan para siempre.  ¬°Hemos implementado una unidad de memoria! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/773/2b8/cff/7732b8cffe9ffaf7b33320070373485d.png"></div><br>  Comenzaremos a demostrar nuestro ejemplo con la memoria inicializada a 0, y la figura anterior simplemente muestra la persistencia de la memoria. <br><br><h3>  M√°quina de estado del cabezal de lectura-escritura </h3><br>  El cabezal de lectura / escritura de una m√°quina Turing se presenta como parte de la informaci√≥n de la cara.  Por lo tanto, adem√°s de la cara que almacena 0 o 1, si el cabezal de lectura / escritura est√° en √©l, tambi√©n almacena el estado de la m√°quina de estados. <br><br>  En nuestro ejemplo, se utilizan dos estados (sin incluir el estado final): A y B. Si se lee 1, entonces, en cualquiera de los estados (A o B), el programa finaliza. <br><br>  Para manejar esto, necesitamos los siguientes mosaicos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d9/4a3/988/7d94a39887d1a95352c0205ff9f530eb.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4d/31b/a7a/a4d31ba7a6b49c895390e7caeda59479.png"></div><br>  Ahora que tenemos las reglas para la transici√≥n al estado final (reglas 2 y 4), necesitamos entender c√≥mo implementar las reglas que controlan el cambio de un estado a otro (reglas 1 y 3). <br><br><h3>  Mover el cabezal de lectura / escritura </h3><br>  La regla 1 establece que si estamos en el estado A y leemos 0, debemos escribir 1, mover la cabeza de lectura / escritura hacia abajo y pasar al estado B. <br><br>  Necesitamos este mosaico para leer 0 en el estado A, escribir 1 como salida, y ordenar al mosaico a continuaci√≥n que entre en el estado B. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a3/85d/f54/3a385df54323ebee4f460b42899498a9.png"></div><br>  El mosaico debajo del actual puede tener un valor de 0 o 1;  sin conocer un valor espec√≠fico, debemos guardarlo, pero aceptar el cabezal de lectura / escritura y estar en estado B. Para esto, necesitamos dos mosaicos: uno para 0 en la cinta en esta posici√≥n, el otro para 1 en la cinta. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/973/18c/7f8/97318c7f8e44bf70cb6537da8c2bbd9e.png"></div><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f8e/ab0/772/f8eab0772ad7827b994646a275b9f23b.png"></div><br>  La regla 3 establece que si estamos en el estado B y leemos 0, debemos escribir 1, mover la cabeza de lectura-escritura hacia arriba y pasar al estado A. <br><br>  Para hacer esto, necesitamos una construcci√≥n similar a la construcci√≥n para la regla 1, pero no nos movemos hacia abajo, sino hacia arriba.  Las siguientes tres fichas dar√°n el resultado deseado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c1a/d68/bd0/c1ad68bd057f7b7fa0bb228d158bb36b.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6f/e96/0da/a6fe960da1b315bda9d7461c7f2f4e6e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/a94/88e/8f3a9488eb5b556ed35942c58a02ddab.png"></div><br><h2>  Azulejos iniciales de columna </h2><br>  Percibiremos los l√≠mites del √°rea de simulaci√≥n como si tuvieran una cara "x". <br><br>  Esto significa que para crear la columna inicial (m√°quina de Turing en el tiempo 0) necesitamos dos mosaicos especiales.  Se necesita un mosaico para almacenar el valor 0 en la cinta, que inicializa la cinta, y otro mosaico para almacenar la posici√≥n del cabezal de lectura / escritura en el estado A, que es nuestro estado inicial. <br><br>  Estas dos fichas son: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edb/d34/969/edbd349698db9c4871c63fc44298fefe.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/199/6df/449/1996df4494d4b8ea4854ea1b3d2f9036.png"></div><br><h2>  Conjunto listo de azulejos </h2><br>  Aqu√≠ est√° el conjunto completo de 12 mosaicos que utilizaremos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/853/d56/8c1/853d568c1a623fe7c1fc123dff3dd671.png"></div><br><h2>  Simulaci√≥n completa </h2><br>  Aqu√≠ est√° el dise√±o original de nuestra m√°quina Turing en el momento 0. Tenga en cuenta que este es uno de los posibles estados iniciales, pero este es el estado que hemos elegido.  No dejamos la oportunidad de elegir d√≥nde comienza el cabezal de lectura / escritura, y su presencia tambi√©n.  Si seguimos solo las reglas de las caras, entonces podemos obtener 4 o 0 cabezas de lectura-escritura, o cualquier n√∫mero entre ellas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33e/5b8/e7a/33e5b8e7a21b1c52a54b28324f50665d.png"></div><br>  A partir de aqu√≠, para crear la segunda columna, comenzamos desde la parte superior y bajamos, eligiendo un mosaico que coincida con las restricciones de la cara que toca.  En este primer paso, la cabeza lee 0, escribe 1, se mueve hacia abajo y pasa al estado B. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c6/551/9b1/4c65519b125288868d742b3f362e7380.png"></div><br>  Aqu√≠ est√° el segundo paso, donde la cabeza lee 0, escribe 1, se mueve hacia arriba y pasa al estado A. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e2/5bd/1e0/3e25bd1e0afad891f739c61a500dbf4c.png"></div><br>  Aqu√≠ est√° el √∫ltimo paso en el que la cabeza lee 1 y entra en el estado final, lo que indica que el programa est√° completo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb8/25d/6bb/bb825d6bb75417f9863376d7f23524df.png"></div><br>  El programa finaliz√≥ y nos dio un valor de salida de 0110, o 6. Estos valores de salida no son particularmente significativos, pero otros programas pueden producir resultados significativos.  Por ejemplo, podemos obligar a una m√°quina de Turing a sumar dos n√∫meros, y la salida ser√° la suma de estos dos n√∫meros. <br><br><h2>  Detalle importante </h2><br>  Aqu√≠ debemos mencionar un detalle importante que no consideramos anteriormente, y que no se menciona en la mayor√≠a de las explicaciones de las m√°quinas Turing en las fichas Van. <br><br>  Al colocar el segundo mosaico para el tiempo 2, la √∫nica restricci√≥n en las caras es que el mosaico debe tener x en la parte superior y 1 en la izquierda.  De hecho, debido a esto, la situaci√≥n se vuelve ambigua, porque no est√° claro cu√°l de los dos mosaicos que se muestran a continuaci√≥n deben seleccionarse. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/adc/bd4/f89/adcbd4f89a80ff7b2dbed991803a2dba.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/a94/88e/8f3a9488eb5b556ed35942c58a02ddab.png"></div><br>  Entonces, ¬øc√≥mo elegimos el correcto? <br><br>  La respuesta es que simplemente asumimos y elegimos uno de ellos.  Si en este caso se selecciona el mosaico incorrecto, cuando pasemos al siguiente mosaico, buscaremos un mosaico con x en la parte superior y B0 a la izquierda.  Tal mosaico no existe, por lo que no podemos colocar el mosaico.  Cuando esto sucede, debemos volver al √∫ltimo mosaico y probar una de las otras opciones. <br><br>  Esto es, desafortunadamente, cuando se simulan m√°quinas de Turing usando fichas de Wang, hay literalmente un proceso de prueba y error, pero al menos es bastante manejable.  Realmente complica un poco los c√°lculos en el sombreador de p√≠xeles (o en otros dispositivos con alto paralelismo), pero los costos no son mucho mayores. <br><br><h2>  Conclusi√≥n y enlaces </h2><br>  Algunos de los enlaces a continuaci√≥n tratan sobre los mosaicos Wang y las m√°quinas de Turing, pero las discusiones no parecen adherirse estrictamente a las m√°quinas de Turing.  Por ejemplo, puede notar que en algunos ejemplos, los datos pueden regresar "en el tiempo": cuando el programa finaliza, la respuesta est√° en cinta en el momento 0 de la m√°quina Turing, a pesar de que estos datos no estaban all√≠ en el momento 0. Esto muestra que los mosaicos de Wang pueden hacer los c√°lculos solos, no solo simulando m√°quinas de Turing, sino que no s√© exactamente c√≥mo se llamar√° esta t√©cnica. <br><br>  Adem√°s, si est√° interesado en saber qu√© es √∫til en la computaci√≥n usando los mosaicos Wang, entonces personalmente no podr√© imaginar casos de su aplicaci√≥n pr√°ctica.  Sin embargo, los cient√≠ficos parecen haber descubierto que el ADN puede actuar de la misma manera que las fichas de Van en el sentido de que las conexiones se hacen solo entre caras compatibles.  Gracias a esto, los c√°lculos basados ‚Äã‚Äãen el ADN ahora se est√°n investigando en funci√≥n del proceso de computaci√≥n utilizando los mosaicos de Wang.  ¬°Un tema bastante interesante! <br><br>  Aqu√≠ est√° la implementaci√≥n del c√°lculo de n√∫meros primos usando mosaicos Wang en Shadertoy en el sombreador de p√≠xeles WebGL: <br><br>  <a href="https://www.shadertoy.com/view/4sV3zK">Shadertoy: Wang Tiles: PrimeGenerator</a> <br><br>  Aqu√≠ hay algunos videos m√°s geniales sobre los autos de Turing y el problema de detenerse: <br><br>  <a href="https://www.youtube.com/watch%3Fv%3DdNRDvLACg5Q">M√°quinas de Turing explicadas - Computerphile</a> <br><br>  <a href="https://www.youtube.com/watch%3Fv%3DmacM_MtS_w4">Turing y el problema de la detenci√≥n - Computerphile</a> <br><br>  Y aqu√≠ hay algunos enlaces m√°s: <br><br>  <a href="https://moyix.wordpress.com/2012/04/06/computing-with-tiles/">Computaci√≥n con azulejos</a> <br><br>  <a href="https://en.wikipedia.org/wiki/Wang_tile">Wikipedia: Van tiles</a> <br><br>  <a href="http://grahamshawcross.com/2012/10/12/wang-tiles-and-turing-machines/">Wang Tiles y M√°quinas Turing</a> <br><br>  <a href="https://because0fbeauty.wordpress.com/2014/02/28/wang-tiles-1/">Wang Tiles - 1</a> <br><br>  Aqu√≠ hay algunos art√≠culos cient√≠ficos: <br><br>  <a href="http://www.math.oregonstate.edu/~math_reu/proceedings/REU_Proceedings/Proceedings1989/2_Michie89.pdf">Computaci√≥n con azulejos</a> <br><br>  <a href="http://link.springer.com/chapter/10.1007%252F978-0-387-09680-3_13">Computabilidad de las inclinaciones</a> </div></div><p>Source: <a href="https://habr.com/ru/post/484974/">https://habr.com/ru/post/484974/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../484954/index.html">Gu√≠a visual de soluci√≥n de problemas para Kubernetes</a></li>
<li><a href="../484964/index.html">Configurar el equilibrio de carga en InfoWatch Traffic Monitor</a></li>
<li><a href="../484966/index.html">Plantilla lista para usar con Spring</a></li>
<li><a href="../484968/index.html">WPF DataGrid. Lucha por la plantilla</a></li>
<li><a href="../484972/index.html">Wine 5.0 lanzado</a></li>
<li><a href="../484978/index.html">PubSub es casi gratis: NOTIFICAR caracter√≠sticas en PostgreSQL</a></li>
<li><a href="../484982/index.html">¬øEs f√°cil organizar su negocio para un especialista en TI?</a></li>
<li><a href="../484984/index.html">Desarrollador de juegos de Unity. Nuevo curso de OTUS</a></li>
<li><a href="../484990/index.html">Luxoft TechTalks: podcasts de video de gur√∫s mundiales de TI y m√°s</a></li>
<li><a href="../484992/index.html">M√°s bonito en proyectos grandes: dedica 20 minutos a la configuraci√≥n, olv√≠date del formateo para siempre</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>