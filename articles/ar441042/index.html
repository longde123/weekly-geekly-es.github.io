<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💂 ✉️ 🧠 إنشاء أيقونات متعددة المنصات متعددة العلامات التجارية باستخدام رسم وسكربت Node.js - الجزء رقم 2 ✝️ 🎗️ 🏳️‍🌈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="هذا هو الجزء الثاني من منشور حول إنشاء خط أنابيب يمكن أن يأخذ ملف Sketch وتصدير جميع الرموز المدرجة في الملف ، بتنسيقات مختلفة ، لأنظمة تشغيل مختلفة ،...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>إنشاء أيقونات متعددة المنصات متعددة العلامات التجارية باستخدام رسم وسكربت Node.js - الجزء رقم 2</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/441042/" style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/na/kj/v5/nakjv5srowi99bsjteoqabwtoz8.png"><br><br>  هذا هو الجزء الثاني من منشور حول إنشاء خط أنابيب يمكن أن يأخذ ملف Sketch وتصدير جميع الرموز المدرجة في الملف ، بتنسيقات مختلفة ، لأنظمة تشغيل مختلفة ، مع إمكانية اختبار AB لكل رمز. <br><br>  يمكنك قراءة الجزء الأول من المنشور <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">هنا</a> . <br><br><img src="https://habrastorage.org/webt/s6/lt/2d/s6lt2dttycpvlqbolmyeyacaeas.png"><br><br>  كانت ملفات Sketch ، مع جميع الرموز التي تم جمعها وتصميمها وتسميتها بشكل صحيح ، جاهزة.  الآن حان الوقت لبدء كتابة الكود. <br><br>  يكفي القول ، إن العملية كانت إلى حد كبير تجربة وخطأ: بعد مجموعة التعليمات البرمجية الأولية المهمة ، التي طورها فريقي الرائد <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">نيخيل فيرما</a> (الذي وضع أسس البرنامج النصي) ، مررت بعملية تدريجية تطلبت على الأقل ثلاث مراحل من إعادة البناء. وعدد لا بأس به من التنقيحات.  لهذا السبب ، لن أخوض في الكثير من التفاصيل حول كيفية تطوير البرنامج النصي ، لكنني أركز على كيفية عمل البرنامج النصي اليوم ، بشكله النهائي. <br><a name="habracut"></a><br><h2 style=";text-align:right;direction:rtl">  بناء السيناريو </h2><br>  النص البرمجي للبناء - المكتوب في Node.js - واضح نسبيًا في التدفق: بمجرد استيراد التبعيات ، أعلن قائمة ملفات Sketch المراد معالجتها (كقائمة من العلامات التجارية ، ولكل علامة تجارية قائمة ملفات لهذه العلامة التجارية) و تأكد من تثبيت Sketch على العميل ، ويقوم البرنامج النصي بحفظ مجموعة من العلامات التجارية ، ولكل واحدة من هذه الخطوات يتم تنفيذ هذه الخطوات بالتسلسل: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  احصل على الرموز المميزة للعلامة التجارية (نحتاج إلى قيم الألوان) </li><li style=";text-align:right;direction:rtl">  استنساخ ملفات Sketch المرتبطة بالعلامة التجارية ، وقم بفك ضغطها لفضح ملفات JSON الداخلية ، ومعالجة بعض القيم الداخلية لملفات JSON هذه (المزيد حول هذا لاحقًا) </li><li style=";text-align:right;direction:rtl">  اقرأ البيانات الوصفية ذات الصلة من ملفات Sketch JSON ( <i>document.json</i> و <i>meta.json</i> <i>والصفحات / pageUniqueID.json</i> ) ؛  نحتاج على وجه الخصوص إلى قائمة الأنماط المشتركة وقائمة الأصول / الرموز الموجودة في الملفات </li><li style=";text-align:right;direction:rtl">  بعد عدد قليل من عمليات المعالجة الإضافية لملفات Sketch JSON ، قم بضغطها مرة أخرى ، وباستخدام ملفات Sketch (المستنسخة والمحدثة) ، قم بتصدير وإنشاء ملفات الإخراج النهائية للمنصات الثلاثة (iOS و Android و Mobile Web) </li></ol><br>  يمكنك عرض الأجزاء ذات الصلة من البرنامج النصي للبناء الرئيسي هنا: <br><br><pre style=";text-align:right;direction:rtl"><code class="plaintext hljs">// ... modules imports here const SKETCH_FILES = { badoo: ['icons_common'], blendr: ['icons_common', 'icons_blendr'], fiesta: ['icons_common', 'icons_fiesta'], hotornot: ['icons_common', 'icons_hotornot'], }; const SKETCH_FOLDER_PATH = path.resolve(__dirname, '../src/'); const SKETCH_TEMP_PATH = path.resolve(SKETCH_FOLDER_PATH, 'tmp'); const DESTINATION_PATH = path.resolve(__dirname, '../dist'); console.log('Build started...'); if (sketchtool.check()) { console.log(`Processing Sketch file via ${sketchtool.version()}`); build(); } else { console.info('You need Sketch installed to run this script'); process.exit(1); } // ---------------------------------------- function build() { // be sure to start with a blank slate del.sync([SKETCH_TEMP_PATH, DESTINATION_PATH]); // process all the brands declared in the list of Sketch files Object.keys(SKETCH_FILES).forEach(async (brand) =&gt; { // get the design tokens for the brand const brandTokens = getDesignTokens(brand); // prepare the Sketch files (unzipped) and get a list of them const sketchUnzipFolders = await prepareSketchFiles({ brand, sketchFileNames: SKETCH_FILES[brand], sketchFolder: SKETCH_FOLDER_PATH, sketchTempFolder: SKETCH_TEMP_PATH }); // get the Sketch metadata const sketchMetadata = getSketchMetadata(sketchUnzipFolders); const sketchDataSharedStyles = sketchMetadata.sharedStyles; const sketchDataAssets = sketchMetadata.assetsMetadata; generateAssetsPDF({ platform: 'ios', brand, brandTokens, sketchDataSharedStyles, sketchDataAssets }); generateAssetsSVGDynamicMobileWeb({ platform: 'mw', brand, brandTokens, sketchDataSharedStyles, sketchDataAssets }); generateAssetsVectorDrawableDynamicAndroid({ platform: 'android', brand, brandTokens, sketchDataSharedStyles, sketchDataAssets }); }); }</code> </pre> <br>  في الواقع ، رمز خط الأنابيب بالكامل أكثر تعقيدًا من هذا ، والتعقيد يكمن في <b>وظائف</b> <b>preparSketchFiles</b> و <b>getSketchMetadata</b> و <b>createAssets</b> <b>[format] [platform]</b> .  سأحاول شرحهم بمزيد من التفاصيل أدناه. <br><br><h2 style=";text-align:right;direction:rtl">  تحضير ملفات Sketch </h2><br>  الخطوة الأولى في عملية الإنشاء هي إعداد ملفات Sketch ، بحيث يمكن استخدامها لاحقًا لتصدير الأصول للأنظمة الأساسية المختلفة. <br><br>  الملفات المرتبطة بالعلامة التجارية - بالنسبة إلى Blendr ، على سبيل المثال ، <i>icons_common.sketch</i> و <i>icons_blendr.sketch</i> - يتم استنساخها في البداية في مجلد مؤقت (بشكل أكثر دقة ، في مجلد فرعي يحمل اسم العلامة التجارية التي تتم معالجتها) ثم فك ضغطها. <br><br>  ثم تتم معالجة ملفات JSON الداخلية ، إلى بادئة تضاف إلى الأصول التي ستخضع لاختبار AB ، بحيث يتم حفظها عند تصديرها في مجلد فرعي باسم محدد مسبقًا (الاسم الفريد للتجربة).  لفهم الأصول التي يتم اختبارها ، نحن ببساطة نتحقق مما إذا كان اسم الصفحة المخزنة في Sketch مسبوقًا بـ <i>"XP_"</i> . <br><br><img src="https://habrastorage.org/webt/k7/qo/df/k7qodfiyytkacnk1uknx_6gxhzw.png"><br>  <i>مقارنة بين أسماء الطبقات ، داخل ملفات Sketch ، قبل التحديث وبعده.</i> <br><br>  في المثال أعلاه ، عندما يتم تصدير الأصول ، سيتم حفظ الأصول في المجلد الفرعي <i>"this__is_an_experiment"</i> ، مع اسم الملف <i>"</i> اسم <i>الرمز [variant-name] .ext"</i> . <br><br><h2 style=";text-align:right;direction:rtl">  قراءة البيانات الوصفية للرسم </h2><br>  تتمثل الخطوة المهمة الثانية في العملية في إخراج جميع بيانات التعريف ذات الصلة من ملفات Sketch ، خاصةً من ملفات JSON الداخلية.  كما هو موضح أعلاه ، هذه الملفات هي الملفين الرئيسيين ( <i>document.json</i> و <i>meta.json</i> ) وملفات <i>الصفحات</i> ( <i>pages / pageUniqueId.json</i> ). <br><br>  يتم استخدام <i>ملف document.json</i> للحصول على قائمة الأنماط المشتركة ، والتي تظهر أسفل خاصية كائن <i>layerStyles</i> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">{ "_class": "document", "do_objectID": "45D2DA82-B3F4-49D1-A886-9530678D71DC", "colorSpace": 1, ... "layerStyles": { "_class": "sharedStyleContainer", "objects": [ { "_class": "sharedStyle", "do_objectID": "9BC39AAD-CDE6-4698-8EA5-689C3C942DB4", "name": "features/feature-like", "value": { "_class": "style", "fills": [ { "_class": "fill", "isEnabled": true, "color": { "_class": "color", "alpha": 1, "blue": 0.10588235408067703, "green": 0.4000000059604645, "red": 1 }, "fillType": 0, "noiseIndex": 0, "noiseIntensity": 0, "patternFillType": 1, "patternTileScale": 1 } ], "blur": {...}, "startMarkerType": 0, "endMarkerType": 0, "miterLimit": 10, "windingRule": 1 } }, ...</code> </pre> <br>  لكل نمط ، نقوم بتخزين بعض المعلومات الأساسية في كائن قيمة المفتاح.  سيتم استخدام هذا لاحقًا كلما احتجنا لاسترداد اسم النمط استنادًا إلى <i>معرفه</i> الفريد (في Sketch ، خاصية <i>do_objectID</i> ): <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">const parsedSharedStyles = {}; parsedDocument.layerStyles.objects.forEach((object) =&gt; { parsedSharedStyles[object.do_objectID] = { name: object.name, isFill: _.get(object, 'value.fills[0].color') !== undefined, isBorder: _.get(object, 'value.borders[0].color') !== undefined, }; });</code> </pre> <br><br>  في هذه المرحلة ، ننتقل إلى ملف <i>meta.json</i> للحصول على قائمة الصفحات ، ولا سيما نحتاج إلى <i>معرّفها</i> <i>الفريد</i> <i>واسمها</i> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">{ "commit": "623a23f2c4848acdbb1a38c2689e571eb73eb823", "pagesAndArtboards": { "EE6BE8D9-9FAD-4976-B0D8-AB33D2B5DBB7": { "name": "Icons", "artboards": { "3275987C-CE1B-4369-B789-06366EDA4C98": { "name": "badge-feature-like" }, "C6992142-8439-45E7-A346-FC35FA01440F": { "name": "badge-feature-crush" }, ... "7F58A1C4-D624-40E3-A8C6-6AF15FD0C32D": { "name": "tabbar-livestream" } ... } }, "ACF82F4E-4B92-4BE1-A31C-DDEB2E54D761": { "name": "XP_this__is_an_experiment", "artboards": { "31A812E8-D960-499F-A10F-C2006DDAEB65": { "name": "this__is_an_experiment/tabbar-livestream[variant1]" }, "20F03053-ED77-486B-9770-32E6BA73A0B8": { "name": "this__is_an_experiment/tabbar-livestream[variant2]" }, "801E65A4-3CC6-411B-B097-B1DBD33EC6CC": { "name": "this__is_an_experiment/tabbar-livestream[control]" } } },</code> </pre> <br>  ثم ، لكل صفحة نقرأ ملف JSON المقابل ضمن مجلد <i>الصفحات</i> (كما سبق ذكره ، اسم الملف هو <i>[pageUniqueId] .json</i> ) ، ونحن نذهب إلى الأصول الموجودة في تلك الصفحة (تظهر كطبقات).  وبهذه الطريقة ، لكل رمز نحصل عليه ، عرضه / ارتفاعه ، بيانات تعريف Sketch لأيقونة الطبقة ، وإذا كان موجودًا على صفحة التجربة ، اسم اختبار AB المعني ، واسم المتغير لهذا الرمز. <br><br>  <i>إشعار</i> : الكائن "page.json" معقد للغاية ، لذلك لن أخوض فيه هنا.  إذا كنت فضوليًا وترغب في رؤية شكله ، أقترح عليك إنشاء ملف رسم جديد وفارغ وإضافة محتوى فيه وحفظه ؛  ثم أعد تسمية امتداده في zip ، وقم بفك ضغطه والنظر في أحد الملفات التي تظهر ضمن مجلد "الصفحات". <br><br>  أثناء معالجة اللوحات الفنية ، نقوم أيضًا بإنشاء قائمة بالتجارب (مع أصولها المقابلة) التي سيتم استخدامها لاحقًا لتحديد خيارات الأيقونات المستخدمة ولأي تجربة ، يتم ربط اسم خيارات الأيقونة بالكائن "icon icon". <br><br>  لكل ملف Sketch قيد المعالجة مرتبط بالعلامة التجارية ، ننتج كائن بيانات <i>تعريفية للممتلكات</i> يشبه هذا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">{ "navigation-bar-edit": { "do_objectID": "86321895-37CE-4B3B-9AA6-6838BEDB0977", ...sketch_artboard_properties, "name": "navigation-bar-edit", "assetname": "navigation-bar-edit", "source": "icons_common", "width": 48, "height": 48 "layers": [ { "do_objectID": "A15FA03C-DEA6-4732-9F85-CA0412A57DF4", "name": "Path", ...sketch_layer_properties, "sharedStyleID": "6A3C0FEE-C8A3-4629-AC48-4FC6005796F5", "style": { ... "fills": [ { "_class": "fill", "isEnabled": true, "color": { "_class": "color", "alpha": 1, "blue": 0.8784313725490196, "green": 0.8784313725490196, "red": 0.8784313725490196 }, } ], "miterLimit": 10, "startMarkerType": 0, "windingRule": 1 }, }, ], ... }, "experiment-name/navigation-bar-edit[variant]": { "do_objectID": "00C0A829-D8ED-4E62-8346-E7EFBC04A7C7", ...sketch_artboard_properties, "name": "experiment-name/navigation-bar-edit[variant]", "assetname": "navigation-bar-edit", "source": "icons_common", "width": 48, "height": 48 ...</code> </pre> <br>  كما ترون ، يمكن أن تحتوي "الأيقونة" نفسها (في هذه الحالة <i>، شريط التنقل</i> ) على "أصول" متعددة مرتبطة بها ، من حيث التجارب.  ولكن يمكن أن يظهر الرمز نفسه بنفس الاسم في ملف رسم ثانٍ مرتبط بالعلامة التجارية ، وهذا مفيد للغاية: إنها الحيلة التي استخدمناها ، لتجميع مجموعة مشتركة من الرموز ثم تحديد أشكال مختلفة من الرموز المختلفة بناءً على العلامة التجارية. <br><br>  لهذا السبب أعلنا ملفات Sketch المرتبطة بكل علامة تجارية معينة كصفيف: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">const SKETCH_FILES = { badoo: ['icons_common'], blendr: ['icons_common', 'icons_blendr'], fiesta: ['icons_common', 'icons_fiesta'], hotornot: ['icons_common', 'icons_hotornot'], };</code> </pre> <br>  لأنه في هذه الحالة يهم الأمر.  وفي الواقع ، في الدالة <i>getSketchMetadata</i> ، التي يطلق عليها البرنامج النصي للبناء ، لا <i>نرجع</i> كائنات <i>الأصول Metadata</i> (واحد لكل ملف) كقائمة ، بل نؤدي إلى دمج عميق لكل كائن ، واحد في الآخر ، ثم إرجاع كائن <i>الأصولMetadata</i> المدمج واحد. <br><br>  هذا ليس أكثر من الدمج "المنطقي" لملفات Sketch وأصولها في ملف واحد.  لكن المنطق ليس في الواقع بسيطًا كما يبدو.  في ما يلي المخطط الذي كان يتعين علينا إنشاؤه لمعرفة ما يحدث عندما تكون هناك أيقونات تحمل نفس الاسم (ربما تحت اختبار AB) في ملفات مختلفة مرتبطة بنفس العلامة التجارية: <br><br><img src="https://habrastorage.org/webt/yg/ug/-6/ygug-6xnds3cvysntithaenmbfw.png"><br>  <i>المخطط المنطقي لكيفية عمل "تجاوز" نفس الأيقونة ، بين مجموعة مشتركة / مشتركة من الرموز والرموز المصممة خصيصًا للعلامات البيضاء (مع الأخذ في الاعتبار أيضًا حالة اختبار AB)</i> <br><br><h2 style=";text-align:right;direction:rtl">  إنشاء الملفات النهائية بتنسيقات مختلفة للأنظمة الأساسية المختلفة </h2><br>  الخطوة الأخيرة من العملية هي إنشاء ملفات الرموز فعليًا بتنسيقات مختلفة للأنظمة الأساسية المختلفة (PDF لـ iOS و SVG / JSX للويب و VectorDrawable لنظام Android). <br><br>  كما ترون من خلال عدد المعلمات التي تم تمريرها إلى الوظائف التي <i>تنشئ مجموعات [تنسيق] [النظام الأساسي] ، فإن</i> هذا هو الجزء الأكثر تعقيدًا من خط الأنابيب.  هنا <b>تبدأ العملية في الانقسام</b> والاختلاف بين الأنظمة الأساسية المختلفة.  انظر أدناه التدفق المنطقي الكامل للبرنامج النصي ، وكيف <b>ينقسم</b> الجزء المتعلق بتوليد الأصول <b>في ثلاثة تدفقات متشابهة ولكن غير متطابقة:</b> <br><br> <a href=""><img src="https://habrastorage.org/webt/jv/83/xy/jv83xyzcpvzmn4snh0xakkrfu8k.png"></a> <br><br>  من أجل توليد الأصول النهائية بالألوان الصحيحة المرتبطة بالعلامة التجارية التي تتم معالجتها ، نحتاج إلى القيام بمجموعة أخرى من المعالجات على ملفات Sketch JSON: نحن نكرر التكرار على كل طبقة لها نمط مشترك مطبق ، واستبدال قيم اللون مع الألوان من الرموز المميزة للعلامة التجارية. <br><br>  بالنسبة إلى نظام أندرويد ، هناك حاجة إلى معالجة إضافية (المزيد حول هذا لاحقًا): نقوم بتغيير خاصية تعبئة قاعدة كل طبقة من <i>الغريب</i> إلى <i>غير الصفري</i> (يتم التحكم في هذا بواسطة خاصية "windingRule" في كائن JSON ، حيث " 1 تعني كلمة "زوجي فردي" و "0" تعني "غير صفري"). <br><br>  بعد الانتهاء من هذه العمليات ، نقوم بضغط ملفات Sketch JSON مرة أخرى في ملف Sketch قياسي ، بحيث يمكن معالجتها لتصدير الأصول مع الخصائص المحدثة (الملفات المستنسخة والمحدثة هي ملفات Sketch عادية للغاية: يمكن فتحها في Sketch ، عرض ، تحرير ، حفظ ، الخ). <br><br>  في هذه المرحلة ، يمكننا استخدام sketchtool ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">في غلاف عقدة</a> ) لتصدير جميع الأصول تلقائيًا بتنسيقات محددة لمنصات معينة.  لكل ملف مرتبط بعلامة تجارية (بشكل صحيح ، نسخته المستنسخة والمحدثة) نقوم بتشغيل هذا الأمر: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">sketchtool.run(`export slices ${cloneSketchFile} --formats=svg &lt;i&gt;--scales=1 &lt;/i&gt;--output=${destinationFolder} --overwriting`);</code> </pre> <br>  كما تعتقد ، يقوم هذا الأمر بتصدير الأصول بتنسيق معين ، مع تطبيق تحجيم اختياري (في الوقت الحالي ، نحافظ دائمًا على المقياس الأصلي) ، في مجلد وجهة.  خيار - <i>الكتابة</i> هو المفتاح هنا: بنفس الطريقة التي نقوم بها "دمج عميق" للكائنات الأصول البيانات الوصفية (التي ترقى إلى "دمج منطقي" لملفات Sketch) ، عندما نقوم بتصدير نقوم به من ملفات متعددة إلى نفس المجلد (فريد لكل ماركة / منصة).  هذا يعني أنه إذا كان موجودًا - تم تحديده بواسطة اسم الطبقة - موجودًا بالفعل في ملف رسم سابق ، فستتم الكتابة فوقه بواسطة التصدير التالي.  التي ، مرة أخرى ، ليست أكثر من عملية "دمج". <br><br>  في هذه الحالة ، على الرغم من ذلك ، قد يكون لدينا بعض الأصول "الأشباح".  يحدث هذا عندما يتم اختبار رمز AB في ملف ، ولكن يتم الكتابة عليه في ملف لاحق.  في مثل هذه الحالات ، يتم تصدير الملفات المتغيرة إلى مجلد الوجهة ، والمشار إليها في كائن الأصول البيانات <i>الوصفية</i> كأصل (مع مفتاحه وخصائصه) ، ولكن لا ترتبط بأي أصل "أساسي" (بسبب الدمج العميق لكائنات <i>أصول البيانات</i> ).  ستتم إزالة هذه الملفات في خطوة لاحقة ، قبل إتمام العملية. <br><br><hr><br>  كما ذكر أعلاه ، نحن بحاجة إلى صيغ نهائية مختلفة لأنظمة مختلفة.  بالنسبة لنظام التشغيل iOS ، نريد ملفات PDF ، ويمكننا تصديرها مباشرة باستخدام أمر <i>sketchtool</i> .  بينما ، بالنسبة إلى Mobile Web ، نريد ملفات JSX ، وبالنسبة إلى Android ، نريد ملفات VectorDrawable ؛  لهذا السبب ، نقوم بتصدير الأصول بتنسيق SVG إلى مجلد وسيط ، ثم نعرضها لمزيد من المعالجة. <br><br><h2 style=";text-align:right;direction:rtl">  ملفات PDF لنظام التشغيل iOS </h2><br>  الغريب أن PDF هو (فقط؟) التنسيق المدعوم من Xcode و OS / iOS لاستيراد أصول المتجهات وعرضها (فيما يلي <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">شرح</a> موجز للأسباب التقنية وراء هذا الاختيار من قِبل Apple). <br><br>  نظرًا لأننا نستطيع التصدير مباشرة في PDF عبر Sketchtool ، ليست هناك حاجة لخطوات إضافية لهذا النظام الأساسي: ببساطة نقوم بحفظ الملفات مباشرة في مجلد الوجهة ، وهذا كل شيء. <br><br><h2 style=";text-align:right;direction:rtl">  React / JSX الملفات للويب </h2><br>  في حالة الويب ، نستخدم مكتبة Node تسمى <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">svgr</a> لتحويل ملفات SVG العادية إلى مكونات <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">React</a> .  لكننا نريد أن نفعل شيئًا أكثر قوة: نريد أن "نرسم الأيقونة ديناميكيًا" في وقت التشغيل ، مع الألوان القادمة من الرموز المميزة للتصميم.  لهذا السبب ، قبل التحويل مباشرة ، استبدلنا في SVG قيم <i>تعبئة</i> المسارات التي كان لها في الأصل نمط مشترك مطبق ، مع قيمة الرمز المميز المقابل المرتبطة بهذا النمط. <br><br>  لذلك ، إذا كان هذا هو ملف <i>badge-feature-like.svg الذي</i> تم تصديره من Sketch: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;svg width="128px" height="128px" viewBox="0 0 128 128" version="1.1" xmlns="&lt;a href="http://www.w3.org/2000/svg"&gt;http://www.w3.org/2000/svg&lt;/a&gt;" xmlns:xlink="&lt;a href="http://www.w3.org/1999/xlink"&gt;http://www.w3.org/1999/xlink&lt;/a&gt;"&gt; &lt;!-- Generator: sketchtool 52.2 (67145) - &lt;a href="http://www.bohemiancoding.com/sketch"&gt;http://www.bohemiancoding.com/sketch&lt;/a&gt; --&gt; &lt;title&gt;badge-feature-like&lt;/title&gt; &lt;desc&gt;Created with sketchtool.&lt;/desc&gt; &lt;g id="Icons" fill="none" fill-rule="evenodd"&gt; &lt;g id="badge-feature-like"&gt; &lt;circle id="circle" fill="#E71032" cx="64" cy="64" r="64"&gt; &lt;path id="Shape" fill="#FFFFFF" d="M80.4061668,..."&gt;&lt;/path&gt; &lt;/g&gt; &lt;/g&gt; &lt;/svg&gt;</code> </pre> <br>  <i>سيبدو</i> أصل / رمز <i>الشارة</i> النهائي كما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">/* This file is generated automatically - DO NOT EDIT */ /* eslint-disable max-lines,max-len,camelcase */ const React = require('react'); module.exports = function badge_feature_like({ tokens }) { return ( &lt;svg data-origin="pipeline" viewBox="0 0 128 128"&gt; &lt;g fill="none" fillRule="evenodd"&gt; &lt;circle fill={tokens.TOKEN_COLOR_FEATURE_LIKED_YOU} cx={64} cy={64} r={64} /&gt; &lt;path fill="#FFF" d="M80.4061668,..." /&gt; &lt;/g&gt; &lt;/svg&gt; ); };</code> </pre> <br>  كما ترون ، لقد استبدلنا القيمة الثابتة للون <i>تعبئة</i> الدائرة ، بقيمة ديناميكية ، تأخذ قيمتها من الرموز المميزة للتصميم (سيتم توفيرها لمكون React <i>&lt;Icon /&gt;</i> عبر Context API ، ولكن هذه قصة أخرى). <br><br>  أصبح هذا الاستبدال ممكناً من خلال بيانات تعريف Sketch للأصل المخزن في كائن <i>Metadata للأصول</i> : تكرار الحلقات بشكل متكرر من خلال طبقات الأصل ، من الممكن إنشاء محدد DOM (في الحالة أعلاه ، سيكون <i>#Icons # badge-feature- مثل #circle</i> ) <i>واستخدمها</i> للعثور على العقدة في شجرة SVG ، واستبدال قيمة سمة <i>الملء</i> الخاصة بها (لهذه العملية ، نستخدم مكتبة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">cheerio</a> ). <br><br><h2 style=";text-align:right;direction:rtl">  VectorDrawable الملفات لالروبوت </h2><br>  يدعم Android الرسومات المتجهة باستخدام تنسيق المتجه المخصص الخاص به ، والذي يسمى <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">VectorDrawable</a> .  عادة ما يتم التحويل من SVG إلى VectorDrawable <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مباشرة داخل Android Studio</a> بواسطة المطورين.  لكننا أردنا هنا أتمتة العملية برمتها ، لذلك كنا بحاجة لإيجاد طريقة لتحويلها عبر الكود. <br><br>  بعد النظر إلى المكتبات والأدوات المختلفة ، قررنا استخدام مكتبة تسمى <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">svg2vectordrawable</a> .  ليس فقط يتم صيانته بنشاط (على الأقل ، أفضل من الآخرين الذين وجدناهم) ولكنه أيضًا أكثر اكتمالًا. <br><br>  الحقيقة هي أن VectorDrawable لا يتساوى مع ميزة SVG: بعض الميزات المتقدمة لـ SVG (مثل التدرجات الشعاعية ، الأقنعة المعقدة ، إلخ.) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">غير مدعومة</a> ، وبعضها قد اكتسب دعمًا مؤخرًا فقط (باستخدام Android API 24 و أعلى).  الجانب السلبي لهذا هو أنه في نظام Android قبل 24 عامًا ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">فإن قاعدة التعبئة "الفردية" غير مدعومة</a> .  لكن في Badoo نحتاج إلى دعم Android 5 والإصدارات الأحدث  لهذا السبب ، كما هو موضح أعلاه ، لنظام Android نحتاج إلى تحويل كل مسار في ملفات Sketch إلى تعبئة "غير صفرية". <br><br>  يحتمل أن يقوم المصممون بهذا يدويًا: <br><br><img src="https://habrastorage.org/webt/oj/ec/bp/ojecbp2no3lxsas5uwxcqmobcji.png"><br><br>  ولكن قد يتم التغاضي عن هذا بسهولة ، وبالتالي تكون عرضة للخطأ البشري. <br><br>  لهذا السبب ، أضفنا خطوة إضافية في عمليتنا لنظام Android ، حيث نقوم تلقائيًا بتحويل جميع المسارات إلى <i>غير صفري</i> في Sketch JSON.  هذا هو أنه عندما نقوم بتصدير الأيقونات إلى SVG ، فهي بالفعل بهذا التنسيق ، ويكون كل VectorDrawable الذي تم إنشاؤه متوافقًا أيضًا مع أجهزة Android 5. <br><br>  يبدو الملف النهائي الخاص بـ <i>badge-feature-like.xml</i> في هذه الحالة كما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">&lt;!-- This file is generated automatically - DO NOT EDIT --&gt; &lt;vector xmlns:android="&lt;a href="http://schemas.android.com/apk/res/android"&gt;http://schemas.android.com/apk/res/android&lt;/a&gt;" android:width="128dp" android:height="128dp" android:viewportWidth="128" android:viewportHeight="128"&gt; &lt;path android:fillColor="?color_feature_liked_you" android:pathData="M64 1a63 63 0 1 0 0 126A63 63 0 1 0 64 1z" /&gt; &lt;path android:fillColor="#FFFFFF" android:pathData="M80.406 ..." /&gt; &lt;/vector&gt;</code> </pre> <br>  كما ترون ، في ملفات VectorDrawable أيضًا ، نقوم بحقن أسماء متغيرة لألوان <i>التعبئة</i> ، المقترنة برموز التصميم عبر الأنماط المخصصة في تطبيقات Android. <br><br>  هذا ما يبدو عليه VectorDrawable بمجرد استيراده في Android Studio: <br><br> <a href=""><img src="https://habrastorage.org/webt/zu/n4/8q/zun48q0knfv8k9xy4amb6eqrxxa.png"></a> <br>  <i>مثال على أيقونة VectorDrawable التي تم استيرادها إلى Android Studio</i> <br><br>  هناك شيء واحد يجب ملاحظته في هذه الحالة: يحتوي Android Studio على طريقة صارمة وموضوعة لتنظيم الأصول: لا يوجد مجلد متداخل وكل الأسماء الصغيرة!  هذا يعني أنه كان علينا التوصل إلى تنسيق مختلف قليلاً عن أسماء الرموز الخاصة بهم: في حالة الأصل الموجود تحت التجربة ، سيكون اسمه مثل <i>اسم_اسم_اسم_اسم_العلامة_العلامة_المعيار _ الاسم البديل</i> . <br><br><h2 style=";text-align:right;direction:rtl">  JSON القاموس كمكتبة الأصول </h2><br>  بمجرد حفظ ملفات الأصول في نسقها النهائي ، فإن آخر شيء لا يزال يتعين القيام به هو حفظ جميع المعلومات الوصفية التي تم جمعها أثناء عملية الإنشاء ، وتخزينها في "قاموس" ، بحيث يمكن إتاحتها لاحقًا عندما يتم استيراد الأصول واستهلاكها بواسطة codebase من الأنظمة الأساسية المختلفة. <br><br>  بعد استخلاص قائمة الأيقونات المسطحة من كائن <i>أصول البيانات</i> ، نقوم <i>بحلها</i> فوق كل عنصر نتحقق منه: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  إذا كان رصيدًا عاديًا (على سبيل المثال ، <i>tabbar-livestream</i> ) ، وإذا كان كذلك ، فنحن نحتفظ به ؛ </li><li style=";text-align:right;direction:rtl">  إذا كان هناك اختلاف في اختبار AB (على سبيل المثال ، <i>التجربة / tabbar-liveestream [البديل]</i> ) ، فإننا نربط اسمها <i>ومسارها</i> واختبارها AB وأسماء المتغيرات ، <i>باختبارات</i> خاصية <i>الأصل</i> "الأساسي" (في هذه الحالة ، <i>tabbar- livestream</i> ) ، ثم نزيل إدخال المتغير من القائمة / الكائن (فقط التهم "الأساسية") ؛ </li><li style=";text-align:right;direction:rtl">  إذا كان متغير "شبح" ، فنحن نحذف الملف ، ثم نزيل الإدخال من القائمة / الكائن. </li></ul><br>  بمجرد اكتمال الحلقة ، سيحتوي القاموس على قائمة بجميع الرموز "الأساسية" فقط (واختبارات AB الخاصة بهم ، إذا كانت قيد التجربة).  لكل منها ، سوف تحتوي على اسمها وحجمها ومسارها ، وإذا كانت أيقونة تحت اختبار AB ، فإن المعلومات حول الخيارات المختلفة للأصل. <br><br>  ثم يتم حفظ هذا القاموس بتنسيق JSON في مجلد الوجهة <i>للعلامة التجارية</i> والنظام <i>الأساسي</i> .  هنا ، على سبيل المثال ، هو ملف <i>الأصول.json الذي تم</i> إنشاؤه لتطبيق "Blendr" على "الويب المحمول": <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">{ "platform": "mw", "brand": "blendr", "assets": { "badge-feature-like": { "assetname": "badge-feature-like", "path": "assets/badge-feature-like.jsx", "width": 64, "height": 64, "source": "icons_common" }, "navigation-bar-edit": { "assetname": "navigation-bar-edit", "path": "assets/navigation-bar-edit.jsx", "width": 48, "height": 48, "source": "icons_common" }, "tabbar-livestream": { "assetname": "tabbar-livestream", "path": "assets/tabbar-livestream.jsx", "width": 128, "height": 128, "source": "icons_blendr", "abtest": { "this__is_an_experiment": { "control": "assets/this__is_an_experiment/tabbar-livestream__control.jsx", "variant1": "assets/this__is_an_experiment/tabbar-livestream__variant1.jsx", "variant2": "assets/this__is_an_experiment/tabbar-livestream__variant2.jsx" }, "a_second-experiment": { "control": "assets/a_second-experiment/tabbar-livestream__control.jsx", "variantA": "assets/a_second-experiment/tabbar-livestream__variantA.jsx" } } }, ... } }</code> </pre> <br>  الخطوة الأخيرة هي ضغط جميع مجلدات <i>الأصول</i> في.  ملفات <i>zip</i> ، بحيث يمكن تنزيلها بسهولة أكبر. <br><br><h2 style=";text-align:right;direction:rtl">  النتيجة النهائية </h2><br>  العملية الموضحة أعلاه - من الاستنساخ الأولي ومعالجة ملفات Sketch ، إلى تصدير (وتحويل) الأصول في التنسيق المطلوب لكل نظام أساسي مدعوم ، إلى تخزين المعلومات الوصفية المجمعة في مكتبة أصول - هي تكرار لكل علامة تجارية تم الإعلان عنها في البرنامج النصي للبناء <br><br>  فيما يلي لقطة <i>للشكل الذي</i> تبدو عليه بنية <i>src</i> والمجلدات <i>dist</i> ، بمجرد اكتمال عملية الإنشاء: <br><br><img src="https://habrastorage.org/webt/yg/nc/d9/ygncd9uupdngcnav-rmkrsq1dsg.png"><br>  <i>هيكل المجلدات "src" و "dist" بعد الانتهاء من عملية الإنشاء.</i> <br><br>  في هذه المرحلة ، من خلال أمر واحد بسيط ، يمكن تحميل جميع الموارد (ملفات JSON وملفات ZIP وملفات الأصول) إلى مستودع بعيد ، وإتاحتها لجميع الأنظمة الأساسية المختلفة ، للتنزيل والاستهلاك في قواعدها البرمجية. <br><br>  (كيف تسترجع المنصات الفعلية الأصول وتعالجها - عن طريق البرامج النصية المخصصة التي تم تصميمها خصيصًا لهذا الغرض - تتجاوز نطاق هذا المقال ، لكن من المحتمل أن يتم تغطيتها قريبًا في منشورات مدونة مخصصة أخرى ، بواسطة أحد المطورين الآخرين الذين عملوا معي في هذا المشروع). <br><br><h2 style=";text-align:right;direction:rtl">  الاستنتاجات (والدروس المستفادة على طول الطريق) </h2><br>  لطالما أحببت <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">رسم</a>  لسنوات ، كانت الأداة "الفعلية" لاختيار تصميم الويب والتطبيقات (والتطوير).  لذلك كنت مهتمًا جدًا <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">وفضوليًا</a> لاستكشاف تكاملات محتملة مثل <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">html-sketchapp</a> أو أدوات مشابهة ، يمكن استخدامها في سير العمل وخطوط الأنابيب الخاصة بنا. <br><br>  هذا التدفق (المثالي) كان دائمًا <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الكأس المقدسة بالنسبة لي</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">وكثير غيرها</a> ): <br><br><img src="https://habrastorage.org/webt/kq/7l/n4/kq7ln4kr6txurb-mvh6brqbhnqe.png"><br><br>  يمكن أن تتخيل رسم كأداة تصميم ك "هدف" محتمل لقاعدة البيانات. <br><br>  لكن عليّ أن أعترف أنني بدأت أخيرًا أتساءل عما إذا كانت Sketch لا تزال الأداة الصحيحة ، لا سيما في سياق نظام التصميم.  لذلك ، بدأت استكشاف أدوات جديدة مثل <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Figma</a> ، مع واجهات برمجة التطبيقات المفتوحة ، و <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Framer X</a> ، مع تكاملها المذهل مع React ، لأنني لم أشاهد جهودًا مماثلة من Sketch للانتقال إلى التكامل مع الكود (مهما كانت الكود). <br><br>  حسنًا ، لقد غير هذا المشروع رأيي.  ليس تماما ، ولكن بالتأكيد الكثير. <br><br>  ربما لا يقوم Sketch بالكشف عن واجهات برمجة التطبيقات الخاصة به رسميًا ، ولكن بالتأكيد الطريقة التي بنوا بها البنية الداخلية لملفاتهم هي نوع من واجهة برمجة التطبيقات "غير الرسمية".  كان بإمكانهم استخدام أسماء خفية ، أو تشويش المفاتيح في كائنات JSON ؛  وبدلاً من ذلك ، اختاروا اتفاقية تسمية واضحة وسهلة القراءة ، وقابلة للقراءة ، وشاملة.  لا أستطيع أن أعتقد أن هذا مجرد عرضي. <br><br>  حقيقة أن ملفات Sketch يمكن معالجتها قد فتحت في ذهني مجموعة واسعة من التطورات والتحسينات المستقبلية المحتملة.  من المكونات الإضافية للتحقق من صحة تسمية ، وتصميم وهيكل الطبقات للأيقونات ، إلى التكامل ممكن مع ويكي لدينا ووثائق نظام التصميم لدينا (في كلا الاتجاهين) ، من خلال إنشاء تطبيقات العقدة المستضافة في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الكترون</a> أو <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">كارلو</a> لتسهيل العديد من المهام المتكررة التي يتعين على المصممين القيام بها. <br><br>  ومن بين المكافآت غير المتوقعة لهذا المشروع (على الأقل بالنسبة لي) أن ملفات Sketch التي تحمل أيقونات كوزموس أصبحت "مصدراً للحقيقة" ، على غرار ما حدث مع <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">نظام تصميم Cosmos</a> .  إذا لم يكن هناك رمز ، فلن يكون موجودًا في قاعدة البيانات (أو أفضل منه ، يجب ألا يكون موجودًا: لكننا على الأقل نعرف أنه استثناء).  أعلم أن الأمر واضح تمامًا الآن ، لكنه لم يكن من قبل ، على الأقل بالنسبة لي. <br><br>  ما بدأ كمشروع MVP ، سرعان ما أصبح الغوص العميق (حرفيًا) في الملفات الداخلية لملفات Sketch ، مع إدراك أنه يمكن التلاعب بها.  لا نعرف حتى الآن إلى أين سيؤدي كل هذا ، لكنه كان حتى الآن نجاحًا.  يوافق جميع المصممين والمطورين ومديري البرامج وأصحاب المصلحة ، على أن هذا سيوفر الكثير من العمل اليدوي للجميع ، ويمنع الكثير من الأخطاء المحتملة.  ولكنه أيضًا سيفتح الأبواب أمام استخدامات الرموز التي كانت مستحيلة حتى الآن. <br><br>  شيء واحد أخير: ما وصفته في هذا المنشور الطويل هو خط أنابيب قمنا ببنائه هنا لحل <i>مشاكلنا</i> الخاصة ، وبالتالي فهو بالضرورة مخصص للغاية لسياقنا.  <i>ضع</i> في اعتبارك أنه قد لا يناسب احتياجات عملك أو يناسب السياق <i>الخاص بك</i> . <br><br>  لكن المهم بالنسبة لي وما أردت مشاركته هو أنه يمكن القيام به.  ربما بطرق مختلفة ، مع أساليب مختلفة وتنسيقات الإخراج المختلفة ، ربما تنطوي على تعقيد أقل (على سبيل المثال: قد لا تحتاج إلى العلامة التجارية المتعددة واختبار AB).  ولكن الآن يمكنك أتمتة سير العمل الذي ينطوي عليه تسليم أيقوناتك باستخدام برنامج نصي Node.js مخصص ورسم. <br><br>  ابحث عن طريقتك الخاصة للقيام بذلك.  انها ممتعة (وسهلة نسبيا). <br><br><h2 style=";text-align:right;direction:rtl">  الاعتمادات </h2><br>  تم تطوير هذا المشروع الضخم بالتعاون مع <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Nikhil Verma</a> (Mobile Web) ، الذي أنشأ الإصدار الأول من النص البرمجي للبناء ، و <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Artem Rudoi</a> (Android) و <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Igor Savelev</a> (iOS) ، الذين طوروا البرامج النصية التي تستورد الأصول <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">وتستهلكها</a> في منصات الأصلية منها.  شكراً لكم أيها الناس ، لقد كان انفجارًا يعمل معكم في هذا المشروع وشاهده على أرض الواقع. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar441042/">https://habr.com/ru/post/ar441042/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar441030/index.html">الكشف عن الهجمات على شبكة الإنترنت مع Seq2Seq Autencoder</a></li>
<li><a href="../ar441032/index.html">كيبي صنع لوحة مفاتيح USB الخاصة بك من الصفر</a></li>
<li><a href="../ar441034/index.html">6 نقاط لنمو التحويل أو كيفية زيادة الثقة باستخدام الهاتف على الموقع</a></li>
<li><a href="../ar441036/index.html">كيفية تقديم وتلقي الملاحظات إذا كنت عصفور sociophobus</a></li>
<li><a href="../ar441040/index.html">إنشاء أيقونات متعددة المنصات متعددة العلامات التجارية باستخدام رسم وسكربت Node.js - الجزء الأول</a></li>
<li><a href="../ar441044/index.html">قصة كيف قمنا بتغيير أيقونة PVS-Studio</a></li>
<li><a href="../ar441046/index.html">قصة كيف قمنا بتغيير أيقونة PVS-Studio</a></li>
<li><a href="../ar441048/index.html">مكتب العدوانية الموالية</a></li>
<li><a href="../ar441050/index.html">صنع كاميرا حرارية DIY تعتمد على Raspberry Pi</a></li>
<li><a href="../ar441052/index.html">16 مارس Badoo PHP Meetup: الاختبارات وجودة الرمز. التسجيل مفتوح</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>