<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚵🏻 🙏 🐞 牧羊犬 👩🏼‍🌾 👦🏽 👏🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sheepdog是可扩展的系统，可为虚拟机提供分布式块设备。 它的开发于2009年由日本公司Nippon Telegraph and Telephone Corporation的开发人员开始。 Sheepdog是GPL2许可下的开源应用程序。 2015年11月发布的最新版本0.9.3将成为1.0版本...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>牧羊犬</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412739/"><p><img src="https://habrastorage.org/webt/ru/g3/9i/rug39i1kkn-c4ack--isbvvzjma.jpeg"></p><br><p> <strong>Sheepdog</strong>是可扩展的系统，可为虚拟机提供分布式块设备。 它的开发于2009年由日本公司<em>Nippon Telegraph and Telephone Corporation</em>的开发人员开始。  <strong>Sheepdog</strong>是GPL2许可下的开源应用程序。  2015年11月发布的最新版本0.9.3将成为1.0版本的遗留物，适用于商业用途<sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1</a></sup> <sup><a name="cite_ref-1"></a></sup>  。  <em>（已经变成-大约。）</em> </p><br><blockquote> 为了引起人们的兴趣，开发人员于2010年8月发布了第一个版本（0.1.0）-同时，主要QEMU开发分支中立即包含了对dogdog的支持。 <a name="habracut"></a><br> 我在2011年11月对牧羊犬进行的首次测试<sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2</a></sup> <sup><a name="cite_ref-2"></a></sup> 并且结果对于I / O操作是好的。 但是，然后， <strong>牧羊犬</strong>系统在恢复跌落节点方面<strong>仍然</strong>存在问题。 这个问题可能很快就解决了，因为应用程序开发非常活跃，但是那时我使用了另一个解决方案。 </blockquote><br><h1 id="vozmozhnosti"> 可能性 </h1><br><p>  <strong>牧羊犬</strong>的工作原理在已发表的演讲中得到了很好的描述，因此，我将仅作简要概述。 </p><br><p>  <strong>可扩展</strong> <br> 群集大小可以在节点级别任意增加，可以在操作期间增加数据的容量和空间，也可以通过增加节点数量来增加。 节点越多，VDI I / O的性能就越高。 </p><br><p>  <strong>他很简单</strong> <br> 与CEPH等其他系统不同， <strong>Sheepdog</strong>不能直接与文件系统一起使用，而是以固定大小的块进行操作，因此，它不需要单独的守护程序来提供元数据。 所有控制都是使用与<strong>狗</strong>直接通讯的单个<strong>狗</strong>工具执行的 <br>  <em>（ceph还使用对象-大约每个。）</em> </p><br><p>  <strong>计算下降的节点</strong> <br> 每个VDI包含这些块（对象），这些块同时复制到几个节点，因此，如果其中一个掉落，则数据仍然可用，并且掉落的节点中的对象开始复制到另一个节点。 </p><br><p>  <strong>支持块设备快照</strong> <br> 牧羊犬<strong>快照的</strong>工作原理与Btrfs相同。 附加的VDI块将保存，并将新数据写入新块。 </p><br><p> 在某些情况下，以下功能可能会出现问题： </p><br><p>  <strong>牧羊犬不支持SPOF</strong> <br> 如果VDI通过QEMU用作块设备，则在多个位置同时连接VDI时可能会出现问题。  SPOF <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3</a></sup>可以防止这种情况。 <sup><a name="cite_ref-3"></a></sup> 牧羊犬没有。 但是，在新版本的Sheepdog中，可以阻止VDI，以便不允许多个连接。 </p><br><p>  <strong>数据对象的生命周期</strong> <br> 仅当删除所有与它们关联的克隆和快照时，才能删除VDI对象。 这与Btrfs完全相同。 因此，删除未使用的快照可能不足以腾出存储空间。 </p><br><h1 id="demon-kommunikacii"> 通讯守护程序 </h1><br><p> 与Ceph或GlusterFS相比，牧羊犬小得可笑。 这是因为他没有亲自解决所有问题，而是最大限度地利用了已经发挥作用的东西。 </p><br><p> 反过来，它提供了可以用作物理磁盘以及软件团队等的块设备。 </p><br><p> 它仅关心数据对象在其上运行的节点之间的分布。 </p><br><p> 但是，他需要<strong>通信守护程序</strong>提供的信息- <strong>缺少Dogdog</strong>的关键组件。 </p><br><p>  <strong>通信守护程序</strong> -不提供在节点之间交换数据的功能。 这就是<strong>绵羊</strong>恶魔在做什么。  <strong>绵羊</strong>只能通过它找出当前处于活动状态的节点。 </p><br><h2 id="corosync"> 同步 </h2><br><p> 首先， <strong>Sheepdog</strong>假定节点将通过<strong>corosync</strong>相互通信。 它最多支持64个节点，尽管从理论上讲它应该能够提供更多服务，但它最适合于最多16个节点的小型集群。 </p><br><p> 通常， <strong>corosync</strong>也使用Pacemaker，因此无需安装其他任何东西。 </p><br><h3 id="ustanovka-corosync-na-debian"> 在Debian上安装corosync </h3><br><p>  Corosync位于分发存储库中，其安装非常简单： </p><br><pre><code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> apt<span class="hljs-literal"><span class="hljs-literal">-get</span></span> install corosync libcoro<span class="hljs-built_in"><span class="hljs-built_in">sync-common4</span></span></code> </pre> <br><h3 id="nastroyka-corosync">  Corosync设置 </h3><br><h2 id="zookeeper"> 动物园管理员 </h2><br><p>  <strong>牧羊犬</strong>开发人员建议将<strong>Zookeeper</strong>用于较大的群集。 根据开发人员的说法，已构建并测试了具有1000个节点的<strong>Sheepdog</strong>测试存储<sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4</a></sup> <sup><a name="cite_ref-4"></a></sup>  。 </p><br><h3 id="ustanovka-zookeeper-na-debian"> 在Debian上安装Zookeeper </h3><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> apt<span class="hljs-literal"><span class="hljs-literal">-get</span></span> install zookeeper zookeeperd</code> </pre> <br><p> 启动守护程序.. </p><br><pre> <code class="hljs pgsql">$ /usr/<span class="hljs-keyword"><span class="hljs-keyword">share</span></span>/zookeeper/bin/zkServer.sh <span class="hljs-keyword"><span class="hljs-keyword">start</span></span></code> </pre> <br><p>  Zookeeper运行的默认端口为2181 </p><br><p> 在动物园管理员的支持下运行牧羊犬： </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> sheep <span class="hljs-literal"><span class="hljs-literal">-c</span></span> zookeeper:IP1:PORT1,IP2:PORT2,IP3:PORT3 ...other...option...</code> </pre> <br><p>  <strong>zookeeper</strong>的好处是，在这种情况下， <strong>Sheepdog</strong>的节点配置更加清晰明了，但是存在一个问题，即Debian安装软件包不包含其支持。 </p><br><p> 因此，要获得具有Zookeeper支持的Sheepdog，您必须从源代码进行编译。 尽管我不能排除目前情况可能有所不同。 <br>  <em>（zookeeper支持仍需要从源进行编译-大约每个。）</em> </p><br><h1 id="nastroyka-demona-sheep"> 设置绵羊守护程序 </h1><br><p> 当对象管理器<strong>Sheep</strong>守护程序启动时，该节点将成为Sheepdog的一部分。 它始终以两个副本工作： </p><br><ol><li><p> 该过程的第一个实例从网关开始，该网关从客户端（例如，从QEMU块设备的驱动程序）接收I / O请求，计算目标节点并在它们之间发送进一步处理的请求。 即，它建立许多网络连接。 </p><br></li><li> 另一个充当本地对象管理器（ <strong>Object Manager</strong> ） </li></ol><br><p>  Sheep守护程序配置参数可以在运行时作为命令行参数传递。 如果没有，将使用默认值，请谨慎使用： </p><br><p>  <strong>端口号</strong> <br> 除非另有指定，否则绵羊守护程序将在端口7000上运行 </p><br><p>  <strong>保管箱路径</strong> <br> 除非另有说明，否则shep目录使用/ var / lib / Sheepdog目录，并且VDI对象存储在其<code>obj</code>子目录中。 </p><br><blockquote> 从理论上讲，没有什么能阻止多个<strong>羊</strong>实例在一个节点上工作-主要条件是每个人都使用自己的端口号和自己的存储。 节点的IP地址问题已基本解决。 在不同端口上运行的<strong>羊</strong>守护程序的每个运行实例将自动连接到现有集群！ <br><br> 重要信息是端口号是VDI容器配置的一部分。 您需要知道是否要将<strong>绵羊</strong>守护程序重新配置为在现有集群的另一个端口上运行。 <br><br> 因此，如果运行具有不同端口号但具有相同对象存储路径的<strong>羊</strong>守护程序实例，则可能会丢失现有VDI容器中的信息。 </blockquote><br><h1 id="demon-sheep-kak-shlyuz"> 恶魔羊作为门户 </h1><br><p> 在没有VDI对象存储空间的计算机上，可以通过<code>-G</code>标志以网关模式独占运行<strong>羊</strong>守护程序。 </p><br><p> 在这种情况下，分发VDI对象时，根本不会使用本地存储，并且数据将直接分发到其他节点。 </p><br><h1 id="demon-sheep-kak-menedzher-obektov"> 绵羊恶魔作为对象管理者 </h1><br><p> 第二个正在运行的实例充当本地对象管理器，从作为网关启动的实例接收I / O请求，并在本地对象存储（ <strong>对象存储</strong> ）中执行r / w操作 </p><br><h2 id="hranilische-obektov"> 对象存储 </h2><br><p> 默认情况下， <strong>Sheepdog中</strong> VDI对象的存储为目录<code>/var/lib/sheepdog/obj</code> ， <strong>羊</strong>守护程序也将其用作其内部目录结构的一部分-这是默认的存储路径。 </p><br><p> 如果希望将VDI对象存储在其他位置，则可以在启动时将安装另一个块设备的路径作为参数传递。 </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">sheep</span></span> ... /cesta_do_přípojného_bodu</code> </pre> <br><p> 还有更多的传达方式。 新版本的<strong>Sheepdog</strong>支持所谓的多设备技术，该技术使您可以在必要时动态增加内存容量，而不必重新启动<strong>Sheepdog</strong> 。 增加存储容量的工作原理类似于Btrfs。 </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">sheep</span></span> ... /cesta_do_A,/cesta_do_B,/cesta_do_C</code> </pre> <br><p>  <em>（指定的第一个目录仅用于元数据-大约每个）</em> </p><br><p> 也可以通过<strong>狗节点md</strong>添加（或删除）附加存储 </p><br><p>  ... </p><br><p> 当存储文件系统不“通过设计”支持此功能时（与Btrfs或ZFS不同），多设备提供的功能特别有用。 通常，选择用于存储对象，其属性，参数和设置的文件系统会严重影响虚拟机IO文件系统的性能。 </p><br><blockquote> 多设备技术需要文件方面的高级属性，这对于btrfs <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">5</a></sup>这样的现代文件系统来说不是问题 <sup><a name="cite_ref-5"></a></sup> 或ext4。 但是一些较旧的文件系统，例如reiserfs或ext2 <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">6</a></sup> <sup><a name="cite_ref-6"></a></sup> 不支持他们。 <br><br> 如果要使用不支持扩展属性来存储对象的文件系统，则需要编译不具有多设备支持的<strong>Sheepdog</strong> 。 </blockquote><br><h2 id="tip-hranilischa---plain-versus-tree"> 存储类型-普通还是树 </h2><br><p> 格式化群集时，除其他选项外，您可以指定存储类型（后端存储）。 您可以将类型设置为<strong>plain</strong>或<strong>tree</strong> 。 对于<strong>普通</strong>类型，目录结构将如下所示： </p><br><pre> <code class="hljs ruby"><span class="hljs-params"><span class="hljs-params">| |</span></span>- obj <span class="hljs-params"><span class="hljs-params">| |</span></span>- &lt;id &gt; <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">|-&lt; &gt; |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span>-&lt; &gt; <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">|-&lt; &gt; |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span>- ... <span class="hljs-params"><span class="hljs-params">| |</span></span>- &lt;id  &gt; <span class="hljs-params"><span class="hljs-params">| |</span></span> ... <span class="hljs-params"><span class="hljs-params">|- config [] |</span></span>- epoch <span class="hljs-params"><span class="hljs-params">| |</span></span>- &lt; &gt; <span class="hljs-params"><span class="hljs-params">| |</span></span>- &lt; &gt; <span class="hljs-params"><span class="hljs-params">| |</span></span>- ... <span class="hljs-params"><span class="hljs-params">|- journal \- sheep.log []</span></span></code> </pre> <br><p>  <code>obj</code>目录中的所有VDI对象将被发送到一个子目录，该子目录的名称基于当前的时代标识符。 也就是说，对于每个时代，相应的VDI对象将被分开存储。 但是，在一个时代中，目录中可能会出现大量VDI对象，这随后会减慢对文件的访问。 因此，您可以选择第二个选项，即<strong>tree</strong> ： </p><br><pre> <code class="hljs ruby"><span class="hljs-params"><span class="hljs-params">|- obj |</span></span> <span class="hljs-params"><span class="hljs-params">|- aa |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span>-&lt; &gt; <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">|-&lt; &gt; |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span>-&lt; &gt; <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">|- ... |</span></span> <span class="hljs-params"><span class="hljs-params">|- ab |</span></span> <span class="hljs-params"><span class="hljs-params">| ... |</span></span> <span class="hljs-params"><span class="hljs-params">|- meta |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span>- &lt; &gt; <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">|- ... |</span></span> <span class="hljs-params"><span class="hljs-params">|- 0a |</span></span> <span class="hljs-params"><span class="hljs-params">| ... |</span></span>- config [] <span class="hljs-params"><span class="hljs-params">|- epoch |</span></span> <span class="hljs-params"><span class="hljs-params">|- &lt; &gt; |</span></span> <span class="hljs-params"><span class="hljs-params">|- &lt; &gt; |</span></span> <span class="hljs-params"><span class="hljs-params">|- ... \- sheep.log []</span></span></code> </pre> <br><p> 在这种类型的存储中， <strong>Sheep</strong>守护程序在<code>obj</code>目录中创建一组256个子目录，名称为<code>0a, ..., 99</code> ，然后根据<strong>VDI id</strong>的后两个字符分散对象，这不仅对于每个VDI容器都是唯一的，而且对于其快照或克隆。 </p><br><h2 id="imena-vdi-obektov">  VDI对象名称 </h2><br><p> 当<strong>Sheepdog</strong>将数据保存在VDI容器中时，文件将开始出现在<code>obj</code>数据存储中，每个文件都有其自己的名称，该名称由几个元素组成： </p><br><pre> <code class="hljs go">../obj/<span class="hljs-number"><span class="hljs-number">8f</span></span>/<span class="hljs-number"><span class="hljs-number">00e8</span></span>b18f00000005 ^^</code> </pre> <br><p> 前两个字符指示对象的类型。 数据对象以<code>00...</code>开头，元数据（可以存储在另一个目录中） <code>80...</code> </p><br><pre> <code class="hljs go">../obj/<span class="hljs-number"><span class="hljs-number">8f</span></span>/<span class="hljs-number"><span class="hljs-number">00e8</span></span>b18f00000005 ^^^^^^</code> </pre> <br><p> 然后是VDI。 它不仅对于每个容器都是唯一的，而且对于其快照或克隆也是唯一的。 </p><br><pre> <code class="hljs go">../obj/<span class="hljs-number"><span class="hljs-number">8f</span></span>/<span class="hljs-number"><span class="hljs-number">00e8</span></span>b18f00000005 ^^ ^^</code> </pre> <br><p> 在<strong>树</strong>存储类型的情况下，VDI标识符的最后两位数字指示对象所属的子目录所在的位置。 </p><br><pre> <code class="hljs go">../obj/<span class="hljs-number"><span class="hljs-number">8f</span></span>/<span class="hljs-number"><span class="hljs-number">00e8</span></span>b18f00000005 ^^^^^^^^</code> </pre> <br><p>  VDI容器的标识符（以十六进制表示）后跟VDI容器中对象的序列号 </p><br><h2 id="epoha"> 时代 </h2><br><p>  <code>epoch</code>子目录包含属于该时代的对象的二进制列表。 每当每个群集更改时（添加或删除节点时），时期数都会增加。 每个此类更改都会启动<strong>恢复</strong>过程，在此过程中，将在节点上检查本地对象的当前状态，然后增加了时代。 </p><br><h1 id="kak-optimalno-vybrat-hranilische-vdi-obektov"> 如何选择最佳的VDI对象存储 </h1><br><p> 可用存储容量是根据节点上的可用空间计算的。  <strong>绵羊</strong>选择的空间始终取决于存储VDI对象的块设备中的可用空间。 </p><br><p>  VDI容器的大小只是一个虚拟形状，与VDI对象所占用的空间无关。 知道Sheepdog如何处理集群中的数据很重要： </p><br><blockquote> 牧羊犬总是试图在那个时代的所有机器之间平均存储数据。 </blockquote><p> 这意味着，如果其中一个节点掉落，时代改变并且<strong>Sheepdog</strong>立即开始恢复过程，它将在其余节点上创建丢失的VDI对象以补偿损失。 </p><br><p> 添加新节点时也会出现类似情况。  <strong>牧羊犬</strong>将开始将VDI对象从新节点均匀地移动到其存储库中，以便使节点上数据空间的填充百分比尽可能地平衡。 使用以下命令可以总体了解当前节点上已使用了多少空间： </p><br><pre> <code class="hljs pgsql">nod1 ~ # collie node md <span class="hljs-keyword"><span class="hljs-keyword">info</span></span> -A Id Size Used Avail Use% <span class="hljs-type"><span class="hljs-type">Path</span></span> Node <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1.1</span></span> TB <span class="hljs-number"><span class="hljs-number">391</span></span> GB <span class="hljs-number"><span class="hljs-number">720</span></span> GB <span class="hljs-number"><span class="hljs-number">35</span></span>% /<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/sheepdog-data/obj Node <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">702</span></span> GB <span class="hljs-number"><span class="hljs-number">394</span></span> GB <span class="hljs-number"><span class="hljs-number">307</span></span> GB <span class="hljs-number"><span class="hljs-number">56</span></span>% /<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/sheepdog-data/obj Node <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">794</span></span> GB <span class="hljs-number"><span class="hljs-number">430</span></span> GB <span class="hljs-number"><span class="hljs-number">364</span></span> GB <span class="hljs-number"><span class="hljs-number">54</span></span>% /<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/sheepdog-data/obj Node <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1.6</span></span> TB <span class="hljs-number"><span class="hljs-number">376</span></span> GB <span class="hljs-number"><span class="hljs-number">1.2</span></span> TB <span class="hljs-number"><span class="hljs-number">22</span></span>% /<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/sheepdog-data/obj Node <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1.2</span></span> TB <span class="hljs-number"><span class="hljs-number">401</span></span> GB <span class="hljs-number"><span class="hljs-number">838</span></span> GB <span class="hljs-number"><span class="hljs-number">32</span></span>% /<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/sheepdog-data/obj Node <span class="hljs-number"><span class="hljs-number">5</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1.5</span></span> TB <span class="hljs-number"><span class="hljs-number">370</span></span> GB <span class="hljs-number"><span class="hljs-number">1.1</span></span> TB <span class="hljs-number"><span class="hljs-number">24</span></span>% /<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/sheepdog-data/obj Node <span class="hljs-number"><span class="hljs-number">6</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1.6</span></span> TB <span class="hljs-number"><span class="hljs-number">388</span></span> GB <span class="hljs-number"><span class="hljs-number">1.2</span></span> TB <span class="hljs-number"><span class="hljs-number">23</span></span>% /<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/sheepdog-data/obj</code> </pre> <br><h2 id="proizvoditelnost-io">  I / O性能 </h2><br><p> 在这里必须要说的是， <strong>牧羊犬的</strong>工作方式与Ceph不同，并且具有不同的优先级。 </p><br><p> 对于Ceph而言，放置数据对象，块设备的性能，主机连接性和响应速度时，OSD设备的“重量”至关重要。  <em>（实际上不是-大约）</em> </p><br><p> 我不知道牧羊犬会做这样的事情吗？ 可能吧 首先给他的数据。 在I / O操作方面的性能是次要的。 当然，有了更强大的节点，它的I / O性能可以提高，但是它始终取决于特定的结构。  <em>（然而， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">测试</a>显示出比ceph更好的牧羊犬性能-大约per）</em> </p><br><blockquote> 我向Sheepdog添加了一个新节点，数据存储在旋转的2TB SATA II磁盘上。 该光盘的最大写入速度约为80M / s。 实际上，它变化很大，因为SATA驱动器无法同时读写。 <br><br> 最初，此磁盘上VDI的平均写入速度约为20〜30M / s，因为除了恢复VDI中的数据外，还复制了392G容器数据。 这持续了6.5个小时。 写入速度在40〜55M / s之间。 <br><br> 显然，在这种情况下，写入速度受到本地块设备的I / O性能的限制。 </blockquote><p> 对于Sheepdog，适用以下规则：“具有快速连接的节点上存在的VDI对象越多，I / O操作的性能就越好。” </p><br><p> 由于在后台移动VDI对象意味着“节点的快速死亡”将减慢那些占用最大空间的数据对象的复制，因此这将表现为VDI容器的I / O操作性能下降。 </p><br><h2 id="zanimaemoe-prostranstvo"> 占用空间 </h2><br><p> 放置数据对象时，可用空间的数量对于<strong>羊</strong>守护程序至关重要。 该机制看起来很简单。  <strong>绵羊</strong>守护程序通过该<strong>绵羊</strong>守护程序不时地与VDI容器进行数据通信，从而确定节点上的可用空间和已占用空间的利用率，并对其进行排序。 然后将数据分配到利用率最低的节点之间。 </p><br><p> 如果主要存在快速写入路径，则对VDI容器的写入操作也将很快。 由于执行VDI容器的I / O操作的速度越快， <strong>Sheep</strong>守护程序可以越早进行下一个操作。 </p><br><p> 重要的是，对于Sheepdog，当其中一个节点完全充满时，将不会出现任何情况。 如果节点上的利用率变得更差，那么Sheep守护程序将开始将其数据对象移动到另一个位置。 </p><br><p> 牧羊犬的工作原理与Btrfs一样-仅使用真正占用的空间。 因此，您可以创建一个虚拟VDI容器，其容量为1 TB，实际上将占用存储在其中的数据所占用的空间。 从这个角度来看，希望在VDI容器中使用这样的格式的虚拟磁盘和文件系统，它们可以相互清理。 </p><br><h1 id="zapusk-klastera"> 集群启动 </h1><br><blockquote> 虽然可以同时停止所有节点，但不能一次启动节点！ 节点应逐渐连接。 从节点列表中首先指定的节点开始。 <br>  <em>（这是一个非常奇怪的说法-大约每人）</em> </blockquote><br><h1 id="vdi">  Vdi </h1><br><p> 这是<strong>Sheepdog</strong>中虚拟磁盘的通用缩写，而不是其特定格式<sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">7。</a></sup> <sup><a name="cite_ref-7"></a></sup>  。 通常，这是一个具有固定大小的隔离专区的虚拟盒子， <strong>Sheepdog</strong>随后将客户端传输的数据放入其中。 </p><br><h1 id="sozdanie-vdi"> 创建VDI </h1><br><p> 在创建或导入第一个VDI之前，我们需要格式化集群。 格式化群集时，将设置参数，然后在创建每个后续VDI时默认使用这些参数。 </p><br><p> 演示创建名为Disk1且大小为1 GB的新VDI的示例 </p><br><pre> <code class="hljs ruby">root@nod1 <span class="hljs-symbol"><span class="hljs-symbol">:~</span></span><span class="hljs-comment"><span class="hljs-comment"># collie vdi create disk1 1G root</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@nod</span></span></span><span class="hljs-comment">1 :~# collie vdi list Name Id Size Used Shared Creation time VDI id Copies Tag Block Size Shift disk1 0 1.0 GB 0.0 MB 0.0 MB 2015-12-04 14:07 e8b18f 2 22</span></span></code> </pre> <br><p>  <strong>编号</strong> <br>  VDI标识符 </p><br><p>  <strong>尺码</strong> <br>  VDI的大小不必立即进行预分配。 <br> 如果此VDI是使用<code>qemu-img convert</code>创建的增量格式（qcow2等），它将与虚拟磁盘的大小不匹配，但会不断增长。 </p><br><p>  <strong>二手的</strong> <br> 有关VDI数据对象占用多少空间的信息。 <br>  VDI不需要在创建过程中分配数据对象，因为它尚未创建数据对象，因此它根本不会占据任何空间。 </p><br><p>  <strong>共享的</strong> <br> 其他VDI共享的数据对象的数量 </p><br><p>  <strong>创作时间</strong> <br>  VDI创建时间 </p><br><p>  <strong>块大小</strong> <br>  VDI对象的大小。 注意！ 它不是以MB为单位指定，而是以两个字节的幂为单位。 在旧版本中，仅使用4 MB固定大小的对象。 当前，VDI可能具有更大的对象。 常规虚拟机的VDI对象的最佳大小约为64MB（26）。 默认大小22（4 MB）也很小。 少不能安装。 对象的尺寸越小， <strong>Sheepdog</strong>在使用VDI时必须处理的文件数量越多，从IO的角度来看，使用文件并不是一个便宜的问题。 大量文件，尤其是使用慢速SATA控制器的文件，可能会导致读写速度急剧下降。 可以使用的最大对象大小为31（2 GB）。 如果VDI始终存储大量静态数据（例如备份），这将是有益的。 </p><br><p>  <strong>Vdi ID</strong> <br>  VDI标识符。 </p><br><h2 id="chto-soderzhit-vdi">  VDI包含什么？ </h2><br><p>  VDI内容是数据。 这是一个分布式块设备，因此<strong>Sheepdog</strong>不会解决此数据或垃圾。 从这个角度来看，VDI看起来像是LVM逻辑卷。 预先填充的VDI对应于具有专用范围的经典LV分区，而VDI类似于在池中创建的精简LV分区（请参阅LVM（thin_provisioning）），但区别在于数据范围（对象）不在本地存储块设备，并分散在节点之间。 </p><br><blockquote>  VDI格式与此类似地用作文件系统。 一些顺序地占用保留的扩展区（对象），其他的将它们映射为它们的inode，然后直接向它们发送数据。 节点存储文件系统，VDI格式和内部文件系统的不正确组合会导致I / O性能显着下降。 </blockquote><br><h2 id="kak-poluchit-informaciyu-o-vdi"> 如何获取有关VDI的信息 </h2><br><p> 要了解有关VDI格式的更多信息，可以使用<strong>qemu-img info</strong> ： </p><br><pre> <code class="hljs mel">root@nod1 :~# qemu-img info sheepdog:localhost:<span class="hljs-number"><span class="hljs-number">8000</span></span>:disk1 <span class="hljs-keyword"><span class="hljs-keyword">image</span></span>: sheepdog:localhost:<span class="hljs-number"><span class="hljs-number">8000</span></span>:test2 <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>: qcow2 virtual <span class="hljs-keyword"><span class="hljs-keyword">size</span></span>: <span class="hljs-number"><span class="hljs-number">12</span></span>G (<span class="hljs-number"><span class="hljs-number">12884901888</span></span> bytes) disk <span class="hljs-keyword"><span class="hljs-keyword">size</span></span>: <span class="hljs-number"><span class="hljs-number">4.0</span></span>G cluster_size: <span class="hljs-number"><span class="hljs-number">65536</span></span> Format specific information: compat: <span class="hljs-number"><span class="hljs-number">1.1</span></span> lazy refcounts: false refcount bits: <span class="hljs-number"><span class="hljs-number">16</span></span> corrupt: false</code> </pre> <br><p> 从命令的输出中，您可以发现disk1的标称大小为12G。 目前仅需4G。 由于它是qcow2格式，因此很明显它是作为增量创建的。 </p><br><pre> <code class="hljs mel">root@nod1 :~# collie vdi list Name Id Size Used Shared Creation time VDI id Copies Tag Block Size Shift disk2 <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">4.0</span></span> GB <span class="hljs-number"><span class="hljs-number">4.0</span></span> GB <span class="hljs-number"><span class="hljs-number">0.0</span></span> MB <span class="hljs-number"><span class="hljs-number">2015</span></span><span class="hljs-number"><span class="hljs-number">-12</span></span><span class="hljs-number"><span class="hljs-number">-04</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>:<span class="hljs-number"><span class="hljs-number">07</span></span> <span class="hljs-number"><span class="hljs-number">825</span></span>dc1 <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span> root@nod1 :~# qemu-img info sheepdog:localhost:<span class="hljs-number"><span class="hljs-number">8000</span></span>:disk2 <span class="hljs-keyword"><span class="hljs-keyword">image</span></span>: sheepdog:localhost:<span class="hljs-number"><span class="hljs-number">8000</span></span>:disk2 <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>: raw virtual <span class="hljs-keyword"><span class="hljs-keyword">size</span></span>: <span class="hljs-number"><span class="hljs-number">4.0</span></span>G (<span class="hljs-number"><span class="hljs-number">4294967296</span></span> bytes) disk <span class="hljs-keyword"><span class="hljs-keyword">size</span></span>: <span class="hljs-number"><span class="hljs-number">4.0</span></span>G root@nod1 :~# find /datastore/obj/ | grep <span class="hljs-number"><span class="hljs-number">825</span></span>dc1 /datastore/obj/meta/<span class="hljs-number"><span class="hljs-number">80825</span></span>dc100000000 /datastore/obj/c1/<span class="hljs-number"><span class="hljs-number">00825</span></span>dc100000000 /datastore/obj/c1/<span class="hljs-number"><span class="hljs-number">00825</span></span>dc100000001</code> </pre> <br><p> 在这种情况下，Disk2是作为原始分配的4 GB VDI以原始格式创建的，块大小为2 GB，实际上仅占用两个2 GB </p><br><h2 id="eksport-vdi-v-fayl"> 将VDI导出到文件 </h2><br><p>  VDI内容可以通过多种方式从<strong>Sheepdog</strong>导出。 也许最快的是使用<strong>狗读</strong> 。 该命令有点混乱，但仅表示：“加载VDI的内容并将其发送到STDOUT ..”，可以将其重定向到文件： </p><br><pre> <code class="hljs ruby">root@nod1 <span class="hljs-symbol"><span class="hljs-symbol">:~</span></span><span class="hljs-comment"><span class="hljs-comment"># collie vdi read disk1 &gt; /backups/soubor.raw</span></span></code> </pre> <br><p> 如果VDI具有10G，但仅使用2G，它将创建一个具有10 GB完整容量的文件。 </p><br><p>  <strong>在此命令中，VDI的内容未更改</strong> ，因此，如果可以直接使用VDI的内容（例如，压缩qcow2格式的虚拟磁盘） </p><br><pre> <code class="hljs mel">.. -drive <span class="hljs-keyword"><span class="hljs-keyword">file</span></span>=<span class="hljs-keyword"><span class="hljs-keyword">file</span></span>:/disk1_exportovany_z_vdi,..,<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>=qcow2 ..</code> </pre> <br><p> 将VDI内容存储到文件中的另一种方法是使用<strong>qemu-img convert</strong> 。 它不是很快，但是它允许您使用相应虚拟磁盘格式的不同选项将VDI转换为另一种格式。 </p><br><pre> <code class="hljs ruby">root@nod1 <span class="hljs-symbol"><span class="hljs-symbol">:~</span></span><span class="hljs-comment"><span class="hljs-comment"># qemu-img convert -f qcow2 -O file -o preallocation=full,nocow=on sheepdog:localhost:8000:disk1 /disk1_exportovany_z_vdi</span></span></code> </pre> <br><h2 id="inkrementnoe-rezervnoe-kopirovanie"> 增量备份 </h2><br><p> 创建增量备份 </p><br><p> 第一个快照和第二个快照之间的增量。 </p><br><pre> <code class="hljs ruby">root@nod1 <span class="hljs-symbol"><span class="hljs-symbol">:~</span></span><span class="hljs-comment"><span class="hljs-comment"># collie vdi backup test -F snap1 -s snap2 /backups/soubor_diff</span></span></code> </pre> <br><p> 从增量备份还原VDI </p><br><pre> <code class="hljs ruby">root@nod1 <span class="hljs-symbol"><span class="hljs-symbol">:~</span></span><span class="hljs-comment"><span class="hljs-comment"># collie vdi restore test -s snap1 /tmp/backup restoring /tmp/backup... done</span></span></code> </pre> <br><p> 导入增量备份时，VDI当然应该具有从中进行备份的快照。 </p><br><p> 通过阅读图像测试的原始内容进行验证... </p><br><pre> <code class="hljs ruby"> root@nod1 <span class="hljs-symbol"><span class="hljs-symbol">:~</span></span><span class="hljs-comment"><span class="hljs-comment"># collie vdi read test 0 512 -s 3</span></span></code> </pre> <br><h1 id="import-vdi-iz-fayla"> 从文件导入VDI </h1><br><p> 可以类似于导出来执行将现有虚拟磁盘导入为本地FS文件的操作。 但是，区别在于<strong>使用</strong>了<strong>狗写操作</strong> （“从STDIN读取数据并写入VDI文件..”） </p><br><pre> <code class="hljs ruby">root@nod1 <span class="hljs-symbol"><span class="hljs-symbol">:~</span></span><span class="hljs-comment"><span class="hljs-comment"># collie vdi write disk1 &lt; /backups/soubor.raw</span></span></code> </pre> <br><p></p><br><blockquote><ul><li> 内容只能导入到现有的VDI中。 </li><li> 导入的VDI总是比原始文件占用更多空间，因为从中还原VDI的数据块包含标记区域上的数据。 </li></ul><br></blockquote><p> 如果VDI还不存在，并且我们不知道虚拟磁盘需要多少空间，则可以使用<strong>qemu-img convert</strong> </p><br><pre> <code class="hljs ruby">root@nod1 <span class="hljs-symbol"><span class="hljs-symbol">:~</span></span><span class="hljs-comment"><span class="hljs-comment"># qemu-img convert -f file -O qcow2 -o redundancy=2:1 ./disk_ukladany_do_vdi sheepdog:localhost:8000:disk</span></span></code> </pre> <br><blockquote> 尽管VDI格式（例如qcow2，qed和其他格式）可以在VDI中使用。 为了提高I / O效率，最好预先分配数据块。 <br>     ,        <strong>Sheepdog</strong>     VDI. </blockquote><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http://www.sheepdog-project.org/doc/vdi_read_and_write.html</a> </p><br><h1 id="proverka-vdi">  VDI </h1><br><p>    VDI ,      . </p><br><pre> <code class="hljs ruby">root@nod1 <span class="hljs-symbol"><span class="hljs-symbol">:~</span></span><span class="hljs-comment"><span class="hljs-comment"># collie vdi check disk1</span></span></code> </pre> <br><blockquote>    VDI,     .    Sheepdog    ,      .     ,            . </blockquote><p> :   'dog node kill'     ,         ethernet ,   sheep    .          (,    Ethernet),         sheep .               . </p><br><h2 id="io-proizvoditelnost-vdi"> IO  VDI </h2><br><p>  VDI    .          .       ,   IO   VDI. </p><br><p>   <strong>Sheepdog</strong>    SYNC,    .   -,     VFS,   ,       ,       . </p><br><p>       VDI  <strong>Sheepdog</strong>    ,            .              .  <strong>Sheepdog</strong>        VDI-. </p><br><h2 id="ispolzovanie-vfs-kesha-nody">  VFS-  </h2><br><p>      IO  VDI      <strong>sheep</strong>   <strong>-n</strong> .    SYNC         ,   ,        VFS .     ,   VFS  ,   ,      ! </p><br><p>         .            ,          — , ,    . </p><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">sheep</span></span> -n ...</code> </pre> <br><blockquote>   <strong>Sheepdog</strong>      .      <strong>-D</strong> </blockquote><br><h1 id="obektnyy-kesh">   </h1><br><p>     -   .   <strong>sheep</strong>           -   IO —  SSD .  ,   VDI,       SYNC   .             . </p><br><p>       ,   VDI     ,         VDI   . ,     ,     ,      VDI. </p><br><pre> <code class="hljs dos">sheep -w size=<span class="hljs-number"><span class="hljs-number">20000</span></span>,directio,<span class="hljs-built_in"><span class="hljs-built_in">dir</span></span>=/<span class="hljs-built_in"><span class="hljs-built_in">dir</span></span> ...</code> </pre> <br><p> <strong>size</strong> <br>   </p><br><p> <strong>directio</strong> <br>     <strong>sheep</strong>      ,      .      SSD. </p><br><p> <strong>dir</strong> </p><br><pre> <code class="hljs erlang">     ,     .</code> </pre> <br><p>       ( )   <strong>dog</strong> . </p><br><blockquote>        VDI          <strong>dog vd cashe flush</strong> ,     VDI! </blockquote><br><h2 id="zhurnal">  </h2><br><p>   —  .           VDI,     VFS   ,           (/store_dir/journal/[epoch]/[vdi_object_id]),     ,    . </p><br><p>   IO   ,        (cik, cak),   (sequence). </p><br><p>  , <strong>Sheepdog</strong>        VDI ,           ,  SSD-.     ,       VDI    ,           ,                VDI. </p><br><p>        <strong>sheep</strong>      —         </p><br><pre> <code class="hljs matlab">$ sheep -<span class="hljs-built_in"><span class="hljs-built_in">j</span></span> <span class="hljs-built_in"><span class="hljs-built_in">size</span></span>=<span class="hljs-number"><span class="hljs-number">256</span></span>M ...</code> </pre> <br><p>       ,  VDI      ,    .        -,   —   —         -: </p><br><pre> <code class="hljs matlab">$ sheep -<span class="hljs-built_in"><span class="hljs-built_in">j</span></span> dir=/dir,<span class="hljs-built_in"><span class="hljs-built_in">size</span></span>=<span class="hljs-number"><span class="hljs-number">256</span></span>M ...</code> </pre> <br><p>  dir =      ,          .       ,     SW RAID     SSD. </p><br><p> <strong>:</strong>    <strong>sheep</strong>     ,    .     ,      skip,   . </p><br><pre> <code class="hljs matlab">$ sheep -<span class="hljs-built_in"><span class="hljs-built_in">j</span></span> dir=/dir,<span class="hljs-built_in"><span class="hljs-built_in">size</span></span>=<span class="hljs-number"><span class="hljs-number">256</span></span>M,skip ...</code> </pre> <br><hr><br><ol><li>  <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">↑</a></sup> <sup><a name="cite_note-1"></a> .       2015 . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http://events.linuxfoundation.jp/sites/events/files/slides/COJ2015_Sheepdog_20150604.pdf</a></sup> </li><li>  <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">↑</a></sup> <sup><a name="cite_note-2"></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http://www.abclinuxu.cz/blog/kenyho_stesky/2011/11/sheepdog-hrajeme-si-v-hampejzu</a></sup> </li><li>  <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">↑</a></sup> <sup><a name="cite_note-3"></a> SPOF ( <strong>S</strong> ingle <strong>p</strong> oint <strong>o</strong> f <strong>f</strong> ailure) ,             .  SPOF   VDI   iSCSI  <strong>tgtd</strong></sup> </li><li>  <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">↑</a></sup> <sup><a name="cite_note-4"></a></sup>  <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1个</a></sup> </li><li><p>  <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">↑</a></sup> <sup><a name="cite_note-5"></a> Btrfs —    COW,       ,        .   ,      -,      .      ,     ,              .      ,         ,   .  ,     :</sup> </p><br><p> <sup>autodefrag —     ,          .</sup> </p><br><p> <sup>      </sup> </p><br><p> <sup>nocow —           (),      —           GlusterFS</sup> </p><br><p> <sup> Btrfs   ,     ,     FS,       <strong>Sheepdog</strong> .</sup> </p><br><ul><li> <sup>    ,   ,    ,      </sup> </li><li> <sup>  multipath,                         .</sup> </li></ul><br><p> <sup>,  ,        ,        Sheepdog.</sup> </p><br></li><li><p>  <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">↑</a></sup> <sup><a name="cite_note-6"></a> <strong>Ext2</strong> .     -  FS  Btrfs,    ext2,     inode.    ext3  ext4     .   inode , Sheepdog          . ,      -,   .           ,   <strong>Sheepdog</strong>      ,         <strong>dog vdi check</strong> . ,  ext2  ,            —    -     <strong>dog vdi md</strong> ,       VDI     .</sup> </p><br></li><li>  <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">↑</a></sup> <sup><a name="cite_note-7"></a>    ,   , <strong>vdi</strong>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">QEMU_Block_Disk</a></sup> </li></ol><br><h1 id="ssylki"> 参考文献 </h1><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/collie/sheepdog/wiki</a> — ,        <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http://www.osrg.net/sheepdog/</a> —    Nippon Telegraph and Telephone Corporation <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http://www.sheepdog-project.org/doc/index.html</a> —   Sheepdog   0.8.0;  — Valerio Pachera <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http://www.admin-magazine.com/Archive/2014/23/Distributed-storage-with-Sheepdog</a> —  Udo Seidela   <strong>Sheepdog</strong> ,   23-   Admin   2014  </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN412739/">https://habr.com/ru/post/zh-CN412739/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN412725/index.html">如何使您的IT基础架构变得无聊</a></li>
<li><a href="../zh-CN412727/index.html">如何选择2018年的原型制作工具？</a></li>
<li><a href="../zh-CN412729/index.html">GDPR。 有必要在俄罗斯表演吗？</a></li>
<li><a href="../zh-CN412735/index.html">在PHDays 8离开ATM Alone比赛</a></li>
<li><a href="../zh-CN412737/index.html">保护30亿人的个人数据-金砖国家的法律异同</a></li>
<li><a href="../zh-CN412741/index.html">如何停止担心人工智能会让您失业</a></li>
<li><a href="../zh-CN412743/index.html">职业：网络侦探</a></li>
<li><a href="../zh-CN412747/index.html">MIS。 医疗数据存储</a></li>
<li><a href="../zh-CN412749/index.html">电子艺术：电流</a></li>
<li><a href="../zh-CN412751/index.html">秃顶：治疗的理论与实践，第1部分“我的二氢睾丸激素，我的敌人”</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>