<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚öæÔ∏è üß§ üßñüèø RectTransformUtility, atau cara membuat komponen yang menjiwai elemen UI di belakang layar ü§öüèΩ üçá ‚öíÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel terakhir - Varietas koordinat yang digunakan dalam GUI Unity3d, saya mencoba untuk berbicara singkat tentang varietas koordinat di Unity...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RectTransformUtility, atau cara membuat komponen yang menjiwai elemen UI di belakang layar</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457142/">  Dalam artikel terakhir - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Varietas koordinat yang digunakan dalam GUI Unity3d,</a> saya mencoba untuk berbicara singkat tentang varietas koordinat di Unity UI / RectTransform.  Sekarang saya ingin menyoroti sedikit hal yang berguna untuk UI sebagai RectTransformUtility.  Yang merupakan salah satu alat utama untuk menghitung sesuatu di UI dalam kaitannya dengan sesuatu yang lain. <br><br><h3>  Tantangan sederhana </h3><br>  Ada tugas - Anda memerlukan komponen yang menghapus elemen UI secara animasi di luar tepi layar yang dipilih.  Komponen harus berwarna ungu di mana ia berada secara hierarkis, di tempat mana jangkar berada, ukuran layar apa, dan di mana tempat layar itu berada.  Komponen harus dapat membersihkan objek di 4 sisi (atas, bawah, kiri, kanan) untuk waktu tertentu. <br><a name="habracut"></a><br>  <b>Refleksi</b> <br><br>  Pada prinsipnya, bagaimana ini bisa dilakukan?  Cari tahu ukuran layar dalam koordinat objek, pindahkan objek ke koordinat di luar tepi layar, dan tampaknya masalahnya ada di topi.  Tapi ada beberapa tapi: <br><br>  <b>Bagaimana cara mengetahui koordinat layar relatif terhadap UI?</b> <br><br>  Jika Anda google di dahi, maka google beberapa hal yang tidak berguna atau tidak berguna, atau bahkan pertanyaan yang belum terjawab.  Hal terdekat yang cocok untuk Anda adalah ketika beberapa elemen UI mengikuti kursor, yang hanya ada di koordinat layar. <br><br><pre><code class="java hljs">RectTransformUtility.ScreenPointToLocalPointInRectangle(canvas, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(Input.mousePosition), <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, out topRightLocalCoord);</code> </pre> <br>  Ini adalah RectTransformUtility dan ScreenPointToLocalPointInRectangle secara langsung.  Di sini kita mendapatkan koordinat lokal di dalam kotak (RectTransform), berdasarkan posisi titik di layar. <br>  Dalam contoh saat ini, kami menemukan koordinat lokal kursor mouse, kami perlu menggantinya dengan tepi layar: <br><br><pre> <code class="java hljs">RectTransformUtility.ScreenPointToLocalPointInRectangle(canvas, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(Screen.width, Screen.height), <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, out topRightLocalCoord);</code> </pre> <br>  Dan jadi kami mendapat koordinat titik kanan atas layar sehingga objek meninggalkan layar ke kanan, objek kami harus lebih jauh dari titik ini + katakanlah lebar kotak atau inden yang ditentukan. <br><br>  <b>Jadi, peringatan pertama</b> <br><br>  Kami mendapat koordinat lokal yang cocok untuk objek langsung di dalam kanvas, jika sungai yang akan dipindahkan terletak di kotak lain, maka koordinat lokalnya akan dianggap relatif terhadap induknya, bukan kanvas.  Artinya, koordinat ini sendiri tidak cocok untuk kita. <br><br>  <b>Ada dua cara</b> , yang pertama adalah menggunakan koordinat global, untuk itu bersifat global.  Atau hitung koordinat layar dalam koordinat lokal setiap kotak secara terpisah. <br><br>  <b>Pertimbangkan kasus pertama</b> - bagaimana mengkonversi koordinat lokal ke global. <br><br>  Sebagian besar metode yang di-Google-go - TransformPoint <br><br><pre> <code class="java hljs">transform.position = myCanvas.transform.TransformPoint(pos);</code> </pre> <br>  Karenanya, kami mengonversi koordinat lokal ke global. <br><br>  Menurut pendapat saya, ini umumnya merupakan langkah ekstra, karena RectTransformUtility memiliki metode ScreenPointToWorldPointInRectangle yang segera mengembalikan posisi global. <br><br>  Kita perlu menggeser kotak di luar tepi kanan layar, untuk ini kita mengambil koordinat X dari posisi yang ditemukan, dan Y meninggalkan kotak yang kita pindahkan sehingga hanya bergerak ke kanan. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(topRightCoord.x+offset, rectTransform.position.y, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Koordinat yang dihasilkan diumpankan oleh DoTween. <br><br><pre> <code class="java hljs">rectTransform.DOMove(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(correctedTargetRight.x, rectTransform.position.y, <span class="hljs-number"><span class="hljs-number">0</span></span>), timeForHiding);</code> </pre> <br>  Dan hore, benda itu pergi ke kanan.  Tapi ... <br><br>  <b>Nuansa kedua</b> <br><br>  Di sini kita mengetahui bahwa sebenarnya posisi rect tergantung pada pivot rect. <br><br><img src="https://habrastorage.org/webt/bf/5p/6_/bf5p6_dcykozhdxi21bfc0y8lxi.png"><br><br>  Oleh karena itu, objek dapat menari dengan posisi tergantung pada pivot, ditambah objek bisa sangat besar dan offset tidak akan mendorongnya sepenuhnya di belakang layar, akan selalu ada kemungkinan potongan akan menonjol. <br><br>  Artinya, kita perlu mengacaukan kompensasi untuk offset yang akan memperhitungkan ukuran rect + pivot. <br><br>  Nuansa kedua adalah memindahkan objek dengan ukuran kotak, Anda harus tahu koordinat lokal atau jangkar, dan kami mendapatkan koordinat global.  Saya harus segera mengatakan bahwa koordinat global tidak dapat diambil dan dikonversi ke koordinat UI lokal, atau untuk anchor. <br>  Saya datang dengan kruk berikut, kita mengingat posisi awal dari persegi, memindahkannya ke posisi global akhir, menggeser posisi jangkar dengan ukuran persegi ke kanan, mengingat posisi global yang memperhitungkan offset, memperhitungkan ukuran objek, dan memberi makan dengan lubang, tidak lupa untuk kembali ke aslinya. posisi. <br><br><div class="spoiler">  <b class="spoiler_title">Contoh kode</b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> targetRight = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(topRightLocalCoord.x, rectTransform.position.y, <span class="hljs-number"><span class="hljs-number">0</span></span>); rectTransform.position = targetRight; rectTransform.anchoredPosition += rectTransform.sizeDelta; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> correctedTargetRight = rectTransform.position; rectTransform.localPosition = startPoint; rectTransform.DOMove(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(correctedTargetRight.x, rectTransform.position.y, <span class="hljs-number"><span class="hljs-number">0</span></span>), timeForHiding);</code> </pre> <br></div></div><br>  Ini terlihat seperti penopang raksasa, tetapi penopang ini memungkinkan Anda untuk menyinkronkan koordinat global dan lainnya.  Ini membantu ketika ada objek di antarmuka yang bergerak relatif satu sama lain, dan mereka berada di hierarki yang berbeda.  Yah, ditambah sejauh ini ini adalah satu-satunya cara yang saya temukan untuk mendapatkan koordinat persegi dari global. <br><br>  Pada titik ini, kita akan mengatakan tidak pada kruk, dan kembali ke ide mendapatkan ukuran layar dalam koordinat lokal. <br><br><h3>  Cara kedua </h3><br>  Cara kedua adalah untuk mendapatkan ukuran layar untuk setiap kotak secara individual, jadi kita akan tahu koordinat lokal dari tepi layar, terlepas dari kanvas atau hierarki. <br><br>  <b>Nuansa ketiga</b> <br><br><pre> <code class="java hljs">RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(Screen.width, Screen.height), <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, out topRightCoord); RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, out bottomScreenCoord);</code> </pre> <br>  Objek dapat ditemukan di mana saja di layar, tidak seperti kanvas yang menutupi seluruh layar.  Oleh karena itu, jarak ke tepi kiri dan kanan layar dapat berbeda secara signifikan.  Dalam kasus kanvas, kita hanya memiliki tepi kanan atas, dan minus kanan atas itu akan menjadi kiri atas.  Dalam hal ini, Anda perlu mendapatkan titik kiri bawah dan kanan atas secara terpisah, seperti yang ditunjukkan dalam contoh kode. <br><br>  <b>Nuansa keempat</b> <br><br>  Koordinat lokal adalah offset relatif terhadap pusat induk, ketika rect tertanam dalam rect lain, yang menempati sebagian kecil kanvas, maka kita membutuhkan koordinat yang memperhitungkan perpindahan, well, semuanya sederhana. <br><br><pre> <code class="java hljs">((Vector3)bottomLeftCoord + rectTransform.localPosition)</code> </pre> <br>  tambahkan vektor dan dapatkan koordinat yang kita butuhkan.  Ternyata lebih membingungkan daripada dengan koordinat global, tapi sekarang kita bisa melakukan perhitungan yang terkait dengan ukuran kotak.  Dan dengan tenang akhirnya menambahkan kompensasi tanpa kruk. <br><br><pre> <code class="java hljs"> (Vector3)topRightCoord + rectTransform.localPosition + (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3((rectTransform.sizeDelta.x * rectTransform.pivot.x) + rectTransform.sizeDelta.x, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre> <br>  Beginilah tampaknya koordinat untuk bergeser ke kanan dengan kompensasi untuk lebar kotak dan bergeser ke luar layar ke lebar kotak, tidak ada cara untuk mengatur offset, saya berencana untuk menambahkannya sedikit nanti, tapi saya pikir seseorang akan tertarik untuk mencoba menulis ini sendiri. <br><br><h2>  Kesimpulan </h2><br><ol><li>  Untuk elemen UI, lebih baik menggunakan koordinat lokal atau jangkar, dan Anda harus mencoba memahaminya.  Koordinat global dapat digunakan untuk kasus-kasus khusus, tetapi mereka tidak memungkinkan untuk bekerja dengan baik, misalnya, dengan ukuran rect dan dalam banyak episode mikro lainnya. </li><li>  Anda perlu melihat RectTransformUtility, ia memiliki banyak fungsi yang berguna untuk UI, semua perhitungan terkait dengan posisi sesuatu di dalam dan di sekitar persegi panjang dilakukan melaluinya. </li></ol><br>  Nah, komponen itu sendiri, jika ada yang ingin bermain dengannya, DoTween akan dibutuhkan untuk ini: <br><br><div class="spoiler">  <b class="spoiler_title">Komponen</b> <div class="spoiler_text"><pre> <code class="java hljs">using DG.Tweening; using UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Direction { DEFAULT, RIGHT, LEFT, TOP, BOTTOM } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CanvasType {OVERLAY, CAMERATYPE} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HideBeyondScreenComponent</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Direction direction; [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CanvasType canvasType; [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> timeForHiding = <span class="hljs-number"><span class="hljs-number">1</span></span>; [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> offset = <span class="hljs-number"><span class="hljs-number">50</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 startPoint; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> RectTransform rectTransform; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector2 topRightCoord; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector2 bottomLeftCoord; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ rectTransform = transform as RectTransform; startPoint = rectTransform.localPosition; Camera camera = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (canvasType == CanvasType.CAMERATYPE) camera = Camera.main; RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(Screen.width, Screen.height), camera, out topRightCoord); RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), camera, out bottomLeftCoord); Hide(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ rectTransform.DOLocalMove(startPoint, timeForHiding); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Hide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (direction) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Direction.LEFT: rectTransform.DOLocalMove(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(EndPosition(Direction.LEFT).x, rectTransform.localPosition.y, <span class="hljs-number"><span class="hljs-number">0</span></span>), timeForHiding); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Direction.RIGHT: rectTransform.DOLocalMove(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(EndPosition(Direction.RIGHT).x, rectTransform.localPosition.y, <span class="hljs-number"><span class="hljs-number">0</span></span>), timeForHiding); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Direction.TOP: rectTransform.DOLocalMove(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(rectTransform.localPosition.x, EndPosition(Direction.TOP).y, <span class="hljs-number"><span class="hljs-number">0</span></span>), timeForHiding); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Direction.BOTTOM: rectTransform.DOLocalMove(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(rectTransform.localPosition.x, EndPosition(Direction.BOTTOM).y, <span class="hljs-number"><span class="hljs-number">0</span></span>), timeForHiding); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NegativeCompensation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2((-rectTransform.sizeDelta.x - offset) + rectTransform.sizeDelta.x * rectTransform.pivot.x, (-rectTransform.sizeDelta.y - offset) + rectTransform.sizeDelta.y * rectTransform.pivot.y); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PositiveCompensation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2((rectTransform.sizeDelta.x * rectTransform.pivot.x) + offset, (rectTransform.sizeDelta.y * rectTransform.pivot.y) + offset); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Vector2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EndPosition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Direction direction)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (direction) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Direction.LEFT: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((Vector3)bottomLeftCoord + rectTransform.localPosition) + NegativeCompensation(); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Direction.RIGHT: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (Vector3)topRightCoord + rectTransform.localPosition + PositiveCompensation(); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Direction.TOP: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((Vector3)topRightCoord + rectTransform.localPosition) + PositiveCompensation(); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Direction.BOTTOM: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((Vector3)bottomLeftCoord + rectTransform.localPosition) + NegativeCompensation(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> startPoint; } }</code> </pre> <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id457142/">https://habr.com/ru/post/id457142/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id457132/index.html">Substitusi impor dalam praktek. Bagian 3.1. "QP OS". Ulasan pertama dari jenisnya tentang sistem operasi</a></li>
<li><a href="../id457134/index.html">Otak mempercepat persepsi, menebak apa yang akan terjadi selanjutnya</a></li>
<li><a href="../id457136/index.html">Faktor kunci dari Pemberdayaan Tim yang Sukses</a></li>
<li><a href="../id457138/index.html">Friday Post: Pertanyaan Cewek Cinta</a></li>
<li><a href="../id457140/index.html">Karena saya tidak sengaja menemukan kemungkinan penambahan akun tanpa akhir dengan operator seluler Amerika saya</a></li>
<li><a href="../id457144/index.html">Kami menulis emulator yang tidak diperlukan oleh siapa pun</a></li>
<li><a href="../id457150/index.html">Terminal Windows Baru Sekarang Tersedia di Microsoft Store</a></li>
<li><a href="../id457152/index.html">Konferensi DEFCON 25. Garry Kasparov. "Pertempuran terakhir otak." Bagian 1</a></li>
<li><a href="../id457154/index.html">Desain aplikasi responsif untuk setiap pengguna</a></li>
<li><a href="../id457156/index.html">Apa yang mungkin menjadi sistem komputasi masa depan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>