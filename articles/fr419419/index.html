<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🔬 🐢 🗃️ Auto-tests de l'interface utilisateur: comment le faire ne vaut pas la peine 🚴🏼 🐝 📽️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr. Je m'appelle Vitaliy Kotov, je travaille dans le service d'essais de Badoo. J'écris beaucoup d'autotests d'interface utilisateur, mais ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Auto-tests de l'interface utilisateur: comment le faire ne vaut pas la peine</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/419419/">  Bonjour, Habr.  Je m'appelle Vitaliy Kotov, je travaille dans le service d'essais de Badoo.  J'écris beaucoup d'autotests d'interface utilisateur, mais je travaille encore plus avec ceux qui l'ont fait il n'y a pas si longtemps et qui n'ont pas encore réussi à marcher sur tous les râteaux. <br><br>  Donc, après avoir ajouté ma propre expérience et les observations d'autres gars, j'ai décidé de préparer pour vous une collection de "comment écrire des tests ne vaut pas la peine".  J'ai pris en charge chaque exemple avec une description détaillée, des exemples de code et des captures d'écran. <br><br>  L'article sera intéressant pour les auteurs débutants de tests d'interface utilisateur, mais les personnes âgées dans ce sujet apprendront probablement quelque chose de nouveau, ou souriront tout simplement, en se souvenant «dans leur jeunesse».  :) <br><br>  C'est parti! <br><br><img width="651" src="https://habrastorage.org/webt/gn/un/vn/gnunvna-dpyr8dzj9gwsh-xinlm.jpeg"><br><br><a name="habracut"></a><br><h2>  Table des matières </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Localisateurs sans attributs</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Vérifier l'élément manquant</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rechercher un article</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Données aléatoires</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Atomicité des tests (partie 1)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Atomicité des tests (partie 2)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Erreur en cliquant sur un élément existant</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Texte d'erreur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Résumé</a> </li></ul><a name="locators"></a><br><h2>  Localisateurs sans attributs </h2><br>  Commençons par un exemple simple.  Puisque nous parlons de tests d'interface utilisateur, les localisateurs y jouent un rôle important.  Un localisateur est une ligne composée selon une certaine règle et décrivant un ou plusieurs éléments XML (en particulier HTML). <br><br>  Il existe plusieurs types de localisateurs.  Par exemple, les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">localisateurs CSS</a> sont utilisés pour les feuilles de style en cascade.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les localisateurs XPath</a> sont utilisés pour travailler avec des documents XML.  Et ainsi de suite. <br><br>  Une liste complète des types de localisateurs utilisés par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Selenium</a> peut être trouvée sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">seleniumhq.github.io</a> . <br><br>  Dans les tests d'interface utilisateur, les localisateurs sont utilisés pour décrire les éléments avec lesquels le pilote doit interagir. <br><br>  Dans presque n'importe quel inspecteur de navigateur, il est possible de sélectionner l'élément qui nous intéresse et de copier son XPath.  Cela ressemble à ceci: <br><br><img width="650" src="https://habrastorage.org/webt/mw/oi/fz/mwoifzz6ukpjltmexvq6sasxw2c.png"><br><br>  Il s'avère un tel localisateur: <br><br> <code>/html/body/div[3]/div[1]/div[2]/div/div/div[2]/div[1]/a <br></code> <br>  Il semble qu'il n'y ait rien de mal à un tel localisateur.  Après tout, nous pouvons le sauvegarder dans une constante ou un champ de la classe, qui, par son nom, transmettra l'essence de l'élément: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@FindBy</span></span>(xpath = <span class="hljs-string"><span class="hljs-string">"/html/body/div[3]/div[1]/div[2]/div/div/div[2]/div[1]/a"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> WebElement createAccountButton;</code> </pre><br>  Et enveloppez le texte d'erreur correspondant au cas où l'élément ne serait pas trouvé: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waitForCreateAccountButton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ By by = By.xpath(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.createAccountButton); WebDriverWait wait = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebDriverWait(driver, timeoutInSeconds); wait .withMessage(“Cannot find Create Account button.”) .until( ExpectedConditions.presenceOfElementLocated(by) ); }</code> </pre><br>  Cette approche a un avantage: il n'est pas nécessaire d'apprendre XPath. <br><br>  Cependant, il existe un certain nombre d'inconvénients.  Premièrement, lorsque vous changez la disposition, rien ne garantit que l'élément sur un tel localisateur restera le même.  Il est possible qu'un autre prenne sa place, ce qui entraînera des circonstances imprévues.  Deuxièmement, la tâche des autotests est de rechercher les bogues et non de surveiller les changements de disposition.  Par conséquent, l'ajout d'un wrapper ou d'autres éléments plus haut dans l'arborescence ne devrait pas affecter nos tests.  Sinon, il nous faudra beaucoup de temps pour mettre à jour les localisateurs. <br><br>  Conclusion: vous devez créer des localisateurs qui décrivent correctement l'élément et résistent aux changements de disposition en dehors de la partie testée de notre application.  Par exemple, vous pouvez vous lier à un ou plusieurs attributs d'un élément: <br><br> <code>//a[@rel=”createAccount”] <br></code> <br>  Un tel localisateur est plus facile à percevoir dans le code, et il ne se cassera que si "rel" disparaît. <br><br>  Un autre avantage d'un tel localisateur est la possibilité de rechercher dans le référentiel de modèles avec l'attribut spécifié.  Mais que rechercher si le localisateur ressemble à l'exemple d'origine?  :) <br><br>  Si initialement dans l'application, les éléments n'ont pas d'attributs ou s'ils sont définis automatiquement (par exemple, en raison de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">obscurcissement des</a> classes), cela vaut la peine d'être discuté avec les développeurs.  Ils ne devraient pas moins s'intéresser à l'automatisation des tests de produits et vous rencontreront sûrement et vous proposeront une solution. <br><a name="no_element"></a><br><h2>  Vérifier l'élément manquant </h2><br>  Chaque utilisateur Badoo a son propre profil.  Il contient des informations sur l'utilisateur: (nom, âge, photos) et des informations sur qui l'utilisateur souhaite discuter.  De plus, il est possible d'indiquer vos intérêts. <br><br>  Supposons que nous ayons eu une fois un bug (bien que, bien sûr, ce ne soit pas le cas :)).  L'utilisateur de son profil a choisi ses centres d'intérêt.  Ne trouvant pas d'intérêt approprié dans la liste, il a décidé de cliquer sur «Plus» pour mettre à jour la liste. <br><br>  Comportement attendu: les anciens intérêts devraient disparaître, de nouveaux devraient apparaître.  Mais à la place, une «erreur inattendue» est apparue: <br><br><img width="550" src="https://habrastorage.org/webt/tz/fp/lt/tzfpltsr9rkjpk-qtmoj4ustqjc.png"><br><br>  Il s'est avéré qu'il y avait un problème côté serveur, la réponse n'était pas la même et le client a traité ce problème en affichant une notification. <br><br>  Notre tâche est d'écrire un autotest qui vérifiera ce cas. <br><br>  Nous écrivons approximativement le script suivant: <br><br><ul><li>  Ouvrir le profil </li><li>  Ouvrir la liste des intérêts </li><li>  Cliquez sur le bouton "Plus" </li><li>  Assurez-vous que l'erreur ne s'est pas produite (par exemple, il n'y a pas d'élément div.error) </li></ul><br>  Nous effectuons un tel test.  Cependant, ce qui suit se produit: après quelques jours / mois / années, le bogue réapparaît, bien que le test ne détecte rien.  Pourquoi? <br><br>  Tout est assez simple: lors de la réussite du test, le localisateur de l'élément par lequel nous avons recherché le texte d'erreur a changé.  Il y a eu une refactorisation des modèles et au lieu de la classe "error" nous avons eu la classe "error_new". <br><br>  Pendant le refactoring, le test a continué de fonctionner comme prévu.  L'élément div.error n'apparaissait pas; il n'y avait aucune raison de la chute.  Mais maintenant, l'élément "div.error" n'existe plus du tout - par conséquent, le test n'échouera jamais, quoi qu'il arrive dans l'application. <br><br>  Conclusion: il vaut mieux tester l'opérabilité de l'interface avec des contrôles positifs.  Dans notre exemple, nous devons nous attendre à ce que la liste des intérêts ait changé. <br><br>  Dans certains cas, un test négatif ne peut pas être remplacé par un test positif.  Par exemple, lors de l'interaction avec un élément, rien ne se passe dans une «bonne» situation et une erreur apparaît dans une «mauvaise» situation.  Dans ce cas, vous devriez trouver un moyen de simuler un «mauvais» scénario et d'y écrire également un autotest.  Ainsi, nous vérifions que l'élément d'erreur apparaît dans le cas négatif et surveillons ainsi la pertinence du localisateur. <br><a name="element_exists"></a><br><h2>  Rechercher un article </h2><br>  Comment s'assurer que l'interaction de test avec l'interface a réussi et que tout fonctionne?  Cela se voit le plus souvent dans les changements survenus dans cette interface. <br><br>  Prenons un exemple.  Vous devez vous assurer que lors de l'envoi d'un message, il apparaît dans le chat: <br><br><img width="350" src="https://habrastorage.org/webt/ac/uy/ww/acuywwe6rttek93vzdcf0n66th4.png"><br><br>  Le script ressemble à ceci: <br><br><ul><li>  Ouvrir le profil utilisateur </li><li>  Ouvrez le chat avec lui </li><li>  Rédiger un message </li><li>  Soumettre </li><li>  Attendez que le message apparaisse. </li></ul><br>  Nous décrivons un tel scénario dans notre test.  Supposons qu'un message de discussion correspond à un localisateur: <br><br> <code>p.message_text <br></code> <br>  Voici comment nous vérifions que l'élément apparaît: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.waitForPresence(By.css(<span class="hljs-string"><span class="hljs-string">'p.message_text'</span></span>), <span class="hljs-string"><span class="hljs-string">"Cannot find sent message."</span></span>);</code> </pre><br>  Si notre attente fonctionne, alors tout est en ordre: les messages de chat sont dessinés. <br><br>  Comme vous l'avez peut-être deviné, après un certain temps, l'envoi de messages de discussion est interrompu, mais notre test continue de fonctionner sans interruption.  Faisons les choses correctement. <br><br>  Il s'avère que la veille un nouvel élément est apparu dans le chat: du texte qui invite l'utilisateur à mettre en évidence le message s'il passe soudainement inaperçu: <br><br><img width="550" src="https://habrastorage.org/webt/ie/yc/82/ieyc82alpp-8kcoblkwyvup60my.png"><br><br>  Et, le plus drôle, il relève également de notre localisateur.  Seulement, il a une classe supplémentaire qui le distingue des messages envoyés: <br><br> <code>p.message_text.highlight <br></code> <br>  Notre test n'a pas cassé lorsque ce bloc est apparu, mais la case «attendre que le message apparaisse» a cessé d'être pertinente.  L'élément qui était un indicateur d'un événement réussi est maintenant toujours là. <br><br>  Conclusion: si la logique du test est basée sur la vérification de l'apparence d'un élément, il est nécessaire de vérifier qu'il n'y en a pas avant notre interaction avec l'interface utilisateur. <br><br><ul><li>  Ouvrir le profil utilisateur </li><li>  Ouvrez le chat avec lui </li><li>  <b>Assurez-vous qu'aucun message n'a été envoyé</b> </li><li>  Rédiger un message </li><li>  Soumettre </li><li>  Attendez que le message apparaisse. </li></ul><br><a name="random_data"></a><h2>  Données aléatoires </h2><br>  Très souvent, les tests d'interface utilisateur fonctionnent avec des formulaires dans lesquels ils saisissent des données.  Par exemple, nous avons un formulaire d'inscription: <br><br><img width="550" src="https://habrastorage.org/webt/dd/gv/z2/ddgvz2ss4i8juyv7c5jrgqahd84.png"><br><br>  Les données de ces tests peuvent être stockées dans des configurations ou codées en dur dans un test.  Mais parfois, la pensée vient à l'esprit: pourquoi ne pas randomiser les données?  C'est bien, nous couvrirons plus de cas! <br><br>  Mon conseil: non.  Et maintenant je vais vous dire pourquoi. <br><br>  Supposons que notre test soit enregistré sur Badoo.  Nous décidons de choisir au hasard le sexe de l'utilisateur.  Au moment de la rédaction du test, le flux d'inscription pour la fille et pour le garçon n'est pas différent, donc notre test réussit. <br><br>  Imaginez maintenant qu'après un certain temps, le flux d'enregistrement devient différent.  Par exemple, nous donnons à la fille des bonus gratuits immédiatement après l'inscription, à propos desquels nous lui notifions une superposition spéciale. <br><br>  Dans le test, il n'y a pas de logique pour fermer la superposition, mais cela, à son tour, interfère avec toutes les autres actions prescrites dans le test.  Nous obtenons un test qui tombe dans 50% des cas.  Tout outil d'automatisation confirmera que les tests d'interface utilisateur ne sont pas intrinsèquement stables par nature.  Et c'est normal, il faut vivre avec, en plaçant constamment entre une logique redondante "pour toutes les occasions" (qui gâche sensiblement la lisibilité du code et complique son support) et cette instabilité elle-même. <br><br>  La prochaine fois, lorsque le test échouera, nous n'aurons peut-être pas le temps de le gérer.  Nous venons de le redémarrer et voyons qu'il est passé.  Nous décidons que dans notre application tout fonctionne comme il se doit et la chose est un test instable.  Et calme-toi. <br><br>  Passons maintenant.  Et si cette superposition se brise?  Le test continuera de réussir dans 50% des cas, ce qui retarde considérablement la recherche du problème. <br><br>  Et c'est bien quand, en raison de la randomisation des données, nous créons une situation "50 par 50".  Mais cela se passe différemment.  Par exemple, avant de vous inscrire, un mot de passe était considéré comme acceptable sur au moins trois caractères.  Nous écrivons du code qui propose un mot de passe aléatoire d'au moins trois caractères (parfois trois caractères et parfois plus).  Et puis la règle change - et le mot de passe doit déjà contenir au moins quatre caractères.  Quelle est la probabilité d'une chute dans ce cas?  Et, si notre test détecte un vrai bug, à quelle vitesse le découvrirons-nous? <br><br>  Il est particulièrement difficile de travailler avec des tests où de nombreuses données aléatoires sont entrées: nom, sexe, mot de passe, etc. Dans ce cas, il existe également de nombreuses combinaisons différentes, et si une erreur se produit dans l'une d'entre elles, il est généralement difficile de la remarquer. <br><br>  Conclusion  Comme je l'ai écrit ci-dessus, la randomisation des données est mauvaise.  Il vaut mieux couvrir plus de cas aux dépens des fournisseurs de données, sans oublier bien sûr les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">classes d'équivalence</a> .  La réussite des tests prendra plus de temps, mais vous pouvez le combattre.  Mais nous serons sûrs que s'il y a un problème, il sera détecté. <br><a name="atom_tests_1"></a><br><h2>  Atomicité des tests (partie 1) </h2><br>  Regardons l'exemple suivant.  Nous écrivons un test qui vérifie le compteur d'utilisateurs dans le pied de page. <br><br><img width="651" src="https://habrastorage.org/webt/9j/n4/ws/9jn4wsd3jlh_wdnoiwrkjdfho9s.png"><br><br>  Le scénario est simple: <br><br><ul><li>  Ouvrir l'application </li><li>  Trouver le compteur de pied de page </li><li>  Assurez-vous qu'il est visible </li></ul><br>  Nous appelons un tel test testFooterCounter et l'exécutons.  Il devient alors nécessaire de vérifier que le compteur n'affiche pas zéro.  Nous ajoutons ce test à un test existant, pourquoi pas? <br><br>  Mais alors il devient nécessaire de vérifier que dans le pied de page il y a un lien vers la description du projet (le lien "A propos de nous").  Ecrire un nouveau test ou ajouter à un test existant?  Dans le cas d'un nouveau test, nous devrons relancer l'application, préparer l'utilisateur (si nous vérifions le pied de page sur la page autorisée), se connecter - en général, passer un temps précieux.  Dans une telle situation, renommer le test en testFooterCounterAndLinks semble être une bonne idée. <br><br>  D'une part, cette approche présente des avantages: gain de temps, stockage de tous les chèques d'une partie de notre application (en l'occurrence, le pied de page) en un seul endroit. <br><br>  Mais il y a un inconvénient notable.  Si le test échoue lors du premier test, nous ne vérifierons pas le reste du composant.  Supposons qu'un test se bloque dans une branche, non pas à cause de l'instabilité, mais à cause d'un bogue.  Que faire  Renvoyer une tâche décrivant uniquement ce problème?  Ensuite, nous courons le risque d'obtenir une tâche avec un correctif de ce bogue uniquement, exécutons un test et découvrons que le composant est également cassé plus loin, dans un autre endroit.  Et il peut y avoir de nombreuses itérations de ce type.  Dans ce cas, donner un coup de pied dans les deux sens prendra beaucoup de temps et sera inefficace. <br><br>  Conclusion: si possible, atomisez les chèques.  Dans ce cas, même en cas de problème dans un cas, nous vérifierons tous les autres.  Et, si vous devez retourner le billet, nous pouvons immédiatement décrire tous les problèmes. <br><a name="atom_tests_2"></a><br><h2>  Atomicité des tests (partie 2) </h2><br>  Prenons un autre exemple.  Nous écrivons un test de chat qui vérifie la logique suivante.  Si les utilisateurs ont une sympathie mutuelle, le promoblock suivant apparaît dans le chat: <br><br><img width="550" src="https://habrastorage.org/webt/2o/v8/kp/2ov8kp9mojel1g_txzatwy91nig.png"><br><br>  Le scénario est le suivant: <br><br><ul><li>  Voter par l'utilisateur A pour l'utilisateur B </li><li>  Voter par l'utilisateur B pour l'utilisateur A </li><li>  Utilisateur A chat ouvert avec l'utilisateur B </li><li>  Confirmez que l'unité est en place </li></ul><br>  Pendant un certain temps, le test fonctionne avec succès, mais ensuite ce qui se passe ... Non, cette fois, le test ne manque aucun bug.  :) <br><br>  Après un certain temps, nous découvrons qu'il existe un autre bug non lié à notre test: si vous ouvrez un chat, fermez-le immédiatement et rouvrez-le, le bloc disparaît.  Ce n'est pas le cas le plus évident, et dans le test, nous ne l'avons bien sûr pas prévu.  Mais nous décidons que nous devons également le couvrir. <br><br>  La même question se pose: écrire un autre test ou insérer un test dans un test existant?  En écrire un nouveau semble inapproprié, car dans 99% des cas, il fera de même que l'existant.  Et nous décidons d'ajouter le test au test qui existe déjà: <br><br><ul><li>  Voter par l'utilisateur A pour l'utilisateur B </li><li>  Voter par l'utilisateur B pour l'utilisateur A </li><li>  Utilisateur A chat ouvert avec l'utilisateur B </li><li>  Confirmez que l'unité est en place </li><li>  <b>Fermer le chat</b> </li><li>  <b>Ouvrir le chat</b> </li><li>  Confirmez que l'unité est en place </li></ul><br>  Un problème peut survenir lorsque, par exemple, nous refactorisons un test après une longue période.  Par exemple, une refonte se produira sur un projet - et vous devrez réécrire de nombreux tests. <br><br>  Nous allons ouvrir le test et essayer de nous souvenir de ce qu'il vérifie.  Par exemple, un test est appelé testPromoAfterMutualAttraction.  Comprenons-nous pourquoi l'ouverture et la fermeture du chat sont écrites à la fin?  Probablement pas.  Surtout si ce test n'a pas été écrit par nous.  Allons-nous laisser cette pièce?  Peut-être que oui, mais s'il y a des problèmes avec lui, il est probable que nous le supprimerons simplement.  Et la vérification sera perdue simplement parce que sa signification ne sera pas évidente. <br><br>  Je vois deux solutions ici.  Premièrement: faites toujours le deuxième test et appelez-le testCheckBlockPresentAfterOpenAndCloseChat.  Avec un tel nom, il sera clair que nous ne faisons pas seulement un certain ensemble d'actions, mais faisons un contrôle très conscient, car il y a eu une expérience négative.  La deuxième solution consiste à écrire un commentaire détaillé dans le code expliquant pourquoi nous effectuons ce test dans ce test particulier.  Il est également conseillé d'indiquer le numéro de bug dans le commentaire. <br><a name="click_error"></a><br><h2>  Erreur en cliquant sur un élément existant </h2><br>  L'exemple suivant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">m'a</a> lancé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">bbidox</a> , pour lequel il est un gros plus en karma! <br><br>  Il y a une situation très intéressante où le code de test devient déjà ... un framework.  Supposons que nous ayons une méthode comme celle-ci: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clickSomeButton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ WebElement button_element = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.waitForButtonToAppear(); button_element.click(); }</code> </pre><br>  À un moment donné, quelque chose d'étrange commence à arriver à cette méthode: le test se bloque lorsque vous essayez de cliquer sur un bouton.  Nous ouvrons la capture d'écran prise au moment où le test s'est écrasé, et nous voyons qu'il y a un bouton dans la capture d'écran et que la méthode waitForButtonToAppear a fonctionné avec succès.  Question: quel est le problème avec le clic? <br><br>  Le plus dur dans cette situation est que le test peut parfois réussir.  :) <br><br>  Faisons les choses correctement.  Supposons que le bouton considéré dans l'exemple se trouve sur une telle superposition: <br><br><img width="550" src="https://habrastorage.org/webt/pe/77/bd/pe77bddhspi2hdw1eagnzk8iydm.png"><br><br>  Il s'agit d'une superposition spéciale à travers laquelle un utilisateur de notre site Web peut remplir des informations sur lui-même.  Lorsque vous cliquez sur le bouton de superposition en surbrillance, le bloc suivant apparaît à remplir. <br><br>  Pour le plaisir, ajoutons une classe OLOLO supplémentaire pour ce bouton: <br><br><img width="550" src="https://habrastorage.org/webt/ul/qv/fj/ulqvfjphig982sp-ntzfcmwdc0q.png"><br><br>  Après quoi, nous cliquons sur ce bouton.  Visuellement, rien n'a changé, mais le bouton lui-même est resté en place: <br><br><img width="550" src="https://habrastorage.org/webt/86/os/3x/86os3xs2ycobeqm75psth6xuidk.png"><br><br>  Que s'est-il passé?  En fait, lorsque JS a redessiné le bloc pour nous, il a également redessiné le bouton.  Il est toujours disponible sur le même localisateur, mais c'est un autre bouton.  Cela est démontré par le manque de la classe OLOLO que nous avons ajoutée. <br><br>  Dans le code ci-dessus, nous stockons l'élément dans la variable $ element.  Si un élément est régénéré pendant ce temps, il peut ne pas être visible visuellement, mais vous ne pouvez plus cliquer dessus - la méthode click () échouera. <br><br>  Il existe plusieurs solutions: <br><br><ul><li>  Wrap click dans le bloc try et dans l'élément catch rebuild </li><li>  Ajouter un bouton à un attribut pour signaler qu'il a changé </li></ul><br><a name="error_message"></a><h2>  Texte d'erreur </h2><br>  Enfin, un point simple, mais non moins important. <br><br>  Cet exemple s'applique non seulement aux tests d'interface utilisateur, mais se produit également très souvent dans ceux-ci.  Habituellement, lorsque vous écrivez un test, vous êtes dans le contexte de ce qui se passe: vous décrivez la vérification après la vérification et comprenez leur signification.  Et vous écrivez des textes d'erreur dans le même contexte: <br><br><pre> <code class="java hljs">WebElement element = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.waitForPresence(By.css(<span class="hljs-string"><span class="hljs-string">"a.link"</span></span>), <span class="hljs-string"><span class="hljs-string">"Cannot find button"</span></span>);</code> </pre><br>  Qu'est-ce qui pourrait être incompréhensible dans ce code?  Le test s'attend à l'apparition d'un bouton et, s'il n'est pas là, tombe naturellement. <br><br>  Imaginez maintenant que l'auteur du test soit en arrêt maladie et que son collègue s'occupe des tests.  Et puis il abandonne le test testQuestionsOnProfile et écrit ce message: «Bouton introuvable».  Un collègue doit comprendre ce qui se passe le plus rapidement possible, car la sortie arrive bientôt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ba/pe/dv/bapedvs1g2gplrhebyipl0p7cl0.gif"></div><br><br>  Que devra-t-il faire? <br><br>  Il est inutile d'ouvrir la page sur laquelle le test est tombé et de vérifier le localisateur "a.link" - il n'y a aucun élément.  Par conséquent, vous devez étudier attentivement le test et déterminer ce qu'il vérifie. <br><br>  Ce serait beaucoup plus simple avec un texte d'erreur plus détaillé: «Impossible de trouver le bouton d'envoi sur la superposition de questions».  Avec une telle erreur, vous pouvez immédiatement ouvrir la superposition et voir où le bouton est allé. <br><br>  Sortie deux.  Tout d'abord, il vaut la peine de transmettre le texte d'erreur à n'importe quelle méthode de votre framework de test, en plus, un paramètre obligatoire pour qu'il n'y ait pas de tentation de l'oublier.  Deuxièmement, le texte d'erreur doit être détaillé.  Cela ne signifie pas toujours que cela devrait être long, il suffit de préciser ce qui a mal tourné dans le test. <br><br>  Comment comprendre que le texte d'erreur est bien écrit?  Très simple.  Imaginez que votre application soit en panne et que vous deviez aller voir les développeurs et expliquer quoi et où s'est cassé.  Si vous leur dites seulement ce qui est écrit dans le texte d'erreur, comprendront-ils? <br><a name="summary"></a><br><h2>  Résumé </h2><br>  La rédaction d'un script de test est souvent une activité intéressante.  Dans le même temps, nous poursuivons de nombreux objectifs.  Nos tests doivent: <br><br><ul><li>  couvrir autant de cas que possible </li><li>  travailler aussi vite que possible </li><li>  être compris </li><li>  élargir </li><li>  facile à entretenir </li><li>  commander une pizza </li><li>  et ainsi de suite ... </li></ul><br>  Il est particulièrement intéressant de travailler avec des tests dans un projet en constante évolution, où ils doivent être constamment mis à jour: ajouter quelque chose et couper quelque chose.  C'est pourquoi il vaut la peine de réfléchir à l'avance sur certains points et de ne pas toujours se précipiter avec les décisions.  :) <br><br>  J'espère que mes conseils vous aideront à éviter certains problèmes et vous rendront plus réfléchi dans les études de cas.  Si le public aime l'article, je vais essayer de collecter des exemples plus ennuyeux.  En attendant - au revoir! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr419419/">https://habr.com/ru/post/fr419419/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr419409/index.html">Nouveaux NUC Intel basés sur les processeurs Coffee Lake</a></li>
<li><a href="../fr419411/index.html">À propos du feu dans un gratte-ciel. Cinéma et réalité</a></li>
<li><a href="../fr419413/index.html">Chisel - (pas tout à fait) une nouvelle approche du développement de la logique numérique</a></li>
<li><a href="../fr419415/index.html">Mattermost et Powershell - une puissance énorme ou une petite automatisation à la maison</a></li>
<li><a href="../fr419417/index.html">RGPD: cartographie des données ou comment les clients trouvent des ordinateurs portables oubliés depuis longtemps</a></li>
<li><a href="../fr419423/index.html">On nous promet une vidéo en temps réel sans frises ni secousses</a></li>
<li><a href="../fr419425/index.html">Semaine de la sécurité 29. Hacking Reddit, un portefeuille pour les routeurs de crypto-monnaie et MikroTik</a></li>
<li><a href="../fr419427/index.html">Epson invite tout le monde au pique-nique des geeks 2018</a></li>
<li><a href="../fr419429/index.html">J'ai 57 ans et je suis un scrum master</a></li>
<li><a href="../fr419431/index.html">Année avec Scrum ou voies de développement professionnel des développeurs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>