<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêÜ üë©üèΩ‚Äçüè´ üë®üèΩ‚Äçüç≥ SQL Index Manager - uma ferramenta gratuita para desfragmentar e manter √≠ndices ü§¥üèø üö∂üèø üñ≤Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Por muitos anos trabalhando como DBA do SQL Server, administrando servidores e otimizando o desempenho. Em geral, eu queria fazer algo √∫til no meu tem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SQL Index Manager - uma ferramenta gratuita para desfragmentar e manter √≠ndices</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459914/">  Por muitos anos trabalhando como DBA do SQL Server, administrando servidores e otimizando o desempenho.  Em geral, eu queria fazer algo √∫til no meu tempo livre para o Universo e nossos colegas.  Portanto, no final, temos uma pequena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ferramenta de</a> manuten√ß√£o de √≠ndice de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">c√≥digo aberto</a> para o SQL Server e o Azure. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/546/8b0/98e/5468b098eea90eb287427b56021c6962.png" alt="Gerenciador de √çndice SQL"><br><br><a name="habracut"></a><h3>  Id√©ia </h3><br>  √Äs vezes, ao trabalhar em suas prioridades, as pessoas podem se parecer com uma bateria do tipo dedo - h√° carga de motiva√ß√£o suficiente para apenas um flash, e √© isso.  E at√© recentemente, eu n√£o era exce√ß√£o a essa observa√ß√£o da vida.  Muitas vezes, fui visitado por id√©ias para criar algo pr√≥prio, mas as prioridades mudaram e nada foi levado ao fim. <br><br>  Uma influ√™ncia bastante forte sobre minha motiva√ß√£o e desenvolvimento profissional foi fornecida pelo trabalho na empresa Devart, de Kharkov, que se dedicou √† cria√ß√£o de software para o desenvolvimento e administra√ß√£o de bancos de dados SQL Server, MySQL e Oracle. <br><br>  Antes de chegar a eles, eu tinha pouca id√©ia das especificidades de criar meu pr√≥prio produto, mas j√° no processo, adquiri muito conhecimento sobre a estrutura interna do SQL Server.  Tendo otimizado as solicita√ß√µes de metadados em suas linhas de produtos h√° mais de um ano, gradualmente comecei a entender qual funcionalidade √© mais requisitada no mercado do que qualquer outra. <br><br>  Em um certo est√°gio, surgiu a id√©ia de criar um novo produto de nicho, mas, devido √†s circunst√¢ncias, ela n√£o decolou.  Naquela √©poca, para o novo projeto, n√£o havia recursos livres suficientes suficientes na empresa sem comprometer o neg√≥cio principal. <br><br>  J√° quando ele trabalhava em um novo local e tentava fazer o projeto por conta pr√≥pria, tinha que fazer alguns compromissos constantemente.  A id√©ia inicial de tornar um produto grande e cheio de recursos rapidamente se transformou em uma dire√ß√£o diferente - para dividir a funcionalidade planejada em mini-ferramentas separadas e implement√°-las independentemente uma da outra. <br><br>  Como resultado, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><b>SQL Index Manager</b></a> nasceu - uma ferramenta gratuita de manuten√ß√£o de √≠ndice para o SQL Server e o Azure.  A id√©ia principal era tomar como base alternativas comerciais da RedGate e Devart e tentar melhorar sua funcionalidade.  Fornecer, para usu√°rios iniciantes e experientes, a capacidade de analisar e manter convenientemente √≠ndices. <br><br><h3>  Implementa√ß√£o </h3><br>  Em palavras, tudo sempre parece simples ... Peguei um e olhei para alguns vidosiks motivadores, fiquei na prateleira e comecei a fazer um produto legal.  Mas, na pr√°tica, nem tudo √© t√£o f√°cil, pois existem muitas armadilhas ao trabalhar com a fun√ß√£o de tabela do sistema sys.dm_db_index_physical_stats e, em combina√ß√£o, o √∫nico local de onde voc√™ pode obter informa√ß√µes relevantes sobre a fragmenta√ß√£o do √≠ndice. <br><br>  Desde os primeiros dias de desenvolvimento, houve uma grande oportunidade de criar um caminho sombrio entre os esquemas padr√£o e copiar a l√≥gica j√° depurada do trabalho dos aplicativos concorrentes, acrescentando um pouco de piada.  Mas, depois de analisar as solicita√ß√µes de metadados, eu queria fazer algo mais otimizado, que, devido √† burocracia das grandes empresas, nunca teria aparecido em seus produtos. <br><br>  Ao analisar o RedGate SQL Index Manager (1.1.9.1378 - $ 155), voc√™ pode ver que o aplicativo usa uma abordagem muito simples: com uma consulta, obtemos uma lista de tabelas e visualiza√ß√µes do usu√°rio e, ap√≥s a segunda consulta, uma lista de todos os √≠ndices no banco de dados selecionado √© retornada. <br><br><pre><code class="1c hljs">SELECT objects.name AS tableOrViewName , objects.object_id AS tableOrViewId , schemas.name AS schemaName , CAST(ISNULL(lobs.NumLobs, <span class="hljs-number"><span class="hljs-number">0</span></span>) AS BIT) AS ContainsLobs , o.is_memory_optimized FROM sys.objects AS objects JOIN sys.schemas AS schemas ON schemas.schema_id = objects.schema_id LEFT JOIN ( SELECT object_id , COUNT(*) AS NumLobs FROM sys.columns WITH (NOLOCK) WHERE system_type_id IN (<span class="hljs-number"><span class="hljs-number">34</span></span>, <span class="hljs-number"><span class="hljs-number">35</span></span>, <span class="hljs-number"><span class="hljs-number">99</span></span>) OR max_length = -<span class="hljs-number"><span class="hljs-number">1</span></span> GROUP BY object_id ) AS lobs ON objects.object_id = lobs.object_id LEFT JOIN sys.tables AS o ON o.object_id = objects.object_id WHERE objects.type = 'U' OR objects.type = 'V' SELECT i.object_id AS tableOrViewId , i.name AS indexName , i.index_id AS indexId , i.allow_page_locks AS allowPageLocks , p.partition_number AS partitionNumber , CAST((c.numPartitions - <span class="hljs-number"><span class="hljs-number">1</span></span>) AS BIT) AS belongsToPartitionedIndex FROM sys.indexes AS i JOIN sys.partitions AS p ON p.index_id = i.index_id AND p.object_id = i.object_id JOIN ( SELECT COUNT(*) AS numPartitions , object_id , index_id FROM sys.partitions GROUP BY object_id , index_id ) AS c ON c.index_id = i.index_id AND c.object_id = i.object_id WHERE i.index_id &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> -- ignore heaps AND i.is_disabled = <span class="hljs-number"><span class="hljs-number">0</span></span> AND i.is_hypothetical = <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Em um ciclo, para cada se√ß√£o do √≠ndice, uma solicita√ß√£o √© enviada para determinar seu tamanho e n√≠vel de fragmenta√ß√£o.  No final da varredura, os √≠ndices que pesam menos que o limite de entrada s√£o descartados no cliente. <br><br><pre> <code class="1c hljs">EXEC sp_executesql N' SELECT index_id, avg_fragmentation_in_percent, page_count FROM sys.dm_db_index_physical_stats(@databaseId, @objectId, @indexId, @partitionNr, NULL)' , N'@databaseId int,@objectId int,@indexId int,@partitionNr int' , @databaseId = <span class="hljs-number"><span class="hljs-number">7</span></span>, @objectId = <span class="hljs-number"><span class="hljs-number">2133582639</span></span>, @indexId = <span class="hljs-number"><span class="hljs-number">1</span></span>, @partitionNr = <span class="hljs-number"><span class="hljs-number">1</span></span> EXEC sp_executesql N' SELECT index_id, avg_fragmentation_in_percent, page_count FROM sys.dm_db_index_physical_stats(@databaseId, @objectId, @indexId, @partitionNr, NULL)' , N'@databaseId int,@objectId int,@indexId int,@partitionNr int' , @databaseId = <span class="hljs-number"><span class="hljs-number">7</span></span>, @objectId = <span class="hljs-number"><span class="hljs-number">2133582639</span></span>, @indexId = <span class="hljs-number"><span class="hljs-number">2</span></span>, @partitionNr = <span class="hljs-number"><span class="hljs-number">1</span></span> EXEC sp_executesql N' SELECT index_id, avg_fragmentation_in_percent, page_count FROM sys.dm_db_index_physical_stats(@databaseId, @objectId, @indexId, @partitionNr, NULL)' , N'@databaseId int,@objectId int,@indexId int,@partitionNr int' , @databaseId = <span class="hljs-number"><span class="hljs-number">7</span></span>, @objectId = <span class="hljs-number"><span class="hljs-number">2133582639</span></span>, @indexId = <span class="hljs-number"><span class="hljs-number">3</span></span>, @partitionNr = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Ao analisar a l√≥gica desta aplica√ß√£o, voc√™ pode encontrar muitas defici√™ncias.  Por exemplo, se voc√™ encontrar falhas nas ninharias, antes de enviar uma solicita√ß√£o, nenhuma verifica√ß√£o ser√° feita sobre se a se√ß√£o atual cont√©m seq√º√™ncias de caracteres para excluir se√ß√µes vazias da varredura. <br><br>  Mas o problema √© mais grave em outro aspecto: o n√∫mero de solicita√ß√µes do servidor ser√° aproximadamente igual ao n√∫mero total de linhas de sys.partitions.  Dado o fato de que bancos de dados reais podem conter dezenas de milhares de se√ß√µes, essa nuance pode levar a um grande n√∫mero de solicita√ß√µes semelhantes ao servidor.  Em uma situa√ß√£o em que o banco de dados √© remoto, o tempo de varredura se tornar√° ainda maior devido ao aumento de atrasos na rede para cada solicita√ß√£o, mesmo a mais simples. <br><br>  Diferentemente do RedGate, um produto similar desenvolvido no Devart - o dbForge Index Manager para SQL Server (1.10.38 - $ 99) recebe informa√ß√µes em uma consulta grande e exibe tudo no cliente: <br><br><pre> <code class="1c hljs">SELECT SCHEMA_NAME(o.[schema_id]) AS [schema_name] , o.name AS parent_name , o.[type] AS parent_type , i.name , i.type_desc , s.avg_fragmentation_in_percent , s.page_count , p.partition_number , p.[rows] , ISNULL(lob.is_lob_legacy, <span class="hljs-number"><span class="hljs-number">0</span></span>) AS is_lob_legacy , ISNULL(lob.is_lob, <span class="hljs-number"><span class="hljs-number">0</span></span>) AS is_lob , CASE WHEN ds.[type] = 'PS' THEN <span class="hljs-number"><span class="hljs-number">1</span></span> ELSE <span class="hljs-number"><span class="hljs-number">0</span></span> END AS is_partitioned FROM sys.dm_db_index_physical_stats(DB_ID(), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) s JOIN sys.partitions p ON s.[object_id] = p.[object_id] AND s.index_id = p.index_id AND s.partition_number = p.partition_number JOIN sys.indexes i ON i.[object_id] = s.[object_id] AND i.index_id = s.index_id LEFT JOIN ( SELECT c.[object_id] , index_id = ISNULL(i.index_id, <span class="hljs-number"><span class="hljs-number">1</span></span>) , is_lob_legacy = MAX(CASE WHEN c.system_type_id IN (<span class="hljs-number"><span class="hljs-number">34</span></span>, <span class="hljs-number"><span class="hljs-number">35</span></span>, <span class="hljs-number"><span class="hljs-number">99</span></span>) THEN <span class="hljs-number"><span class="hljs-number">1</span></span> END) , is_lob = MAX(CASE WHEN c.max_length = -<span class="hljs-number"><span class="hljs-number">1</span></span> THEN <span class="hljs-number"><span class="hljs-number">1</span></span> END) FROM sys.columns c LEFT JOIN sys.index_columns i ON c.[object_id] = i.[object_id] AND c.column_id = i.column_id AND i.index_id &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> WHERE c.system_type_id IN (<span class="hljs-number"><span class="hljs-number">34</span></span>, <span class="hljs-number"><span class="hljs-number">35</span></span>, <span class="hljs-number"><span class="hljs-number">99</span></span>) OR c.max_length = -<span class="hljs-number"><span class="hljs-number">1</span></span> GROUP BY c.[object_id], i.index_id ) lob ON lob.[object_id] = i.[object_id] AND lob.index_id = i.index_id JOIN sys.objects o ON o.[object_id] = i.[object_id] JOIN sys.data_spaces ds ON i.data_space_id = ds.data_space_id WHERE i.[type] IN (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) AND i.is_disabled = <span class="hljs-number"><span class="hljs-number">0</span></span> AND i.is_hypothetical = <span class="hljs-number"><span class="hljs-number">0</span></span> AND s.index_level = <span class="hljs-number"><span class="hljs-number">0</span></span> AND s.alloc_unit_type_desc = 'IN_ROW_DATA' AND o.[type] IN ('U', 'V')</code> </pre> <br>  Conseguimos nos livrar do problema principal com o v√©u do mesmo tipo de consultas em um produto concorrente, mas as desvantagens dessa implementa√ß√£o s√£o que nenhum par√¢metro adicional √© passado para a fun√ß√£o sys.dm_db_index_physical_stats que pode limitar a varredura de √≠ndices obviamente desnecess√°rios.  De fato, isso leva √† obten√ß√£o de informa√ß√µes sobre todos os √≠ndices no sistema e cargas extras de disco no est√°gio de varredura. <br><br>  √â importante observar que os dados obtidos de sys.dm_db_index_physical_stats n√£o s√£o armazenados em cache permanentemente no buffer pool, portanto, minimizar as leituras f√≠sicas ao obter informa√ß√µes sobre a fragmenta√ß√£o do √≠ndice foi uma das tarefas priorit√°rias durante o desenvolvimento. <br><br>  Ap√≥s v√°rias experi√™ncias, acabou combinando as duas abordagens, dividindo a varredura em duas partes.  Primeiro, uma consulta grande determina o tamanho das se√ß√µes, pr√©-filtrando as que n√£o est√£o no intervalo de filtragem: <br><br><pre> <code class="1c hljs">INSERT INTO <span class="hljs-meta"><span class="hljs-meta">#AllocationUnits (ContainerID, ReservedPages, UsedPages) SELECT [container_id] , SUM([total_pages]) , SUM([used_pages]) FROM sys.allocation_units WITH(NOLOCK) GROUP BY [container_id] HAVING SUM([total_pages]) BETWEEN @MinIndexSize AND @MaxIndexSize</span></span></code> </pre> <br>  Em seguida, obtemos apenas as se√ß√µes que cont√™m dados para evitar opera√ß√µes de leitura desnecess√°rias de √≠ndices vazios. <br><br><pre> <code class="1c hljs">SELECT [object_id] , [index_id] , [partition_id] , [partition_number] , [rows] , [data_compression] INTO <span class="hljs-meta"><span class="hljs-meta">#Partitions FROM sys.partitions WITH(NOLOCK) WHERE [object_id] &gt; 255 AND [rows] &gt; 0 AND [object_id] NOT IN (SELECT * FROM #ExcludeList)</span></span></code> </pre> <br>  Dependendo das configura√ß√µes, somente os tipos de √≠ndices s√£o obtidos que o usu√°rio deseja analisar (o trabalho com heaps, √≠ndices de cluster / n√£o cluster e indicadores de coluna √© suportado). <br><br><pre> <code class="1c hljs">INSERT INTO <span class="hljs-meta"><span class="hljs-meta">#Indexes SELECT ObjectID = i.[object_id] , IndexID = i.index_id , IndexName = i.[name] , PagesCount = a.ReservedPages , UnusedPagesCount = a.ReservedPages - a.UsedPages , PartitionNumber = p.[partition_number] , RowsCount = ISNULL(p.[rows], 0) , IndexType = i.[type] , IsAllowPageLocks = i.[allow_page_locks] , DataSpaceID = i.[data_space_id] , DataCompression = p.[data_compression] , IsUnique = i.[is_unique] , IsPK = i.[is_primary_key] , FillFactorValue = i.[fill_factor] , IsFiltered = i.[has_filter] FROM #AllocationUnits a JOIN #Partitions p ON a.ContainerID = p.[partition_id] JOIN sys.indexes i WITH(NOLOCK) ON i.[object_id] = p.[object_id] AND p.[index_id] = i.[index_id] WHERE i.[type] IN (0, 1, 2, 5, 6) AND i.[object_id] &gt; 255</span></span></code> </pre> <br>  Depois disso, um pouco de m√°gica come√ßa: para todos os pequenos √≠ndices, determinamos o n√≠vel de fragmenta√ß√£o chamando repetidamente a fun√ß√£o sys.dm_db_index_physical_stats com uma indica√ß√£o completa de todos os par√¢metros. <br><br><pre> <code class="1c hljs">INSERT INTO <span class="hljs-meta"><span class="hljs-meta">#Fragmentation (ObjectID, IndexID, PartitionNumber, Fragmentation) SELECT i.ObjectID , i.IndexID , i.PartitionNumber , r.[avg_fragmentation_in_percent] FROM #Indexes i CROSS APPLY sys.dm_db_index_physical_stats(@DBID, i.ObjectID, i.IndexID, i.PartitionNumber, 'LIMITED') r WHERE i.PagesCount &lt;= @PreDescribeSize AND r.[index_level] = 0 AND r.[alloc_unit_type_desc] = 'IN_ROW_DATA' AND i.IndexType IN (0, 1, 2)</span></span></code> </pre> <br>  Em seguida, retornamos todas as informa√ß√µes poss√≠veis ao cliente, filtrando o excesso de dados: <br><br><pre> <code class="1c hljs">SELECT i.ObjectID , i.IndexID , i.IndexName , ObjectName = o.[name] , SchemaName = s.[name] , i.PagesCount , i.UnusedPagesCount , i.PartitionNumber , i.RowsCount , i.IndexType , i.IsAllowPageLocks , u.TotalWrites , u.TotalReads , u.TotalSeeks , u.TotalScans , u.TotalLookups , u.LastUsage , i.DataCompression , f.Fragmentation , IndexStats = STATS_DATE(i.ObjectID, i.IndexID) , IsLobLegacy = ISNULL(lob.IsLobLegacy, <span class="hljs-number"><span class="hljs-number">0</span></span>) , IsLob = ISNULL(lob.IsLob, <span class="hljs-number"><span class="hljs-number">0</span></span>) , IsSparse = CAST(CASE WHEN p.ObjectID IS <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> THEN <span class="hljs-number"><span class="hljs-number">0</span></span> ELSE <span class="hljs-number"><span class="hljs-number">1</span></span> END AS BIT) , IsPartitioned = CAST(CASE WHEN dds.[data_space_id] IS NOT <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> THEN <span class="hljs-number"><span class="hljs-number">1</span></span> ELSE <span class="hljs-number"><span class="hljs-number">0</span></span> END AS BIT) , FileGroupName = fg.[name] , i.IsUnique , i.IsPK , i.FillFactorValue , i.IsFiltered , a.IndexColumns , a.IncludedColumns FROM <span class="hljs-meta"><span class="hljs-meta">#Indexes i JOIN sys.objects o WITH(NOLOCK) ON o.[object_id] = i.ObjectID JOIN sys.schemas s WITH(NOLOCK) ON s.[schema_id] = o.[schema_id] LEFT JOIN #AggColumns a ON a.ObjectID = i.ObjectID AND a.IndexID = i.IndexID LEFT JOIN #Sparse p ON p.ObjectID = i.ObjectID LEFT JOIN #Fragmentation f ON f.ObjectID = i.ObjectID AND f.IndexID = i.IndexID AND f.PartitionNumber = i.PartitionNumber LEFT JOIN ( SELECT ObjectID = [object_id] , IndexID = [index_id] , TotalWrites = NULLIF([user_updates], 0) , TotalReads = NULLIF([user_seeks] + [user_scans] + [user_lookups], 0) , TotalSeeks = NULLIF([user_seeks], 0) , TotalScans = NULLIF([user_scans], 0) , TotalLookups = NULLIF([user_lookups], 0) , LastUsage = ( SELECT MAX(dt) FROM ( VALUES ([last_user_seek]) , ([last_user_scan]) , ([last_user_lookup]) , ([last_user_update]) ) t(dt) ) FROM sys.dm_db_index_usage_stats WITH(NOLOCK) WHERE [database_id] = @DBID ) u ON i.ObjectID = u.ObjectID AND i.IndexID = u.IndexID LEFT JOIN #Lob lob ON lob.ObjectID = i.ObjectID AND lob.IndexID = i.IndexID LEFT JOIN sys.destination_data_spaces dds WITH(NOLOCK) ON i.DataSpaceID = dds.[partition_scheme_id] AND i.PartitionNumber = dds.[destination_id] JOIN sys.filegroups fg WITH(NOLOCK) ON ISNULL(dds.[data_space_id], i.DataSpaceID) = fg.[data_space_id] WHERE o.[type] IN ('V', 'U') AND ( f.Fragmentation &gt;= @Fragmentation OR i.PagesCount &gt; @PreDescribeSize OR i.IndexType IN (5, 6) )</span></span></code> </pre> <br>  Depois disso, as consultas pontuais determinam o n√≠vel de fragmenta√ß√£o para √≠ndices grandes. <br><br><pre> <code class="1c hljs">EXEC sp_executesql N' DECLARE @DBID INT = DB_ID() SELECT [avg_fragmentation_in_percent] FROM sys.dm_db_index_physical_stats(@DBID, @ObjectID, @IndexID, @PartitionNumber, ''LIMITED'') WHERE [index_level] = 0 AND [alloc_unit_type_desc] = ''IN_ROW_DATA''' , N'@ObjectID int,@IndexID int,@PartitionNumber int' , @ObjectId = <span class="hljs-number"><span class="hljs-number">1044198770</span></span>, @IndexId = <span class="hljs-number"><span class="hljs-number">1</span></span>, @PartitionNumber = <span class="hljs-number"><span class="hljs-number">1</span></span> EXEC sp_executesql N' DECLARE @DBID INT = DB_ID() SELECT [avg_fragmentation_in_percent] FROM sys.dm_db_index_physical_stats(@DBID, @ObjectID, @IndexID, @PartitionNumber, ''LIMITED'') WHERE [index_level] = 0 AND [alloc_unit_type_desc] = ''IN_ROW_DATA''' , N'@ObjectID int,@IndexID int,@PartitionNumber int' , @ObjectId = <span class="hljs-number"><span class="hljs-number">1552724584</span></span>, @IndexId = <span class="hljs-number"><span class="hljs-number">0</span></span>, @PartitionNumber = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Devido a essa abordagem, ao gerar consultas, foi poss√≠vel resolver os problemas com o desempenho da verifica√ß√£o encontrados nos aplicativos concorrentes.  Isso pode ser conclu√≠do, mas, no processo de desenvolvimento, surgiram novas id√©ias que permitiram expandir o escopo de aplica√ß√£o do seu produto. <br><br>  Inicialmente, o suporte ao trabalho com WAIT_AT_LOW_PRIORITY foi implementado e, em seguida, foi poss√≠vel usar DATA_COMPRESSION e FILL_FACTOR para reconstruir √≠ndices. <br><br><img src="https://habrastorage.org/webt/kd/em/xj/kdemxjo8sj0hxa4y_omvv3dph6a.png" alt="Configura√ß√µes do SQL Index Manager"><br><br>  O aplicativo estava um pouco cheio de funcionalidades n√£o planejadas anteriormente, como a manuten√ß√£o de colunas de servi√ßo: <br><br><pre> <code class="1c hljs">SELECT * FROM ( SELECT IndexID = [index_id] , PartitionNumber = [partition_number] , PagesCount = SUM([size_in_bytes]) / <span class="hljs-number"><span class="hljs-number">8192</span></span> , UnusedPagesCount = ISNULL(SUM(CASE WHEN [state] = <span class="hljs-number"><span class="hljs-number">1</span></span> THEN [size_in_bytes] END), <span class="hljs-number"><span class="hljs-number">0</span></span>) / <span class="hljs-number"><span class="hljs-number">8192</span></span> , Fragmentation = CAST(ISNULL(SUM(CASE WHEN [state] = <span class="hljs-number"><span class="hljs-number">1</span></span> THEN [size_in_bytes] END), <span class="hljs-number"><span class="hljs-number">0</span></span>) * <span class="hljs-number"><span class="hljs-number">100</span></span>. / SUM([size_in_bytes]) AS FLOAT) FROM sys.fn_column_store_row_groups(@ObjectID) GROUP BY [index_id] , [partition_number] ) t WHERE Fragmentation &gt;= @Fragmentation AND PagesCount BETWEEN @MinIndexSize AND @MaxIndexSize</code> </pre> <br>  Ou a capacidade de criar √≠ndices n√£o agrupados em cluster com base nas informa√ß√µes de dm_db_missing_index: <br><br><pre> <code class="1c hljs">SELECT ObjectID = d.[object_id] , UserImpact = gs.[avg_user_impact] , TotalReads = gs.[user_seeks] + gs.[user_scans] , TotalSeeks = gs.[user_seeks] , TotalScans = gs.[user_scans] , LastUsage = ISNULL(gs.[last_user_scan], gs.[last_user_seek]) , IndexColumns = CASE WHEN d.[equality_columns] IS NOT <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> AND d.[inequality_columns] IS NOT <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> THEN d.[equality_columns] + ', ' + d.[inequality_columns] WHEN d.[equality_columns] IS NOT <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> AND d.[inequality_columns] IS <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> THEN d.[equality_columns] ELSE d.[inequality_columns] END , IncludedColumns = d.[included_columns] FROM sys.dm_db_missing_index_groups g WITH(NOLOCK) JOIN sys.dm_db_missing_index_group_stats gs WITH(NOLOCK) ON gs.[group_handle] = g.[index_group_handle] JOIN sys.dm_db_missing_index_details d WITH(NOLOCK) ON g.[index_handle] = d.[index_handle] WHERE d.[database_id] = DB_ID()</code> </pre> <br><h3>  Sum√°rio </h3><br>  Ap√≥s seis meses da fase de desenvolvimento ativo, fico feliz que os planos n√£o terminem a√≠, porque quero continuar desenvolvendo este produto.  A pr√≥xima etapa √© adicionar funcionalidade para procurar √≠ndices duplicados ou n√£o utilizados, al√©m de implementar o suporte completo para veicular estat√≠sticas no SQL Server. <br><br>  Com base no fato de haver muitas solu√ß√µes pagas no mercado agora, quero acreditar que, devido ao posicionamento livre, uma descri√ß√£o mais otimizada dos metadados e a presen√ßa de v√°rias pequenas coisas √∫teis para algu√©m, este produto definitivamente se tornar√° √∫til nas tarefas di√°rias. <br><br>  A vers√£o atual do aplicativo pode ser baixada no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><b>GitHub</b></a> .  As fontes est√£o no mesmo lugar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt459914/">https://habr.com/ru/post/pt459914/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt459898/index.html">O plano voltou √† economia</a></li>
<li><a href="../pt459900/index.html">Visualizando uma coluna de um DataFrame usando a biblioteca Seaborn</a></li>
<li><a href="../pt459902/index.html">Mapa interativo das regi√µes russas para iniciantes. Erros que cometi e que voc√™ n√£o deve cometer</a></li>
<li><a href="../pt459906/index.html">Tic Tac Toe, parte 3: Desfazer / Refazer com armazenamento de comando</a></li>
<li><a href="../pt459910/index.html">Situa√ß√£o: as empresas n√£o t√™m pressa em desenvolver servi√ßos para assistentes de voz - quais s√£o os riscos</a></li>
<li><a href="../pt459918/index.html">Solu√ß√£o de problemas com pwnable.kr 03 - bof. Estouro de buffer na pilha</a></li>
<li><a href="../pt459922/index.html">Remo√ß√£o de ru√≠do de alta frequ√™ncia dos sinais dos sensores de vibra√ß√£o durante o diagn√≥stico de vibra√ß√£o dos rolamentos</a></li>
<li><a href="../pt459924/index.html">Ciclo de teste de rea√ß√£o completa. Relat√≥rio Auto.ru</a></li>
<li><a href="../pt459928/index.html">Caminho do aluno para o desenvolvimento de aplicativos para dispositivos m√≥veis</a></li>
<li><a href="../pt459930/index.html">Automa√ß√£o de importa√ß√£o Python</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>