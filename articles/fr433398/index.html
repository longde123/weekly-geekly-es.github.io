<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ûüèΩ üßîüèº üö£ Pens√©e fonctionnelle. Partie 7 üîÅ üíÉüèæ üçΩÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous continuons notre s√©rie d'articles sur la programmation fonctionnelle en F #. Aujourd'hui, nous avons un sujet tr√®s int√©ressant: la d√©finition des...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pens√©e fonctionnelle. Partie 7</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/433398/"><p>  Nous continuons notre s√©rie d'articles sur la programmation fonctionnelle en F #.  Aujourd'hui, nous avons un sujet tr√®s int√©ressant: la d√©finition des fonctions.  Y compris, parlons des fonctions anonymes, des fonctions sans param√®tres, des fonctions r√©cursives, des combinateurs et bien plus encore.  Regardez sous le chat! </p><br><p><img src="https://habrastorage.org/webt/7j/cd/7x/7jcd7xzdvnhpyxuebjvbzb1uiqs.jpeg"></p><br><ul><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Premi√®re partie</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Deuxi√®me partie</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Troisi√®me partie</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Quatri√®me partie</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cinqui√®me partie</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sixi√®me partie</a></strong> <a name="habracut"></a></li></ul><br><h1>  D√©finition de fonction </h1><br><p>  Nous savons d√©j√† comment cr√©er des fonctions r√©guli√®res en utilisant la syntaxe "let": </p><br><pre><code class="plaintext hljs">let add xy = x + y</code> </pre> <br><p>  Dans cet article, nous examinerons d'autres fa√ßons de cr√©er des fonctions, ainsi que des conseils pour les d√©finir. </p><br><h2>  Fonctions anonymes (lambdas) </h2><br><p>  Si vous connaissez les lambdas dans d'autres langues, les paragraphes suivants vous sembleront familiers.  Les fonctions anonymes (ou ¬´expressions lambda¬ª) sont d√©finies comme suit: </p><br><pre> <code class="plaintext hljs">fun parameter1 parameter2 etc -&gt; expression</code> </pre> <br><p>  Par rapport aux lambdas de C #, il existe deux diff√©rences: </p><br><ul><li>  lambdas devrait commencer par le mot-cl√© <code>fun</code> , qui n'est pas requis en C # </li><li>  une seule fl√®che <code>-&gt;</code> utilis√©e <code>-&gt;</code> , au lieu de double <code>=&gt;</code> de C #. </li></ul><br><p>  D√©finition lambda de la fonction d'addition: </p><br><pre> <code class="plaintext hljs">let add = fun xy -&gt; x + y</code> </pre> <br><p>  M√™me fonction sous forme traditionnelle: </p><br><pre> <code class="plaintext hljs">let add xy = x + y</code> </pre> <br><p>  Les lambdas sont souvent utilis√©s sous la forme de petites expressions ou lorsqu'il n'y a pas de d√©sir de d√©finir une fonction distincte pour une expression.  Comme vous l'avez d√©j√† vu, lorsque vous travaillez avec des listes, ce n'est pas rare. </p><br><pre> <code class="plaintext hljs">//    let add1 i = i + 1 [1..10] |&gt; List.map add1 //        [1..10] |&gt; List.map (fun i -&gt; i + 1)</code> </pre> <br><p>  Notez que les parenth√®ses doivent √™tre utilis√©es autour des lambdas. </p><br><p>  Les lambdas sont √©galement utilis√©s lorsqu'une fonction clairement diff√©rente est n√©cessaire.  Par exemple, le " <code>adderGenerator</code> " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">discut√© pr√©c√©demment,</a> dont nous avons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">discut√© plus t√¥t,</a> peut √™tre r√©√©crit en utilisant lambdas. </p><br><pre> <code class="plaintext hljs">//   let adderGenerator x = (+) x //     let adderGenerator x = fun y -&gt; x + y</code> </pre> <br><p>  La version lambda est un peu plus longue, mais indique imm√©diatement qu'une fonction interm√©diaire sera retourn√©e. </p><br><p>  Les lambdas peuvent √™tre imbriqu√©s.  Un autre exemple de d√©finition <code>adderGenerator</code> , cette fois uniquement sur lambdas. </p><br><pre> <code class="plaintext hljs">let adderGenerator = fun x -&gt; (fun y -&gt; x + y)</code> </pre> <br><p>  √ätes-vous clair que les trois d√©finitions sont √©quivalentes? </p><br><pre> <code class="plaintext hljs">let adderGenerator1 xy = x + y let adderGenerator2 x = fun y -&gt; x + y let adderGenerator3 = fun x -&gt; (fun y -&gt; x + y)</code> </pre> <br><p>  Sinon, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">relisez le chapitre sur le curry</a> .  C'est tr√®s important pour comprendre! </p><br><h2>  Correspondance de motifs </h2><br><p>  Lorsqu'une fonction est d√©finie, il est possible de lui passer explicitement des param√®tres, comme dans les exemples ci-dessus, mais il est √©galement possible de comparer avec un mod√®le directement dans la section des param√®tres.  En d'autres termes, la section des param√®tres peut contenir des mod√®les (mod√®les correspondants), et pas seulement des identifiants! </p><br><p>  L'exemple suivant illustre l'utilisation de mod√®les dans une d√©finition de fonction: </p><br><pre> <code class="plaintext hljs">type Name = {first:string; last:string} //    let bob = {first="bob"; last="smith"} //   //     let f1 name = //   let {first=f; last=l} = name //     printfn "first=%s; last=%s" fl //   let f2 {first=f; last=l} = //        printfn "first=%s; last=%s" fl //  f1 bob f2 bob</code> </pre> <br><p>  Ce type de comparaison ne peut se produire que lorsque la correspondance est toujours d√©cidable.  Par exemple, vous ne pouvez pas faire correspondre les types d'union et les listes de cette mani√®re, car certains cas ne peuvent pas √™tre mis en correspondance. </p><br><pre> <code class="plaintext hljs">let f3 (x::xs) = //       printfn "first element is=%A" x</code> </pre> <br><p>  Le compilateur donnera un avertissement sur la correspondance incompl√®te (une liste vide provoquera une erreur d'ex√©cution √† l'entr√©e de cette fonction). </p><br><h2>  Erreur courante: tuples vs  de nombreux param√®tres </h2><br><p>  Si vous venez d'un langage de type C, le tuple utilis√© comme seul argument de la fonction peut douloureusement ressembler √† une fonction multi-param√®tres.  Mais ce n'est pas la m√™me chose!  Comme je l'ai not√© plus t√¥t, si vous voyez une virgule, c'est probablement un tuple.  Les param√®tres sont s√©par√©s par des espaces. </p><br><p>  Exemple de confusion: </p><br><pre> <code class="plaintext hljs">//      let addTwoParams xy = x + y //      -  let addTuple aTuple = let (x,y) = aTuple x + y //         //        let addConfusingTuple (x,y) = x + y</code> </pre> <br><ul><li>  La premi√®re d√©finition, " <code>addTwoParams</code> ", prend deux param√®tres, s√©par√©s par un espace. </li><li>  La deuxi√®me d√©finition, " <code>addTuple</code> ", prend un param√®tre.  Ce param√®tre lie "x" et "y" √† partir du tuple et les additionne. </li><li>  La troisi√®me d√©finition, " <code>addConfusingTuple</code> ", prend un seul param√®tre comme " <code>addTuple</code> ", mais l'astuce est que ce tuple est d√©compress√© (adapt√© au mod√®le) et li√© dans le cadre de la d√©finition du param√®tre √† l'aide de la correspondance de mod√®le.  Dans les coulisses, tout se passe exactement de la m√™me mani√®re que dans <code>addTuple</code> . </li></ul><br><p>  Regardons les signatures (regardez-les toujours si vous n'√™tes pas s√ªr de quelque chose). </p><br><pre> <code class="plaintext hljs">val addTwoParams : int -&gt; int -&gt; int //   val addTuple : int * int -&gt; int // tuple-&gt;int val addConfusingTuple : int * int -&gt; int // tuple-&gt;int</code> </pre> <br><p>  Et maintenant ici: </p><br><pre> <code class="plaintext hljs">// addTwoParams 1 2 // ok --      addTwoParams (1,2) // error -     // =&gt; error FS0001: This expression was expected to have type // int but here has type 'a * 'b</code> </pre> <br><p>  Ici, nous voyons une erreur dans le deuxi√®me appel. </p><br><p>  Premi√®rement, le compilateur traite <code>(1,2)</code> comme un tuple g√©n√©ralis√© de la forme <code>('a * 'b)</code> , qu'il essaie de passer comme premier param√®tre √† <code>addTwoParams</code> .  Apr√®s quoi, il se plaint que le premier param√®tre <code>addTwoParams</code> pas <code>int</code> , mais une tentative a √©t√© faite pour passer un tuple. </p><br><p>  Pour faire un tuple, utilisez une virgule! </p><br><pre> <code class="plaintext hljs">addTuple (1,2) // ok addConfusingTuple (1,2) // ok let x = (1,2) addTuple x // ok let y = 1,2 //  , //  ! addTuple y // ok addConfusingTuple y // ok</code> </pre> <br><p>  Et vice versa, si vous passez plusieurs arguments √† une fonction en attente d'un tuple, vous obtenez √©galement une erreur incompr√©hensible. </p><br><pre> <code class="plaintext hljs">addConfusingTuple 1 2 // error --          // =&gt; error FS0003: This value is not a function and // cannot be applied</code> </pre> <br><p>  Cette fois, le compilateur a d√©cid√© qu'une fois deux arguments <code>addConfusingTuple</code> , <code>addConfusingTuple</code> devrait √™tre curry.  Et l'entr√©e " <code>addConfusingTuple 1</code> " est une application partielle et doit renvoyer une fonction interm√©diaire.  Tenter d'appeler cette fonction interm√©diaire avec le param√®tre "2" g√©n√©rera une erreur, car  il n'y a pas de fonction interm√©diaire!  Nous voyons la m√™me erreur que dans le chapitre sur le curry, o√π nous avons discut√© des probl√®mes avec trop de param√®tres. </p><br><h3>  Pourquoi ne pas utiliser des tuples comme param√®tres? </h3><br><p>  La discussion des tuples ci-dessus montre une autre fa√ßon de d√©finir des fonctions avec de nombreux param√®tres: au lieu de les passer s√©par√©ment, tous les param√®tres peuvent √™tre assembl√©s en une seule structure.  Dans l'exemple ci-dessous, la fonction prend un seul param√®tre - un tuple de trois √©l√©ments. </p><br><pre> <code class="plaintext hljs">let f (x,y,z) = x + y * z //  - int * int * int -&gt; int //  f (1,2,3)</code> </pre> <br><p>  Il est √† noter que la signature est diff√©rente de la signature d'une fonction √† trois param√®tres.  Il n'y a qu'une fl√®che, un param√®tre et des ast√©risques pointant vers le tuple <code>(int*int*int)</code> . </p><br><p>  Quand il est n√©cessaire de soumettre des arguments avec des param√®tres s√©par√©s, et quand un tuple? </p><br><ul><li>  Quand les tuples sont importants en eux-m√™mes.  Par exemple, pour des op√©rations dans un espace tridimensionnel, les triples tuples seront plus pratiques que trois coordonn√©es s√©par√©ment. </li><li>  Parfois, les tuples sont utilis√©s pour combiner des donn√©es qui doivent √™tre stock√©es ensemble dans une seule structure.  Par exemple, les m√©thodes <code>TryParse</code> de la biblioth√®que .NET renvoient le r√©sultat et une variable bool√©enne en tant que tuple.  Mais pour stocker une grande quantit√© de donn√©es li√©es, il est pr√©f√©rable de d√©finir une classe ou un enregistrement ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">record</a> . </li></ul><br><h3>  Cas particulier: Tuples et fonctions de la biblioth√®que .NET </h3><br><p>  Lors de l'appel de biblioth√®ques .NET, les virgules sont tr√®s courantes! </p><br><p>  Ils acceptent tous les tuples, et les appels se ressemblent comme en C #: </p><br><pre> <code class="plaintext hljs">//  System.String.Compare("a","b") //   System.String.Compare "a" "b"</code> </pre> <br><p>  La raison en est que les fonctions du .NET classique ne sont pas analys√©es et ne peuvent pas √™tre partiellement appliqu√©es.  <em>Tous les</em> param√®tres doivent <em>toujours</em> √™tre transmis imm√©diatement, et la mani√®re la plus √©vidente est d'utiliser un tuple. </p><br><p>  Notez que ces appels ne ressemblent qu'√† transf√©rer des tuples, mais c'est en fait un cas sp√©cial.  Vous ne pouvez pas passer de vrais tuples dans de telles fonctions: </p><br><pre> <code class="plaintext hljs">let tuple = ("a","b") System.String.Compare tuple // error System.String.Compare "a","b" // error</code> </pre> <br><p>  Si vous souhaitez appliquer partiellement les fonctions .NET, √©crivez simplement des wrappers dessus, comme cela a √©t√© fait <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pr√©c√©demment</a> , ou comme indiqu√© ci-dessous: </p><br><pre> <code class="plaintext hljs">//    let strCompare xy = System.String.Compare(x,y) //    let strCompareWithB = strCompare "B" //      ["A";"B";"C"] |&gt; List.map strCompareWithB</code> </pre> <br><h2>  Guide de s√©lection des param√®tres individuels et group√©s </h2><br><p>  La discussion des tuples m√®ne √† un sujet plus g√©n√©ral: quand les param√®tres doivent-ils √™tre s√©par√©s et quand ils sont regroup√©s? </p><br><p>  Vous devez faire attention √† la fa√ßon dont F # diff√®re de C # √† cet √©gard.  En C #, <em>tous les</em> param√®tres sont <em>toujours</em> pass√©s, donc cette question ne se pose m√™me pas l√†!  En F #, en raison d'une application partielle, seuls certains param√®tres peuvent √™tre repr√©sent√©s, il est donc n√©cessaire de faire la distinction entre le cas o√π les param√®tres doivent √™tre combin√©s et le cas o√π ils sont ind√©pendants. </p><br><p>  Recommandations g√©n√©rales sur la fa√ßon de structurer les param√®tres lors de la conception de vos propres fonctions. </p><br><ul><li>  Dans le cas g√©n√©ral, il est toujours pr√©f√©rable d'utiliser des param√®tres s√©par√©s au lieu de passer une structure, que ce soit un tuple ou un enregistrement.  Cela permet un comportement plus flexible, comme une application partielle. </li><li>  Mais, lorsqu'un groupe de param√®tres <em>doit</em> √™tre transmis √† la fois, une sorte de m√©canisme de regroupement doit √™tre utilis√©. </li></ul><br><p>  En d'autres termes, lorsque vous d√©veloppez une fonction, demandez-vous: ¬´Puis-je fournir ce param√®tre s√©par√©ment?¬ª  Si la r√©ponse est non, les param√®tres doivent √™tre regroup√©s. </p><br><p>  Regardons quelques exemples: </p><br><pre> <code class="plaintext hljs">//     . //      ,       let add xy = x + y //         //      ,    let locateOnMap (xCoord,yCoord) = //  //      //      -     type CustomerName = {First:string; Last:string} let setCustomerName aCustomerName = //  let setCustomerName first last = //   //     //     //    ,     let setCustomerName myCredentials aName = //</code> </pre> <br><p>  Enfin, assurez-vous que l'ordre des param√®tres aidera dans une application partielle (voir le manuel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ).  Par exemple, pourquoi ai-je mis <code>myCredentials</code> avant <code>aName</code> dans la derni√®re fonction? </p><br><h2>  Fonctions sans param√®tres </h2><br><p>  Parfois, vous pouvez avoir besoin d'une fonction qui n'accepte aucun param√®tre.  Par exemple, vous avez besoin de la fonction "hello world" qui peut √™tre appel√©e plusieurs fois.  Comme indiqu√© dans la section pr√©c√©dente, la d√©finition na√Øve ne fonctionne pas. </p><br><pre> <code class="plaintext hljs">let sayHello = printfn "Hello World!" //     </code> </pre> <br><p>  Mais cela peut √™tre corrig√© en ajoutant un param√®tre d'unit√© √† la fonction ou en utilisant un lambda. </p><br><pre> <code class="plaintext hljs">let sayHello() = printfn "Hello World!" //  let sayHello = fun () -&gt; printfn "Hello World!" // </code> </pre> <br><p>  Apr√®s cela, la fonction doit toujours √™tre appel√©e avec l'argument <code>unit</code> : </p><br><pre> <code class="plaintext hljs">//  sayHello()</code> </pre> <br><p>  Ce qui se produit assez souvent lors de l'interaction avec les biblioth√®ques .NET: </p><br><pre> <code class="plaintext hljs">Console.ReadLine() System.Environment.GetCommandLineArgs() System.IO.Directory.GetCurrentDirectory()</code> </pre> <br><p>  N'oubliez pas, appelez-les avec les param√®tres de l' <code>unit</code> ! </p><br><h2>  D√©finir de nouveaux op√©rateurs </h2><br><p>  Vous pouvez d√©finir des fonctions en utilisant un ou plusieurs caract√®res d'op√©rateur (voir la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> pour une liste de caract√®res): </p><br><pre> <code class="plaintext hljs">//  let (.*%) xy = x + y + 1</code> </pre> <br><p>  Vous devez utiliser des parenth√®ses autour des caract√®res pour d√©finir la fonction. </p><br><p>  Les op√©rateurs commen√ßant par <code>*</code> n√©cessitent un espace entre les parenth√®ses et <code>*</code> , car  en F # <code>(*</code> agit comme le d√©but d'un commentaire (comme <code>/*...*/</code> en C #): </p><br><pre> <code class="plaintext hljs">let ( *+* ) xy = x + y + 1</code> </pre> <br><p>  Une fois d√©finie, une nouvelle fonction peut √™tre utilis√©e de la mani√®re habituelle si elle est plac√©e entre crochets: </p><br><pre> <code class="plaintext hljs">let result = (.*%) 2 3</code> </pre> <br><p>  Si la fonction est utilis√©e avec deux param√®tres, vous pouvez utiliser l'enregistrement d'op√©rateur d'infixe sans parenth√®ses. </p><br><pre> <code class="plaintext hljs">let result = 2 .*% 3</code> </pre> <br><p>  Vous pouvez √©galement d√©finir des op√©rateurs de pr√©fixe commen√ßant par <code>!</code>  ou <code>~</code> (avec quelques restrictions, voir la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> ) </p><br><pre> <code class="plaintext hljs">let (~%%) (s:string) = s.ToCharArray() // let result = %% "hello"</code> </pre> <br><p>  En F #, la d√©finition des instructions est une op√©ration assez courante, et de nombreuses biblioth√®ques exportent des instructions avec des noms comme <code>&gt;=&gt;</code> et <code>&lt;*&gt;</code> . </p><br><h2>  Style sans point </h2><br><p>  Nous avons d√©j√† vu de nombreux exemples de fonctions qui n'avaient pas les derniers param√®tres pour r√©duire le niveau de chaos.  Ce style est appel√© style sans <strong>point</strong> ou <strong>programmation tacite</strong> . </p><br><p>  Voici quelques exemples: </p><br><pre> <code class="plaintext hljs">let add xy = x + y //  let add x = (+) x // point free let add1Times2 x = (x + 1) * 2 //  let add1Times2 = (+) 1 &gt;&gt; (*) 2 // point free let sum list = List.reduce (fun sum e -&gt; sum+e) list //  let sum = List.reduce (+) // point free</code> </pre> <br><p>  Ce style a ses avantages et ses inconv√©nients. </p><br><p>  L'un des avantages est que l'accent est mis sur la composition de fonctions d'ordre sup√©rieur au lieu de s'occuper d'objets de bas niveau.  Par exemple, " <code>(+) 1 &gt;&gt; (*) 2</code> " est un ajout explicite suivi d'une multiplication.  Et " <code>List.reduce (+)</code> " indique clairement que l'op√©ration d'ajout est importante, quelles que soient les informations de la liste. </p><br><p>  Un style inutile vous permet de vous concentrer sur l'algorithme de base et d'identifier les caract√©ristiques communes dans le code.  La fonction " <code>reduce</code> " utilis√©e ci-dessus en est un bon exemple.  Ce sujet sera abord√© dans une s√©rie pr√©vue sur le traitement des listes. </p><br><p>  D'un autre c√¥t√©, une utilisation excessive d'un tel style peut rendre le code obscur.  Les param√®tres explicites font office de documentation et leurs noms (tels que "liste") facilitent la compr√©hension de ce que fait la fonction. </p><br><p>  Comme tout dans la programmation, la meilleure recommandation est de pr√©f√©rer l'approche qui offre le plus de clart√©. </p><br><h2>  Combinateurs </h2><br><p>  Les " <strong>combinateurs</strong> " sont appel√©s fonctions dont le r√©sultat ne d√©pend que de leurs param√®tres.  Cela signifie qu'il n'y a pas de d√©pendance vis-√†-vis du monde ext√©rieur et, en particulier, qu'aucune autre fonction ou valeur globale ne peut les affecter. </p><br><p>  En pratique, cela signifie que les fonctions combinatoires sont limit√©es par une combinaison de leurs param√®tres de diverses mani√®res. </p><br><p>  Nous avons d√©j√† vu plusieurs combinateurs: un tuyau et un op√©rateur de composition.  Si vous regardez leurs d√©finitions, il est clair qu'elles ne font que r√©organiser les param√®tres de diff√©rentes mani√®res. </p><br><pre> <code class="plaintext hljs">let (|&gt;) xf = fx //  pipe let (&lt;|) fx = fx //  pipe let (&gt;&gt;) fgx = g (fx) //   let (&lt;&lt;) gfx = g (fx) //  </code> </pre> <br><p>  D'un autre c√¥t√©, des fonctions comme "printf", bien que primitives, ne sont pas des combinateurs car elles d√©pendent du monde ext√©rieur (E / S). </p><br><h3>  Oiseaux combinatoires </h3><br><p>  Les combinateurs sont √† la base de toute une section de la logique (naturellement appel√©e "logique combinatoire"), qui a √©t√© invent√©e de nombreuses ann√©es avant les ordinateurs et les langages de programmation.  La logique combinatoire a une tr√®s grande influence sur la programmation fonctionnelle. </p><br><p>  Pour en savoir plus sur les combinateurs et la logique combinatoire, je recommande le livre de Raymond Smullyan "To Mock a Mockingbird".  Dans ce document, il explique d'autres combinateurs et leur donne de mani√®re fantaisiste <a href="">des noms d'oiseaux</a> .  Voici quelques exemples de combinateurs standard et leurs noms d'oiseaux: </p><br><pre> <code class="plaintext hljs">let I x = x //  ,  Idiot bird let K xy = x // the Kestrel let M x = x &gt;&gt; x // the Mockingbird let T xy = yx // the Thrush ( !) let Q xyz = y (xz) // the Queer bird ( !) let S xyz = xz (yz) // The Starling //   ... let rec Y fx = f (Y f) x // Y-,  Sage bird</code> </pre> <br><p>  Les noms de lettres sont assez standard, vous pouvez donc vous r√©f√©rer au combinateur K √† toute personne connaissant cette terminologie. </p><br><p>  Il s'av√®re que de nombreux mod√®les de programmation courants peuvent √™tre repr√©sent√©s par ces combinateurs standard.  Par exemple, Kestrel est un mod√®le r√©gulier dans l'interface fluide o√π vous faites quelque chose mais retournez l'objet d'origine.  Le muguet est une pipe, Queer est une composition directe et le combinateur Y fait un excellent travail de cr√©ation de fonctions r√©cursives. </p><br><p>  En fait, il existe un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">th√©or√®me bien connu selon</a> lequel toute fonction calculable peut √™tre construite en utilisant seulement deux combinateurs de base, Kestrel et Starling. </p><br><h3>  Biblioth√®ques combinatoires </h3><br><p>  Les biblioth√®ques combinatoires sont des biblioth√®ques qui exportent de nombreuses fonctions combinatoires con√ßues pour √™tre partag√©es.  Un utilisateur d'une telle biblioth√®que peut facilement combiner des fonctions pour obtenir des fonctions encore plus grandes et plus complexes, comme des cubes facilement. </p><br><p>  Une biblioth√®que de combinateurs bien con√ßue vous permet de vous concentrer sur les fonctions de haut niveau et de masquer le ¬´bruit¬ª de bas niveau.  Nous avons d√©j√† vu leur puissance dans plusieurs exemples de la s√©rie "pourquoi utiliser F #", et le module <code>List</code> est plein de telles fonctions, " <code>fold</code> " et " <code>map</code> " sont √©galement des combinateurs si vous y pensez. </p><br><p>  Un autre avantage des combinateurs est qu'ils sont le type de fonction le plus s√ªr.  Parce que  ils n'ont aucune d√©pendance vis-√†-vis du monde ext√©rieur, ils ne peuvent pas changer lorsque l'environnement mondial change.  Une fonction qui lit une valeur globale ou utilise des fonctions de biblioth√®que peut se rompre ou changer entre les appels si le contexte change.  Cela n'arrivera jamais aux combinateurs. </p><br><p>  En F #, les biblioth√®ques de combinateur sont disponibles pour l'analyse (FParsec), la cr√©ation de HTML, les frameworks de test, etc.  Nous discuterons et utiliserons les combinateurs plus tard dans la prochaine s√©rie. </p><br><h2>  Fonctions r√©cursives </h2><br><p>  Souvent, une fonction doit se r√©f√©rer √† elle-m√™me √† partir de son corps.  Un exemple classique est la fonction de Fibonacci. </p><br><pre> <code class="plaintext hljs">let fib i = match i with | 1 -&gt; 1 | 2 -&gt; 1 | n -&gt; fib(n-1) + fib(n-2)</code> </pre> <br><p>  Malheureusement, cette fonction ne pourra pas compiler: </p><br><pre> <code class="plaintext hljs">error FS0039: The value or constructor 'fib' is not defined</code> </pre> <br><p>  Vous devez indiquer au compilateur qu'il s'agit d'une fonction r√©cursive utilisant le mot cl√© <code>rec</code> . </p><br><pre> <code class="plaintext hljs">let rec fib i = match i with | 1 -&gt; 1 | 2 -&gt; 1 | n -&gt; fib(n-1) + fib(n-2)</code> </pre> <br><p>  Les fonctions r√©cursives et les structures de donn√©es sont tr√®s courantes dans la programmation fonctionnelle, et j'esp√®re consacrer toute une s√©rie √† ce sujet plus tard. </p><br><h1>  Ressources suppl√©mentaires </h1><br><p>  Il existe de nombreux didacticiels pour F #, y compris des documents pour ceux qui viennent avec une exp√©rience C # ou Java.  Les liens suivants peuvent √™tre utiles pour approfondir F #: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Guide F #</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">F # pour le plaisir et le profit</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">F # Wiki</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Apprenez X en Y minutes: F #</a> </li></ul><br><p>  Plusieurs autres fa√ßons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de commencer √† apprendre le F # sont</a> √©galement d√©crites. </p><br><p>  Enfin, la communaut√© F # est tr√®s conviviale pour les d√©butants.  Il y a un chat tr√®s actif chez Slack, soutenu par la F # Software Foundation, avec des salles pour d√©butants que vous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pouvez rejoindre librement</a> .  Nous vous recommandons fortement de le faire! </p><br><p>  N'oubliez pas de visiter le site de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">communaut√© russophone F #</a> !  Si vous avez des questions sur l'apprentissage d'une langue, nous serons heureux d'en discuter dans les salles de chat: </p><br><ul><li>  room <code>#ru_general</code> dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Slack Chat de</a> la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">F # Software Foundation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chat dans Telegram</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">discuter avec gitter</a> </li><li>  room #en_general dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Slack Chat de</a> la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">F # Software Foundation</a> </li></ul><br><h2>  √Ä propos des auteurs de traduction </h2><br><p>  Traduit par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>@kleidemos</em></a> <br><img src="https://habrastorage.org/getpro/habr/post_images/f95/c6d/92c/f95c6d92c5b1126b093792a43955aa43.png" width="56" height="56">  La traduction et les modifications √©ditoriales ont √©t√© apport√©es par les efforts de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">communaut√© russophone des d√©veloppeurs F #</a> .  Nous remercions √©galement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>@schvepsss</em></a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>@shwars d'</em></a> avoir pr√©par√© cet article pour publication. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr433398/">https://habr.com/ru/post/fr433398/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr433386/index.html">Comment utiliser une vision par ordinateur pour √©valuer l'√©tat de la voiture. D√©couvrez Yandex.Taxi</a></li>
<li><a href="../fr433388/index.html">Fan de formule ou pourquoi nous jouons √† des jeux</a></li>
<li><a href="../fr433390/index.html">Yandex a rejoint la protection de Linux et de l'industrie informatique contre la p√™che √† la tra√Æne des brevets</a></li>
<li><a href="../fr433392/index.html">Courte critique du t√©l√©phone IP Snom D725</a></li>
<li><a href="../fr433396/index.html">Frontend 2018: r√©sultats de l'ann√©e</a></li>
<li><a href="../fr433400/index.html">Tutoriel React Partie 2: Composants fonctionnels</a></li>
<li><a href="../fr433402/index.html">Pens√©e fonctionnelle. Partie 8</a></li>
<li><a href="../fr433404/index.html">Tutoriel React, partie 3: fichiers de composants, structure du projet</a></li>
<li><a href="../fr433406/index.html">Pens√©e fonctionnelle. Partie 9</a></li>
<li><a href="../fr433408/index.html">Gestion efficace de la m√©moire dans Node.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>