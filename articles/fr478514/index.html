<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå≥ üëäüèΩ üëäüèæ Utilisation de donn√©es chiffr√©es pour l'apprentissage automatique sans les d√©chiffrer üà≥ üçΩÔ∏è ü¶é</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Utilisation de donn√©es chiffr√©es pour l'apprentissage automatique sans les d√©chiffrer 
 Cet article d√©crit les techniques cryptographiques avanc√©es. C...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Utilisation de donn√©es chiffr√©es pour l'apprentissage automatique sans les d√©chiffrer</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/478514/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/_p/ns/yf/_pnsyfz49v6t61j8whitl-q4qw0.jpeg"></div><br>  Utilisation de donn√©es chiffr√©es pour l'apprentissage automatique sans les d√©chiffrer <br>  Cet article d√©crit les techniques cryptographiques avanc√©es.  Ceci est juste un aper√ßu des recherches men√©es par Julia Computing.  N'utilisez pas les exemples donn√©s ici dans les applications commerciales.  Consultez toujours les cryptographes avant d'appliquer la cryptographie. <br><br>  <a href="">Ici,</a> vous pouvez t√©l√©charger le package qui impl√©mente toute la magie, et <a href="">voici</a> le code qui est discut√© dans l'article. <br><a name="habracut"></a><br><h2>  Pr√©sentation </h2><br>  Supposons que vous venez de d√©velopper un nouveau mod√®le d'apprentissage automatique sympa (bien s√ªr, en utilisant <a href="">Flux.jl</a> ).  Et maintenant, vous voulez commencer √† le d√©ployer pour vos utilisateurs.  Comment allez-vous faire cela?  Le moyen le plus simple est probablement de donner le mod√®le aux utilisateurs et de le laisser s'ex√©cuter localement sur leurs donn√©es.  Mais cette approche pr√©sente des inconv√©nients: <br><br><ol><li>  Les mod√®les d'apprentissage automatique sont volumineux et les ordinateurs des utilisateurs peuvent ne pas disposer de suffisamment de ressources informatiques ou disque. </li><li>  Les mod√®les d'apprentissage automatique sont souvent mis √† jour et il peut ne pas √™tre pratique pour vous d'envoyer r√©guli√®rement de grandes quantit√©s de donn√©es sur le r√©seau. <br></li><li>  Le d√©veloppement de mod√®les prend du temps et n√©cessite une grande quantit√© de ressources informatiques.  Et vous voudrez peut-√™tre une compensation sous forme de frais pour l'utilisation de votre mod√®le. </li></ol><br>  Ensuite, ils se souviennent g√©n√©ralement que le mod√®le peut √™tre fourni dans le cloud via l'API.  Au cours des derni√®res ann√©es, de nombreux services de ce type sont apparus; chaque grande plateforme cloud offre des services similaires aux d√©veloppeurs d'entreprise.  Mais les utilisateurs potentiels sont confront√©s √† un dilemme √©vident: d√©sormais, leurs donn√©es sont trait√©es sur un serveur distant, qui peut ne pas √™tre fiable.  Cela a des implications √©thiques et juridiques claires qui limitent l'utilisation de ces services.  Dans les secteurs r√©glement√©s, notamment les soins de sant√© et les services financiers, il est souvent impossible d'envoyer des donn√©es sur les patients et les clients √† des tiers pour traitement. <br><br>  D'autres options? <br><br>  Il s'av√®re que c'est le cas!  Les d√©couvertes r√©centes en cryptographie permettent de calculer avec des donn√©es <i>sans les d√©coder</i> .  Par exemple, un utilisateur envoie des donn√©es chiffr√©es (par exemple, des images) √† l'API cloud, qui lance un mod√®le d'apprentissage automatique, puis envoie une r√©ponse chiffr√©e.  √Ä aucun moment, les donn√©es ne sont d√©chiffr√©es, le fournisseur de cloud n'a pas acc√®s aux images sources et ne peut pas d√©chiffrer les pr√©visions calcul√©es.  Comment est-ce possible?  Voyons l'exemple de la cr√©ation d'un service de reconnaissance de l'√©criture manuscrite sur des images chiffr√©es √† partir de l'ensemble de donn√©es MNIST. <br><br><h2>  √Ä propos du chiffrement homomorphe </h2><br>  La capacit√© d'effectuer des calculs avec des donn√©es chiffr√©es est commun√©ment appel√©e ¬´informatique s√©curis√©e¬ª.  Il s'agit d'un vaste domaine de recherche, avec de nombreuses approches de la cryptographie en fonction de toutes sortes de sc√©narios d'application.  Nous nous concentrerons sur une technique appel√©e ¬´cryptage homomorphique¬ª.  Dans un tel syst√®me, les op√©rations suivantes sont g√©n√©ralement disponibles pour nous: <br><br><ul><li><code>pub_key, eval_key, priv_key = keygen()</code> <br> </li><li> <code>encrypted = encrypt(pub_key, plaintext)</code> <br> </li><li> <code>decrypted = decrypt(priv_key, encrypted)</code> <br> </li><li> <code>encrypted‚Ä≤ = eval(eval_key, f, encrypted)</code> <br> </li></ul><br>  Les trois premi√®res op√©rations sont simples et famili√®res √† tous ceux qui ont d√©j√† utilis√© des algorithmes de chiffrement asym√©triques (par exemple, si vous vous √™tes connect√© via TLS).  Toute magie op√®re lors de la derni√®re op√©ration.  Lors du chiffrement, il √©value la fonction <code>f</code> et renvoie une autre valeur chiffr√©e calcul√©e en fonction du r√©sultat de l'√©valuation <code>f</code> sur la valeur chiffr√©e.  Cette caract√©ristique a donn√© son nom √† son approche.  L'√©valuation est li√©e √† l'op√©ration de chiffrement: <br><br><pre> <code class="julia hljs">f(decrypt(priv_key, encrypted)) == decrypt(priv_key, eval(eval_key, f, encrypted))</code> </pre> <br>  De m√™me, en utilisant une valeur chiffr√©e, nous pouvons √©valuer des homomorphismes arbitraires <code>f</code> . <br><br>  Les fonctions <code>f</code> prises en charge d√©pendent des sch√©mas cryptographiques et des op√©rations prises en charge.  Si un seul <code>f</code> pris en charge (par exemple, <code>f = +</code> ), alors le circuit est appel√© ¬´partiellement homomorphe¬ª.  Si <code>f</code> peut √™tre un ensemble complet de passerelles, sur la base desquelles des sch√©mas arbitraires peuvent √™tre cr√©√©s, alors pour une taille limit√©e du sch√©ma, cela s'appelle un autre type de calcul partiellement homomorphe - "quelque peu homomorphique", et pour une taille illimit√©e - calcul "compl√®tement homomorphique".  Vous pouvez transformer "en quelque sorte" un cryptage compl√®tement homomorphe en utilisant la technique d'amor√ßage, mais cela d√©passe le cadre de notre article.  Le cryptage enti√®rement homomorphe est une d√©couverte relativement r√©cente, le premier sch√©ma de travail (bien que peu pratique) a √©t√© publi√© par <a href="https://www.cs.cmu.edu/~odonnell/hits09/gentry-homomorphic-encryption.pdf">Craig Gentry en 2009</a> .  Il existe un certain nombre de sch√©mas ult√©rieurs (et pratiques) compl√®tement homomorphes.  Il existe √©galement des progiciels qui mettent en ≈ìuvre qualitativement ces sch√©mas.  Le plus souvent, ils utilisent <a href="https://github.com/microsoft/SEAL">Microsoft SEAL</a> et <a href="https://palisade-crypto.org/">PALISADE</a> .  De plus, j'ai r√©cemment ouvert le code d'impl√©mentation de ces algorithmes <a href="">Pure Julia</a> .  Pour cet article, nous utiliserons le cryptage CKKS impl√©ment√©. <br><br><h2>  Pr√©sentation de CKS </h2><br>  CKKS (par les noms des auteurs de l' <a href="https://eprint.iacr.org/2016/421.pdf">ouvrage scientifique</a> Cheon-Kim-Kim-Song, qui a propos√© l'algorithme en 2016) est un sch√©ma de cryptage homomorphique qui permet une √©valuation homomorphique des op√©rations primitives suivantes: <br><br><ul><li>  L'addition √©l√©ment par √©l√©ment des longueurs de <code>n</code> vecteurs de nombres complexes. <br></li><li>  Multiplication par √©l√©ment des longueurs de <code>n</code> vecteurs complexes. <br></li><li>  Faire pivoter (dans le contexte du <code>circshift</code> ) les √©l√©ments d'un vecteur. <br></li><li>  Appariement int√©gr√© des √©l√©ments vectoriels. <br></li></ul><br>  Le param√®tre <code>n</code> d√©pend du niveau de s√©curit√© et de pr√©cision souhait√© et est g√©n√©ralement assez √©lev√©.  Dans notre exemple, il sera √©gal √† 4096 (une valeur plus √©lev√©e augmente la s√©curit√©, mais est √©galement plus difficile dans les calculs, elle √©volue approximativement comme <code>n log n</code> ). <br><br>  De plus, les calculs utilisant CKKS sont <i>bruyants</i> .  Par cons√©quent, les r√©sultats sont approximatifs et il faut veiller √† ce que les r√©sultats soient √©valu√©s avec une pr√©cision suffisante pour ne pas affecter l'exactitude du r√©sultat. <br><br>  D'un autre c√¥t√©, de telles restrictions ne sont pas inhabituelles pour les d√©veloppeurs de packages d'apprentissage automatique.  Des acc√©l√©rateurs sp√©ciaux comme le GPU fonctionnent √©galement g√©n√©ralement avec des vecteurs num√©riques.  De plus, pour de nombreux d√©veloppeurs, les nombres √† virgule flottante semblent parfois bruyants en raison de l'influence des algorithmes de s√©lection, du multithreading, etc.  Je tiens √† souligner que la principale diff√©rence ici est que les calculs arithm√©tiques avec des nombres √† virgule flottante sont initialement d√©terministes, m√™me si cela n'est pas √©vident en raison de la complexit√© de la mise en ≈ìuvre, bien que les primitives CKKS soient vraiment bruyantes.  Mais cela permet peut-√™tre aux utilisateurs de comprendre que le bruit n'est pas aussi effrayant qu'il n'y para√Æt. <br><br>  Voyons maintenant comment vous pouvez effectuer ces op√©rations dans Julia (remarque: des param√®tres tr√®s dangereux sont s√©lectionn√©s, avec ces op√©rations, nous n'illustrons que l'utilisation de la biblioth√®que dans REPL). <br><br><pre> <code class="julia hljs">julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ToyFHE <span class="hljs-comment"><span class="hljs-comment"># Let's play with 8 element vectors julia&gt; N = 8; # Choose some parameters - we'll talk about it later julia&gt; ‚Ñõ = NegacyclicRing(2N, (40, 40, 40)) ‚Ñ§‚ÇÅ‚ÇÉ‚ÇÇ‚Çâ‚ÇÇ‚ÇÇ‚Çá‚Çâ‚Çâ‚Çá‚ÇÖ‚ÇÜ‚Çà‚ÇÄ‚Çà‚ÇÅ‚ÇÑ‚ÇÖ‚Çá‚ÇÑ‚ÇÄ‚ÇÇ‚Çá‚ÇÄ‚ÇÅ‚ÇÇ‚ÇÄ‚Çá‚ÇÅ‚ÇÄ‚ÇÑ‚ÇÇ‚ÇÑ‚Çà‚ÇÇ‚ÇÖ‚Çá/(x¬π‚Å∂ + 1) # We'll use CKKS julia&gt; params = CKKSParams(‚Ñõ) CKKS parameters # We need to pick a scaling factor for a numbers - again we'll talk about that later julia&gt; Tscale = FixedRational{2^40} FixedRational{1099511627776,T} where T # Let's start with a plain Vector of zeros julia&gt; plain = CKKSEncoding{Tscale}(zero(‚Ñõ)) 8-element CKKSEncoding{FixedRational{1099511627776,T} where T} with indices 0:7: 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im # Ok, we're ready to get started, but first we'll need some keys julia&gt; kp = keygen(params) CKKS key pair julia&gt; kp.priv CKKS private key julia&gt; kp.pub CKKS public key # Alright, let's encrypt some things: julia&gt; foreach(i-&gt;plain[i] = i+1, 0:7); plain 8-element CKKSEncoding{FixedRational{1099511627776,T} where T} with indices 0:7: 1.0 + 0.0im 2.0 + 0.0im 3.0 + 0.0im 4.0 + 0.0im 5.0 + 0.0im 6.0 + 0.0im 7.0 + 0.0im 8.0 + 0.0im julia&gt; c = encrypt(kp.pub, plain) CKKS ciphertext (length 2, encoding CKKSEncoding{FixedRational{1099511627776,T} where T}) # And decrypt it again julia&gt; decrypt(kp.priv, c) 8-element CKKSEncoding{FixedRational{1099511627776,T} where T} with indices 0:7: 0.9999999999995506 - 2.7335193113350057e-16im 1.9999999999989408 - 3.885780586188048e-16im 3.000000000000205 + 1.6772825551165524e-16im 4.000000000000538 - 3.885780586188048e-16im 4.999999999998865 + 8.382500573679615e-17im 6.000000000000185 + 4.996003610813204e-16im 7.000000000001043 - 2.0024593503998215e-16im 8.000000000000673 + 4.996003610813204e-16im # Note that we had some noise. Let's go through all the primitive operations we'll need: julia&gt; decrypt(kp.priv, c+c) 8-element CKKSEncoding{FixedRational{1099511627776,T} where T} with indices 0:7: 1.9999999999991012 - 5.467038622670011e-16im 3.9999999999978817 - 7.771561172376096e-16im 6.00000000000041 + 3.354565110233105e-16im 8.000000000001076 - 7.771561172376096e-16im 9.99999999999773 + 1.676500114735923e-16im 12.00000000000037 + 9.992007221626409e-16im 14.000000000002085 - 4.004918700799643e-16im 16.000000000001346 + 9.992007221626409e-16im julia&gt; csq = c*c CKKS ciphertext (length 3, encoding CKKSEncoding{FixedRational{1208925819614629174706176,T} where T}) julia&gt; decrypt(kp.priv, csq) 8-element CKKSEncoding{FixedRational{1208925819614629174706176,T} where T} with indices 0:7: 0.9999999999991012 - 2.350516767363621e-15im 3.9999999999957616 - 5.773159728050814e-15im 9.000000000001226 - 2.534464540987068e-15im 16.000000000004306 - 2.220446049250313e-15im 24.99999999998865 + 2.0903753311370056e-15im 36.00000000000222 + 4.884981308350689e-15im 49.000000000014595 + 1.0182491378134327e-15im 64.00000000001077 + 4.884981308350689e-15im</span></span></code> </pre> <br>  Si simple!  Un lecteur attentif peut remarquer que CSQ est l√©g√®rement diff√©rent du texte chiffr√© pr√©c√©dent.  En particulier, le texte chiffr√© a une ¬´longueur 3¬ª et l'√©chelle est beaucoup plus grande.  Une explication de ce que c'est et de ce qui est n√©cessaire d√©passe le cadre de cet article.  Il suffit de dire que nous devons baisser les valeurs avant de poursuivre les calculs, sinon le "lieu" se terminera dans le texte chiffr√©.  Heureusement, nous pouvons r√©duire chacune des deux valeurs augment√©es: <br><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment"># To get back down to length 2, we need to `keyswitch` (aka # relinerarize), which requires an evaluation key. Generating # this requires the private key. In a real application we would # have generated this up front and sent it along with the encrypted # data, but since we have the private key, we can just do it now. julia&gt; ek = keygen(EvalMultKey, kp.priv) CKKS multiplication key julia&gt; csq_length2 = keyswitch(ek, csq) CKKS ciphertext (length 2, encoding CKKSEncoding{FixedRational{1208925819614629174706176,T} where T}) # Getting the scale back down is done using modswitching. julia&gt; csq_smaller = modswitch(csq_length2) CKKS ciphertext (length 2, encoding CKKSEncoding{FixedRational{1.099511626783e12,T} where T}) # And it still decrypts correctly (though note we've lost some precision) julia&gt; decrypt(kp.priv, csq_smaller) 8-element CKKSEncoding{FixedRational{1.099511626783e12,T} where T} with indices 0:7: 0.9999999999802469 - 5.005163520332181e-11im 3.9999999999957723 - 1.0468514951188039e-11im 8.999999999998249 - 4.7588542623100616e-12im 16.000000000023014 - 1.0413447889166631e-11im 24.999999999955193 - 6.187833723406491e-12im 36.000000000002345 + 1.860733715346631e-13im 49.00000000001647 - 1.442396043149794e-12im 63.999999999988695 - 1.0722489563648028e-10im</span></span></code> </pre> <br>  De plus, la commutation de modules (abr√©viation de commutation de module, commutation de module) r√©duit la taille du module de texte chiffr√©, nous ne pouvons donc pas continuer √† le faire ind√©finiment (nous utilisons un sch√©ma de cryptage quelque peu homomorphique): <br><br><pre> <code class="julia hljs">julia&gt; ‚Ñõ <span class="hljs-comment"><span class="hljs-comment"># Remember the ring we initially created ‚Ñ§‚ÇÅ‚ÇÉ‚ÇÇ‚Çâ‚ÇÇ‚ÇÇ‚Çá‚Çâ‚Çâ‚Çá‚ÇÖ‚ÇÜ‚Çà‚ÇÄ‚Çà‚ÇÅ‚ÇÑ‚ÇÖ‚Çá‚ÇÑ‚ÇÄ‚ÇÇ‚Çá‚ÇÄ‚ÇÅ‚ÇÇ‚ÇÄ‚Çá‚ÇÅ‚ÇÄ‚ÇÑ‚ÇÇ‚ÇÑ‚Çà‚ÇÇ‚ÇÖ‚Çá/(x¬π‚Å∂ + 1) julia&gt; ToyFHE.ring(csq_smaller) # It shrunk! ‚Ñ§‚ÇÅ‚ÇÇ‚ÇÄ‚Çà‚Çâ‚ÇÇ‚ÇÖ‚Çà‚ÇÇ‚ÇÄ‚ÇÅ‚ÇÑ‚ÇÑ‚ÇÖ‚Çâ‚ÇÉ‚Çá‚Çá‚Çâ‚ÇÉ‚ÇÉ‚ÇÅ‚ÇÖ‚ÇÖ‚ÇÉ/(x¬π‚Å∂ + 1)&lt;/code&gt;     ‚Äî  (rotations).      keyswitch,       (evaluation key,     ): &lt;source lang="julia"&gt;julia&gt; gk = keygen(GaloisKey, kp.priv; steps=2) CKKS galois key (element 25) julia&gt; decrypt(circshift(c, gk)) decrypt(kp, circshift(c, gk)) 8-element CKKSEncoding{FixedRational{1099511627776,T} where T} with indices 0:7: 7.000000000001042 + 5.68459112632516e-16im 8.000000000000673 + 5.551115123125783e-17im 0.999999999999551 - 2.308655353580721e-16im 1.9999999999989408 + 2.7755575615628914e-16im 3.000000000000205 - 6.009767921608429e-16im 4.000000000000538 + 5.551115123125783e-17im 4.999999999998865 + 4.133860996136768e-17im 6.000000000000185 - 1.6653345369377348e-16im # And let's compare to doing the same on the plaintext julia&gt; circshift(plain, 2) 8-element OffsetArray(::Array{Complex{Float64},1}, 0:7) with eltype Complex{Float64} with indices 0:7: 7.0 + 0.0im 8.0 + 0.0im 1.0 + 0.0im 2.0 + 0.0im 3.0 + 0.0im 4.0 + 0.0im 5.0 + 0.0im 6.0 + 0.0im</span></span></code> </pre> <br>  Nous avons couvert les bases de l'utilisation de la biblioth√®que HE.  Mais avant de passer √† l'utilisation de ces primitives pour calculer les pr√©visions du r√©seau de neurones, regardons le processus d'apprentissage. <br><br><h2>  Mod√®le d'apprentissage automatique </h2><br>  Si vous n'√™tes pas familier avec l'apprentissage automatique ou la biblioth√®que Flux.jl, je vous recommande de parcourir rapidement la <a href="https://fluxml.ai/Flux.jl/stable/">documentation de Flux.jl</a> ou de voir une <a href="https://juliaacademy.com/p/introduction-to-machine-learning">introduction</a> gratuite <a href="https://juliaacademy.com/p/introduction-to-machine-learning">√† l'apprentissage automatique</a> , car nous ne discuterons que des modifications apport√©es √† l'application du mod√®le aux donn√©es chiffr√©es. <br><br>  Commen√ßons par utiliser le r√©seau <a href="">de</a> neurones convolutifs <a href="">du zoo Flux</a> .  Nous allons effectuer le m√™me cycle de formation, avec la pr√©paration des donn√©es et ainsi de suite, il suffit de configurer un peu le mod√®le.  Le voici: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> reshape_and_vcat(x) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y=reshape(x, <span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, size(x, <span class="hljs-number"><span class="hljs-number">4</span></span>)) vcat((y[:,i,:] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i=axes(y,<span class="hljs-number"><span class="hljs-number">2</span></span>))...) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> model = Chain( <span class="hljs-comment"><span class="hljs-comment"># First convolution, operating upon a 28x28 image Conv((7, 7), 1=&gt;4, stride=(3,3), x-&gt;x.^2), reshape_and_vcat, Dense(256, 64, x-&gt;x.^2), Dense(64, 10), )</span></span></code> </pre><br>  Il s'agit du m√™me mod√®le que dans le travail <a href="https://eprint.iacr.org/2018/1041.pdf">¬´Secure Outsourced Matrix Computation and Application to Neural Networks¬ª</a> , qui utilise le m√™me sch√©ma cryptographique avec deux diff√©rences: 1) pour des raisons de simplicit√©, nous n'avons pas chiffr√© le mod√®le lui-m√™me, et 2) apr√®s chaque couche que nous avons Des vecteurs bay√©siens sont utilis√©s (dans Flux, cela se fait par d√©faut), je ne sais pas ce que c'√©tait dans le travail mentionn√©.  Peut-√™tre, en raison du deuxi√®me point, la pr√©cision sur l'ensemble de test de notre mod√®le s'est av√©r√©e √™tre l√©g√®rement plus √©lev√©e (98,6% contre 98,1%), mais des diff√©rences hyperparam√©triques pourraient √©galement √™tre la raison. <br><br>  L'activation des fonctions <code>x.^2</code> est inhabituelle (pour ceux qui ont de l'exp√©rience en apprentissage automatique).  Le plus souvent, dans de tels cas, ils utilisent le <code>tanh</code> , le <code>relu</code> ou quelque chose de plus fantaisiste.  Mais bien que ces fonctions (en particulier <code>relu</code> ) soient facilement calcul√©es pour les valeurs de texte ordinaires, cependant, elles peuvent n√©cessiter beaucoup de ressources informatiques pour les √©valuer sous forme crypt√©e (nous estimons g√©n√©ralement l'approximation polynomiale).  Heureusement, dans ce cas, <code>x.^2</code> fonctionne tr√®s bien. <br><br>  Le reste du cycle d'apprentissage est rest√© le m√™me.  Nous avons supprim√© <code>softmax</code> du mod√®le pour la fonction de perte de <code>logitcrossentropy</code> (vous pouvez le laisser et √©valuer softmax apr√®s d√©cryptage sur le client).  Le code complet pour la formation du mod√®le se trouve <a href="">sur GitHub</a> , il s'ex√©cute en quelques minutes sur n'importe quelle nouvelle carte vid√©o. <br><br><h2>  Op√©rations efficaces </h2><br>  Nous savons maintenant quelles op√©rations nous devons effectuer: <br><br><ul><li>  Coagulation. <br></li><li>  √âl√©ment au carr√©. <br></li><li>  Multiplication matricielle. <br></li></ul><br>  Avec la quadrature, tout est simple, nous l'avons d√©j√† examin√© ci-dessus, nous allons donc consid√©rer deux autres op√©rations.  Nous supposons que la longueur du paquet de donn√©es est de 64 (vous remarquerez peut-√™tre que les param√®tres du mod√®le et la taille du paquet sont choisis de mani√®re √† tirer parti du vecteur √† 4096 √©l√©ments que nous avons obtenu √† la suite d'un choix r√©aliste de param√®tres). <br><br><h3>  La coagulation </h3><br>  Rappelez-vous comment fonctionne la coagulation.  Prenez une fen√™tre (dans notre cas 7x7) du tableau d'entr√©e d'origine, et chaque √©l√©ment de fen√™tre est multipli√© par un √©l√©ment de masque de convolution.  Ensuite, nous d√©pla√ßons la fen√™tre √† une √©tape (dans notre cas, l'√©tape est 3, c'est-√†-dire que nous d√©pla√ßons 3 √©l√©ments) et r√©p√©tons le processus (avec le m√™me masque de convolution).  L'animation du processus ( <a href="https://github.com/vdumoulin/conv_arithmetic">source</a> ) pour la convolution 3x3 avec l'√©tape <code>(2, 2)</code> montr√©e ci-dessous (tableau bleu - entr√©e, vert - sortie): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h5/a3/q3/h5a3q3ea0pljgdagz1wd-k2igdy.gif"></div><br>  De plus, nous effectuons la convolution dans quatre ¬´canaux¬ª diff√©rents (c'est-√†-dire que nous r√©p√©tons la convolution 3 fois de plus avec des masques diff√©rents). <br><br>  Maintenant que nous savons quoi faire, il reste √† comprendre comment.  Nous avons la chance que la convolution soit la premi√®re op√©ration de notre mod√®le.  Par cons√©quent, afin d'√©conomiser des ressources, nous pouvons pr√©traiter les donn√©es sur le client, puis les chiffrer (sans utiliser de poids).  Faisons √ßa: <br><br><ul><li>  Tout d'abord, nous calculons chaque fen√™tre de convolution (c'est-√†-dire un √©chantillon 7x7 √† partir des images source), ce qui nous donne 64 matrices 7x7 pour chaque image d'entr√©e.  Notez que pour une fen√™tre 7x7 par incr√©ments de 2, il y aura des fen√™tres de convolution 8x8 pour √©valuer l'image d'entr√©e 28x28. <br></li><li>  Collectons dans un vecteur les m√™mes positions dans chaque fen√™tre.  Autrement dit, pour chaque image, nous aurons un vecteur √† 64 √©l√©ments, ou un vecteur d'√©l√©ments 64x64 pour un paquet de taille 64 (un total de 49 matrices 64x64). <br></li><li>  Nous crypterons. <br></li></ul><br>  La coagulation se transforme alors simplement en une multiplication scalaire de la matrice enti√®re avec l'√©l√©ment de masque correspondant.  Et en r√©sumant plus tard les 49 √©l√©ments, nous obtenons le r√©sultat du pliage.  Voici √† quoi pourrait ressembler la mise en ≈ìuvre de cette strat√©gie (en texte brut): <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> public_preprocess(batch) ka = OffsetArray(<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">7</span></span>) <span class="hljs-comment"><span class="hljs-comment"># Create feature extracted matrix I = [[batch[i‚Ä≤*3 .+ (1:7), j‚Ä≤*3 .+ (1:7), 1, k] for i‚Ä≤=ka, j‚Ä≤=ka] for k = 1:64] # Reshape into the ciphertext I·µ¢‚±º = [[I[k][l...][i,j] for k=1:64, l=product(ka, ka)] for i=1:7, j=1:7] end I·µ¢‚±º = public_preprocess(batch) # Evaluate the convolution weights = model.layers[1].weight conv_weights = reverse(reverse(weights, dims=1), dims=2) conved = [sum(I·µ¢‚±º[i,j]*conv_weights[i,j,1,channel] for i=1:7, j=1:7) for channel = 1:4] conved = map(((x,b),)-&gt;x .+ b, zip(conved, model.layers[1].bias))</span></span></code> </pre> <br>  Ce (module pour changer la dimension) (modulo - changer l'ordre des tailles) donne la m√™me r√©ponse que l'op√©ration <code>model.layers[1](batch)</code> . <br><br>  Ajoutez des op√©rations de chiffrement: <br><br><pre> <code class="julia hljs">I·µ¢‚±º = public_preprocess(batch) C_I·µ¢‚±º = map(I·µ¢‚±º) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Iij plain = CKKSEncoding{Tscale}(zero(plaintext_space(ckks_params))) plain .= OffsetArray(vec(Iij), <span class="hljs-number"><span class="hljs-number">0</span></span>:(N√∑<span class="hljs-number"><span class="hljs-number">2</span></span>-<span class="hljs-number"><span class="hljs-number">1</span></span>)) encrypt(kp, plain) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> weights = model.layers[<span class="hljs-number"><span class="hljs-number">1</span></span>].weight conv_weights = reverse(reverse(weights, dims=<span class="hljs-number"><span class="hljs-number">1</span></span>), dims=<span class="hljs-number"><span class="hljs-number">2</span></span>) conved3 = [sum(C_I·µ¢‚±º[i,j]*conv_weights[i,j,<span class="hljs-number"><span class="hljs-number">1</span></span>,channel] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">7</span></span>, j=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">7</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> channel = <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>] conved2 = map(((x,b),)-&gt;x .+ b, zip(conved3, model.layers[<span class="hljs-number"><span class="hljs-number">1</span></span>].bias)) conved1 = map(ToyFHE.modswitch, conved2)</code> </pre> <br>  Veuillez noter que l'interrupteur √† cl√© n'est pas requis ici car les poids sont publics.  Nous n'augmentons donc pas la longueur du texte chiffr√©. <br><br><h3>  Multiplication matricielle </h3><br>  Passant √† la multiplication matricielle, nous pouvons utiliser la rotation des √©l√©ments dans le vecteur pour changer l'ordre des indices de multiplication.  Envisagez le placement en ligne des √©l√©ments de matrice dans un vecteur.  Si nous d√©calons le vecteur d'un multiple de la taille de la ligne, nous obtenons l'effet de la rotation des colonnes, qui est une primitive suffisante pour impl√©menter la multiplication matricielle (au moins les matrices carr√©es).  Essayons: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> matmul_square_reordered(weights, x) sum(<span class="hljs-number"><span class="hljs-number">1</span></span>:size(weights, <span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> k <span class="hljs-comment"><span class="hljs-comment"># We rotate the columns of the LHS and take the diagonal weight_diag = diag(circshift(weights, (0,(k-1)))) # We rotate the rows of the RHS x_rotated = circshift(x, (k-1,0)) # We do an elementwise, broadcast multiply weight_diag .* x_rotated end end function matmul_reorderd(weights, x) sum(partition(1:256, 64)) do range matmul_square_reordered(weights[:, range], x[range, :]) end end fc1_weights = model.layers[3].W x = rand(Float64, 256, 64) @assert (fc1_weights*x) ‚âà matmul_reorderd(fc1_weights, x)</span></span></code> </pre> <br>  Bien s√ªr, pour la multiplication matricielle g√©n√©rale, quelque chose de plus compliqu√© est n√©cessaire, mais pour l'instant cela suffit. <br><br><h2>  Am√©liorer la technique </h2><br>  Maintenant, tous les composants de notre technique fonctionnent.  Voici le code entier (sauf pour d√©finir les options de s√©lection et des choses similaires): <br><br><pre> <code class="julia hljs">ek = keygen(EvalMultKey, kp.priv) gk = keygen(GaloisKey, kp.priv; steps=<span class="hljs-number"><span class="hljs-number">64</span></span>) I·µ¢‚±º = public_preprocess(batch) C_I·µ¢‚±º = map(I·µ¢‚±º) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Iij plain = CKKSEncoding{Tscale}(zero(plaintext_space(ckks_params))) plain .= OffsetArray(vec(Iij), <span class="hljs-number"><span class="hljs-number">0</span></span>:(N√∑<span class="hljs-number"><span class="hljs-number">2</span></span>-<span class="hljs-number"><span class="hljs-number">1</span></span>)) encrypt(kp, plain) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> weights = model.layers[<span class="hljs-number"><span class="hljs-number">1</span></span>].weight conv_weights = reverse(reverse(weights, dims=<span class="hljs-number"><span class="hljs-number">1</span></span>), dims=<span class="hljs-number"><span class="hljs-number">2</span></span>) conved3 = [sum(C_I·µ¢‚±º[i,j]*conv_weights[i,j,<span class="hljs-number"><span class="hljs-number">1</span></span>,channel] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">7</span></span>, j=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">7</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> channel = <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>] conved2 = map(((x,b),)-&gt;x .+ b, zip(conved3, model.layers[<span class="hljs-number"><span class="hljs-number">1</span></span>].bias)) conved1 = map(ToyFHE.modswitch, conved2) Csqed1 = map(x-&gt;x*x, conved1) Csqed1 = map(x-&gt;keyswitch(ek, x), Csqed1) Csqed1 = map(ToyFHE.modswitch, Csqed1) <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> encrypted_matmul(gk, weights, x::ToyFHE.CipherText) result = repeat(diag(weights), inner=<span class="hljs-number"><span class="hljs-number">64</span></span>).*x rotated = x <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k = <span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">64</span></span> rotated = ToyFHE.rotate(gk, rotated) result += repeat(diag(circshift(weights, (<span class="hljs-number"><span class="hljs-number">0</span></span>,(k-<span class="hljs-number"><span class="hljs-number">1</span></span>)))), inner=<span class="hljs-number"><span class="hljs-number">64</span></span>) .* rotated <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> fq1_weights = model.layers[<span class="hljs-number"><span class="hljs-number">3</span></span>].W Cfq1 = sum(enumerate(partition(<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">256</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> (i,range) encrypted_matmul(gk, fq1_weights[:, range], Csqed1[i]) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> Cfq1 = Cfq1 .+ OffsetArray(repeat(model.layers[<span class="hljs-number"><span class="hljs-number">3</span></span>].b, inner=<span class="hljs-number"><span class="hljs-number">64</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">4095</span></span>) Cfq1 = modswitch(Cfq1) Csqed2 = Cfq1*Cfq1 Csqed2 = keyswitch(ek, Csqed2) Csqed2 = modswitch(Csqed2) <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> naive_rectangular_matmul(gk, weights, x) <span class="hljs-meta"><span class="hljs-meta">@assert</span></span> size(weights, <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt; size(weights, <span class="hljs-number"><span class="hljs-number">2</span></span>) weights = vcat(weights, zeros(eltype(weights), size(weights, <span class="hljs-number"><span class="hljs-number">2</span></span>)-size(weights, <span class="hljs-number"><span class="hljs-number">1</span></span>), size(weights, <span class="hljs-number"><span class="hljs-number">2</span></span>))) encrypted_matmul(gk, weights, x) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> fq2_weights = model.layers[<span class="hljs-number"><span class="hljs-number">4</span></span>].W Cresult = naive_rectangular_matmul(gk, fq2_weights, Csqed2) Cresult = Cresult .+ OffsetArray(repeat(vcat(model.layers[<span class="hljs-number"><span class="hljs-number">4</span></span>].b, zeros(<span class="hljs-number"><span class="hljs-number">54</span></span>)), inner=<span class="hljs-number"><span class="hljs-number">64</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">4095</span></span>)</code> </pre> <br>  Cela n'a pas l'air trop soign√©, mais si vous avez fait tout cela, vous devez comprendre chaque √©tape. <br>  R√©fl√©chissons maintenant aux abstractions qui pourraient simplifier nos vies.  Nous quittons le domaine de la cartographie et du machine learning et passons √† l'architecture du langage de programmation, profitons donc du fait que Julia vous permet d'utiliser et de cr√©er des abstractions puissantes.  Par exemple, vous pouvez encapsuler l'ensemble du processus d'extraction des convolutions dans votre type de tableau: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BlockArrays <span class="hljs-string"><span class="hljs-string">""" ExplodedConvArray{T, Dims, Storage} &lt;: AbstractArray{T, 4} Represents a an `nxmx1xb` array of images, but rearranged into a series of convolution windows. Evaluating a convolution compatible with `Dims` on this array is achievable through a sequence of scalar multiplications and sums on the underling storage. """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ExplodedConvArray{T, <span class="hljs-built_in"><span class="hljs-built_in">Dims</span></span>, Storage} &lt;: <span class="hljs-built_in"><span class="hljs-built_in">AbstractArray</span></span>{T, <span class="hljs-number"><span class="hljs-number">4</span></span>} <span class="hljs-comment"><span class="hljs-comment"># sx*sy matrix of b*(dx*dy) matrices of extracted elements # where (sx, sy) = kernel_size(Dims) # (dx, dy) = output_size(DenseConvDims(...)) cdims::Dims x::Matrix{Storage} function ExplodedConvArray{T, Dims, Storage}(cdims::Dims, storage::Matrix{Storage}) where {T, Dims, Storage} @assert all(==(size(storage[1])), size.(storage)) new{T, Dims, Storage}(cdims, storage) end end Base.size(ex::ExplodedConvArray) = (NNlib.input_size(ex.cdims)..., 1, size(ex.x[1], 1)) function ExplodedConvArray{T}(cdims, batch::AbstractArray{T, 4}) where {T} x, y = NNlib.output_size(cdims) kx, ky = NNlib.kernel_size(cdims) stridex, stridey = NNlib.stride(cdims) kax = OffsetArray(0:x-1, 0:x-1) kay = OffsetArray(0:x-1, 0:x-1) I = [[batch[i‚Ä≤*stridex .+ (1:kx), j‚Ä≤*stridey .+ (1:ky), 1, k] for i‚Ä≤=kax, j‚Ä≤=kay] for k = 1:size(batch, 4)] I·µ¢‚±º = [[I[k][l...][i,j] for k=1:size(batch, 4), l=product(kax, kay)] for (i,j) in product(1:kx, 1:ky)] ExplodedConvArray{T, typeof(cdims), eltype(I·µ¢‚±º)}(cdims, I·µ¢‚±º) end function NNlib.conv(x::ExplodedConvArray{&lt;:Any, Dims}, weights::AbstractArray{&lt;:Any, 4}, cdims::Dims) where {Dims&lt;:ConvDims} blocks = reshape([ Base.ReshapedArray(sum(xx[i,j]*weights[i,j,1,channel] for i=1:7, j=1:7), (NNlib.output_size(cdims)...,1,size(x, 4)), ()) for channel = 1:4 ],(1,1,4,1)) BlockArrays._BlockArray(blocks, BlockArrays.BlockSizes([8], [8], [1,1,1,1], [64])) end</span></span></code> </pre><br>  Ici, nous avons de nouveau utilis√© <code>BlockArrays</code> pour repr√©senter un tableau <code>8x8x4x64</code> comme quatre tableaux <code>8x8x1x64</code> comme dans le code source.  Maintenant, la pr√©sentation de la premi√®re √©tape est devenue beaucoup plus belle, au moins avec des tableaux non chiffr√©s: <br><br><pre> <code class="julia hljs">julia&gt; cdims = DenseConvDims(batch, model.layers[<span class="hljs-number"><span class="hljs-number">1</span></span>].weight; stride=(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>), padding=(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>), dilation=(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) DenseConvDims: (<span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) * (<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>) -&gt; (<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), stride: (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) pad: (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), dil: (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), flip: <span class="hljs-literal"><span class="hljs-literal">false</span></span> julia&gt; a = ExplodedConvArray{eltype(batch)}(cdims, batch); julia&gt; model(a) <span class="hljs-number"><span class="hljs-number">10</span></span>√ó<span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Float32</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>}: [snip]</code> </pre><br>  Maintenant, comment pouvons-nous connecter cela avec le cryptage?  Pour ce faire, vous avez besoin de: <br><br><ol><li>  Chiffrez la structure ( <code>ExplodedConvArray</code> ) afin que nous obtenions le texte chiffr√© pour chaque champ.  Les op√©rations avec une telle structure crypt√©e v√©rifieront ce que la fonction ferait avec la structure d'origine et feront la m√™me chose de mani√®re homomorphe. <br></li><li>  Intercepter certaines op√©rations afin de les effectuer diff√©remment dans un contexte chiffr√©. </li></ol><br>  Heureusement, Julia nous fournit une abstraction pour cela: un plugin de compilation qui utilise le m√©canisme <a href="">Cassette.jl</a> .  Je ne vous dirai pas ce que c'est et comment cela fonctionne, je dirai bri√®vement qu'il peut d√©terminer le contexte, par exemple, <code>Encrypted</code> , puis il d√©finit les r√®gles de fonctionnement des op√©rations dans ce contexte.  Par exemple, vous pouvez √©crire ceci pour la deuxi√®me exigence: <br><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment"># Define Matrix multiplication between an array and an encrypted block array function (*::Encrypted{typeof(*)})(a::Array{T, 2}, b::Encrypted{&lt;:BlockArray{T, 2}}) where {T} sum(a*b for (i,range) in enumerate(partition(1:size(a, 2), size(b.blocks[1], 1)))) end # Define Matrix multiplication between an array and an encrypted array function (*::Encrypted{typeof(*)})(a::Array{T, 2}, b::Encrypted{Array{T, 2}}) where {T} result = repeat(diag(a), inner=size(a, 1)).*x rotated = b for k = 2:size(a, 2) rotated = ToyFHE.rotate(GaloisKey(*), rotated) result += repeat(diag(circshift(a, (0,(k-1)))), inner=size(a, 1)) .* rotated end result end</span></span></code> </pre><br>  En cons√©quence, l'utilisateur pourra √©crire tout ce qui pr√©c√®de avec un minimum de travail manuel: <br><br><pre> <code class="julia hljs">kp = keygen(ckks_params) ek = keygen(EvalMultKey, kp.priv) gk = keygen(GaloisKey, kp.priv; steps=<span class="hljs-number"><span class="hljs-number">64</span></span>) <span class="hljs-comment"><span class="hljs-comment"># Create evaluation context ctx = Encrypted(ek, gk) # Do public preprocessing batch = ExplodedConvArray{eltype(batch)}(cdims, batch); # Run on encrypted data under the encryption context Cresult = ctx(model)(encrypt(kp.pub, batch)) # Decrypt the answer decrypt(kp, Cresult)</span></span></code> </pre> <br> ,     .   (   ‚Ñõ,   modswitch, keyswitch  ..)       ,      .  ,    ,    ,         ,        . <br><br><h2>  Conclusion </h2><br>          ‚Äî      .     Julia          .  RAMPARTS ( <a href="https://eprint.iacr.org/2019/988.pdf">paper</a> , <a href="https://www.youtube.com/watch%3Fv%3D_KLlMg6jKQg">JuliaCon talk</a> )       :  Julia-   -  PALISADE. Julia Computing    RAMPARTS    Verona, <a href="https://galois.com/news/15m-iarpa-hector-contract-privacy-preserving-technology/"> </a>     .             ,     .  .     ,   ,          . <br><br>        ,   <a href=""> ToyFHE</a> .   <a href="https://juliacomputing.github.io/ToyFHE.jl/dev/man/background/"></a> , ,   ,         . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr478514/">https://habr.com/ru/post/fr478514/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr478498/index.html">1. Mise en route de Fortinet v 6.0. Pr√©sentation</a></li>
<li><a href="../fr478500/index.html">Pourquoi y a-t-il si peu de conf√©rences en √©t√©?</a></li>
<li><a href="../fr478502/index.html">Une technologie intelligente pour tous</a></li>
<li><a href="../fr478508/index.html">T√©l√©gramme en tant que service</a></li>
<li><a href="../fr478510/index.html">Nous vous invitons √† DINS QA EVENING 12/12/19: cr√©ez un Jenkins Pipeline et apprenez comment parall√©liser le lancement des tests avec leur aide</a></li>
<li><a href="../fr478518/index.html">Exp√©rience du d√©ploiement d'infrastructures de bureau sur Zextras / Zimbra OSE</a></li>
<li><a href="../fr478522/index.html">Admettez-le, Watson, √™tes-vous compl√®tement d√©concert√©?</a></li>
<li><a href="../fr478526/index.html">Un tas d'OpenVPN sur Windows Server et Mikrotik avec la migration de ce truc vers Linux</a></li>
<li><a href="../fr478528/index.html">Pet (une histoire fantastique)</a></li>
<li><a href="../fr478530/index.html">TechnoText-2019: qui a finalement gagn√© et √† quoi ils servaient</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>