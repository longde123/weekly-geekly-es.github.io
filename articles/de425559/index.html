<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∞üèª üßî üåßÔ∏è MIT-Kurs "Computer Systems Security". Vorlesung 10: Symbolische Ausf√ºhrung, Teil 3 üë®üèæ‚Äçü§ù‚Äçüë®üèº üêõ üò∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Massachusetts Institute of Technology. Vorlesung # 6.858. "Sicherheit von Computersystemen." Nikolai Zeldovich, James Mickens. 2014 Jahr 
 Computer Sy...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MIT-Kurs "Computer Systems Security". Vorlesung 10: Symbolische Ausf√ºhrung, Teil 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/425559/"><h3>  Massachusetts Institute of Technology.  Vorlesung # 6.858.  "Sicherheit von Computersystemen."  Nikolai Zeldovich, James Mickens.  2014 Jahr </h3><br>  Computer Systems Security ist ein Kurs zur Entwicklung und Implementierung sicherer Computersysteme.  Die Vortr√§ge behandeln Bedrohungsmodelle, Angriffe, die die Sicherheit gef√§hrden, und Sicherheitstechniken, die auf j√ºngsten wissenschaftlichen Arbeiten basieren.  Zu den Themen geh√∂ren Betriebssystemsicherheit, Funktionen, Informationsflussmanagement, Sprachsicherheit, Netzwerkprotokolle, Hardwaresicherheit und Sicherheit von Webanwendungen. <br><br>  Vorlesung 1: ‚ÄûEinf√ºhrung: Bedrohungsmodelle‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 2: ‚ÄûKontrolle von Hackerangriffen‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 3: ‚ÄûPuffer√ºberl√§ufe: Exploits und Schutz‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 4: ‚ÄûTrennung von Privilegien‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 5: ‚ÄûWoher kommen Sicherheitssysteme?‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> <br>  Vorlesung 6: ‚ÄûChancen‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 7: ‚ÄûNative Client Sandbox‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 8: ‚ÄûNetzwerksicherheitsmodell‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 9: ‚ÄûSicherheit von Webanwendungen‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 10: ‚ÄûSymbolische Ausf√ºhrung‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <a name="habracut"></a><br><br>  Wenn wir nun dem Zweig nach unten folgen, sehen wir den Ausdruck t = y.  Da wir jeweils einen Pfad betrachten, m√ºssen wir f√ºr t keine neue Variable einf√ºhren.  Wir k√∂nnen einfach sagen, dass t nicht mehr 0 ist, da t = y ist. <br><br>  Wir bewegen uns weiter nach unten und kommen zu dem Punkt, an dem wir zu einem anderen Zweig gelangen.  Was ist die neue Annahme, die wir treffen m√ºssen, um diesen Weg weiter zu beschreiten?  Dies ist eine Annahme, dass t &lt;y ist. <br><br>  Was ist t?  Wenn Sie den rechten Zweig nachschlagen, sehen wir, dass t = y ist.  Und in unserer Tabelle ist T = y und Y = y.  Daraus folgt logischerweise, dass unsere Einschr√§nkung wie y &lt;y aussieht, was nicht sein kann. <br><br><img src="https://habrastorage.org/webt/tu/pe/kp/tupekplxzar-nappngbqlwuy12y.jpeg"><br><br>  Somit hatten wir alles in Ordnung, bis wir diesen Punkt t &lt;y erreichten.  Bis wir zu der falschen Aussage kommen, haben wir alle Ungleichungen, um richtig zu sein.  Dies funktioniert jedoch nicht, da bei der Ausf√ºhrung von Aufgaben des richtigen Zweigs eine logische Inkonsistenz auftritt. <br><br>  Wir haben das, was oft als Zustand des Pfades bezeichnet wird.  Diese Bedingung muss erf√ºllt sein, damit das Programm diesen Weg einschl√§gt.  Wir wissen jedoch, dass diese Bedingung nicht erf√ºllt werden kann, daher ist es f√ºr das Programm unm√∂glich, diesen Weg zu gehen.  Dieser Weg wurde nun vollst√§ndig beseitigt, und wir wissen, dass dieser richtige Weg nicht zur√ºckgelegt werden kann. <br><br>  Was ist mit dem anderen Weg?  Versuchen wir, den linken Zweig auf andere Weise zu durchlaufen.  Was sind die Bedingungen f√ºr diesen Weg?  Wieder beginnt unser symbolischer Zustand bei t = 0 und X und Y sind gleich den Variablen x und y. <br><br><img src="https://habrastorage.org/webt/5a/oo/cc/5aooccskimxeaooehicyxgew8jc.jpeg"><br><br>  Wie sieht die Pfadbeschr√§nkung in diesem Fall jetzt aus?  Wir bezeichnen den linken Zweig als True und den rechten Zweig als False und betrachten weiter den Wert t = x.  Als Ergebnis der logischen Verarbeitung der Bedingungen t = x, x&gt; y und t &lt;y erhalten wir, dass wir gleichzeitig x&gt; y und x &lt;y haben. <br><br><img src="https://habrastorage.org/webt/jz/lz/9e/jzlz9e9yvnbqh7y3wwaowffufuc.jpeg"><br><br>  Es ist klar, dass dieser Zustand des Pfades unbefriedigend ist.  Wir k√∂nnen kein x haben, das sowohl gr√∂√üer als auch kleiner als y ist.  Es gibt keine Zuordnung zu einer Variablen X, die beide Bedingungen erf√ºllt.  Dies zeigt uns also, dass der andere Weg ebenfalls unbefriedigend ist. <br><br>  Es stellt sich heraus, dass wir in diesem Moment alle m√∂glichen Wege im Programm erkundet haben, die uns in diesen Zustand f√ºhren k√∂nnten.  Wir k√∂nnen tats√§chlich feststellen und √ºberpr√ºfen, dass es keinen Weg gibt, der uns zu der Aussage false f√ºhren w√ºrde. <br>  <b>Zielgruppe:</b> In diesem Beispiel haben Sie gezeigt, dass Sie den Fortschritt eines Programms in allen m√∂glichen Branchen untersucht haben.  Einer der Vorteile der symbolischen Ausf√ºhrung besteht jedoch darin, dass wir nicht alle m√∂glichen exponentiellen Pfade untersuchen m√ºssen.  Wie kann man dies in diesem Beispiel vermeiden? <br><br>  <b>Professor:</b> Das ist eine sehr gute Frage.  In diesem Fall gehen Sie einen Kompromiss zwischen der Zeichenausf√ºhrung und der gew√ºnschten Genauigkeit ein.  In diesem Fall verwenden wir weniger die symbolische Ausf√ºhrung als vielmehr das erste Mal, dass wir den Programmablauf in beiden Zweigen gleichzeitig betrachten.  Aber dank dessen sind unsere Einschr√§nkungen sehr, sehr einfach geworden. <br><br>  Die einzelnen Einschr√§nkungen ‚Äûauf eine Weise nach der anderen‚Äú sind sehr einfach, aber Sie m√ºssen dies immer wieder tun, indem Sie alle vorhandenen Zweige und exponentiell - und alle m√∂glichen Wege - studieren. <br>  Es gibt exponentiell viele Pfade, aber f√ºr jeden Pfad als Ganzes gibt es auch einen exponentiell gro√üen Satz von Eingabedaten, die diesen Pfad gehen k√∂nnen.  Dies gibt Ihnen also bereits einen gro√üen Vorteil, denn anstatt alle m√∂glichen Eingaben zu versuchen, versuchen Sie, jeden m√∂glichen Weg zu versuchen.  Aber kannst du etwas besser machen? <br><br>  Dies ist einer der Bereiche, in denen viel experimentiert wurde, beispielsweise in Bezug auf die symbolische Ausf√ºhrung, beispielsweise die gleichzeitige Ausf√ºhrung mehrerer Pfade.  In den Vorlesungsmaterialien haben Sie Heuristiken und eine Reihe von Strategien kennengelernt, mit denen Experimentatoren die Suche l√∂sbarer gemacht haben. <br><br>  Zum Beispiel ist eines der Dinge, die sie tun, dass sie einen Weg nach dem anderen erkunden, dies aber nicht v√∂llig blind tun.  Sie √ºberpr√ºfen die Bedingungen des Pfades nach jedem Schritt.  Angenommen, hier in unserem Programm gibt es anstelle von ‚Äûfalse‚Äú einen komplexen Programmbaum, ein Kontrollflussdiagramm. <br><br><img src="https://habrastorage.org/webt/ly/a_/em/lya_em86ezzhqftrrv247zfdnwq.jpeg"><br><br>  Sie m√ºssen nicht warten, bis Sie das Ende erreicht haben, um zu √ºberpr√ºfen, ob dieser Pfad m√∂glich ist.  In diesem Moment, wenn Sie die Bedingung t &lt;y erreichen, wissen Sie bereits, dass dieser Weg unbefriedigend ist, und Sie werden niemals in diese Richtung gehen.  Das Abschneiden der falschen Zweige zu Beginn des Programms reduziert daher den Aufwand f√ºr empirische Arbeiten.  Eine angemessene Erkundung des Pfades verhindert die M√∂glichkeit eines zuk√ºnftigen Programmfehlers.  Viele der praktischen Werkzeuge, die heute verwendet werden, beginnen haupts√§chlich mit zuf√§lligen Tests, um die ersten Pfade zu erhalten. Danach beginnen sie, die Pfade in der Nachbarschaft zu erkunden.  Sie verarbeiten viele Optionen f√ºr die m√∂gliche Ausf√ºhrung des Programms f√ºr jeden Zweig und fragen sich, was auf diesen Pfaden passiert. <br><br>  Es ist besonders n√ºtzlich, wenn wir eine gute Reihe von Tests haben.  Sie f√ºhren Ihren Test aus und stellen fest, dass dieser Code nicht ausgef√ºhrt wird.  Daher k√∂nnen Sie den Pfad nehmen, der der Implementierung des Codes am n√§chsten kam, und fragen, ob dieser Pfad ge√§ndert werden kann, damit er in die richtige Richtung verl√§uft. <br><br><img src="https://habrastorage.org/webt/ik/26/yz/ik26yz36aargvenedflizgtebnu.jpeg"><br><br>  Aber in dem Moment, in dem Sie versuchen, alle Pfade gleichzeitig zu erstellen, beginnen Einschr√§nkungen, die unl√∂sbar werden.  Daher k√∂nnen Sie jeweils eine Funktion ausf√ºhren, w√§hrend Sie alle Pfade in einer Funktion zusammen lernen k√∂nnen.  Wenn Sie versuchen, gro√üe Bl√∂cke zu erstellen, k√∂nnen Sie im Allgemeinen alle m√∂glichen Wege erkunden. <br><br>  Das Wichtigste ist, dass Sie f√ºr jeden Zweig Ihre Einschr√§nkungen √ºberpr√ºfen und feststellen, ob dieser Zweig wirklich in beide Richtungen gehen kann.  Wenn sie nicht beide Wege gehen kann, sparen Sie Zeit und M√ºhe, indem Sie nicht in die Richtung gehen, in die sie nicht gehen kann.  Au√üerdem erinnere ich mich nicht an die spezifischen Strategien, mit denen sie Wege finden, die mit gr√∂√üerer Wahrscheinlichkeit zu sehr guten Ergebnissen f√ºhren.  Es ist jedoch sehr wichtig, im Anfangsstadium die falschen Zweige abzuschneiden. <br><br>  Bisher haben wir haupts√§chlich √ºber ‚ÄûSpielzeugcode‚Äú gesprochen, √ºber ganzzahlige Variablen, √ºber Zweige, √ºber sehr einfache Dinge.  Aber was passiert, wenn Sie ein komplexeres Programm haben?  Was passiert insbesondere, wenn Sie ein Programm haben, das eine Menge enth√§lt? <br><br><img src="https://habrastorage.org/webt/jh/u9/j0/jhu9j05lzmmvolihvaaluj4tqqe.jpeg"><br><br>  In der Vergangenheit war der H√ºfthaufen der Fluch aller Softwareanalysen, da die sauberen und eleganten Dinge in Fortrans Zeit vollst√§ndig explodieren, wenn Sie versuchen, sie mit C-Programmen auszuf√ºhren, in denen Sie links und rechts Speicher zuweisen.  Dort haben Sie √úberlagerungen und all das Durcheinander, das mit dem Programm verbunden ist, mit zugewiesenem Speicher und mit arithmetischen Zeigern.  Dies ist einer der Bereiche, in denen die symbolische Ausf√ºhrung eine hervorragende F√§higkeit besitzt, √ºber Programme nachzudenken. <br><br>  Wie machen wir das?  Vergessen wir f√ºr einen Moment die Zweige und den Kontrollfluss.  Wir haben hier ein einfaches Programm.  Es reserviert etwas Speicher, macht ihn ung√ºltig und erh√§lt einen neuen Zeiger y vom Zeiger x.  Dann schreibt sie etwas in y und pr√ºft, ob der im Zeiger y gespeicherte Wert dem im Zeiger x gespeicherten Wert entspricht. <br><br>  Basierend auf den Grundkenntnissen von C k√∂nnen Sie sehen, dass diese Pr√ºfung nicht durchgef√ºhrt wird, da x zur√ºckgesetzt wird und y = 25 ist, sodass x einen anderen Ort angibt.  Bisher ist bei uns alles in Ordnung. <br>  Die Art und Weise, wie wir den Heap modellieren und wie der Heap auf den meisten Systemen modelliert wird, verwendet die Heap-Darstellung in C, wo es sich nur um eine gigantische Adressbasis handelt, ein gigantisches Array, in das Sie Ihre Daten einf√ºgen k√∂nnen. <br>  Dies bedeutet, dass wir unser Programm als einen sehr gro√üen globalen Datensatz darstellen k√∂nnen, der als MEM bezeichnet wird.  Dies ist ein Array, das im Wesentlichen Adressen Werten zuordnet.  Eine Adresse ist nur ein 64-Bit-Wert.  Und was passiert, wenn Sie etwas von dieser Adresse gelesen haben?  Dies h√§ngt davon ab, wie Sie den Speicher modellieren. <br><br>  Wenn Sie es auf Byte-Ebene modellieren, erhalten Sie ein Byte.  Wenn Sie es auf Wortebene modellieren, erhalten Sie ein Wort.  Abh√§ngig von der Art der Fehler, an denen Sie interessiert sind, und davon, ob Sie √ºber die Speicherzuordnung besorgt sind oder nicht, werden Sie sie etwas anders modellieren, aber normalerweise ist der Speicher nur ein Array von Adresse zu Wert. <br><br><img src="https://habrastorage.org/webt/ml/5h/u3/ml5hu3rxqhuwkwjute0ykkgzzru.jpeg"><br><br>  Die Adresse ist also nur eine ganze Zahl.  In gewisser Weise spielt es keine Rolle, was C von der Adresse h√§lt, es ist nur eine 64-Bit- oder 32-Bit-Ganzzahl, abh√§ngig von Ihrem Computer.  Es ist einfach ein Wert, der in diesem Speicher indiziert ist.  Und was Sie speichern k√∂nnen, k√∂nnen Sie aus diesem Speicher lesen. <br><br>  Daher werden Dinge wie Zeigerarithmetik einfach zu Ganzzahlarithmetik.  In der Praxis gibt es einige Schwierigkeiten, da in C die Zeigerarithmetik die Zeigertypen kennt und sie proportional zur Gr√∂√üe zunehmen.  Als Ergebnis erhalten wir die folgende Zeile: <br><br>  y = x + 10;  ÔÉù sizeof (int) <br><br><img src="https://habrastorage.org/webt/nw/kg/zi/nwkgziisznkedw-6waxmrpsdn9a.jpeg"><br><br>  Aber was wirklich z√§hlt, ist, was passiert, wenn Sie in den Speicher schreiben und aus ihm lesen.  Basierend auf dem Zeiger, dass 25 in y geschrieben werden soll, nehme ich ein Array von Speicher und indiziere es mit y.  Und ich schreibe 25 in diesen Speicherort. <br><br>  Dann gehe ich zur Anweisung MEM [y] = MEM [x] √ºber, lese den Wert von Position y im Speicher, lese den Wert von Position x im Speicher und vergleiche sie miteinander.  Also √ºberpr√ºfe ich, ob sie √ºbereinstimmen oder nicht. <br><br>  Dies ist eine sehr einfache Annahme, mit der Sie von einem Programm, das Heap verwendet, zu einem Programm wechseln k√∂nnen, das dieses gigantische globale Array verwendet, das Speicher darstellt.  Dies bedeutet, dass Sie jetzt, wenn Sie √ºber Programme sprechen, die den Heap verwalten, wirklich nicht √ºber Programme sprechen m√ºssen, die den Heap verwalten.  Sie werden es perfekt schaffen, √ºber Arrays und nicht √ºber Haufen zu sprechen. <br><br>  Hier ist eine weitere einfache Frage.  Was ist mit der Malloc-Funktion?  Sie k√∂nnen einfach die Malloc-Implementierung in C verwenden, alle hervorgehobenen Seiten im Auge behalten, alles, was freigegeben wurde, im Auge behalten, nur eine kostenlose Liste haben und das ist genug.  Es stellt sich heraus, dass Sie f√ºr viele Zwecke und f√ºr viele Arten von Fehlern kein Malloc ben√∂tigen, um komplex zu sein. <br><br>  Tats√§chlich k√∂nnen Sie von malloc, das so aussieht: x = malloc (sizeof (int) * 100), zu malloc dieser Art wechseln: <br><br>  POS = 1 <br>  Int malloc (int n) { <br>  rv = POS <br>  POS + = n; <br>  }} <br><br>  Was einfach sagt: "Ich werde den Z√§hler f√ºr den n√§chsten freien Speicherplatz im Speicher speichern, und wenn jemand nach einer Adresse fragt, gebe ich ihm diesen Ort und erh√∂he diese Position und kehre dann rv zur√ºck."  In diesem Fall wird das Malloc im traditionellen Sinne v√∂llig ignoriert. <br><br><img src="https://habrastorage.org/webt/pp/tl/_r/pptl_romuwu16scn3eykmzscdmm.jpeg"><br><br>  In diesem Fall wird kein Speicher freigegeben.  Die Funktion bewegt sich einfach weiter und weiter aus dem Speicher und immer weiter und weiter, und hier endet sie ohne Freigabe.  Es ist ihr auch egal, dass es Speicherbereiche gibt, in denen es sich nicht lohnt zu schreiben, da spezielle Adressen von besonderer Bedeutung f√ºr das Betriebssystem reserviert sind. <br><br>  Es modelliert nichts, was das Schreiben der Malloc-Funktion kompliziert macht, sondern nur auf einer bestimmten Abstraktionsebene, wenn Sie versuchen, √ºber einen komplexen Code zu sprechen, der Zeigermanipulationen ausf√ºhrt. <br><br>  Gleichzeitig ist es Ihnen egal, wie viel Speicher freigegeben wird, aber Sie sind besorgt dar√ºber, ob das Programm beispielsweise au√üerhalb eines Puffers schreiben wird. In diesem Fall kann diese Malloc-Funktion recht gut sein. <br><br><img src="https://habrastorage.org/webt/kw/hy/sr/kwhysrcz5pnqvcxeuskiazouxgs.jpeg"><br><br>  Und das passiert tats√§chlich sehr, sehr oft, wenn Sie echten Code symbolisch ausf√ºhren.  Ein sehr wichtiger Schritt ist die Modellierung der Funktionen Ihrer Bibliothek.  Die Art und Weise, wie Sie Bibliotheksfunktionen modellieren, hat einerseits einen gro√üen Einfluss auf die Leistung und Skalierbarkeit der Analyse, andererseits wirkt sich dies auch auf die Genauigkeit aus. <br><br>  Wenn Sie also ein solches ‚ÄûSpielzeug‚Äú -Modell wie dieses haben, wird es sehr schnell reagieren, aber gleichzeitig gibt es bestimmte Arten von Fehlern, die Sie nicht bemerken k√∂nnen.  In diesem Modell ignoriere ich beispielsweise Verteilungen vollst√§ndig, sodass m√∂glicherweise eine Fehlermeldung angezeigt wird, wenn jemand Zugriff auf nicht zugewiesenen Speicherplatz erh√§lt.  Daher werde ich im wirklichen Leben niemals dieses Malloc-Modell von Mickey Mouse verwenden. <br><br>  Es ist also immer ein Gleichgewicht zwischen Genauigkeit der Analyse und Effizienz.  Und je komplexer die Modelle von Standardfunktionen wie Malloc werden, desto weniger skalierbar ist ihre Analyse.  F√ºr einige Fehlerklassen ben√∂tigen Sie jedoch diese einfachen Modelle.  Daher sind verschiedene Bibliotheken in C von gro√üer Bedeutung, die ben√∂tigt werden, um zu verstehen, was ein solches Programm tats√§chlich tut. <br><br>  Daher haben wir das Problem des Denkens √ºber den Heap reduziert, indem wir √ºber das Programm mit Arrays nachgedacht haben, aber ich habe Ihnen nicht wirklich gesagt, wie Sie √ºber das Programm mit Arrays argumentieren sollen.  Es stellt sich heraus, dass die meisten SMT-L√∂ser die Array-Theorie unterst√ºtzen. <br><br><img src="https://habrastorage.org/webt/p3/m3/4j/p3m34j1tdfcrmtpyngc-syfb7rs.jpeg"><br><br>  Die Idee ist, dass wenn a ein Array ist, es eine Notation gibt, mit der Sie dieses Array nehmen und ein neues Array erstellen k√∂nnen, wobei der Speicherort i auf den Wert e aktualisiert wird.  Das ist klar? <br><br>  Wenn ich also ein Array a habe und diese Aktualisierungsoperation durchf√ºhre und dann versuche, den Wert von k zu lesen, bedeutet dies, dass der Wert von k gleich dem Wert von k im Array a ist, wenn k von i verschieden ist und er gleich e ist. wenn k gleich i ist. <br><br>  Das Aktualisieren eines Arrays bedeutet, dass Sie das alte Array nehmen und mit einem neuen Array aktualisieren m√ºssen.  Wenn Sie eine Formel haben, die die Theorie der Arrays enth√§lt, habe ich deshalb mit einem Null-Array begonnen, das √ºberall einfach durch Nullen dargestellt wird. <br><br><img src="https://habrastorage.org/webt/ga/gt/v_/gagtv_latqjqssanfp7tqklcq5i.jpeg"><br><br>  Dann schreibe ich 5 an Position i und 7 an Position j, danach lese ich aus k und √ºberpr√ºfe, ob es 5 ist oder nicht.  Dann kann es erweitert werden, indem die Definition f√ºr etwas verwendet wird, das zum Beispiel sagt: ‚ÄûWenn k i und k y ist, w√§hrend k sich von j unterscheidet, dann ist es ja 5, andernfalls nicht 5 ". <br><br>  In der Praxis erweitern SMT-L√∂ser dies nicht nur auf viele Boolesche Formeln, sondern verwenden diese Hin- und Her-Strategie zwischen dem SAT-L√∂ser und der Engine, die in der Lage ist, √ºber die Array-Theorie zu sprechen, um diese Arbeit auszuf√ºhren. <br><br>  Wichtig ist, dass Sie unter Verwendung dieser Theorie von Arrays mit derselben Strategie, die wir zum Generieren von Formeln f√ºr Ganzzahlen angewendet haben, tats√§chlich Formeln generieren k√∂nnen, die Array-Logik, Array-Aktualisierungen, Array-Achsen und Array-Iteration enthalten.  Und solange Sie Ihren Pfad korrigieren, sind diese Formeln sehr einfach zu generieren. <br>  Wenn Sie Ihre Pfade nicht korrigieren, aber eine Formel erstellen m√∂chten, die dem Durchgang des Programms entlang aller Pfade entspricht, ist dies ebenfalls relativ einfach.  Das einzige, mit dem Sie sich befassen m√ºssen, ist eine spezielle Art von Schleifen. <br><br>  W√∂rterb√ºcher und Karten lassen sich auch sehr einfach mit undefinierten Funktionen modellieren.  Tats√§chlich ist die Theorie der Arrays selbst nur ein Sonderfall einer unbestimmten Funktion.  Mit Hilfe solcher Funktionen k√∂nnen kompliziertere Dinge getan werden.  Im modernen SMT-Solver gibt es eine integrierte Unterst√ºtzung f√ºr √úberlegungen zu Mengen und Mengenoperationen. Dies kann sehr n√ºtzlich sein, wenn Sie √ºber ein Programm sprechen, das die Berechnung von Mengen umfasst. <br><br>  Beim Entwerfen eines dieser Werkzeuge ist die Modellierungsphase sehr wichtig.  Und es geht nicht nur darum, wie Sie komplexe Programmfunktionen bis auf Ihre Theorien modellieren, zum Beispiel Dinge wie das Reduzieren von Heaps auf Arrays.  Der Punkt ist auch, welche Theorien und L√∂ser Sie verwenden.  Es gibt eine gro√üe Anzahl von Theorien und L√∂sern mit unterschiedlichen Beziehungen, f√ºr die ein angemessener Kompromiss zwischen Effizienz und Kosten gew√§hlt werden muss. <br><br><img src="https://habrastorage.org/webt/wf/o9/2m/wfo92mcuifuz0rgcowvad6wrcxs.jpeg"><br><br>  Die meisten praktischen Werkzeuge halten sich an die Theorie der Bitvektoren und k√∂nnen bei Bedarf die Theorie der Arrays zur Modellierung von Heaps verwenden.  Im Allgemeinen versuchen praktische Werkzeuge, komplexere Theorien wie die Mengenlehre zu vermeiden.  Dies liegt daran, dass sie in einigen F√§llen normalerweise weniger skalierbar sind, wenn Sie nicht mit einem Programm arbeiten, f√ºr das diese Art von Tool wirklich erforderlich ist. <br><br>  <b>Zielgruppe:</b> Worauf konzentrieren sich Entwickler neben der Untersuchung der symbolischen Leistung? <br><br> <b>:</b>       ‚Äî      ,      . , , ,             ,       .    ,     . <br><br>  ,       ,         .    ,       ,      ,   ,  ,    ,    ,            . <br><br> ,   ‚Äî   ,     ,      . ,   ,           ‚Äî     ,   JavaScript  Python,         .             ,     . <br><br><img src="https://habrastorage.org/webt/k_/hw/9f/k_hw9fclb1unjv4v4jojv1a-4bk.jpeg"><br><br>       ,             Python.  ,         ,        : ¬´,    ,    ,     ¬ª.   . <br><br> ,         ,   ,       ,    ,     . <br>   ,  ,   ,      -  ,           ,             . <br><br>      ,     ,     ,      .  , ,         Microsoft Word,     , ,   . <br><br>       , ,     ,         ,      . <br><br>    ,          .    ,        ,   - ,   - .    ,    ,      .     ,       . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yRVZPvHYHzw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Die Vollversion des Kurses finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br> ,    .    ?     ?       , <b>30%        entry-level ,      :</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps  $20     ?</a> (   RAID1  RAID10,  24    40GB DDR4). <br><br>  <b>VPS (KVM) E5-2650 v4 (6 Kerne) 10 GB DDR4 240 GB SSD 1 Gbit / s bis Dezember kostenlos,</b> wenn Sie f√ºr einen Zeitraum von sechs Monaten bezahlen, k√∂nnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> bestellen. <br><br> <b>Dell R730xd  2  ?</b>    <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2  Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100   $249</a>    !</b>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   .  c   Dell R730xd 5-2650 v4  9000   ?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425559/">https://habr.com/ru/post/de425559/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425549/index.html">Supermicro-Aktien st√ºrzen bei der Untersuchung des Einsatzes chinesischer Spionagechips ab</a></li>
<li><a href="../de425551/index.html">Wer sollte Geld aus dem Verkauf eines von AI geschaffenen Kunstwerks erhalten?</a></li>
<li><a href="../de425553/index.html">Was der Graf von Monte Cristo √ºber Cybersicherheit sagen kann</a></li>
<li><a href="../de425555/index.html">Charles Nutter √ºber dynamische Sprachen in der JVM unter jug.msk.ru</a></li>
<li><a href="../de425557/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 10: Symbolische Ausf√ºhrung, Teil 1</a></li>
<li><a href="../de425561/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 10: Symbolische Ausf√ºhrung, Teil 2</a></li>
<li><a href="../de425563/index.html">Kalifornien verbietet den Verkauf von IoT-Ger√§ten mit oder ohne einfache Passw√∂rter</a></li>
<li><a href="../de425565/index.html">Schnelle Festkomma-Mathematik f√ºr Finanzanwendungen in Java</a></li>
<li><a href="../de425569/index.html">PCB-Funktionstests</a></li>
<li><a href="../de425571/index.html">Sichern eines Webservers unter Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>