<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤰🏻 🧔 🌧️ MIT-Kurs "Computer Systems Security". Vorlesung 10: Symbolische Ausführung, Teil 3 👨🏾‍🤝‍👨🏼 🐛 😰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Massachusetts Institute of Technology. Vorlesung # 6.858. "Sicherheit von Computersystemen." Nikolai Zeldovich, James Mickens. 2014 Jahr 
 Computer Sy...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MIT-Kurs "Computer Systems Security". Vorlesung 10: Symbolische Ausführung, Teil 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/425559/"><h3>  Massachusetts Institute of Technology.  Vorlesung # 6.858.  "Sicherheit von Computersystemen."  Nikolai Zeldovich, James Mickens.  2014 Jahr </h3><br>  Computer Systems Security ist ein Kurs zur Entwicklung und Implementierung sicherer Computersysteme.  Die Vorträge behandeln Bedrohungsmodelle, Angriffe, die die Sicherheit gefährden, und Sicherheitstechniken, die auf jüngsten wissenschaftlichen Arbeiten basieren.  Zu den Themen gehören Betriebssystemsicherheit, Funktionen, Informationsflussmanagement, Sprachsicherheit, Netzwerkprotokolle, Hardwaresicherheit und Sicherheit von Webanwendungen. <br><br>  Vorlesung 1: „Einführung: Bedrohungsmodelle“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 2: „Kontrolle von Hackerangriffen“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 3: „Pufferüberläufe: Exploits und Schutz“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 4: „Trennung von Privilegien“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 5: „Woher kommen Sicherheitssysteme?“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> <br>  Vorlesung 6: „Chancen“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 7: „Native Client Sandbox“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 8: „Netzwerksicherheitsmodell“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 9: „Sicherheit von Webanwendungen“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 10: „Symbolische Ausführung“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <a name="habracut"></a><br><br>  Wenn wir nun dem Zweig nach unten folgen, sehen wir den Ausdruck t = y.  Da wir jeweils einen Pfad betrachten, müssen wir für t keine neue Variable einführen.  Wir können einfach sagen, dass t nicht mehr 0 ist, da t = y ist. <br><br>  Wir bewegen uns weiter nach unten und kommen zu dem Punkt, an dem wir zu einem anderen Zweig gelangen.  Was ist die neue Annahme, die wir treffen müssen, um diesen Weg weiter zu beschreiten?  Dies ist eine Annahme, dass t &lt;y ist. <br><br>  Was ist t?  Wenn Sie den rechten Zweig nachschlagen, sehen wir, dass t = y ist.  Und in unserer Tabelle ist T = y und Y = y.  Daraus folgt logischerweise, dass unsere Einschränkung wie y &lt;y aussieht, was nicht sein kann. <br><br><img src="https://habrastorage.org/webt/tu/pe/kp/tupekplxzar-nappngbqlwuy12y.jpeg"><br><br>  Somit hatten wir alles in Ordnung, bis wir diesen Punkt t &lt;y erreichten.  Bis wir zu der falschen Aussage kommen, haben wir alle Ungleichungen, um richtig zu sein.  Dies funktioniert jedoch nicht, da bei der Ausführung von Aufgaben des richtigen Zweigs eine logische Inkonsistenz auftritt. <br><br>  Wir haben das, was oft als Zustand des Pfades bezeichnet wird.  Diese Bedingung muss erfüllt sein, damit das Programm diesen Weg einschlägt.  Wir wissen jedoch, dass diese Bedingung nicht erfüllt werden kann, daher ist es für das Programm unmöglich, diesen Weg zu gehen.  Dieser Weg wurde nun vollständig beseitigt, und wir wissen, dass dieser richtige Weg nicht zurückgelegt werden kann. <br><br>  Was ist mit dem anderen Weg?  Versuchen wir, den linken Zweig auf andere Weise zu durchlaufen.  Was sind die Bedingungen für diesen Weg?  Wieder beginnt unser symbolischer Zustand bei t = 0 und X und Y sind gleich den Variablen x und y. <br><br><img src="https://habrastorage.org/webt/5a/oo/cc/5aooccskimxeaooehicyxgew8jc.jpeg"><br><br>  Wie sieht die Pfadbeschränkung in diesem Fall jetzt aus?  Wir bezeichnen den linken Zweig als True und den rechten Zweig als False und betrachten weiter den Wert t = x.  Als Ergebnis der logischen Verarbeitung der Bedingungen t = x, x&gt; y und t &lt;y erhalten wir, dass wir gleichzeitig x&gt; y und x &lt;y haben. <br><br><img src="https://habrastorage.org/webt/jz/lz/9e/jzlz9e9yvnbqh7y3wwaowffufuc.jpeg"><br><br>  Es ist klar, dass dieser Zustand des Pfades unbefriedigend ist.  Wir können kein x haben, das sowohl größer als auch kleiner als y ist.  Es gibt keine Zuordnung zu einer Variablen X, die beide Bedingungen erfüllt.  Dies zeigt uns also, dass der andere Weg ebenfalls unbefriedigend ist. <br><br>  Es stellt sich heraus, dass wir in diesem Moment alle möglichen Wege im Programm erkundet haben, die uns in diesen Zustand führen könnten.  Wir können tatsächlich feststellen und überprüfen, dass es keinen Weg gibt, der uns zu der Aussage false führen würde. <br>  <b>Zielgruppe:</b> In diesem Beispiel haben Sie gezeigt, dass Sie den Fortschritt eines Programms in allen möglichen Branchen untersucht haben.  Einer der Vorteile der symbolischen Ausführung besteht jedoch darin, dass wir nicht alle möglichen exponentiellen Pfade untersuchen müssen.  Wie kann man dies in diesem Beispiel vermeiden? <br><br>  <b>Professor:</b> Das ist eine sehr gute Frage.  In diesem Fall gehen Sie einen Kompromiss zwischen der Zeichenausführung und der gewünschten Genauigkeit ein.  In diesem Fall verwenden wir weniger die symbolische Ausführung als vielmehr das erste Mal, dass wir den Programmablauf in beiden Zweigen gleichzeitig betrachten.  Aber dank dessen sind unsere Einschränkungen sehr, sehr einfach geworden. <br><br>  Die einzelnen Einschränkungen „auf eine Weise nach der anderen“ sind sehr einfach, aber Sie müssen dies immer wieder tun, indem Sie alle vorhandenen Zweige und exponentiell - und alle möglichen Wege - studieren. <br>  Es gibt exponentiell viele Pfade, aber für jeden Pfad als Ganzes gibt es auch einen exponentiell großen Satz von Eingabedaten, die diesen Pfad gehen können.  Dies gibt Ihnen also bereits einen großen Vorteil, denn anstatt alle möglichen Eingaben zu versuchen, versuchen Sie, jeden möglichen Weg zu versuchen.  Aber kannst du etwas besser machen? <br><br>  Dies ist einer der Bereiche, in denen viel experimentiert wurde, beispielsweise in Bezug auf die symbolische Ausführung, beispielsweise die gleichzeitige Ausführung mehrerer Pfade.  In den Vorlesungsmaterialien haben Sie Heuristiken und eine Reihe von Strategien kennengelernt, mit denen Experimentatoren die Suche lösbarer gemacht haben. <br><br>  Zum Beispiel ist eines der Dinge, die sie tun, dass sie einen Weg nach dem anderen erkunden, dies aber nicht völlig blind tun.  Sie überprüfen die Bedingungen des Pfades nach jedem Schritt.  Angenommen, hier in unserem Programm gibt es anstelle von „false“ einen komplexen Programmbaum, ein Kontrollflussdiagramm. <br><br><img src="https://habrastorage.org/webt/ly/a_/em/lya_em86ezzhqftrrv247zfdnwq.jpeg"><br><br>  Sie müssen nicht warten, bis Sie das Ende erreicht haben, um zu überprüfen, ob dieser Pfad möglich ist.  In diesem Moment, wenn Sie die Bedingung t &lt;y erreichen, wissen Sie bereits, dass dieser Weg unbefriedigend ist, und Sie werden niemals in diese Richtung gehen.  Das Abschneiden der falschen Zweige zu Beginn des Programms reduziert daher den Aufwand für empirische Arbeiten.  Eine angemessene Erkundung des Pfades verhindert die Möglichkeit eines zukünftigen Programmfehlers.  Viele der praktischen Werkzeuge, die heute verwendet werden, beginnen hauptsächlich mit zufälligen Tests, um die ersten Pfade zu erhalten. Danach beginnen sie, die Pfade in der Nachbarschaft zu erkunden.  Sie verarbeiten viele Optionen für die mögliche Ausführung des Programms für jeden Zweig und fragen sich, was auf diesen Pfaden passiert. <br><br>  Es ist besonders nützlich, wenn wir eine gute Reihe von Tests haben.  Sie führen Ihren Test aus und stellen fest, dass dieser Code nicht ausgeführt wird.  Daher können Sie den Pfad nehmen, der der Implementierung des Codes am nächsten kam, und fragen, ob dieser Pfad geändert werden kann, damit er in die richtige Richtung verläuft. <br><br><img src="https://habrastorage.org/webt/ik/26/yz/ik26yz36aargvenedflizgtebnu.jpeg"><br><br>  Aber in dem Moment, in dem Sie versuchen, alle Pfade gleichzeitig zu erstellen, beginnen Einschränkungen, die unlösbar werden.  Daher können Sie jeweils eine Funktion ausführen, während Sie alle Pfade in einer Funktion zusammen lernen können.  Wenn Sie versuchen, große Blöcke zu erstellen, können Sie im Allgemeinen alle möglichen Wege erkunden. <br><br>  Das Wichtigste ist, dass Sie für jeden Zweig Ihre Einschränkungen überprüfen und feststellen, ob dieser Zweig wirklich in beide Richtungen gehen kann.  Wenn sie nicht beide Wege gehen kann, sparen Sie Zeit und Mühe, indem Sie nicht in die Richtung gehen, in die sie nicht gehen kann.  Außerdem erinnere ich mich nicht an die spezifischen Strategien, mit denen sie Wege finden, die mit größerer Wahrscheinlichkeit zu sehr guten Ergebnissen führen.  Es ist jedoch sehr wichtig, im Anfangsstadium die falschen Zweige abzuschneiden. <br><br>  Bisher haben wir hauptsächlich über „Spielzeugcode“ gesprochen, über ganzzahlige Variablen, über Zweige, über sehr einfache Dinge.  Aber was passiert, wenn Sie ein komplexeres Programm haben?  Was passiert insbesondere, wenn Sie ein Programm haben, das eine Menge enthält? <br><br><img src="https://habrastorage.org/webt/jh/u9/j0/jhu9j05lzmmvolihvaaluj4tqqe.jpeg"><br><br>  In der Vergangenheit war der Hüfthaufen der Fluch aller Softwareanalysen, da die sauberen und eleganten Dinge in Fortrans Zeit vollständig explodieren, wenn Sie versuchen, sie mit C-Programmen auszuführen, in denen Sie links und rechts Speicher zuweisen.  Dort haben Sie Überlagerungen und all das Durcheinander, das mit dem Programm verbunden ist, mit zugewiesenem Speicher und mit arithmetischen Zeigern.  Dies ist einer der Bereiche, in denen die symbolische Ausführung eine hervorragende Fähigkeit besitzt, über Programme nachzudenken. <br><br>  Wie machen wir das?  Vergessen wir für einen Moment die Zweige und den Kontrollfluss.  Wir haben hier ein einfaches Programm.  Es reserviert etwas Speicher, macht ihn ungültig und erhält einen neuen Zeiger y vom Zeiger x.  Dann schreibt sie etwas in y und prüft, ob der im Zeiger y gespeicherte Wert dem im Zeiger x gespeicherten Wert entspricht. <br><br>  Basierend auf den Grundkenntnissen von C können Sie sehen, dass diese Prüfung nicht durchgeführt wird, da x zurückgesetzt wird und y = 25 ist, sodass x einen anderen Ort angibt.  Bisher ist bei uns alles in Ordnung. <br>  Die Art und Weise, wie wir den Heap modellieren und wie der Heap auf den meisten Systemen modelliert wird, verwendet die Heap-Darstellung in C, wo es sich nur um eine gigantische Adressbasis handelt, ein gigantisches Array, in das Sie Ihre Daten einfügen können. <br>  Dies bedeutet, dass wir unser Programm als einen sehr großen globalen Datensatz darstellen können, der als MEM bezeichnet wird.  Dies ist ein Array, das im Wesentlichen Adressen Werten zuordnet.  Eine Adresse ist nur ein 64-Bit-Wert.  Und was passiert, wenn Sie etwas von dieser Adresse gelesen haben?  Dies hängt davon ab, wie Sie den Speicher modellieren. <br><br>  Wenn Sie es auf Byte-Ebene modellieren, erhalten Sie ein Byte.  Wenn Sie es auf Wortebene modellieren, erhalten Sie ein Wort.  Abhängig von der Art der Fehler, an denen Sie interessiert sind, und davon, ob Sie über die Speicherzuordnung besorgt sind oder nicht, werden Sie sie etwas anders modellieren, aber normalerweise ist der Speicher nur ein Array von Adresse zu Wert. <br><br><img src="https://habrastorage.org/webt/ml/5h/u3/ml5hu3rxqhuwkwjute0ykkgzzru.jpeg"><br><br>  Die Adresse ist also nur eine ganze Zahl.  In gewisser Weise spielt es keine Rolle, was C von der Adresse hält, es ist nur eine 64-Bit- oder 32-Bit-Ganzzahl, abhängig von Ihrem Computer.  Es ist einfach ein Wert, der in diesem Speicher indiziert ist.  Und was Sie speichern können, können Sie aus diesem Speicher lesen. <br><br>  Daher werden Dinge wie Zeigerarithmetik einfach zu Ganzzahlarithmetik.  In der Praxis gibt es einige Schwierigkeiten, da in C die Zeigerarithmetik die Zeigertypen kennt und sie proportional zur Größe zunehmen.  Als Ergebnis erhalten wir die folgende Zeile: <br><br>  y = x + 10;   sizeof (int) <br><br><img src="https://habrastorage.org/webt/nw/kg/zi/nwkgziisznkedw-6waxmrpsdn9a.jpeg"><br><br>  Aber was wirklich zählt, ist, was passiert, wenn Sie in den Speicher schreiben und aus ihm lesen.  Basierend auf dem Zeiger, dass 25 in y geschrieben werden soll, nehme ich ein Array von Speicher und indiziere es mit y.  Und ich schreibe 25 in diesen Speicherort. <br><br>  Dann gehe ich zur Anweisung MEM [y] = MEM [x] über, lese den Wert von Position y im Speicher, lese den Wert von Position x im Speicher und vergleiche sie miteinander.  Also überprüfe ich, ob sie übereinstimmen oder nicht. <br><br>  Dies ist eine sehr einfache Annahme, mit der Sie von einem Programm, das Heap verwendet, zu einem Programm wechseln können, das dieses gigantische globale Array verwendet, das Speicher darstellt.  Dies bedeutet, dass Sie jetzt, wenn Sie über Programme sprechen, die den Heap verwalten, wirklich nicht über Programme sprechen müssen, die den Heap verwalten.  Sie werden es perfekt schaffen, über Arrays und nicht über Haufen zu sprechen. <br><br>  Hier ist eine weitere einfache Frage.  Was ist mit der Malloc-Funktion?  Sie können einfach die Malloc-Implementierung in C verwenden, alle hervorgehobenen Seiten im Auge behalten, alles, was freigegeben wurde, im Auge behalten, nur eine kostenlose Liste haben und das ist genug.  Es stellt sich heraus, dass Sie für viele Zwecke und für viele Arten von Fehlern kein Malloc benötigen, um komplex zu sein. <br><br>  Tatsächlich können Sie von malloc, das so aussieht: x = malloc (sizeof (int) * 100), zu malloc dieser Art wechseln: <br><br>  POS = 1 <br>  Int malloc (int n) { <br>  rv = POS <br>  POS + = n; <br>  }} <br><br>  Was einfach sagt: "Ich werde den Zähler für den nächsten freien Speicherplatz im Speicher speichern, und wenn jemand nach einer Adresse fragt, gebe ich ihm diesen Ort und erhöhe diese Position und kehre dann rv zurück."  In diesem Fall wird das Malloc im traditionellen Sinne völlig ignoriert. <br><br><img src="https://habrastorage.org/webt/pp/tl/_r/pptl_romuwu16scn3eykmzscdmm.jpeg"><br><br>  In diesem Fall wird kein Speicher freigegeben.  Die Funktion bewegt sich einfach weiter und weiter aus dem Speicher und immer weiter und weiter, und hier endet sie ohne Freigabe.  Es ist ihr auch egal, dass es Speicherbereiche gibt, in denen es sich nicht lohnt zu schreiben, da spezielle Adressen von besonderer Bedeutung für das Betriebssystem reserviert sind. <br><br>  Es modelliert nichts, was das Schreiben der Malloc-Funktion kompliziert macht, sondern nur auf einer bestimmten Abstraktionsebene, wenn Sie versuchen, über einen komplexen Code zu sprechen, der Zeigermanipulationen ausführt. <br><br>  Gleichzeitig ist es Ihnen egal, wie viel Speicher freigegeben wird, aber Sie sind besorgt darüber, ob das Programm beispielsweise außerhalb eines Puffers schreiben wird. In diesem Fall kann diese Malloc-Funktion recht gut sein. <br><br><img src="https://habrastorage.org/webt/kw/hy/sr/kwhysrcz5pnqvcxeuskiazouxgs.jpeg"><br><br>  Und das passiert tatsächlich sehr, sehr oft, wenn Sie echten Code symbolisch ausführen.  Ein sehr wichtiger Schritt ist die Modellierung der Funktionen Ihrer Bibliothek.  Die Art und Weise, wie Sie Bibliotheksfunktionen modellieren, hat einerseits einen großen Einfluss auf die Leistung und Skalierbarkeit der Analyse, andererseits wirkt sich dies auch auf die Genauigkeit aus. <br><br>  Wenn Sie also ein solches „Spielzeug“ -Modell wie dieses haben, wird es sehr schnell reagieren, aber gleichzeitig gibt es bestimmte Arten von Fehlern, die Sie nicht bemerken können.  In diesem Modell ignoriere ich beispielsweise Verteilungen vollständig, sodass möglicherweise eine Fehlermeldung angezeigt wird, wenn jemand Zugriff auf nicht zugewiesenen Speicherplatz erhält.  Daher werde ich im wirklichen Leben niemals dieses Malloc-Modell von Mickey Mouse verwenden. <br><br>  Es ist also immer ein Gleichgewicht zwischen Genauigkeit der Analyse und Effizienz.  Und je komplexer die Modelle von Standardfunktionen wie Malloc werden, desto weniger skalierbar ist ihre Analyse.  Für einige Fehlerklassen benötigen Sie jedoch diese einfachen Modelle.  Daher sind verschiedene Bibliotheken in C von großer Bedeutung, die benötigt werden, um zu verstehen, was ein solches Programm tatsächlich tut. <br><br>  Daher haben wir das Problem des Denkens über den Heap reduziert, indem wir über das Programm mit Arrays nachgedacht haben, aber ich habe Ihnen nicht wirklich gesagt, wie Sie über das Programm mit Arrays argumentieren sollen.  Es stellt sich heraus, dass die meisten SMT-Löser die Array-Theorie unterstützen. <br><br><img src="https://habrastorage.org/webt/p3/m3/4j/p3m34j1tdfcrmtpyngc-syfb7rs.jpeg"><br><br>  Die Idee ist, dass wenn a ein Array ist, es eine Notation gibt, mit der Sie dieses Array nehmen und ein neues Array erstellen können, wobei der Speicherort i auf den Wert e aktualisiert wird.  Das ist klar? <br><br>  Wenn ich also ein Array a habe und diese Aktualisierungsoperation durchführe und dann versuche, den Wert von k zu lesen, bedeutet dies, dass der Wert von k gleich dem Wert von k im Array a ist, wenn k von i verschieden ist und er gleich e ist. wenn k gleich i ist. <br><br>  Das Aktualisieren eines Arrays bedeutet, dass Sie das alte Array nehmen und mit einem neuen Array aktualisieren müssen.  Wenn Sie eine Formel haben, die die Theorie der Arrays enthält, habe ich deshalb mit einem Null-Array begonnen, das überall einfach durch Nullen dargestellt wird. <br><br><img src="https://habrastorage.org/webt/ga/gt/v_/gagtv_latqjqssanfp7tqklcq5i.jpeg"><br><br>  Dann schreibe ich 5 an Position i und 7 an Position j, danach lese ich aus k und überprüfe, ob es 5 ist oder nicht.  Dann kann es erweitert werden, indem die Definition für etwas verwendet wird, das zum Beispiel sagt: „Wenn k i und k y ist, während k sich von j unterscheidet, dann ist es ja 5, andernfalls nicht 5 ". <br><br>  In der Praxis erweitern SMT-Löser dies nicht nur auf viele Boolesche Formeln, sondern verwenden diese Hin- und Her-Strategie zwischen dem SAT-Löser und der Engine, die in der Lage ist, über die Array-Theorie zu sprechen, um diese Arbeit auszuführen. <br><br>  Wichtig ist, dass Sie unter Verwendung dieser Theorie von Arrays mit derselben Strategie, die wir zum Generieren von Formeln für Ganzzahlen angewendet haben, tatsächlich Formeln generieren können, die Array-Logik, Array-Aktualisierungen, Array-Achsen und Array-Iteration enthalten.  Und solange Sie Ihren Pfad korrigieren, sind diese Formeln sehr einfach zu generieren. <br>  Wenn Sie Ihre Pfade nicht korrigieren, aber eine Formel erstellen möchten, die dem Durchgang des Programms entlang aller Pfade entspricht, ist dies ebenfalls relativ einfach.  Das einzige, mit dem Sie sich befassen müssen, ist eine spezielle Art von Schleifen. <br><br>  Wörterbücher und Karten lassen sich auch sehr einfach mit undefinierten Funktionen modellieren.  Tatsächlich ist die Theorie der Arrays selbst nur ein Sonderfall einer unbestimmten Funktion.  Mit Hilfe solcher Funktionen können kompliziertere Dinge getan werden.  Im modernen SMT-Solver gibt es eine integrierte Unterstützung für Überlegungen zu Mengen und Mengenoperationen. Dies kann sehr nützlich sein, wenn Sie über ein Programm sprechen, das die Berechnung von Mengen umfasst. <br><br>  Beim Entwerfen eines dieser Werkzeuge ist die Modellierungsphase sehr wichtig.  Und es geht nicht nur darum, wie Sie komplexe Programmfunktionen bis auf Ihre Theorien modellieren, zum Beispiel Dinge wie das Reduzieren von Heaps auf Arrays.  Der Punkt ist auch, welche Theorien und Löser Sie verwenden.  Es gibt eine große Anzahl von Theorien und Lösern mit unterschiedlichen Beziehungen, für die ein angemessener Kompromiss zwischen Effizienz und Kosten gewählt werden muss. <br><br><img src="https://habrastorage.org/webt/wf/o9/2m/wfo92mcuifuz0rgcowvad6wrcxs.jpeg"><br><br>  Die meisten praktischen Werkzeuge halten sich an die Theorie der Bitvektoren und können bei Bedarf die Theorie der Arrays zur Modellierung von Heaps verwenden.  Im Allgemeinen versuchen praktische Werkzeuge, komplexere Theorien wie die Mengenlehre zu vermeiden.  Dies liegt daran, dass sie in einigen Fällen normalerweise weniger skalierbar sind, wenn Sie nicht mit einem Programm arbeiten, für das diese Art von Tool wirklich erforderlich ist. <br><br>  <b>Zielgruppe:</b> Worauf konzentrieren sich Entwickler neben der Untersuchung der symbolischen Leistung? <br><br> <b>:</b>       —      ,      . , , ,             ,       .    ,     . <br><br>  ,       ,         .    ,       ,      ,   ,  ,    ,    ,            . <br><br> ,   —   ,     ,      . ,   ,           —     ,   JavaScript  Python,         .             ,     . <br><br><img src="https://habrastorage.org/webt/k_/hw/9f/k_hw9fclb1unjv4v4jojv1a-4bk.jpeg"><br><br>       ,             Python.  ,         ,        : «,    ,    ,     ».   . <br><br> ,         ,   ,       ,    ,     . <br>   ,  ,   ,      -  ,           ,             . <br><br>      ,     ,     ,      .  , ,         Microsoft Word,     , ,   . <br><br>       , ,     ,         ,      . <br><br>    ,          .    ,        ,   - ,   - .    ,    ,      .     ,       . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yRVZPvHYHzw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Die Vollversion des Kurses finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br> ,    .    ?     ?       , <b>30%        entry-level ,      :</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps  $20     ?</a> (   RAID1  RAID10,  24    40GB DDR4). <br><br>  <b>VPS (KVM) E5-2650 v4 (6 Kerne) 10 GB DDR4 240 GB SSD 1 Gbit / s bis Dezember kostenlos,</b> wenn Sie für einen Zeitraum von sechs Monaten bezahlen, können Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> bestellen. <br><br> <b>Dell R730xd  2  ?</b>    <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2  Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100   $249</a>    !</b>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   .  c   Dell R730xd 5-2650 v4  9000   ?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425559/">https://habr.com/ru/post/de425559/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425549/index.html">Supermicro-Aktien stürzen bei der Untersuchung des Einsatzes chinesischer Spionagechips ab</a></li>
<li><a href="../de425551/index.html">Wer sollte Geld aus dem Verkauf eines von AI geschaffenen Kunstwerks erhalten?</a></li>
<li><a href="../de425553/index.html">Was der Graf von Monte Cristo über Cybersicherheit sagen kann</a></li>
<li><a href="../de425555/index.html">Charles Nutter über dynamische Sprachen in der JVM unter jug.msk.ru</a></li>
<li><a href="../de425557/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 10: Symbolische Ausführung, Teil 1</a></li>
<li><a href="../de425561/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 10: Symbolische Ausführung, Teil 2</a></li>
<li><a href="../de425563/index.html">Kalifornien verbietet den Verkauf von IoT-Geräten mit oder ohne einfache Passwörter</a></li>
<li><a href="../de425565/index.html">Schnelle Festkomma-Mathematik für Finanzanwendungen in Java</a></li>
<li><a href="../de425569/index.html">PCB-Funktionstests</a></li>
<li><a href="../de425571/index.html">Sichern eines Webservers unter Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>