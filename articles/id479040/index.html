<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤œğŸ¾ ğŸš± ğŸ¤œğŸ¾ Tes regresi visual. Mulai ulang ğŸ‘©ğŸ»â€ğŸ¤â€ğŸ‘¨ğŸ¾ ğŸ™‡ ğŸ‘©ğŸ½â€ğŸŒ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel saya sebelumnya saya berbicara tentang pengalaman menggunakan mesin Gemini untuk mengembangkan tes visual, atau lebih tepatnya, tes regr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tes regresi visual. Mulai ulang</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/directum/blog/479040/">  Dalam <a href="https://habr.com/ru/post/454464/">artikel</a> saya sebelumnya saya berbicara tentang pengalaman menggunakan mesin <a href="https://github.com/gemini-testing/gemini">Gemini</a> untuk mengembangkan tes visual, atau lebih tepatnya, tes regresi visual.  Tes semacam itu memeriksa apakah ada sesuatu yang "bergerak" di UI setelah perubahan berikutnya dengan membandingkan tangkapan layar saat ini dengan yang sebelumnya diperbaiki.  Sejak itu, banyak perubahan dalam pendekatan kami dalam menulis tes visual, termasuk mesin yang digunakan.  Sekarang kita menggunakan <a href="https://github.com/gemini-testing/hermione">Hermione</a> , tetapi dalam artikel ini saya akan memberitahu tidak hanya dan tidak begitu banyak tentang Hermione, tetapi tentang masalah yang telah terakumulasi sejak saat itu dan bagaimana menyelesaikannya, yang, antara lain, menyebabkan transisi ke mesin baru. <br><a name="habracut"></a><br>  Pertama, meskipun tes berhasil, dan cukup berhasil, kami tidak memiliki pemahaman yang jelas tentang apa yang dicakup oleh tes dan apa yang tidak.  Tentu saja ada beberapa gagasan tentang tingkat cakupan, tetapi kami tidak mengukurnya secara kuantitatif.  Kedua, komposisi tes meningkat dari waktu ke waktu dan tes yang berbeda sering menguji hal yang sama, karena  dalam tangkapan layar yang berbeda, beberapa bagian bertepatan dengan bagian yang sama, tetapi dalam tangkapan layar yang berbeda.  Akibatnya, bahkan perubahan kecil pada CSS dapat membanjiri banyak tes sekaligus dan memerlukan pembaruan sejumlah besar standar.  Ketiga, tema gelap muncul di produk kami, dan untuk menutupinya dengan beberapa pengujian, beberapa pengujian secara selektif beralih menggunakan tema gelap, yang juga tidak menambah kejelasan pada masalah dengan menentukan tingkat cakupan. <br><br><h2>  Optimalisasi kinerja </h2><br>  Kami mulai, anehnya, dengan kinerja yang dioptimalkan.  Saya akan menjelaskan alasannya.  Tes visual kami didasarkan pada <a href="https://github.com/storybooks/storybook">Storybook</a> .  Setiap cerita dalam buku cerita bukan komponen tunggal, tetapi seluruh "blok" (misalnya, kotak dengan daftar entitas, kartu entitas, dialog, atau bahkan aplikasi secara keseluruhan).  Untuk menampilkan blok ini, Anda perlu "memompa" cerita dengan data, tidak hanya data yang ditampilkan kepada pengguna, tetapi juga keadaan komponen yang digunakan di dalam blok.  Informasi ini disimpan bersama dengan kode sumber dalam bentuk file json yang berisi representasi serial dari keadaan aplikasi (redux store).  Ya, data ini, secara sederhana, berlebihan, tetapi sangat menyederhanakan pembuatan tes.  Untuk membuat tes baru, kita cukup membuka kartu, daftar atau dialog yang diinginkan dalam aplikasi, mengambil snapshot dari kondisi aplikasi saat ini dan membuat serialisasi ke dalam file.  Lalu kami menambahkan cerita baru dan tes yang mengambil tangkapan layar dari cerita ini (semua dalam beberapa baris kode). <br><br>  Pendekatan ini pasti meningkatkan ukuran bundel.  Tingkat duplikasi data di dalamnya hanya "berguling".  Saat menjalankan tes, mesin gemini mengeksekusi setiap test suite dalam sesi browser terpisah.  Setiap sesi memuat bundel baru dan ukuran bundel dalam skema seperti itu jauh dari nilai terakhir. <br><br>  Untuk mengurangi waktu uji berjalan, kami mengurangi jumlah suite uji dengan meningkatkan jumlah tes di dalamnya.  Dengan demikian, satu test suite dapat mempengaruhi beberapa cerita sekaligus.  Dalam skema ini, kami praktis kehilangan kemampuan untuk "menyaring" hanya area tertentu dari layar karena fakta bahwa Gemini memungkinkan Anda untuk mengatur area tangkapan layar hanya untuk test suite secara keseluruhan (meskipun API memungkinkan Anda untuk melakukan ini sebelum setiap tangkapan layar, tetapi dalam praktiknya tidak berfungsi). <br><br>  Ketidakmampuan untuk membatasi area tangkapan layar dalam pengujian menyebabkan duplikasi informasi visual dalam gambar referensi.  Meskipun tidak ada banyak tes, masalah ini tampaknya tidak signifikan.  Ya, dan UI tidak sering berubah.  Tapi ini tidak bisa berlangsung selamanya - desain ulang menjulang di cakrawala. <br><br>  Ke depan, saya akan mengatakan bahwa di Hermione area tangkapan layar dapat ditetapkan untuk setiap pemotretan dan, sekilas, beralih ke mesin baru akan menyelesaikan semua masalah.  Tapi kita masih harus "menghancurkan" suite tes besar.  Faktanya adalah bahwa tes visual secara inheren tidak stabil (ini bisa disebabkan oleh berbagai alasan, misalnya, dengan kelambatan jaringan, menggunakan animasi, atau dengan "cuaca di Mars") dan sangat sulit untuk dilakukan tanpa coba ulang otomatis.  Baik Gemini dan Hermione melakukan pengujian ulang untuk test suite secara keseluruhan, dan "lebih tebal" test suite tersebut, semakin kecil kemungkinannya untuk menyelesaikan dengan sukses selama pengujian ulang, karena  pada percobaan berikutnya, tes yang sebelumnya berhasil diselesaikan dapat jatuh.  Untuk suite uji tebal, kami harus menerapkan skema coba lagi alternatif yang dibangun ke dalam mesin Gemini dan benar-benar tidak ingin melakukan ini lagi ketika beralih ke mesin baru. <br><br>  Oleh karena itu, untuk mempercepat pemuatan suite uji, kami membagi bundel monolitik menjadi beberapa bagian, mengalokasikan setiap snapshot dari status aplikasi menjadi â€œbagianâ€ terpisah, memuat â€œsesuai permintaanâ€ untuk setiap cerita secara terpisah.  Kode pembuatan cerita sekarang terlihat seperti ini: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// visual-regression.stories.js import React from 'react'; import StoryProvider from './story-provider'; const stories = storiesOf('visual-regression', module); [ { name: 'Contract', loadData: import('./snapshots/contract.testdata') }, { name: 'ExecutionTask', loadData: import('./snapshots/execution-task.testdata') }, { name: 'ExecutionAssignment', loadData: import('./snapshots/execution-assignment.testdata') }, { name: 'DocumentTemplate', loadData: import('./snapshots/document-template.testdata') }, { name: 'Explorer', loadData: import('./snapshots/explorer.testdata') }, { name: 'Inbox', loadData: import('./snapshots/inbox.testdata') }, ] .map(story =&gt; { stories .add(story.name, () =&gt; &lt;StoryProvider loadSnapshot={story.loadData} /&gt;) .add(`${story.name}Dark`, () =&gt; &lt;StoryProvider loadSnapshot={story.loadData} theme='night' /&gt;); });</span></span></code> </pre> <br>  Untuk membuat cerita, komponen StoryProvider digunakan (kodenya akan diberikan di bawah).  Snapshots diambil menggunakan fungsi <a href="https://webpack.js.org/guides/code-splitting/">impor dinamis</a> .  Cerita yang berbeda berbeda satu sama lain hanya dalam gambar negara.  Untuk tema gelap, ceritanya dihasilkan, menggunakan snapshot yang sama dengan cerita untuk tema terang.  Dalam konteks buku cerita, kelihatannya seperti ini: <br><br><div class="spoiler">  <b class="spoiler_title">Cerita tema default</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/d6/vc/uk/d6vcukhmensy0jogshjj4hifoui.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Cerita bertema gelap</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/jy/z0/uu/jyz0uuyel6t1pofayyjxftuunwg.png"><br></div></div><br>  Komponen StoryProvider menerima panggilan balik untuk memuat snapshot di mana fungsi import () dipanggil.  Fungsi import () bekerja secara tidak sinkron, sehingga Anda tidak dapat segera mengambil tangkapan layar setelah memuat cerita - kami berisiko menghapus kekosongan.  Untuk menangkap momen akhir pengunduhan, penyedia membuat elemen DOM penanda menandakan mesin uji untuk seluruh waktu pengunduhan, yang harus ditunda dengan tangkapan layar: <br><br><div class="spoiler">  <b class="spoiler_title">story-provider.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// story-provider.js const propsStub = { // -,      . . . }; type Props = { loadSnapshot: () =&gt; Object, theme: ?string }; const StoryProvider = (props: Props) =&gt; { const [ snapshotState, setsnapshotState ] = React.useState(null); React.useEffect(() =&gt; { //    (async() =&gt; setsnapshotState((await props.loadSnapshot).default))(); }); if (!snapshotState) //     ,     return &lt;div className={'loading-stub'}&gt;Loading...&lt;/div&gt;; //    snapshotState.metadata = require('./snapshots/metadata'); //  redux-   const store = createMockStore(snapshotState); //   applyTheme(props.theme); return ( &lt;Provider store={store}&gt; &lt;MemoryRouter&gt; &lt;App {...propsStub} /&gt; &lt;/MemoryRouter&gt; &lt;/Provider&gt; ); }; export default StoryProvider;</span></span></code> </pre><br></div></div><br>  Selain itu, untuk mengurangi ukuran bundel, nonaktifkan penambahan peta sumber ke bundel.  Tetapi agar tidak kehilangan kemampuan untuk men-debug cerita (Anda tidak pernah tahu apa), kami melakukan ini dengan ketentuan: <br><br><div class="spoiler">  <b class="spoiler_title">.storybook / webpack.config.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// .storybook/webpack.config.js ... module.exports = { ... devtool: process.env.NODE_ENV === 'vr-test' ? '(none)' : 'eval-source-map' };</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">package.json</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// package.json { ... "scripts": { ... "storybook": "start-storybook", "build-storybook": "cross-env NODE_ENV=vr-test build-storybook -o ./storybook-static", ... },</span></span></code> </pre><br></div></div><br>  <b>Skrip build-storybook npm run</b> mengkompilasi sebuah buku cerita statis tanpa sourcemap ke dalam folder statis-buku cerita.  Ini digunakan saat melakukan tes.  Dan <b>skrip buku cerita npm run</b> digunakan untuk mengembangkan dan men-debug cerita uji. <br><br><h2>  Penghapusan duplikasi informasi visual </h2><br>  Seperti yang saya katakan di atas, Gemini memungkinkan Anda untuk mengatur pemilih area tangkapan layar untuk test suite secara keseluruhan, yang berarti bahwa untuk sepenuhnya menyelesaikan masalah duplikasi informasi visual dalam tangkapan layar, kami harus membuat suite pengujian kami sendiri untuk setiap tangkapan layar.  Bahkan dengan mempertimbangkan optimalisasi memuat cerita, itu tidak terlihat terlalu optimis dalam hal kecepatan dan kami berpikir untuk mengganti mesin uji. <br><br>  Sebenarnya, mengapa Hermione?  Saat ini, repositori Gemini ditandai sebagai usang dan, cepat atau lambat, kami harus "pindah" ke suatu tempat.  Struktur file konfigurasi Hermione identik dengan struktur file konfigurasi Gemini dan kami dapat menggunakan kembali konfigurasi ini.  Plugin Gemini dan Hermione juga umum.  Selain itu, kami dapat menggunakan kembali infrastruktur uji - mesin virtual dan menggunakan selenium-grid. <br><br>  Tidak seperti Gemini, Hermione tidak diposisikan sebagai alat hanya untuk pengujian regresi tata letak.  Kemampuan manipulasi browsernya jauh lebih luas dan hanya dibatasi oleh kemampuan <a href="http://v4.webdriver.io/">Webdriver IO</a> .  Dalam kombinasi dengan <a href="https://github.com/mochajs/mocha">moka,</a> mesin ini nyaman digunakan lebih banyak untuk pengujian fungsional (mensimulasikan tindakan pengguna) daripada untuk pengujian tata letak.  Untuk pengujian regresi tata letak, Hermione hanya menyediakan metode assertView (), yang membandingkan tangkapan layar laman peramban dengan referensi.  Tangkapan layar dapat dibatasi pada area yang ditentukan menggunakan penyeleksi css. <br><br>  Untuk kasus kami, ujian untuk setiap cerita individu akan terlihat seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    describe('Visual regression', function() { it('Contract card should equal to etalon', function() { return this.browser //  story   .url('http://localhost:8080/iframe.html?selectedKind=visual-regression&amp;selectedStory=ContractDark') // ,      story .waitForVisible('.loading-stub', true) //          .assertView('layout', '.form'); }) });</span></span></code> </pre><br>  Metode waitForVisible (), terlepas dari namanya, memungkinkan Anda untuk mengharapkan tidak hanya penampilan, tetapi juga menyembunyikan elemen, jika Anda mengatur parameter kedua menjadi true.  Di sini kita menggunakannya untuk menunggu elemen marker disembunyikan, menunjukkan bahwa snapshot data belum dimuat dan cerita belum siap untuk tangkapan layar. <br><br>  Jika Anda mencoba menemukan metode waitForVisible () dalam dokumentasi Hermione, Anda tidak akan menemukan apa pun.  Faktanya adalah bahwa metode waitForVisible () <a href="http://v4.webdriver.io/api/utility/waitForVisible.html">adalah metode API WebOver IO</a> .  Metode url (), masing-masing juga.  Dalam metode url (), kami meneruskan alamat bingkai dari cerita tertentu, bukan keseluruhan buku cerita.  Pertama, ini diperlukan agar daftar cerita tidak ditampilkan di jendela browser - kita tidak perlu mengujinya.  Kedua, jika perlu, kita dapat memiliki akses ke elemen DOM di dalam bingkai (metode webdriverIO memungkinkan Anda untuk mengeksekusi kode JavaScript dalam konteks browser). <br><br>  Untuk menyederhanakan penulisan tes, kami membuat bungkus kami lebih dari tes moka.  Faktanya adalah bahwa tidak ada pengertian khusus dalam elaborasi rinci kasus uji untuk pengujian regresi.  Semua kasus uji adalah sama - 'harus sama dengan etalon'.  Yah, saya tidak ingin menduplikasi kode untuk menunggu pemuatan data di setiap tes.  Oleh karena itu, pekerjaan yang sama untuk semua tes "monyet" didelegasikan ke fungsi pembungkus, dan tes itu sendiri ditulis secara deklaratif (well, hampir).  Ini adalah teks dari fungsi ini: <br><br><div class="spoiler">  <b class="spoiler_title">buat-test-suite.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> themes = [ <span class="hljs-string"><span class="hljs-string">'default'</span></span>, <span class="hljs-string"><span class="hljs-string">'dark'</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rootClassName = <span class="hljs-string"><span class="hljs-string">'.explorer'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> loadingStubClassName = <span class="hljs-string"><span class="hljs-string">'.loading-stub'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timeout = <span class="hljs-number"><span class="hljs-number">2000</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTestSuite</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">testSuite</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { name, storyName, browsers, testCases, selector } = testSuite; <span class="hljs-comment"><span class="hljs-comment">//  ,       browsers &amp;&amp; hermione.only.in(browsers); //      themes.forEach(theme =&gt; { describe(`${name}_${theme}`, () =&gt; it('should equal to etalon', function() { let browser = this.browser //   story .url(`${storybookUrl}/iframe.html?selectedKind=visual-regression&amp;selectedStory=${storyName}-${theme}`) //     .waitForVisible(loadingStubClassName, timeout, true) .waitForVisible(rootClassName); //    (  ) if (testCases &amp;&amp; testCases.length &gt; 0) { testCases.forEach(testCase =&gt; { if (testCase.before) browser = testCase.before(browser); browser = browser.assertView(`${name}__${testCase.name}_${theme}`, testCase.selector || selector || rootClassName, testCase.options); }); return browser; } //    ,    return browser.assertView(`${name}_${theme}`, selector || rootClassName); })); }); }</span></span></code> </pre><br></div></div><br>  Objek yang mendeskripsikan suite tes dilewatkan ke input fungsi.  Setiap rangkaian uji dibangun sesuai dengan skenario berikut: ambil tangkapan layar dari tata letak utama (misalnya, area kartu entitas atau area daftar entitas), lalu tekan tombol pemrograman yang dapat mengarah pada penampilan elemen lain (misalnya, panel sembul atau menu konteks) dan â€œambil tangkapan layar Â»Setiap elemen tersebut secara terpisah.  Jadi, kami mensimulasikan tindakan pengguna di browser, tetapi tidak dengan tujuan menguji skenario bisnis, tetapi hanya untuk "menangkap" jumlah maksimum komponen visual yang mungkin.  Selain itu, duplikasi informasi visual dalam tangkapan layar minimal, karena  tangkapan layar diambil "secara searah" menggunakan penyeleksi.  Contoh test suite: <br><br><div class="spoiler">  <b class="spoiler_title">explorer-suite.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// explorer-suite.js //         module.exports = { //  story,    storyName: 'explorer', //    name: 'explorer', //  ,       browsers: [ 'chrome-1920x1080', 'ie-1920x1080' ], //   testCases: [ { //    name: 'layout' }, { //    name: 'notification-area', selector: '.notification-area__popup', before: b =&gt; b .click('.notification-area__popup-button') .waitForVisible('.notification-area__popup') .execute(function() { //       document.querySelectorAll('.expandable-item__content')[2].click(); }) }, //... ] };</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">tests.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// tests.js [ require('./suites/explorer-suite'), //... ] .forEach(suite =&gt; createTestSuite(suite));</span></span></code> </pre><br></div></div><br><h2>  Penentuan cakupan </h2><br>  Jadi, kami menemukan kecepatan dan redundansi, masih untuk mengetahui efektivitas pengujian kami, yaitu menentukan tingkat cakupan kode dengan tes (di sini dengan kode saya maksudkan style sheet CSS). <br><br>  Untuk cerita uji, kami secara empiris memilih kartu, daftar, dan elemen lain yang paling rumit untuk diisi agar dapat mencakup sebanyak mungkin gaya dengan satu tangkapan layar.  Misalnya, untuk menguji kartu entitas, kartu dengan sejumlah besar jenis kontrol yang berbeda (teks, nomor, transfer, tanggal, kisi, dll.) Dipilih.  Kartu untuk berbagai jenis entitas memiliki spesifiknya masing-masing, misalnya, panel dengan daftar versi dokumen dapat ditampilkan dari kartu dokumen, dan korespondensi pada tugas ini ditampilkan dalam kartu tugas.  Dengan demikian, untuk setiap jenis entitas, kisahnya sendiri dan serangkaian tes khusus untuk jenis ini, dll., Dibuat.  Pada akhirnya, kami memperkirakan bahwa segala sesuatu tampaknya ditutupi dengan tes, tetapi kami ingin sedikit lebih percaya diri daripada "suka". <br><br>  Untuk mengevaluasi cakupan di Chrome DevTools, ada alat dengan nama Cakupan yang sangat cocok untuk kasus ini: <br><br><img src="https://habrastorage.org/webt/ma/yt/dh/maytdhehcjiumoxdsdj-woa40lo.png"><br><br>  Cakupan memungkinkan Anda untuk menentukan gaya atau kode js mana yang digunakan saat bekerja dengan halaman browser.  Laporan tentang penggunaan garis hijau menunjukkan kode yang digunakan, merah - tidak digunakan.  Dan semuanya akan baik-baik saja jika kita memiliki aplikasi tingkat "halo, dunia", tetapi apa yang harus dilakukan ketika kita memiliki ribuan baris kode?  Pengembang cakupan memahami hal ini dengan baik dan menyediakan kemampuan untuk mengekspor laporan ke file yang sudah dapat dikerjakan secara terprogram. <br><br>  Saya harus mengatakan segera bahwa sejauh ini kami belum menemukan cara untuk mengumpulkan tingkat cakupan secara otomatis.  Secara teoritis, ini dapat dilakukan dengan menggunakan browser kepala tanpa kepala, tetapi pupeteer tidak bekerja di bawah kendali selenium, yang berarti bahwa kita tidak akan dapat menggunakan kembali kode pengujian kami.  Jadi untuk sekarang, mari kita lewati topik yang sangat menarik ini dan bekerja dengan pena. <br><br>  Setelah menjalankan tes dalam mode manual, kami mendapatkan laporan cakupan, yang merupakan file json.  Dalam laporan untuk setiap css, js, ts, dll.  file menunjukkan teksnya (dalam satu baris) dan interval kode yang digunakan dalam teks ini (dalam bentuk indeks karakter dari baris ini).  Di bawah ini adalah bagian dari laporan: <br><br><div class="spoiler">  <b class="spoiler_title">coverage.json</b> <div class="spoiler_text"><pre> <code class="json hljs">[ { <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://localhost:6006/theme-default.css"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ranges"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"end"</span></span>: <span class="hljs-number"><span class="hljs-number">8127</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"... --theme_primary-accent: #5b9bd5;\r\n --theme_primary-light: #ffffff;\r\n --theme_primary: #f4f4f4;\r\n ..."</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://localhost:6006/main.css"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ranges"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"end"</span></span>: <span class="hljs-number"><span class="hljs-number">610</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">728</span></span>, <span class="hljs-attr"><span class="hljs-attr">"end"</span></span>: <span class="hljs-number"><span class="hljs-number">754</span></span> } ] <span class="hljs-string"><span class="hljs-string">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"... \r\n line-height:1;\r\n}\r\n\r\nol, ul{\r\n list-style:none;\r\n}\r\n\r\nblockquote, q..."</span></span> ]</code> </pre><br></div></div><br>  Pada pandangan pertama, tidak ada yang sulit dalam menemukan penyeleksi css yang tidak digunakan.  Tetapi apa yang harus dilakukan dengan informasi ini?  Memang, dalam analisis akhir, kita perlu menemukan penyeleksi tidak spesifik, tetapi komponen yang kita lupa untuk menutup dengan tes.  Gaya satu komponen dapat diatur oleh lebih dari selusin penyeleksi.  Akibatnya, berdasarkan hasil analisis laporan, kami mendapatkan ratusan penyeleksi yang tidak digunakan, dan jika Anda berurusan dengan masing-masing dari mereka, Anda dapat menghabiskan banyak waktu. <br><br>  Di sini, ekspresi reguler membantu kami.  Tentu saja, mereka hanya akan berfungsi jika konvensi penamaan untuk kelas css terpenuhi (dalam kode kami, kelas css dinamai sesuai dengan metodologi BEM - block_name_name_name_ame_modifier).  Menggunakan ekspresi reguler, kami menghitung nilai unik dari nama blok, yang tidak lagi sulit untuk dikaitkan dengan komponen.  Tentu saja, kami juga tertarik pada elemen dan pengubah, tetapi tidak di tempat pertama, pertama kita perlu berurusan dengan "ikan" yang lebih besar.  Di bawah ini adalah skrip untuk memproses laporan Cakupan <br><br><div class="spoiler">  <b class="spoiler_title">coverage.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> modules = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./coverage.json'</span></span>).filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> e.url.endsWith(<span class="hljs-string"><span class="hljs-string">'.css'</span></span>)); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">module, rangeStart, rangeEnd, isUsed</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rules = <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.text.slice(rangeStart, rangeEnd); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rules) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> regex = <span class="hljs-regexp"><span class="hljs-regexp">/^\.([^\d{:,)_ ]+-?)+/gm</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> classNames = rules.match(regex); classNames &amp;&amp; classNames.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> selectors[name] = selectors[name] || isUsed); } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> previousEnd, selectors = {}; modules.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">module</span></span></span><span class="hljs-function"> =&gt;</span></span> { previousEnd = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> range <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.ranges) { processRange(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, previousEnd, range.start, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); processRange(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, range.start, range.end, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); previousEnd = range.end; } processRange(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, previousEnd, <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.length, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'className;isUsed'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(selectors).sort().forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${s}</span></span></span><span class="hljs-string">;</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${selectors[s]}</span></span></span><span class="hljs-string">`</span></span>); });</code> </pre><br></div></div><br>  Kami menjalankan skrip dengan terlebih dahulu meletakkan file coverage.json yang diekspor dari Chrome DevTools dan menulis knalpot ke file .csv: <br><br>  <b>node coverage.js&gt; coverage.csv</b> <br><br>  Anda dapat membuka file ini menggunakan excel dan menganalisis data, termasuk menentukan persentase cakupan kode dengan tes. <br><br><img src="https://habrastorage.org/webt/gh/ss/b8/ghssb8zrlh41pakcvwhyl6fcjge.png"><br><br><h2>  Alih-alih resume </h2><br>  Menggunakan buku cerita sebagai dasar untuk tes visual telah sepenuhnya dibenarkan sendiri - kami memiliki tingkat cakupan kode css yang cukup dengan tes dengan jumlah cerita yang relatif kecil dan biaya minimal untuk membuat yang baru. <br><br>  Transisi ke mesin baru memungkinkan kami untuk menghilangkan duplikasi informasi visual dalam tangkapan layar, yang sangat menyederhanakan dukungan tes yang ada. <br><br>  Tingkat cakupan kode css diukur dan, dari waktu ke waktu, dipantau.  Tentu saja ada pertanyaan besar - bagaimana tidak melupakan perlunya kendali ini dan bagaimana tidak ketinggalan sesuatu dalam proses mengumpulkan informasi tentang liputan.  Idealnya, saya ingin mengukur tingkat cakupan secara otomatis pada setiap uji coba, sehingga ketika ambang yang ditentukan tercapai, tes akan jatuh dengan kesalahan.  Kami akan mengerjakan ini, jika ada berita, saya pasti akan memberi tahu Anda. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id479040/">https://habr.com/ru/post/id479040/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id479022/index.html">Smart TV Samsung, LG, Vizio dan TCL setiap detik mengambil "sidik jari" layar dan mengirim ke server</a></li>
<li><a href="../id479026/index.html">Penjumlahan Sejati Saluran Internet - OpenMPTCPRouter</a></li>
<li><a href="../id479034/index.html">Bagaimana menghubungkan ke VPN perusahaan di Linux menggunakan openconnect dan vpn-slice</a></li>
<li><a href="../id479036/index.html">Intel tidak dapat mengatasi permintaan akan prosesor. Akibatnya, HP dan Dell menderita</a></li>
<li><a href="../id479038/index.html">Transformasi Digital Leroy Merlin: Merancang Antarmuka untuk Bekerja dengan Panggilan Pelanggan</a></li>
<li><a href="../id479042/index.html">Metode Y adalah cara yang sangat mudah untuk membangun Rubik's Cube</a></li>
<li><a href="../id479044/index.html">Implementasi ring ring saya di NOR flash</a></li>
<li><a href="../id479048/index.html">Node.js Streaming untuk boneka atau cara bekerja dengan aliran</a></li>
<li><a href="../id479050/index.html">Penelitian paten di bidang TI. Kursus pejuang muda. Bagian II Sumber informasi untuk penelitian paten</a></li>
<li><a href="../id479052/index.html">[Superkomputer 2019]. Penyimpanan multi-cloud sebagai aplikasi untuk drive Kingston DC1000M baru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>