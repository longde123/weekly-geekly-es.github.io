<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🤝‍👨🏽 🙎🏿 👩‍👩‍👧‍👦 Bagaimana cara mengatur jam tangan? Analisis trek front-end kejuaraan pemrograman kedua 🎓 💅🏾 ✌🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Habrapost baru dalam serangkaian analisis kejuaraan baru-baru ini. Peserta kualifikasi yang memilih bagian frontend harus menyelesaikan beberapa tugas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana cara mengatur jam tangan? Analisis trek front-end kejuaraan pemrograman kedua</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/478550/"><img src="https://habrastorage.org/webt/4e/n2/ks/4en2ksorc6zfdwcwfcvsceozmxg.jpeg" width="300" align="right">  Habrapost baru dalam serangkaian analisis kejuaraan baru-baru ini.  Peserta kualifikasi yang memilih bagian frontend harus menyelesaikan beberapa tugas dengan kompleksitas yang sangat berbeda: yang pertama (sesuai dengan harapan kami) memakan waktu 20 menit, yang terakhir - sekitar satu jam.  Kami menguji berbagai keterampilan pengembang antarmuka, termasuk kemampuan untuk memahami bidang subjek yang tidak biasa. <br><br><h2>  A. Musnahkan itu </h2>  <sup><i>Penulis: Maxim Sysoev, Konstantin Petryaev</i></sup> <br><br>  Tugas pertama adalah pemanasan.  Setiap peserta mendapat satu dari empat opsi untuk tugas tersebut, mirip satu sama lain.  Kami mengusulkan tidak hanya kondisi tekstual, tetapi juga solusi rekursif "buruk".  Itu perlu untuk mengulang kode (menulis algoritma serakah yang menghasilkan solusi tercepat), menghilangkan rekursi dan berbagai omong kosong seperti operasi dan perhitungan yang tidak perlu. <br><br><h4>  Ketentuan </h4><br>  Anda mendapat pekerjaan di laboratorium untuk mempelajari antimateri, di mana mereka melakukan berbagai percobaan.  Departemen Anda mempelajari proses yang terjadi saat menggabungkan materi dan antimateri.  Anda perlu melakukan serangkaian percobaan pada sejumlah molekul tertentu. <br><a name="habracut"></a><br>  Departemen tetangga telah mengembangkan alat yang mengubah materi menjadi antimateri untuk waktu yang singkat.  Ini akan bermanfaat bagi Anda dalam melakukan percobaan di mana algoritma berikut digunakan: <br><br>  - Kami menemukan 2 molekul terberat. <br>  - Kami mengubah salah satunya menjadi antimateri. <br>  - Gabungkan mereka.  Apalagi jika beratnya sama, mereka dimusnahkan.  Jika beratnya berbeda, maka kita mendapatkan molekul baru, yang beratnya sama dengan perbedaan bobot dari dua sebelumnya.  Molekul yang dihasilkan itu sendiri adalah materi. <br>  - Jika ada satu molekul yang tersisa, Anda perlu mencari tahu beratnya.  Jika ada banyak molekul, kita kembali ke langkah 1. <br><br>  Anda perlu mengetahui molekul berapa berat yang akan tersisa di akhir percobaan, pengetahuan ini dibutuhkan oleh para ilmuwan dari departemen lain. <br><br>  Pengembang sebelumnya membuat sketsa kode yang terlibat dalam perhitungan ini, tetapi kode tersebut tidak dapat menyelesaikan perhitungan saat percobaan dilakukan pada sejumlah besar molekul.  Anda perlu memperbaiki kode agar berfungsi dalam jumlah waktu yang wajar. <br><br>  <b>Kode diwarisi untuk Anda</b> <br><br>  Sebagai input, Anda akan memiliki array dengan bobot molekul.  Sebagai hasil, Anda harus mengembalikan angka yang menunjukkan berat molekul terakhir.  Jika tidak ada molekul yang tersisa, maka perlu untuk mengembalikan 0. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> findLatestWeight = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">weights, i = weights.length - </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cur = weights.length - <span class="hljs-number"><span class="hljs-number">1</span></span> === i; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i === <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> weights[<span class="hljs-number"><span class="hljs-number">0</span></span>]; weights.sort(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a - b); weights[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] = (weights[i] === weights[i<span class="hljs-number"><span class="hljs-number">-1</span></span>]) ? <span class="hljs-number"><span class="hljs-number">0</span></span> : weights[i] - weights[i<span class="hljs-number"><span class="hljs-number">-1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> findLatestWeight(weights, i - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Contoh dan catatan</b> <div class="spoiler_text"><h4>  Contoh </h4><br>  Pintu Masuk: [2,7,4,1,8,1] <br>  Output: 1 <br><br>  Kami mengambil molekul dengan berat 7 dan 8, mengubah 7 menjadi antimolekul dan menabraknya dengan molekul berat 8. Masih ada molekul berbobot 1. Berat molekul sisa baja [2,4,1,1,1].  Kami mengambil molekul dengan berat 2 dan 4, mengubah 2 menjadi antimolekul dan menabraknya dengan molekul berat 4. Masih ada molekul berat 2. Berat molekul sisa baja [2,1,1,1].  Kami mengambil molekul dengan berat 2 dan 1, mengubah 1 menjadi antimolekul dan menabraknya dengan molekul berat 2. Masih ada molekul berbobot 1. Bobot sisa molekul baja [1,1,1].  Kami mengambil molekul dengan berat 1 dan 1, mengubah salah satunya menjadi antimolekul dan berbenturan dengan yang kedua.  Mereka dimusnahkan.  Berat molekul yang tersisa [1].  Satu molekul tersisa.  Hasilnya adalah 1. <br><br><h4>  Catatan </h4><br>  Sebagai solusi, berikan file yang mengekspor versi terkoreksi dari fungsi findLatestWeight: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findLatestWeight</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">weights</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } module.exports = findLatestWeight;</span></span></code> </pre> <br>  Solusinya akan berjalan di Node.js 12. <br></div></div><br><h4>  Solusi </h4><br>  Solusi "buruk" yang diberikan memiliki beberapa masalah sekaligus.  Yang pertama adalah rekursi.  Seperti yang dinyatakan dalam kondisi tersebut, kami akan memproses sejumlah besar array, yang segera menghilangkan solusi rekursif. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> findLatestWeight = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">weights</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = weights.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i === <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> weights[<span class="hljs-number"><span class="hljs-number">0</span></span>] || <span class="hljs-number"><span class="hljs-number">0</span></span>; weights.sort(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a - b); weights[i<span class="hljs-number"><span class="hljs-number">-1</span></span>] = (weights[i]=== weights[i<span class="hljs-number"><span class="hljs-number">-1</span></span>]) ? <span class="hljs-number"><span class="hljs-number">0</span></span> : weights[i]-weights[i<span class="hljs-number"><span class="hljs-number">-1</span></span>]; i--; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre> <br>  Memperluas rekursi di sini cukup sederhana, namun, masalah lain muncul - ada penyortiran konstan (dari kecil ke besar) dan bekerja dengan akhir array.  Akibatnya, kami mendapatkan penurunan elemen kedua dari belakang dalam array.  Tetapi setelah itu kita tidak memangkas array, dan jika array sejuta elemen dilewatkan ke fungsi, maka kita akan mengurutkannya kembali sampai akhir. <br><br>  Pilihan untuk mengatasi masalah ini adalah mencoba untuk terus memangkas array. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> findLatestWeight = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">weights</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = weights.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i === <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> weights[<span class="hljs-number"><span class="hljs-number">0</span></span>] || <span class="hljs-number"><span class="hljs-number">0</span></span>; weights.sort(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a - b); weights[i<span class="hljs-number"><span class="hljs-number">-1</span></span>] = (weights[i]=== weights[i<span class="hljs-number"><span class="hljs-number">-1</span></span>]) ? <span class="hljs-number"><span class="hljs-number">0</span></span> : weights[i]-weights[i<span class="hljs-number"><span class="hljs-number">-1</span></span>]; weights.length = i; <span class="hljs-comment"><span class="hljs-comment">// &lt;---   i--; } while (true); }</span></span></code> </pre> <br>  Tidak buruk, tetapi kita juga harus menyingkirkan penyortiran, yang dengan sendirinya merupakan operasi yang mahal.  Pada umumnya, pada waktu tertentu, kami akan tertarik dengan 2 anggota array terbesar.  Artinya, itu adalah pencarian untuk dua tertinggi, yang dilakukan dalam satu pass cukup sederhana.  Untuk kenyamanan, kami melakukan pencarian seperti itu di fungsi yang terpisah. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> maximumTwo = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> max1 = arr[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> max2 = arr[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> max1I = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> max2I = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; arr.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[i] &gt; max1) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (max1 &gt; max2) { max2 = arr[i]; max2I = i; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { max1 = arr[i]; max1I = i; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[i] &gt; max2) { max2 = arr[i]; max2I = i; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (max1 &gt; max2) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [max2, max1, max2I, max1I]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [max1, max2, max1I, max2I]; };</code> </pre> <br>  Dan kami mengubah fungsi pencarian sebagai berikut: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fn = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">weights</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weights.length &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> weights[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [x, y, xI, yI] = maximumTwo(weights); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x === <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y; } weights[xI] = <span class="hljs-number"><span class="hljs-number">0</span></span>; weights[yI] = y - x; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); };</code> </pre> <br>  Dengan demikian, kita akan selalu nol yang lebih kecil dari dua elemen, dan mengubah yang lebih besar menjadi perbedaan di antara mereka.  Kami menyingkirkan penyortiran dan mendapatkan satu linear pass sebagai gantinya. <br><br>  Dari kesalahan umum yang kami perhatikan, para peserta mengambil elemen maksimum, mengalikannya dengan –1 dan menambahkannya ke batu terbesar kedua.  Hasilnya adalah angka negatif, yang kemudian digunakan dalam perhitungan "sebagaimana adanya".  Selain itu, tugas tersebut memiliki jebakan mental yang terkait dengan fakta bahwa Anda dapat mencoba untuk meninggalkan batu yang unik dalam berat dan menghitung perbedaannya.  Namun, pendekatan ini tidak memberikan hasil yang benar. <br><br><h2>  B. BEM </h2>  <sup><i>Penulis: Eugene Mishchenko, Vladimir Grinenko <a href="https://habr.com/ru/users/tadatuta/" class="user_link">tadatuta</a></i></sup> <br><br><h4>  Ketentuan </h4><br>  Layout Alexander terlibat dalam banyak proyek menggunakan metodologi BEM.  Dia bahkan membuat plugin yang berguna untuk IDE favoritnya, yang memungkinkannya untuk menulis nama kelas dalam notasi singkat dan menyebarkannya secara penuh.  Tetapi masalahnya adalah bahwa untuk setiap proyek, orang-orang mengatur pembatas yang berbeda antara blok, elemen dan pengubah (block__mod__val-elem, blok-mod-val ___ elem), dan setiap kali ia harus mengedit ini secara manual dalam plugin-nya.  Bantu Alexander menulis modul yang akan menentukan pemisah untuk entitas berdasarkan kelas.  Aturan untuk pembatas adalah jumlah karakter yang berubah-ubah (bukan huruf).  Contoh kemungkinan notasi (pengubah untuk blok dalam data input mungkin tanpa nilai): <br><br><pre> <code class="javascript hljs">block_mod__elem <span class="hljs-comment"><span class="hljs-comment">// ,     block_mod_mod__elem block__elem_mod_mod</span></span></code> </pre><br>  Klarifikasi: <br>  - Kelas dalam proyek hanya ditulis dalam huruf kecil. <br>  - Sebuah string dengan kelas CSS yang valid diumpankan ke input modul. <br><br>  Modul harus mengembalikan respons formulir: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">mod</span></span>: <span class="hljs-string"><span class="hljs-string">"_"</span></span>, <span class="hljs-comment"><span class="hljs-comment">//    elem: "__", //    }</span></span></code> </pre> <br>  Modul harus dikeluarkan sebagai modul commonJS: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">) </span></span>{ }</code> </pre> <br><h4>  Solusi </h4><br>  Tugas kedua memakan waktu sekitar 20 menit.  Dengan bantuannya, kami ingin menguji pengetahuan tentang ekspresi reguler di antara para peserta. <br><br>  Dari kondisi tersebut, kita belajar bahwa input ke fungsi akan berupa string yang berisi kelas CSS yang valid dengan batasan tambahan, di mana urutan huruf dipisahkan oleh urutan sewenang-wenang dari karakter non-huruf.  Tugas kita adalah menemukan pemisah dan memahami semantiknya. <br><br>  Bagian pertama dari nama kelas akan selalu menjadi nama blok.  Ini adalah urutan satu huruf atau lebih.  Kami menulis persamaan reguler yang sesuai: [az] +. <br><br>  Kita akan memerlukan ekspresi yang sama untuk mencari bagian yang tersisa: nama pengubah dan nilainya, atau nama elemen dengan pengubah dan nilai yang sesuai. <br><br>  Untuk mencari pembatas, kita perlu urutan non-huruf, ungkapan: [^ az] + cocok. <br><br>  Gabungkan dan tentukan grup yang nilainya akan kita gunakan: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [, mod, elem ] = str.match(<span class="hljs-regexp"><span class="hljs-regexp">/[az]+(?:([^az]+)[az]+(?:\1)?[az]+)([^az]+)[az]+(?:\2)?[az]+/</span></span>);</code> </pre> <br>  Sekarang Anda perlu memastikan bahwa kami mendefinisikan semantik dari grup yang ditemukan dengan benar.  Anda dapat memanfaatkan fakta bahwa hanya pengubah yang dapat bertemu dua kali. <br><br>  Kami akan menulis fungsi yang akan mengambil string asli dan pemisah ditemukan untuk menghitung jumlah kemunculan: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> substringCount = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">source, substr</span></span></span><span class="hljs-function">) =&gt;</span></span> (source.match(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">RegExp</span></span>(<span class="hljs-string"><span class="hljs-string">'[az]'</span></span> + substr + <span class="hljs-string"><span class="hljs-string">'[az]'</span></span>, <span class="hljs-string"><span class="hljs-string">'g'</span></span>)) || []).length;</code> </pre> <br>  Jika ternyata pembatas elem terjadi dua kali, dan mod - sekali, maka sebenarnya yang terjadi adalah sebaliknya.  Keputusan akhir: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [, mod, elem ] = str.match(<span class="hljs-regexp"><span class="hljs-regexp">/[az]+(?:([^az]+)[az]+(?:\1)?[az]+)([^az]+)[az]+(?:\2)?[az]+/</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> substringCount = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">source, substr</span></span></span><span class="hljs-function">) =&gt;</span></span> (source.match(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">RegExp</span></span>(<span class="hljs-string"><span class="hljs-string">'[az]'</span></span> + substr + <span class="hljs-string"><span class="hljs-string">'[az]'</span></span>, <span class="hljs-string"><span class="hljs-string">'g'</span></span>)) || []).length; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (substringCount(str, elem) === <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; substringCount(str, mod) === <span class="hljs-number"><span class="hljs-number">1</span></span>) { [mod, elem] = [elem, mod]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { mod, elem }; }</code> </pre> <br><h2>  C. Pabrik Klon </h2>  <sup><i>Penulis: Dmitry Andriyanov <a href="https://habr.com/ru/users/dima117/" class="user_link">dima117</a> , Alexey Gusev</i></sup> <br><br><h4>  Ketentuan </h4><br>  Di luar jendela adalah 2319.  Perusahaan mengkloning karyawan yang sukses untuk melakukan tugas yang kompleks. <br><br>  Dalam produksi klon, mereka memutuskan untuk memberi label "produk" baru dengan tato barcode di bahu mereka - untuk membedakan klon satu sama lain. <br><br>  Bantu staf pabrik menulis fungsi yang akan menggambar barcode dengan informasi tentang klon. <br><br>  <b>Format Informasi Klon</b> <br><br>  Informasi tentang klon disimpan sebagai berikut: <br><br><pre> <code class="javascript hljs">type CloneInfo = { <span class="hljs-comment"><span class="hljs-comment">/** *   —  'male'  'female' */</span></span> sex: string; <span class="hljs-comment"><span class="hljs-comment">/** *   —      *    ,  10  */</span></span> id: string; <span class="hljs-comment"><span class="hljs-comment">/** *   —      *     ( 0  26 ) */</span></span> name: string; }</code> </pre> <br>  <b>Algoritma Rendering Barcode</b> <br><br>  Barcode yang digunakan di pabrik klon terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/jl/jj/dc/jljjdcawcmcsrmsgyyi9bk19oii.png" width="400"><br><br>  Barcode memiliki ukuran tetap - 148 x 156 piksel.  Di sekeliling barcode terdapat bingkai hitam putih masing-masing 3 piksel.  Di dalam bingkai adalah konten barcode, terdiri dari 18 baris 17 kotak hitam atau putih per baris.  Ukuran setiap kotak adalah 8 kali 8 piksel. <br><br>  Kotak putih dalam konten menyandikan 0, hitam - 1. <br><br>  <b>Algoritma Pembuatan Konten Kode Batang</b> <br><br>  Di persimpangan baris pertama dan kolom konten pertama, sebuah kotak diambil yang mengkode jenis kelamin klon.  Nilai perempuan dikodekan oleh nol (putih), laki-laki oleh satu (hitam). <br><br>  Selanjutnya, garis formulir &lt;id&gt; &lt;name&gt; dibentuk dari kolom isian dan nama.  Bidang nama diisi dengan spasi di ujung hingga 26 karakter. <br><br>  String yang dihasilkan dikonversi menjadi array byte - setiap karakter string diberi kode ASCII yang sesuai (angka dari 0 hingga 255). <br><br>  Kemudian setiap elemen dari array yang dihasilkan diterjemahkan ke dalam notasi biner (delapan karakter 0 atau 1) dan dikodekan dengan urutan delapan kotak (0 - kuartrat putih, 1 - kotak hitam).  Kotak diambil dalam konten barcode secara berurutan dan baris demi baris. <br><br>  Baris terakhir konten berisi informasi kontrol. <br><br>  <b>Mengontrol Algoritma Penghitungan Informasi</b> <br><br>  Setiap kotak di garis informasi kontrol menentukan paritas jumlah nilai konten di kolom yang sesuai.  Jika jumlah nol dan yang ada di kolom adalah genap, maka kotak putih digambar dalam informasi kontrol, jika tidak, kotak hitam. <br><br><div class="spoiler">  <b class="spoiler_title">Format dan contoh solusi</b> <div class="spoiler_text">  <b>Format Solusi</b> <br><br>  Solusi yang Anda muat harus berisi fungsi renderBarcode: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *       element * @param cloneInfo {CloneInfo} —    * @param element {HTMLDivElement} — div    * 148x156 ,      */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">renderBarcode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cloneInfo, element</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   }&lt;/source lang="javascript"&gt;      Google Chrome 77. &lt;h4&gt; 1&lt;/h4&gt;   : &lt;source lang="javascript"&gt;{ "sex": "male", "id": "c5j818dyo5", "name": "Oleg Vladimirovich" }</span></span></code> </pre> <br>  Kode batang: <br><br><img src="https://habrastorage.org/webt/zm/pi/iz/zmpiiztvwzeo77-xswxzdrfhshs.png"><br><br><h4>  Contoh 2 </h4><br>  Informasi Klon: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"sex"</span></span>: <span class="hljs-string"><span class="hljs-string">"female"</span></span>, <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"0owrgqqwfw"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Dazdraperma Petrovna"</span></span> }</code> </pre> <br>  Kode batang: <br><br><img src="https://habrastorage.org/webt/9e/yk/vo/9eykvoqjupololm76rjmle7030k.png"></div></div><br><h4>  Solusi </h4><br>  Itu perlu untuk benar membentuk representasi biner dari data, menghitung checksum untuk itu dan menggambar data ini di tata letak.  Mari kita coba melakukan ini sesederhana dan mungkin dahi - tanpa optimasi kode. <br><br>  Mari kita mulai dengan representasi biner.  Pertama, deklarasikan fungsi pembantu: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    ASCII- function charToByte(char) { return char.charCodeAt(0); } //      0  1 (      ) function byteToString(byte) { return byte.toString(2).padStart(8, '0'); }</span></span></code> </pre> <br>  Kami membentuk dari sumber data string yang terdiri dari nol dan yang: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dataString = (cloneInfo.sex === <span class="hljs-string"><span class="hljs-string">'female'</span></span> ? <span class="hljs-string"><span class="hljs-string">'0'</span></span> : <span class="hljs-string"><span class="hljs-string">'1'</span></span>) + cloneInfo.id.split(<span class="hljs-string"><span class="hljs-string">''</span></span>).map(charToByte).map(byteToString).join(<span class="hljs-string"><span class="hljs-string">''</span></span>) + cloneInfo.name.padEnd(<span class="hljs-number"><span class="hljs-number">26</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>).split(<span class="hljs-string"><span class="hljs-string">''</span></span>).map(charToByte).map(byteToString).join(<span class="hljs-string"><span class="hljs-string">''</span></span>);</code> </pre> <br>  Kemudian tulis tata letak dan gaya untuk barcode kami: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,    «» . //  ,      DOM API   innerHTML,     . //     ,      ,      «». //         —   ,        . const contentElId = 'content-' + Math.random(); element.style.display = 'flex'; element.innerHTML = ` &lt;style&gt; .barcode { border: 3px solid black; box-sizing: border-box; } .content { margin-top: 3px; margin-left: 3px; width: 136px; height: 144px; display: flex; flex-wrap: wrap; } .content__bit { width: 8px; height: 8px; } .content__bit_one { background: black; } &lt;/style&gt; &lt;div class="content" id="${contentElId}"&gt;&lt;/div&gt; `; const contentDiv = document.getElementById(contentElId); element.className += ' barcode';</span></span></code> </pre> <br>  Jadikan data biner dalam tata letak: <br><br><pre> <code class="javascript hljs">dataString .split(<span class="hljs-string"><span class="hljs-string">''</span></span>) .forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bit</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bitDiv = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'div'</span></span>); bitDiv.className = <span class="hljs-string"><span class="hljs-string">'content__bit content__bit_'</span></span> + (bit === <span class="hljs-string"><span class="hljs-string">'0'</span></span> ? <span class="hljs-string"><span class="hljs-string">'zero'</span></span> : <span class="hljs-string"><span class="hljs-string">'one'</span></span>); contentDiv.appendChild(bitDiv); });</code> </pre> <br>  Tetap menghitung dan menampilkan checksum.  Ini bisa dilakukan seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">17</span></span>; i++) { <span class="hljs-comment"><span class="hljs-comment">//   let sum = 0; for (let j = i; j &lt; 17 ** 2; j += 17) { sum += parseInt(dataString[j], 2); } const check = 0; const bitDiv = document.createElement('div'); //       bitDiv.className = 'content__bit content__bit_' + (sum % 2 === 0 ? 'zero' : 'one'); contentDiv.appendChild(bitDiv); }</span></span></code> </pre> <br><h2>  D. Otomatiskan itu </h2>  <sup><i>Penulis: Vladimir Rusov, Dmitry Kanatnikov</i></sup> <br><br>  Di setiap opsi kualifikasi, ada tugas di mana halaman HTML dengan tabel atau daftar diusulkan sebagai input.  Tugas-tugas dari seri ini memiliki legenda yang berbeda, tetapi semuanya bermuara pada kenyataan bahwa Anda perlu membawa halaman ke format yang mirip dengan Markdown.  Kami akan menganalisis solusi untuk salah satu masalah. <br><br><h4>  Ketentuan </h4><br>  Di portal negara bagian untuk penyediaan layanan mereka memungkinkan untuk mengajukan dokumen sepenuhnya secara otomatis, untuk ini Anda hanya perlu mengisi tabel dengan data pribadi. <br><br>  Data ini kemudian ditransfer untuk verifikasi ke beberapa otoritas, termasuk Kementerian Dalam Negeri.  Setelah dimulainya pengujian, ternyata Kementerian Dalam Negeri menerima data dalam format Penurunan harga, dan Layanan Negara menggunakan format HTML.  Bantu saya menulis skrip untuk memigrasikan satu format ke format yang lain sehingga orang-orang segera memulai <br><br>  Anda perlu menulis fungsi yang mengambil tabel HTML sebagai input dan mengubahnya menjadi markup seperti penurunan harga. <br><br>  Sebagai solusi untuk tugas ini, kirim file .js di mana fungsi solusi dinyatakan: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">solution</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">input</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Input / Output Format dan Catatan</b> <div class="spoiler_text"><h4>  Format input </h4><br>  Tabel HTML hadir sebagai string: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">table</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">colgroup</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">col</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">align</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"right"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">col</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">col</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">align</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"center"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">colgroup</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">thead</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span>Command <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span>Description <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">th</span></span></span><span class="hljs-tag">&gt;</span></span>Is implemented <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">th</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">thead</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tbody</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">th</span></span></span><span class="hljs-tag">&gt;</span></span>git status<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">th</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span>List all new or modified files<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">th</span></span></span><span class="hljs-tag">&gt;</span></span>Yes<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">th</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">th</span></span></span><span class="hljs-tag">&gt;</span></span>git diff<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">th</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span>Show file differences that haven't been staged<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span>No<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tbody</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">table</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Tabel dapat berisi tag grup, thead, dan tbody dalam urutan yang tetap.  Semua tag ini bersifat opsional, tetapi setidaknya tag atau kartu akan selalu ada. <br><br>  - colgroup berisi tag col yang dapat memiliki atribut penyelarasan opsional dengan salah satu dari tiga nilai (kiri | tengah | kanan) <br>  - thead dan tbody berisi 1 atau lebih tr <br>  - tr, pada gilirannya, mengandung td dan th <br>  - Tabel akan selalu memiliki setidaknya satu baris.  - Baris akan selalu memiliki setidaknya satu sel.  - Setidaknya satu simbol non-spasi putih selalu ada dalam sel. <br>  - Jumlah elemen th / td dalam garis selalu bertepatan antara semua baris dan dengan jumlah elemen col dalam grup, jika ada grup. <br>  - Spasi dan jeda baris dalam HTML sumber dapat terjadi di mana saja yang tidak melanggar validitas HTML. <br><br><h4>  Format output </h4><br>  Output harus berupa garis dengan markdown markdown: <br><br> <code>| Command | Description | **Is implemented** | <br> | ---: | :--- | :---: | <br> | **git status** | List all new or modified files | **Yes** | <br> | **git diff** | Show file differences that haven't been staged | No |</code> <br> <br>  - Baris pertama yang ditemui dalam sebuah tabel harus selalu berubah menjadi baris tajuk dalam markdown markdown. <br>  - Semua baris lainnya masuk ke badan tabel. <br>  - Pemisah header selalu ditampilkan. <br>  - Isi td dimasukkan apa adanya, isi th sebagai ** tebal **. <br>  - Selalu ada satu ruang antara isi sel di markup markdown dan pembatas sel (|). <br>  - Spasi di tepi isi tag td dan th harus dihapus. <br>  - Hentian baris dalam konten sel harus dihapus. <br>  - Lebih dari satu spasi berturut-turut dalam isi sel harus diganti dengan satu spasi. <br>  - Untuk penyelarasan dalam sel kolom dari tabel penurunan harga, format pemisah header bertanggung jawab: <br><br>  |  : --- |  berarti perataan kiri <br>  |  : ---: |  berarti perataan tengah <br>  |  ---: |  berarti perataan kanan <br><br>  Jika tidak ada atribut align yang ditentukan dalam tag col, alignment harus diatur ke kiri. <br><br><h4>  Catatan </h4><br>  - Untuk umpan baris Anda harus menggunakan karakter \ n. <br>  - Solusinya akan diuji di lingkungan browser <b>(Chrome 78)</b> dengan akses ke dokumen dan objek jendela. <br>  - Anda dapat menggunakan sintaks hingga <b>es2018</b> inklusif. </div></div><br><h4>  Solusi </h4><br>  Masalahnya diselesaikan dengan hanya melintasi pohon DOM dari tabel.  Dukungan untuk pohon DOM diimplementasikan pada tingkat browser, ini merupakan bagian integral darinya, sehingga tidak akan ada masalah.  Untuk mengatasi masalah, cukup menerjemahkan pohon DOM dari HTML ke markdown Markup. <br><br>  Setelah memeriksa contoh-contohnya, Anda dapat melihat bahwa konversi tersebut cukup sederhana.  Di bawah ini adalah kode yang merupakan badan fungsi solusi (input). <br><br>  Pertama, kita perlu mengonversi string dari HTML ke struktur DOM: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> div = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'div'</span></span>); div.innerHTML = input; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> table = div.firstChild;</code> </pre> <br>  Setelah menerima pohon DOM, kita bisa melewatinya dan memproses data dari berbagai node DOM.  Untuk melakukan ini, cukup secara rekursif memotong urutan anak-anak dari berbagai elemen DOM: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processors = { <span class="hljs-string"><span class="hljs-string">'colgroup'</span></span>: processColgroup, <span class="hljs-string"><span class="hljs-string">'thead'</span></span>: processThead, <span class="hljs-string"><span class="hljs-string">'tbody'</span></span>: processTbody, }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> child <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> table.children) { processors[child.tagName.toLowerCase()](child); }</code> </pre> <br>  Dari colgroup dan tag col, kami tertarik untuk mengetahui perataan kolom tabel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> alignments = []; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> defaultAlign = <span class="hljs-string"><span class="hljs-string">'left'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processColgroup = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">colgroup</span></span></span><span class="hljs-function">) =&gt;</span></span> { alignments.push(...Array(...colgroup.children).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">col</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> col.align || defaultAlign; })); };</code> </pre> <br>  Dalam tag thead, tbody dan tr, kami hanya tertarik pada anak-anak: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rows = []; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processThead = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">thead</span></span></span><span class="hljs-function">) =&gt;</span></span> { rows.push(...Array(...thead.children).map(processTr)); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processTbody = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tbody</span></span></span><span class="hljs-function">) =&gt;</span></span> { rows.push(...Array(...tbody.children).map(processTr)); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processTr = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tr</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(...tr.children).map(processCell); };</code> </pre> <br>  Penting untuk tidak lupa bahwa, dengan konvensi, td dan th diformat secara berbeda: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processCell = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cell</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tag = cell.tagName.toLowerCase(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> content = clearString(cell.innerHTML); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-string"><span class="hljs-string">'td'</span></span>: content, <span class="hljs-string"><span class="hljs-string">'th'</span></span>: <span class="hljs-string"><span class="hljs-string">`**</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${content}</span></span></span><span class="hljs-string">**`</span></span>, }[tag]; };</code> </pre> <br>  Untuk bekerja dengan konten uji DOM, Anda harus memenuhi persyaratan yang dijelaskan dalam ketentuan: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clearLineBreaks = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">) =&gt;</span></span> str.replace(<span class="hljs-regexp"><span class="hljs-regexp">/\r?\n|\r/g</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clearSpaces = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">) =&gt;</span></span> str.replace(<span class="hljs-regexp"><span class="hljs-regexp">/\s+/g</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clearString = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">) =&gt;</span></span> clearSpaces(clearLineBreaks(str)).trim();</code> </pre> <br>  Setelah kami berjalan di sekitar pohon DOM, sebagian besar tabel kami ditulis ke deretan baris: <br><br> <code>[ <br> ["Command","Description","**Is implemented**"], <br> ["**git status**","List all new or modified files","**Yes**"], <br> ["**git diff**","Show file differences that haven't been staged","No"] <br> ]</code> <br> <br>  Informasi perataan kolom ada di larik perataan: <br><br> <code>["right","left","center"]</code> <br> <br>  Penting untuk diingat bahwa informasi perataan kolom mungkin tidak ada dalam input: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> updateAlignments = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (alignments.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; alignments.push(...rows[<span class="hljs-number"><span class="hljs-number">0</span></span>].map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> defaultAlign)); }; updateAlignments();</code> </pre> <br>  Konversi keberpihakan ke bentuk akhir: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> alignmentsContents = alignments.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">align</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-string"><span class="hljs-string">'left'</span></span>: <span class="hljs-string"><span class="hljs-string">' :--- '</span></span>, <span class="hljs-string"><span class="hljs-string">'center'</span></span>: <span class="hljs-string"><span class="hljs-string">' :---: '</span></span>, <span class="hljs-string"><span class="hljs-string">'right'</span></span>: <span class="hljs-string"><span class="hljs-string">' ---: '</span></span> }[align]; }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> delimiter = <span class="hljs-string"><span class="hljs-string">`|</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${alignmentsContents.join(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'|'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">|`</span></span>;</code> </pre> <br>  Nilai pembatas contoh: <br><br> <code>"| ---: | :--- | :---: |"</code> <br> <br>  Langkah terakhir adalah pembentukan garis Markdown yang berisi semua data yang dibaca dari HTML: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lineEnd = <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; rows.forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">row, i</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) markdown += lineEnd; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mdRow = <span class="hljs-string"><span class="hljs-string">`| </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${row.join(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">' | '</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string"> |`</span></span>; markdown += mdRow; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i === <span class="hljs-number"><span class="hljs-number">0</span></span>) { markdown += lineEnd; markdown += delimiter; } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> markdown;</code> </pre> <br>  Membangun kembali berarti bahwa semua kode di atas adalah badan fungsi solusi (input).  Sebagai hasil dari fungsi ini, kita mendapatkan kode tabel penurunan harga yang diinginkan ditunjukkan pada contoh output dari kondisi tugas. <br><br><h2>  E. Virus pandemi </h2>  <sup><i>Penulis: Andrey Mokrousov, Ivan Petukhov</i></sup> <br><br>  Organisasi Kesehatan Dunia telah menerbitkan laporan tentang tanda-tanda pandemi virus baru yang akan datang yang mengancam pengembang front-end.  Diketahui bahwa virus tidak memanifestasikan dirinya sampai tuan rumah melihat kode JS yang mengandung beberapa ekspresi.  Segera setelah orang yang terinfeksi melihat ungkapan ini, ia kehilangan kemampuannya untuk menulis kode dalam JS dan mulai secara spontan menulis kode dalam Fortran. <br><br>  Laporan tersebut menyebutkan bahwa virus diaktifkan dengan melihat penggunaan argumen pertama dari fungsi yang dilewatkan oleh argumen ke panggilan fungsi Zyn, yaitu, orang yang terinfeksi tidak dapat menunjukkan ekspresi seperti Zyn (fungsi (a, b, c) {console.log (a)}). <br><br>  Agar tidak kehilangan semua front-end mereka secara tidak sengaja, AST &amp; Co memutuskan untuk memeriksa apakah kode mereka mengandung ekspresi di atas.  Bantu insinyur perusahaan menulis cek semacam itu. <br><br>  Tentang kode AST &amp; Co, kita tahu bahwa: <br><br>  - ada tertulis dalam ES3, <br>  - akses ke properti dari suatu objek dimungkinkan baik melalui titik dan melalui tanda kurung (ab dan a ['b']), <br>  - bagian dari ekspresi dapat disimpan dalam variabel, tetapi tidak pernah diteruskan ke fungsi oleh parameter (a (x) - dilarang), <br>  - tidak ada fungsi yang mengembalikan bagian dari ekspresi yang diinginkan, <br> —      ,    , <br> —             (a[x], x — ), <br> —         , . .      var a = x; a = y;  var a = b = 1. <br><br><div class="spoiler"> <b class="spoiler_title">   </b> <div class="spoiler_text"><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Format Solusi </font></font></h4><br>       CommonJS-,   ,       (ast)  . <br><br>      ast-,       callback-,    Zyn      ,   . <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast</span></span></span><span class="hljs-function">) </span></span>{ ... return [...]; }</code> </pre> <br><h4>  Catatan </h4><br>         . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *   .     , *   callback- onNodeEnter (  ) *  onNodeLeave (  )    *     (  Scope ). * * @param {object} ast  ast. * @param {Function} [onNodeEnter=(node, scope)=&gt;{}]       . * @param {Function} [onNodeLeave=(node, scope)=&gt;{}]       . */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traverse</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> ast, onNodeEnter = (node, scope</span></span></span><span class="hljs-function">) =&gt; </span></span>{}, onNodeLeave = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node, scope</span></span></span><span class="hljs-function">) =&gt;</span></span> {} ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rootScope = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Scope(ast); _inner(ast, rootScope); <span class="hljs-comment"><span class="hljs-comment">/** *    . *     scope,   . * * @param {object} astNode ast-. * @param {Scope} currentScope   . * @return {Scope}      astNode. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolveScope</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">astNode, currentScope</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> isFunctionExpression = ast.type === <span class="hljs-string"><span class="hljs-string">'FunctionExpression'</span></span>, isFunctionDeclaration = ast.type === <span class="hljs-string"><span class="hljs-string">'FunctionDeclaration'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isFunctionExpression &amp;&amp; !isFunctionDeclaration) { <span class="hljs-comment"><span class="hljs-comment">//      . return currentScope; } //      . const newScope = new Scope(ast, currentScope); ast.params.forEach(param =&gt; { //     . newScope.add(param.name); }); if (isFunctionDeclaration) { //       . currentScope.add(ast.id.name); } else { //  -    . newScope.add(ast.id.name); } return newScope; } /** *    ast. * * @param {object} astNode  ast-. * @param {Scope} scope     ast-. */ function _inner(astNode, scope) { if (Array.isArray(astNode)) { astNode.forEach(node =&gt; { /*    . *  , ,  . */ _inner(node, scope); }); } else if (astNode &amp;&amp; typeof astNode === 'object') { onNodeEnter(astNode, scope); const innerScope = resolveScope(astNode, scope), keys = Object.keys(astNode).filter(key =&gt; { // loc -  ,   ast-. return key !== 'loc' &amp;&amp; astNode[key] &amp;&amp; typeof astNode[key] === 'object'; }); keys.forEach(key =&gt; { //   . _inner(astNode[key], innerScope); }); onNodeLeave(astNode, scope); } } } /** *   . * * @class Scope (name) * @param {object} astNode ast-,    . * @param {object} parentScope   . */ function Scope(astNode, parentScope) { this._node = astNode; this._parent = parentScope; this._vars = new Set(); } Scope.prototype = { /** *      . * * @param {string} name  . */ add(name) { this._vars.add(name); }, /** *       . * * @param {string} name  . * @return {boolean}          . */ isDefined(name) { return this._vars.has(name) || (this._parent &amp;&amp; this._parent.isDefined(name)); } };</span></span></code> </pre> </div></div><br><h4>  Solusi </h4><br>    . <br><br><blockquote> —    ES3 </blockquote> ,          . ,       . <br><br><blockquote> —        ,     (ab  a['b']) </blockquote>       Zyn,   Z['y'].n, Zy['n']  Z['y']['n']. <br><br><blockquote>       ,        (a(x) — ) </blockquote>         ,         . ,     : var x = Zy; xn(...). <br><br><blockquote> —  ,     , <br> —      ,    , <br> —         , ..      var a = x; a = y;  var a = b = 1. </blockquote>   (       )  ,        - . <br><br><blockquote> —     ,        (a[x], x — ) </blockquote>          ,    : var x = 'y'; Z[x].n(...). <br><br> C    : <br> 1.   ,     ,     . <br> 2.   ,     . <br><br> ,     ,         —          .        2. <br><br> <b> </b> <br><br>     :   Zyn(function(a, b, c){...}),  —     . <br><br>    FunctionExpression —      CallExpression,   callee — MemberExpression.   property — n,  object (  MemberExpression  object  property   y) — Z. <br><br>        ,      —  —  .     —  Identifier    ,      MemberExpression  ObjectLiteral    (xa  var x = {a: ...} ). <br><br><pre> <code class="javascript hljs">+++ b/traverse.js @@ <span class="hljs-number"><span class="hljs-number">-120</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span> +<span class="hljs-number"><span class="hljs-number">120</span></span>,<span class="hljs-number"><span class="hljs-number">59</span></span> @@ Scope.prototype = { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._vars.has(name) || <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">._parent &amp;&amp; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">._parent.isDefined(name</span></span></span><span class="hljs-function">)); } }; + +</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">module</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">exports</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast</span></span></span><span class="hljs-function">) { + </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">var</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function"> = []; + + </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">traverse</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast, (node, scope</span></span></span><span class="hljs-function">) =&gt;</span></span> { + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.type !== <span class="hljs-string"><span class="hljs-string">'CallExpression'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; + } + <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> args = node.arguments; + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (args.length !== <span class="hljs-number"><span class="hljs-number">1</span></span> || + args[<span class="hljs-number"><span class="hljs-number">0</span></span>].type !== <span class="hljs-string"><span class="hljs-string">'FunctionExpression'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; + } + <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> callee = node.callee; + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (callee.type !== <span class="hljs-string"><span class="hljs-string">'MemberExpression'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; + } + <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> property = callee.property, + object = callee.object; + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property.name !== <span class="hljs-string"><span class="hljs-string">'n'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; + } + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (object.type !== <span class="hljs-string"><span class="hljs-string">'MemberExpression'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; + } + property = object.property; + object = object.object; + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property.name !== <span class="hljs-string"><span class="hljs-string">'y'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; + } + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (object.type !== <span class="hljs-string"><span class="hljs-string">'Identifier'</span></span> || + object.name !== <span class="hljs-string"><span class="hljs-string">'Z'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; + } + + checkFunction(args[<span class="hljs-number"><span class="hljs-number">0</span></span>]); + }); + + <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast</span></span></span><span class="hljs-function">) </span></span>{ + <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstArg = ast.params[<span class="hljs-number"><span class="hljs-number">0</span></span>]; + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!firstArg) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; + } + + traverse(ast.body, (node, scope) =&gt; { + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.type !== <span class="hljs-string"><span class="hljs-string">'Identifier'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; + } + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.name === firstArg.name) { + result.push(node); + } + }); + } + + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; +};</code> </pre> <br>    traverse ,       ,      MemberExpression  ObjectProperty. : <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="javascript hljs">--- a/traverse.js +++ b/traverse.js @@ <span class="hljs-number"><span class="hljs-number">-60</span></span>,<span class="hljs-number"><span class="hljs-number">16</span></span> +<span class="hljs-number"><span class="hljs-number">60</span></span>,<span class="hljs-number"><span class="hljs-number">16</span></span> @@ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traverse</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> * @param {object} astNode  ast- * @param {Scope} scope     ast- *</span></span><span class="hljs-regexp"><span class="hljs-function"><span class="hljs-params"><span class="hljs-regexp">/ - function _inner(astNode, scope) { + function _inner(astNode, scope, parent) { if (Array.isArray(astNode)) { astNode.forEach(node =&gt; { /</span></span></span></span><span class="hljs-function"><span class="hljs-params">*    . *  , ,   *</span></span><span class="hljs-regexp"><span class="hljs-function"><span class="hljs-params"><span class="hljs-regexp">/ - _inner(node, scope); + _inner(node, scope, parent); }); } else if (astNode &amp;&amp; typeof astNode === 'object') { - onNodeEnter(astNode, scope); + onNodeEnter(astNode, scope, parent); const innerScope = resolveScope(astNode, scope), keys = Object.keys(astNode).filter(key =&gt; { @@ -80,10 +80,10 @@ function traverse( keys.forEach(key =&gt; { /</span></span></span></span><span class="hljs-regexp"><span class="hljs-function"><span class="hljs-params"><span class="hljs-regexp">/    - _inner(astNode[key], innerScope); + _inner(astNode[key], innerScope, astNode); }); - onNodeLeave(astNode, scope); + onNodeLeave(astNode, scope, parent); } } } @@ -164,10 +164,22 @@ module.exports = function (ast) { return; } - traverse(ast.body, (node, scope) =&gt; { + traverse(ast.body, (node, scope, parent) =&gt; { if (node.type !== 'Identifier') { return; } + if (!parent) { + return; + } + if (parent.type === 'MemberExpression' &amp;&amp; + parent.computed === false &amp;&amp; + parent.property === node) { + return; + } + if (parent.type === 'ObjectProperty' &amp;&amp; + parent.key === node) { + return; + } if (node.name === firstArg.name) { result.push(node); }</span></span></span></span></span></span></code> </pre> </div></div><br>         .   getPropName: <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="javascript hljs">--- a/traverse.js +++ b/traverse.js @@ <span class="hljs-number"><span class="hljs-number">-121</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span> +<span class="hljs-number"><span class="hljs-number">121</span></span>,<span class="hljs-number"><span class="hljs-number">18</span></span> @@ Scope.prototype = { } }; +<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPropName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node</span></span></span><span class="hljs-function">) </span></span>{ + <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> prop = node.property; + + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!node.computed) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prop.name; + } + + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prop.type === <span class="hljs-string"><span class="hljs-string">'StringLiteral'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prop.value; + } +} + <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = []; @@ <span class="hljs-number"><span class="hljs-number">-137</span></span>,<span class="hljs-number"><span class="hljs-number">17</span></span> +<span class="hljs-number"><span class="hljs-number">149</span></span>,<span class="hljs-number"><span class="hljs-number">17</span></span> @@ <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (callee.type !== <span class="hljs-string"><span class="hljs-string">'MemberExpression'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } - <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> property = callee.property, + <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> property = getPropName(callee), object = callee.object; - <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property.name !== <span class="hljs-string"><span class="hljs-string">'n'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property !== <span class="hljs-string"><span class="hljs-string">'n'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (object.type !== <span class="hljs-string"><span class="hljs-string">'MemberExpression'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } - property = object.property; + property = getPropName(object); object = object.object; - <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property.name !== <span class="hljs-string"><span class="hljs-string">'y'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property !== <span class="hljs-string"><span class="hljs-string">'y'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (object.type !== <span class="hljs-string"><span class="hljs-string">'Identifier'</span></span> ||</code> </pre> </div></div><br>      :        .        .     1. <br><br> <b> Scope</b> <br><br>    Scope       .  ,   ,        traverse: <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="javascript hljs">--- a/traverse.js +++ b/traverse.js @@ <span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span> +<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span> @@ +<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> scopeStorage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>(); + +<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getScopeFor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast, outerScope</span></span></span><span class="hljs-function">) </span></span>{ + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!scopeStorage.has(ast)) { + scopeStorage.set(ast, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Scope(ast, outerScope)); + } + + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> scopeStorage.get(ast); +} <span class="hljs-comment"><span class="hljs-comment">/** *   .     , *   callback- onNodeEnter (  ). @@ -13,7 +22,7 @@ function traverse( onNodeEnter = (node, scope) =&gt; {}, onNodeLeave = (node, scope) =&gt; {} ) { - const rootScope = new Scope(ast); + const rootScope = getScopeFor(ast); _inner(ast, rootScope); @@ -36,19 +45,19 @@ function traverse( } //      . - const newScope = new Scope(ast, currentScope); + const newScope = getScopeFor(ast, currentScope); ast.params.forEach(param =&gt; { //     . - newScope.add(param.name); + newScope.add(param.name, param); }); if (isFunctionDeclaration) { //       . - currentScope.add(ast.id.name); + currentScope.add(ast.id.name, ast); } else if (ast.id) { //  -    . - newScope.add(ast.id.name); + newScope.add(ast.id.name, ast); } return newScope; @@ -98,7 +107,7 @@ function traverse( function Scope(astNode, parentScope) { this._node = astNode; this._parent = parentScope; - this._vars = new Set(); + this._vars = new Map(); } Scope.prototype = { @@ -107,8 +116,24 @@ Scope.prototype = { * * @param {string} name   */</span></span> - add(name) { - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._vars.add(name); + add(name, value) { + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._vars.set(name, { + value: value, + scope: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> + }); + }, + resolve(node) { + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!node) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node; + } + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.type === <span class="hljs-string"><span class="hljs-string">'Identifier'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._vars.get(node.name); + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; + } + value = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">._parent &amp;&amp; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">._parent.resolve(node</span></span></span><span class="hljs-function">)); + </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">return</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">; + } }, /** *       . @@ -136,6 +161,12 @@ </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">getPropName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">module</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">exports</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">var</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function"> = []; + </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">traverse</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast, (node, scope</span></span></span><span class="hljs-function">) =&gt;</span></span> { + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.type === <span class="hljs-string"><span class="hljs-string">'VariableDeclarator'</span></span>) { + scope.add(node.id.name, node.init); + } + }); + traverse(ast, (node, scope) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.type !== <span class="hljs-string"><span class="hljs-string">'CallExpression'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> </div></div><br> <b> Scope</b> <br><br>      .        ,     Scope    . ,   Scope   ,        : <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="javascript hljs">--- a/traverse.js +++ b/traverse.js @@ <span class="hljs-number"><span class="hljs-number">-146</span></span>,<span class="hljs-number"><span class="hljs-number">13</span></span> +<span class="hljs-number"><span class="hljs-number">146</span></span>,<span class="hljs-number"><span class="hljs-number">17</span></span> @@ Scope.prototype = { } }; -<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPropName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node</span></span></span><span class="hljs-function">) </span></span>{ +<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPropName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node, scope</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> prop = node.property; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!node.computed) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prop.name; } + <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> resolved = scope.resolve(prop); + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (resolved) { + prop = resolved.value; + } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prop.type === <span class="hljs-string"><span class="hljs-string">'StringLiteral'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prop.value; } @@ <span class="hljs-number"><span class="hljs-number">-177</span></span>,<span class="hljs-number"><span class="hljs-number">22</span></span> +<span class="hljs-number"><span class="hljs-number">181</span></span>,<span class="hljs-number"><span class="hljs-number">43</span></span> @@ <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> callee = node.callee; + + <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> resolved = scope.resolve(callee); + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (resolved) { + callee = resolved.value; + scope = resolved.scope; + } + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (callee.type !== <span class="hljs-string"><span class="hljs-string">'MemberExpression'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } - <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> property = getPropName(callee), + <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> property = getPropName(callee, scope), object = callee.object; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property !== <span class="hljs-string"><span class="hljs-string">'n'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } + + resolved = scope.resolve(object); + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (resolved) { + object = resolved.value; + scope = resolved.scope; + } + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (object.type !== <span class="hljs-string"><span class="hljs-string">'MemberExpression'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } - property = getPropName(object); + property = getPropName(object, scope); object = object.object; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property !== <span class="hljs-string"><span class="hljs-string">'y'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } + + resolved = scope.resolve(object); + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (resolved) { + object = resolved.value; + scope = resolved.scope; + } + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (object.type !== <span class="hljs-string"><span class="hljs-string">'Identifier'</span></span> || object.name !== <span class="hljs-string"><span class="hljs-string">'Z'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> </div></div><br> <b> </b> <br><br>        :       .    : <br><br> —  ,  Z —     ,   - . <br> —  ,         ,        . <br> —       ,       var a = 'x', b = a. <br><br>    ,   . <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="javascript hljs">--- a/traverse.js +++ b/traverse.js @@ <span class="hljs-number"><span class="hljs-number">-128</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span> +<span class="hljs-number"><span class="hljs-number">128</span></span>,<span class="hljs-number"><span class="hljs-number">23</span></span> @@ Scope.prototype = { } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.type === <span class="hljs-string"><span class="hljs-string">'Identifier'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._vars.get(node.name); - <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value) { - <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!value) { + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._parent) { + value = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._parent.resolve(node); + } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { + <span class="hljs-comment"><span class="hljs-comment">//   scope,  node — + //   . + this.add(node.name, node); + return this.resolve(node); + } + } + if (!value) { + return; + } + if (value.value.type === 'Identifier' &amp;&amp; + value.value !== node) { + return value.scope.resolve(value.value) || value; } - value = (this._parent &amp;&amp; this._parent.resolve(node)); return value; } }, @@ -165,12 +178,15 @@ function getPropName(node, scope) { module.exports = function (ast) { var result = []; + traverse(ast, (node, scope) =&gt; { if (node.type === 'VariableDeclarator') { scope.add(node.id.name, node.init); } }); + let rootScope = getScopeFor(ast); + traverse(ast, (node, scope) =&gt; { if (node.type !== 'CallExpression') { return; @@ -213,9 +229,10 @@ module.exports = function (ast) { } resolved = scope.resolve(object); + let zScope; if (resolved) { object = resolved.value; - scope = resolved.scope; + zScope = resolved.scope; } if (object.type !== 'Identifier' || @@ -223,6 +240,10 @@ module.exports = function (ast) { return; } + if (zScope &amp;&amp; zScope !== rootScope) { + return; + } + checkFunction(args[0]); }); @@ -232,7 +253,10 @@ module.exports = function (ast) { return; } - traverse(ast.body, (node, scope, parent) =&gt; { + traverse(ast, (node, scope, parent) =&gt; { + if (parent === ast) { + return; + } if (node.type !== 'Identifier') { return; } @@ -248,7 +272,9 @@ module.exports = function (ast) { parent.key === node) { return; } - if (node.name === firstArg.name) { + + let resolved = scope.resolve(node); + if (resolved &amp;&amp; resolved.value === firstArg) { result.push(node); } });</span></span></code> </pre> </div></div><br>   : <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> scopeStorage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getScopeFor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast, outerScope</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!scopeStorage.has(ast)) { scopeStorage.set(ast, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Scope(ast, outerScope)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> scopeStorage.get(ast); } <span class="hljs-comment"><span class="hljs-comment">/** *   .     , *  callback- onNodeEnter (  ) *  onNodeLeave (  )    *     (  Scope ) * * @param {object} ast  ast * @param {Function} [onNodeEnter=(node, scope)=&gt;{}]        * @param {Function} [onNodeLeave=(node, scope)=&gt;{}]        */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traverse</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> ast, onNodeEnter = (node, scope</span></span></span><span class="hljs-function">) =&gt; </span></span>{}, onNodeLeave = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node, scope</span></span></span><span class="hljs-function">) =&gt;</span></span> {} ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rootScope = getScopeFor(ast); _inner(ast, rootScope); <span class="hljs-comment"><span class="hljs-comment">/** *    . *     scope,    * * @param {object} ast ast- * @param {Scope} currentScope    * @return {Scope}      astNode */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolveScope</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast, currentScope</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> isFunctionExpression = ast.type === <span class="hljs-string"><span class="hljs-string">'FunctionExpression'</span></span>, isFunctionDeclaration = ast.type === <span class="hljs-string"><span class="hljs-string">'FunctionDeclaration'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isFunctionExpression &amp;&amp; !isFunctionDeclaration) { <span class="hljs-comment"><span class="hljs-comment">//       return currentScope; } //       const newScope = getScopeFor(ast, currentScope); ast.params.forEach(param =&gt; { //      newScope.add(param.name, param); }); if (isFunctionDeclaration) { //        currentScope.add(ast.id.name, ast); } else if (ast.id) { //  -     newScope.add(ast.id.name, ast); } return newScope; } /** *    ast * * @param {object} astNode  ast- * @param {Scope} scope     ast- */ function _inner(astNode, scope, parent) { if (Array.isArray(astNode)) { astNode.forEach(node =&gt; { /*    . *  , ,   */ _inner(node, scope, parent); }); } else if (astNode &amp;&amp; typeof astNode === 'object') { onNodeEnter(astNode, scope, parent); const innerScope = resolveScope(astNode, scope), keys = Object.keys(astNode).filter(key =&gt; { // loc -  ,   ast- return key !== 'loc' &amp;&amp; astNode[key] &amp;&amp; typeof astNode[key] === 'object'; }); keys.forEach(key =&gt; { //    _inner(astNode[key], innerScope, astNode); }); onNodeLeave(astNode, scope, parent); } } } /** *    * * @class Scope (name) * @param {object} astNode ast-,     * @param {object} parentScope    */ function Scope(astNode, parentScope) { this._node = astNode; this._parent = parentScope; this._vars = new Map(); } Scope.prototype = { /** *       * * @param {string} name   */ add(name, value) { this._vars.set(name, { value: value, scope: this }); }, resolve(node) { if (!node) { return node; } if (node.type === 'Identifier') { let value = this._vars.get(node.name); if (!value) { if (this._parent) { value = this._parent.resolve(node); } else { //   scope,  node - //    this.add(node.name, node); return this.resolve(node); } } if (!value) { return; } if (value.value.type === 'Identifier' &amp;&amp; value.value !== node) { return value.scope.resolve(value.value) || value; } return value; } }, /** *       . * * @param {string} name   * @return {boolean}           */ isDefined(name) { return this._vars.has(name) || (this._parent &amp;&amp; this._parent.isDefined(name)); } }; function getPropName(node, scope) { let prop = node.property; if (!node.computed) { return prop.name; } let resolved = scope.resolve(prop); if (resolved) { prop = resolved.value; } if (prop.type === 'StringLiteral') { return prop.value; } } module.exports = function (ast) { var result = []; traverse(ast, (node, scope) =&gt; { if (node.type === 'VariableDeclarator') { scope.add(node.id.name, node.init); } }); let rootScope = getScopeFor(ast); traverse(ast, (node, scope) =&gt; { if (node.type !== 'CallExpression') { return; } let args = node.arguments; if (args.length !== 1 || args[0].type !== 'FunctionExpression') { return; } let callee = node.callee; let resolved = scope.resolve(callee); if (resolved) { callee = resolved.value; scope = resolved.scope; } if (callee.type !== 'MemberExpression') { return; } let property = getPropName(callee, scope), object = callee.object; if (property !== 'n') { return; } resolved = scope.resolve(object); if (resolved) { object = resolved.value; scope = resolved.scope; } if (object.type !== 'MemberExpression') { return; } property = getPropName(object, scope); object = object.object; if (property !== 'y') { return; } resolved = scope.resolve(object); let zScope; if (resolved) { object = resolved.value; zScope = resolved.scope; } if (object.type !== 'Identifier' || object.name !== 'Z') { return; } if (zScope &amp;&amp; zScope !== rootScope) { return; } checkFunction(args[0]); }); function checkFunction(ast) { let firstArg = ast.params[0]; if (!firstArg) { return; } traverse(ast, (node, scope, parent) =&gt; { if (parent === ast) { return; } if (node.type !== 'Identifier') { return; } if (!parent) { return; } if (parent.type === 'MemberExpression' &amp;&amp; parent.computed === false &amp;&amp; parent.property === node) { return; } if (parent.type === 'ObjectProperty' &amp;&amp; parent.key === node) { return; } let resolved = scope.resolve(node); if (resolved &amp;&amp; resolved.value === firstArg) { result.push(node); } }); } return result; };</span></span></code> </pre> </div></div><br><h2> F.  Framework- </h2> <sup><i>:  ,   <a href="https://habr.com/ru/users/collapsus/" class="user_link">collapsus</a></i></sup> <br><br>                  API.          —   ,    .         . <br><br><h4>  </h4><br>     —        .    .       ,         .     ! <br><br>         .     ,       .    ,         ,   ,    (       ).  ,        ,         0 (0 , 0 , 0 ). <br><br> ,    ,       .      JavaScript  JS-   Framework. <br><br>     : ,   .            ( ,    ).      ()   .             (  ). <br><br>         0.       ,    ( time)     . <br><br> <b>   </b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ONE_SECOND_DEGREES = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ONE_SECOND_FACTOR = <span class="hljs-number"><span class="hljs-number">1</span></span> / Framework.SPEED * ONE_SECOND_DEGREES; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClock</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Framework</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Clock</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arrows.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Framework.Arrow(<span class="hljs-string"><span class="hljs-string">"seconds"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"red"</span></span> })); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arrows.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Framework.Arrow(<span class="hljs-string"><span class="hljs-string">"minutes"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">weight</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">length</span></span>: <span class="hljs-number"><span class="hljs-number">80</span></span> })); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arrows.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Framework.Arrow(<span class="hljs-string"><span class="hljs-string">"hours"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">weight</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">length</span></span>: <span class="hljs-number"><span class="hljs-number">60</span></span> })); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buttons.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Framework.Button(<span class="hljs-string"><span class="hljs-string">"A"</span></span>, () =&gt; { alert(<span class="hljs-string"><span class="hljs-string">"A"</span></span>); })); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tick = <span class="hljs-number"><span class="hljs-number">0</span></span>; } onBeforeTick() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [arrow] = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arrows; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tick++; arrow.rotateFactor = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tick % <span class="hljs-number"><span class="hljs-number">10</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : ONE_SECOND_FACTOR; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"before: "</span></span> + arrow.pos); } onAfterTick() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [arrow] = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arrows; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"after: "</span></span> + arrow.pos); } }</code> </pre> <br>     : <br> —  —  ,   , <br> —      , <br> —  ,    ;     (100 )        ;   ,      . <br><br><h4>  Solusi </h4><br> ,      -,   «   »,      .    ,    ,      ,           . <br><br>       : ,   .       . ,       ,           . <br><br>         : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TPS = <span class="hljs-number"><span class="hljs-number">1000</span></span> / Framework.INTERVAL; <span class="hljs-comment"><span class="hljs-comment">//   </span></span></code> </pre> <br>       //      . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTarget</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ticks, planet</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { h, m, s } = planet; <span class="hljs-comment"><span class="hljs-comment">//    const ts = Math.floor(ticks / TPS); //   const ss = ts % s * 360 / s; const mm = Math.floor(ts / s) % m * 360 / m; const hh = Math.floor(ts / (s * m)) % h * 360 / h; return { hh, mm, ss }; }</span></span></code> </pre> <br>   ,          —     rotateFactor.      getRotateFactor,     ,       ,    .     : <br> 1.   , <br> 2.  . <br><br>         .    . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRotateFactor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos, target, forward = true</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> angle = target - pos; <span class="hljs-comment"><span class="hljs-comment">//        if (forward) { //      angle &lt; 0 &amp;&amp; (angle += 360); //        0  360 ( 360   0),    } else { //         Math.abs(angle) &gt; 180 &amp;&amp; (angle -= Math.sign(angle) * 360) } return angle / Framework.SPEED; }</span></span></code> </pre> <br>     ,    MAX_SPEED    .      getRotateFactor. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MAX_FACTOR = Framework.MAX_SPEED / Framework.SPEED; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRotateFactor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos, target, forward = true</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> angle = target - pos; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (forward) { angle &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; (angle += <span class="hljs-number"><span class="hljs-number">360</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.abs(angle) &gt; <span class="hljs-number"><span class="hljs-number">180</span></span> &amp;&amp; (angle -= <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sign(angle) * <span class="hljs-number"><span class="hljs-number">360</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> factor = angle / Framework.SPEED; <span class="hljs-comment"><span class="hljs-comment">//      ,    return Math.abs(factor) &gt; MAX_FACTOR ? Math.sign(factor) * MAX_FACTOR : factor; }</span></span></code> </pre> <br>       : <br><br><pre> <code class="javascript hljs">buttonAHandler() { <span class="hljs-comment"><span class="hljs-comment">//     this.pos = (this.pos + 1) % this.planets.length; //      this.forward = false; }</span></span></code> </pre> <br>  ,     : <br><br><pre> <code class="javascript hljs">onBeforeTick() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [sec, min, hour] = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arrows; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> time = ++<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ticks; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> planet = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.planets[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.pos]; <span class="hljs-comment"><span class="hljs-comment">//        const target = getTarget(time, planet); //      sec.rotateFactor = getRotateFactor(sec.pos, target.ss, this.forward); min.rotateFactor = getRotateFactor(min.pos, target.mm, this.forward); hour.rotateFactor = getRotateFactor(hour.pos, target.hh, this.forward); //       ,       !sec.rotateFactor &amp;&amp; !min.rotateFactor &amp;&amp; !hour.rotateFactor &amp;&amp; (this.forward = true); }</span></span></code> </pre> <br>   : <br><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TPS = <span class="hljs-number"><span class="hljs-number">1000</span></span> / Framework.INTERVAL; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MAX_FACTOR = Framework.MAX_SPEED / Framework.SPEED; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTarget</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ticks, planet</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { h, m, s } = planet; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ts = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(ticks / TPS); <span class="hljs-comment"><span class="hljs-comment">// total seconds const ss = ts % s * 360 / s; const mm = Math.floor(ts / s) % m * 360 / m; const hh = Math.floor(ts / (s * m)) % h * 360 / h; return { hh, mm, ss }; } function getRotateFactor(pos, target, forward = true) { let angle = target - pos; if (forward) { angle &lt; 0 &amp;&amp; (angle += 360); } else { Math.abs(angle) &gt; 180 &amp;&amp; (angle -= Math.sign(angle) * 360) } const factor = angle / Framework.SPEED; return Math.abs(factor) &gt; MAX_FACTOR ? Math.sign(factor) * MAX_FACTOR : factor; } class MyClock extends Clock { // planets -   // [ { h: 4, m: 20, s: 10 }, ... ] constructor({ planets, time }) { super(); this.arrows.push(new Arrow('seconds', { color: 'red' })); this.arrows.push(new Arrow('minutes', { weight: 3, length: 80 })); this.arrows.push(new Arrow('hours', { weight: 3, length: 60 })); this.buttons.push(new Button('Switch', this.buttonAHandler.bind(this))); this.planets = planets; this.ticks = time * TPS; this.pos = 0; this.forward = false; } onBeforeTick() { const [sec, min, hour] = this.arrows; const time = ++this.ticks; const planet = this.planets[this.pos]; const target = getTarget(time, planet); sec.rotateFactor = getRotateFactor(sec.pos, target.ss, this.forward); min.rotateFactor = getRotateFactor(min.pos, target.mm, this.forward); hour.rotateFactor = getRotateFactor(hour.pos, target.hh, this.forward); !sec.rotateFactor &amp;&amp; !min.rotateFactor &amp;&amp; !hour.rotateFactor &amp;&amp; (this.forward = true); } buttonAHandler() { this.pos = (this.pos + 1) % this.planets.length; this.forward = false; } }</span></span></code> </pre> </div></div><br> <b></b> <br><br>   .              .  ,  ,     ,             . <br><br>    :   ,  ,  ,   ,      (,   ,      ). <br><br> <b></b> <br><br>    .           .     — ,      .         . <br><br>   ,      .      ,     (   )  18 . <br><br><hr><br> : <br><br> — <a href="https://habr.com/ru/company/yandex/blog/477452/"> ML-  </a> <br> — <a href="https://habr.com/ru/company/yandex/blog/460139/"> -  </a> <br> — <a href="https://habr.com/ru/company/yandex/blog/430560/"> -    </a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id478550/">https://habr.com/ru/post/id478550/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id478538/index.html">Cara memeriksa validitas paspor Anda</a></li>
<li><a href="../id478540/index.html">Persiapan untuk forum kesepuluh "Positive Hack Days 10: Memulai"</a></li>
<li><a href="../id478542/index.html">FigmaGen: Otomasi Gaya di Aplikasi iOS</a></li>
<li><a href="../id478544/index.html">Vue Storefront: Impor Direktori dari Magento 2</a></li>
<li><a href="../id478546/index.html">Soket web Beberapa pengalaman dalam pengembangan dan operasi. Kami memodifikasi klien</a></li>
<li><a href="../id478552/index.html">Applet kedua, menutupnya dan tombol transparan dalam Memproses 3</a></li>
<li><a href="../id478554/index.html">Webinar "SRE - sensasi atau masa depan?" 12 Desember pukul 11:00</a></li>
<li><a href="../id478560/index.html">Apakah pengirim pesan instan gratis anonim?</a></li>
<li><a href="../id478564/index.html">Bagaimana kami di TsIAN menjinakkan terabyte log</a></li>
<li><a href="../id478572/index.html">Bot di jaringan saraf: bagaimana asisten virtual bekerja dan belajar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>