<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï¥Ô∏è üß£ üê® Swift funcional √© f√°cil üóúÔ∏è üóúÔ∏è ü•ë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Os artigos sobre programa√ß√£o funcional escrevem muito sobre como a abordagem FP melhora o desenvolvimento: torna-se f√°cil escrever, ler, transmitir, c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Swift funcional √© f√°cil</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redmadrobot/blog/455359/"><p><img src="https://habrastorage.org/webt/ly/by/ev/lybyevylxskr_odybeuhzn4ywa4.jpeg" alt="imagem"></p><br><p>  Os artigos sobre programa√ß√£o funcional escrevem muito sobre como a abordagem FP melhora o desenvolvimento: torna-se f√°cil escrever, ler, transmitir, codificar, testar, criar arquitetura ruim <del>  e o cabelo fica macio e sedoso </del>  . </p><br><p>  Uma desvantagem √© o alto limite de entrada.  Tentando entender o FP, deparei-me com uma enorme quantidade de teoria, functores, m√¥nadas, teoria de categorias e tipos de dados alg√©bricos.  E como aplicar AF na pr√°tica n√£o era claro.  Al√©m disso, foram dados exemplos em idiomas desconhecidos para mim - Haskell e rock. </p><br><p>  Ent√£o eu decidi descobrir o PF desde o come√ßo.  Eu descobri e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">disse ao codefest</a> que o FP √© realmente apenas o que j√° usamos no Swift e podemos us√°-lo ainda mais eficientemente. </p><a name="habracut"></a><br><h2 id="funkcionalnoe-programmirovanie-chistye-funkcii-i-otsutstvie-sostoyaniy">  Programa√ß√£o funcional: fun√ß√µes puras e falta de estados </h2><br><p>  Determinar o que significa escrever em um paradigma espec√≠fico n√£o √© uma tarefa f√°cil.  Os paradigmas s√£o formados h√° d√©cadas por pessoas com vis√µes diferentes, incorporadas em linguagens com abordagens diferentes e cercadas de ferramentas.  Essas ferramentas e abordagens s√£o consideradas parte integrante dos paradigmas, mas, na realidade, n√£o s√£o. </p><br><p>  Por exemplo, acredita-se que a programa√ß√£o orientada a objetos se sustenta em tr√™s pilares - heran√ßa, encapsulamento e polimorfismo.  Mas o encapsulamento e o polimorfismo s√£o implementados em fun√ß√µes com a mesma facilidade que em objetos.  Ou encerramentos - eles nasceram em linguagens funcionais puras, mas por tanto tempo migraram para linguagens industriais que deixaram de ser associados ao FP.  As m√¥nadas tamb√©m chegam √†s l√≠nguas industriais, mas ainda n√£o perderam sua participa√ß√£o no Haskell condicional na mente das pessoas. </p><br><p>  Como resultado, acontece que √© imposs√≠vel determinar claramente o que √© um paradigma espec√≠fico.  Mais uma vez, me deparei com isso no codefest 2019, onde todos os especialistas em PF, falando sobre o paradigma funcional, chamavam coisas diferentes. </p><br><p>  Pessoalmente, gostei da defini√ß√£o do wiki: </p><br><p>  ‚ÄúA programa√ß√£o funcional √© uma se√ß√£o da matem√°tica discreta e um paradigma de programa√ß√£o no qual o processo de c√°lculo √© tratado como o c√°lculo dos valores das fun√ß√µes no entendimento matem√°tico das √∫ltimas (em oposi√ß√£o a fun√ß√µes como subprogramas na programa√ß√£o processual).‚Äù </p><br><p>  O que √© uma fun√ß√£o matem√°tica?  Esta √© uma fun√ß√£o cujo resultado depende apenas dos dados aos quais √© aplicado. </p><br><p>  Um exemplo de fun√ß√£o matem√°tica em quatro linhas de c√≥digo √© semelhante a este: </p><br><pre><code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Int, b: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = summ(a: <span class="hljs-number"><span class="hljs-number">2</span></span>, b: <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br><p>  Chamando a fun√ß√£o summ com os argumentos de entrada 2 e 3, obtemos 5. Esse resultado √© inalterado.  Mude o programa, thread, local de execu√ß√£o - o resultado permanecer√° o mesmo. </p><br><p>  E uma fun√ß√£o n√£o matem√°tica √© quando uma vari√°vel global √© declarada em algum lugar. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> z = <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre> <br><p>  A fun√ß√£o soma agora adiciona os argumentos de entrada e o valor de z. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Int, b: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b + z } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = summ(a: <span class="hljs-number"><span class="hljs-number">2</span></span>, b: <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br><p>  Depend√™ncia adicionada ao estado global.  Agora √© imposs√≠vel prever inequivocamente o valor de x.  Ele muda constantemente, dependendo de quando a fun√ß√£o foi chamada.  Chamamos a fun√ß√£o 10 vezes seguidas e a cada vez podemos obter um resultado diferente. </p><br><p>  Outra vers√£o da fun√ß√£o n√£o matem√°tica: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Int, b: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { z = b - a <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b }</code> </pre> <br><p>  Al√©m de retornar a soma dos argumentos de entrada, a fun√ß√£o altera a vari√°vel global z.  Esse recurso tem um efeito colateral. </p><br><p>  A programa√ß√£o funcional possui um termo especial para fun√ß√µes matem√°ticas - fun√ß√µes puras.  Uma fun√ß√£o pura √© uma fun√ß√£o que retorna o mesmo resultado para o mesmo conjunto de valores de entrada e n√£o tem efeitos colaterais. </p><br><p>  Fun√ß√µes puras s√£o a pedra angular do FP, todo o resto √© secund√°rio.  Sup√µe-se que, seguindo esse paradigma, os utilizemos apenas.  E se voc√™ n√£o trabalhar com estados globais ou mut√°veis, eles n√£o estar√£o no aplicativo. </p><br><h2 id="klassy-i-struktury-v-funkcionalnoy-paradigme">  Classes e estruturas em um paradigma funcional </h2><br><p>  Inicialmente, pensei que FP fosse apenas sobre fun√ß√µes, e classes e estruturas s√£o usadas apenas no OOP.  Mas as aulas tamb√©m se encaixam no conceito de FP.  Somente eles devem ser, digamos, "limpos". </p><br><p>  Uma classe "pura" √© uma classe, cujos m√©todos s√£o fun√ß√µes puras e propriedades imut√°veis.  (Este √© um termo n√£o oficial, cunhado na prepara√ß√£o do relat√≥rio). </p><br><p>  D√™ uma olhada nesta classe: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> surname: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> email: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFullname</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name + <span class="hljs-string"><span class="hljs-string">" "</span></span> + surname } }</code> </pre> <br><p>  Pode ser considerado como encapsulamento de dados ... </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> surname: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> email: <span class="hljs-type"><span class="hljs-type">String</span></span> }</code> </pre><br><p>  e fun√ß√µes para trabalhar com eles. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFullname</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name + <span class="hljs-string"><span class="hljs-string">" "</span></span> + surname }</code> </pre> <br><p>  Do ponto de vista do FP, usar a classe User n√£o √© diferente de trabalhar com primitivas e fun√ß√µes. </p><br><p>  Declare o valor - usu√°rio Vanya. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ivan = <span class="hljs-type"><span class="hljs-type">User</span></span>( name: <span class="hljs-string"><span class="hljs-string">""</span></span>, surname: <span class="hljs-string"><span class="hljs-string">""</span></span>, email: <span class="hljs-string"><span class="hljs-string">"ivanov@example.com"</span></span> )</code> </pre> <br><p>  Aplique a fun√ß√£o getFullname a ela. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fullName = ivan.getFullname()</code> </pre> <br><p>  Como resultado, obtemos um novo valor - o nome de usu√°rio completo.  Como voc√™ n√£o pode alterar os par√¢metros da propriedade ivan, o resultado da chamada de getFullname permanece inalterado. </p><br><p>  Obviamente, um leitor atento pode dizer: "Espere um minuto, o m√©todo getFullname retorna o resultado com base em valores globais para ele - propriedades de classe, n√£o argumentos".  Mas, na verdade, um m√©todo √© apenas uma fun√ß√£o na qual um objeto √© passado como argumento. </p><br><p>  Swift ainda suporta esta entrada explicitamente: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fullName = <span class="hljs-type"><span class="hljs-type">User</span></span>.getFullname(ivan)()</code> </pre> <br><p>  Se precisarmos alterar algum valor do objeto, por exemplo, email, teremos que criar um novo objeto.  Isso pode ser feito pelo m√©todo apropriado. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> surname: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> email: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">change</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(email: String)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">User</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">User</span></span>(name: name, surname: surname, email: email) } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newIvan = ivan.change(email: <span class="hljs-string"><span class="hljs-string">"god@example.com"</span></span>)</code> </pre> <br><h2 id="funkcionalnye-atributy-v-swift">  Atributos funcionais no Swift </h2><br><p>  Eu j√° escrevi que muitas ferramentas, implementa√ß√µes e abordagens consideradas parte de um paradigma podem realmente ser usadas em outros paradigmas.  Por exemplo, m√¥nadas, tipos de dados alg√©bricos, infer√™ncia autom√°tica de tipos, tipagem estrita, tipos dependentes e valida√ß√£o de programa durante a compila√ß√£o s√£o considerados parte do FP.  Mas muitas dessas ferramentas podemos encontrar no Swift. </p><br><p>  Digita√ß√£o forte e infer√™ncia de tipo fazem parte do Swift.  Eles n√£o precisam ser entendidos ou introduzidos no projeto, apenas os temos. </p><br><p>  N√£o h√° tipos dependentes, embora eu n√£o me recusei a verificar a sequ√™ncia de caracteres pelo compilador: √© um email, uma matriz, que n√£o est√° vazio, um dicion√°rio, que cont√©m a chave da apple.  A prop√≥sito, tamb√©m n√£o h√° tipos dependentes em Haskell. </p><br><p>  Tipos de dados alg√©bricos est√£o dispon√≠veis, e isso √© uma coisa matem√°tica interessante, mas dif√≠cil de entender.  A beleza √© que ele n√£o precisa ser entendido matematicamente para us√°-lo.  Por exemplo, Int, enum, Opcional, Hashable s√£o tipos alg√©bricos.  E se Int estiver em muitos idiomas e Protocol estiver em Objective-C, ent√£o enum com valores associados, protocolos com implementa√ß√£o padr√£o e tipos associativos est√£o longe de qualquer lugar. </p><br><p>  A valida√ß√£o de compila√ß√£o √© frequentemente referida quando se fala em idiomas como ferrugem ou haskell.  Entende-se que a linguagem √© t√£o expressiva que permite descrever todos os casos extremos para que sejam verificados pelo compilador.  Portanto, se o programa foi compilado, certamente funcionar√°.  Ningu√©m contesta que ele pode conter erros na l√≥gica, porque voc√™ filtrou incorretamente os dados para exibi√ß√£o no usu√°rio.  Mas n√£o cair√°, porque voc√™ n√£o recebeu dados do banco de dados, o servidor retornou a resposta errada para a qual voc√™ estava contando ou o usu√°rio digitou sua data de nascimento como uma sequ√™ncia, n√£o como um n√∫mero. </p><br><p>  N√£o posso dizer que a compila√ß√£o de c√≥digo r√°pido possa detectar todos os erros: por exemplo, √© f√°cil evitar um vazamento de mem√≥ria.  Mas digita√ß√£o forte e opcional protegem contra muitos erros est√∫pidos.  O principal √© limitar a extra√ß√£o for√ßada. </p><br><h2 id="monady-ne-chast-paradigmy-fp-a-instrument-neobyazatelnyy">  M√¥nadas: n√£o faz parte do paradigma FP, mas uma ferramenta (opcional) </h2><br><p>  Freq√ºentemente, FPs e m√¥nadas s√£o usados ‚Äã‚Äãno mesmo aplicativo.  Ao mesmo tempo, eu at√© pensei que as m√¥nadas s√£o programa√ß√£o funcional.  Quando os compreendi (mas isso n√£o √© exato), tirei v√°rias conclus√µes: </p><br><ul><li>  eles s√£o simples; </li><li>  eles s√£o confort√°veis; </li><li>  entend√™-los opcionalmente, basta poder aplicar; </li><li>  voc√™ pode facilmente ficar sem eles. </li></ul><br><p>  O Swift j√° possui duas m√¥nadas padr√£o - Opcional e Resultado.  Ambos s√£o necess√°rios para lidar com efeitos colaterais.  Opcional protege contra poss√≠vel nulo.  Resultado - de v√°rias situa√ß√µes excepcionais. </p><br><p>  Considere o exemplo levado ao ponto do absurdo.  Suponha que tenhamos fun√ß√µes que retornam um n√∫mero inteiro do banco de dados e do servidor.  O segundo pode retornar nulo, mas usamos a extra√ß√£o impl√≠cita para obter o comportamento do Objective-C-time. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromDB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int!</span></span></code> </pre> <br><p>  Continuamos a ignorar Opcional e implementamos uma fun√ß√£o para somar esses n√∫meros. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summInts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int!</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromDB = getIntFromDB() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromServer = getIntFromServer()! <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> summ = intFromDB + intFromServer <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> summ }</code> </pre> <br><p>  Chamamos a fun√ß√£o final e usamos o resultado. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = summInts() <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(result)</code> </pre> <br><p>  Este exemplo funcionar√°?  Bem, definitivamente compila, mas n√£o sabemos se a falha ocorre em tempo de execu√ß√£o ou n√£o.  Esse c√≥digo √© bom, mostra perfeitamente nossas inten√ß√µes (precisamos da soma de dois n√∫meros) e n√£o cont√©m nada de sup√©rfluo.  Mas ele √© perigoso.  Portanto, apenas juniores e pessoas confiantes escrevem dessa maneira. </p><br><p>  Mude o exemplo para torn√°-lo seguro. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromDB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summInts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromDB = getIntFromDB() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromServer = getIntFromServer() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromServer = intFromServer { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> summ = intFromDB + intFromServer <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> summ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = summInts() { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(result) }</code> </pre> <br><p>  Este c√≥digo √© bom, √© seguro.  Usando extra√ß√£o expl√≠cita, defendemos o poss√≠vel nulo.  Mas tornou-se complicado e, entre as verifica√ß√µes seguras, j√° √© dif√≠cil discernir nossa inten√ß√£o.  Ainda precisamos da soma de dois n√∫meros, n√£o de uma verifica√ß√£o de seguran√ßa. </p><br><p>  Nesse caso, o Opcional possui um m√©todo de mapa, herdado do tipo Maybe de Haskell.  N√≥s o aplicamos e o exemplo mudar√°. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromDB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summInts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromDB = getIntFromDB() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromServer = getIntFromServer() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> intFromServer.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x + intFromDB } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = summInts() { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(result) }</code> </pre> <br><p>  Ou ainda mais compacto. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromDB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getintFromServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summInts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getintFromServer().<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span> + getIntFromDB() } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = summInts() { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(result) }</code> </pre> <br><p>  Usamos map para converter intFromServer no resultado que precisamos sem extra√ß√£o. </p><br><p>  Nos livramos da verifica√ß√£o dentro de summInts, mas a deixamos no n√≠vel superior.  Isso √© feito intencionalmente, pois no final da cadeia de computa√ß√£o devemos escolher um m√©todo para processar a falta de resultado. </p><br><p>  Ejetar </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = summInts() { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(result) }</code> </pre><br><p>  Usar valor padr√£o </p><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(result ?? <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br><p>  Ou exiba um aviso se os dados n√£o forem recebidos. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = summInts() { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(result) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">""</span></span>) }</code> </pre> <br><p>  Agora, o c√≥digo no exemplo n√£o cont√©m muito, como no primeiro exemplo, e √© seguro, como no segundo. </p><br><p>  Mas o mapa nem sempre funciona como deveria </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a: <span class="hljs-type"><span class="hljs-type">String?</span></span> = <span class="hljs-string"><span class="hljs-string">"7"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = a.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { <span class="hljs-type"><span class="hljs-type">Int</span></span>($<span class="hljs-number"><span class="hljs-number">0</span></span>) } type(of: b)<span class="hljs-comment"><span class="hljs-comment">//Optional&lt;Optional&lt;Int&gt;&gt;</span></span></code> </pre> <br><p>  Se passarmos uma fun√ß√£o para mapear, cujo resultado √© opcional, obtemos um Duplo opcional.  Mas n√£o precisamos de dupla prote√ß√£o contra nada.  Um √© o suficiente.  O m√©todo flatMap permite resolver o problema, √© um an√°logo do mapa com uma diferen√ßa, implanta os bonecos de nidifica√ß√£o. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a: <span class="hljs-type"><span class="hljs-type">String?</span></span> = <span class="hljs-string"><span class="hljs-string">"7"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = a.flatMap { <span class="hljs-type"><span class="hljs-type">Int</span></span>($<span class="hljs-number"><span class="hljs-number">0</span></span>) } type(of: b)<span class="hljs-comment"><span class="hljs-comment">//Optional&lt;Int&gt;.</span></span></code> </pre> <br><p>  Outro exemplo em que o map e flatMap n√£o √© muito conveniente de usar. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a: <span class="hljs-type"><span class="hljs-type">Int?</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b: <span class="hljs-type"><span class="hljs-type">Int?</span></span> = <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = a.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span> + b! }</code> </pre><br><p>  E se uma fun√ß√£o receber dois argumentos e ambos forem opcionais?  Obviamente, o FP tem uma solu√ß√£o - este √© um functor aplicativo e currying.  Mas essas ferramentas parecem bastante estranhas sem o uso de operadores especiais que n√£o est√£o em nosso idioma, e escrever operadores personalizados √© considerado uma m√° forma.  Portanto, consideramos uma maneira mais intuitiva: escrevemos uma fun√ß√£o especial. </p><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@discardableResult</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perform</span></span></span><span class="hljs-function">&lt;Result, U, Z&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> transform: </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(U, Z)</span></span></span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Result</span></span>, <span class="hljs-number"><span class="hljs-number">_</span></span> optional1: <span class="hljs-type"><span class="hljs-type">U?</span></span>, <span class="hljs-number"><span class="hljs-number">_</span></span> optional2: <span class="hljs-type"><span class="hljs-type">Z?</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">rethrows</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Result?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> optional1 = optional1, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> optional2 = optional2 <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> transform(optional1, optional2) }</code> </pre> <br><p>  S√£o necess√°rios dois valores opcionais como argumentos e uma fun√ß√£o com dois argumentos.  Se ambas as op√ß√µes tiverem valores, uma fun√ß√£o ser√° aplicada a elas. <br>  Agora podemos trabalhar com v√°rias op√ß√µes sem implant√°-las. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a: <span class="hljs-type"><span class="hljs-type">Int?</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b: <span class="hljs-type"><span class="hljs-type">Int?</span></span> = <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = perform(+, a, b)</code> </pre> <br><p>  A segunda m√¥nada, Result, tamb√©m possui os m√©todos map e flatMap.  Assim, voc√™ pode trabalhar exatamente da mesma maneira. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromDB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Result</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">ServerError</span></span>&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summInts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Result</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">ServerError</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromDB = getIntFromDB() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromServer = getIntFromServer() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> intFromServer.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x + intFromDB } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .success(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result) = summInts() { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(result) }</code> </pre> <br><p>  Na verdade, √© isso que une as m√¥nadas - a capacidade de trabalhar com o valor dentro do cont√™iner sem remov√™-lo.  Na minha opini√£o, isso torna o c√≥digo conciso.  Mas se voc√™ n√£o gostar, basta usar extratos expl√≠citos, isso n√£o contradiz o paradigma do FP. </p><br><h2 id="primer-sokraschaem-chislo-gryaznyh-funkciy">  Exemplo: reduzindo o n√∫mero de fun√ß√µes sujas </h2><br><p>  Infelizmente, em programas reais, estados globais e efeitos colaterais est√£o por toda parte - solicita√ß√µes de rede, fontes de dados, interfaces de usu√°rio.  E apenas fun√ß√µes puras n√£o podem ser dispensadas.  Mas isso n√£o significa que o FP seja completamente inacess√≠vel para n√≥s: podemos tentar reduzir o n√∫mero de fun√ß√µes sujas, que geralmente s√£o muitas. </p><br><p>  Vejamos um pequeno exemplo pr√≥ximo ao desenvolvimento da produ√ß√£o.  Crie uma interface do usu√°rio, especificamente um formul√°rio de inscri√ß√£o.  O formul√°rio tem algumas limita√ß√µes: </p><br><p>  1) Fa√ßa login com menos de 3 caracteres <br>  2) Senha com pelo menos 6 caracteres <br>  3) O bot√£o "Login" estar√° ativo se ambos os campos forem v√°lidos. <br>  4) A cor do quadro do campo reflete seu estado, preto - √© v√°lido, vermelho - n√£o √© v√°lido </p><br><p>  O c√≥digo que descreve essas restri√ß√µes pode ser assim: </p><br><p>  Manipulando qualquer entrada do usu√°rio </p><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">textFieldTextDidChange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1.     // 2.   guard let login = loginView.text, let password = passwordView.text else { // 3. - loginButton.isEnabled = false return } let loginIsValid = login.count &gt; constants.loginMinLenght if loginIsValid { // 4. - loginView.layer.borderColor = constants.normalColor } let passwordIsValid = password.count &gt; constants.passwordMinLenght if passwordIsValid { // 5. - passwordView.layer.borderColor = constants.normalColor } // 6. - loginButton.isEnabled = loginIsValid &amp;&amp; passwordIsValid }</span></span></code> </pre> <br><p>  Processamento de conclus√£o de login: </p><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loginDidEndEdit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color: <span class="hljs-type"><span class="hljs-type">CGColor</span></span> <span class="hljs-comment"><span class="hljs-comment">// 1.     // 2.   if let login = loginView.text, login.count &gt; 3 { color = constants.normalColor } else { color = constants.errorColor } // 3.   loginView.layer.borderColor = color }</span></span></code> </pre> <br><p>  Processamento de conclus√£o de senha: </p><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">passwordDidEndEdit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color: <span class="hljs-type"><span class="hljs-type">CGColor</span></span> <span class="hljs-comment"><span class="hljs-comment">// 1.     // 2.   if let password = passwordView.text, password.count &gt; 6 { color = constants.normalColor } else { color = constants.errorColor } // 3. - passwordView.layer.borderColor = color }</span></span></code> </pre> <br><p>  Pressionando o bot√£o Enter: </p><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loginPressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1.     // 2.   guard let login = loginView.text, let password = passwordView.text else { return } auth(login: login, password: password) { [weak self] user, error in if let user = user { /*  */ } else if error is AuthError { guard let `self` = self else { return } // 3. - self.passwordView.layer.borderColor = self.constants.errorColor // 4. - self.loginView.layer.borderColor = self.constants.errorColor } else { /*   */ } } }</span></span></code> </pre> <br><p>  Esse c√≥digo pode n√£o ser o melhor, mas no geral √© bom e funciona.  √â verdade que ele tem v√°rios problemas: </p><br><ul><li>  4 extratos expl√≠citos; </li><li>  4 depend√™ncias no estado global; </li><li>  8 efeitos colaterais; </li><li>  estados finais n√£o √≥bvios; </li><li>  fluxo n√£o linear. </li></ul><br><p>  O principal problema √© que voc√™ n√£o pode simplesmente pegar e dizer o que est√° acontecendo com nossa tela.  Olhando para um m√©todo, vemos o que ele faz com um estado global, mas n√£o sabemos quem, onde e quando toca o estado.  Como resultado, para entender o que est√° acontecendo, voc√™ precisa encontrar todos os pontos de trabalho com as visualiza√ß√µes e entender em que ordem as influ√™ncias ocorrem.  Manter tudo isso em mente √© muito dif√≠cil. </p><br><p>  Se o processo de altera√ß√£o do estado for linear, voc√™ poder√° estud√°-lo passo a passo, o que reduzir√° a carga cognitiva no programador. </p><br><p>  Vamos tentar mudar o exemplo, tornando-o mais funcional. </p><br><p>  Primeiro, definimos um modelo que descreve o estado atual da tela.  Isso permitir√° que voc√™ saiba exatamente quais informa√ß√µes s√£o necess√°rias para o trabalho. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoginOutputModel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> login: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> password: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loginIsValid: <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> login.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> &gt; <span class="hljs-number"><span class="hljs-number">3</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> passwordIsValid: <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> password.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> &gt; <span class="hljs-number"><span class="hljs-number">6</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isValid: <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> loginIsValid &amp;&amp; passwordIsValid } }</code> </pre> <br><p>  Um modelo que descreve as altera√ß√µes aplicadas √† tela.  Ela √© necess√°ria para saber exatamente o que mudaremos. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoginInputModel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> loginBorderColor: <span class="hljs-type"><span class="hljs-type">CGColor?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> passwordBorderColor: <span class="hljs-type"><span class="hljs-type">CGColor?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> loginButtonEnable: <span class="hljs-type"><span class="hljs-type">Bool?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> popupErrorMessage: <span class="hljs-type"><span class="hljs-type">String?</span></span> }</code> </pre> <br><p>  Eventos que podem levar a um novo estado de tela.  Ent√£o, saberemos exatamente quais a√ß√µes mudam a tela. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> textFieldTextDidChange <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> loginDidEndEdit <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> passwordDidEndEdit <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> loginPressed <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> authFailure(<span class="hljs-type"><span class="hljs-type">Error</span></span>) }</code> </pre> <br><p>  Agora descrevemos o principal m√©todo de mudan√ßa.  Essa fun√ß√£o pura, com base no evento de estado atual, coleta um novo estado da tela. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeInputModel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( event: Event, outputModel: LoginOutputModel?)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">LoginInputModel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> event { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .textFieldTextDidChange: <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mapValidToColor: (<span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">CGColor?</span></span> = { $<span class="hljs-number"><span class="hljs-number">0</span></span> ? normalColor : <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">LoginInputModel</span></span>( loginBorderColor: outputModel .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span>.loginIsValid } .flatMap(mapValidToColor), passwordBorderColor: outputModel .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span>.passwordIsValid } .flatMap(mapValidToColor), loginButtonEnable: outputModel?.passwordIsValid ) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .loginDidEndEdit: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">LoginInputModel</span></span>(<span class="hljs-comment"><span class="hljs-comment">/**/</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .passwordDidEndEdit: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">LoginInputModel</span></span>(<span class="hljs-comment"><span class="hljs-comment">/**/</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .loginPressed: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">LoginInputModel</span></span>(<span class="hljs-comment"><span class="hljs-comment">/**/</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .authFailure(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> error <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-type"><span class="hljs-type">AuthError</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">LoginInputModel</span></span>(<span class="hljs-comment"><span class="hljs-comment">/**/</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .authFailure: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">LoginInputModel</span></span>(<span class="hljs-comment"><span class="hljs-comment">/**/</span></span>) } }</code> </pre> <br><p>  O mais importante √© que esse m√©todo √© o √∫nico que pode se envolver na constru√ß√£o de um novo estado - e √© limpo.  Pode ser estudado passo a passo.  Veja como os eventos transformam a tela do ponto A ao ponto B. Se algo quebrar, o problema est√° exatamente aqui.  E √© f√°cil de testar. </p><br><p>  Adicione uma propriedade auxiliar para obter o estado atual, este √© o √∫nico m√©todo que depende do estado global. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> outputModel: <span class="hljs-type"><span class="hljs-type">LoginOutputModel?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> perform(<span class="hljs-type"><span class="hljs-type">LoginOutputModel</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>, loginView.text, passwordView.text) }</code> </pre> <br><p>  Adicione outro m√©todo "sujo" para criar os efeitos colaterais de alterar a tela. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> event: Event)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> inputModel = makeInputModel(event: event, outputModel: outputModel) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color = inputModel.loginBorderColor { loginView.layer.borderColor = color } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color = inputModel.passwordBorderColor { passwordView.layer.borderColor = color } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> isEnable = inputModel.loginButtonEnable { loginButton.isEnabled = isEnable } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error = inputModel.popupErrorMessage { showPopup(error) } }</code> </pre> <br><p>  Embora o m√©todo updateView n√£o seja limpo, √© o √∫nico local em que as propriedades da tela s√£o alteradas.  O primeiro e o √∫ltimo item da cadeia de c√°lculos.  E se algo der errado, √© aqui que o ponto de interrup√ß√£o estar√°. </p><br><p>  Resta apenas iniciar a convers√£o nos lugares certos. </p><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">textFieldTextDidChange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { updateView(.textFieldTextDidChange) } <span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loginDidEndEdit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { updateView(.loginDidEndEdit) } <span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">passwordDidEndEdit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { updateView(.passwordDidEndEdit) }</code> </pre> <br><p>  O m√©todo loginPressed saiu um pouco exclusivo. </p><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loginPressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { updateView(.loginPressed) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> completion: (<span class="hljs-type"><span class="hljs-type">Result</span></span>&lt;<span class="hljs-type"><span class="hljs-type">User</span></span>, <span class="hljs-type"><span class="hljs-type">Error</span></span>&gt;) -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span> = { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] result <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> result { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .success(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user): <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .failure(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error): <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>?.updateView(.authFailure(error)) } } outputModel.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { auth(login: $<span class="hljs-number"><span class="hljs-number">0</span></span>.login, password: $<span class="hljs-number"><span class="hljs-number">0</span></span>.password, completion: completion) } }</code> </pre> <br><p>  O fato √© que clicar no bot√£o "Login" inicia duas cadeias de c√°lculos, o que n√£o √© proibido. </p><br><h2 id="zaklyuchenie">  Conclus√£o </h2><br><p>  Antes de estudar FP, fiz uma forte √™nfase em paradigmas de programa√ß√£o.  Era importante para mim que o c√≥digo seguisse OOP, n√£o gostasse de fun√ß√µes est√°ticas ou objetos sem estado, n√£o escrevesse fun√ß√µes globais. </p><br><p>  Agora, parece-me que todas as coisas que considerei parte de um paradigma s√£o bastante arbitr√°rias.  O principal √© um c√≥digo limpo e compreens√≠vel.  Para atingir esse objetivo, voc√™ pode usar tudo o que √© poss√≠vel: fun√ß√µes puras, classes, m√¥nadas, heran√ßa, composi√ß√£o, infer√™ncia de tipos.  Todos se d√£o bem e melhoram o c√≥digo - basta aplic√°-los ao local. </p><br><h2 id="chto-esche-pochitat-po-teme">  O que mais para ler sobre o tema </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Defini√ß√£o de programa√ß√£o funcional da Wikipedia</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Haskell Starter Book</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Explica√ß√£o dos functores, m√¥nadas e aplicadores nos dedos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Livro de Haskell sobre pr√°ticas para o uso do Talvez (opcional)</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Livro sobre a natureza funcional do Swift</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Definindo tipos de dados alg√©bricos de um wiki</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Um artigo sobre tipos de dados alg√©bricos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Outro artigo sobre tipos de dados alg√©bricos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Relat√≥rio Yandex sobre programa√ß√£o funcional no Swift</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Implementando a Prelude Standard Library (Haskell) no Swift</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Biblioteca com ferramentas funcionais no Swift</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Outra biblioteca</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">E mais um</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt455359/">https://habr.com/ru/post/pt455359/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt455345/index.html">Cuidado M√©dico</a></li>
<li><a href="../pt455347/index.html">Interfaces funcionais ... em VBA</a></li>
<li><a href="../pt455351/index.html">VMware EMPOWER 2019 - os principais an√∫ncios e conclus√µes da confer√™ncia</a></li>
<li><a href="../pt455353/index.html">Acelera√ß√£o de hardware de redes neurais profundas: GPU, FPGA, ASIC, TPU, VPU, IPU, DPU, NPU, RPU, NNP e outras letras</a></li>
<li><a href="../pt455355/index.html">Redes de TV a cabo para os menores. Parte 8: Rede de backbone √≥ptico</a></li>
<li><a href="../pt455361/index.html">Criamos uma extens√£o do navegador que verifica os resultados do exame</a></li>
<li><a href="../pt455367/index.html">VueJs + MVC c√≥digo m√≠nimo funcionalidade m√°xima</a></li>
<li><a href="../pt455369/index.html">Certifica√ß√£o de administradores de banco de dados e muito mais no anivers√°rio do DevConfX (21 a 22 de junho em Moscou)</a></li>
<li><a href="../pt455371/index.html">Fonte de corrente est√°vel de 5 ŒºA a 20 mA</a></li>
<li><a href="../pt455373/index.html">Como ajustar a lei da Primavera para que ela se torne uma eleva√ß√£o para pequenos fornecedores? Cancele</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>