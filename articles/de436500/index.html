<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤶 🕖 🤱🏽 Wie der Rahmen von Rise of the Tomb Raider gerendert wird 🛸 🗳️ 🐐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rise of the Tomb Raider (2015) ist die Fortsetzung des hervorragenden Neustarts von Tomb Raider (2013). Persönlich finde ich beide Teile interessant, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie der Rahmen von Rise of the Tomb Raider gerendert wird</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436500/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/1k/5p/s6/1k5ps6qnv2soku_ymxsemz7wnxa.gif"></div><br>  Rise of the Tomb Raider (2015) ist die Fortsetzung des hervorragenden Neustarts von Tomb Raider (2013).  Persönlich finde ich beide Teile interessant, weil sie sich von der stagnierenden Originalserie entfernt und die Geschichte von Lara erneut erzählt haben.  In diesem Spiel steht wie im Prequel die Handlung im Mittelpunkt und bietet faszinierende Mechaniken für Handwerk, Jagd und Klettern / Forschung. <br><br>  Tomb Raider verwendete die von Crystal Dynamics entwickelte Crystal Engine, die auch in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Deus Ex: Human Revolution verwendet wurde</a> .  Die Fortsetzung verwendete eine neue Engine namens Foundation, die zuvor für Lara Croft und den Temple of Osiris (2014) entwickelt wurde.  Sein Rendering kann allgemein als Fliesenmotor mit vorläufigem Beleuchtungsdurchlauf beschrieben werden, und später werden wir herausfinden, was dies bedeutet.  Mit der Engine können Sie zwischen den Renderern DX11 und DX12 wählen.  Ich habe mich aus den unten diskutierten Gründen für Letzteres entschieden.  Um den Rahmen zu erfassen, wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Renderdoc</a> 1.2 auf dem Geforce 980 Ti verwendet. Das Spiel enthält alle Funktionen und Dekorationen. <br><br><h2>  Analysierter Rahmen </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/254/df9/0bb/254df90bbbfd5498710f37624e12d1f4.jpg"></div><br>  Um Spoiler zu vermeiden, werde ich sagen, dass die Bösen in diesem Rahmen Lara jagen, weil sie nach einem Artefakt sucht, nach dem sie suchen.  Dieser Interessenkonflikt kann nicht ohne Waffen gelöst werden.  Lara schlich sich nachts in die feindliche Basis.  Ich habe einen Rahmen mit atmosphärischer und kontrastreicher Beleuchtung gewählt, in dem sich der Motor zeigen kann. <a name="habracut"></a><br><br><h4>  Tiefenvorschuss </h4><br>  Hier wird die für viele Spiele übliche Optimierung durchgeführt - ein kleiner vorläufiger Durchgang der Tiefe (ca. 100 Draw Calls).  Das Spiel rendert die größten Objekte (und nicht diejenigen, die mehr Platz auf dem Bildschirm beanspruchen), um die Funktionen des Early-Z-Videoprozessors zu nutzen.  Lesen Sie mehr darüber in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem Intel-Artikel</a> .  Kurz gesagt, GPUs können die Ausführung eines Pixel-Shaders vermeiden, wenn sie feststellen können, dass er vom vorherigen Pixel überlappt wird.  Dies ist eine relativ kostengünstige Passage, bei der der Z-Puffer mit Tiefenwerten vorgefüllt wird. <br><br>  Zu diesem Zeitpunkt entdeckte ich eine interessante Detailgenauigkeitstechnik (LOD) namens „Fizzle“ oder „Checkerboard“.  Dies ist eine übliche Methode, um Objekte in einiger Entfernung schrittweise anzuzeigen oder auszublenden, damit sie später entweder durch ein Netz mit geringerer Qualität ersetzt oder vollständig ausgeblendet werden können.  Schau dir diesen Truck an.  Es scheint, als würde es zweimal gerendert, aber tatsächlich wird es mit einer hohen LOD und einer niedrigen LOD an derselben Position gerendert.  Jede der Ebenen rendert die Pixel, die die andere nicht gerendert hat.  Die erste LOD hat 182.226 Eckpunkte und die zweite LOD hat 47.250. In großer Entfernung sind sie nicht zu unterscheiden, aber eine davon ist dreimal billiger.  In diesem Frame verschwindet LOD 0 fast vollständig und LOD 1 wird fast vollständig gerendert.  Nach dem vollständigen Verschwinden von LOD 0 wird nur LOD 1 gerendert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c31/d8d/24e/c31d8d24e58229c27fb4edf6f635974d.png"></div><br>  <i>LOD 0</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bf/3b4/5bb/7bf3b45bbe13521b4bae010f72a702a7.png"></div><br>  <i>LOD 1</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jy/7r/it/jy7rit_bwqm4n0lwpzzlydyx5rs.gif"></div><br>  Die pseudozufällige Textur und der Wahrscheinlichkeitskoeffizient ermöglichen es uns, Pixel zu verwerfen, die den Schwellenwert nicht überschritten haben.  Diese Textur wird in ROTR verwendet.  Man könnte sich fragen, warum Alpha-Blending nicht verwendet wird.  Alpha-Blending hat viele Nachteile im Vergleich zum Fizzle-Fading. <br><br><ol><li>  <strong>Bequemlichkeit für den vorläufigen Durchgang der Tiefen:</strong> Dank der Darstellung eines undurchsichtigen Objekts mit darin eingebrachten Löchern können wir den vorläufigen Durchgang rendern und Early-Z verwenden.  Objekte mit Alpha-Überblendung in einem so frühen Stadium werden aufgrund von Sortierproblemen nicht in den Tiefenpuffer gerendert. </li><li>  <strong>Zusätzliche Shader erforderlich</strong> : Wenn ein verzögerter Renderer verwendet wird, enthält der Shader von undurchsichtigen Objekten keine Beleuchtung.  Wenn Sie ein undurchsichtiges Objekt durch ein transparentes ersetzen müssen, benötigen Sie eine separate Option für die Beleuchtung.  Zusätzlich zur Erhöhung des Speicherbedarfs und der Komplexität aufgrund mindestens eines zusätzlichen Shaders für alle undurchsichtigen Objekte müssen diese genau sein, um zu vermeiden, dass sich Objekte vorwärts bewegen.  Dies ist aus vielen Gründen kompliziert, aber alles hängt davon ab, dass das Rendern jetzt in einem anderen Codepfad erfolgt. </li><li>  <strong>Größere Neuzeichnungen</strong> : Durch Alpha-Blending können große Neuzeichnungen erstellt werden. Bei einer bestimmten Komplexität von Objekten kann ein großer Teil der Bandbreite erforderlich sein, um die LOD zu schattieren. </li><li>  <strong>Z-Konflikte</strong> : Z-Konflikte sind ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Flickereffekt,</a> wenn zwei Polygone in sehr geringer Tiefe zueinander gerendert werden.  In diesem Fall werden sie aufgrund der Ungenauigkeit der Gleitkommaberechnungen nacheinander gerendert.  Wenn wir zwei aufeinanderfolgende LODs rendern, eine nach und nach ausblenden und die zweite anzeigen, können sie einen Z-Konflikt verursachen, da sie sehr nahe beieinander liegen.  Es gibt immer Möglichkeiten, dies zu umgehen, beispielsweise ein Polygon einem anderen vorzuziehen, aber ein solches System ist komplex. </li><li>  <strong>Z-Buffer-Effekte</strong> : Viele Effekte wie SSAO verwenden nur den Tiefenpuffer.  Wenn wir transparente Objekte am Ende der Pipeline gerendert haben, als die Umgebungsokklusion bereits abgeschlossen war, konnten wir dies nicht berücksichtigen. </li></ol><br>  Der Nachteil dieser Technik ist, dass sie schlechter aussieht als Alpha-Blending, aber ein gutes Rauschmuster, Unschärfe nach Sprudeln oder vorübergehendes Anti-Aliasing kann sie fast vollständig verbergen.  In dieser Hinsicht macht ROTR nichts besonders Ungewöhnliches. <br><br><h4>  Normaler Pass </h4><br>  Crystal Dynamics verwendet in seinen Spielen ein eher ungewöhnliches Beleuchtungsmuster, das wir im Beleuchtungsgang behandeln werden.  Im Moment genügt es zu sagen, dass die Engine keinen G-Puffer-Durchgang hat.  Zumindest in dem Maße, wie es in anderen Spielen bekannt ist.  In dieser Passage übertragen die Objekte nur Informationen über die Tiefe und Normalen an die Ausgabe.  Normalen werden im Renderziel des Formats RGBA16_SNORM im Weltraum aufgezeichnet.  Es ist merkwürdig, dass diese Engine das Z-up-Schema verwendet, nicht das Y-up (die Z-Achse ist nach oben gerichtet, nicht die Y-Achse), das in anderen Modellierungs-Engines / -Paketen häufiger verwendet wird.  Der Alpha-Kanal enthält Glanz, der dann als <code>exp2(glossiness * 12 + 1.0)</code> entpackt <code>exp2(glossiness * 12 + 1.0)</code> .  Der Glanzwert kann auch negativ sein, da das Vorzeichen als Flag verwendet wird, das angibt, ob die Oberfläche metallisch ist.  Dies kann von selbst bemerkt werden, da alle dunklen Farben im Alphakanal mit Metallobjekten zusammenhängen. <br><br><table><tbody><tr><td>  <strong><font color="#ff0000">R.</font></strong> </td><td>  <strong><font color="#00ff00">G.</font></strong> </td><td>  <strong><font color="0000ff">B.</font></strong> </td><td></td></tr><tr><td>  <strong>Normal.x</strong> </td><td>  <strong>Normal.y</strong> </td><td>  <strong>Normal.z</strong> </td><td>  <b>Glanz + Metallizität</b> </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e8/209/484/1e8209484fe730d178c4afffef4c8f93.jpg"></div><br>  <i>Normal</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fb/dd3/b2d/8fbdd3b2d2ddbce3111a4c017e7daef3.jpg"></div><br>  <i>Glanz / Metallizität</i> <br><br>  <strong>Vorteile der Abreise</strong> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa1/b15/52b/aa1b1552b0f81c2122d094441e531f3f.jpg"></div><br>  Denken Sie daran, dass wir im Abschnitt „Tiefenvorbereitung“ über das Einsparen von Pixelkosten gesprochen haben.  Ich werde ein wenig zurückgehen, um es zu veranschaulichen.  Nehmen Sie das folgende Bild auf.  Dadurch wird der detaillierte Teil des Berges zum normalen Puffer.  Renderdoc hat freundlicherweise die Pixel, die den Tiefentest bestanden haben, mit Grün und diejenigen, die ihn nicht bestanden haben, mit Rot hervorgehoben (sie werden nicht gerendert).  Die Gesamtzahl der Pixel, die ohne diesen vorläufigen Durchgang gerendert würden, entspricht ungefähr 104518 (berechnet in Photoshop).  Die Gesamtzahl der tatsächlich gerenderten Pixel beträgt 23858 (berechnet von Renderdoc).  Sparen Sie ca. 77%!  Wie wir sehen, kann dieser vorläufige Durchgang bei intelligenter Verwendung einen großen Gewinn bringen und erfordert nur etwa hundert Draw Calls. <br><br>  <strong>Aufzeichnen von Multithread-Befehlen</strong> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/919/5d0/623/9195d06236fd6247cea6e6065f05e9e8.png"></div><br>  Es ist erwähnenswert, dass ich mich für den DX12-Renderer entschieden habe - das Aufzeichnen von Multithread-Befehlen.  In früheren APIs wie DX11 wird das Rendern normalerweise in einem einzelnen Thread ausgeführt.  Der Grafiktreiber erhielt Rendering-Befehle vom Spiel und übertrug ständig GPU-Anfragen, aber das Spiel wusste nicht, wann dies passieren würde.  Dies führt zu Ineffizienz, da der Treiber irgendwie erraten muss, was die Anwendung versucht, und nicht auf mehrere Threads skaliert.  Neuere APIs wie DX12 übergeben die Kontrolle an einen Entwickler, der entscheiden kann, wie und wann Befehle geschrieben werden sollen.  Obwohl Renderdoc nicht zeigen kann, wie die Aufnahme durchgeführt wird, werden Sie feststellen, dass sieben Farbdurchgänge als Farbdurchlauf N gekennzeichnet sind und jeder von ihnen in ein Paar ExecuteCommandList: Reset / Close eingeschlossen ist.  Es markiert den Anfang und das Ende der Befehlsliste.  Die Liste umfasst ungefähr 100-200 Draw Calls.  Dies bedeutet nicht, dass sie mit mehreren Streams aufgezeichnet wurden, sondern weist darauf hin. <br><br>  <strong>Fußspuren im Schnee</strong> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca6/d21/2e8/ca6d212e89b61f52738dfbd01363e366.jpg"></div><br>  Wenn Sie sich Lara ansehen, können Sie sehen, dass sie beim Bewegen vor dem Screenshot Spuren im Schnee hinterlassen hat.  In jedem Frame wird ein Compute-Shader ausgeführt, der Verformungen in bestimmten Bereichen aufzeichnet und diese basierend auf Art und Höhe der Oberfläche anwendet.  Hier wird nur die normale Karte auf den Schnee angewendet (d. H. Die Geometrie ändert sich nicht), aber in einigen Bereichen, in denen der Schnee dicker ist, wird die Verformung tatsächlich durchgeführt!  Sie können auch sehen, wie der Schnee an seinen Platz "fällt" und die von Lara hinterlassenen Spuren füllt.  Diese Technik wird in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GPU Pro 7</a> ausführlicher beschrieben.  Die Schneekettetextur ist eine Art Höhenkarte, die Laras Bewegungen verfolgt und an den Rändern festgeklebt wird, damit der Sampling-Shader diese Faltung nutzen kann. <br><br><h4>  Atlas der Schatten </h4><br>  Beim Erstellen der Schattenzuordnung wird ein ziemlich gängiger Ansatz verwendet: Packen Sie so viele Schattenkarten wie möglich in eine gemeinsame Schattenstruktur.  Ein solcher Schattenatlas ist eigentlich eine riesige 16-Bit-Textur mit einer Größe von 16384 × 8196.  Auf diese Weise können Sie die Schattenkarten im Atlas sehr flexibel wiederverwenden und skalieren.  In dem Rahmen, den wir analysieren, werden 8 Schattenkarten im Atlas aufgezeichnet.  Vier von ihnen beziehen sich auf die Hauptquelle der gerichteten Beleuchtung (der Mond, weil es nachts passiert), weil sie kaskadierende Schattenkarten verwenden - eine ziemlich Standardtechnik von Fernschatten für die gerichtete Beleuchtung, die ich bereits etwas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">früher erklärt habe</a> .  Interessanterweise sind bei der Erfassung dieses Rahmens auch mehrere Projektions- und Scheinwerferquellen enthalten.  Die Tatsache, dass 8 Schattenkarten in diesem Rahmen aufgezeichnet werden, bedeutet nicht, dass nur 8 Quellen für das Werfen von Schattenlicht darin enthalten sind.  Das Spiel kann Schattenberechnungen zwischenspeichern, dh Beleuchtung, die weder die Position der Quelle noch die Geometrie im Bereich geändert hat, sollte ihre Schattenkarte nicht aktualisieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f00/8d9/169/f008d9169bd3490c26f923bcc4ea8e85.jpg"></div><br>  Es scheint, dass das Rendern von Schattenkarten auch vom Schreiben von Multithread-Befehlen in die Liste profitiert. In diesem Fall wurden bis zu 19 Befehlslisten zum Rendern von Schattenkarten geschrieben. <br><br>  <strong>Schatten von gerichteter Beleuchtung</strong> <br><br>  Schatten von gerichteter Beleuchtung werden vor dem Durchgang der Beleuchtung berechnet und später abgetastet.  Ich weiß nicht, was passieren würde, wenn die Szene mehrere gerichtete Lichtquellen hätte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cef/209/845/cef209845628db5e68588f07880542eb.jpg"></div><br><h4>  Umgebungsokklusion </h4><br>  Für Umgebungsokklusion können Sie mit ROTR entweder HBAO oder eine Variante von HBAO + verwenden (diese Technik wurde ursprünglich von NVIDIA veröffentlicht).  Es gibt verschiedene Variationen dieses Algorithmus, daher werde ich die in ROTR gefundene betrachten.  Zunächst wird der Tiefenpuffer in 16 Texturen unterteilt, von denen jede 1/16 aller Tiefenwerte enthält.  Die Trennung wird so durchgeführt, dass jede Textur einen Wert aus einem 4 × 4-Block der in der folgenden Abbildung gezeigten ursprünglichen Textur enthält.  Die erste Textur enthält alle rot markierten Werte (1), die zweite enthält die blau markierten Werte (2) usw.  Wenn Sie mehr über diese Technik erfahren möchten, finden Sie hier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Artikel von</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Louis Bavoil</a> , der auch einer der Autoren des Artikels über HBAO war. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c9/2dc/60f/1c92dc60fe369caed766efe18dd2739d.png"></div><br>  Der nächste Schritt berechnet die Umgebungsokklusion für jede Textur, wodurch wir 16 AO-Texturen erhalten.  Eine Umgebungsokklusion wird wie folgt erzeugt: Der Tiefenpuffer wird mehrmals abgetastet, wobei die Position neu erstellt und das Berechnungsergebnis für jede der Proben akkumuliert wird.  Jede Umgebungsokklusionstextur wird unter Verwendung unterschiedlicher Abtastkoordinaten berechnet, dh in einem 4 × 4-Pixelblock erzählt jedes Pixel seinen eigenen Teil der Geschichte.  Dies erfolgt aus Leistungsgründen.  Jedes Pixel tastet den Tiefenpuffer bereits 32 Mal ab, und für den vollen Effekt sind 16 × 32 = 512 Abtastwerte erforderlich, was selbst für die leistungsstärksten GPUs eine Pleite ist.  Dann rekombinieren sie zu einer Vollbild-Textur, die sich als ziemlich verrauscht herausstellt. Um die Ergebnisse unmittelbar danach zu glätten, wird ein Vollbild-Unschärfe-Durchgang durchgeführt.  Wir haben in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shadow of Mordor</a> eine sehr ähnliche Lösung gesehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/25f/e57/dd8/25fe57dd8001f561e9a971b36b57085e.png" alt="Bild"></div><br>  <i>HBAO Teile</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/113/e1b/7d0/113e1b7d065a25b8f4dfb8dce29c808c.png" alt="Bild"></div><br>  <i>Voller HBAO mit Lärm</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/063/bfe/cd1/063bfecd15cdf8d62a0b6221fddfe4ee.png" alt="Bild"></div><br>  <i>Volle horizontale HBAO-Unschärfe</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51d/af9/8e2/51daf98e295b549a57089b4d17df1975.png" alt="Bild"></div><br>  <i>Bereit HBAO</i> <br><br><h4>  Pre-Pass für gekachelte Beleuchtung </h4><br>  Light Prepass ist eine eher ungewöhnliche Technik.  Die meisten Entwicklungsteams verwenden eine Kombination aus verzögerter + direkter Beleuchtungsberechnung (mit Variationen, z. B. mit Kachel, Cluster) oder vollständig direkt für einige Effekte des Bildschirmbereichs.  Die Vorbeleuchtungstechnik ist so ungewöhnlich, dass sie eine Erklärung verdient.  Wenn das Konzept der traditionellen verzögerten Beleuchtung darin besteht, die Eigenschaften von Materialien von der Beleuchtung zu trennen, ist die Idee, die Beleuchtung von den Eigenschaften der Materialien zu trennen, der Eckpfeiler des vorläufigen Durchgangs der Beleuchtung.  Obwohl diese Formulierung etwas albern aussieht, besteht der Unterschied zur herkömmlichen verzögerten Beleuchtung darin, dass wir alle Materialeigenschaften (wie Albedo, Spiegelfarbe, Rauheit, Metallizität, Mikrookklusion, Emissionsgrad) in einem riesigen G-Puffer speichern und später als verwenden Eingabedaten für nachfolgende Beleuchtungsdurchläufe.  Herkömmliche verzögerte Beleuchtung kann den Durchsatz stark belasten.  Je komplexer die Materialien sind, desto mehr Informationen und Operationen werden im G-Puffer benötigt.  Im vorläufigen Beleuchtungsdurchlauf akkumulieren wir jedoch zunächst die gesamte Beleuchtung separat unter Verwendung der Mindestdatenmenge und wenden sie dann in nachfolgenden Durchgängen auf die Materialien an.  In diesem Fall reicht die Beleuchtung nur für Normalen, Rauheit und Metallität aus.  Shader (hier werden zwei Durchgänge verwendet) geben Daten in drei RGBA16F-Renderzielformaten aus.  Eine enthält diffuse Beleuchtung, die zweite enthält spiegelnde Beleuchtung und die dritte enthält Umgebungsbeleuchtung.  Zu diesem Zeitpunkt werden alle Schattendaten berücksichtigt.  Es ist merkwürdig, dass im ersten Durchgang (diffuse + Spiegelbeleuchtung) für einen Vollbilddurchgang ein Viereck aus zwei Dreiecken verwendet wird und in anderen Effekten ein Vollbilddreieck verwendet wird (warum dies wichtig ist, erfahren Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ).  Unter diesem Gesichtspunkt ist der gesamte Rahmen nicht ganzheitlich. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41d/6ba/a3b/41d6baa3b45cc3e0df1423eaf015d416.jpg" alt="Bild"></div><br>  <i>Diffuse Beleuchtung</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9cd/0c5/137/9cd0c513782787daa220b7627b11b28e.jpg" alt="Bild"></div><br>  <i>Spiegelbeleuchtung</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33d/ed9/cbc/33ded9cbc62470319b7729b542b7e830.jpg" alt="Bild"></div><br>  <i>Umgebungsbeleuchtung</i> <br><br>  <strong>Fliesenoptimierung</strong> <br><br>  Fliesenbeleuchtung ist eine Optimierungstechnik, mit der eine große Anzahl von Lichtquellen gerendert werden kann.  ROTR teilt den Bildschirm in 16 × 16 Kacheln auf und speichert dann Informationen darüber, welche Quellen jede Kachel schneiden. Das heißt, Beleuchtungsberechnungen werden nur für die Quellen durchgeführt, die sich auf die Kacheln beziehen.  Zu Beginn des Frames wird eine Folge von Computer-Shadern gestartet, die bestimmen, welche Quellen sich auf die Kacheln beziehen.  In der Beleuchtungsphase bestimmt jedes Pixel, in welcher Kachel es sich befindet, und durchläuft jede Lichtquelle in der Kachel, wobei alle Beleuchtungsberechnungen durchgeführt werden.  Wenn die Quellen effizient mit Kacheln verknüpft sind, können Sie viel Rechenaufwand und den größten Teil der Bandbreite einsparen und die Produktivität steigern. <br><br>  <strong>Tiefenzoom</strong> <br><br>  Tiefenbasiertes Upsampling ist eine interessante Technik, die in diesem und den folgenden Durchgängen nützlich ist.  Manchmal können rechenintensive Algorithmen nicht mit voller Auflösung gerendert werden, daher werden sie mit einer niedrigeren Auflösung gerendert und dann vergrößert.  In unserem Fall wird die Umgebungsbeleuchtung in halber Auflösung berechnet, dh nach den Berechnungen muss die Beleuchtung korrekt neu erstellt werden.  In der einfachsten Form werden 4 Pixel mit niedriger Auflösung aufgenommen und interpoliert, um etwas zu erhalten, das dem Originalbild ähnelt.  Dies funktioniert für reibungslose Übergänge, sieht aber bei Diskontinuitäten nicht gut aus, da wir dort nicht verwandte Werte mischen, die im Bildschirmbereich benachbart sein können, im Weltraum jedoch voneinander entfernt sind.  Bei Lösungen für dieses Problem werden normalerweise mehrere Tiefenpufferproben genommen und mit der Tiefenprobe verglichen, die wir neu erstellen möchten.  Wenn die Probe zu weit entfernt ist, berücksichtigen wir sie bei der Rekonstruktion nicht.  Ein solches Schema funktioniert gut, bedeutet jedoch, dass der Erholungs-Shader sehr bandbreitenintensiv ist. <br><br>  ROTR macht einen schwierigen Schritt mit dem frühen Verwerfen von Schablonen.  Nach dem Übergeben der Normalen ist der Tiefenpuffer vollständig gefüllt, sodass die Engine einen Vollbilddurchlauf durchführt und alle unterbrochenen Pixel im Schablonenpuffer markiert.  Wenn es an der Zeit ist, den Umgebungslichtpuffer neu zu erstellen, verwendet die Engine zwei Shader: Einer ist sehr einfach für Bereiche ohne Tiefenlücken, der andere ist komplexer für Pixel mit Lücken.  Frühe Schablonen verwerfen Pixel, wenn sie nicht zu der entsprechenden Region gehören, d. H. Es gibt Kosten nur in den erforderlichen Regionen.  Die folgenden Bilder sind viel klarer: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/747/912/729/747912729abfecffd281c72e8ca4e258.jpg" alt="Bild"></div><br>  <i>Umgebungsbeleuchtung mit halber Auflösung</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0d/e46/b7e/f0de46b7e19ace552377d1a39d86ed22.png" alt="Bild"></div><br>  <i>Skalierung der Tiefen des Innenraums</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d64/354/63b/d6435463b209e7361831b279abcf1ae1.jpg" alt="Bild"></div><br>  <i>Umgebungsbeleuchtung in voller Auflösung, keine Rippen</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db5/e12/702/db5e1270220121c5ca9c2a9277d519ed.png" alt="Bild"></div><br>  <i>Skalieren der Rippentiefen</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ea/971/5cf/3ea9715cf0c57785d926b0711808b256.jpg" alt="Bild"></div><br>  <i>Bereit Umgebungsbeleuchtung</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a5/5d2/128/4a55d2128ab191fb120ca3c1c4310c95.jpg" alt="Bild"></div><br>  <i>Ansicht mit halber Auflösung</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd4/eaa/a07/cd4eaaa0719a527bcdd1add09f00597b.jpg" alt="Bild"></div><br>  <i>Eine Nahaufnahme des neu erstellten Bildes</i> <br><br>  Nach dem vorläufigen Durchgang der Beleuchtung wird die Geometrie auf das Förderband übertragen. Nur dieses Mal tastet jedes Objekt Beleuchtungstexturen, Umgebungsokklusionstexturen und andere Eigenschaften von Materialien ab, die wir nicht von Anfang an in den G-Puffer geschrieben haben.  Dies ist gut, da die Bandbreite hier erheblich gespart wird, da Sie nicht eine Reihe von Texturen lesen müssen, um sie in einen großen G-Puffer zu schreiben, und sie dann erneut lesen / dekodieren müssen.  Der offensichtliche Nachteil dieses Ansatzes besteht darin, dass die gesamte Geometrie erneut übertragen werden muss und die Textur des vorläufigen Durchgangs der Beleuchtung an sich eine große Belastung für den Durchsatz darstellt.  Ich habe mich gefragt, warum ich nicht ein helleres Format verwenden soll, zum Beispiel R11G11B10F, um vorläufige Passbeleuchtungstexturen zu verwenden, aber der Alphakanal enthält zusätzliche Informationen, sodass dies unmöglich wäre.  Wie dem auch sei, dies ist eine interessante technische Lösung.  Zu diesem Zeitpunkt ist die gesamte undurchsichtige Geometrie bereits gerendert und beleuchtet.  Beachten Sie, dass es lichtemittierende Objekte wie den Himmel und den Laptop-Bildschirm enthält. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2eb/3cb/0a3/2eb3cb0a3f58c521079fc2bbd1b3fd67.jpg"></div><br><h4>  Reflexionen </h4><br>  Diese Szene ist kein gutes Beispiel für die Demonstration von Reflexionen, deshalb habe ich eine andere gewählt.  Der Reflection Shader ist eine ziemlich komplizierte Kombination von Zyklen, die auf zwei Teile reduziert werden kann: einer tastet kubische Karten ab und der andere führt SSR (Screen Space Reflection - Berechnung von Reflexionen im Screen Space) durch;  All dies erfolgt in einem Durchgang und wird am Ende unter Berücksichtigung des Koeffizienten gemischt, der bestimmt, ob die SSR Reflexion erfasst (wahrscheinlich ist der Koeffizient nicht binär, sondern ein Wert im Intervall [0, 1]).  SSR funktioniert bei vielen Spielen auf übliche Weise - es zeichnet wiederholt den Tiefenpuffer nach und versucht, den besten Schnittpunkt zwischen dem von der schattierten Oberfläche reflektierten Strahl und einer anderen Oberfläche irgendwo auf dem Bildschirm zu finden.  SSR arbeitet mit der Mip-Kette der zuvor reduzierten Skala des aktuellen HDR-Puffers und nicht mit dem gesamten Puffer. <br><br>  Es gibt auch Korrekturfaktoren wie die Helligkeit der Reflexion sowie die eigentümliche Fresnel-Textur, die vor dieser Passage basierend auf den Normalen und der Rauheit berechnet wurde.  Ich bin mir nicht ganz sicher, aber nach dem Studium des Assembler-Codes scheint es mir, dass ROTR SSR nur für glatte Oberflächen berechnen kann.  Der Motor hat nach der SSR-Phase keine Unschärfekette, die in anderen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Motoren</a> vorhanden ist, und es gibt nicht einmal eine Möglichkeit, den Tiefenpuffer mithilfe von Strahlen zu verfolgen, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">je nach Rauheit variieren</a> .  Im Allgemeinen erhalten rauere Oberflächen Reflexionen von kubischen Karten oder überhaupt nicht.  Wenn SSR funktioniert, ist seine Qualität jedoch sehr hoch und stabil, unter Berücksichtigung der Tatsache, dass es sich im Laufe der Zeit nicht ansammelt und keine räumliche Unschärfe für SSR durchgeführt wird.  Alpha-Daten unterstützen auch SSR (in einigen Tempeln können Sie sehr schöne Reflexionen im Wasser sehen) und dies ist eine gute Ergänzung, die Sie nicht oft sehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5af/b6f/093/5afb6f0937fe9b172b8e38d3f0459b9b.jpg" alt="Bild"></div><br>  <i>Reflexionen zu</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecc/66d/c6c/ecc66dc6ca98108593b9a5ec4695dc63.jpg" alt="Bild"></div><br>  <i>Reflexionspuffer</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ec9/6ff/e57/ec96ffe5730e775b678a47ae23906b73.jpg" alt="Bild"></div><br>  <i>Reflexionen nach</i> <br><br><h4>  Beleuchteter Nebel </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/578/565/d2a/578565d2af38eac19d8aff86b82cf710.jpg"></div><br>  In unserer Szene ist Nebel schlecht dargestellt, weil er den Hintergrund verdunkelt und daher von Partikeln erzeugt wird, so dass wir das Beispiel wieder mit Reflexionen verwenden.  Der Nebel ist relativ einfach, aber sehr effektiv.  Es gibt zwei Modi: global, die allgemeine Farbe des Nebels und die Farbe der nach innen gerichteten Streuung, die aus der kubischen Karte erhalten wird.  Vielleicht wurde die kubische Karte wieder aus den kubischen Reflexionskarten entnommen oder neu erstellt.  In beiden Modi wird die Verdünnung des Nebels aus der globalen Verdünnungstextur entnommen, in der die Verdünnungskurven für verschiedene Effekte gepackt sind.  In einem solchen Schema ist es bemerkenswert, dass es einen sehr kostengünstigen beleuchteten Nebel ergibt, d.h.  Streuung nach innen gerichteter Veränderungen im Raum, wodurch die Illusion entsteht, dass Nebel mit entferntem Licht in Wechselwirkung tritt.  Dieser Ansatz kann auch für die nach innen gerichtete atmosphärische Streuung in der Nähe des Himmels verwendet werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e33/e0e/c3a/e33e0ec3aee95a3cd5a669b332946083.jpg" alt="Bild"></div><br>  <i>Nebel zu</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/acb/5ed/c78/acb5edc78ab74eb97b9350c1e7aba261.jpg" alt="Bild"></div><br>  <i>Nebel danach</i> <br><br><h4>  Volumenbeleuchtung </h4><br>  In den frühen Phasen des Rahmens werden mehrere Vorgänge ausgeführt, um die volumetrische Beleuchtung vorzubereiten.  Zwei Puffer werden von der CPU auf die GPU kopiert: Lichtquellenindizes und Lichtquellendaten.  Beide werden von einem Computer-Shader gelesen, der eine 40 x 23 x 16 3D-Textur der Kameraansicht ausgibt, die die Anzahl der Lichtquellen enthält, die diesen Bereich durchqueren.  Die Textur ist 40 × 23, da jede Kachel 32 × 32 Pixel (1280/32 = 40, 720/32 = 22,5) einnimmt und 16 die Anzahl der Pixel in der Tiefe ist.  Die Textur enthält nicht alle Lichtquellen, sondern nur diejenigen, die als voluminös markiert sind (es gibt drei in unserer Szene).  Wie wir weiter unten sehen werden, gibt es andere gefälschte volumetrische Effekte, die durch flache Texturen erzeugt werden.  Die angezeigte Textur hat eine höhere Auflösung - 160x90x64.  Nach dem Bestimmen der Anzahl der Lichtquellen pro Kachel und ihres Index werden drei Rechen-Shader nacheinander ausgeführt, wobei die folgenden Operationen ausgeführt werden: <br><br><ol><li>  Der erste Durchgang bestimmt die Lichtmenge, die in Form einer Pyramide der Sichtbarkeit in die Zelle innerhalb des Volumens eintritt.  Jede Zelle sammelt den Einfluss aller Lichtquellen, als hätten sie Schwebeteilchen, die auf Licht reagieren und einen Teil davon an die Kamera zurückgeben. </li><li>  Der zweite Durchgang verwischt die Beleuchtung mit einem kleinen Radius.  Dies ist wahrscheinlich erforderlich, um ein Flackern beim Bewegen der Kamera zu vermeiden, da die Auflösung sehr niedrig ist. </li><li>  Der dritte Durchgang umgeht die Volumentextur von vorne nach hinten, fügt schrittweise den Einfluss jeder Quelle hinzu und gibt die fertige Textur.  Tatsächlich simuliert es die Gesamtmenge der einfallenden Beleuchtung entlang des Strahls bis zu einer bestimmten Entfernung.       ,     ,              .     . </li></ol><br>    ,    3D-, ,       . ,      —   ,         HDR-.          16 . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b58/939/e8a/b58939e8ae5abf2320c519abc51f6e8a.jpg" alt="Bild"></div><br> <i>  </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ab/006/e9d/1ab006e9d0b62e0ea0470751185ffe41.jpg" alt="Bild"></div><br> <i>  </i> <br><br><h4>   </h4><br>   PureHair  ,        .   -  ,         .   ,          .   Tomb Raider     TressFX,    Crystal Dynamics   .      7 .       .    : <br><br><ol><li>              ( motion blur) </li><li>          1×1        () </li><li>   122       (Triangle Strip) (   —  ).     ,         .    7 ,      .     ,      ,  .      « ». </li><li>  /   quad    ,     ,     .  ,          ,    . </li><li>       4,      (    « ») </li></ol><br>       ,   AMD   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a> .        1,       ,     3,   ,       ,       ,   ; , Renderdoc  - .  ,  , ,     ,       . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21f/127/76f/21f12776f41f0893c37a677deca12529.jpg" alt="Bild"></div><br> <i> </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/832/f49/ecd/832f49ecd96406db87ee99f3b1089de0.jpg" alt="Bild"></div><br> <i>  </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/289/33e/030/28933e0309107cfcb3120564d55fd412.jpg" alt="Bild"></div><br> <i>  </i> <br><br><h4>   -   </h4><br>        ,      .         ,          (         ).         ,   !           HDR-,    , ,     .. -    ,     -  (,        ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/445/4a8/311/4454a83115f4118ab092fc1ff3bcaaf1.jpg"></div><br>       ,       ,   ,    ,       , ,   ..  HDR-          ,     .     ,     40 .    ,     .       ,         ,      (   ,       ,   ).  ,       -,   ,   ..  ,       , , .   ,    «»  ,    .   ,       .  ,        . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e78/0f1/c77/e780f1c77d8c9031e10b1ddc6faf6b20.jpg" alt="Bild"></div><br> <i>  </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1db/409/09c/1db40909cea712bec3b9f1d4eab109d7.jpg" alt="Bild"></div><br> <i> -</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c1/8f2/80a/2c18f280ab65f272470ff711def4b89e.jpg" alt="Bild"></div><br> <i>   1</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/098/e29/66c/098e2966cf5d8bdc62a7d76bfdc2344e.jpg" alt="Bild"></div><br> <i>   2</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0b/c73/f5a/e0bc73f5ab35af88840eebe45f175074.jpg" alt="Bild"></div><br> <i>   3</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eb0/6ef/e9e/eb06efe9eb6fe1db3e749e6b1a6c1c9c.jpg" alt="Bild"><br> <i>   </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56e/263/ba6/56e263ba63ae60ee5af108c172711410.jpg" alt="Bild"></div><br> <i>  </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e8f/564/288/e8f564288ae2310272be7ac9899409d9.jpg" alt="Bild"></div><br> <i> -</i> <br><br><h4>     </h4><br> ROTR        .     ,      -,    .     ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> .   (luminance)  ROTR            ,      .      64×64,      (20, 12, 1)  256       .        (  ): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; ++i) { uint2 iCoord = CalculateCoord(threadID, i, j); <span class="hljs-comment"><span class="hljs-comment">// Obtain coordinate float3 hdrValue = Load(hdrTexture, iCoord.xyz); // Read HDR float maxHDRValue = max3(hdrValue); // Find max component float minHDRValue = min3(hdrValue); // Find min component float clampedAverage = max(0.0, (maxHDRValue + minHDRValue) / 2.0); float logAverage = log(clampedAverage); // Natural logarithm sumLogAverage += logAverage; }</span></span></code> </pre> <br>       64  (256 ,     16 ).  ,    ,         (     64×64 ,  , ,     ).          ;      16  ,          ,       ( 0)        .    240 ,         .    64 ,          ,     .          . <br><br>         ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>     .     64      ,          ,      ,    .             ,         . <br><br>             . ,   ROTR  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   (Photographic Tonemapping)</a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, was die Verwendung logarithmischer Mittel anstelle der üblichen Mittel erklärt. </font><font style="vertical-align: inherit;">Die Tonwertkorrekturformel im Shader (nach der Belichtung) kann wie folgt erweitert werden:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bz/yv/-k/bzyv-kjhv-hs6lj3mh4yfrh427w.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/id/zn/1d/idzn1d3rn-3qs7vrokrn94d9z1m.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine kurze Erklärung finden Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ich konnte nicht herausfinden, warum eine zusätzliche Division durch Lm notwendig ist, weil sie den Einfluss der Multiplikation aufhebt. </font><font style="vertical-align: inherit;">In jedem Fall ist whitePoint 1.0, sodass der Vorgang in diesem Frame nicht viel bewirkt. Das Bild ändert nur die Verschlusszeit. </font><font style="vertical-align: inherit;">Die Werte des LDR-Intervalls sind nicht einmal begrenzt! </font><font style="vertical-align: inherit;">Es tritt während der Farbkorrektur auf, wenn der Farbwürfel indirekt Werte über 1,0 begrenzt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1a/92f/2e8/e1a92f2e852892aa137c170a56718f8e.jpg" alt="Bild"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exposition gegenüber</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/788/c4f/905/788c4f905eecffaa8d5dbd12d1c8972d.jpg" alt="Bild"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Belichtung nach</font></font></i> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Linseneffekt </font></font></h4><br>   (Lens Flares)   .       1xN ( N —     ,      ,     28).    -       ,         - ,   ,       .        ,    . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a0/604/e96/8a0604e96d5a4fe4ebf691719f03d75f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dann wird jedes Element als einfache ebene ausgerichtete Ebenen gerendert, die von Lichtquellen emittiert werden. </font><font style="vertical-align: inherit;">Wenn der Alpha-Wert kleiner als 0,01 ist, wird der Position der Wert NaN zugewiesen, damit dieses Partikel nicht rastert. </font><font style="vertical-align: inherit;">Sie sind ein bisschen wie der Bloom-Effekt und fügen Glühen hinzu, aber dieser Effekt selbst wird später erzeugt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/526/da9/a18/526da9a184f303dc8e3bfd82cd16034a.jpg" alt="Bild"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linse flackert auf</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/465/440/335/4654403353e5b94dc7bae2a68b95ed88.jpg" alt="Bild"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linseneffektelemente</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c1/f10/c43/5c1f10c4396cbd6a8502a28b5a53fe0f.jpg" alt="Bild"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linseneffekte nach</font></font></i> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Blüte </font></font></h4><br>  Bloom   :   HDR-,   ,        ,     .          .     ,  .      7  : 2  , 1   , 4   . <br><br><ol><li>                  target   (mip 1).        .  ,   mip-    ,           0.02. </li><li>     mip      mip 2, 3, 4  5. </li><li>       mip 5.        ,    .       ,             . </li><li>   —   .  3          ,   mip N    mip N + 1,       ,     .     bloom      ,     . </li><li>     mip 1      HDR-,      bloom. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b0c/478/bc7/b0c478bc7ccc0c4774cea8b2aaa4ec8b.jpg" alt="Bild"></div><br> <i>Bloom </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f77/b74/99b/f77b7499b451e0f232b06d183ccc04f4.jpg"></div><br> <i>MIP 1   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c65/ae2/875/c65ae2875487b8a9b441a9ce0b137430.jpg"></div><br> <i>MIP 2   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/55b/9a4/757/55b9a4757f48867201dc76df90ea0dd1.jpg"></div><br> <i>MIP 3   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba5/17d/a6f/ba517da6f179cca1067a08115579c155.jpg"></div><br> <i>MIP 4   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33f/91f/44d/33f91f44dcc1f9a395375fce8535ac2d.jpg" alt="Bild"></div><br> <i>MIP 5   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecb/561/33d/ecb56133d1965bcc93024c5cded95ec7.jpg"></div><br> <i> MIP 5  Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/235/0ed/474/2350ed47490101cda12baffbd61fc8f0.jpg"></div><br> <i>MIP 4   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff0/cfb/4df/ff0cfb4dfeea995b8666d4b8aec057a1.jpg"></div><br> <i>MIP 3   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/980/7ca/a31/9807caa31251495050af2e2fd32b5e90.jpg" alt="Bild"></div><br> <i>MIP 2   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/857/4be/854/8574be854f2526857ef9b6854d6f7235.jpg"></div><br> <i>MIP 1   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9be/aa8/8a1/9beaa88a1bf00876801bb103ef85dd16.jpg"></div><br> <i>Bloom </i> <br><br>     ,       .     ,       ; ,    ,      16.    :         ,         float32  float16!             .    ,      . <br><br><h4> FXAA </h4><br> ROTR       (),  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FXAA</a> (Fast Approximate AA)  SSAA (Super Sampling AA).     temporal AA,      AAA-   .     , FXAA     , SSAA   ,   «» ,     . <br><br><h4> Motion Blur </h4><br> ,  Motion blur (  )  ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shadows of Mordor</a> .                .      ,  ,          ,     ,     .              ,        ,       .         ,   ,          .      : -,      ,         , -,      .    ,       . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f4/91d/df6/3f491ddf60c6a1a6b9caeaec316eab4f.jpg" alt="Bild"></div><br> <i>Motion Blur </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e5/eb5/d42/2e5eb5d42d4e0c36c4c96e764538f8c8.jpg"></div><br> <i> Motion Blur</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edf/3ed/2e7/edf3ed2e7144ec27ba21b3b16e606c7f.jpg"></div><br> <i>Motion Blur,  1</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c5/c65/931/7c5c6593183900a85a3d0372fce9eb03.jpg"></div><br> <i>Motion Blur,  2</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a3/bc5/bcc/8a3bc5bcc85c92d698fc081e49c0f318.jpg"></div><br> <i>Motion Blur,  3</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04f/5e1/a7e/04f5e1a7e722d9818c8a23ef5759c172.jpg"></div><br> <i>Motion Blur,  4</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9d/98f/579/f9d98f579e02acec8e3ef99e90bdd0c0.jpg"></div><br> <i>Motion Blur,  5</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99e/3ca/b5c/99e3cab5cbf5d25b2eea0d3311eae7cf.jpg"></div><br> <i>Motion Blur,  6</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/042/af0/5bd/042af05bd488751c53bd97c73cb037fc.jpg"></div><br> <i>Motion Blur,    </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e10/26d/c47/e1026dc47d9035e8713422ad8210e6a7.jpg"></div><br> <i>Motion Blur,   </i> <br><br><h4>     </h4><br>    ,      . <br><br><ol><li>  :          </li><li>  :     </li><li> :      ,        ,    ,    ,      </li></ol><br><h4> UI </h4><br> UI    —       .     UI      -.  ROTR        .   ,      3D UI;     HDR- sRGB-      ,     (-)   . <br><br><h4>   </h4><br> ,       ,    .       .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Crystal Dynamics</a>   ,     .           Renderdoc.       PC    . , ,        —    ,           DX12. ,          . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436500/">https://habr.com/ru/post/de436500/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436490/index.html">Motorola plant die Einführung der Razr v3-Inkarnation</a></li>
<li><a href="../de436492/index.html">Wir suchen Redner beim 10. DIY Mitap am 17. Februar 2019</a></li>
<li><a href="../de436494/index.html">Ersetzen einer Festplatte unter Beibehaltung der richtigen Nummerierung in CEPH</a></li>
<li><a href="../de436496/index.html">PVS-Studio für Java</a></li>
<li><a href="../de436498/index.html">Software AG: Nicht nur ARIS</a></li>
<li><a href="../de436502/index.html">Abonnement verwöhnt oder wie man mehr an dieselben Kunden verkauft</a></li>
<li><a href="../de436504/index.html">System im Paket oder was ist unter Chip-Paketabdeckung?</a></li>
<li><a href="../de436506/index.html">Wie man ohne großen Aufwand einen KI-Rassisten erschafft</a></li>
<li><a href="../de436508/index.html">Investitionen in Höhe von 10 Millionen US-Dollar und Wozniaks Lob - Schaffung eines Bildungscomputers für Kinder</a></li>
<li><a href="../de436510/index.html">Kerndaten im Detail</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>