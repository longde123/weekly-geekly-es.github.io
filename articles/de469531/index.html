<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñ•Ô∏è üïπÔ∏è ‚ò∫Ô∏è "Programmiersprachen besser und schlechter zu vergleichen, ist eine v√∂llig idiotische Besch√§ftigung." üë©üèº‚Äçüîß üõ©Ô∏è üò∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Haftungsausschluss : Ja, am Montag haben wir einen Habrapost mit einem solchen Sprachvergleich ver√∂ffentlicht. Nein, wir sind nicht verr√ºckt. Alles l√§...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>"Programmiersprachen besser und schlechter zu vergleichen, ist eine v√∂llig idiotische Besch√§ftigung."</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/469531/"><img src="https://habrastorage.org/webt/yv/ge/fz/yvgefz8egxcjmh0dvu66dqynh5q.png"><br><br><blockquote>  <b>Haftungsausschluss</b> : Ja, am Montag haben wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Habrapost</a> mit einem solchen Sprachvergleich ver√∂ffentlicht.  Nein, wir sind nicht verr√ºckt.  Alles l√§uft nach Plan. </blockquote><br>  Vitaly Bragilevsky kombiniert Kenntnisse der theoretischen Informatik mit der aktuellen Programmierpraxis.  Er unterrichtet Disziplinen der theoretischen Informatik, ist Mitglied des Haskell Standardization Committee und Mitglied des √úberwachungsausschusses f√ºr die Entwicklung des HHCell Compilers GHC. <br><br>  Diese Habrastatya ist ein gro√üartiges Interview mit Vitaly zu folgenden Themen: <br><br><ul><li>  JavaScript lehren und kennenlernen; <br></li><li>  Warum Haskell w√§hlen? <br></li><li>  Der Platz funktionaler Sprachen im Leben eines Programmierers; <br></li><li>  Was n√ºtzt JavaScript und wie entwickelt es sich? <br></li><li>  Was wird in den n√§chsten 10-15 Jahren in Programmiersprachen erscheinen? <br></li><li>  Welche Programmiersprachen sind glaubw√ºrdig und warum? <br></li><li>  Was ist der Unterschied zwischen wissenschaftlichen Konferenzen und Entwicklerkonferenzen?  Warum sollte ein Lehrer √ºberhaupt zu ihnen gehen? <br></li><li>  Ist es wichtig, dem Programmierer vorzulesen, sind B√ºcher veraltet und welche von ihnen m√ºssen gelesen werden? <br></li></ul><br>  Die Interviews werden von Mitgliedern des Programmkomitees der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Moskauer HolyJS 2019-</a> Konferenz, Alexei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zolotikh</a> und Artyom Kobzar, gef√ºhrt.  Wenn Ihnen das Interview nicht ausreicht, wird Vitaliy sehr bald beim n√§chsten HolyJS anhand von Beispielen erl√§utern und zeigen, wie JavaScript mit der Theorie der Algorithmen verbunden werden kann. <br><a name="habracut"></a><br><h2>  √úber das Lehren und Kennenlernen von JavaScript </h2><br>  <b>Artyom</b> : Unter unseren Zuh√∂rern, insbesondere in der JavaScript-Community, sind Sie nicht allgemein bekannt. Erz√§hlen Sie uns bitte von sich selbst, was Sie tun, was Ihre Hobbys sind - Arbeiter, Profis, m√∂glicherweise nicht arbeitende. <br><br>  <b>Vitaliy</b> : Ich unterrichte haupts√§chlich, unterrichte einen Kurs an der St. Petersburg State University und nehme regelm√§√üig an anderen Arbeiten teil.  Da ich Lehrer bin, musste ich viele verschiedene Themen studieren.  Wie es normalerweise an einer Universit√§t der Fall ist, muss ein bestimmter Kurs gelesen werden, und daf√ºr m√ºssen Sie all dies verstehen. <br><br>  So kam es, dass ich viele Dinge unterrichtete.  Zum Beispiel hie√ü einer meiner allerersten Spezialkurse, den ich im ersten Jahr meiner Arbeit, als ich noch sehr jung war, zugewiesen wurde, Web XML Technologies.  Dann waren dies hei√üe Themen, Ajax erschien nur in JavaScript und es gab wirklich keine Literatur.  Ich erkl√§rte, wie man das alles benutzt. <br><br>  Seitdem hat niemand wirklich verstanden, wie man es benutzt, alles war auf Beispiele wie dieses beschr√§nkt: Es gibt zwei Dropdown-Listen, der Benutzer w√§hlt ein Element in einer der Listen aus, eine Anfrage wird an den Server gesendet und Sie erhalten Daten zum Ausf√ºllen der zweiten Dropdown-Liste.  Es war eine Neuheit, es gab nur wenige solcher Websites auf Websites.  Dann wurde nur die Google-Suche im Beta-Modus angezeigt. Wenn Sie mit der Eingabe einer Abfrage beginnen, werden Sie aufgefordert, fortzufahren.  Ajax-Zeug war neu und ich habe es ihnen beigebracht. <br><br>  Was ich erst danach nicht unterrichtet habe: sowohl mathematische als auch programmiererische Dinge.  Es war einmal, als ich auf Haskell stie√ü, und seitdem ist es das Hauptattraktionsgebiet geworden, was ich auch getan habe.  Neben dem Unterrichten, dem Studium der Informatik im Allgemeinen begann ich, mit dem Verlag "DMK-press" zusammenzuarbeiten, mehrere B√ºcher f√ºr sie zu √ºbersetzen (mit anderen Leuten habe ich selbst etwas bearbeitet).  Es war auch √ºberall in Haskell.  Vielleicht sind diese beiden Arten von Aktivit√§ten - Unterrichten und was mit der √úbersetzung von B√ºchern ins Russische verbunden ist - die Hauptsache, die ich getan habe. <br><br>  <b>Artyom</b> : Das hei√üt, wir haben uns direkt einen JavaScript-Veteranen genannt.  Ich habe Ajax und wahrscheinlich sogar PHP gefunden. <br><br>  <b>Vitaliy</b> : Ja, ich habe in den ersten Jahren sogar in PHP programmiert und mehrere Websites geschrieben. <br><br><h2>  √úber die Gr√ºnde f√ºr die Wahl von Haskell </h2><br><br>  <b>Artyom</b> : Sie sind in der Haskell-Community am bekanntesten.  Warum haben Sie in Haskell und diesem √ñkosystem Halt gemacht? <br><br>  <b>Vitaliy</b> : Da ich nie √ºber eine Karriere als Programmierer nachgedacht habe, war ich frei in dem, was ich mag.  Ich musste mich nicht daf√ºr interessieren, wof√ºr sie mehr bezahlen.  Als ich von Haskell erfuhr, hat es mir sehr gut gefallen.  Es ist nicht sehr gut, dar√ºber zu sprechen, und irgendwie erlaubte ich mir sogar, etwas zu sagen wie "Haskell ist eine Sprache f√ºr kluge Leute in der englischsprachigen Gemeinschaft, und die Gemeinschaft ist im Durchschnitt schlauer."  Die Amerikaner haben mich daf√ºr geschlagen, und sie haben Recht.  Aber genau das hat mich interessiert. <br><br>  Das hei√üt, zu einer Zeit, als ich noch an einer Universit√§t studierte, besch√§ftigte ich mich mit ziemlich strenger Mathematik, so dass es f√ºr mich sehr nat√ºrlich war, zu einem relativ harten Programmierthema zu wechseln.  Im Allgemeinen ist klar, dass Haskell von den in der Produktion verwendeten Programmiersprachen eine der wissenschaftsintensivsten oder ressourcenintensivsten ist.  All diese Abstraktion, die es gibt, kommt der Mathematik am n√§chsten.  Daher war es f√ºr mich eine nat√ºrliche Wahl. <br><br><h2>  √úber funktionale Sprachen und ihren Platz in der Welt der Programmierer </h2><br>  <b>Alexei</b> : Wie denkst du √ºber dynamische und funktionale Sprachen?  Was ist mit Lisp-√§hnlichen Dingen? <br><br>  <b>Vitaliy</b> : Ich positioniere mich nicht so sehr als Haskellist, sondern als Liebhaber von Programmiersprachen im Allgemeinen.  Erstens ist klar, dass alle Sprachen ein Existenzrecht haben.  Ich glaube, dass der Vergleich von Programmiersprachen auf einer ‚Äûbesser-schlechteren‚Äú Basis eine v√∂llig idiotische Besch√§ftigung ist.  Leider geschieht dies oft in sozialen Netzwerken und nicht nur, aber dies macht keinen Sinn. <br><br>  Ich mag es, die Funktionen von Programmiersprachen zu lernen und Programmiersprachen anhand dieser Funktionen zu klassifizieren.  Aber zu bedenken, dass dies eine gute und eine schlechte Funktion ist, ist dumm.  Daher ist es klar, dass Sprachen mit dynamischer Typisierung sicherlich ein Existenzrecht haben.  Zum Beispiel habe ich jetzt in meinem Studiengang f√ºr Studienanf√§nger die Programmiersprache Julia als Grundlage genommen.  Dies ist eine dynamische Sprache, es gibt ein Typensystem.  Es war interessant f√ºr mich, ihn zu unterrichten und gleichzeitig diesen Anwendungsbereich zu sehen. <br><br>  Im Allgemeinen war die erste funktionale Sprache, auf die ich stie√ü, Lisp.  Wenn ich vor vielen Jahren das Buch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûDie Struktur und Interpretation von Computerprogrammen‚Äú</a> las, beeindruckt das nat√ºrlich alles.  Deshalb habe ich gro√ües Interesse an all dem.  Zum Beispiel habe ich auch eine gro√üe Liebe zu JavaScript, weil ich seine Geschichte gut kenne. <br><br>  Ich wei√ü, als es zum ersten Mal erschien, h√§tte es so etwas wie Lisp sein sollen, denn zuerst war die urspr√ºngliche Syntax schemaartig.  Und dann wurde es aus Marketinggr√ºnden durch ein C-√§hnliches ersetzt, aber nat√ºrlich sitzen Lisp-Sprachen im Inneren und es beeindruckt mich. <br><br>  Im Allgemeinen habe ich das Gef√ºhl, dass viele JavaScript-Liebhaber dies nicht wissen, und es geht ihnen gut, aber ich wei√ü, also bin ich noch besser.  Alle Sprachen sind also gut und es ist interessant f√ºr mich, sie zu studieren. Es ist interessant, den Bereich der Anwendbarkeit zu studieren. Es ist interessant zu sehen, was mit ihnen einfacher und bequemer gemacht wird.  Und im Allgemeinen ist ein solcher Sprachvergleich f√ºr einzelne Aufgaben auch ein separater interessanter Bereich, mit dem ich mich gerne befasse. <br><br><h2>  Was ist gut in Javascript </h2><br>  <b>Artyom</b> : W√§hrend Sie den Bericht vorbereiteten, hatten Sie Kontakt mit der neuen Version von JavaScript, mit dem, was darin eingebettet war.  Was k√∂nnen Sie aus Sicht der Theorie der Programmiersprachen als gute, schlechte, vielleicht interessante L√∂sung herausgreifen? <br><br>  <b>Vitaliy</b> : Unter dem Gesichtspunkt der Vielfalt der Programmiersprachen ist das Objektmodell nat√ºrlich das interessanteste in JavaScript.  Das war es von Anfang an.  Das Prototypmodell hat eine sehr reiche Geschichte, es ist super interessant, weil es praktisch keine andere moderne Sprache jetzt hat. <br><br>  In Sprachen wie C # l√∂sen sie mithilfe von Erweiterungsmethoden das Problem, Methoden zu vorhandenen Objekten hinzuzuf√ºgen.  Dies war von Anfang an JavaScript, und dort sieht es viel nat√ºrlicher aus.  Das hei√üt, wir haben einen Prototyp, zu dem wir Methoden hinzuf√ºgen und darauf basierend neue Objekte erstellen.  In Sprachen wie C # ist dies meiner Meinung nach k√ºnstlicher. <br><br>  Ich war interessiert zu sehen, wie Module zu JS hinzugef√ºgt werden.  In JavaScript gibt es seit Jahrzehnten Probleme mit Modulen, und ich frage mich, wie sie damit begonnen haben.  Da Module ein tiefes theoretisches Thema sind, gibt es viele verschiedene Ans√§tze f√ºr ihre Implementierung.  Ich kann zwar nicht sagen, dass ich dies gr√ºndlich studiert habe, aber dies scheint mir ein interessanter Fall auf dem Gebiet der Entwicklung von Programmiersprachen zu sein.  Das hei√üt, wie Sie der vorhandenen Sprache Funktionen hinzuf√ºgen, die vorher nicht vorhanden waren. <br><br>  Dies ist immer noch interessant, da vor einigen Jahren in Haskell versucht wurde, beispielsweise korrektere Module hinzuzuf√ºgen.  Jetzt k√∂nnen wir sagen, dass dieser Versuch fehlgeschlagen ist und niemand damit begonnen hat.  Dies ist das sogenannte Rucksackprojekt, das hei√üt, es scheint implementiert zu sein, aber die Verwendung ist so unbedeutend, dass klar wurde, dass sie ein gutes neues modulares System gemacht haben, aber es hat nicht sehr gut funktioniert. <br><br>  Ich habe das Gef√ºhl, als ich mit verschiedenen Leuten gesprochen habe, die sich mit JavaScript besch√§ftigen, dass die Module in JS besser geworden sind.  Es stimmt, ich wei√ü das sehr oberfl√§chlich.  Ich denke, die Meinung zu JavaScript wird sehr stark von der Tatsache beeinflusst, dass man dort sehr schlechten Code schreiben kann.  Und wenn Sie sehr schlechten Code schreiben k√∂nnen, muss jemand ihn in gro√üen Mengen schreiben.  Dies wirkt sich negativ auf die Beurteilung der Sprache aus.  Aus Sicht der Theorie der Programmiersprachen ist dies nat√ºrlich nicht sehr gut. <br><br>  <b>Alexey</b> : Haben Sie es geschafft, die neuesten JavaScript-Versionen zu sehen?  Was hat neben dem Modulsystem √ºberrascht? <br><br>  <b>Vitaliy</b> : Ich kann nicht sagen, dass es mir gelungen ist.  Ich bl√§tterte durch etwas, aber nicht sehr tief.  Ich kann nicht auflisten. <br><br><h2>  Was wird in naher Zukunft in Programmiersprachen erscheinen </h2><br><br>  <b>Artyom</b> : Die Theorie der Programmiersprachen ist ein eher akademisches Umfeld und im Prinzip interessant.  Was sind die neuen Funktionen in Sprachen, die in 10-15 Jahren erscheinen werden?  Welche Forschungsarbeiten werden derzeit in diesem Bereich durchgef√ºhrt? <br><br>  <b>Vitaliy</b> : Ich w√ºrde sagen, dass das derzeit hei√üeste Thema das schrittweise Tippen ist.  Dies ist der Fall, wenn gleichzeitig im Programm sowohl typisierte als auch nicht typisierte Teile vorhanden sind.  Es ist f√ºr Python, f√ºr JavaScript ist es f√ºr Spielzeugsprachen gemacht.  Das hei√üt, wir k√∂nnen erstens typisierte und untypisierte Teile kombinieren, und zweitens haben wir eine einfache M√∂glichkeit, die Typisierung zu erweitern. <br><br>  Das hei√üt, wir f√ºhren eine Prototyp-Implementierung von etwas durch, wie es immer in dynamischen Sprachen ohne Typen geschehen ist, und dann h√§ngen wir immer mehr Typen an einzelne Komponenten.  Im Idealfall erhalten wir ein typisiertes Programm mit allen Vorteilen.  Zur Laufzeit treten weniger Fehler auf und so weiter. <br><br>  Dies ist vielleicht eine der wichtigsten Entwicklungen.  Einige Elemente liegen bereits in Form von Bibliotheken vor, dies ist jedoch bislang noch ein Forschungsgebiet.  Wenn wir uns f√ºhrende Konferenzen zu Programmiersprachen ansehen, gibt es mit Sicherheit mehrere Abschnitte, die sich dem schrittweisen Tippen und Tippen widmen.  Dies wird mit ziemlicher Sicherheit in den meisten dynamischen Sprachen enthalten sein, da es sehr praktisch ist.  Es stellt sich die Kombination zweier Welten heraus. <br><br>  Seit zehn Jahren wird an abh√§ngigen Typen geforscht, wenn der Typ von den Werten abh√§ngt.  Das gr√∂√üte Problem besteht darin, dass die Grenze zwischen der Kompilierungsphase und der Ausf√ºhrungsphase gel√∂scht wird, da in der Kompilierungsphase bestimmte Werte noch nicht bekannt sind, die Typen jedoch √ºberpr√ºft werden m√ºssen.  Das hei√üt, bestimmte Werte werden zur Laufzeit angezeigt, die Typen sollten jedoch bereits korrekt sein. <br><br>  Und dort m√ºssen Sie bereits eine Funktion schreiben, in der sich je nach √ºbergebenem Wert die Art des Ergebnisses √§ndert.  Diese Verwischung der Grenze zwischen Laufzeit und Kompilierungszeit ist eine sehr interessante Sache, sie wird auch seit 10-15 Jahren aktiv in der Theorie untersucht und wird mit ziemlicher Sicherheit in viele Sprachen fallen, haupts√§chlich statisch typisierte, da das Ausdruckstypensystem aufgrund dieser Entwicklung erheblich erh√∂ht wird. <br><br>  Es stimmt, es gibt einen Nachteil.  Es stellt sich heraus, dass das Schreiben von Programmen zu kompliziert sein kann.  Es scheint, dass die Typen alles kontrollieren, aber das Schreiben ist sehr schwierig. Manchmal denkt man, dass man mit diesen abh√§ngigen Typen einen Typ nehmen und programmieren muss. <br><br>  <b>Artyom</b> : Sie machen es hier. <br><br>  <b>Vitaliy</b> : Dies kann auch mit gro√üem Wunsch geschehen, nur manchmal gibt es keinen Ort, an den man gehen kann.  Wenn Sie vom Server kommen, verstehen Sie nicht, was, und bis Sie das Programm starten, wissen Sie nicht, dass Sie solche Dinge noch verwenden m√ºssen, selbst in Haskell gibt es keinen Ort, an den Sie gehen k√∂nnen. <br><br><h2>  Wie Vitaly Haskell entwickelt </h2><br><br>  <b>Artyom</b> : Es ist lustig.  Zur√ºck nach Haskell.  Sie sind Mitglied des Haskell 2020-Komitees. Bei Podlodka sagten Sie, dass Sie dort nichts unternommen haben, aber in einem Interview haben Sie erw√§hnt, dass Sie immer noch an einfachen Familien mit eingeschr√§nkten Funktionen arbeiten.  Welche anderen spezifischen Dinge implementieren, √ºberwachen oder beteiligen Sie sich m√∂glicherweise an der Implementierung des neuen Haskell-Standards? <br><br>  <b>Vitaliy</b> : Dies sind zwei verschiedene Aussch√ºsse.  Ich habe zwei Aussch√ºsse.  Eines ist Haskell 2020, in dem nichts wirklich passiert, es ist ein totes Komitee.  Sein Zweck ist es, einen Sprachstandard zu schreiben, und er wird sicherlich nicht geschrieben.  Es klingt besser - "Ausschuss f√ºr die Entwicklung eines Sprachstandards", funktioniert aber nicht. <br><br>  Das zweite Komitee hei√üt "GHC Compiler Supervisory Committee" - der Glasgow Haskell Compiler.  Ich bin seit etwas mehr als einem Jahr dabei, seine Aufgabe ist viel weniger ehrgeizig.  Dieses Komitee ber√ºcksichtigt Funktionen, Vorschl√§ge zum √Ñndern des Compilers und die Version der Sprache, die in diesem Compiler implementiert ist.  Es gibt ein Standard-Haskell, aber es gibt ein Haskell, das von einem bestimmten Compiler implementiert wurde.  Hier ist ein Beispiel f√ºr eine solche Spracherweiterung: ‚Äûeinfache Typfamilien‚Äú.  Dies ist ein Versuch, die Programmierung auf Typebene durch Hinzuf√ºgen zus√§tzlicher Steuerelemente zu vereinfachen. <br><br>  Es stimmt, ich muss sagen, dass es eine ziemlich freie Umgebung gibt, das hei√üt, ich habe wahrscheinlich den ganzen Sommer √ºber keine Requisiten befolgt und viel Zeit diesem Komitee geschuldet. Ich habe vor, darauf zur√ºckzukommen. <br><br>  Meine Aufgabe dort ist folgende: Sie hat es aufgezeigt: Es gibt einen beschriebenen Vorschlag, ich muss nachsehen, vielleicht dem Autor raten, etwas abzuschlie√üen und schlie√ülich mit einem Vorschlag an das Komitee zu gehen, entweder um die Aufnahme in den Compiler zu empfehlen oder um ihn abzulehnen.  Nachdem ich diesen Vorschlag eingereicht habe, diskutiert und trifft der Ausschuss eine Entscheidung - dort wird alles gemeinsam entschieden. <br><br>  Einer der S√§tze, die ich schulde, bezieht sich auf den Unterstrich in Standardanmerkungen.  Wenn Sie den Typ nicht vollst√§ndig angeben k√∂nnen, gibt es dort L√ºcken, und es gibt einen Vorschlag, dieses System zu reformieren, um irgendwie alles einheitlich zu analysieren.  L√∂cher k√∂nnen in Standardanmerkungen enthalten sein, bei der Implementierung von Funktionen.  Ein bestimmter einheitlicher Ansatz wird vorgeschlagen. <br><br>  Dieses Komitee ber√ºcksichtigt enge √Ñnderungen im Compiler. <br><br>  <b>Artyom</b> : Wir haben auch ein Standardisierungskomitee - TC39.  Zuerst kommt ein bestimmter und er sucht einen Champion.  Ein Champion ist eine Person aus einem Komitee, die bereit ist, diese Site zu √ºberwachen.  Dann haben wir, soweit ich wei√ü, einen Abschluss nach Stufen.  Es gibt 4 Stufen, auf denen sich das Feature bewegt.  Null ist, wenn es nur einen Vorschlag gibt, eine ist, wenn ein Champion gefunden und eine API auf hoher Ebene beschrieben wird, und so weiter.  Der vierte ist bereits in die Sprache eingegeben.  Die Person, die die Pr√§position gemacht hat, und der Kurator nehmen an den Sitzungen dieses Komitees teil und f√∂rdern diesen Vorschlag.  Wie geht es dir?  Ist es nur ein Ausschuss, der dann intern entscheidet? <br><br>  <b>Vitaliy</b> : Alle unsere Aktivit√§ten sind offen, sie werden auf GitHub und teilweise in offenen Mailinglisten durchgef√ºhrt.  Der Autor des Vorschlags kommt herein - w√§hrend wir √ºber den Vorschlag nachdenken, interessiert uns die Umsetzung nicht sehr.  Es kann sein, es kann nicht sein, wir analysieren es in keiner Weise, nichts h√§ngt davon ab.  Erstens gibt es eine Diskussion in der breiten Community, jeder kann diesen Vorschlag kommentieren. <br><br>  Wenn er sich dann niedergelassen hat, legt der Autor es dem Ausschuss vor, dh er bittet den Ausschuss, dar√ºber nachzudenken.  Der Ausschusssekret√§r ernennt einen Hirten, der ihn beaufsichtigen wird.  Er schaut, analysiert, bietet vielleicht Verbesserungen an oder versucht im Gegenteil zu rechtfertigen, warum dies kein Existenzrecht hat, woraufhin er einen Vorschlag vorlegt, ihn abzulehnen oder m√∂glicherweise zur √úberarbeitung zu senden oder zu akzeptieren.  Der Ausschuss diskutiert, trifft eine Entscheidung. <br><br>  Und wenn das Komitee beschlie√üt, dass wir dieser Vor-Site zustimmen, und sie in den Status eines akzeptierten √ºbergeht, kann grunds√§tzlich jeder ihre Umsetzung aufnehmen.  Bis zu diesem Punkt gibt es m√∂glicherweise keine Implementierung, wir treffen nur eine Entscheidung - ja, es w√§re sch√∂n, eine solche Funktion in der Sprache oder im Compiler zu haben, und wir haben eine solche Liste akzeptierter, aber nicht implementierter Unterknoten. <br><br>  Au√üerdem ist dies nicht l√§nger die Aufgabe des Komitees, dann stellt jeder eine Pull-Anfrage an den Quellcode des Compilers, es gibt Ingenieure, das Team √ºberschneidet sich teilweise mit dem Komitee, diejenigen, die bereits entscheiden, ob diese Pull-Anfrage akzeptiert wird oder nicht. <br><br>  Da das Komitee zustimmt, dies zu akzeptieren, das hei√üt, es ist im Prinzip notwendig, die Zusammenf√ºhrungsanforderung zu akzeptieren, aber es gibt technische Fragen, es wird dort nicht verschl√ºsselt, einige Leistungsprobleme werden von dem Team gel√∂st, das den Compiler direkt entwickelt.  Dies ist nicht l√§nger unser Job. <br><br>  <b>Alexei</b> : Es stellt sich heraus, dass Haskell jetzt ziemlich alte Standards hat.  Ich sehe, es gibt Haskell 2010. <br><br>  <b>Vitaly</b> : Ja, 2010, sehr alt.  Es gab mehrere Versuche, einen neuen zu schreiben.  Es gab eine Idee, jedes Jahr Standards herauszugeben, aber leider schlug alles fehl.  2016 trat ein 2020-Ausschuss zusammen, aber er tat auch nichts.  Es gibt mehrere Gr√ºnde f√ºr unterschiedliche Schwierigkeitsgrade, warum diese Arbeit nicht fortgesetzt wird.  Ja, der neueste Standard von 2010, es gibt keinen neuen und es ist nicht sichtbar, dass er angezeigt wird. <br><br><h2>  √úber Kurse und neue Projekte </h2><br>  <b>Artyom</b> : <b>Kommen</b> wir zur√ºck zu Ihrer Hauptt√§tigkeit, dem Unterrichten.  Ich habe Sie pers√∂nlich im Verlauf der Kategorietheorie getroffen, was mir sehr gut gef√§llt.  Du sagst, du magst ihn nicht.  Auf welche anderen Kurse k√∂nnten Sie stolz sein und auf welche w√ºrden Sie sich gerne treffen?  Zum Beispiel war der Kurs vielleicht mit Pfosten, aber im Prinzip ist das Erz√§hlprogramm selbst sehr gut. <br><br>  <b>Vitaly</b> : Erstens habe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ich</a> alle Kurse, die ich habe, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf YouTube</a> ver√∂ffentlicht.  Dort habe ich einen Kurs √ºber Idris - dies ist eine solche Programmiersprache mit abh√§ngigen Typen, und sogar zwei Versionen habe ich zweimal gelesen.  Ich habe dort auch ein paar Kurse zum Haskell Language Compiler.  Einer widmet sich modelltheoretischen Fragen.  Ich erinnere mich nicht genau an den Namen, aber dort geht es darum, wie die Typentheorie direkt im Haskell-Compiler funktioniert. <br><br>  Die Idee ist einfach: Der gesamte Haskell-Code wird zu einem ziemlich einfachen Œª-Kalk√ºl kompiliert, dem sogenannten F-System mit kleinen Erweiterungen.  Dies ist tats√§chlich im Compiler-Code enthalten, und der Kurs konzentriert sich darauf, wie diese Elemente der Typentheorie direkt im Compiler verwendet werden. <br><br>  Und es gibt einen Kurs, in dem ich allgemein √ºber die Geschichte der Typinferenz erz√§hle und wie die Typinferenz zu Beginn, als sie in den 60er Jahren erfunden wurde, arrangiert wurde, bevor die Typinferenz in der Haskell-Sprache angeordnet wurde. Was sind die Schwierigkeiten? wie das alles funktioniert. <br><br>  Es gibt einen kurzen Kurs, den ich an der Sommerschule f√ºr Mathematik unterrichtet habe.  Dort nehmen sie von Zeit zu Zeit, wie mir gesagt wurde, an Informatikkursen teil, damit sich die Kinder ausruhen k√∂nnen.      ,  ,    ,   ,        :     .         ‚Äî  ‚Äî         .        ,      ,       ,      . <br><br> ,  ,    . -       ,     ,    ,    ,  ,     ,    -  .   ,    - ,         .  ,      ,    -   -   .     . <br><br>        . -,  ,     ,   ,  ,  .      , .     ,    -   ,  -,     - ,   ,       .    -  ,  , -    ,    .          .        , ,     . <br><br>       , ,    , .   ,  , ,      ,           ,    ,     . <br><br> <b></b> :     - ?  ,  ,    .   , ,  , ,    -  . <br><br> <b></b> :         Computer Science Club.    ,          ,  ,     .  ,     . <br><br>     10 .    ¬´ GHC Haskell:  ¬ª.         GHC,    ,   40 ,      10 .          :     . <br><br>          ,       Haskell,  ,   .            ,  , .     . <br><br>        ,       1-2 .        .      ,  ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>    .    ,   : ,  ‚Äî   ,  -   ,    .           ,       . <br><br> ,  ,   ,   .        ,         ,     .   ,    . <br><br>    ,       ,     ,      ,   ,   .      ,   . <br><br> <b></b> :   ,     JetBrains  - ,    .    ? , -   ? <br><br> <b></b> :  JetBrains      ,    Haskell   ,   JetBrains  Haskell-  ,     . <br><br> <b></b> :  Haskell  JetBrains? <br><br> <b></b> :      Haskell c   JetBrains,    .     ,   . <br><br> <b></b> :     Haskell  JetBrains? <br><br> <b></b> :     -  Haskell   JetBrains?  ,  . <br><br> <b></b> : ,    . () <br><br> <b></b> :     .   ,    Java,    Haskell. <br><br> <b></b> :   ,    JetBrains? <br><br> <b></b> :      JetBrains Education.   JetBrains Research ‚Äî ,  Education ‚Äî . <br><br><h2>  JavaScript- </h2><br><br> <b></b> :      ,    , ,   JavaScript? , ,  ,  Elm,       Haskell. <br><br> <b></b> : -,        .  GHCJS   ,  ,      ,    .  Elm    ,       Haskell,  .   ,      ,     -        . <br><br>   ,       ,       ,   .        JavaScript     . <br><br> ,   Idris   ‚Äî    Idris   PHP,  JavaScript,    .   . , , JavaScript  Haskell . <br><br>     ,  - ,     ‚Äî     ,         ‚Äî  ,  . <br><br>    ‚Äî , ,   ,    ,      .   ,     .  ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  HolyJS</a>       ,         ,     ,   ,     ,         .       ‚Äî   ,    . <br><br>         ,   Œª-   ,    ‚Äî Œª-,  ,     ,      .     ,     Œª-,     ,    . <br><br>    1936 ,               ‚Äî         .   ,   . <br><br><h2>        </h2><br><br> <b></b> :        ,     ?      Swift, ,   enum  ,   Union,           ? <br><br> <b></b> :  , ,   .    : ,          ,    . ,      ,  Python        ,            ,    . <br><br>   ,     ,   Python,      .  ,       ,    ,    . <br><br>   ,  ,     ,  ,    ,    .          C#.  C# : -, Microsoft    Java,   , , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ,      Delphi,   #,   C#   ,      Haskell,     . <br><br>     ,       . ,  JetBrains,   Kotlin,    . Kotlin, C#, Swift  Apple,        .   ,       . <br><br> ++ -   , ,  ,   - ,         ,        ,  . ,  ,   ,  JavaScript ,     . , ,  . <br><br>        ,    ,       . <br><br> <b></b> : -,       ,    ,     Mozilla  Rust. <br><br> <b></b> : , Mozilla ‚Äî    ,  ,  - open source-,   .      .    ,   Rust   ,     .   ,   Rust   ,  -  , . <br><br>   ,   Twitter   ‚Äî -     Microsoft,   , ,     C++   Microsoft   Rust.  , .       ,       Rust. ,  , ,    ,      .   ,    . <br><br>   Rust   ,         - ,    . <br><br><h2>       </h2><br><br> <b></b> : ! , ,      , , ,    ‚Äî   ,  .        , , , - ,       ? <br><br> <b></b> :         ,  ,     .      ,     . -,    , .         .    ,  ,     ‚Äî   .         ‚Äî   ,    ,    .     . <br><br>      ‚Äî    ,  ,   -,    ,      .       ,        . <br><br>      ,  ,   ,  .  ,     ,    .      . ,   , ,       ,      .    -     .        .       . <br><br> <b></b> :      ?      , ,         ,   , ,    ? <br><br> <b></b> :  ,   .   , ,     ,      ,         .       ,    -     ,  , , ,  .  ,      .    ,    ‚Äî  .    ,   ,    . <br><br>  ,       ‚Äî   . <br><br><h2>    </h2><br><br> <b></b> :       HolyJS   ? , -    ? ,      . <br><br> <b></b> : ,   ,   ,    ,      ,      .    ,   ,   .    ,             . <br><br>       ,  ,         AppsConf.        .     .         ,    . <br><br>     , , ,  .      : ¬´       ,      ?¬ª.      -   , ,        : ,  ,  Twitter ,  Google .    ,       . <br><br>       .  ,   ,   ,   , ,   ,   ,    . <br><br>  ,       ,      ,          .            ‚Äî  ,    . <br><br><h2>     </h2><br><br>  <b>Artyom</b> : Noch eine Frage, vielleicht chaotisch.  Haben Sie ein Buch √ºber Haskell mit dem Titel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Haskell in Depth geschrieben</a> ? <br><br>  <b>Vitaliy</b> : Leider wurde das Buch dabei nicht geschrieben.  Dies wird als "Early-Access-Programm" bezeichnet.  Und sie wurde leider verlangsamt, und ich kehre langsam zur√ºck, um daran zu arbeiten.  Etwa die H√§lfte davon ist dort geschrieben, und die zweite H√§lfte ist versp√§tet, wof√ºr ich mich sehr sch√§me f√ºr diejenigen, die diesen fr√ºhen Zugang erworben haben. <br><br>  <b>Artyom</b> : Hier ist eine interessante Tatsache: Es gibt eine Meinung in der Community, dass B√ºcher √ºber Programmierung, insbesondere wenn es nicht um Grundkenntnisse geht, nicht sehr gut sind, da die Informationen schnell veraltet sind.  Wie haben Sie als Autor des Buches eine solche Erfahrung gemacht?  Und haben Sie ein solches Problem in Betracht gezogen, dass die Informationen, die Sie in einem Buch angeben, schnell veraltet sein k√∂nnen? <br><br>  <b>Vitaliy</b> : Nat√ºrlich verstehe ich nicht, wie B√ºcher in JavaScript geschrieben sind - meiner Meinung nach ist dies √ºberhaupt eine unm√∂gliche Aufgabe.  Mit Haskell in diesem Sinne etwas einfacher.  Aber hier ist was ich sagen kann. <br><br>  Wenn wir in der Schule Mathematik studieren, ist diese Mathematik im Allgemeinen auch sehr veraltet.  Dies sind die Dinge, die vor ein paar tausend Jahren aufgetaucht sind, ein Satz von Pythagoras.  Vielleicht wird es noch implementiert, aber zu sagen, dass jemand die H√∂he der Pyramiden mit dem Satz von Pythagoras misst, ist ungef√§hr so, normalerweise werden Laser-Roulettes verwendet oder so √§hnlich. <br><br>  Hier ist es ungef√§hr gleich.  Wenn jemand ein gro√üartiger Profi in etwas ist und schon lange Technologie einsetzt, braucht er nat√ºrlich kein Buch.  Nun, das Buch ist nicht f√ºr ihn und ist geschrieben, es wird ben√∂tigt, um in irgendeine Art von Technologie einzusteigen, um dies zu verstehen.  Und wenn Sie bereits eingegeben haben, haben Sie andere Quellen f√ºr die Entwicklung. <br><br>  Daher scheint es mir, dass die B√ºcher nirgendwo hingehen werden.  Wenn Sie anfangen, etwas zu lernen, k√∂nnen Sie nat√ºrlich Programmiersprachen anhand von Artikeln lernen, aber in den meisten F√§llen wird das Ergebnis nicht gut funktionieren.  Meistens ist dies die √úbertragung ihrer Ideen √ºber eine andere Programmiersprache auf eine neue.  Sie erkennen die idiomatischen Konstruktionen f√ºr diese Sprache nicht und wissen nicht, wie Sie sie richtig verwenden sollen. <br><br>  Zuerst ist es besser, das Buch zu nehmen, es zu sortieren und die Basis zu bekommen.  Lassen Sie es nicht die neuesten Versionen von Bibliotheken beschreiben, lassen Sie etwas zur Sprache hinzuf√ºgen, es ist alles m√∂glich, um aufzuholen.  Um die Basis zu bekommen, brauchst du meiner Meinung nach noch ein Buch.  Dies gilt f√ºr alle Programmiersprachen, auch f√ºr JavaScript.  Wie auch immer, wir brauchen eine Art Stabilit√§t, einen solchen Bezugspunkt, auf den Sie sich beziehen k√∂nnen. <br><br>  Dies ist √ºbrigens eines der Ziele beim Schreiben eines Haskell-Sprachstandards, um einen so stabilen Punkt in der Geschichte der Sprache zu schaffen, mit der Sie ein Buch schreiben k√∂nnen.  Auf die eine oder andere Weise kann sich die Sprache entwickeln, aber es gibt einen Standard, und jeder Sch√ºler kann sich darauf konzentrieren. <br><br>  Es ist interessant, wie B√ºcher f√ºr viele Programmiersprachen die Rolle eines Standards spielen.  Zum Beispiel hat Straustrup ein Buch √ºber C ++ geschrieben, und auf diesen Punkt k√∂nnen Sie sich immer beziehen.  C ++ ist weit fortgeschritten, aber beim Erlernen der Sprache ist es durchaus m√∂glich, sich auf diese Version zu konzentrieren, die von Straustrup beschrieben wird. <br><br>  <b>Artyom</b> : Sie haben ein interessantes Thema √ºber die Ressourcen angesprochen, die Menschen ben√∂tigen, die die Sprache nicht lernen, aber tiefer gehen und weitermachen m√∂chten.  Sie k√∂nnen einige Ressourcen empfehlen, die Sie zum Lernen verwenden, und Ressourcen, die f√ºr einen Ingenieur n√ºtzlich w√§ren, um in eine Theorie einzutauchen.  Informatik, in die Typentheorie oder, wie Sie sagten, eine gewisse Unwissenheit eines Ingenieurs beseitigen? <br><br>  <b>Vitaliy</b> : Es f√§llt mir schwer, ein Beispiel zu nennen. Ich kann √ºberhaupt nicht sagen, dass ich regelm√§√üig Informationsquellen habe.  Die vielleicht wichtigste Quelle f√ºr mich ist Twitter.  Es stellt sich heraus, dass alles √ºber Twitter zu mir kommt.  Einige interessante Links erscheinen mir, ich behalte sie f√ºr mich und lese sie regelm√§√üig.  Ich habe das Gef√ºhl, dass es zumindest in Haskell keine solche Quelle gibt, aber es gibt viele angesehene Leute, die vern√ºnftige Dinge schreiben. <br><br>  Ich habe irgendwie versucht, Reddit regelm√§√üig f√ºr diesen Zweck zu verwenden, aber irgendwie hat es bei mir nicht funktioniert, ich habe einfach nicht genug Zeit, um ihm zu folgen.  Aber auf Twitter kommt mir sowieso alles, was fr√ºher oder sp√§ter erscheint.  Schnell gesucht, interessant - gespeichert, dann gelesen. <br><br>  Um etwas im Bereich der Informatik oder IT zu empfehlen, bin ich im Allgemeinen nicht bereit, eine solche Site oder Ressource nicht zu kennen.  Eine wichtige Quelle f√ºr diejenigen, die mit Programmiersprachen zu tun haben, ist die Website <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://lambda-the-ultimate.org</a> .  Dort erscheinen die interessantesten Dinge und es wird diskutiert.  Dies ist ein Muss f√ºr alle, die sich f√ºr die Theorie der Programmiersprachen interessieren. <br><br><h2>  Was dem Programmierer vorzulesen </h2><br><br>  <b>Alexei</b> : Sie sagen, dass B√ºcher nicht ablaufen.  Gibt es eine Liste mit Must-Have-Dingen zum Lesen oder nur Ihre Lieblingsb√ºcher, die Sie empfehlen k√∂nnen?  Ich spreche von Programmiertheorie, von allgemeiner Ingenieurkompetenz. <br><br>  <b>Vitaliy</b> : Ich werde regelm√§√üig gebeten, eine Liste zu erstellen. Ich √ºbernehme keine solche Arbeit. Dies ist eine sehr schwierige Aufgabe. <br><br>  Nach der Theorie der Programmiersprachen gibt es Pierces Buch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Typen in Programmiersprachen".</a>  Dies ist im Allgemeinen eine Grundierung, mit der Typen beginnen k√∂nnen.  Wahrscheinlich w√§re sein erstes Drittel f√ºr alle Programmierer n√ºtzlich. <br><br>  Mein Kollege und ich √ºbersetzten ein Buch mit dem Titel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einf√ºhrung in die Theorie der Programmiersprachen</a> .  Es ist sehr klein und erkl√§rt die formale Semantik, Typinferenz und theoretische Dinge aus der Kompilierung.  Eine so n√ºtzliche Einf√ºhrung in Programmiersprachen. <br><br>  Es gibt ein Buch von Charles Petzold <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Annotated Turing"</a> .  Dies ist ein erstaunliches Genre: Der Autor nahm 1936 einen Turing-Artikel, in dem Turing das beschrieb, was sp√§ter als Turing-Maschine bekannt wurde, und schrieb ein dickes Buch, das diesen Artikel erkl√§rt.  Und der Artikel selbst ist Seite 15. Au√üerdem gibt es eine Geschichte aus dem Leben von Turing selbst, den Hintergrund dieser Aufgabe, wie alles passiert ist.  Abschnitt f√ºr Abschnitt gibt er ein Fragment des Artikels und eine Erkl√§rung dessen, was dort gemeint war. <br><br>  Wenn wir den Artikel jetzt lesen, wird es f√ºr uns sehr schwierig.  Aber dieses Buch von Petzold ist erstaunlich, es stellt den gesamten Kontext wieder her und beschreibt den Artikel selbst.  Ich empfehle dies jedem, dies ist eine sehr interessante Lekt√ºre, die den Geist erweitert.  Es geht auch um Œª-Kalk√ºl, weil alles in der N√§he ist und philosophische Fragen im Zusammenhang mit Berechnungen aufgeworfen werden. <br><br>  Auch aus technologischer Sicht bin ich nat√ºrlich ein gro√üer Fan von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">McConnells</a> Buch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûPerfect Code‚Äú</a> .  Es scheint mir, dass dies auch eine wichtige Lekt√ºre ist.  Sie k√∂nnen nicht alles hintereinander lesen, sondern es einfach auf zuf√§lligen Seiten √∂ffnen, ein paar Seiten lesen und schlie√üen.  Hier geht es darum, wie man Code schreibt. <br><br>  Zwar habe ich k√ºrzlich mit mehreren mobilen Arbeitern gesprochen, sie sagen, dass ein dummes Buch, in dem es nichts N√ºtzliches gibt.  Aber es geht darum, wie man solchen Code so schreibt, dass er lange lebt, unterst√ºtzt und ge√§ndert werden kann.  Vielleicht haben sie wirklich keine solchen Bed√ºrfnisse. <br><br>  Ja, und es gibt dort nicht Swift, nicht Kotlin, eine Art Java, verschiedene Beispiele in verschiedenen Sprachen, √ºber die moderne Programmierer nicht mehr wirklich sprechen.  Das Buch begann zweitausendstel.  Aber ich denke, dass diese Lekt√ºre f√ºr jeden Programmierer sehr n√ºtzlich ist.  McConnell ist immer noch gut darin, dass er alles mit Forschung best√§tigt und sagt: ‚ÄûAlso haben wir so und so eine Studie gemacht, aber so und so, und hier sind die Ergebnisse.  Lassen Sie uns gemeinsam diskutieren, wie man Code schreibt, um ihn gut zu machen. ‚Äú <br><br>  Hier vielleicht genug von einer solchen Lekt√ºre. <br><br>  <b>Artyom</b> : F√ºr eine speziellere Frage frage ich: Sie haben die "Modern Compiler Implementation" empfohlen, die in drei Versionen verf√ºgbar ist - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ML</a> . <br><br>  <b>Vitaliy</b> : Ja, das ist ein Buch √ºber Compiler.  Ich wei√ü nicht, ob jeder es lesen muss, es ist wahrscheinlicher f√ºr diejenigen, die sich f√ºr Compiler interessieren.  Aber ja, ich mag es - es ist klein und wenn Sie damit arbeiten, k√∂nnen Sie wirklich Ihren eigenen Compiler schreiben.  Ich bin mir nicht sicher, ob alle Programmierer ihren eigenen Compiler schreiben m√ºssen, aber wenn Sie pl√∂tzlich neugierig sind, sind Appels B√ºcher wirklich interessant, aber schon etwas Enges. <br><br>  Jetzt kann ich mich einfach nicht mehr an alles erinnern.  In regelm√§√üigen Abst√§nden taucht etwas an der Oberfl√§che auf, weil ich einmal viel gelesen habe.  Zum Beispiel ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûDie Struktur und Interpretation von Computerprogrammen‚Äú</a> auch ein Klassiker, der zum Lesen und Ausf√ºhren von √úbungen n√ºtzlich ist.  Auch wenn ich nicht ganz einverstanden bin, aber das Lesen selbst ist sehr n√ºtzlich. <br><br><blockquote>  Vitaly Bragilevsky wird am 8. und 9. November 2019 mit einem Bericht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûJavaScript im Dienste der theoretischen Informatik‚Äú zur</a> Moskauer HolyJS 2019-Konferenz kommen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.</a> Tickets k√∂nnen auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Website gekauft werden</a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de469531/">https://habr.com/ru/post/de469531/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de469521/index.html">Ich kaufte ein Motorrad, um zu fahren, nicht um zu fallen</a></li>
<li><a href="../de469523/index.html">Abh√§ngigkeit der Codeleistung vom Kontext der Variablendeklaration in JavaScript</a></li>
<li><a href="../de469525/index.html">Automatisiertes Steuerungssystem f√ºr einen Bergbaubagger</a></li>
<li><a href="../de469527/index.html">Ist die Gegensprechanlage ein Spionageohr?</a></li>
<li><a href="../de469529/index.html">Text-Rendering hasst dich</a></li>
<li><a href="../de469533/index.html">Probleme und Bedrohungen der biometrischen Identifizierung</a></li>
<li><a href="../de469537/index.html">Swift mit Snake kennenlernen</a></li>
<li><a href="../de469541/index.html">Zusammenstellung und Bereitstellung derselben Microservices mit werf und GitLab CI</a></li>
<li><a href="../de469543/index.html">Redis-Skalierung und Failover f√ºr DirectumRX-Dienste</a></li>
<li><a href="../de469545/index.html">Was ist neu im Linux-Kernel 5.3 - Grafiktreiber, Virtualisierung und √Ñnderungen im Netzwerksubsystem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>