<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçü§ù‚Äçüë®üèº üçü üë©üèΩ‚Äçü§ù‚Äçüë®üèº WBOIT en OpenGL: transparence sans tri ü§üüèø üòú üèí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ce message concerne la transparence pond√©r√©e ind√©pendante de l'ordre (WBOIT) - l'astuce qui a √©t√© abord√©e dans JCGT en 2013. 

 Lorsque plusieurs obje...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WBOIT en OpenGL: transparence sans tri</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457292/">  Ce message concerne la transparence pond√©r√©e ind√©pendante de l'ordre (WBOIT) - l'astuce qui a √©t√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">abord√©e</a> dans JCGT en 2013. <br><a name="habracut"></a><br>  Lorsque plusieurs objets transparents apparaissent sur un √©cran, la couleur des pixels d√©pend de celui qui est le plus proche du spectateur.  Voici un op√©rateur de m√©lange bien connu utilis√© dans ce cas: <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><merror><mtext>\&amp;#xA0;begin&amp;#xA0;{matrix}&amp;#xA0;C&amp;#xA0;=&amp;#xA0;C_&amp;#xA0;{near}&amp;#xA0;\&amp;#xA0;alpha&amp;#xA0;+&amp;#xA0;C_&amp;#xA0;{far}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;alpha)&amp;#xA0;&amp;amp;&amp;amp;&amp;#xA0;(1)&amp;#xA0;\&amp;#xA0;end&amp;#xA0;{matrix}</mtext></merror></math>" role="presentation"><span class="noError" style="display: inline-block;" aria-hidden="true">\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;C_&nbsp;{near}&nbsp;\&nbsp;alpha&nbsp;+&nbsp;C_&nbsp;{far}&nbsp;(1-&nbsp;\&nbsp;alpha)&nbsp;&amp;&amp;&nbsp;(1)&nbsp;\&nbsp;end&nbsp;{matrix}</span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><merror><mtext>\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;C_&nbsp;{near}&nbsp;\&nbsp;alpha&nbsp;+&nbsp;C_&nbsp;{far}&nbsp;(1-&nbsp;\&nbsp;alpha)&nbsp;&amp;&amp;&nbsp;(1)&nbsp;\&nbsp;end&nbsp;{matrix}</mtext></merror></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> \ begin {matrix} C = C_ {near} \ alpha + C_ {far} (1- \ alpha) && (1) \ end {matrix} </script></p><br><br>  L'ordre des fragments est important.  L'op√©rateur contient la couleur (C <sub>pr√®s</sub> ) et l'opacit√© ( <i>Œ±</i> ) d'un fragment proche et la couleur globale (C <sub>loin</sub> ) de tous les fragments derri√®re lui.  L'opacit√© peut aller de 0 √† 1;  0 signifie que l'objet est compl√®tement transparent (invisible) et 1 signifie qu'il est compl√®tement opaque. <br><br>  Pour utiliser cet op√©rateur, vous devez trier les fragments par profondeur.  Imaginez quelle mal√©diction c'est.  En r√®gle g√©n√©rale, vous devez effectuer un tri par trame.  Si vous triez des objets, vous devrez peut-√™tre traiter des surfaces de forme irr√©guli√®re qui doivent √™tre coup√©es en sections, puis les PARTIES coup√©es de ces surfaces doivent √™tre tri√©es (vous devez absolument le faire pour les surfaces qui se croisent).  Si vous triez des fragments, vous allez placer le tri r√©el dans vos shaders.  Cette m√©thode est connue sous le nom de ¬´transparence ind√©pendante de l'ordre¬ª (OIT), et elle est bas√©e sur une liste li√©e stock√©e dans la m√©moire vid√©o.  Il est presque impossible de pr√©voir la quantit√© de m√©moire √† allouer √† cette liste.  Et si vous manquez de m√©moire, vous obtenez des artefacts √† l'√©cran. <br><br>  Consid√©rez-vous chanceux si vous pouvez r√©guler le nombre d'objets transparents sur votre sc√®ne et ajuster leurs positions relatives.  Mais si vous d√©veloppez une CAO, il appartient aux utilisateurs de positionner leurs objets, il y aura donc autant d'objets qu'ils le souhaitent et leur placement sera tout √† fait arbitraire. <br><br>  Vous voyez maintenant pourquoi est-il si tentant de trouver un op√©rateur de fusion qui ne n√©cessite pas de tri pr√©alable.  Et il y a un tel op√©rateur - dans un document que j'ai mentionn√© au d√©but.  En fait, il existe plusieurs formules, mais l'une d'entre elles, les auteurs (et moi-m√™me) consid√®rent la meilleure: <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display"><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><merror><mtext>\&amp;#xA0;begin&amp;#xA0;{matrix}&amp;#xA0;C&amp;#xA0;=&amp;#xA0;{{\&amp;#xA0;sum_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;C_i&amp;#xA0;\&amp;#xA0;alpha_i}&amp;#xA0;\&amp;#xA0;over&amp;#xA0;{\&amp;#xA0;sum_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;\&amp;#xA0;alpha_i}}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;prod_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;alpha_i))&amp;#xA0;+&amp;#xA0;C_0&amp;#xA0;\&amp;#xA0;prod_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;alpha_i)&amp;#xA0;&amp;amp;&amp;amp;&amp;#xA0;(2)&amp;#xA0;\&amp;#xA0;end&amp;#xA0;{matrix}</mtext></merror></math>" role="presentation"><span class="noError" style="display: inline-block;" aria-hidden="true">\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;{{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;C_i&nbsp;\&nbsp;alpha_i}&nbsp;\&nbsp;over&nbsp;{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;\&nbsp;alpha_i}}&nbsp;(1-&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i))&nbsp;+&nbsp;C_0&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i)&nbsp;&amp;&amp;&nbsp;(2)&nbsp;\&nbsp;end&nbsp;{matrix}</span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><merror><mtext>\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;{{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;C_i&nbsp;\&nbsp;alpha_i}&nbsp;\&nbsp;over&nbsp;{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;\&nbsp;alpha_i}}&nbsp;(1-&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i))&nbsp;+&nbsp;C_0&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i)&nbsp;&amp;&amp;&nbsp;(2)&nbsp;\&nbsp;end&nbsp;{matrix}</mtext></merror></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-2"> \ begin {matrix} C = {{\ sum_ {i = 1} ^ {n} C_i \ alpha_i} \ over {\ sum_ {i = 1} ^ {n} \ alpha_i}} (1- \ prod_ {i = 1} ^ {n} (1- \ alpha_i)) + C_0 \ prod_ {i = 1} ^ {n} (1- \ alpha_i) && (2) \ end {matrix} </script></p><br><br><img src="https://habrastorage.org/webt/65/b9/oz/65b9ozbni1afvlupqfso9uve2ey.png" width="1000"><br><br>  Sur la capture d'√©cran, on peut voir des groupes de triangles transparents dispos√©s sur quatre couches de profondeur.  Sur le c√¥t√© gauche, ils ont √©t√© rendus avec WBOIT, et sur le c√¥t√© droit, le m√©lange classique d√©pendant de l'ordre - avec la formule (1) - a √©t√© utilis√© (je l'appellerai d√©sormais CODB). <br><br>  Avant de pouvoir commencer √† rendre des objets transparents, nous devons rendre tous les objets non transparents.  Apr√®s cela, les objets transparents sont rendus avec le test de profondeur mais sans √©crire quoi que ce soit dans un tampon de profondeur (cela peut √™tre fait de cette fa√ßon: <code>glEnable(GL_DEPTH_TEST); glDepthMask(GL_FALSE);</code> ). <br><br>  Maintenant, regardons ce qui se passe √† un moment donn√© avec les coordonn√©es de l'espace √©cran (x, y).  Les fragments transparents - qui se trouvent √™tre plus proches que ceux non transparents - r√©ussissent le test de profondeur, peu importe la fa√ßon dont ils sont plac√©s par rapport aux fragments transparents d√©j√† rendus.  Ces fragments transparents qui tombent derri√®re le non transparent - eh bien, ils ne passent pas le test de profondeur et sont jet√©s, naturellement. <br><br>  C <sub>0</sub> dans la formule (2) est la couleur du fragment non transparent rendu en ce point (x, y).  Nous avons au total n fragments transparents qui ont r√©ussi le test de profondeur, et ils ont des indices i ‚àà [1, n].  C <sub>i</sub> est la couleur du i√®me fragment transparent et <i>Œ± <sub>i</sub></i> est son opacit√©. <br><br>  La formule (2) est l√©g√®rement similaire √† la formule (1), bien qu'elle ne soit pas tr√®s √©vidente.  Remplacer <img src="https://habrastorage.org/webt/xz/w1/z8/xzw1z8f-nsnfuokbqssbhic6tpw.png" width="60">  avec C <sub>pr√®s</sub> , C <sub>0</sub> avec C <sub>loin</sub> et <img src="https://habrastorage.org/webt/li/tu/em/lituem-w98r3gl7cee5184y6b7q.png" width="100">  avec <i>Œ±</i> et la formule (1) sera exactement ce que vous obtiendrez.  En effet, <img src="https://habrastorage.org/webt/xz/w1/z8/xzw1z8f-nsnfuokbqssbhic6tpw.png" width="60">  est la <b>moyenne arithm√©tique pond√©r√©e</b> des couleurs de tous les fragments transparents (il existe une formule similaire en m√©canique pour le "centre de masse"), et elle ira pour la couleur du fragment <sub>proche</sub> C <sub>proche</sub> .  C <sub>0</sub> est la couleur du fragment non transparent derri√®re tous ces fragments transparents pour lesquels nous calculons la moyenne arithm√©tique pond√©r√©e.  En d'autres termes, nous rempla√ßons tous les fragments transparents par un fragment "moyenne pond√©r√©e" et utilisons l'op√©rateur de m√©lange standard - formule (1).  Maintenant, il existe une formule un peu sophistiqu√©e pour <i>Œ±</i> , et nous n'avons pas encore compris sa signification. <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mtext>&amp;#xA0;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><mi>a</mi><mo>=</mo><mn>1</mn><mo>&amp;#x2212;</mo><mtext>&amp;#xA0;</mtext><mi>p</mi><mi>r</mi><mi>o</mi><msubsup><mi>d</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>n</mi></mrow></msubsup><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo>&amp;#x2212;</mo><mtext>&amp;#xA0;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><msub><mi>a</mi><mi>i</mi></msub><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="34.233ex" height="2.901ex" viewBox="0 -832 14738.9 1249" role="img" focusable="false" style="vertical-align: -0.969ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjMkP-OXydA4W7oA-XbQw1NkT2aRw#MJMATHI-61" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjMkP-OXydA4W7oA-XbQw1NkT2aRw#MJMATHI-6C" x="779" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjMkP-OXydA4W7oA-XbQw1NkT2aRw#MJMATHI-70" x="1078" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjMkP-OXydA4W7oA-XbQw1NkT2aRw#MJMATHI-68" x="1581" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjMkP-OXydA4W7oA-XbQw1NkT2aRw#MJMATHI-61" x="2158" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjMkP-OXydA4W7oA-XbQw1NkT2aRw#MJMAIN-3D" x="2965" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjMkP-OXydA4W7oA-XbQw1NkT2aRw#MJMAIN-31" x="4021" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjMkP-OXydA4W7oA-XbQw1NkT2aRw#MJMAIN-2212" x="4744" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjMkP-OXydA4W7oA-XbQw1NkT2aRw#MJMATHI-70" x="5995" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjMkP-OXydA4W7oA-XbQw1NkT2aRw#MJMATHI-72" x="6498" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjMkP-OXydA4W7oA-XbQw1NkT2aRw#MJMATHI-6F" x="6950" y="0"></use><g transform="translate(7435,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjMkP-OXydA4W7oA-XbQw1NkT2aRw#MJMATHI-64" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjMkP-OXydA4W7oA-XbQw1NkT2aRw#MJMATHI-6E" x="741" y="499"></use><g transform="translate(520,-308)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjMkP-OXydA4W7oA-XbQw1NkT2aRw#MJMATHI-69" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjMkP-OXydA4W7oA-XbQw1NkT2aRw#MJMAIN-3D" x="345" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjMkP-OXydA4W7oA-XbQw1NkT2aRw#MJMAIN-31" x="1124" y="0"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjMkP-OXydA4W7oA-XbQw1NkT2aRw#MJMAIN-28" x="9204" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjMkP-OXydA4W7oA-XbQw1NkT2aRw#MJMAIN-31" x="9594" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjMkP-OXydA4W7oA-XbQw1NkT2aRw#MJMAIN-2212" x="10316" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjMkP-OXydA4W7oA-XbQw1NkT2aRw#MJMATHI-61" x="11567" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjMkP-OXydA4W7oA-XbQw1NkT2aRw#MJMATHI-6C" x="12097" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjMkP-OXydA4W7oA-XbQw1NkT2aRw#MJMATHI-70" x="12395" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjMkP-OXydA4W7oA-XbQw1NkT2aRw#MJMATHI-68" x="12899" y="0"></use><g transform="translate(13475,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjMkP-OXydA4W7oA-XbQw1NkT2aRw#MJMATHI-61" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjMkP-OXydA4W7oA-XbQw1NkT2aRw#MJMATHI-69" x="748" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjMkP-OXydA4W7oA-XbQw1NkT2aRw#MJMAIN-29" x="14349" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>&nbsp;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><mi>a</mi><mo>=</mo><mn>1</mn><mo>‚àí</mo><mtext>&nbsp;</mtext><mi>p</mi><mi>r</mi><mi>o</mi><msubsup><mi>d</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></msubsup><mo stretchy="false">(</mo><mn>1</mn><mo>‚àí</mo><mtext>&nbsp;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">)</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-3"> \ alpha = 1- \ prod_ {i = 1} ^ {n} (1- \ alpha_i) </script></p><br>  C'est une fonction scalaire dans un espace √† n dimensions.  Tous les <i>Œ± <sub>i</sub></i> sont contenus dans [0, 1], donc sa d√©riv√©e partielle par rapport √† l'un des <i>Œ± <sub>i</sub></i> est une constante non n√©gative.  Cela signifie que l'opacit√© du fragment "moyenne pond√©r√©e" augmente lorsque vous augmentez l'opacit√© de l'un des fragments transparents, ce qui est exactement ce que nous voulons.  De plus, il augmente lin√©airement. <br><br>  Si l'opacit√© d'un fragment est √©gale √† 0, elle est compl√®tement invisible.  Cela ne contribue pas du tout √† la couleur r√©sultante. <br><br>  Si au moins un fragment a une opacit√© de 1, alors <i>Œ±</i> vaut √©galement 1.  Autrement dit, un fragment non transparent devient invisible, ce qui est bien.  Le probl√®me est que les autres fragments transparents (derri√®re ce fragment avec opacit√© = 1) peuvent toujours √™tre vus √† travers lui et contribuent √† la couleur r√©sultante: <br><br><img src="https://habrastorage.org/webt/3s/lm/3y/3slm3yxglf43xno7dyqu8g7ua-o.png" width="300"><br><br>  Le triangle orange sur cette image se trouve en haut, le triangle vert en dessous et en dessous du triangle vert se trouvent des triangles gris et cyan.  Le fond est noir.  L'opacit√© du triangle orange est de 1;  tous les autres ont une opacit√© = 0,5.  Ici, vous pouvez voir que WBOIT semble tr√®s pauvre.  Le seul endroit o√π la vraie couleur orange appara√Æt est le bord du triangle vert d√©limit√© par une ligne blanche non transparente.  Comme je viens de le mentionner, un fragment non transparent est invisible s'il a un fragment transparent au-dessus avec une opacit√© = 1. <br><br>  On le voit mieux sur la photo suivante: <br><br><img src="https://habrastorage.org/webt/-3/dc/ey/-3dcey8p1s2ynmgq9oyatw1ojma.png" width="300"><br><br>  L'opacit√© du triangle orange est 1, le triangle vert avec la transparence d√©sactiv√©e est juste rendu avec des objets non transparents.  Il ressemble √† la couleur VERTE du triangle derri√®re le tamis √† travers le triangle sup√©rieur en tant que couleur ORANGE. <br><br>  Le moyen le plus simple de rendre votre image plausible est de ne pas d√©finir une opacit√© √©lev√©e pour vos objets.  Dans un projet o√π j'utilise cette technique, je ne fixe pas d'opacit√© sup√©rieure √† 0,5.  Il s'agit de CAD 3D o√π les objets sont dessin√©s sch√©matiquement et n'ont pas besoin d'√™tre tr√®s r√©alistes, cette restriction est donc acceptable. <br><br>  Avec de faibles opacit√©s, les images gauche et droite sont tr√®s similaires: <br><br><img src="https://habrastorage.org/webt/hz/pc/ud/hzpcud9vuojz7vk0rsofbidyumy.png" width="1000"><br><br>  Et ils diff√®rent sensiblement avec des opacit√©s √©lev√©es: <br><br><img src="https://habrastorage.org/webt/iv/hq/_l/ivhq_lqrb8ofbxie323mtwpfg-q.png" width="1000"><br><br>  Voici un poly√®dre transparent: <br><br><img src="https://habrastorage.org/webt/nm/oi/6u/nmoi6u1xvycmbwvt50z6pinofbg.png" width="500"><br><img src="https://habrastorage.org/webt/ej/9u/p1/ej9up1muignigkr73kn2mi5byrs.png" width="500"><br><br>  Il a des faces lat√©rales orange et des faces horizontales vertes, ce qui n'est malheureusement pas √©vident, ce qui signifie que l'image ne semble pas cr√©dible.  Partout o√π un visage orange se trouve au-dessus, la couleur doit √™tre plus orange, et l√† o√π elle se trouve derri√®re un visage vert, la couleur doit √™tre plus verte.  Mieux vaut les dessiner avec une seule couleur: <br><br><img src="https://habrastorage.org/webt/a2/eg/bf/a2egbfdzwlwmaltuc4lpyna45gs.png" width="500"><br><br><h3>  Injecter de la profondeur dans l'op√©rateur de m√©lange </h3><br>  Afin de compenser le manque de tri en profondeur, les auteurs du document JCGT susmentionn√© ont propos√© plusieurs fa√ßons d'injecter de la profondeur dans la formule (2).  Cela complique la mise en ≈ìuvre et rend le r√©sultat moins pr√©visible.  Pour que cela fonctionne, les param√®tres de fusion doivent √™tre ajust√©s en fonction d'une sc√®ne 3D sp√©cifique.  Je n'ai pas approfondi ce sujet, donc si vous voulez en savoir plus, lisez l'article. <br><br>  Les auteurs affirment que parfois WBOIT est capable de faire quelque chose que CODB ne peut pas faire.  Par exemple, envisagez de dessiner une fum√©e comme un syst√®me de particules avec deux particules: la fum√©e sombre et la fum√©e plus claire.  Lorsque les particules se d√©placent et qu'une particule en traverse une autre, leur couleur m√©lang√©e passe instantan√©ment de l'obscurit√© √† la lumi√®re, ce qui n'est pas bon.  L'op√©rateur WBOIT avec profondeur produit un r√©sultat plus pr√©f√©rable avec une transition en douceur de la couleur.  Les cheveux ou la fourrure mod√©lis√©s comme un ensemble de tubes fins ont la m√™me propri√©t√©. <br><br><h3>  Le code </h3><br>  Passons maintenant √† l'impl√©mentation OpenGL de la formule (2).  Vous pouvez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">voir l'impl√©mentation</a> sur GitHub.  C'est une application bas√©e sur Qt, et les images que vous voyez ici en sont principalement issues. <br><br>  Si vous √™tes nouveau dans le rendu transparent, voici un bon mat√©riel d'entr√©e de gamme: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Apprenez OpenGL.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">M√©lange</a> <br><br>  Je recommande de le lire avant de poursuivre avec ce post. <br><br>  Afin d'√©valuer la formule (2), nous avons besoin de 2 tampons d'image suppl√©mentaires, de 3 textures multisamles et d'un tampon de rendu de profondeur.  Les objets non transparents seront rendus dans la premi√®re texture, colorTextureNT.  Son type est GL_RGB10_A2.  La deuxi√®me texture (colorTexture) sera de type GL_RGBA16F.  Les trois premiers composants de colorTexture contiendront cette partie de la formule (2): <img src="https://habrastorage.org/webt/9p/7i/vm/9p7ivmikwxs8ltenmceiumeogoo.png" width="70">  et <img src="https://habrastorage.org/webt/i2/bg/uc/i2bguc_jhzovzvn6ybqfkkuds4q.png" width="50">  sera √©crit dans le quatri√®me composant.  La derni√®re texture, alphaTexture, de type GL_R16 contiendra <img src="https://habrastorage.org/webt/ma/si/f0/masif074trzop-clpwvbwtfj92i.png" width="90">  . <br><br>  Tout d'abord, nous devons cr√©er tous ces objets et obtenir leurs identifiants √† partir d'OpenGL: <br><pre> <code class="cpp hljs"> f-&gt;glGenFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebufferNT ); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTextureNT ); f-&gt;glGenRenderbuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;depthRenderbuffer); f-&gt;glGenFramebuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebuffer ); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTexture); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;alphaTexture);</code> </pre> <br>  J'utilise Qt framewok, comme vous vous en souvenez, et tous les appels √† OpenGL sont effectu√©s √† partir d'un objet de type QOpenGLFunctions_4_5_Core, pour lequel j'utilise toujours le nom f. <br><br>  L'allocation de m√©moire vient ensuite: <br><pre> <code class="cpp hljs"> f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_RGB16F, w, h, GL_TRUE ); f-&gt;glBindRenderbuffer(GL_RENDERBUFFER, depthRenderbuffer); f-&gt;glRenderbufferStorageMultisample( GL_RENDERBUFFER, numOfSamples, GL_DEPTH_COMPONENT, w, h ); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTexture); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_RGBA16F, w, h, GL_TRUE ); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, alphaTexture); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_R16F, w, h, GL_TRUE );</code> </pre> <br>  Configuration de Framebuffer: <br><pre> <code class="cpp hljs"> f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebufferNT); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT, <span class="hljs-number"><span class="hljs-number">0</span></span> ); f-&gt;glFramebufferRenderbuffer( GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRenderbuffer ); f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, colorTexture, <span class="hljs-number"><span class="hljs-number">0</span></span> ); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, GL_TEXTURE_2D_MULTISAMPLE, alphaTexture, <span class="hljs-number"><span class="hljs-number">0</span></span> ); GLenum attachments[<span class="hljs-number"><span class="hljs-number">2</span></span>] = {GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1}; f-&gt;glDrawBuffers(<span class="hljs-number"><span class="hljs-number">2</span></span>, attachments); f-&gt;glFramebufferRenderbuffer( GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRenderbuffer );</code> </pre> <br>  Lors de la deuxi√®me passe de rendu, la sortie du fragment shader se fera dans deux textures, qui doivent √™tre explicitement sp√©cifi√©es avec glDrawBuffers. <br>  La plupart de ce code est ex√©cut√© une seule fois, au d√©marrage du programme.  Le code d'allocation de texture et de m√©moire tampon est ex√©cut√© √† chaque fois que la taille de la fen√™tre est modifi√©e.  Nous passons maintenant au code ex√©cut√© √† chaque mise √† jour du contenu de la fen√™tre. <br><pre> <code class="cpp hljs"> f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebufferNT); <span class="hljs-comment"><span class="hljs-comment">// ... rendering non-transparent objects ... // ....... // done! (you didn't expect me to explain how do I render primitives in OpenGL, did you? // It's not relevant for this topic</span></span></code> </pre> <br>  Nous venons de rendre tous les objets non transparents dans colorTextureNT et d'√©crire les profondeurs dans le rendu du tampon.  Avant d'utiliser ce m√™me rendu de m√©moire tampon lors de la prochaine passe de rendu, nous devons nous assurer que toutes les op√©rations d'√©criture dans le rendu de m√©moire tampon de profondeur √† partir d'objets non transparents sont termin√©es.  Il est r√©alis√© avec GL_FRAMEBUFFER_BARRIER_BIT.  Une fois les objets transparents rendus, nous allons appeler la fonction ApplyTextures () qui effectuera la passe de rendu finale o√π le fragment shader √©chantillonnera √† partir des textures colorTextureNT, colorTexture et alphaTexture afin d'appliquer la formule (2).  Les textures doivent √™tre pr√™tes √† ce moment, nous utilisons donc GL_TEXTURE_FETCH_BARRIER_BIT avant d'appeler ApplyTextures (). <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> GLfloat clearColor[<span class="hljs-number"><span class="hljs-number">4</span></span>] = { <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> GLfloat clearAlpha = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); f-&gt;glClearBufferfv(GL_COLOR, <span class="hljs-number"><span class="hljs-number">0</span></span>, clearColor); f-&gt;glClearBufferfv(GL_COLOR, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;clearAlpha); f-&gt;glMemoryBarrier(GL_FRAMEBUFFER_BARRIER_BIT); PrepareToTransparentRendering(); { <span class="hljs-comment"><span class="hljs-comment">// ... rendering transparent objects ... } CleanupAfterTransparentRendering(); f-&gt;glMemoryBarrier(GL_TEXTURE_FETCH_BARRIER_BIT); f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, defaultFBO); ApplyTextures();</span></span></code> </pre> <br>  defaultFBO est un framebuffer que nous utilisons pour afficher l'image √† l'√©cran.  Dans la plupart des cas, c'est 0, mais dans Qt c'est QOpenGLWidget :: defaultFramebufferObject (). <br><br>  Dans chaque invocation d'un shader de fragment, nous aurons acc√®s √† la couleur et √† l'opacit√© du fragment actuel.  Mais dans colorTexture doit appara√Ætre une somme (et dans alphaTexture un produit) de ces entit√©s.  Pour cela, nous utiliserons le m√©lange.  De plus, √©tant donn√© que pour la premi√®re texture nous calculons une somme tandis que pour la seconde nous calculons un produit, nous devons fournir diff√©rents param√®tres de fusion (glBlendFunc et glBlendEquation) pour chaque pi√®ce jointe. <br><br>  Voici le contenu de la fonction PrepareToTransparentRendering (): <br><pre> <code class="cpp hljs"> f-&gt;glEnable(GL_DEPTH_TEST); f-&gt;glDepthMask(GL_FALSE); f-&gt;glDepthFunc(GL_LEQUAL); f-&gt;glDisable(GL_CULL_FACE); f-&gt;glEnable(GL_MULTISAMPLE); f-&gt;glEnable(GL_BLEND); f-&gt;glBlendFunci(<span class="hljs-number"><span class="hljs-number">0</span></span>, GL_ONE, GL_ONE); f-&gt;glBlendEquationi(<span class="hljs-number"><span class="hljs-number">0</span></span>, GL_FUNC_ADD); f-&gt;glBlendFunci(<span class="hljs-number"><span class="hljs-number">1</span></span>, GL_DST_COLOR, GL_ZERO); f-&gt;glBlendEquationi(<span class="hljs-number"><span class="hljs-number">1</span></span>, GL_FUNC_ADD);</code> </pre> <br><br>  Et le contenu de la fonction CleanupAfterTransparentRendering (): <br><pre> <code class="cpp hljs"> f-&gt;glDepthMask(GL_TRUE); f-&gt;glDisable(GL_BLEND);</code> </pre> <br>  Dans mon fragment shader, w repr√©sente l'opacit√©.  Le produit de la couleur et w - et w lui-m√™me - ira au premier param√®tre de sortie, et 1 - w ira au deuxi√®me param√®tre de sortie.  Un qualificatif de disposition doit √™tre d√©fini pour chaque param√®tre de sortie sous la forme de "location = X", o√π X est un index d'un √©l√©ment dans le tableau des pi√®ces jointes - celui que nous avons donn√© √† la fonction glDrawBuffers.  Pour √™tre pr√©cis, le param√®tre de sortie avec location = 0 va √† la texture li√©e √† GL_COLOR_ATTACHMENT1, et le param√®tre avec location = 1 va √† la texture li√©e √† GL_COLOR_ATTACHMENT1.  Ces m√™mes nombres sont utilis√©s dans les fonctions glBlendFunci et glBlendEquationi pour indiquer la couleur d'attache pour laquelle nous d√©finissons les param√®tres de fusion. <br><br>  Le fragment shader: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core in vec3 color; layout (location = 0) out vec4 outData; layout (location = 1) out float alpha; layout (location = 2) uniform float w; void main() { outData = vec4(w * color, w); alpha = 1 - w; }</span></span></code> </pre> <br>  Dans la fonction ApplyTextures (), nous dessinons simplement un rectangle couvrant toute la fen√™tre.  Le fragment shader √©chantillonne les donn√©es des trois textures en utilisant les coords d'espace d'√©cran actuels comme coords de texture et un index d'√©chantillonnage actuel (gl_SampleID) comme index d'√©chantillonnage pour les textures multi-√©chantillons.  La pr√©sence de la variable gl_SampleID dans le code du shader oblige le syst√®me √† invoquer le fragment shader une fois par √©chantillon (alors qu'il est normalement invoqu√© une fois par pixel, en √©crivant sa sortie sur tous les √©chantillons appartenant √† une primitive). <br><br>  Le vertex shader est simple: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core const vec2 p[4] = vec2[4]( vec2(-1, -1), vec2( 1, -1), vec2( 1, 1), vec2(-1, 1) ); void main() { gl_Position = vec4(p[gl_VertexID], 0, 1); }</span></span></code> </pre> <br><br>  Le fragment shader: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core out vec4 outColor; layout (location = 0) uniform sampler2DMS colorTextureNT; layout (location = 1) uniform sampler2DMS colorTexture; layout (location = 2) uniform sampler2DMS alphaTexture; void main() { ivec2 upos = ivec2(gl_FragCoord.xy); vec4 cc = texelFetch(colorTexture, upos, gl_SampleID); vec3 sumOfColors = cc.rgb; float sumOfWeights = cc.a; vec3 colorNT = texelFetch(colorTextureNT, upos, gl_SampleID).rgb; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (sumOfWeights == 0) { outColor = vec4(colorNT, 1.0); return; } float alpha = 1 - texelFetch(alphaTexture, upos, gl_SampleID).r; colorNT = sumOfColors / sumOfWeights * alpha + colorNT * (1 - alpha); outColor = vec4(colorNT, 1.0); }</span></span></code> </pre> <br>  Et enfin - Fonction ApplyTextures (): <br><pre> <code class="cpp hljs"> f-&gt;glActiveTexture(GL_TEXTURE0); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); f-&gt;glActiveTexture(GL_TEXTURE1); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTexture); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); f-&gt;glActiveTexture(GL_TEXTURE2); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, alphaTexture); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); f-&gt;glEnable(GL_MULTISAMPLE); f-&gt;glDisable(GL_DEPTH_TEST); f-&gt;glDrawArrays(GL_TRIANGLE_FAN, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre> <br><br>  Au final, les ressources OpenGL doivent √™tre lib√©r√©es.  Je le fais dans le destructeur de mon widget OpenGL: <br><pre> <code class="cpp hljs"> f-&gt;glDeleteFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebufferNT); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTextureNT); f-&gt;glDeleteRenderbuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;depthRenderbuffer); f-&gt;glDeleteFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebuffer); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTexture); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;alphaTexture);</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr457292/">https://habr.com/ru/post/fr457292/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr457282/index.html">"La mort de Dieu" ou l'effondrement des lois g√©n√©ralement accept√©es pour la constitution d'√©quipes informatiques et la cr√©ation de syst√®mes informatiques au 21e si√®cle</a></li>
<li><a href="../fr457284/index.html">WBOIT en OpenGL: transparence sans tri</a></li>
<li><a href="../fr457286/index.html">La solution des t√¢ches WorldSkills du module R√©seau dans la comp√©tence de "CCA". Partie 1 - Configuration de base</a></li>
<li><a href="../fr457288/index.html">Station de travail cryptographique bas√©e sur les jetons PKCS # 11. Signature √©lectronique. 2e partie</a></li>
<li><a href="../fr457290/index.html">Conf√©rence DEFCON 25. Garry Kasparov. "La derni√®re bataille du cerveau." 2e partie</a></li>
<li><a href="../fr457294/index.html">"Live high" ou mon histoire de la procrastination √† l'auto-d√©veloppement</a></li>
<li><a href="../fr457298/index.html">Frontend Weekly Digest (17-23 juin 2019)</a></li>
<li><a href="../fr457300/index.html">Le condens√© de mati√®res fra√Æches du monde du front-end de la derni√®re semaine n ¬∞ 370 (17-23 juin 2019)</a></li>
<li><a href="../fr457302/index.html">10 fonctionnalit√©s pour acc√©l√©rer l'analyse des donn√©es en Python</a></li>
<li><a href="../fr457304/index.html">Services de statistiques pour les applications mobiles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>