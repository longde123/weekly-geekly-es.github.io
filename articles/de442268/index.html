<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëñ üßóüèª üë®üèΩ‚Äçüè≠ AsyncIO Micropython: Synchronisationsmethoden in der asynchronen Programmierung üë©üèæ‚Äçüåæ üõë üôåüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bei der sequentiellen Programmierung sto√üe ich st√§ndig auf den offensichtlichen Wunsch, das Programm nicht zu einem Zeitpunkt anzuhalten, an dem das Z...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>AsyncIO Micropython: Synchronisationsmethoden in der asynchronen Programmierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442268/">  Bei der sequentiellen Programmierung sto√üe ich st√§ndig auf den offensichtlichen Wunsch, das Programm nicht zu einem Zeitpunkt anzuhalten, an dem das Ziel einzelner Aufgaben (Prozesse) regelm√§√üige Aktionen sind - beispielsweise das Abrufen von Sensorwerten oder das √úbertragen von Daten nach einem Zeitplan an einen Server oder das Eingeben / Ausgeben einer gro√üen Datenmenge.  Am einfachsten ist es nat√ºrlich, auf den Abschluss des periodischen Ereignisses zu warten und dann langsam andere Aufgaben auszuf√ºhren. <br><a name="habracut"></a><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: do_ext_proc_before() do_internal_proc() sleep(<span class="hljs-number"><span class="hljs-number">5</span></span>) do_ext_proc_after()</code> </pre> <cut><br>  Sie k√∂nnen 'sleep ()' abbrechen und die √úberpr√ºfung auf einige Bedingungen in der Schleife aktivieren, sodass Sie die Hauptschleife nicht mindestens bis zum Auftreten eines periodischen Ereignisses verz√∂gern k√∂nnen: <br><br><pre> <code class="python hljs"> start = time() set_timer(start,wait=<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-comment"><span class="hljs-comment">#   set_timeout(start,wait_to=7) #   set_irq(alarm) #    while True: curTime = time() do_ext_proc_before() if timer(curTime) or timeout(curTime) or alarm: # if all events crazy start simultaneously - reset all start = time() set_timer(start,wait=5) #   set_timeout(start,wait_to=7) #   set_irq(alarm) #    do_internal_proc() do_ext_proc_after()</span></span></code> </pre><br>  Bei der asynchronen Programmierung wird jede Aufgabe zu einem unabh√§ngigen Prozess und wird je nach spezifischer Implementierung parallel oder pseudo-parallel ausgef√ºhrt, wobei ein internes Verst√§ndnis der nat√ºrlichen oder k√ºnstlich festgelegten Wartebedingungen oder die Verwendung einer begrenzten Ressource, beispielsweise einer Festplatte oder eines Kommunikationskanals, verwendet wird. <br><br><pre> <code class="python hljs"> setTask(do_ext_proc_before()) setTask(do_internal_proc(),timer=<span class="hljs-number"><span class="hljs-number">5</span></span>,timeout=<span class="hljs-number"><span class="hljs-number">7</span></span>,alarm_handler=alarm) setTask(do_ext_proc_after()) runTasks()</code> </pre><br>  Jetzt tritt ein Problem auf, das bei der sequentiellen Programmierung nicht vorhanden ist - was ist zu tun, wenn einige Prozesse mit ihren asynchronen synchronisiert werden m√ºssen? <br>  tun?  Wenn Sie beispielsweise Daten von Sensoren empfangen haben, starten Sie den Prozess des Sendens von Daten an einen Server oder reagieren Sie auf einen Notfall.  Dar√ºber hinaus wird bei der asynchronen Programmierung die Organisation der asynchronen Eingabe / Ausgabe im Sprachstandard organisch gel√∂st, und andere Situationen werden in Bibliotheken gel√∂st. <br><br>  Ich habe diese Frage mit der ver√∂ffentlichten erweiterten asyncio Micropython-Bibliothek untersucht <br>  Peter Hinch ( <a href="">https://github.com/peterhinch/micropython-async/blob/master/TUTORIAL.md</a> ) <br>  Die einfachste L√∂sung besteht darin, das Ereignis interessierten Prozessen zu signalisieren.  Verwenden Sie dazu die Event () -Klasse, die mehrere Module enth√§lt <br><br><pre> <code class="python hljs"> Event.Set( timeout = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, data = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> ) -    (Event = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>), ,     , Event.IsSet() - ,   ,  <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>,    <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>   Event.Wait() -   ,     - Done,Timeout,Cancel Event.Data() -  ,     Event.Clear() -   (Event = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>).</code> </pre><br>  Der Abschluss wird in der Regel von dem Prozess aufgezeichnet, der auf das Eintreten des Ereignisses wartet, z. B. der Anzeige auf dem Bildschirm oder das Speichern von Daten auf der Festplatte oder das Zeitlimit. Dann m√ºssen die Daten nicht aktualisiert oder gespeichert werden, da sie aus irgendeinem Grund nicht aktualisiert werden Aufgrund seiner Unterbrechung beim Auftreten eines anderen wichtigen Ereignisses, z. B. beim √úbergang in den Ruhemodus oder beim Neustart, m√ºssen m√∂glicherweise alle anstehenden Prozesse durch Zur√ºcksetzen der entsprechenden Ereignisse freigegeben werden. <br><br>  Es sollte beachtet werden, dass es ratsam ist, Event.Clear () mit nur einem Prozess zu erstellen, wenn dies nicht dem angegebenen Algorithmus widerspricht.  Wenn andernfalls mehrere Prozesse auf das Ereignis Event.Set () warten, wird davon ausgegangen, dass Event.Clear () von einem der interessierten Prozesse ausgef√ºhrt wird, wobei nur sichergestellt wird, dass alle interessierten Prozesse auf das Ereignis reagiert haben.  Dies verkompliziert die Entscheidungslogik bei Verwendung der Ereignisklasse, wenn mehrere Prozesse auf ein Ereignis warten.  Diese Situation wird gel√∂st, indem eine bestimmte Anzahl von Clear () f√ºr das aufgetretene Ereignis festgelegt wird. <br><br><pre> <code class="python hljs"> Barrier.Set( quantity = <span class="hljs-number"><span class="hljs-number">1</span></span>, timeout = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, data = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> ) - quantity = <span class="hljs-number"><span class="hljs-number">1</span></span>  Event.Set() Barrier.IsSet() - ,   ,  <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>,    <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>   Barrier.Wait() -   ,     - Done,Timeout,Cancel Barrier.Data() -  ,     Barrier.qty -      Barrier.Clear() -   (Event = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>),        Barrier.quantity  ,    ,    </code> </pre><br>  Gleichzeitig wird keine Buchhaltung gef√ºhrt - welcher spezifische Prozess hat bereits reagiert und welcher noch nicht, was zu dem Problem der erneuten Reaktion auf das Ereignis f√ºhren kann, wenn dies f√ºr einen bestimmten Algorithmus wesentlich ist.  Wenn Sie anstelle von Barrier.quantity eine Liste mit Namen interessierter Prozesse √ºbergeben, kann dieser Konflikt vermieden werden.  Au√üerdem k√∂nnen Sie im Falle eines Timeouts oder einer Unterbrechung des Ereignisses feststellen, welche spezifischen ausstehenden Prozesse noch nicht funktioniert haben.  All dies gilt f√ºr eine Situation, in der ein oder mehrere Prozesse auf das Eintreten eines bestimmten Ereignisses warten, oder f√ºr eine Eins-zu-Viele-Situation.  Dies tritt auf, wenn der Prozess oder die Prozesse do_ext_proc_after () w√§hrend der sequentiellen Programmierung erst nach Abschluss von do_internal_proc () ausgef√ºhrt werden.  Zum besseren Verst√§ndnis werden wir die vorhandene Event-Klasse und Barrier-Klasse in die neue EEvent-Klasse erweitern und sie oder die von ihr generierten Objekte global machen.  Hier ist "Ersteller" der Name oder die Liste der Namen von Prozessen, die das Ereignis ausl√∂sen oder die Ressource entsperren. "Ordner" ist der Name oder die Liste der Namen von Prozessen, die auf das Ereignis warten oder die Ressource entsperren <br><br><pre> <code class="python hljs"> EEvent.Set (creators, folowers, timeout = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, data = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> ) -  <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>,        EEvent.IsSet( procName ) - procName -   ID   EEvent.Wait( procName ) EEvent.Clear( procName ) EEvent.Folowers() -    ,      . Barrier.qty = len(EEvent.List()) EEvent.Creators() -   ,    </code> </pre><br>  Mit den Modulen der EEvent-Klasse k√∂nnen wir die L√∂sung des zuvor diskutierten Problems beschreiben. <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_internal_proc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... EEvent.Set (<span class="hljs-string"><span class="hljs-string">'p_Creator'</span></span>,(<span class="hljs-string"><span class="hljs-string">'p_Folwer1'</span></span>,<span class="hljs-string"><span class="hljs-string">'p_Folwer2'</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># exec 'p_Folwer1','p_Folwer2' after event is come in 'p_Creator' ... def do_ext_proc_after1() ... EEvent.Wait('p_Creator') ... EEvent.Clear('p_Folwer1') def do_ext_proc_after1() ... EEvent.Wait('p_Creator') ... EEvent.Clear('p_Folwer2')</span></span></code> </pre><br>  Stellen Sie sich die umgekehrte Situation vor - wenn ein Prozess auf den Abschluss mehrerer Ereignisse wartet oder eine Situation mit vielen zu einem.  Mit anderen Worten, wenn die Ausf√ºhrung von do_internal_proc () erst nach der Ausf√ºhrung von do_ext_proc_before () erfolgen kann. Im Extremfall, wenn ein Prozess auf den Abschluss / das Auftreten eines Ereignisses wartet, kann die Aufgabe mithilfe der Ereignisklasse gel√∂st werden.  Wenn der Abschluss mehrerer Ereignisse erwartet wird, z. B. erst nachdem die empfangenen Daten angezeigt und an den Server gesendet und auf der Festplatte gespeichert wurden, muss jeder ausgef√ºhrte Prozess seine Teilnahme am erwarteten Ereignis herstellen und warten, bis alle Prozesse abgeschlossen sind. <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_ext_proc_before1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> ... </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EEvent</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'p_Creator1'</span></span></span></span><span class="hljs-function"><span class="hljs-params">,</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'p_Folwer'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> ... </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_ext_proc_before2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> ... </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EEvent</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'p_Creator2'</span></span></span></span><span class="hljs-function"><span class="hljs-params">,</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'p_Folwer'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> ... </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_internal_proc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... EEvent.Wait((<span class="hljs-string"><span class="hljs-string">'p_Creator1'</span></span>,<span class="hljs-string"><span class="hljs-string">'p_Creator2'</span></span>)) ... EEvent.Clear(<span class="hljs-string"><span class="hljs-string">'p_Folwer'</span></span>)</code> </pre><br>  Ein weiterer wichtiger Aspekt der asynchronen Programmierung ist die gemeinsame Nutzung einer begrenzten Ressource.  Beispielsweise sollte die Datenaktualisierung nur von einem Prozess durchgef√ºhrt werden. Der Rest der Prozesse, die eine √§hnliche Aktion beanspruchen, muss sich in der Warteschlange befinden oder warten, bis die Daten aktualisiert werden.  Gleichzeitig ist es m√∂glich, dass das Lesen von Daten zur Anzeige oder Weiterleitung nicht kritisch ist.  Daher ist es notwendig, die Liste der konkurrierenden Prozesse zu kennen, wenn relevante Ereignisse organisiert werden. <br><br>  Im asynchronen Programmierstandard wird diese Aufgabe durch Lock-Class-Module gel√∂st.  Im allgemeinen Fall kann das Problem auch √§hnlich wie in der Eins-zu-Viele-Situation gel√∂st werden. <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_internal_proc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># lock activity all 'followers' in list ... EEvent.Set ('p_Creator',('p_Folwer1','p_Folwer2')) # exec 'p_Folwer1','p_Folwer2' after event is come in 'p_Creator' ... def do_ext_proc_after1() ... EEvent.Wait('p_Creator') # waiting for recourse releale if ( EEvent.Set ('p_Folwer1','p_Folwer2')): # lock resource 'p_Folower1' now is 'p_Creator' ... else: EEvent.Wait('p_Folower2') # continue waiting for recourse releale ... EEvent.Clear('p_Folwer1') # releafe recourse def do_ext_proc_after1() ... EEvent.Wait('p_Creator') if ( EEvent.Set ('p_Folwer2','p_Folwer1')): # lock resource 'p_Folower2' now is 'p_Creator' ... else: EEvent.Wait('p_Folower1') # continue waiting for recourse releale ... EEvent.Clear('p_Folwer2') # releafe recourse</span></span></code> </pre><br>  Zus√§tzlich zu den in Betracht gezogenen Optionen gibt es L√∂sungen, die den Durchsatz begrenzen, Warteschlangen organisieren und die Planung von Prozessen steuern. In meiner T√§tigkeit bestand jedoch noch kein Bedarf daf√ºr und daher ein Bed√ºrfnis nach ausreichendem Verst√§ndnis f√ºr mich selbst, obwohl ich nicht ausschlie√üe, dass es elegantere oder elegantere gibt wirtschaftliche Entscheidungen. <br><br>  Abschlie√üend m√∂chte ich sagen, dass sequentielle und asynchrone Ans√§tze das gleiche Recht haben, zu existieren und die gegebenen Algorithmen erfolgreich zu implementieren.  Daher wird die Anwendung dieses oder jenes Ansatzes durch die Priorit√§ten des Erstellers bestimmt - was f√ºr ihn bei der Implementierung der gegebenen Algorithmen wichtiger ist - Transparenz und Lesbarkeit, Geschwindigkeit oder Volumen des resultierenden Codes. </cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442268/">https://habr.com/ru/post/de442268/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442258/index.html">Web Scraping f√ºr Webentwickler: eine kurze Zusammenfassung</a></li>
<li><a href="../de442260/index.html">10 Git-Befehle, die ein Entwickler kennen sollte</a></li>
<li><a href="../de442262/index.html">Geheimnis der Firmware</a></li>
<li><a href="../de442264/index.html">Beseitigung von M√∂glichkeiten zur Entf√ºhrung von Verkehr</a></li>
<li><a href="../de442266/index.html">Delta Chat - dezentraler Messenger √ºber E-Mail</a></li>
<li><a href="../de442270/index.html">5 Fehler, die beim Erstellen von 3D-Modellen f√ºr den 3D-Druck vermieden werden sollten</a></li>
<li><a href="../de442272/index.html">Go + = Paketversionierung</a></li>
<li><a href="../de442274/index.html">Dart 2. Asynchrone Programmierung: Datenstr√∂me</a></li>
<li><a href="../de442278/index.html">Kibana Benutzerhandbuch. Visualisierung. Teil 6</a></li>
<li><a href="../de442280/index.html">Maschinelles Lernen in Dodo. So starten Sie eine neue Richtung, wenn Sie Entwickler sind</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>