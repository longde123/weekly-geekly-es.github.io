<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🈲 🕔 🛕 Blockchain tanpa perantara: cara kami mengirim sekuritas ke registri terdistribusi 👁️ 👩🏻‍🎓 😀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Semua kegiatan ekonomi secara historis dibangun di atas perantara. Apa pun, bahkan transaksi sederhana antara kedua pihak disertai dengan keterlibatan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Blockchain tanpa perantara: cara kami mengirim sekuritas ke registri terdistribusi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/442692/">  Semua kegiatan ekonomi secara historis dibangun di atas perantara.  Apa pun, bahkan transaksi sederhana antara kedua pihak disertai dengan keterlibatan berbagai perantara - bank, pertukaran, lembaga kliring, dll.  Pengecualian perantara mungkin akan membuat interaksi lebih efisien.  Jadi mengapa tidak mencoba membangun infrastruktur baru yang terdesentralisasi berdasarkan blockchain, di mana peserta dalam transaksi dapat bekerja secara langsung?  Dalam posting ini, kita akan berbicara tentang bagaimana kita memulai perjalanan kita ke infrastruktur seperti itu: kita mengembangkan transaksi blockchain dan akhirnya melakukan repo - pinjaman uang yang dijamin oleh sekuritas. <br><br><img src="https://habrastorage.org/webt/5y/08/en/5y08enodezvkfd1qngslkh-pl4y.png"><br><a name="habracut"></a><br><h2>  Obligasi jangka pendek </h2><br>  Transaksi keuangan OTC pertama kami di blockchain adalah penerbitan obligasi jangka pendek dari operator seluler MTS dengan partisipasi dari National Settlement Depository (NSD).  Ini adalah semacam "bank sentral" dari semua tempat penyimpanan.  Deposit adalah perantara infrastruktur yang menyimpan catatan pemilik sekuritas dan menerbitkannya. <br><br>  Dalam transaksi itu, MTS, dengan menyebut fungsi kontrak pintar, dicatat dalam blockchain sebagai ekspresi keinginan untuk menjual sekuritas ke Sberbank, dan itu mengkonfirmasi dalam blockchain perjanjiannya dengan ketentuan-ketentuan transaksi.  Perintah balasan yang ditandatangani oleh kedua belah pihak diterima oleh NSD, yang mengeksekusi mereka dalam sistem akuntansi mereka.  Selain itu, blockchain menampilkan akun peserta transaksi dalam sekuritas dan uang. <br><br>  Dalam proyek itu, kami memilih platform <i>Hyperledger Fabric 1.1</i> open source, yang dirancang untuk membuat solusi blockchain perusahaan tertutup.  Blokir publik tidak cocok di sini, karena kita perlu memastikan privasi data.  Kami menghadapi keterbatasan seperti itu dalam pilot anjak Sberbank dengan M. Video, yang diimplementasikan pada blockchain Ethereum.  Sebaliknya, Hyperledger Fabric memungkinkan Anda untuk menempatkan semua peserta dalam transaksi di saluran khusus di mana mereka dapat bertukar informasi yang diperlukan dan memprosesnya dengan kontrak pintar berfitur lengkap. <br><br>  Kode sumber proyek obligasi MTS diunggah ke publik di GitHub.  Bahkan tanpa masuk ke dalam algoritma pekerjaan, Anda dapat memahami bahwa dalam siklus hidup transaksi, blockchain diberi peran yang agak sederhana sebagai transportasi pesanan kliring.  Di sisi lain, berdasarkan instruksi ini, saldo akun berubah - jadi dari sudut pandang logika bisnis, ini lebih menarik daripada layanan manajemen dokumen elektronik sederhana. <br><br>  Keuntungan utama dari solusi ini adalah fleksibilitas.  Skema “dua rekanan dan pendaftar” mencakup hampir semua transaksi di pasar OTC, dan dengan perubahan kecil - sebagian besar transaksi komersial pada umumnya. <br><br><h2>  REPO 1.0 </h2><br>  Dalam proyek baru di blockchain, kami memutuskan untuk menunjukkan bagaimana menerapkan perjanjian pembelian kembali dalam sistem desentralisasi - pinjaman uang terhadap sekuritas.  Biasanya, ini dan transaksi OTC lainnya melalui perantara - penyimpanan, kliring, broker. <br><br>  Dalam proyek ini, kami menandatangani perjanjian pembelian kembali antara Sberbank dan mitra asing.  Sudah menggunakan Hyperledger Fabric versi 1.2.  Dibandingkan dengan obligasi MTS, kami memiliki dua perbedaan: <br><br><ul><li>  Hanya dua peserta dalam transaksi yang terhubung ke blockchain, yang deposannya - Euroclear dan Clearstream - menerima semua pesanan melalui saluran transmisi data tradisional dari kantor belakang Sberbank dan rekanannya. <br></li><li>  Dalam kontrak pintar, kami menerapkan logika bisnis yang kompleks: kutipan harian dari keamanan yang berfungsi sebagai jaminan untuk pinjaman tersebut diunduh ke blockchain, dan kontrak pintar menghitung kebutuhan dan jumlah pembayaran awal, dengan mempertimbangkan perubahan biaya jaminan, diskon, kalender pertukaran keluar dan parameter lainnya.  Sinkronisasi P2P dari algoritma perhitungan antara peserta tidak dapat diperoleh tanpa registri terdistribusi.  Ini jauh lebih nyaman daripada perhitungan independen kewajiban dan jumlah masing-masing pihak - tidak ada rekonsiliasi yang memakan waktu, tidak ada konfirmasi. <br></li></ul><br>  Antara rekanan mengatur obrolan dan alur kerja di dalam saluran.  Data tentang mereka disimpan di blockchain.  Setelah setiap perubahan dalam registri terdistribusi, anggota saluran menerima peringatan email. <br><br>  "REPO 1.0" kami bekerja dari sisi hukum.  Dengan bantuan satu firma hukum besar, dilakukan analisis terhadap kasus-kasus Pengadilan Tinggi London.  Selain itu, EDS bank dan mitranya menggunakan algoritma kriptografi yang berbeda. <br><br><h3>  Bagaimana cara kerja REPO 1.0? </h3><br>  Setiap pihak dalam transaksi memiliki simpul blockchain sendiri.  Semua node terhubung satu sama lain dalam jaringan P2P.  Misalkan Anda perlu membuat kesepakatan.  Kami menggunakan kontrak pintar antara para pihak untuk transaksi, di mana instrumen keuangan sepenuhnya dijelaskan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f42/e38/b7e/f42e38b7e23eac1217952790f217a4e9.png"><br><br>  Setelah pembuatan kontrak di pihak kami, pedagang menandatanganinya.  Klien juga meninjau dan menandatangani kontrak.  Kemudian tanda tangan ditinjau dan diverifikasi.  Dalam hal ini, transaksi dilakukan berdasarkan hukum Inggris, data pada tanda tangan digital elektronik dimasukkan ke dalam dokumen GMRA.  Untuk penandatanganan oleh klien, diperlukan verifikasi bahwa orang yang berwenang hadir dalam sertifikat tanda tangan.  Akhirnya, klien menerima kontrak dan menyetujui semua persyaratan.  Anda dapat melampirkan sejumlah dokumen ke kontrak yang ditandatangani. <br><br>  Setelah itu, kontrak menerima status "sedang bekerja".  Kontrak "dalam proses" secara otomatis dihitung ulang setelah memuat harga pasar baru.  Jika ada sekuritas dalam kontrak, harga pasar diambil, Loan-To-Value (LTV) dihitung ulang - rasio jumlah pinjaman dengan nilai sekuritas dalam sekuritas.  LTV adalah salah satu istilah kunci dalam transaksi repo, artinya ditentukan dalam kontrak.  Harga saham telah naik tajam - dan LTV menjadi kurang dari yang ditunjukkan dalam GMRA (ketika datang ke hukum Inggris).  Dengan demikian, bank mengembalikan sekuritas kepada klien (sebagai salah satu opsi), karena dengan mempertimbangkan harga baru, ternyata bank memiliki keamanan yang lebih tinggi. <br><br>  Tetapi jika LTV menjadi lebih besar, maka program ini memungkinkan Anda untuk mencetak pemberitahuan agunan - pemberitahuan kepada klien tentang perlunya membuat keamanan tambahan (saham atau uang) sehingga nilai LTV kembali ke nilai awal.  Sebelumnya, pemberitahuan jaminan hanya bisa dikirim melalui pos, dokumen terpisah dibuat untuk ini, dan selama pembuatan dokumen-dokumen ini, LTV dapat berubah lagi.  Sekarang kita melihat perhitungan yang sama dengan klien online, kita dapat dengan mudah berinteraksi. <br><br>  Selain itu, program ini setiap hari menetapkan harga pembelian kembali sekuritas, dengan mempertimbangkan bunga.  Jika klien tidak setuju dengan itu ketika memuat harga pasar, ia melihat log perhitungan ulang penuh - apa, apa yang menjadi, berapa harga yang dimuat, dari mana asalnya.  Dan kemudian diskusi obrolan dimulai. <br><br><h2>  REPO 2.0 </h2><br>  Kami ingin REPO kami di blockchain agar dapat memulai pergerakan aset nyata berdasarkan logika internal kami.  Tetapi dalam REPO 1.0, karena kesulitan organisasi dengan menghubungkan deposan Barat, kami belum dapat mencapai ini.  Jadi kami memulai pilot Repo 2.0 baru.  Dia memiliki dua tujuan: <br><br><ul><li>  Transaksi harus dilakukan dengan partisipasi dua pihak dan penyimpanan, untuk memanfaatkan infrastruktur proyek obligasi MTS sebaik-baiknya. <br></li><li>  Blockchain perlu diberdayakan untuk menilai kembali agunan dan mengatur margin call yang dapat secara otomatis dieksekusi oleh penyimpanan yang terhubung ke jaringan terdistribusi. <br></li></ul><br>  NSD segera ingin terhubung ke proyek.  Untuk mendapatkan transaksi yang dimulai dalam blockchain di bidang konservatif undang-undang federal yang mengatur pasar keuangan domestik, kami bekerja dengan pengacara untuk perjanjian tambahan lima halaman dengan perjanjian manajemen dokumen elektronik.  Itu ditandatangani oleh semua pihak untuk transaksi dan NSD. <br><br>  NSD bertindak sebagai clearing house dalam transaksi ini.  Dia melakukan semua instruksi tentang pergerakan dana dan sekuritas.  Transaksi ini disimpulkan berdasarkan hukum Rusia. <br><br>  Klien menerima kontrak dengan tanda tangan elektronik.  Kemudian perjanjian tersebut diterima oleh Sberbank dengan tanda tangannya - perjanjian tersebut memeriksa kepatuhan semua parameter dengan nilai-nilai yang diperlukan dan wewenang orang yang diterima dari klien.  Setelah itu, kontrak mulai bekerja.  NSD mengunggah data pasar, kontrak pintar dihitung ulang. <br><br><h3>  Bagaimana cara kerja REPO 2.0? </h3><br>  Untuk menyebarkan jaringan dan berinteraksi dengan antarmuka klien dengan kode rantai, kami menggunakan solusi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fabric Starter</a> .  Alih-alih antarmuka grpc standar untuk HLF, ia menyediakan API REST, yang dalam kasus kami secara signifikan mengurangi kompleksitas integrasi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/07a/86a/997/07a86a997c7017a122b03aad7995f6ad.png"><br><br>  Jaringan naik sebagai berikut.  Masing-masing dari tiga sisi setelah pra-instalasi pada server Docker meluncurkan Fabric Starter, yang menciptakan wadah dengan komponen-komponen dari node.  Komponen ini termasuk rekan eksternal untuk berinteraksi dengan organisasi lain dan layanan REST API di mana node berinteraksi dengan aplikasi klien.  Pada peluncuran Starter, jaringan blockchain juga dikonfigurasi dan saluran pribadi dibuat di mana kode rantai dengan kebijakan-dukungan diinstal.  Dalam kasus kami, setiap transaksi harus memiliki tanda tangan dari ketiga peserta. <br><br>  Selama fase pengujian, Docker Swarm digunakan untuk mengatur koneksi server peserta, namun, untuk tujuan membuat kesepakatan nyata, mereka beralih ke DNS.  Platform itu sendiri bertanggung jawab untuk transportasi pesan, data ditransmisikan melalui Internet dengan enkripsi TLS. <br><br><h2>  Sisi teknis dari masalah ini </h2><br>  Proses pengembangan aplikasi terdistribusi pada HLF dimulai secara tradisional - dengan struktur data dan kode rantai (pada kenyataannya, satu set prosedur tersimpan), panggilan yang mengarah ke penyimpanan, modifikasi atau pembacaan struktur ini dari buku besar.  Platform ini memungkinkan penggunaan berbagai bahasa pemrograman untuk pengembangan kode rantai dan DBMS untuk penyimpanan lokal.  Kami lebih memilih Go dan CouchDB. <br><br>  Esensi utama untuk proyek repo dalam model data kami adalah kontrak itu sendiri dan kewajiban anak perusahaannya.  Mereka diciptakan untuk masing-masing dari dua pilot, serta untuk panggilan margin.  Arsitektur ini merupakan langkah maju dibandingkan dengan model ikatan MTS, yang didasarkan pada esensi "Orde".  Objek independen juga dibuat untuk sekuritas, yang dengan demikian sebagian tokenized.  Tetapi pengembangan percobaan dengan manajemen akun dan tokenization uang virtual, kami memutuskan untuk menunda ke salah satu versi berikutnya dari solusi. <br><br>  Fungsi utama dari solusi kami: <br><br><ul><li>  Buat kontrak. <br></li><li>  Tanda tangani kontrak dengan EDS Anda yang mengonfirmasi penerimaan persyaratan kontrak. <br></li><li>  Unduh harga pasar dan mulai menghitung ulang nilai agunan.  Penyimpangan dari ambang batas yang ditetapkan menyebabkan penciptaan kewajiban margin call baru. <br></li><li>  Cerminkan status kewajiban. <br></li></ul><br>  Di sisi teknis, prosedur evaluasi ulang paling menarik di sini.  Mari kita analisa lebih detail. <br><br>  Dalam proses bisnis, prosedur harus diluncurkan sekali sehari, setelah Oracle (dalam uji coba "REPO 2.0" yang dilakukan oleh NSD) mengunggah penawaran harga sekuritas ke dalam sistem. <br><br><pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *CIBContract)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">recalculationData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stub shim.ChaincodeStubInterface, loadData *loadDataType, curDay </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pb</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Response</span></span></span></span> {...}</code> </pre> <br>  Siklus utama dari prosedur berjalan melalui semua sekuritas yang kutipannya telah diperbarui. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, securities := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> loadData.Securities {...}</code> </pre> <br>  Selanjutnya, beberapa pemeriksaan dilakukan.  Misalnya, jika pertukaran dengan mana data pasar diterima hari ini adalah hari libur, maka penghitungan ulang tidak boleh terjadi. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> t.checkHoliday(stub, contract.Settings.Calendars) == <span class="hljs-string"><span class="hljs-string">"yes"</span></span> { hisYes := historyType{curDay, <span class="hljs-string"><span class="hljs-string">"LoadData. Calendar"</span></span>, <span class="hljs-string"><span class="hljs-string">"System"</span></span>, <span class="hljs-string"><span class="hljs-string">"LoadData. Today is holiday ! No load market data to contract !"</span></span>} ... contract.History = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(contract.History, hisYes) … err = stub.PutState(contrID, contractJSONasBytes) }</code> </pre><br>  Untuk menghitung harga obligasi yang diperbarui, hasil kupon yang masih harus dibayar (NDC) ditambahkan ke harga bersih yang dimuat.  Pilot menerapkan dukungan untuk skema 30/360 untuk menghitung NKD. <br><br><pre> <code class="go hljs">priceIzm = <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(securities.Price + <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(securities.CouponRate)*<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(settlementDate.Year()) - <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(dateStart.Year()))*<span class="hljs-number"><span class="hljs-number">360</span></span> + (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(settlementDate.Month()) - <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(dateStart.Month()))*<span class="hljs-number"><span class="hljs-number">30</span></span> + (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(settlementDate.Day()) - <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(dateStart.Day())))*<span class="hljs-number"><span class="hljs-number">100</span></span>/<span class="hljs-number"><span class="hljs-number">360</span></span>/<span class="hljs-number"><span class="hljs-number">100</span></span>) curCurrVal = priceIzm</code> </pre><br>  Jika mata uang transaksi berbeda dari mata uang di mana sekuritas dikutip, terjemahan pertukaran dilakukan. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> contract.GeneralTerms.PurchasePrice.Currency != securities.Currency { curCurrName = securities.Currency + <span class="hljs-string"><span class="hljs-string">"-"</span></span> + contract.GeneralTerms.PurchasePrice.Currency               <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, currency := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> loadData.Currencies {              <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> currency.Name == curCurrName {                           curCurrVal = priceIzm * currency.Value } } }</code> </pre><br>  Sekarang kita perlu menghitung LTV.  Pertahankan nilai koefisien lama untuk cerita. <br><br><pre> <code class="go hljs">oldCurLTV := contract.MarginingTerms.CurrentLTV</code> </pre> <br>  Hal ini diperlukan untuk memperhitungkan panggilan margin yang dilakukan selama masa transaksi.  Persyaratan dapat datang dari kedua sisi, dan dalam dua bentuk: <br><br><ul><li>  Efek.  Peminjam membuat keamanan tambahan jika terjadi penurunan harga pasar keamanan.  Kreditor mengembalikan bagian dari keamanan jika terjadi kenaikan harga. <br></li><li>  Uang  Peminjam lebih awal dari jadwal membayar bagian dari pinjaman yang tidak lagi dijamin oleh jaminan yang lebih murah.  Pemberi pinjaman meningkatkan jumlah pinjaman dalam menanggapi peningkatan nilai agunan. <br></li></ul><br>  Dalam kasus pertama, jumlah sekuritas dalam agunan diperbarui secara sederhana.  Dan dalam hal menghasilkan uang dari mereka, itu juga perlu untuk mendapatkan keuntungan yang ditentukan dalam ketentuan tambahan transaksi. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, addCollateral := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> contract.MarginingTerms.AddCollateral { currSumCollateral := addCollateral.Sum + (addCollateral.Sum*contract.MarginingTerms.RateOnCashMargin*<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(deltaColDate) / <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(contract.MarginingTerms.Basis))/<span class="hljs-number"><span class="hljs-number">100</span></span> ... allSumCollateral = allSumCollateral + currSumCollateral ... ht := historyType{curDay, System<span class="hljs-string"><span class="hljs-string">", "</span></span>LoadData. Recalculation data(addCollateral) Contract <span class="hljs-string"><span class="hljs-string">" + contrID + "</span></span> - currSumCollateral: <span class="hljs-string"><span class="hljs-string">" + strconv.FormatFloat(float64(currSumCollateral), 'f', 2, 64) ... }        ... contract.History = append(contract.History, ht) }</span></span></code> </pre> <br>  Kami menghitung jumlah total pembelian kembali - pada kenyataannya, ini adalah jumlah pinjaman dengan bunga, yang harus kami bayar. <br><br><pre> <code class="go hljs">rePurchasePriceCur := contract.GeneralTerms.PurchasePrice.Sum + (contract.GeneralTerms.PurchasePrice.Sum*contract.GeneralTerms.RepoRate*<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(deltaSigningDate)/<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(contract.MarginingTerms.Basis))/<span class="hljs-number"><span class="hljs-number">100</span></span></code> </pre><br>  Sekarang kita menghitung koefisien LTV.  Untuk melakukan ini, kurangi sekuritas tunai dari harga pembelian kembali dan bagi nilai yang dihasilkan dengan nilai total sekuritas dalam sekuritas.  Jumlah yang dikreditkan oleh kreditor ditandai dengan "-" dan akan ditambahkan ke harga pembelian kembali. <br><br><pre> <code class="go hljs">contract.MarginingTerms.CurrentLTV = (rePurchasePriceCur - allSumCollateral) * <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) / (<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(contract.GeneralTerms.PurchasedSecurities.Quantity) * curCurrVal)</code> </pre><br>  Akhirnya, kami menghitung pemicu dalam kontrak.  Prosedur yang sama akan membuat objek pesanan panggilan margin jika nilai LTV menyimpang dari koridor yang ditentukan. <br><br><pre> <code class="go hljs">contract = t.checkTriggerEvents(stub, <span class="hljs-string"><span class="hljs-string">"LoadData"</span></span>, contract, curDay, securities)</code> </pre><br>  Dan tulis informasi ke histori untuk ditampilkan pada UI. <br><br><pre> <code class="go hljs">ht := historyType{curDay, <span class="hljs-string"><span class="hljs-string">"System"</span></span>, <span class="hljs-string"><span class="hljs-string">"LoadData. Recalculation data(change curLTV, ADTV) Contract "</span></span> + contrID + <span class="hljs-string"><span class="hljs-string">" - oldCurLTV: "</span></span> + strconv.FormatFloat(<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(oldCurLTV), <span class="hljs-string"><span class="hljs-string">'f'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>) + <span class="hljs-string"><span class="hljs-string">", newCurLTV: "</span></span> + strconv.FormatFloat(<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(contract.MarginingTerms.CurrentLTV), <span class="hljs-string"><span class="hljs-string">'f'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>)...} contract.History = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(contract.History, ht)</code> </pre> <br><h2>  Untuk meringkas </h2><br>  Skema semacam itu dapat bekerja tidak hanya dengan sekuritas dan kontrak, tetapi juga dalam skenario lain.  Misalnya, dengan pasokan listrik, di mana ada tarif berbeda, koneksi berbeda pada waktu yang berbeda.  Atau dengan anjak piutang - meminjamkan kepada pemasok dengan sinyal pengiriman barang.  Ada banyak kasus pengguna di bidang ekonomi, ketika semua orang menggunakan sumber data mereka sendiri yang harus diverifikasi. <br><br>  Tujuan kami adalah untuk menciptakan jaringan yang menghubungkan bank dengan satu sama lain dan pelanggan mereka secara nasional, dan menggunakan kontrak pintar untuk menggambarkan di dalamnya kontrak bukan dari crypto, tetapi dari ekonomi tradisional - instrumen keuangan.  Jaringan seperti itu akan stabil, terbuka, dan, sebagaimana seharusnya dalam jaringan P2P, tidak seorang pun di sini akan memiliki status khusus. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id442692/">https://habr.com/ru/post/id442692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id442682/index.html">Apa yang diketik dan cara merakit proyek C ++</a></li>
<li><a href="../id442684/index.html">Performa situs seimbang. Bagian 3: Konten</a></li>
<li><a href="../id442686/index.html">Tutorial DataPower</a></li>
<li><a href="../id442688/index.html">Analisis data scala - kebutuhan mendesak atau peluang yang menyenangkan?</a></li>
<li><a href="../id442690/index.html">Misi Lunar "Bereshit" - selfie di latar belakang Bumi</a></li>
<li><a href="../id442694/index.html">Salah satu raksasa streaming diluncurkan di India dan menarik sejuta pengguna dalam seminggu</a></li>
<li><a href="../id442696/index.html">S for Security: Internet Security of Things dan laporan di InoThings ++ 2019</a></li>
<li><a href="../id442698/index.html">Aplikasi metro Moskow untuk Windows Store</a></li>
<li><a href="../id442700/index.html">Apakah layak untuk berurusan dengan pembangkit listrik tenaga surya seluler?</a></li>
<li><a href="../id442702/index.html">Tentang magistrasi Tinkoff.ru di MIPT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>