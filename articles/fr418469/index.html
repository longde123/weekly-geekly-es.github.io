<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèáüèø üîÖ üö§ Quand ne pas utiliser les algorithmes STL. D√©finir l'exemple üöö üíê üí•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Camarades, bonsoir! Vous avez si froidement d√©mont√© la premi√®re √©dition du livre " C ++ 17 STL. Standard Template Library " de notre part et vous cont...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Quand ne pas utiliser les algorithmes STL. D√©finir l'exemple</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/418469/"> Camarades, bonsoir!  Vous avez si froidement d√©mont√© la premi√®re √©dition du livre " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C ++ 17 STL. Standard Template Library</a> " de notre part et vous continuez √† analyser la seconde, que nous avons finalement d√©cid√© de vous pr√©senter ici un point de vue alternatif.  L'auteur de l'article d'aujourd'hui est Ivan ƒåukiƒá, qui est √©galement propri√©taire du livre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Functional Programming in C ++</a> , qui est en cours de pr√©paration pour une publication chez Manning Publishing House.  Nous vous proposons d'√©valuer ses pens√©es sceptiques, son code et ses calculs <br><a name="habracut"></a><br>  <b>Pr√©ambule</b> <br><br>  Je voulais nommer cet article ¬´Sur la m√©chancet√© des algorithmes STL¬ª afin de tester mes propres comp√©tences en provoquant des clics.  Mais ensuite, il a d√©cid√© qu'il valait mieux √©crire un article pour le public cible, et non pas √©crire un tel article o√π ceux qui souhaitent discuter de mes th√®ses flagrantes se r√©uniraient. <br><br>  Ainsi, je peux supposer que vous √™tes int√©ress√© par les algorithmes, leur complexit√© et que vous souhaitez √©crire le code le plus parfait. <br><br>  <b>Des algorithmes</b> <br><br>  Dans la communaut√© C ++ professionnelle moderne, les gens sont souvent conseill√©s: pour rendre votre programme plus s√ªr, plus rapide, plus expressif, etc.  - Utilisez les algorithmes de la biblioth√®que standard.  J'essaie aussi de vulgariser ce conseil dans mes livres, discours, s√©minaires ... partout o√π il y a un public appropri√©. <br><br>  Bien s√ªr, il est absolument vrai que si nous sommes amen√©s √† √©crire une boucle <code>for</code> pour r√©soudre le probl√®me auquel nous sommes confront√©s, nous devons d'abord nous demander si les algorithmes existants de la biblioth√®que standard (ou boost) sont adapt√©s √† cela, et ne pas agir aveugl√©ment. <br><br>  Nous avons encore besoin de savoir comment ces algorithmes sont mis en ≈ìuvre, quelles exigences et garanties leur sont associ√©es, quelle est leur complexit√© spatiale et temporelle. <br><br>  Habituellement, si nous sommes confront√©s √† une t√¢che qui r√©pond exactement aux exigences de l'algorithme STL et qu'elle peut √™tre appliqu√©e directement, cet algorithme sera la solution la plus efficace. <br><br>  Un probl√®me peut survenir si nous devons pr√©parer les donn√©es d'une mani√®re ou d'une autre avant d'appliquer l'algorithme. <br><br>  <b>Intersection d'ensembles</b> <br><br>  Supposons que nous √©crivons un outil pour les d√©veloppeurs C ++ qui donnerait des conseils sur le remplacement des options de capture par d√©faut (parler de <code>[=]</code> et <code>[&amp;]</code> ) dans les expressions lambda, et afficherait explicitement une liste de variables captur√©es. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::partition(begin(elements), end(elements), [=] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> element) { ^~~ -  -  ,   [threshold] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element &gt; threshold; });</code> </pre> <br>  Lors de l'analyse d'un fichier, nous avons besoin d'une collection qui stocke les variables des port√©es actuelles et voisines.  D√®s que nous rencontrons une expression lambda avec une capture par d√©faut, nous devrons voir quelles variables y sont utilis√©es. <br><br>  En cons√©quence, nous avons deux ensembles: dans l'un il y aura des variables des zones de visibilit√© environnantes, et dans l'autre il y aura des variables utilis√©es dans le corps de l'expression lambda. <br><br>  La liste des options de capture que nous allons proposer pour le remplacement doit √™tre l'intersection de ces deux ensembles (les expressions lambda peuvent utiliser des variables globales qui n'ont pas besoin d'√™tre captur√©es, et toutes les variables de la port√©e environnante ne seront pas utilis√©es dans l'expression lambda). <br><br>  Et, si nous avons besoin d'une intersection, nous pouvons utiliser l' <code>std::set_intersection</code> . <br><br>  Cet algorithme est assez beau dans sa simplicit√©.  Il accepte deux collections tri√©es et les ex√©cute simultan√©ment du d√©but √† la fin: <br><br><ul><li>  Si l'√©l√©ment en cours dans la premi√®re collection est √©gal √† l'√©l√©ment en cours dans la deuxi√®me collection, il est ajout√© au r√©sultat, que l'algorithme d√©place simplement vers l'√©l√©ment suivant dans les deux collections; </li><li>  Si l'√©l√©ment r√©el dans la premi√®re collection est inf√©rieur √† l'√©l√©ment r√©el dans la deuxi√®me collection, l'algorithme ignore simplement l'√©l√©ment actuel dans la premi√®re collection; </li><li>  Si l'√©l√©ment r√©el dans la premi√®re collection est plus grand que l'√©l√©ment r√©el dans la deuxi√®me collection, l'algorithme ignore simplement l'√©l√©ment actuel dans la deuxi√®me collection; </li></ul><br>  Au moins un √©l√©ment (de la premi√®re ou de la deuxi√®me collection d'entr√©e) est ignor√© √† chaque it√©ration - par cons√©quent, la complexit√© de l'algorithme sera lin√©aire - <code>O(m + n)</code> , o√π <code>m</code> est le nombre d'√©l√©ments dans la premi√®re collection et <code>n</code> est le nombre d'√©l√©ments dans la deuxi√®me collection . <br><br>  Simple et efficace.  Tant que les collections d'entr√©e sont tri√©es. <br><br>  <b>Tri</b> <br><br>  Voici le probl√®me: que faire si les collections ne sont pas pr√©-tri√©es? <br><br>  Dans l'exemple pr√©c√©dent, il serait judicieux de stocker des variables de la port√©e environnante dans une structure de type pile, o√π l'analyseur pourrait simplement ajouter de nouveaux √©l√©ments entrant dans une nouvelle port√©e et supprimer les variables de la port√©e actuelle d√®s qu'il quitte. <br><br>  Ainsi, les variables ne seront pas tri√©es par nom, et nous ne pourrons pas utiliser directement <code>std::set_intersection</code> pour les op√©rations sur elles.  De m√™me, si vous suivez les variables dans le corps d'une expression lambda, nous ne pourrons probablement pas les enregistrer sous forme tri√©e. <br><br>  Puisque <code>std::set_intersection</code> ne fonctionne qu'avec des collections tri√©es, dans de nombreux projets, ce principe se produit: d'abord nous trions les collections, puis nous appelons l' <code>std::set_intersection</code> . <br><br>  Si nous oublions que le tri d'une pile de variables dans notre exemple d√©value compl√®tement l'utilisation compl√®te de la pile que nous avons d√©finie, l'algorithme d'intersection pour les collections non tri√©es ressemblera √† ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputIt1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputIt2, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> OutputIt&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unordered_intersection_1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort(first1, last1); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort(first2, last2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::set_intersection(first1, last1, first2, last2, dest); }</code> </pre> <br>  Quelle est la complexit√© de tout cet algorithme?  Le tri prend un temps quasi-lin√©aire, donc la complexit√© globale de cette approche est <code>O(n log n + m log m + n + m)</code> . <br><br>  <b>Trier plus petit</b> <br><br>  Est-il possible de se passer du tri? <br><br>  Si les deux collections ne sont pas tri√©es, nous devrons faire le tour de la deuxi√®me collection pour chaque √©l√©ment du premier - pour d√©cider de l'inclure ou non dans le jeu de r√©sultats.  Bien que cette approche soit assez courante dans les projets r√©els, elle est encore pire que la pr√©c√©dente - sa complexit√© est <code>O(n * m)</code> . <br><br>  Au lieu de tout trier d'affil√©e, ou de ne rien trier, souvenez-vous du Zen et choisissez le troisi√®me chemin - nous trions une seule collection. <br><br>  Si une seule collection est tri√©e, alors nous pouvons parcourir toutes les valeurs de la non tri√©e une par une et pour chaque valeur v√©rifier si elle se trouve dans la collection tri√©e.  Pour ce faire, appliquez une recherche binaire. <br><br>  Dans ce cas, la complexit√© temporelle sera <code>O(n log n)</code> pour trier la premi√®re collection et <code>O (m log n)</code> pour trier et v√©rifier.  La complexit√© totale sera <code>O((n + m) log n)</code> . <br><br>  Si nous d√©cidions de trier la deuxi√®me collection, et non la premi√®re, alors la complexit√© serait <code>O((n + m) log m)</code> . <br><br>  Pour atteindre une efficacit√© maximale, nous trions toujours la collection dans laquelle il y a moins d'√©l√©ments, de sorte que la complexit√© finale de notre algorithme soit <br>  <code>((m + n) log (min(m, n))</code> . <br><br>  L'impl√©mentation ressemblera √† ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputIt1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputIt2, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> OutputIt&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unordered_intersection_2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size1 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::distance(first1, last1); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size2 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::distance(first2, last2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size1 &gt; size2) { unordered_intersection_2(first2, last2, first1, last1, dest); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort(first1, last1); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy_if(first2, last2, dest, [&amp;] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::binary_search(first1, last1, FWD(value)); }); }</code> </pre> <br>  Dans notre exemple avec des listes de capture dans des expressions lambda, la collection de variables pr√©sentes dans l'expression lambda est g√©n√©ralement tri√©e, car elle est probablement plus petite que la collection de toutes les variables de toutes les √©tendues environnantes. <br><br>  <b>Hachage</b> <br><br>  La derni√®re option consiste √† construire <code>std::unordered_set</code> (une impl√©mentation d'ensemble non ordonn√© bas√©e sur le hachage) √† partir d'une plus petite collection, plut√¥t que de la trier.  Dans ce cas, la complexit√© des op√©rations de recherche sera en moyenne de <code>O(1)</code> , mais il faudra du temps pour construire <code>std::unordered_set</code> .  La complexit√© du b√¢timent peut aller de <code>O(n)</code> √† <code>O(n*n)</code> , et c'est un probl√®me potentiel. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputIt1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputIt2, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> OutputIt&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unordered_intersection_3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size1 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::distance(first1, last1); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size2 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::distance(first2, last2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size1 &gt; size2) { unordered_intersection_3(first2, last2, first1, last1, dest); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; test_set(first1, last1); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy_if(first2, last2, dest, [&amp;] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> test_set.count(FWD(value)); }); }</code> </pre> <br>  L'approche de hachage l'emporte compl√®tement lorsque vous devez calculer les intersections de plusieurs ensembles avec un seul petit ensemble pr√©d√©fini.  Autrement dit, nous avons l'ensemble <code>A</code> , les ensembles <code>B‚ÇÅ</code> , <code>B‚ÇÇ‚Ä¶</code> et nous voulons calculer <code>A ‚à© B‚ÇÅ, A ‚à© B‚ÇÇ‚Ä¶</code> <br><br>  Dans ce cas, vous pouvez ignorer la complexit√© de la construction <code>std::unordered_set</code> , et la complexit√© du calcul de chaque intersection sera lin√©aire - <code>O(m)</code> , o√π <code>m</code> est le nombre d'√©l√©ments dans la deuxi√®me collection. <br><br>  <b>Contr√¥le</b> <br><br>  Bien s√ªr, il est toujours utile de v√©rifier la complexit√© de l'algorithme, mais dans de tels cas, il est √©galement sage de v√©rifier diff√©rentes approches √† l'aide de points de contr√¥le.  Surtout lors du choix parmi les deux derni√®res options, o√π nous comparons les recherches binaires et les ensembles bas√©s sur le hachage. <br>  Mon test le plus simple a montr√© que la premi√®re option, o√π vous devez trier les deux collections, est toujours la plus lente. <br><br>  Le tri d'une plus petite collection surpasse <code>std::unordered_set</code> peu <code>std::unordered_set</code> , mais pas particuli√®rement. <br><br>  Les deuxi√®me et troisi√®me approches sont l√©g√®rement plus rapides que la premi√®re dans le cas o√π les deux collections ont un nombre √©gal d'√©l√©ments, et beaucoup plus rapide (jusqu'√† six fois) lorsque le nombre d'√©l√©ments dans une collection est environ 1000 fois plus √©lev√© que dans la seconde. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr418469/">https://habr.com/ru/post/fr418469/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr418457/index.html">Merci post: jour de l'administrateur syst√®me</a></li>
<li><a href="../fr418459/index.html">D√©veloppement d'un scaler LVDS avec deux interfaces DisplayPort</a></li>
<li><a href="../fr418463/index.html">Travailler avec des donn√©es dans Angular</a></li>
<li><a href="../fr418465/index.html">D√©couverte d'une nouvelle option d'attaque Spectre avec la possibilit√© de recevoir √† distance des donn√©es sur le r√©seau</a></li>
<li><a href="../fr418467/index.html">Classification des d√©veloppeurs d'arts martiaux</a></li>
<li><a href="../fr418475/index.html">Windows 10 utilise la technologie d'apprentissage automatique pour d√©terminer si une mise √† niveau est possible</a></li>
<li><a href="../fr418477/index.html">Conf√©rence DEFCON 23. Comment j'ai perdu mon deuxi√®me ≈ìil, ou recherche approfondie sur la destruction des donn√©es. Partie 1</a></li>
<li><a href="../fr418479/index.html">Conf√©rence DEFCON 23. Comment j'ai perdu mon deuxi√®me ≈ìil, ou recherche approfondie sur la destruction des donn√©es. 2e partie</a></li>
<li><a href="../fr418481/index.html">La vie en Isra√´l - quelques moments li√©s √† l'informatique</a></li>
<li><a href="../fr418483/index.html">Comment compresser le chargeur de d√©marrage pour STM8 √† une taille de 8 octets dans la m√©moire FLASH</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>