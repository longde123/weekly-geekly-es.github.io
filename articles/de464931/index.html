<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìé üëäüèæ ‚ôãÔ∏è Assembler-Einf√ºgungen ... in C #? ü§ù üí∏ üïé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Diese Geschichte begann also mit einem Zusammentreffen von drei Faktoren. Ich: 



1. meistens in C # geschrieben; 
2. nur grob vorgestellt, wie es an...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Assembler-Einf√ºgungen ... in C #?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464931/">  Diese Geschichte begann also mit einem Zusammentreffen von drei Faktoren.  Ich: <br><br><ol><li>  meistens in C # geschrieben; </li><li>  nur grob vorgestellt, wie es angeordnet ist und funktioniert; </li><li>  interessierte sich f√ºr Assembler. </li></ol><br>  Diese scheinbar unschuldige Mischung brachte eine seltsame Idee hervor: Ist es m√∂glich, diese Sprachen irgendwie zu kombinieren?  F√ºgen Sie in C # die M√∂glichkeit hinzu, Assembler-Einf√ºgungen durchzuf√ºhren, √§hnlich wie in C ++. <br><br>  Wenn Sie daran interessiert sind, zu welchen Konsequenzen dies gef√ºhrt hat, begr√º√üen Sie bitte bei cat. <br><br> <a href=""><img src="https://habrastorage.org/webt/u-/sg/dk/u-sgdkb-3zwyqg682kuh2vvv1vq.png"></a> <br><a name="habracut"></a><br><h2>  Erste Schwierigkeiten </h2><br>  Selbst in diesem Moment wurde mir klar, dass es sehr unwahrscheinlich ist, dass es Standardtools zum Aufrufen von Assembler-Code aus C # -Code gibt - dies widerspricht zu sehr einem der wichtigen Konzepte der Sprache: der Speichersicherheit.  Nach einer oberfl√§chlichen Untersuchung des Problems (die unter anderem die anf√§ngliche Vermutung best√§tigte - ‚Äûout of the box‚Äú gibt es keine solche M√∂glichkeit) wurde klar, dass es neben dem ideologischen Problem ein rein technisches Problem gibt: C # wird, wie Sie wissen, zu einem Zwischenbytecode zusammengestellt, der weiter interpretiert von der virtuellen CLR-Maschine.  Und genau hier stehen wir vor dem eigentlichen Problem: Einerseits kann der Compiler (im Folgenden meine ich Roslyn von Microsoft, da er de facto der Standard auf dem Gebiet der C # -Compiler ist) offensichtlich nicht erkennen und Assembler-Befehle aus einer Textansicht in eine bin√§re Darstellung √ºbersetzen, was bedeutet, dass wir Maschinenbefehle direkt in ihrer bin√§ren Form als Einf√ºgung verwenden m√ºssen. Andererseits hat die virtuelle Maschine ihren eigenen Bytecode und kann diesen nicht erkennen und ausf√ºhren  Geb√ºndelte Befehle, die wir ihr bieten. <br><br>  Die theoretische L√∂sung f√ºr dieses Problem liegt auf der Hand: Sie m√ºssen sicherstellen, dass der bin√§re Einf√ºgecode vom Prozessor ausgef√ºhrt wird, wobei die Interpretation der virtuellen Maschine umgangen wird.  Am einfachsten ist es, den Bin√§rcode als Array von Bytes zu speichern, auf die die Steuerung zum richtigen Zeitpunkt √ºbertragen wird.  Von hier aus taucht die erste Aufgabe auf: Sie m√ºssen einen Weg finden, um die Kontrolle auf das zu √ºbertragen, was in einem beliebigen Speicherbereich enthalten ist. <br><br><h2>  Erster Prototyp: Ein Array ‚Äûaufrufen‚Äú </h2><br>  Diese Aufgabe ist vielleicht das schwerwiegendste Hindernis f√ºr Eins√§tze.  Es ist einfach, ein Sprachwerkzeug zu verwenden, um einen Zeiger auf unser Array zu erhalten, aber in der C # -Welt existieren Zeiger nur f√ºr Daten, und es ist unm√∂glich, daraus einen Zeiger auf beispielsweise eine Funktion zu machen, damit Sie sie sp√§ter aufrufen k√∂nnen (na ja, oder zumindest konnte ich es nicht herausfinden zu tun). <br><br>  Gl√ºcklicherweise (oder leider) ist nichts unter dem Mond neu und eine schnelle Suche in Yandex nach den W√∂rtern "C #" und "Assembler Inserts" f√ºhrte mich zu einem Artikel in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dezember 2007 Ausgabe des Magazins]] [Aker]</a> .  Nachdem ich die Funktion von dort ehrlich kopiert und an meine Bed√ºrfnisse angepasst hatte, bekam ich <br><br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"kernel32.dll"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VirtualProtect</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* lpAddress, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dwSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> flNewProtect, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">* lpflOldProtect</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* InvokeAsm(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* firstAsmArg, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* secondAsmArg, <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] code) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* p = &amp;i; p += <span class="hljs-number"><span class="hljs-number">0x14</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>; i = *p; <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>* b = code) { *p = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)b; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> prev; VirtualProtect((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)b, (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>)code.Length, <span class="hljs-number"><span class="hljs-number">0x40</span></span>, &amp;prev); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)i; }</code> </pre> <br>  Die Hauptidee dieses Codes besteht darin, die R√ºcksprungadresse der Funktion <code>InvokeAsm()</code> auf dem Stapel durch die Adresse des Byte-Arrays zu ersetzen, an das Sie die Steuerung √ºbertragen m√∂chten.  Nach dem Beenden der Funktion beginnt die Ausf√ºhrung unseres Bin√§rcodes, anstatt die Ausf√ºhrung des Programms fortzusetzen. <br><br>  Wir werden uns detaillierter mit der Magie befassen, die in <code>InvokeAsm()</code> .  Zuerst deklarieren wir eine lokale Variable, die nat√ºrlich auf dem Stapel erscheint, dann erhalten wir ihre Adresse (wodurch wir die Adresse der Oberseite des Stapels erhalten).  Als n√§chstes f√ºgen wir eine bestimmte magische Konstante hinzu, die durch sorgf√§ltige Berechnung des Versatzes der R√ºcksprungadresse relativ zum oberen Rand des Stapels im Debugger erhalten wird, speichern die R√ºcksprungadresse und schreiben stattdessen die Adresse unseres Byte-Arrays.  Die heilige Bedeutung des Speicherns der Absenderadresse liegt auf der Hand - wir m√ºssen das Programm nach dem Einf√ºgen weiter ausf√ºhren, was bedeutet, dass wir wissen m√ºssen, wohin die Kontrolle danach √ºbertragen werden soll.  Als n√§chstes kommt der Aufruf der WinAPI-Funktion aus der kernel32.dll-Bibliothek - <code>VirtualProtect()</code> .  Es wird ben√∂tigt, um die Attribute der Speicherseite zu √§ndern, auf der sich der Einf√ºgecode befindet.  Wenn Sie das Programm kompilieren, wird es nat√ºrlich im Datenbereich angezeigt, und die entsprechende Speicherseite hat Lese- und Schreibzugriff.  Wir m√ºssen auch die Berechtigung hinzuf√ºgen, um den Inhalt auszuf√ºhren.  Schlie√ülich geben wir die gespeicherte reale R√ºcksendeadresse zur√ºck.  Nat√ºrlich wird diese Adresse nicht an den Code zur√ºckgegeben, der <code>InvokeAsm()</code> aufgerufen <code>InvokeAsm()</code> , weil  Ausf√ºhrung unmittelbar nach der <code>return (void*)i;</code>  "Fail" in der Beilage.  Die von der virtuellen Maschine verwendeten Aufrufkonventionen (stdcall mit deaktivierter Optimierung und fastcall mit aktivierter Option) bedeuten jedoch, dass der Wert √ºber das EAX-Register zur√ºckgegeben wird, d. H.  Um von der Einf√ºgung zur√ºckzukehren, m√ºssen wir zwei Anweisungen befolgen: Dr√ºcken Sie <code>push eax</code> (Code 0x50) und <code>ret</code> (Code 0xC3). <br><br><div class="spoiler">  <b class="spoiler_title">Klarstellung</b> <div class="spoiler_text">  In Zukunft werden wir √ºber die Architektur von x86 (oder besser IA-32) sprechen - kitschig, weil ich zu dieser Zeit zumindest irgendwie damit vertraut war, im Gegensatz zu beispielsweise x86-64.  Die oben beschriebene Steuerungs√ºbertragungsmethode sollte jedoch f√ºr 64-Bit-Code funktionieren. <br></div></div><br>  Schlie√ülich sollten Sie zwei nicht verwendete Argumente <code>void* firstAsmArg</code> : <code>void* firstAsmArg</code> und <code>void* secondAsmArg</code> .  Sie werden zum √úbertragen beliebiger Benutzerdaten an die Assembler-Einf√ºgung ben√∂tigt.  Diese Argumente befinden sich entweder an einer bekannten Stelle auf dem Stapel (stdcall) oder wiederum in bekannten Registern (fastcall). <br><br><div class="spoiler">  <b class="spoiler_title">Ein bisschen √ºber Optimierung</b> <div class="spoiler_text">  Da der Code aus Sicht des Compilers nicht versteht, was er ist, kann er versehentlich einen grundlegend wichtigen Aufruf / Inline-Vorgang ausl√∂sen / ein "unbenutztes" Argument nicht speichern / die Implementierung unseres Plans irgendwie st√∂ren.  Dies wird teilweise durch das <code>[MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.NoOptimization)]</code> gel√∂st, aber selbst solche Vorsichtsma√ünahmen haben nicht den gew√ºnschten Effekt: Beispielsweise stellt sich pl√∂tzlich heraus, dass die lokale Variable <code>i</code> , die f√ºr die gesamte Funktion von entscheidender Bedeutung ist, ein Register ist, das offensichtlich alles verdirbt .  Um die Wahrscheinlichkeit eines Fehlers vollst√§ndig auszuschlie√üen, sollten Sie eine Bibliothek mit deaktivierter Optimierung erstellen (entweder in den Projekteigenschaften deaktivieren oder die Debug-Konfiguration verwenden).  Infolgedessen wird stdcall verwendet, daher werde ich in Zukunft von dieser Aufrufkonvention ausgehen. <br></div></div><br><h2>  Verbesserungen </h2><br><h3>  Sicher ist besser als unsicher </h3><br>  Nat√ºrlich gibt es keine Frage der Sicherheit (in dem Sinne, in dem dieses Wort in C # verwendet wird).  Die oben beschriebene <code>InvokeAsm()</code> -Methode arbeitet jedoch mit Zeigern. Dies bedeutet, dass sie nur aus dem Block aufgerufen werden kann, der mit dem <code>unsafe</code> Schl√ºsselwort gekennzeichnet ist. Dies ist nicht immer praktisch - zumindest muss sie mit dem Schalter / unsafe (oder dem entsprechenden H√§kchen in den Projekteigenschaften in VS) kompiliert werden.  Daher erscheint es logisch, eine Shell bereitzustellen, die mindestens IntPtr (im schlimmsten Fall) ausf√ºhrt, und im Idealfall kann der Benutzer die zu √ºbertragenden und zur√ºckzugebenden Typen angeben.  Nun, das klingt nach generisch, wir schreiben generisch, wor√ºber gibt es sonst noch etwas, wor√ºber man sprechen kann?  In der Tat - da ist etwas. <br><br>  Das offensichtlichste: Wie bekomme ich einen Zeiger auf ein Argument, dessen Typ unbekannt ist?  Konstruktionen vom Typ <code>T* ptr = &amp;arg</code> in C # nicht zul√§ssig, und im Allgemeinen ist der Grund nicht schwer zu verstehen: Der Benutzer kann durchaus einen der verwalteten Typen als Typparameter verwenden, auf den kein Zeiger abgerufen werden kann.  Die L√∂sung k√∂nnte darin bestehen, einen Parameter vom Typ nicht <code>unmanaged</code> einzuschr√§nken. Erstens wurde er nur in C # 7.3 angezeigt, und zweitens k√∂nnen keine Zeichenfolgen und Arrays als Argumente √ºbergeben werden, obwohl der <code>fixed</code> Operator die Verwendung dieser Parameter zul√§sst (wir erhalten den Zeiger auf den ersten Zeichen bzw. Array-Element).  Nun, au√üerdem m√∂chte ich dem Benutzer die M√∂glichkeit geben, einschlie√ülich kontrollierter Typen zu arbeiten - da wir angefangen haben, die Regeln der Sprache zu verletzen, werden wir sie bis zum Ende verletzen! <br><br><h3>  Abrufen eines Zeigers auf ein verwaltetes Objekt und eines Objekts per Zeiger </h3><br>  Und wieder begann ich nach nicht sehr fruchtbaren √úberlegungen, nach den endg√ºltigen L√∂sungen zu suchen.  Diesmal hat mir der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel √ºber Habr√©</a> geholfen.  Kurz gesagt, eine der darin vorgeschlagenen Methoden besteht darin, eine Hilfsbibliothek zu schreiben, und zwar nicht in C #, sondern direkt in IL.  Seine Aufgabe besteht darin, ein Objekt (tats√§chlich eine Referenz auf das Objekt) auf den Stapel der virtuellen Maschine zu verschieben, das als Argument √ºbergeben wird, und dann etwas anderes vom Stapel abzurufen - beispielsweise eine Zahl oder <code>IntPtr</code> .  Wenn Sie dieselben Schritte in umgekehrter Reihenfolge ausf√ºhren, k√∂nnen Sie den Zeiger (z. B. vom Assembler-Insert zur√ºckgegeben) in ein Objekt konvertieren.  Diese Methode ist gut, weil alles, was passiert, klar und transparent ist.  Aber es gibt ein Minus: Ich wollte mit so wenig Dateien wie m√∂glich auskommen. Anstatt eine separate Bibliothek zu schreiben, habe ich beschlossen, den IL-Code in die Hauptbibliothek einzubetten.  Die einzige M√∂glichkeit, die ich gefunden habe, besteht darin, Stub-Methoden in C # zu schreiben, ein Projekt zu erstellen, die Bin√§rdatei mit ildasm zu zerlegen, den Code f√ºr die Stub-Methoden neu zu schreiben und alles wieder mit ilasm zusammenzusetzen.  Dies sind einige zus√§tzliche Aktionen, und da Sie sie jedes Mal ausf√ºhren m√ºssen, wenn Sie sie erstellen, nachdem Sie √Ñnderungen am Code vorgenommen haben ... Im Allgemeinen hatte ich es ziemlich schnell satt und suchte nach Alternativen. <br><br>  Gerade zu dieser Zeit fiel mir ein wundervolles Buch in die H√§nde, dank dem ich viel f√ºr mich selbst gelernt habe - ‚ÄûCLR via C #‚Äú von Jeffrey Richter.  Darin haben wir irgendwo im zwanzigsten Kapitel √ºber die <code>GCHandle</code> Struktur gesprochen, die eine <code>Alloc()</code> -Methode enth√§lt, die ein Objekt und eines der <code>GCHandleType</code> Aufz√§hlungselemente <code>GCHandleType</code> .  Wenn Sie diese Methode aufrufen und das gew√ºnschte Objekt und <code>GCHandle.Pinned</code> , k√∂nnen Sie die Adresse dieses Objekts im Speicher <code>GCHandle.Pinned</code> .  Dar√ºber hinaus wird vor dem Aufrufen von <code>GCHandle.Free()</code> Objekt festgelegt, d.h.  vollst√§ndig vor den Auswirkungen des M√ºllsammlers gesch√ºtzt.  Es gibt jedoch bestimmte Probleme.  Erstens <code>GCHandle</code> in keiner Weise, die Konvertierung ‚ÄûZeiger ‚Üí Objekt‚Äú <code>GCHandle</code> , <code>GCHandle</code> nur ‚ÄûObjekt ‚Üí Zeiger‚Äú.  Noch wichtiger ist, dass zur Verwendung von <code>GCHandleType.Pinned</code> Klasse oder Struktur des Objekts, dessen Adresse wir erhalten m√∂chten, das Attribut <code>[StructLayout(LayoutKind.Sequential)]</code> haben muss, w√§hrend <code>LayoutKind.Auto</code> verwendet wird.  Diese Methode eignet sich daher nur f√ºr einige Standardtypen und f√ºr benutzerdefinierte Typen, die urspr√ºnglich unter diesem Gesichtspunkt entwickelt wurden.  Nicht genau die universelle Methode, die wir gerne finden w√ºrden, oder? <br><br>  Versuchen Sie es erneut.  Achten wir nun auf zwei undokumentierte Funktionen, die jedoch von Roslyn unterst√ºtzt werden: <code>__makeref()</code> und <code>__refvalue()</code> .  Der erste nimmt ein Objekt und gibt eine Instanz der <code>TypedReference</code> Struktur zur√ºck, in der ein Verweis auf das Objekt und seinen Typ <code>typedReference</code> , w√§hrend der zweite das Objekt aus der √ºbertragenen <code>typedReference</code> Instanz <code>typedReference</code> .  Warum sind uns diese Funktionen wichtig?  Weil <code>TypedReference</code> eine Struktur ist!  Im Kontext der Diskussion bedeutet dies, dass wir einen Zeiger darauf erhalten k√∂nnen, der in Kombination ein Zeiger auf das erste Feld dieser Struktur sein wird.  Es speichert n√§mlich genau die Verkn√ºpfung zu dem Objekt, das uns interessiert.  Um dann einen Zeiger auf ein verwaltetes Objekt zu erhalten, m√ºssen wir den Wert durch einen Zeiger auf das <code>__makeref()</code> , was <code>__makeref()</code> und ihn in einen Zeiger konvertieren.  Um ein Objekt per Zeiger <code>__makeref()</code> , m√ºssen Sie <code>__makeref()</code> von einem bedingt leeren Objekt des erforderlichen Typs <code>TypedReference</code> , einen Zeiger auf die zur√ºckgegebene <code>TypedReference</code> Instanz <code>TypedReference</code> , einen Zeiger auf das Objekt darauf schreiben und dann <code>__refvalue()</code> aufrufen.  Das Ergebnis ist ungef√§hr so ‚Äã‚Äãwie dieser Code: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Tout ToInstance&lt;Tout&gt;(IntPtr ptr) { Tout temp = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; TypedReference tr = __makeref(temp); Marshal.WriteIntPtr(*(IntPtr*)(&amp;tr), ptr); Tout instance = __refvalue(tr, Tout); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* ToPointer&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> T obj) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T).IsValueType) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**)&amp;tr; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> **(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>***)&amp;tr; } }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Bemerkung</b> <div class="spoiler_text">  Zur√ºck zur Aufgabe, einen sicheren Wrapper f√ºr <code>InvokeAsm()</code> zu <code>InvokeAsm()</code> , sollte beachtet werden, dass die Methode zum <code>InvokeAsm()</code> von Zeigern mit <code>__makeref()</code> und <code>__refvalue()</code> im Gegensatz zu <code>GCHandle.Alloc(GCHandleType.Pinned)</code> nicht garantiert, dass sich unser Garbage Collector nirgendwo befindet Das Objekt bewegt sich nicht.  Daher sollte der Wrapper zun√§chst den Garbage Collector ausschalten und mit der Wiederherstellung seiner Funktionalit√§t enden.  Die L√∂sung ist eher unh√∂flich, aber effektiv. <br></div></div><br><h2>  F√ºr diejenigen, die sich nicht an Opcodes erinnern </h2><br>  Wir haben also gelernt, wie man Bin√§rcode aufruft und nicht nur unmittelbare Werte, sondern auch Zeiger auf alles als Argumente √ºbergibt ... Es gibt nur ein Problem.  Woher bekomme ich den gleichen Bin√§rcode?  Sie k√∂nnen sich mit einem Bleistift, einem Notizblock und einer Opcode-Tabelle (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem</a> ) ausr√ºsten oder einen Hex-Editor mit x86-Assembler-Unterst√ºtzung oder sogar einen vollwertigen √úbersetzer verwenden. All diese Optionen bedeuten jedoch, dass der Benutzer etwas anderes als die Bibliothek verwenden muss.  Dies ist nicht ganz das, was ich wollte, deshalb habe ich beschlossen, meinen √úbersetzer in die Bibliothek aufzunehmen, die traditionell SASM genannt wurde (kurz f√ºr Stack Assembler; es hat nichts mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IDE</a> zu tun). <br><br><div class="spoiler">  <b class="spoiler_title">Haftungsausschluss</b> <div class="spoiler_text">  Ich bin nicht gut darin, Zeichenfolgen zu analysieren, also der √úbersetzercode ... na ja, gelinde gesagt, unvollkommen.  Au√üerdem bin ich nicht stark in regul√§ren Ausdr√ºcken, so dass sie nicht da sind.  Und im Allgemeinen - ein iterativer Parser. <br></div></div><br>  Ich werde wahrscheinlich nicht √ºber den Entstehungsprozess dieses "Wunders" sprechen - diese Geschichte enth√§lt nichts Interessantes, aber ich werde kurz die Hauptmerkmale beschreiben.  Die meisten x86-Anweisungen werden derzeit unterst√ºtzt.  Mathematische Coprozessoranweisungen zum Arbeiten mit Gleitkommazahlen und von Erweiterungen (MMX, SSE, AVX) werden noch nicht unterst√ºtzt.  Es ist m√∂glich, Konstanten, Prozeduren, lokale Stapelvariablen und globale Variablen zu deklarieren, deren Speicher w√§hrend der √úbersetzung direkt in einem Array mit Bin√§rcode zugewiesen wird (wenn diese Variablen mit Beschriftungen benannt werden, kann ihr Wert auch nach dem Einf√ºgen durch Aufrufen von Methoden aus C # abgerufen werden <code>GetBYTEVariable()</code> , <code>GetWORDVariable()</code> , <code>GetDWORDVariable()</code> , <code>GetAStringVariable()</code> und <code>GetWStringVariable()</code> des <code>SASMCode</code> Objekts), <code>addr</code> und <code>addr</code> sind vorhanden.  Eine der wichtigen Funktionen ist die Unterst√ºtzung f√ºr den Import von Funktionen aus externen Bibliotheken mithilfe des Konstrukts <code>extern &lt; &gt; lib &lt; &gt;</code> . <br><br>  <code>asmret</code> Makro verdient einen separaten Absatz.  W√§hrend der √úbersetzung entfaltet es sich in 11 Anweisungen, die den Epilog bilden.  Der Prolog wird standardm√§√üig am Anfang des √ºbersetzten Codes hinzugef√ºgt.  Ihre Aufgabe ist es, den Status des Prozessors zu speichern / wiederherzustellen.  Zus√§tzlich f√ºgt der Prolog vier Konstanten hinzu - <code>$first</code> , <code>$second</code> , <code>$this</code> und <code>$return</code> .  W√§hrend der √úbersetzung werden diese Konstanten durch Adressen auf dem Stapel ersetzt, bei denen jeweils das erste und das zweite Argument an die Assembler-Einf√ºgung √ºbergeben werden, die Adresse des ersten Einf√ºgebefehls und die R√ºcksprungadresse. <br><br><h2>  Zusammenfassung </h2><br>  Der Code sagt viel mehr als Worte, und es w√§re seltsam, das Ergebnis einer ziemlich langen Arbeit nicht zu teilen. Deshalb lade ich alle, die mich interessieren, zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub ein</a> . <br><br>  Wenn ich jedoch versuche, alles, was getan wurde, irgendwie zu verallgemeinern, dann hat sich meiner Meinung nach ein interessantes und teilweise sogar nicht nutzloses Projekt herausgestellt.  Beispielsweise unterscheiden sich identische Algorithmen zum Sortieren von Einf√ºgungen in C # und zum Verwenden von Assembler-Einf√ºgungen in der Geschwindigkeit um mehr als das Zweifache (nat√ºrlich zugunsten von Assembler).  In ernsthaften Projekten wird nat√ºrlich nicht empfohlen, die resultierende Bibliothek zu verwenden (unvorhersehbare Nebenwirkungen sind m√∂glich, aber nicht sehr wahrscheinlich), aber es ist f√ºr Sie durchaus m√∂glich. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464931/">https://habr.com/ru/post/de464931/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464919/index.html">Integrierte Ressourcensteuerung des verwendeten RAM in der Anwendung</a></li>
<li><a href="../de464921/index.html">System.IO.Pipelines - ein wenig bekanntes Tool f√ºr Liebhaber hoher Leistung</a></li>
<li><a href="../de464925/index.html">UX Voice Guide: Situationen, Muster, Werkzeuge (und ein bisschen moralische Unterst√ºtzung)</a></li>
<li><a href="../de464927/index.html">ASIC Miner aus zweiter Hand: Risiken, √úberpr√ºfung und neu verkabelte Hashrate</a></li>
<li><a href="../de464929/index.html">Faules Laden von Browserbildern (Ladeattribut)</a></li>
<li><a href="../de464933/index.html">Anwendungen f√ºr E-Books auf dem Android-Betriebssystem. Teil 4. Spiele</a></li>
<li><a href="../de464935/index.html">Komfortable DevOpsSec: Nemesida WAF Kostenlos f√ºr NGINX mit API und pers√∂nlichem Konto</a></li>
<li><a href="../de464937/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 312 (vom 19. bis 25. August)</a></li>
<li><a href="../de464939/index.html">Testen von @ NonNull / @ Nullable-Annotationen</a></li>
<li><a href="../de464947/index.html">Digitale Veranstaltungen in Moskau vom 25. August bis 1. September</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>