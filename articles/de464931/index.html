<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📎 👊🏾 ♋️ Assembler-Einfügungen ... in C #? 🤝 💸 🕎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Diese Geschichte begann also mit einem Zusammentreffen von drei Faktoren. Ich: 



1. meistens in C # geschrieben; 
2. nur grob vorgestellt, wie es an...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Assembler-Einfügungen ... in C #?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464931/">  Diese Geschichte begann also mit einem Zusammentreffen von drei Faktoren.  Ich: <br><br><ol><li>  meistens in C # geschrieben; </li><li>  nur grob vorgestellt, wie es angeordnet ist und funktioniert; </li><li>  interessierte sich für Assembler. </li></ol><br>  Diese scheinbar unschuldige Mischung brachte eine seltsame Idee hervor: Ist es möglich, diese Sprachen irgendwie zu kombinieren?  Fügen Sie in C # die Möglichkeit hinzu, Assembler-Einfügungen durchzuführen, ähnlich wie in C ++. <br><br>  Wenn Sie daran interessiert sind, zu welchen Konsequenzen dies geführt hat, begrüßen Sie bitte bei cat. <br><br> <a href=""><img src="https://habrastorage.org/webt/u-/sg/dk/u-sgdkb-3zwyqg682kuh2vvv1vq.png"></a> <br><a name="habracut"></a><br><h2>  Erste Schwierigkeiten </h2><br>  Selbst in diesem Moment wurde mir klar, dass es sehr unwahrscheinlich ist, dass es Standardtools zum Aufrufen von Assembler-Code aus C # -Code gibt - dies widerspricht zu sehr einem der wichtigen Konzepte der Sprache: der Speichersicherheit.  Nach einer oberflächlichen Untersuchung des Problems (die unter anderem die anfängliche Vermutung bestätigte - „out of the box“ gibt es keine solche Möglichkeit) wurde klar, dass es neben dem ideologischen Problem ein rein technisches Problem gibt: C # wird, wie Sie wissen, zu einem Zwischenbytecode zusammengestellt, der weiter interpretiert von der virtuellen CLR-Maschine.  Und genau hier stehen wir vor dem eigentlichen Problem: Einerseits kann der Compiler (im Folgenden meine ich Roslyn von Microsoft, da er de facto der Standard auf dem Gebiet der C # -Compiler ist) offensichtlich nicht erkennen und Assembler-Befehle aus einer Textansicht in eine binäre Darstellung übersetzen, was bedeutet, dass wir Maschinenbefehle direkt in ihrer binären Form als Einfügung verwenden müssen. Andererseits hat die virtuelle Maschine ihren eigenen Bytecode und kann diesen nicht erkennen und ausführen  Gebündelte Befehle, die wir ihr bieten. <br><br>  Die theoretische Lösung für dieses Problem liegt auf der Hand: Sie müssen sicherstellen, dass der binäre Einfügecode vom Prozessor ausgeführt wird, wobei die Interpretation der virtuellen Maschine umgangen wird.  Am einfachsten ist es, den Binärcode als Array von Bytes zu speichern, auf die die Steuerung zum richtigen Zeitpunkt übertragen wird.  Von hier aus taucht die erste Aufgabe auf: Sie müssen einen Weg finden, um die Kontrolle auf das zu übertragen, was in einem beliebigen Speicherbereich enthalten ist. <br><br><h2>  Erster Prototyp: Ein Array „aufrufen“ </h2><br>  Diese Aufgabe ist vielleicht das schwerwiegendste Hindernis für Einsätze.  Es ist einfach, ein Sprachwerkzeug zu verwenden, um einen Zeiger auf unser Array zu erhalten, aber in der C # -Welt existieren Zeiger nur für Daten, und es ist unmöglich, daraus einen Zeiger auf beispielsweise eine Funktion zu machen, damit Sie sie später aufrufen können (na ja, oder zumindest konnte ich es nicht herausfinden zu tun). <br><br>  Glücklicherweise (oder leider) ist nichts unter dem Mond neu und eine schnelle Suche in Yandex nach den Wörtern "C #" und "Assembler Inserts" führte mich zu einem Artikel in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dezember 2007 Ausgabe des Magazins]] [Aker]</a> .  Nachdem ich die Funktion von dort ehrlich kopiert und an meine Bedürfnisse angepasst hatte, bekam ich <br><br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"kernel32.dll"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VirtualProtect</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* lpAddress, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dwSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> flNewProtect, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">* lpflOldProtect</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* InvokeAsm(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* firstAsmArg, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* secondAsmArg, <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] code) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* p = &amp;i; p += <span class="hljs-number"><span class="hljs-number">0x14</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>; i = *p; <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>* b = code) { *p = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)b; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> prev; VirtualProtect((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)b, (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>)code.Length, <span class="hljs-number"><span class="hljs-number">0x40</span></span>, &amp;prev); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)i; }</code> </pre> <br>  Die Hauptidee dieses Codes besteht darin, die Rücksprungadresse der Funktion <code>InvokeAsm()</code> auf dem Stapel durch die Adresse des Byte-Arrays zu ersetzen, an das Sie die Steuerung übertragen möchten.  Nach dem Beenden der Funktion beginnt die Ausführung unseres Binärcodes, anstatt die Ausführung des Programms fortzusetzen. <br><br>  Wir werden uns detaillierter mit der Magie befassen, die in <code>InvokeAsm()</code> .  Zuerst deklarieren wir eine lokale Variable, die natürlich auf dem Stapel erscheint, dann erhalten wir ihre Adresse (wodurch wir die Adresse der Oberseite des Stapels erhalten).  Als nächstes fügen wir eine bestimmte magische Konstante hinzu, die durch sorgfältige Berechnung des Versatzes der Rücksprungadresse relativ zum oberen Rand des Stapels im Debugger erhalten wird, speichern die Rücksprungadresse und schreiben stattdessen die Adresse unseres Byte-Arrays.  Die heilige Bedeutung des Speicherns der Absenderadresse liegt auf der Hand - wir müssen das Programm nach dem Einfügen weiter ausführen, was bedeutet, dass wir wissen müssen, wohin die Kontrolle danach übertragen werden soll.  Als nächstes kommt der Aufruf der WinAPI-Funktion aus der kernel32.dll-Bibliothek - <code>VirtualProtect()</code> .  Es wird benötigt, um die Attribute der Speicherseite zu ändern, auf der sich der Einfügecode befindet.  Wenn Sie das Programm kompilieren, wird es natürlich im Datenbereich angezeigt, und die entsprechende Speicherseite hat Lese- und Schreibzugriff.  Wir müssen auch die Berechtigung hinzufügen, um den Inhalt auszuführen.  Schließlich geben wir die gespeicherte reale Rücksendeadresse zurück.  Natürlich wird diese Adresse nicht an den Code zurückgegeben, der <code>InvokeAsm()</code> aufgerufen <code>InvokeAsm()</code> , weil  Ausführung unmittelbar nach der <code>return (void*)i;</code>  "Fail" in der Beilage.  Die von der virtuellen Maschine verwendeten Aufrufkonventionen (stdcall mit deaktivierter Optimierung und fastcall mit aktivierter Option) bedeuten jedoch, dass der Wert über das EAX-Register zurückgegeben wird, d. H.  Um von der Einfügung zurückzukehren, müssen wir zwei Anweisungen befolgen: Drücken Sie <code>push eax</code> (Code 0x50) und <code>ret</code> (Code 0xC3). <br><br><div class="spoiler">  <b class="spoiler_title">Klarstellung</b> <div class="spoiler_text">  In Zukunft werden wir über die Architektur von x86 (oder besser IA-32) sprechen - kitschig, weil ich zu dieser Zeit zumindest irgendwie damit vertraut war, im Gegensatz zu beispielsweise x86-64.  Die oben beschriebene Steuerungsübertragungsmethode sollte jedoch für 64-Bit-Code funktionieren. <br></div></div><br>  Schließlich sollten Sie zwei nicht verwendete Argumente <code>void* firstAsmArg</code> : <code>void* firstAsmArg</code> und <code>void* secondAsmArg</code> .  Sie werden zum Übertragen beliebiger Benutzerdaten an die Assembler-Einfügung benötigt.  Diese Argumente befinden sich entweder an einer bekannten Stelle auf dem Stapel (stdcall) oder wiederum in bekannten Registern (fastcall). <br><br><div class="spoiler">  <b class="spoiler_title">Ein bisschen über Optimierung</b> <div class="spoiler_text">  Da der Code aus Sicht des Compilers nicht versteht, was er ist, kann er versehentlich einen grundlegend wichtigen Aufruf / Inline-Vorgang auslösen / ein "unbenutztes" Argument nicht speichern / die Implementierung unseres Plans irgendwie stören.  Dies wird teilweise durch das <code>[MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.NoOptimization)]</code> gelöst, aber selbst solche Vorsichtsmaßnahmen haben nicht den gewünschten Effekt: Beispielsweise stellt sich plötzlich heraus, dass die lokale Variable <code>i</code> , die für die gesamte Funktion von entscheidender Bedeutung ist, ein Register ist, das offensichtlich alles verdirbt .  Um die Wahrscheinlichkeit eines Fehlers vollständig auszuschließen, sollten Sie eine Bibliothek mit deaktivierter Optimierung erstellen (entweder in den Projekteigenschaften deaktivieren oder die Debug-Konfiguration verwenden).  Infolgedessen wird stdcall verwendet, daher werde ich in Zukunft von dieser Aufrufkonvention ausgehen. <br></div></div><br><h2>  Verbesserungen </h2><br><h3>  Sicher ist besser als unsicher </h3><br>  Natürlich gibt es keine Frage der Sicherheit (in dem Sinne, in dem dieses Wort in C # verwendet wird).  Die oben beschriebene <code>InvokeAsm()</code> -Methode arbeitet jedoch mit Zeigern. Dies bedeutet, dass sie nur aus dem Block aufgerufen werden kann, der mit dem <code>unsafe</code> Schlüsselwort gekennzeichnet ist. Dies ist nicht immer praktisch - zumindest muss sie mit dem Schalter / unsafe (oder dem entsprechenden Häkchen in den Projekteigenschaften in VS) kompiliert werden.  Daher erscheint es logisch, eine Shell bereitzustellen, die mindestens IntPtr (im schlimmsten Fall) ausführt, und im Idealfall kann der Benutzer die zu übertragenden und zurückzugebenden Typen angeben.  Nun, das klingt nach generisch, wir schreiben generisch, worüber gibt es sonst noch etwas, worüber man sprechen kann?  In der Tat - da ist etwas. <br><br>  Das offensichtlichste: Wie bekomme ich einen Zeiger auf ein Argument, dessen Typ unbekannt ist?  Konstruktionen vom Typ <code>T* ptr = &amp;arg</code> in C # nicht zulässig, und im Allgemeinen ist der Grund nicht schwer zu verstehen: Der Benutzer kann durchaus einen der verwalteten Typen als Typparameter verwenden, auf den kein Zeiger abgerufen werden kann.  Die Lösung könnte darin bestehen, einen Parameter vom Typ nicht <code>unmanaged</code> einzuschränken. Erstens wurde er nur in C # 7.3 angezeigt, und zweitens können keine Zeichenfolgen und Arrays als Argumente übergeben werden, obwohl der <code>fixed</code> Operator die Verwendung dieser Parameter zulässt (wir erhalten den Zeiger auf den ersten Zeichen bzw. Array-Element).  Nun, außerdem möchte ich dem Benutzer die Möglichkeit geben, einschließlich kontrollierter Typen zu arbeiten - da wir angefangen haben, die Regeln der Sprache zu verletzen, werden wir sie bis zum Ende verletzen! <br><br><h3>  Abrufen eines Zeigers auf ein verwaltetes Objekt und eines Objekts per Zeiger </h3><br>  Und wieder begann ich nach nicht sehr fruchtbaren Überlegungen, nach den endgültigen Lösungen zu suchen.  Diesmal hat mir der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel über Habré</a> geholfen.  Kurz gesagt, eine der darin vorgeschlagenen Methoden besteht darin, eine Hilfsbibliothek zu schreiben, und zwar nicht in C #, sondern direkt in IL.  Seine Aufgabe besteht darin, ein Objekt (tatsächlich eine Referenz auf das Objekt) auf den Stapel der virtuellen Maschine zu verschieben, das als Argument übergeben wird, und dann etwas anderes vom Stapel abzurufen - beispielsweise eine Zahl oder <code>IntPtr</code> .  Wenn Sie dieselben Schritte in umgekehrter Reihenfolge ausführen, können Sie den Zeiger (z. B. vom Assembler-Insert zurückgegeben) in ein Objekt konvertieren.  Diese Methode ist gut, weil alles, was passiert, klar und transparent ist.  Aber es gibt ein Minus: Ich wollte mit so wenig Dateien wie möglich auskommen. Anstatt eine separate Bibliothek zu schreiben, habe ich beschlossen, den IL-Code in die Hauptbibliothek einzubetten.  Die einzige Möglichkeit, die ich gefunden habe, besteht darin, Stub-Methoden in C # zu schreiben, ein Projekt zu erstellen, die Binärdatei mit ildasm zu zerlegen, den Code für die Stub-Methoden neu zu schreiben und alles wieder mit ilasm zusammenzusetzen.  Dies sind einige zusätzliche Aktionen, und da Sie sie jedes Mal ausführen müssen, wenn Sie sie erstellen, nachdem Sie Änderungen am Code vorgenommen haben ... Im Allgemeinen hatte ich es ziemlich schnell satt und suchte nach Alternativen. <br><br>  Gerade zu dieser Zeit fiel mir ein wundervolles Buch in die Hände, dank dem ich viel für mich selbst gelernt habe - „CLR via C #“ von Jeffrey Richter.  Darin haben wir irgendwo im zwanzigsten Kapitel über die <code>GCHandle</code> Struktur gesprochen, die eine <code>Alloc()</code> -Methode enthält, die ein Objekt und eines der <code>GCHandleType</code> Aufzählungselemente <code>GCHandleType</code> .  Wenn Sie diese Methode aufrufen und das gewünschte Objekt und <code>GCHandle.Pinned</code> , können Sie die Adresse dieses Objekts im Speicher <code>GCHandle.Pinned</code> .  Darüber hinaus wird vor dem Aufrufen von <code>GCHandle.Free()</code> Objekt festgelegt, d.h.  vollständig vor den Auswirkungen des Müllsammlers geschützt.  Es gibt jedoch bestimmte Probleme.  Erstens <code>GCHandle</code> in keiner Weise, die Konvertierung „Zeiger → Objekt“ <code>GCHandle</code> , <code>GCHandle</code> nur „Objekt → Zeiger“.  Noch wichtiger ist, dass zur Verwendung von <code>GCHandleType.Pinned</code> Klasse oder Struktur des Objekts, dessen Adresse wir erhalten möchten, das Attribut <code>[StructLayout(LayoutKind.Sequential)]</code> haben muss, während <code>LayoutKind.Auto</code> verwendet wird.  Diese Methode eignet sich daher nur für einige Standardtypen und für benutzerdefinierte Typen, die ursprünglich unter diesem Gesichtspunkt entwickelt wurden.  Nicht genau die universelle Methode, die wir gerne finden würden, oder? <br><br>  Versuchen Sie es erneut.  Achten wir nun auf zwei undokumentierte Funktionen, die jedoch von Roslyn unterstützt werden: <code>__makeref()</code> und <code>__refvalue()</code> .  Der erste nimmt ein Objekt und gibt eine Instanz der <code>TypedReference</code> Struktur zurück, in der ein Verweis auf das Objekt und seinen Typ <code>typedReference</code> , während der zweite das Objekt aus der übertragenen <code>typedReference</code> Instanz <code>typedReference</code> .  Warum sind uns diese Funktionen wichtig?  Weil <code>TypedReference</code> eine Struktur ist!  Im Kontext der Diskussion bedeutet dies, dass wir einen Zeiger darauf erhalten können, der in Kombination ein Zeiger auf das erste Feld dieser Struktur sein wird.  Es speichert nämlich genau die Verknüpfung zu dem Objekt, das uns interessiert.  Um dann einen Zeiger auf ein verwaltetes Objekt zu erhalten, müssen wir den Wert durch einen Zeiger auf das <code>__makeref()</code> , was <code>__makeref()</code> und ihn in einen Zeiger konvertieren.  Um ein Objekt per Zeiger <code>__makeref()</code> , müssen Sie <code>__makeref()</code> von einem bedingt leeren Objekt des erforderlichen Typs <code>TypedReference</code> , einen Zeiger auf die zurückgegebene <code>TypedReference</code> Instanz <code>TypedReference</code> , einen Zeiger auf das Objekt darauf schreiben und dann <code>__refvalue()</code> aufrufen.  Das Ergebnis ist ungefähr so ​​wie dieser Code: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Tout ToInstance&lt;Tout&gt;(IntPtr ptr) { Tout temp = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; TypedReference tr = __makeref(temp); Marshal.WriteIntPtr(*(IntPtr*)(&amp;tr), ptr); Tout instance = __refvalue(tr, Tout); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* ToPointer&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> T obj) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T).IsValueType) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**)&amp;tr; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> **(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>***)&amp;tr; } }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Bemerkung</b> <div class="spoiler_text">  Zurück zur Aufgabe, einen sicheren Wrapper für <code>InvokeAsm()</code> zu <code>InvokeAsm()</code> , sollte beachtet werden, dass die Methode zum <code>InvokeAsm()</code> von Zeigern mit <code>__makeref()</code> und <code>__refvalue()</code> im Gegensatz zu <code>GCHandle.Alloc(GCHandleType.Pinned)</code> nicht garantiert, dass sich unser Garbage Collector nirgendwo befindet Das Objekt bewegt sich nicht.  Daher sollte der Wrapper zunächst den Garbage Collector ausschalten und mit der Wiederherstellung seiner Funktionalität enden.  Die Lösung ist eher unhöflich, aber effektiv. <br></div></div><br><h2>  Für diejenigen, die sich nicht an Opcodes erinnern </h2><br>  Wir haben also gelernt, wie man Binärcode aufruft und nicht nur unmittelbare Werte, sondern auch Zeiger auf alles als Argumente übergibt ... Es gibt nur ein Problem.  Woher bekomme ich den gleichen Binärcode?  Sie können sich mit einem Bleistift, einem Notizblock und einer Opcode-Tabelle (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem</a> ) ausrüsten oder einen Hex-Editor mit x86-Assembler-Unterstützung oder sogar einen vollwertigen Übersetzer verwenden. All diese Optionen bedeuten jedoch, dass der Benutzer etwas anderes als die Bibliothek verwenden muss.  Dies ist nicht ganz das, was ich wollte, deshalb habe ich beschlossen, meinen Übersetzer in die Bibliothek aufzunehmen, die traditionell SASM genannt wurde (kurz für Stack Assembler; es hat nichts mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IDE</a> zu tun). <br><br><div class="spoiler">  <b class="spoiler_title">Haftungsausschluss</b> <div class="spoiler_text">  Ich bin nicht gut darin, Zeichenfolgen zu analysieren, also der Übersetzercode ... na ja, gelinde gesagt, unvollkommen.  Außerdem bin ich nicht stark in regulären Ausdrücken, so dass sie nicht da sind.  Und im Allgemeinen - ein iterativer Parser. <br></div></div><br>  Ich werde wahrscheinlich nicht über den Entstehungsprozess dieses "Wunders" sprechen - diese Geschichte enthält nichts Interessantes, aber ich werde kurz die Hauptmerkmale beschreiben.  Die meisten x86-Anweisungen werden derzeit unterstützt.  Mathematische Coprozessoranweisungen zum Arbeiten mit Gleitkommazahlen und von Erweiterungen (MMX, SSE, AVX) werden noch nicht unterstützt.  Es ist möglich, Konstanten, Prozeduren, lokale Stapelvariablen und globale Variablen zu deklarieren, deren Speicher während der Übersetzung direkt in einem Array mit Binärcode zugewiesen wird (wenn diese Variablen mit Beschriftungen benannt werden, kann ihr Wert auch nach dem Einfügen durch Aufrufen von Methoden aus C # abgerufen werden <code>GetBYTEVariable()</code> , <code>GetWORDVariable()</code> , <code>GetDWORDVariable()</code> , <code>GetAStringVariable()</code> und <code>GetWStringVariable()</code> des <code>SASMCode</code> Objekts), <code>addr</code> und <code>addr</code> sind vorhanden.  Eine der wichtigen Funktionen ist die Unterstützung für den Import von Funktionen aus externen Bibliotheken mithilfe des Konstrukts <code>extern &lt; &gt; lib &lt; &gt;</code> . <br><br>  <code>asmret</code> Makro verdient einen separaten Absatz.  Während der Übersetzung entfaltet es sich in 11 Anweisungen, die den Epilog bilden.  Der Prolog wird standardmäßig am Anfang des übersetzten Codes hinzugefügt.  Ihre Aufgabe ist es, den Status des Prozessors zu speichern / wiederherzustellen.  Zusätzlich fügt der Prolog vier Konstanten hinzu - <code>$first</code> , <code>$second</code> , <code>$this</code> und <code>$return</code> .  Während der Übersetzung werden diese Konstanten durch Adressen auf dem Stapel ersetzt, bei denen jeweils das erste und das zweite Argument an die Assembler-Einfügung übergeben werden, die Adresse des ersten Einfügebefehls und die Rücksprungadresse. <br><br><h2>  Zusammenfassung </h2><br>  Der Code sagt viel mehr als Worte, und es wäre seltsam, das Ergebnis einer ziemlich langen Arbeit nicht zu teilen. Deshalb lade ich alle, die mich interessieren, zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub ein</a> . <br><br>  Wenn ich jedoch versuche, alles, was getan wurde, irgendwie zu verallgemeinern, dann hat sich meiner Meinung nach ein interessantes und teilweise sogar nicht nutzloses Projekt herausgestellt.  Beispielsweise unterscheiden sich identische Algorithmen zum Sortieren von Einfügungen in C # und zum Verwenden von Assembler-Einfügungen in der Geschwindigkeit um mehr als das Zweifache (natürlich zugunsten von Assembler).  In ernsthaften Projekten wird natürlich nicht empfohlen, die resultierende Bibliothek zu verwenden (unvorhersehbare Nebenwirkungen sind möglich, aber nicht sehr wahrscheinlich), aber es ist für Sie durchaus möglich. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464931/">https://habr.com/ru/post/de464931/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464919/index.html">Integrierte Ressourcensteuerung des verwendeten RAM in der Anwendung</a></li>
<li><a href="../de464921/index.html">System.IO.Pipelines - ein wenig bekanntes Tool für Liebhaber hoher Leistung</a></li>
<li><a href="../de464925/index.html">UX Voice Guide: Situationen, Muster, Werkzeuge (und ein bisschen moralische Unterstützung)</a></li>
<li><a href="../de464927/index.html">ASIC Miner aus zweiter Hand: Risiken, Überprüfung und neu verkabelte Hashrate</a></li>
<li><a href="../de464929/index.html">Faules Laden von Browserbildern (Ladeattribut)</a></li>
<li><a href="../de464933/index.html">Anwendungen für E-Books auf dem Android-Betriebssystem. Teil 4. Spiele</a></li>
<li><a href="../de464935/index.html">Komfortable DevOpsSec: Nemesida WAF Kostenlos für NGINX mit API und persönlichem Konto</a></li>
<li><a href="../de464937/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 312 (vom 19. bis 25. August)</a></li>
<li><a href="../de464939/index.html">Testen von @ NonNull / @ Nullable-Annotationen</a></li>
<li><a href="../de464947/index.html">Digitale Veranstaltungen in Moskau vom 25. August bis 1. September</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>