<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí© ü•ë üçΩÔ∏è E se sem o Python? Julia para aprendizado de m√°quina e geralmente üìú üôÖüèø ‚úãüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sempre queremos escrever c√≥digo rapidamente, mas voc√™ precisa pagar por isso. Em linguagens flex√≠veis de alto n√≠vel comuns, os programas podem ser des...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>E se sem o Python? Julia para aprendizado de m√°quina e geralmente</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/476114/">  Sempre queremos escrever c√≥digo rapidamente, mas voc√™ precisa pagar por isso.  Em linguagens flex√≠veis de alto n√≠vel comuns, os programas podem ser desenvolvidos rapidamente, mas s√£o executados lentamente ap√≥s o lan√ßamento.  Por exemplo, √© monstruosamente lento ler algo pesado em Python puro.  Os idiomas do tipo C funcionam muito mais r√°pido, mas √© mais f√°cil cometer erros, cuja busca reduzir√° a nada o ganho de velocidade. <br><br>  Normalmente, esse dilema √© resolvido da seguinte forma: primeiro eles escrevem o prot√≥tipo em algo flex√≠vel, por exemplo, em Python ou R, e depois reescrevem-no em C / C ++ ou Fortran.  Mas esse ciclo √© muito longo, voc√™ pode ficar sem ele? <br><br><img src="https://habrastorage.org/webt/c0/hu/mw/c0humwwihszecprm5u7-j1ofego.jpeg"><br><br>  Talvez haja uma solu√ß√£o.  Julia √© uma linguagem de programa√ß√£o de alto n√≠vel e flex√≠vel, por√©m r√°pida.  Julia possui despacho m√∫ltiplo, um compilador inteligente integrado e ferramentas de metaprograma√ß√£o.  <strong>Gleb Ivashkevich</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">phtRaveller</a> ), o fundador da termodin√¢mica, que desenvolve sistemas de aprendizado de m√°quina para a ind√∫stria e outras ind√∫strias, um ex-f√≠sico, lhe dir√° mais sobre o que Julia tem. <br><br>  Gleb explicar√° por que novas linguagens s√£o necess√°rias e por que algumas vezes o Python est√° ausente.  Ele lhe dir√° o que √© interessante em Julia, sobre seus pontos fortes e fracos, o comparar√° com outros idiomas e mostrar√° qual o idioma que tem a perspectiva de aprendizado de m√°quina e computa√ß√£o em geral. <br><br>  <em>Isen√ß√£o de responsabilidade.</em>  <em>N√£o haver√° an√°lise de sintaxe.</em>  <em>Habrazhiteli experimentou desenvolvedores, por isso n√£o faz sentido mostrar como escrever um loop, por exemplo.</em> <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/REVmhiJ1Zi8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  O problema de duas l√≠nguas </h2><blockquote>  Se voc√™ escrever c√≥digo rapidamente, os programas ser√£o executados lentamente.  Se os programas funcionarem rapidamente, escreva-os por um longo tempo. </blockquote> O Python cl√°ssico se enquadra na primeira categoria.  Se voc√™ remover o NumPy, considere algo em Python puro lentamente.  Por outro lado, existem idiomas como C e C ++.  √â dif√≠cil encontrar um equil√≠brio, ent√£o, na maioria das vezes, eles escrevem um prot√≥tipo em algo flex√≠vel e, ap√≥s depurar o algoritmo, eles o reescrevem para o idioma mais rapidamente.  Este √© um exemplo de um <strong>problema claro em duas linguagens</strong> : um longo ciclo quando voc√™ precisa escrever em Python e reescrev√™-lo em C ou em Cython, por exemplo. <br><br>  Especialistas em aprendizado de m√°quina e ci√™ncia de dados t√™m NumPy, Sklearn, TensorFlow.  Eles est√£o resolvendo seus problemas h√° anos sem uma √∫nica linha em C, e parece que o problema dos dois idiomas n√£o os preocupa.  N√£o √© assim, o problema se manifesta <strong>implicitamente</strong> , porque o c√≥digo no NumPy ou no TensorFlow n√£o √© realmente Python.  √â usado como uma metalinguagem para lan√ßar o que est√° dentro.  Dentro √© exatamente C / Fortran (no caso do NumPy) ou C ++ (no caso do TensorFlow). <br><br>  Esse "recurso" √© pouco vis√≠vel, por exemplo, no PyTorch, mas no Numpy √© claramente vis√≠vel.  Por exemplo, se um ciclo cl√°ssico de Python apareceu nos c√°lculos, algo deu errado.  No c√≥digo produtivo, os loops n√£o s√£o necess√°rios; voc√™ precisa reescrever tudo para que o NumPy possa vetoriz√°-lo e calcul√°-lo rapidamente. <br><br>  Ao mesmo tempo, parece que muitos NumPy √© r√°pido e est√° tudo bem com ele.  Vamos ver o que NumPy tem sob o cap√¥ para ver isso. <br><br><ul><li>  O NumPy est√° tentando corrigir o problema de flexibilidade do tipo Python, por isso possui um <strong>sistema de tipos</strong> bastante <strong>rigoroso</strong> .  Se a matriz tiver um determinado tipo, n√£o poder√° haver mais nada; se o <code>Float64</code> estiver <code>Float64</code> , nada poder√° ser feito. </li><li>  <strong>Despachar.</strong>  Dependendo dos tipos de matrizes e de qual opera√ß√£o voc√™ precisa executar, o NumPy dentro de si decidir√° qual fun√ß√£o chamar para fazer os c√°lculos o mais r√°pido poss√≠vel.  A biblioteca tentar√° tirar o Python cl√°ssico do circuito de computa√ß√£o. </li></ul><br>  Acontece que o Numpy n√£o √© t√£o r√°pido quanto parece.  √â por isso que existem projetos como <strong>Cython</strong> ou <strong>Numba</strong> .  O primeiro gera c√≥digo C a partir do "h√≠brido" de Python e C, e o segundo compila o c√≥digo em Python e, geralmente, isso √© mais r√°pido. <br><blockquote>  Se o NumPy fosse realmente t√£o r√°pido quanto parece para muitos, a exist√™ncia de Cython e Numba n√£o faria sentido. </blockquote>  Reescrevemos tudo no Cython se queremos encontrar rapidamente algo grande e complexo.  Um dos crit√©rios para a qualidade de um wrapper no Cython √© a presen√ßa ou aus√™ncia de chamadas Python puras no c√≥digo gerado. <br><br>  Um exemplo simples: adicionamos o tipo (bom) ou n√£o (ruim) e obtemos dois c√≥digos completamente diferentes, embora, al√©m dos tipos, as op√ß√µes iniciais n√£o sejam diferentes. <br><br><img src="https://habrastorage.org/webt/23/nj/e0/23nje0ddwbpf8c9debfufjvg0h8.png"><br><br>  Quando geramos o c√≥digo C, no primeiro caso, obtemos o seguinte: <br><br><pre> <code class="cpp hljs">__pyx_t_4 = __pyx_v_i; __pyx_v_result = (__pyx_v_result + (*((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *) ( <span class="hljs-comment"><span class="hljs-comment">/* dim=0 */</span></span> (__pyx_v_a.data + __pyx_t_4 * __pyx_v_a.strides[<span class="hljs-number"><span class="hljs-number">0</span></span>]) ))));</code> </pre> <br>  E no segundo <code>result =0.</code>  vai virar isso: <br><br><pre> <code class="cpp hljs">__pyx_t_6 = PyFloat_FromDouble((*((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *) ( <span class="hljs-comment"><span class="hljs-comment">/* dim=0 */</span></span> (__pyx_v_a.data + __pyx_t_4 * __pyx_v_a.strides[<span class="hljs-number"><span class="hljs-number">0</span></span>]) )))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(!__pyx_t_6)) __PYX_ERR(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_6); __pyx_t_7 = PyNumber_InPlaceAdd(__pyx_v_result, __pyx_t_6); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(!__pyx_t_7)) __PYX_ERR(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_7); __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = <span class="hljs-number"><span class="hljs-number">0</span></span>; __Pyx_DECREF_SET(__pyx_v_result, __pyx_t_7); __pyx_t_7 = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  Quando um tipo √© especificado, o c√≥digo C executa a velocidade da luz.  Se o tipo n√£o for especificado, vemos o Python normal, mas do lado C: chamadas padr√£o do Python, nas quais, por algum motivo, os <code>float</code> s√£o criados a partir do <code>double</code> , os links s√£o contados e muitos outros c√≥digos de lixo.  Esse c√≥digo √© lento porque chama Python para todas as opera√ß√µes. <br><br><h3>  √â poss√≠vel resolver todos os problemas de uma s√≥ vez </h3><br>  √â engra√ßado que, quando pensamos em algo, tentamos remover o Python puro.  Existem duas op√ß√µes para fazer isso. <br><br><ul><li>  Usando <strong>Cython</strong> ou outras ferramentas.  Existem v√°rias maneiras de otimizar seu c√≥digo Cython para acabar com quase nenhuma chamada de Python.  Mas essa n√£o √© a atividade mais agrad√°vel: nem tudo √© t√£o √≥bvio no Cython, e apenas um pouco menos de tempo √© gasto do que se voc√™ escrever tudo em C. O m√≥dulo resultante pode ser usado no Python, mas ainda leva muito tempo, ocorrem erros, o c√≥digo nem sempre √© √≥bvio e nem sempre √© claro como otimiz√°-lo. </li><li>  Usando o Numba, que faz uma <strong>compila√ß√£o JIT</strong> . </li></ul><br>  Mas talvez haja uma maneira melhor, e acho que essa √© a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Julia</a> . <br><br><h2>  Julia </h2><br>  Os criadores afirmam que esta √© uma linguagem <strong>r√°pida</strong> , de <strong>alto n√≠vel</strong> e <strong>flex√≠vel</strong> , compar√°vel ao Python em termos de facilidade de escrever c√≥digo.  Na minha opini√£o, Julia √© como uma <strong>linguagem de script:</strong> voc√™ n√£o precisa fazer o que precisa em C, onde tudo √© de n√≠vel muito baixo, incluindo estruturas de dados.  Ao mesmo tempo, voc√™ pode trabalhar em um console comum, como o Python e outras linguagens. <br><br>  Julia usa a <strong>compila√ß√£o Just-In-Time</strong> - este √© um dos elementos que d√° velocidade.  Mas a linguagem √© boa nos c√°lculos, porque foi desenvolvida para eles.  Julia √© usada para tarefas cient√≠ficas e obt√©m um desempenho decente. <br><blockquote>  Embora Julia esteja tentando parecer uma linguagem de uso geral, Julia √© boa para computa√ß√£o e n√£o muito boa para servi√ßos da Web.  Usar Julia em vez de Django, por exemplo, n√£o √© a melhor escolha. </blockquote>  Vejamos os recursos da linguagem como um exemplo de fun√ß√£o primitiva. <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> f(x) Œ± = <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>x <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> julia&gt; methods(f) <span class="hljs-comment"><span class="hljs-comment"># 1 method for generic function "f": [1] f(x) in Main at mpconf.jl:2</span></span></code> </pre> <br>  Quatro recursos s√£o vis√≠veis neste c√≥digo. <br><br><ul><li>  <strong>Praticamente n√£o h√° restri√ß√µes ao uso do Unicode</strong> .  Voc√™ pode usar f√≥rmulas de um artigo sobre aprendizado profundo ou modelagem num√©rica, reescrever com os mesmos caracteres e tudo funcionar√° - o Unicode √© costurado em quase todos os lugares. </li><li>  <strong>N√£o h√° sinal de multiplica√ß√£o.</strong>  No entanto, nem sempre √© poss√≠vel ficar sem ele, por exemplo, em 2.x (um n√∫mero de ponto flutuante vezes x) que Julia jurar√°. </li><li>  <strong>Sem <code>return</code></strong> .  Em geral, √© recomend√°vel que voc√™ escreva <code>return</code> para poder ver o que est√° acontecendo, mas o exemplo retornar√° <code>Œ±</code> , porque a atribui√ß√£o √© uma express√£o. </li><li>  <strong>Sem tipos</strong> .  Parece que, se houver velocidade, em algum momento os tipos devem aparecer?  Sim, eles aparecer√£o, mas depois. </li></ul><br>  Julia possui tr√™s recursos que oferecem flexibilidade e velocidade: <strong>despacho m√∫ltiplo, metaprograma√ß√£o e paralelismo</strong> .  Falaremos sobre os dois primeiros e deixaremos o paralelismo para estudo independente para usu√°rios avan√ßados. <br><br><h3>  Programa√ß√£o m√∫ltipla </h3><br>  A chamada para os <code>methods(f)</code> no exemplo acima parece inesperada - que tipo de m√©todos a fun√ß√£o possui?  Estamos acostumados ao fato de termos objetos de classe, classes t√™m m√©todos.  Mas em Julia tudo √© invertido: fun√ß√µes t√™m m√©todos, porque a linguagem usa m√∫ltiplos despachos. <br><blockquote>  O planejamento m√∫ltiplo significa que a variante de uma fun√ß√£o espec√≠fica que ser√° executada √© determinada por todo o conjunto de tipos de par√¢metros dessa fun√ß√£o. </blockquote>  Descreverei brevemente como isso funciona em um exemplo j√° familiar. <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> f(x) Œ± = <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>x <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> f(x::<span class="hljs-built_in"><span class="hljs-built_in">AbstractFloat</span></span>) Œ± = <span class="hljs-number"><span class="hljs-number">1</span></span> + sin(x) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> julia&gt; methods(f) <span class="hljs-comment"><span class="hljs-comment"># 2 methods for generic function "f": [1] f(x::AbstractFloat) in Main at mpconf.jl:6 [2] f(x) in Main at mpconf.jl:2</span></span></code> </pre> <br>  Variantes da mesma fun√ß√£o para diferentes conjuntos de tipos s√£o chamadas de m√©todos.  Existem dois no c√≥digo: o primeiro para todos os n√∫meros de ponto flutuante e o segundo para todo o resto.  Quando chamamos a fun√ß√£o pela primeira vez, Julia decide qual m√©todo usar e se deve compil√°-lo.  Se j√° tiver sido chamado e compilado, ser√° usado o que √©. <br><br>  Como em Julia nem tudo est√° do jeito que estamos acostumados, aqui voc√™ pode adicionar fun√ß√µes aos tipos de usu√°rio, mas esses n√£o ser√£o m√©todos de tipo no sentido de POO.  Simplesmente ser√° o campo em que a fun√ß√£o √© gravada, porque a <strong>fun√ß√£o √© o mesmo objeto completo</strong> que todo o resto. <br><br>  Para descobrir o que exatamente ser√° acionado, existem macros especiais.  Eles come√ßam com <code>@</code> .  No exemplo, a macro <code>@which</code> permite descobrir qual m√©todo foi chamado para um caso espec√≠fico. <br><br><img src="https://habrastorage.org/webt/nu/ix/ih/nuixiha2x9r2b148gdqyo81fkri.png"><br><br>  No primeiro caso, Julia decidiu que, como 2 √© um n√∫mero inteiro, ele n√£o se encaixa no <code>AbstractFloat</code> e chama a primeira op√ß√£o.  No segundo caso, ela decidiu que era o <code>Float</code> e j√° havia pedido uma vers√£o especializada.  Aproximadamente, isso funcionar√° se voc√™ adicionar outros m√©todos para alguns tipos espec√≠ficos. <br><br><h3>  LLVM e JIT </h3><br>  Julia usa a estrutura LLVM para compilar.  A biblioteca de compila√ß√£o JIT vem em um pacote de idiomas.  Na primeira vez que a fun√ß√£o √© chamada, Julia procura ver se a fun√ß√£o foi usada com esse conjunto de tipos e a compila, se necess√°rio.  O primeiro lan√ßamento levar√° algum tempo e tudo funcionar√° rapidamente. <br><blockquote>  A fun√ß√£o ser√° compilada no momento da primeira chamada para este conjunto de par√¢metros. </blockquote>  Recursos do compilador <br><br><ul><li>  <strong>O compilador √© razoavelmente razo√°vel</strong> porque o LLVM √© um bom produto. </li><li>  Os desenvolvedores mais avan√ßados podem <strong>analisar o processo de compila√ß√£o</strong> e ver o que ele gera. </li><li>  <strong>A compila√ß√£o de Julia e Numba √© semelhante</strong> .  No Numba, voc√™ tamb√©m cria um decorador JIT, mas no Numba voc√™ n√£o pode "entrar" tanto e decidir o que otimizar ou alterar. </li></ul><br>  Para ilustrar o trabalho do compilador, darei um exemplo de uma fun√ß√£o simples: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> f(x) Œ± = <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span>x <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> julia&gt; <span class="hljs-meta"><span class="hljs-meta">@code_llvm</span></span> f(<span class="hljs-number"><span class="hljs-number">2</span></span>) define i64 <span class="hljs-meta"><span class="hljs-meta">@julia_f_35897</span></span>(i64) { top: %<span class="hljs-number"><span class="hljs-number">1</span></span> = mul i64 %<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> %<span class="hljs-number"><span class="hljs-number">2</span></span> = add i64 %<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> ret i64 %<span class="hljs-number"><span class="hljs-number">2</span></span> }</code> </pre><br>  A macro <code>@code_llvm</code> permite que voc√™ veja o resultado da gera√ß√£o.  Esse <strong>IR LLVM</strong> √© <strong>uma representa√ß√£o intermedi√°ria</strong> , um tipo de montador. <br><br>  No c√≥digo, o argumento da fun√ß√£o √© multiplicado por 3, 1 √© adicionado ao resultado e o resultado √© retornado.  Tudo √© o mais direto poss√≠vel.  Se voc√™ definir a fun√ß√£o de maneira um pouco diferente, por exemplo, substitua 3 por 2, tudo mudar√°. <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> f(x) Œ± = <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>x <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> julia&gt; <span class="hljs-meta"><span class="hljs-meta">@code_llvm</span></span> f(<span class="hljs-number"><span class="hljs-number">2</span></span>) define i64 <span class="hljs-meta"><span class="hljs-meta">@julia_f_35894</span></span>(i64) { top: %<span class="hljs-number"><span class="hljs-number">1</span></span> = shl i64 %<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> %<span class="hljs-number"><span class="hljs-number">2</span></span> = or i64 %<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> ret i64 %<span class="hljs-number"><span class="hljs-number">2</span></span> }</code> </pre> <br>  Parece, qual √© a diferen√ßa: 2, 3, 10?  Mas Julia e LLVM v√™em que quando voc√™ chama uma fun√ß√£o para um n√∫mero inteiro, voc√™ pode ser um pouco mais inteligente.  Multiplicar por um n√∫mero inteiro √© um deslocamento para a esquerda em um bit - √© mais r√°pido que o produto.  Mas, √© claro, isso funciona apenas para n√∫meros inteiros, n√£o funcionar√° para deslocar <code>Float</code> esquerda em 1 bit e obter o resultado da multiplica√ß√£o por 2. <br><br><h3>  Tipos personalizados </h3><br>  Os tipos personalizados em Julia s√£o t√£o r√°pidos quanto os tipos internos.  A programa√ß√£o m√∫ltipla √© executada neles e ser√° t√£o r√°pida quanto para os tipos internos.  Nesse sentido, o mecanismo de despacho m√∫ltiplo est√° profundamente incorporado √† linguagem. <br><br>  √â l√≥gico esperar que as vari√°veis ‚Äã‚Äãn√£o tenham tipos, apenas os valores os tenham.  Vari√°veis ‚Äã‚Äãsem um tipo s√£o apenas um marcador, um r√≥tulo em algum cont√™iner. <br><br>  <strong>O sistema de tipos √© hier√°rquico.</strong>  N√£o podemos criar descendentes de tipos concretos; os tipos abstratos podem apenas t√™-los.  No entanto, tipos abstratos n√£o podem ser instanciados.  Essa nuance n√£o vai agradar a todos. <br><br>  Como os autores da linguagem explicaram quando desenvolveram Julia, eles queriam obter o resultado e, se algo era dif√≠cil de fazer, eles recusavam.  Um sistema desse tipo hier√°rquico foi mais f√°cil de desenvolver.  Este n√£o √© um problema catastr√≥fico, mas se voc√™ n√£o virar a cabe√ßa do avesso, ser√° inconveniente. <br><br>  <strong>Os tipos podem ser parametrizados</strong> , um pouco como o C / C ++.  Por exemplo, podemos ter uma estrutura dentro da qual existem campos, mas os tipos desses campos n√£o s√£o especificados - esses s√£o par√¢metros.  N√≥s especificamos um tipo espec√≠fico na instancia√ß√£o. <br><br>  <strong>Na maioria dos casos, os tipos podem ser ignorados</strong> .  Geralmente eles s√£o necess√°rios quando o tipo ajuda o compilador a adivinhar a melhor forma de compilar.  Nesse caso, os tipos s√£o melhores para especificar.  Voc√™ tamb√©m precisa especificar tipos se quiser obter melhor desempenho. <br><br>  Vamos ver o que √© poss√≠vel e o que n√£o pode ser instanciado. <br><br><img src="https://habrastorage.org/webt/0r/xr/bl/0rxrbllszhjk9okl1-3irj1zdns.png"><br><br>  O primeiro tipo de <code>AbstractPoint</code> n√£o pode ser instanciado.  Este √© apenas um pai comum para todos que podemos especificar nos m√©todos, por exemplo.  A segunda linha diz que o <code>PlanarPoint{T}</code> √© um descendente desse ponto abstrato.  Abaixo os campos come√ßam - aqui voc√™ pode ver a parametriza√ß√£o.  Voc√™ pode colocar um <code>float</code> , <code>int</code> ou outro tipo aqui. <br><br>  O primeiro tipo n√£o pode ser instanciado e, por todo o resto, √© imposs√≠vel criar descendentes.  Al√©m disso, por padr√£o eles s√£o <strong>imut√°veis</strong> .  Para poder alterar os campos, isso deve ser especificado explicitamente. <br><br>  Quando tudo estiver pronto, voc√™ pode continuar, por exemplo, calcular a dist√¢ncia para diferentes tipos de pontos.  No exemplo, o primeiro ponto no plano √© <code>PlanarPoint</code> , depois na esfera e no cilindro.  Dependendo dos dois pontos em que calculamos a dist√¢ncia, precisamos usar m√©todos diferentes.  Em geral, a fun√ß√£o ter√° esta apar√™ncia: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> describe(p::AbstractPoint) println(<span class="hljs-string"><span class="hljs-string">"Point instance: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$p</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Para <code>Float64</code> , <code>Float32</code> , <code>Float16</code> , ser√°: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> distance(pf::PlanarPoint{T}, ps::PlanarPoint{T}) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T&lt;:<span class="hljs-built_in"><span class="hljs-built_in">AbstractFloat</span></span> sqrt((pf.x-ps.x)^<span class="hljs-number"><span class="hljs-number">2</span></span> + (pf.y-ps.y)^<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  E para n√∫meros inteiros, o m√©todo de c√°lculo da dist√¢ncia ter√° a seguinte apar√™ncia: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> distance(pf::PlanarPoint{T}, ps::PlanarPoint{T}) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Integer</span></span> abs(pf.x-ps.x) + abs(pf.y-ps.y) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Para pontos de cada tipo, m√©todos diferentes ser√£o chamados. <br><br><img src="https://habrastorage.org/webt/ya/8n/_d/ya8n_dvihkdqpsmqfkmdl5wm_ro.png"><br><br>  Se voc√™ trapaceia e, por exemplo, aplica <code>distance(f1, i2)</code> , Julia jura: ‚ÄúEu n√£o conhe√ßo esse m√©todo!  Voc√™ me perguntou esses m√©todos e disse que ambos s√£o do mesmo tipo.  Voc√™ n√£o me contou como contar isso quando um par√¢metro √© <code>float</code> e o outro √© <code>int</code> . " <br><br><h3>  Velocidade </h3><br>  Voc√™ j√° deve ter se encantado: ‚ÄúExiste uma compila√ß√£o JIT: escrever √© f√°cil, funciona rapidamente.  Jogue fora o Python e comece a escrever em Julia! <br><br>  Mas n√£o √© t√£o simples.  Nem todos os recursos de Julia ser√£o r√°pidos.  Depende de dois fatores. <br><br><ul><li>  <strong>Do desenvolvedor</strong> .  N√£o h√° idiomas nos quais qualquer fun√ß√£o seja r√°pida.  Um desenvolvedor inexperiente at√© escrever√° c√≥digo em C que funcionar√° muito mais lentamente que o c√≥digo Python de um desenvolvedor experiente.  Qualquer idioma tem seus pr√≥prios truques e nuances, dos quais o desempenho depende.  O compilador, seja ele est√°tico regular ou JIT, n√£o pode fornecer todas as op√ß√µes poss√≠veis e otimizar tudo. </li><li>  <strong>Da estabilidade do tipo</strong> .  Em uma vers√£o mais r√°pida, fun√ß√µes que s√£o est√°veis ‚Äã‚Äãpor tipo ser√£o compiladas. </li></ul><br><h3>  Estabilidade de tipo </h3><br>  O que √© estabilidade de tipo?  Quando o compilador n√£o consegue adivinhar suficientemente o que acontece com os tipos, ele precisa gerar muito c√≥digo de wrapper para que tudo que chegue √† entrada funcione. <br><br>  Um exemplo simples para entender a estabilidade do tipo. <br><br><img src="https://habrastorage.org/webt/ye/83/jv/ye83jvzws3gkfjvobwf6xvtlpaq.png"><br><br>  Os especialistas em aprendizado de m√°quina dir√£o que essa √© uma ativa√ß√£o relu normal: se x&gt; 0, retorne como est√°, caso contr√°rio, retorne zero.  Um problema √© o zero ap√≥s o n√∫mero inteiro do ponto de interroga√ß√£o.  Isso significa que, se chamarmos essa fun√ß√£o para um n√∫mero de ponto flutuante, em um caso, o n√∫mero de ponto flutuante ser√° retornado e, no outro, o n√∫mero inteiro. <br><br>  O compilador n√£o pode adivinhar o tipo de resultado apenas pelo argumento do tipo de fun√ß√£o.  Ele tamb√©m precisa saber o significado.  Portanto, gera muito c√≥digo. <br><br>  Em seguida, criamos uma matriz de 100 por 100 n√∫meros aleat√≥rios de 0 a 1, deslocamos 0,5 para distribuir uniformemente n√∫meros positivos e negativos e medimos o resultado.  Existem dois pontos interessantes: o ponto e a fun√ß√£o.  O ponto ap√≥s <code>rand(100,100)</code> significa "aplicar a cada elemento".  Se voc√™ tem algum tipo de cole√ß√£o e fun√ß√£o escalar, voc√™ acaba com ele e Julia faz o resto.  Podemos assumir que isso √© t√£o eficaz quanto um loop normal em uma linguagem compilada normal.  N√£o h√° necessidade de escrever - tudo ser√° feito para voc√™. <br><br>  N√£o h√° problemas no momento - o <strong>problema est√° dentro da pr√≥pria fun√ß√£o</strong> .  O tempo estimado de execu√ß√£o dessa op√ß√£o em um computador decente para essa matriz √© de microssegundos.  Mas, na realidade - milissegundos, o que √© demais para uma matriz t√£o pequena. <br><br>  Mude apenas uma linha. <br><br><img src="https://habrastorage.org/webt/bt/3g/4t/bt3g4t3kgng3thzuyb75mi_bmzw.png"><br><br>  A fun√ß√£o <code>zero(x)</code> executada gera um zero do mesmo tipo que o argumento <code>(x)</code> .  Isso significa que, independentemente do valor de <code>x</code> , o tipo de resultado sempre ser√° conhecido pelo tipo de <code>x</code> . <br><blockquote>  Quando analisamos apenas o tipo de argumento e j√° sabemos o tipo de resultado, essas s√£o fun√ß√µes que s√£o do tipo est√°vel. </blockquote>  Se precisarmos examinar o significado dos argumentos, essas n√£o s√£o fun√ß√µes est√°veis. <br><br>  Quando o compilador pode otimizar o c√≥digo, a diferen√ßa no tempo de execu√ß√£o √© obtida por duas ordens de magnitude.  No segundo exemplo, ele foi alocado apenas exatamente para uma nova matriz, mais algumas dezenas de bytes e nada mais.  Esta op√ß√£o √© muito mais eficaz que a anterior. <br><br>  Esta √© a principal coisa a observar quando escrevemos c√≥digo em Julia.  Se voc√™ escrever como em Python, funcionar√° como em Python.  Se voc√™ executar as mesmas opera√ß√µes no NumPy, zero com ou sem um ponto n√£o desempenhar√° um papel.  Mas em Julia, isso pode prejudicar muito o desempenho. <br><br>  Felizmente, existe um m√©todo para descobrir se existe um problema.  Essa √© a macro <code>@code_warntype</code> , que permite descobrir se o compilador pode adivinhar onde est√£o os tipos e otimizar se tudo estiver bem. <br><br><img src="https://habrastorage.org/webt/bg/jp/xf/bgjpxfne2jxskxqaloz2omljbda.png"><br><br>  Na primeira op√ß√£o (esquerda), o compilador n√£o tem certeza do tipo e o exibe em vermelho.  No segundo caso, sempre haver√° <code>Float64</code> para esse argumento, para que voc√™ possa gerar um c√≥digo muito mais curto. <br><br>  Isso ainda n√£o √© LLVM, mas o c√≥digo Julia rotulado, <code>return 0</code> ou <code>return 0.0</code> fornece uma diferen√ßa de desempenho de duas ordens de magnitude. <br><br><h3>  Metaprograma√ß√£o </h3><blockquote>  A metaprograma√ß√£o √© quando criamos programas em um programa e os executamos em qualquer lugar. </blockquote>  Este √© um m√©todo poderoso que permite fazer v√°rias coisas interessantes.  Um exemplo cl√°ssico √© o Django ORM, que cria campos usando metaclasses. <br><br>  Muitas pessoas conhecem o aviso de <strong>Tim Peters</strong> , autor do Zen of Python: <i>‚ÄúMetaclasses s√£o uma m√°gica mais profunda com a qual 99% dos usu√°rios nunca devem se preocupar.</i>  <i>Se voc√™ est√° se perguntando se s√£o necess√°rias metaclasses no Python, n√£o precisa delas.</i>  <i>Se voc√™ precisar deles, sabe exatamente por que e como us√°-los. ‚Äù</i> <i><br></i> <br>  Com a metaprograma√ß√£o, a situa√ß√£o √© semelhante, mas em Julia √© costurada muito mais profundamente, essa √© uma caracter√≠stica importante de toda a linguagem.  O c√≥digo Julia √© a mesma estrutura de dados que qualquer outro, voc√™ pode manipular, combinar, criar express√µes e tudo isso funcionar√°. <br><br><pre> <code class="julia hljs">julia&gt; x = <span class="hljs-number"><span class="hljs-number">4</span></span>; julia&gt; typeof(:(x+<span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-built_in"><span class="hljs-built_in">Expr</span></span> julia&gt; expr = :(x+<span class="hljs-number"><span class="hljs-number">1</span></span>) :(x + <span class="hljs-number"><span class="hljs-number">1</span></span>) julia&gt; expr.head :call julia&gt; expr.args <span class="hljs-number"><span class="hljs-number">3</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Any</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}: :+ :x <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  <strong>As macros s√£o uma das ferramentas de metaprograma√ß√£o em Julia</strong> : damos a elas algo, elas parecem, adicionam a correta, removem o desnecess√°rio e d√£o o resultado.  Em todos os exemplos anteriores, passamos a chamada para a fun√ß√£o e a macro interna analisou a chamada.  Tudo isso acontece no n√≠vel do trabalho com a √°rvore de sintaxe. <br><br>  Voc√™ pode analisar express√µes muito simples: se for, por exemplo, <code>(x+1)</code> , ser√° uma chamada para a fun√ß√£o <code>+</code> (a adi√ß√£o n√£o √© um operador, como em muitos outros idiomas, mas uma fun√ß√£o) e dois argumentos: um caractere (dois pontos significa que √© um caractere ) e o segundo √© apenas uma constante. <br><br>  Outro exemplo simples de macro: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">macro</span></span> named(name, expr) println(<span class="hljs-string"><span class="hljs-string">"Starting </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$name</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">quote</span></span> $(esc(expr)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> julia&gt; <span class="hljs-meta"><span class="hljs-meta">@named</span></span> <span class="hljs-string"><span class="hljs-string">"some process"</span></span> x=<span class="hljs-number"><span class="hljs-number">5</span></span>; Starting some process julia&gt; x <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre> <br>  Usando macros, por exemplo, indicadores ou filtros de progresso para quadros de dados s√£o criados - esse √© um mecanismo comum em Julia. <br><blockquote>  As macros n√£o s√£o executadas no momento da chamada, mas ao analisar o c√≥digo. </blockquote>  Este √© o principal recurso de macro em Julia.  -    ,       .   ,   ,       . <br><br><h3> ,      </h3><br> Julia ‚Äî     .      . <br><br><ul><li> Julia  <strong> </strong> .       . </li><li> <strong> </strong> ,    .    ,   ,  C    . </li><li>  Julia <strong>JIT-  </strong> .   ,  , ,   ,    . </li><li>     ‚Äî <strong> </strong> .      . </li><li> <strong>    </strong>     ( ).       ,         .    ,    ,    . </li><li> Julia  <strong></strong> ‚Äî      . </li></ul><br><h2>  Ecossistema </h2><br>  ,    ,   Julia   .    ,     , data science   ,    ,  ,     Python. ,  Python  Pandas,      ,    ,    ,   Julia      . <br><br>  Julia  ,       Python 2008 .        Python,        ,    Julia.    ,     .    ,    Julia. <br><br><h3>   ( ) Python  Julia </h3><br> <strong> </strong> .    Julia:  , ,    .‚Ä¶ <br><br> <strong></strong> .   . <br><br><ul><li> <strong>DataFrames.jl</strong> . </li><li>   <strong>JuliaDB</strong>     ,       . </li><li>        <strong>Query.jl</strong> .     Pandas ‚Äî    - ,   .. </li></ul><br> <strong>Plotting</strong> .     <strong>Matplotlib</strong> ,         Julia.     :  <strong>VegaLite.jl</strong> ,   <strong>Plots.jl</strong> ,     ,  <strong>Gadfly.jl</strong> . <br><br> <strong> </strong> .    <strong>TensorFlow</strong> ,     Flux.jl.    Flux    , ,     ,   Keras  TensorFlow,   .      . <br><br> <strong>Scikit-learn</strong> .   ,  ,     sklearn,    ,  . <br><br> <strong>XGBoost</strong> .  ,  Julia   . <br><br><h3>     ? </h3><br>     <strong>Jupyter</strong> . IDE ‚Äî  Juno,    Visual Studio,         . <br><br> <strong></strong> .  GPU/TPU  .  CUDAnative.jl    Julia     .    Julia-,    -     ,        .    ,      ,      , , . <br><br> <strong> :</strong>   C, Fortran, Python   . <br><br> <strong> </strong>   ,    . <br><br> <strong>Packaging</strong> :      Julia:      , ,   .. <br><br><h3>   </h3><br>      ,      ,   .  ,   ,    .   ,   <strong>PyTorch</strong>       ,  TensorFlow,     ,        . <br><br>      ,        , ,      .      Julia,   , ,      .   ,   <strong> </strong> ,  <strong>Zygote.jl</strong> .     Flux.jl. <br><br><pre> <code class="julia hljs">julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Zygote julia&gt; <span class="hljs-literal"><span class="hljs-literal">œÜ</span></span>(x) = x*sin(x) julia&gt; Zygote.gradient(<span class="hljs-literal"><span class="hljs-literal">œÜ</span></span>, <span class="hljs-literal"><span class="hljs-literal">œÄ</span></span>/<span class="hljs-number"><span class="hljs-number">2.</span></span>) (<span class="hljs-number"><span class="hljs-number">1.0</span></span>,) julia&gt; model = Chain(Dense(<span class="hljs-number"><span class="hljs-number">768</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>, relu), Dense(<span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>), softmax) julia&gt; loss(x, y) = crossentropy(model(x), y) + sum(norm, params(model)) julia&gt; optimizer = ADAM(<span class="hljs-number"><span class="hljs-number">0.001</span></span>) julia&gt; Flux.train!(loss, params(model), data, optimizer) julia&gt; model = Chain(x -&gt; sqrt(x), x-&gt;x-<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>     <code>œÜ</code>  , , ,       . <br><br>  Zygote   ¬´source-to-source¬ª:         ,    ,   .   <strong>differentiable programming ‚Äî  </strong> ‚Äî       backpropagation     ,    . <br><br>     Julia     : ¬´source-to-source¬ª          ,      . ,     . <br><br><h2>  Julia  ? </h2><br>     ,         ‚Äî  .        . <br><br>   - , , ,       ‚Äî . <br><br>    ,   ,  . <br><br>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Julia</a> ,   . <br><br><ul><li>     ,  ,    . Julia   ¬´¬ª . </li><li>    ,     API,     ,    . </li></ul><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Moscow Python Conf++</a>    ,  27   ,          Python  Julia.   ,     ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">telegram-</a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>  MoscowPython. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt476114/">https://habr.com/ru/post/pt476114/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt476104/index.html">N√£o use MTProxy gratuito e outros tipos de proxies gratuitos ...</a></li>
<li><a href="../pt476106/index.html">‚ÄúProtocolos de sistemas de criptografia‚Äù: Diffie - Hellman, El-Gamal, MTI / A (0), STS</a></li>
<li><a href="../pt476108/index.html">C√©rebro mut√°vel</a></li>
<li><a href="../pt476110/index.html">Por que a TI precisa de uma marca pessoal</a></li>
<li><a href="../pt476112/index.html">Elixir como objetivo de desenvolvimento para python ass√≠ncrono</a></li>
<li><a href="../pt476118/index.html">Design de interface para o jogo, desenhe um anel Havel de Dark Souls 3</a></li>
<li><a href="../pt476122/index.html">‚ÄúOu√ßa‚Äù o cosmos: da mat√©ria escura ao cometa Churyumov - Gerasimenko</a></li>
<li><a href="../pt476126/index.html">Como testar o desempenho do servidor: uma sele√ß√£o de v√°rios benchmarks de c√≥digo aberto</a></li>
<li><a href="../pt476128/index.html">Ivan Osipov e Yuri Artamonov sobre Kotlin e plugins para o IntelliJ IDEA na reuni√£o jug.msk.ru</a></li>
<li><a href="../pt476134/index.html">MONQ - monitoramento e AIOps origin√°rios da R√∫ssia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>