<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüé® üéØ üï¥üèø Proxies DNS de bricolaje en Node.JS ‚ñ´Ô∏è üë©‚ÄçüöÄ ü§æüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Un paquete sobre los baches en un bosque lejano para DNS ... 
 L. Kaganov "Aldea en la parte inferior" 

 Al desarrollar una aplicaci√≥n de red, a vece...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Proxies DNS de bricolaje en Node.JS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440050/"><blockquote> Un paquete sobre los baches en un bosque lejano para DNS ... <br>  <em>L. Kaganov "Aldea en la parte inferior"</em> </blockquote><p>  Al desarrollar una aplicaci√≥n de red, a veces se hace necesario ejecutarla localmente, pero acceder a ella utilizando un nombre de dominio real.  La soluci√≥n est√°ndar probada es registrar el dominio en el archivo de hosts.  El inconveniente del enfoque es que los hosts requieren una correspondencia clara de los nombres de dominio, es decir  No es compatible con las estrellas.  Es decir  si hay dominios de la forma: </p><br><pre><code class="plaintext hljs">dom1.example.com, dom2.example.com, dom3.example.com, ................ domN.example.com,</code> </pre> <br><p>  luego, en los hosts, debe registrarlos a todos.  En algunos casos, el dominio de tercer nivel no se conoce de antemano.  Hay un deseo (escribo para m√≠, alguien podr√≠a decir que es normal) sobrevivir con una l√≠nea como esta: </p><br><pre> <code class="plaintext hljs">*.example.com</code> </pre> <br><p>  La soluci√≥n al problema puede ser utilizar su propio servidor DNS, que procesar√° las solicitudes de acuerdo con la l√≥gica especificada.  Existen tales servidores, ambos completamente gratuitos y con una interfaz gr√°fica conveniente, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CoreDNS</a> .  Tambi√©n puede cambiar los registros DNS en el enrutador.  Finalmente, use un servicio como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">xip.io</a> , no es un servidor DNS completo, pero es perfecto para algunas tareas.  En resumen, existen soluciones listas para usar, que puede usar y no molestar. </p><br><p>  Pero este art√≠culo describe otra forma: escribir su propia bicicleta, el punto de partida para crear una herramienta como las enumeradas anteriormente.  Escribiremos nuestro proxy DNS, que escuchar√° las consultas DNS entrantes, y si el nombre de dominio solicitado est√° en la lista, devolver√° la IP especificada y, de lo contrario, solicitar√° un servidor DNS superior y reenviar√° la respuesta recibida sin cambios en el programa solicitante. </p><a name="habracut"></a><br><p>  Al mismo tiempo, puede registrar solicitudes y las respuestas recibidas.  Dado que todos necesitan DNS: navegadores, mensajeros y antivirus, y servicios de sistema operativo, etc., puede ser muy informativo. </p><br><p>  El principio es simple.  En la configuraci√≥n de conexi√≥n de red para IPv4, cambiamos la direcci√≥n del servidor DNS a la direcci√≥n de la m√°quina con nuestro proxy DNS autoescrito en ejecuci√≥n (127.0.0.1, si no estamos trabajando en la red), y en su configuraci√≥n especificamos la direcci√≥n del servidor DNS superior.  Y, al parecer, eso es todo! </p><br><p>  No utilizaremos las funciones est√°ndar para resolver los nombres de dominio <em>nslookup</em> y <em>nsresolve</em> , por lo que la configuraci√≥n del sistema DNS y el contenido del <em>archivo hosts</em> no afectar√°n el funcionamiento del programa.  Dependiendo de la situaci√≥n, puede ser √∫til o no, solo necesita recordar esto.  Para simplificar, nos restringimos a la implementaci√≥n de la funcionalidad b√°sica en s√≠: </p><br><ul><li>  IP spoofing solo para registros de tipo A (direcci√≥n de host) y clase IN (Internet) </li><li>  direcciones IP falsificadas solo versi√≥n 4 </li><li>  conexi√≥n para solicitudes entrantes locales solo a trav√©s de UDP </li><li>  conexi√≥n al servidor DNS ascendente a trav√©s de UDP o TLS </li><li>  Si hay varias interfaces de red, se aceptar√°n solicitudes locales entrantes en cualquiera de ellas. </li><li>  sin soporte EDNS </li></ul><br><div class="spoiler">  <b class="spoiler_title">Hablando de pruebas</b> <div class="spoiler_text"><p>  Hay pocas pruebas unitarias en el proyecto.  Es cierto que funcionan de acuerdo con el principio: lo lanc√©, y si se muestra algo sensato en la consola, entonces todo est√° bien, pero si una excepci√≥n vuela, entonces hay un problema.  Pero incluso un enfoque tan torpe le permite localizar con √©xito el problema, por lo tanto, Unidad. </p></div></div><br><h2 id="nachalo--server-na-53-m-portu">  Inicio - servidor en el puerto 53 </h2><br><p>  Empecemos  En primer lugar, debe ense√±ar a la aplicaci√≥n a aceptar consultas DNS entrantes.  Estamos escribiendo un servidor TCP simple que solo escucha el puerto 53 y registra las conexiones entrantes.  En las propiedades de la conexi√≥n de red, escribimos la direcci√≥n del servidor DNS 127.0.0.1, iniciamos la aplicaci√≥n, vamos al navegador durante varias p√°ginas y ... en silencio en la consola, el navegador muestra la p√°gina normalmente.  Bueno, cambiamos TCP a UDP, comenzamos, vamos por el navegador: en el navegador hay un error de conexi√≥n, algunos datos binarios se vierten en la consola.  Entonces, el sistema env√≠a solicitudes a trav√©s de UDP, y escucharemos las conexiones entrantes a trav√©s de UDP en el puerto 53.  Media hora de trabajo, de los cuales 15 minutos busca en Google c√≥mo generar un servidor TCP y UDP en NodeJS, y hemos resuelto la tarea fundamental del proyecto, que determina la estructura de la aplicaci√≥n futura.  El c√≥digo es el siguiente: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dgram = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'dgram'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = dgram.createSocket(<span class="hljs-string"><span class="hljs-string">'udp4'</span></span>); <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">function</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">server</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">on</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'error'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, (err</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`server error:\n</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${err.stack}</span></span></span><span class="hljs-string">`</span></span>); server.close(); }); server.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (localReq, linfo) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(localReq); <span class="hljs-comment"><span class="hljs-comment">//            }); server.on('listening', () =&gt; { const address = server.address(); console.log(`server listening ${address.address}:${address.port}`); }); const localListenPort = 53; const localListenAddress = 'localhost'; server.bind(localListenPort, localListenAddress); // server listening 0.0.0.0:53 }());</span></span></code> </pre> <br><p>  <em>Listado 1. El c√≥digo m√≠nimo necesario para recibir consultas DNS locales</em> </p><br><p>  El siguiente punto es leer el mensaje para comprender si es necesario devolver nuestra IP en respuesta o simplemente transmitirlo. </p><br><h2 id="dns-soobschenie">  Mensaje DNS </h2><br><p>  La estructura del mensaje DNS se describe en RFC-1035.  Tanto las solicitudes como las respuestas siguen esta estructura y, en principio, difieren en un indicador de un bit (campo QR) en el encabezado del mensaje.  El mensaje incluye cinco secciones: </p><br><pre> <code class="plaintext hljs">+---------------------+ | Header | +---------------------+ | Question | the question for the name server +---------------------+ | Answer | RRs answering the question +---------------------+ | Authority | RRs pointing toward an authority +---------------------+ | Additional | RRs holding additional information +---------------------+</code> </pre> <br><p>  <em>Estructura (s) general (es) de mensajes DNS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tools.ietf.org/html/rfc1035#section-4.1</a></em> </p><br><p>  Un mensaje DNS comienza con un encabezado de longitud fija (esta es la secci√≥n denominada <em>Encabezado</em> ), que contiene campos de 1 bit a dos bytes de largo (por lo tanto, un byte en el encabezado puede contener varios campos).  El encabezado comienza con el campo ID: este es el identificador de solicitud de 16 bits, la respuesta debe tener la misma ID.  A continuaci√≥n est√°n los campos que describen el tipo de solicitud, el resultado de su ejecuci√≥n y el n√∫mero de registros en cada una de las secciones posteriores del mensaje.  Descr√≠balos a todos durante mucho tiempo, as√≠ que a qui√©n le importa, bueno en el RFC: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tools.ietf.org/html/rfc1035#section-4.1.1</a> .  La secci√≥n <em>Encabezado</em> siempre est√° presente en el mensaje DNS. </p><br><pre> <code class="plaintext hljs"> 1 1 1 1 1 1 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | ID | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ |QR| Opcode |AA|TC|RD|RA| Z | RCODE | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | QDCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | ANCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | NSCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | ARCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</code> </pre> <br><p>  <em>Estructura (s) del encabezado del mensaje DNS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tools.ietf.org/html/rfc1035#section-4.1.1</a></em> </p><br><h3 id="sekciya-question">  Secci√≥n de preguntas </h3><br><p>  La secci√≥n <em>Pregunta</em> contiene una entrada que le dice al servidor exactamente qu√© informaci√≥n se necesita de √©l.  Te√≥ricamente, en la secci√≥n de dichos registros puede haber uno o varios, su n√∫mero se indica en el campo QDCOUNT en el encabezado del mensaje y puede ser 0, 1 o m√°s.  Pero en la pr√°ctica, la secci√≥n Pregunta puede contener solo una entrada.  Si la secci√≥n <em>Pregunta</em> conten√≠a varios registros, y uno de ellos provocar√≠a un error al procesar la solicitud en el servidor, surgir√≠a una situaci√≥n indefinida.  Aunque el servidor devolver√° un c√≥digo de error en el campo RCODE en el mensaje de respuesta, no podr√° indicar al procesar qu√© registro se produjo el problema, la especificaci√≥n no describe esto.  Los registros tampoco tienen campos que contengan una indicaci√≥n del error y su tipo.  Por lo tanto, existe un acuerdo (no documentado), seg√∫n el cual la secci√≥n <em>Pregunta</em> puede contener solo un registro, y el campo QDCOUNT tiene un valor de 1. Tampoco est√° completamente claro c√≥mo procesar la solicitud en el lado del servidor, si a√∫n contiene varios registros en la <em>Pregunta</em> .  Alguien aconseja devolver un mensaje con un error de solicitud.  Y, por ejemplo, Google DNS procesa solo el primer registro en la secci√≥n <em>Pregunta</em> , simplemente ignora el resto.  Aparentemente, esto queda a discreci√≥n de los desarrolladores de servicios de DNS. </p><br><p>  En el mensaje DNS de respuesta del servidor, la secci√≥n <em>Pregunta</em> tambi√©n est√° presente y debe copiar completamente la <em>Pregunta de la</em> solicitud (para evitar conflictos, en caso de que un campo ID no sea suficiente). </p><br><p>  La √∫nica entrada en la secci√≥n <em>Pregunta</em> contiene los campos: QNAME (nombre de dominio), QTYPE (tipo), QCLASS (clase).  QTYPE y QCLASS son n√∫meros de doble byte que indican el tipo y la clase de la solicitud.  Los tipos y clases posibles se describen en RFC-1035 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tools.ietf.org/html/rfc1035#section-3.2</a> , todo est√° claro all√≠.  Pero en el m√©todo de grabaci√≥n de un nombre de dominio nos detendremos con m√°s detalle en la secci√≥n "Formato para registrar nombres de dominio". </p><br><p>  En el caso de una consulta, el mensaje DNS a menudo termina con la secci√≥n <em>Pregunta</em> , a veces la secci√≥n <em>Adicional</em> puede seguirlo. </p><br><p>  Si se produjo un error al procesar la solicitud en el servidor (por ejemplo, una solicitud entrante se form√≥ incorrectamente), el mensaje de respuesta tambi√©n finalizar√° con la secci√≥n <em>Pregunta</em> o <em>Adicional</em> , y el campo RCODE del encabezado del mensaje de respuesta contendr√° un c√≥digo de error. </p><br><h3 id="sekcii-answer-authority-i-additional">  <em>Respuesta</em> , <em>autoridad</em> y secciones <em>adicionales</em> </h3><br><p>  Las siguientes secciones son <em>Respuesta</em> , <em>Autoridad</em> y <em>Adicional</em> ( <em>Respuesta</em> y <em>Autoridad</em> est√°n contenidas solo en el mensaje DNS de respuesta. Puede aparecer <em>Adicional</em> en la solicitud y en la respuesta).  Son opcionales, es decir  cualquiera de ellos puede estar presente o no, dependiendo de la solicitud.  Estas secciones tienen la misma estructura y contienen informaci√≥n en el formato de los llamados "registros de recursos" ( <em>registro de recursos</em> o RR).  Hablando en sentido figurado, cada una de estas secciones es una matriz de registros de recursos, y un registro es un objeto con campos.  Cada secci√≥n puede contener uno o m√°s registros, su n√∫mero se indica en el campo correspondiente en el encabezado del mensaje (ANCOUNT, NSCOUNT, ARCOUNT, respectivamente).  Por ejemplo, una solicitud de IP para el dominio "google.com" devolver√° varias direcciones IP, por lo que tambi√©n habr√° varias entradas en la secci√≥n <em>Respuesta</em> , una para cada direcci√≥n.  Si la secci√≥n est√° ausente, el campo de encabezado correspondiente contiene 0. </p><br><p>  Cada <em>registro de recursos</em> (RR) comienza con un campo NAME que contiene un nombre de dominio.  El formato de este campo es el mismo que el campo QNAME de la secci√≥n <em>Pregunta</em> . <br>  Junto a NAME est√°n los campos TYPE (tipo de registro) y CLASS (su clase), ambos campos son num√©ricos de 16 bits, indican el tipo y la clase del registro.  Esto tambi√©n se asemeja a la secci√≥n <em>Pregunta</em> , con la diferencia de que su QTYPE y QCLASS pueden tener los mismos valores que TYPE y CLASS, y algunos m√°s propios que son √∫nicos para ellos.  Es decir, en un lenguaje cient√≠fico seco, el conjunto de valores QTYPE y QCLASS es un superconjunto de los valores TYPE y CLASS.  Lea m√°s sobre las diferencias en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tools.ietf.org/html/rfc1035#section-3.2.2</a> . <br>  Los campos restantes son: </p><br><ul><li>  TTL es un n√∫mero de 32 bits que indica el tiempo que dur√≥ el registro (en segundos). </li><li>  RDLENGTH es un n√∫mero de 16 bits que indica la longitud del siguiente campo RDATA en bytes. </li><li>  RDATA es en realidad una carga √∫til, el formato depende del tipo de registro.  Por ejemplo, para un registro de tipo A (direcci√≥n de host) y clase IN (Internet), estos son 4 bytes que representan una direcci√≥n IPv4. </li></ul><br><h2 id="format-zapisi-domennyh-imyon">  Formato de registro de nombre de dominio </h2><br><p>  El formato para registrar nombres de dominio es el mismo para los campos QNAME y NAME, as√≠ como para el campo RDATA, si es un registro CNAME, MX, NS u otra clase que asume un nombre de dominio como resultado. </p><br><p>  Un nombre de dominio es una secuencia de etiquetas (secciones de un nombre, subdominios; esta es una <strong>etiqueta</strong> en el original, no encontr√© una mejor traducci√≥n).  Una etiqueta es un byte √∫nico de longitud que contiene un n√∫mero: la longitud del contenido de la etiqueta en bytes, seguida de una secuencia de bytes de la longitud especificada.  Las etiquetas siguen una tras otra hasta que se encuentra un byte de longitud que contiene 0. La primera etiqueta puede ser inmediatamente de longitud cero, esto indica el dominio ra√≠z (dominio ra√≠z) con un nombre de dominio vac√≠o (a veces escrito como ""). </p><br><p>  En versiones anteriores de DNS, los bytes en la etiqueta podr√≠an tener cualquier valor de (0 a 255).  Hab√≠a reglas que estaban en la naturaleza de una recomendaci√≥n fuerte: que la etiqueta comience con una letra, termine con una letra o n√∫mero, y contenga solo letras, n√∫meros o guiones en la codificaci√≥n ASCII de 7 bits, con un bit alto cero.  La especificaci√≥n EDNS actual ya requiere el cumplimiento de estas reglas claramente, sin desviaciones. </p><br><p>  Los dos bits m√°s significativos del byte de longitud se utilizan como un atributo de tipo de etiqueta.  Si son cero ( <em>0b00xxxxxx</em> ), entonces esta es una etiqueta normal, y los bits restantes del byte de longitud indican el n√∫mero de bytes de datos incluidos en su composici√≥n.  La longitud m√°xima de la etiqueta es de 63 caracteres.  63 en codificaci√≥n binaria es solo <em>0b00111111</em> . </p><br><p>  Si los dos bits de orden superior son 0 y 1 ( <em>0b01xxxxxx</em> ), <em>respectivamente</em> , esta es una etiqueta de tipo extendido del est√°ndar EDNS ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tools.ietf.org/html/rfc2671#section-3.1</a> ), que nos lleg√≥ desde el 1 de febrero de 2019.  Los seis bits inferiores contendr√°n el valor de la etiqueta.  No estamos discutiendo EDNS en este art√≠culo, pero es √∫til saber que esto tambi√©n sucede. </p><br><p>  La combinaci√≥n de los dos bits m√°s significativos, igual a 1 y 0 ( <em>0b10xxxxxx</em> ), est√° reservada para uso futuro. </p><br><p>  Si ambos bits altos son iguales a 1 ( <em>0b11xxxxxx</em> ), esto significa que los nombres de dominio est√°n comprimidos ( <em>compresi√≥n</em> ), y nos detendremos en esto con m√°s detalle. </p><br><h3 id="szhatie-domennyh-imyon">  Compresi√≥n de nombres de dominio </h3><br><p>  Entonces, si un byte de longitud tiene dos bits altos iguales a 1 ( <em>0b11xxxxxx</em> ), esto es un signo de compresi√≥n de nombre de dominio.  La compresi√≥n se usa para hacer los mensajes m√°s cortos y concisos.  Esto es especialmente cierto cuando se trabaja en UDP, cuando la longitud total del mensaje DNS est√° limitada a 512 bytes (aunque este es el est√°ndar anterior, consulte <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tools.ietf.org/html/rfc1035#section-2.3.4</a> L√≠mites de tama√±o</em> , el nuevo EDNS permite enviar mensajes UPD y m√°s largos).  La esencia del proceso es que si un mensaje DNS contiene nombres de dominio con los mismos subdominios de nivel superior (por ejemplo, <em>mail.yandex.ru</em> y <em>yandex.ru</em> ), en lugar de volver a especificar el nombre de dominio completo, el n√∫mero de bytes en el mensaje DNS desde el cual Contin√∫a leyendo el nombre de dominio.  Puede ser cualquier byte del mensaje DNS, no solo en el registro o secci√≥n actual, sino con la condici√≥n de que sea un byte de la longitud de la etiqueta de dominio.  No puede hacer referencia a la mitad de la marca.  Supongamos que hay un dominio <em>mail.yandex.ru</em> en el mensaje, luego, con la ayuda de la compresi√≥n, tambi√©n es posible designar los dominios "" <em>yandex.ru</em> , <em>ru</em> y root "(por supuesto, la ra√≠z es m√°s f√°cil de escribir sin compresi√≥n, pero es t√©cnicamente posible hacerlo con compresi√≥n), y aqu√≠ para hacer que <em>ndex.ru</em> no funcione.  Adem√°s, todos los nombres de dominio derivados terminar√°n en el dominio ra√≠z, es decir, escribir, por ejemplo, <em>mail.yandex</em> tambi√©n fallar√°. </p><br><p>  Un nombre de dominio puede: </p><br><ul><li>  ser completamente grabado sin compresi√≥n, </li><li>  comenzar desde un lugar que usa compresi√≥n </li><li>  comience con una o m√°s etiquetas sin compresi√≥n, y luego cambie a compresi√≥n, </li><li>  estar vac√≠o (para el dominio ra√≠z). </li></ul><br><p>  Por ejemplo, estamos compilando un mensaje DNS y ya hab√≠amos encontrado el nombre "dom3.example.com" en √©l, ahora necesitamos especificar "dom4.dom3.example.com".  En este caso, puede grabar la secci√≥n "dom4" sin compresi√≥n y luego cambiar a compresi√≥n, es decir, agregar un enlace a "dom3.example.com".  O viceversa, si se encontr√≥ previamente el nombre "dom4.dom3.example.com", para indicar "dom3.example.com" puede usar inmediatamente la compresi√≥n haciendo referencia a la etiqueta "dom3" en √©l.  Lo que no podemos hacer es, como ya se ha dicho, indicar la parte de 'dom4.dom3' a trav√©s de la compresi√≥n, porque el nombre debe terminar con una secci√≥n de nivel superior.  Si de repente necesita especificar segmentos desde el medio, entonces simplemente se indican sin compresi√≥n. </p><br><p>  Para simplificar, nuestro programa no sabe c√≥mo escribir nombres de dominio con compresi√≥n, solo puede leer.  El est√°ndar lo permite, la lectura debe implementarse necesariamente, la escritura es opcional.  T√©cnicamente, la lectura se implementa de esta manera: si los dos bits m√°s significativos de un byte de longitud contienen 1, entonces leemos el byte siguiente y tratamos estos dos bytes como un entero sin signo de 16 bits, con el orden de los bits Big Endian.  Descartamos los dos bits m√°s significativos (que contienen 1), leemos el n√∫mero de 14 bits resultante y seguimos leyendo el nombre de dominio del byte en el mensaje DNS debajo del n√∫mero correspondiente a este n√∫mero. </p><br><p>  El c√≥digo para la funci√≥n de lectura de nombres de dominio es el siguiente: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readDomainName</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">buf, startOffset, objReturnValue = {}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> currentByteIndex = startOffset; <span class="hljs-comment"><span class="hljs-comment">//    ,  DNS- ,      let initOctet = buf.readUInt8(currentByteIndex); let domain = ''; //      , ..       0, //  ,      // "the root domain name has no labels." (c) RFC-1035, p. 4.1.4. Message compression objReturnValue['endOffset'] = currentByteIndex; let lengthOctet = initOctet; while (lengthOctet &gt; 0) { //     var label; if (lengthOctet &gt;= 192) { //   :  0b1100 0000   const pointer = buf.readUInt16BE(currentByteIndex) - 49152; // 49152 === 0b1100 0000 0000 0000 === 192 * 256 const returnValue = {} label = readDomainName(buf, pointer, returnValue); domain += ('.' + label); objReturnValue['endOffset'] = currentByteIndex + 1; //      ,      break; } else { currentByteIndex++; label = buf.toString('ascii', currentByteIndex, currentByteIndex + lengthOctet); domain += ('.' + label); currentByteIndex += lengthOctet; lengthOctet = buf.readUInt8(currentByteIndex); objReturnValue['endOffset'] = currentByteIndex; } } return domain.substring(1); //    ‚Äî  "." }</span></span></code> </pre> <br><p>  <em>Listado 2. Lectura de nombres de dominio de una consulta DNS</em> </p><br><p>  C√≥digo completo para que la funci√≥n lea el registro DNS del b√∫fer binario: </p><br><div class="spoiler">  <b class="spoiler_title">Listado 3. Lectura de un registro DNS desde un b√∫fer binario</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseDnsMessageBytes</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">buf</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> msgFields = {}; <span class="hljs-comment"><span class="hljs-comment">// (c) RFC 1035 p. 4.1.1. Header section format msgFields['ID'] = buf.readUInt16BE(0); const byte_2 = buf.readUInt8(2); //  #2 (starting from 0) const mask_QR = 0b10000000; msgFields['QR'] = !!(byte_2 &amp; mask_QR); //  : 0 "false" =&gt; , 1 "true" =&gt;  const mask_Opcode = 0b01111000; const opcode = (byte_2 &amp; mask_Opcode) &gt;&gt;&gt; 3; //   (): 0, 1, 2,   msgFields['Opcode'] = opcode; const mask_AA = 0b00000100; msgFields['AA'] = !!(byte_2 &amp; mask_AA); const mask_TC = 0b00000010; msgFields['TC'] = !!(byte_2 &amp; mask_TC); const mask_RD = 0b00000001; msgFields['RD'] = !!(byte_2 &amp; mask_RD); const byte_3 = buf.readUInt8(3); //  #3 const mask_RA = 0b10000000; msgFields['RA'] = !!(byte_3 &amp; mask_RA); const mask_Z = 0b01110000; msgFields['Z'] = (byte_3 &amp; mask_Z) &gt;&gt;&gt; 4; //  0,  const mask_RCODE = 0b00001111; msgFields['RCODE'] = (byte_3 &amp; mask_RCODE); // 0 =&gt; no error; (dec) 1, 2, 3, 4, 5 - errors, see RFC msgFields['QDCOUNT'] = buf.readUInt16BE(4); //     Question,   0  1 msgFields['ANCOUNT'] = buf.readUInt16BE(6); //     Answer msgFields['NSCOUNT'] = buf.readUInt16BE(8); //     Authority msgFields['ARCOUNT'] = buf.readUInt16BE(10); //     Additional //    Question let currentByteIndex = 12; //  Question   12-  DNS- (c) RFC 1035 p. 4.1.2. Question section format msgFields['questions'] = []; for (let qdcount = 0; qdcount &lt; msgFields['QDCOUNT']; qdcount++) { const question = {}; const resultByteIndexObj = { endOffset: undefined }; const domain = readDomainName(buf, currentByteIndex, resultByteIndexObj); currentByteIndex = resultByteIndexObj.endOffset + 1; question['domainName'] = domain; question['qtype'] = buf.readUInt16BE(currentByteIndex); // 1 =&gt; "A" record currentByteIndex += 2; question['qclass'] = buf.readUInt16BE(currentByteIndex); // 1 =&gt; "IN" Internet currentByteIndex += 2; msgFields['questions'].push(question); } // (c) RFC 1035 p. 4.1.3. Resource record format //    (Resourse Records, RR)  Answer, Authority, Additional ['answer', 'authority', 'additional'].forEach(function(section, i, arr) { let msgFieldsName, countFieldName; switch(section) { case 'answer': msgFieldsName = 'answers'; countFieldName = 'ANCOUNT'; break; case 'authority': msgFieldsName = 'authorities'; countFieldName = 'NSCOUNT'; break; case 'additional': msgFieldsName = 'additionals'; countFieldName = 'ARCOUNT'; break; } msgFields[msgFieldsName] = []; for (let recordsCount = 0; recordsCount &lt; msgFields[countFieldName]; recordsCount++) { let record = {}; const objReturnValue = {}; const domain = readDomainName(buf, currentByteIndex, objReturnValue); currentByteIndex = objReturnValue['endOffset'] + 1; record['domainName'] = domain; record['type'] = buf.readUInt16BE(currentByteIndex); // 1 =&gt; "A" record currentByteIndex += 2; record['class'] = buf.readUInt16BE(currentByteIndex); // 1 =&gt; "IN" Internet currentByteIndex += 2; // TTL  4  record['ttl'] = buf.readUIntBE(currentByteIndex, 4); currentByteIndex += 4; record['rdlength'] = buf.readUInt16BE(currentByteIndex); currentByteIndex += 2; const rdataBinTempBuf = buf.slice(currentByteIndex, currentByteIndex + record['rdlength']); record['rdata_bin'] = Buffer.alloc(record['rdlength'], rdataBinTempBuf); if (record['type'] === 1 &amp;&amp; record['class'] === 1) { //      IPv4,      let ipStr = ''; for (ipv4ByteIndex = 0; ipv4ByteIndex &lt; 4; ipv4ByteIndex++) { ipStr += '.' + buf.readUInt8(currentByteIndex).toString(); currentByteIndex++; } record['IPv4'] = ipStr.substring(1); //    '.' } else { //    ,   currentByteIndex += record['rdlength']; } msgFields[msgFieldsName].push(record); } }); return msgFields; }</span></span></code> </pre> <br><p> <em> 3.  DNS-   </em> </p></div></div><br><p> ,       . ,     ,   ,    .   ,     DNS-,     ,   .  ,       . </p><br><p>  ,        - <code>server.on("message", () =&gt; {})</code>   1.   : </p><br><div class="spoiler"> <b class="spoiler_title"> 4.    DNS-</b> <div class="spoiler_text"><pre> <code class="javascript hljs">server.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (localReq, linfo) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dnsRequest = functions.parseDnsMessageBytes(localReq); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> question = dnsRequest.questions[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// currently, only one question per query is supported by DNS implementations let forgingHostParams = undefined; // ,         IP for (let i = 0; i &lt; config.requestsToForge.length; i++) { const requestToForge = config.requestsToForge[i]; const targetDomainName = requestToForge.hostName; if (functions.domainNameMatchesTemplate(question.domainName, targetDomainName) &amp;&amp; question.qclass === 1 &amp;&amp; question.qtype === 1) { forgingHostParams = requestToForge; break; } } //  ,    DNS-      if (!!forgingHostParams) { const forgeIp = forgingHostParams.ip; const answers = []; answers.push({ domainName: question.domainName, type: question.qtype, class: question.qclass, ttl: forgedRequestsTTL, rdlength: 4, rdata_bin: functions.ip4StringToBuffer(forgeIp), IPv4: forgeIp }); const localDnsResponse = { ID: dnsRequest.ID, QR: dnsRequest.QR, Opcode: dnsRequest.Opcode, AA: dnsRequest.AA, TC: false, // dnsRequest.TC, RD: dnsRequest.RD, RA: true, Z: dnsRequest.Z, RCODE: 0, // dnsRequest.RCODE, 0 - no errors, look in RFC-1035 for other error conditions QDCOUNT: dnsRequest.QDCOUNT, ANCOUNT: answers.length, NSCOUNT: dnsRequest.NSCOUNT, ARCOUNT: dnsRequest.ARCOUNT, questions: dnsRequest.questions, answers: answers } //     DNS-    const responseBuf = functions.composeDnsMessageBin(localDnsResponse); console.log('response composed for: ', localDnsResponse.questions[0]); server.send(responseBuf, linfo.port, linfo.address, (err, bytes) =&gt; {}); } // ,     DNS-,         else { //     DNS-  UDP,     const responseBuf = await functions.getRemoteDnsResponseBin(localReq, upstreamDnsIP, upstreamDnsPort); //        server.send(responseBuf, linfo.port, linfo.address, (err, bytes) =&gt; {}); //     DNS-  TLS,   , .  9 } });</span></span></code> </pre> <br><p> <em> 4.    DNS-</em> </p></div></div><br><h2 id="dobavlyaem-podderzhku-tls">   TLS </h2><br><p>        DNS-.    ,      DNS-   TLS (HTTPS    ).  DNS-  TLS     TCP,    ,   TLS    .          TCP,   RFC-7766 DNS Transport over TCP ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tools.ietf.org/html/rfc7766</a> ).    ,  :      TLS,   TCP   ( ,       DNS  TCP,      TLS-  TCP-,     ). </p><br><h3 id="ustanovka-tls-soedineniya">  TLS- </h3><br><p>  TLS-           ,       ,   .  ,         TLS-,       .  RFC-7858 -        : </p><br><pre> <code class="plaintext hljs">In order to amortize TCP and TLS connection setup costs, clients and servers SHOULD NOT immediately close a connection after each response. Instead, clients and servers SHOULD reuse existing connections for subsequent queries as long as they have sufficient resources. In some cases, this means that clients and servers may need to keep idle connections open for some amount of time. () https://tools.ietf.org/html/rfc7858#section-3.4</code> </pre> <br><p>       ,   TLS-,   ,     ,   ,   ,       .   ,        30 ,   ,      ,        DNS-.  30  ~  ~   ,   15  60 ,         .        ,         .   - . </p><br><p> TLS-     NodeJS.    ,    TLS-     : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tls = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'tls'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TLS_SOCKET_IDLE_TIMEOUT = <span class="hljs-number"><span class="hljs-number">30000</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    ,     TLS- function Module(connectionOptions, funcOnData, funcOnError, funcOnClose, funcOnEnd) { let socket; function connect() { socket = tls.connect(connectionOptions, () =&gt; { console.log('client connection established:', socket.authorized ? 'authorized' : 'unauthorized'); }); socket.on('data', funcOnData); // connection.on('end', () =&gt; {}); socket.on('close', (hasTransmissionError) =&gt; { //   ,     . //   ,     console.log('connection closed; transmission error:', hasTransmissionError); }); socket.on('end', () =&gt; { console.log('remote TLS server connection closed.') }); socket.on('error', (err) =&gt; { console.log('connection error:', err); console.log('\tmessage:', err.message); console.log('\tstack:', err.stack); }) socket.setTimeout(TLS_SOCKET_IDLE_TIMEOUT); socket.on('timeout', () =&gt; { console.log('socket idle timeout, disconnected.'); socket.end(); }); } this.write = function (dataBuf) { if (socket &amp;&amp; socket.writable) { //  ,     } else { connect(); } socket.write(dataBuf); } return this; } module.exports = Module;</span></span></code> </pre> <br><p> <em> 5. ,   TLS-</em> </p><br><p>       DNS-over-TLS ,   Google DNS.        ,               <code>socket = tls.connect(connectionOptions, () =&gt; {})</code> .     NodeJS: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://nodejs.org/api/tls.html#tls_tls_connect_options_callback</a> ,       . </p><br><p>  TLS-   : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> options = { <span class="hljs-attr"><span class="hljs-attr">port</span></span>: config.upstreamDnsTlsPort, <span class="hljs-comment"><span class="hljs-comment">//        host: config.upstreamDnsTlsHost } const onData = (data) =&gt; { //     , .       7 }; remoteTlsClient = new TlsClient(options, onData);</span></span></code> </pre> <br><p> <em> 6.  TLS-</em> </p><br><p>     ,        TCP-.   TCP/TLS-      DNS-,     ,    ,     ,   .    TCP (  TLS),  DNS-   512 ,    UDP (,  EDNS    UDP  ).  ,  DNS-    UDP,             .       <strong>onData()</strong>   6. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    DNS-,       TLS-   //    ,     2 ,       let dataCurrentPos = 0; try { while (dataCurrentPos &lt; data.length) { const respLen = data.readUInt16BE(dataCurrentPos); respBuf = data.slice(dataCurrentPos + 2, dataCurrentPos + 2 + respLen); const respData = functions.parseDnsMessageBytes(respBuf); const requestKey = functions.getRequestIdentifier(respData); const localResponseParams = localRequestsAwaiting.get(requestKey); localRequestsAwaiting.delete(requestKey); server.send(respBuf, localResponseParams.port, localResponseParams.address, (err, bytesNum) =&gt; {}); dataCurrentPos += 2 + respLen; } } catch (err) { console.error(err); //   ,     throw err; } };</span></span></code> </pre> <br><p> <em> 7.   TLS-   DNS-   6</em> </p><br><h3 id="poryadok-otvetov-ot-udalyonnogo-dns-servera">     DNS- </h3><br><p>  ,            ,     .   ,         ID     QNAME, QTYPE  QCLASS  <em>Question</em> : </p><br><pre> <code class="plaintext hljs">Since pipelined responses can arrive out of order, clients MUST match responses to outstanding queries on the same TLS connection using the Message ID. If the response contains a Question Section, the client MUST match the QNAME, QCLASS, and QTYPE fields. () https://tools.ietf.org/html/rfc7858#section-3.3</code> </pre> <br><p>     ,  ,    ,   ID   <em>Question</em> (   ,      ). </p><br><p>        UDP (.  4),    ,         -,    ,   UDP-     .        ,       DNS-,       .          ,       -.  ,         ,      UDP-         -.  ,  ,    . </p><br><p>      TLS,               .         (IP  ),    ,       . </p><br><p>        IP      "-".   ,    ,   ,     DNS-.   ,    ,         IP  ,     .        7: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//        const requestKey = functions.getRequestIdentifier(respData); //    IP    ,   const localResponseParams = localRequestsAwaiting.get(requestKey); localRequestsAwaiting.delete(requestKey); //      IP   server.send(respBuf, localResponseParams.port, localResponseParams.address, (err, bytesNum) =&gt; {});</span></span></code> </pre> <br><p> <em> 8.        7</em> </p><br><p>      TLS-: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,     const localReqParams = { address: linfo.address, port: linfo.port }; //        const requestKey = functions.getRequestIdentifier(dnsRequest); //       localRequestsAwaiting.set(requestKey, localReqParams); //       ,      const lenBuf = Buffer.alloc(2); lenBuf.writeUInt16BE(localReq.length); const prepReqBuf = Buffer.concat([lenBuf, localReq], 2 + localReq.length); remoteTlsClient.write(prepReqBuf); //  RFC-7766 p.8, 2               </span></span></code> </pre> <br><p> <em> 9.    DNS-  TLS- (  .  4)</em> </p><br><h2 id="chtenie-konfiguracii-iz-fayla-i-eyo-obnovlenie">        </h2><br><p>   ,   ,      .     JSON,    ,   NodeJS   JSON-      .  JSON ‚Äî      ,      .  ,    JSON-  "comment" (  )       . ,  ,  ,    ,  .  ,        ,     .      ,   -  ,    ,            NodeJS.    ,   ,     .  ,         ,       ;   ,   .           ,     - . </p><br><div class="spoiler"> <b class="spoiler_title"> 10.     </b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CONFIG_FILE_PATH = path.resolve(<span class="hljs-string"><span class="hljs-string">'./config.json'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Module</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// config  -,       . //    config        , //         . ,    : // const conf = config; //   conf     ,    : // const requestsToForge = config.requestsToForge; //    , requestsToForge   . const config = {}; Object.defineProperty(this, 'config', { get() { return config; }, enumerable: true }) this.initConfig = async function() { const fileContents = await readConfigFile(CONFIG_FILE_PATH); console.log('initConfig:'); console.log(fileContents); console.log('fileContents logged ^^'); const parsedConfigData = parseConfig(fileContents); Object.assign(config, parsedConfigData); }; async function readConfigFile(configPath) { const promise = new Promise((resolve, reject) =&gt; { fs.readFile(configPath, { encoding: 'utf8', flag: 'r' }, (err, data) =&gt; { if (err) { console.log('readConfigFile err to throw'); throw err; } resolve(data); }); }) .then( fileContents =&gt; { return fileContents; } ) .catch(err =&gt; { console.log('readConfigFile error: ', err); }); return promise; } function parseConfig(fileContents) { const configData = JSON.parse(fileContents); return configData; } //   ,       . //  Windows,    fs.watch     , //      ,   configReadInProgress let configReadInProgress = false; fs.watch(CONFIG_FILE_PATH, async () =&gt; { if(!configReadInProgress) { configReadInProgress = true; console.log('===== config changed, run initConfig() ====='); try { await this.initConfig(); } catch (err) { console.log('===== error initConfig(), skip =====,', err); configReadInProgress = false; } configReadInProgress = false; } else { console.log('===== config changed, initConfig() already running, skip ====='); } }); } let instance; async function getInstance() { if(!instance) { instance = new Module(); await instance.initConfig(); } return instance; } module.exports = getInstance;</span></span></code> </pre> <br><p> <em> 10.     </em> </p></div></div><br><h2 id="itogo">  Total </h2><br><p>    DNS-  NodeJS,     <em>npm</em>   .    ,        ,   ,  ,         . </p><br><p> <strong><a href="">   GitHub</a></strong> </p><br><h3 id="istochniki"> : </h3><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RFC-1035</a> DOMAIN NAMES ‚Äî IMPLEMENTATION AND SPECIFICATION </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RFC-7858</a> Specification for DNS over Transport Layer Security (TLS) </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RFC-7766</a> DNS Transport over TCP ‚Äî Implementation Requirements </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://stackoverflow.com/questions/4082081/requesting-a-and-aaaa-records-in-single-dns-query/4083071#4083071</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/440050/">https://habr.com/ru/post/440050/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../440036/index.html">Mecanograf√≠a t√°ctil</a></li>
<li><a href="../440040/index.html">En desarrollo, cada uno por s√≠ mismo. Pero a veces conduce a un callej√≥n sin salida.</a></li>
<li><a href="../440044/index.html">Historia detallada de Qualcomm</a></li>
<li><a href="../440046/index.html">Lecci√≥n abierta "Crear clientes REST en Spring"</a></li>
<li><a href="../440048/index.html">M√©tricas favoritas: 5 indicadores que todo equipo de ventas debe seguir</a></li>
<li><a href="../440052/index.html">An√°lisis est√°tico de BIOS / UEFI o c√≥mo obtener un gr√°fico de dependencia</a></li>
<li><a href="../440054/index.html">Transfiera el servicio web a Yandex.Cloud con AWS</a></li>
<li><a href="../440058/index.html">Problemas de Internet e Informe de disponibilidad 2018‚Äì2019</a></li>
<li><a href="../440060/index.html">TensorFlow en Apache Ignite</a></li>
<li><a href="../440062/index.html">Planificaci√≥n con mucho gusto. C√≥mo configuramos procesos sin gerentes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>