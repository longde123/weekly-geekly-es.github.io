<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî® üë¢ üíï Kubernetes 1.12: Ein √úberblick √ºber die wichtigsten Innovationen üßúüèº ü•£ üë©üèª‚Äç‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute ist der 27. September, was bedeutet, dass wir w√§hrend der Arbeitszeit (gem√§√ü der US-Zeitzone) mit der n√§chsten Ver√∂ffentlichung von Kubernetes r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kubernetes 1.12: Ein √úberblick √ºber die wichtigsten Innovationen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/424331/"><img src="https://habrastorage.org/files/48b/c2d/ec0/48bc2dec061e42928e98c92cbbadf968.png"><br><br>  Heute ist der 27. September, was <a href="">bedeutet,</a> dass wir w√§hrend der Arbeitszeit (gem√§√ü der US-Zeitzone) mit der n√§chsten Ver√∂ffentlichung von Kubernetes rechnen k√∂nnen - 1.12 (die offizielle Ank√ºndigung wird jedoch manchmal verz√∂gert).  Im Allgemeinen ist es an der Zeit, die glorreiche Tradition fortzusetzen und √ºber die wichtigsten √Ñnderungen zu berichten, die wir auf der Grundlage √∂ffentlicher Informationen aus dem Projekt <a href="">vornehmen werden</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes bietet Tracking-Tabelle</a> , <a href="">CHANGELOG-1.12</a> , zahlreiche Probleme, Pull-Anfragen und Designvorschl√§ge.  Was ist neu in K8s 1.12? <a name="habracut"></a><br><br><h2>  Lagereinrichtungen </h2><br>  Wenn Sie eine Sache herausgreifen, die unter allen Problemen im Zusammenhang mit der Ver√∂ffentlichung von Kubernetes 1.12 h√§ufiger als jede andere erw√§hnt wird, ist dies m√∂glicherweise die <b>Container Storage Interface (CSI)</b> , √ºber die wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bereits neulich geschrieben haben</a> .  Beginnen wir aus diesem Grund mit den √Ñnderungen an der Speicherunterst√ºtzung. <br><br>  Daher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">haben</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CSI-Plugins den</a> Beta-Status <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beibehalten</a> und werden voraussichtlich f√ºr die n√§chste Version von Kubernetes (1.13) stabil sein.  Was ist dann neu in der CSI-Unterst√ºtzung? <br><br>  Im Februar dieses Jahres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">begannen die</a> Arbeiten am <b>Topologiekonzept</b> in der CSI-Spezifikation.  Kurz gesagt, Topologie sind Informationen zur Clustersegmentierung (z. B. nach ‚ÄûRacks‚Äú f√ºr lokale Installationen oder nach ‚ÄûRegionen‚Äú und ‚ÄûZonen‚Äú f√ºr Cloud-Umgebungen), die Orchestrierungssysteme kennen und ber√ºcksichtigen m√ºssen.  Warum?  Von Speicheranbietern zugewiesene Volumes sind nicht unbedingt im gesamten Cluster gleicherma√üen zug√§nglich. Daher sind Kenntnisse der Topologie erforderlich, um Ressourcen effizient zu planen und Bereitstellungsentscheidungen zu treffen. <br><br>  Das Ergebnis der Entstehung von Topologien in CSI ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">angenommen</a> in der Spezifikation am 1. Juni) war ihre Unterst√ºtzung in Kubernetes 1.12: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterst√ºtzung als solche</a> (Registrierung der vom CSI-Treiber gemeldeten Informationen zur Volumentopologie) - Alpha-Version; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterst√ºtzung f√ºr Topologien bei der dynamischen Bereitstellung</a> (siehe die ausf√ºhrliche Dokumentation im Entwurfsvorschlag mit dem Namen " <a href="">Volume Topology Aware Scheduling</a> ") - sofortige Beta-Version; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterst√ºtzung der GCE PD-Topologie</a> - Alpha-Version; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AWS EBS Topology Support</a> - Beta. </li></ul><br>  Dies endet jedoch nicht mit CSI-bezogenen Updates.  Eine weitere wichtige Neuerung in der Version Kubernetes 1.12 ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Unterst√ºtzung von Snapshots</b> f√ºr CSI</a> (im Alpha-Status).  Schnappsch√ºsse f√ºr Volumes als solche wurden in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Version von K8s 1.8 ver√∂ffentlicht</a> .  Die Hauptimplementierung, zu der der Controller und der Provisioner (zwei separate Bin√§rdateien) geh√∂ren, wurde beschlossen, in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein externes Repository √ºbertragen zu werden</a> .  Seitdem wurden Volumes von GCE PD, AWS EBS, OpenStack Cinder, GlusterFS und Kubernetes <code>hostPath</code> . <br><br>  Der neue <a href="">Entwurfsvorschlag</a> zielt darauf ab, ‚Äûdiese Initiative fortzusetzen, indem Snapshot-Unterst√ºtzung f√ºr CSI-Volume-Treiber hinzugef√ºgt wird‚Äú (Snapshot-Unterst√ºtzung in der CSI-Spezifikation wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> beschrieben).  Da Kubernetes das Prinzip einh√§lt, einen Mindestsatz an Funktionen in die Kern-API aufzunehmen, verwendet diese Implementierung (wie bei Snapshots im Volume Snapshot Controller) CRD ( <code>CustomResourceDefinitions</code> ). <br><br>  Und ein paar neue Funktionen f√ºr CSI-Treiber: <br><br><ul><li>  Die Alpha-Version der F√§higkeit des Treibers, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sich</a> in der Kubernetes-API zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">registrieren</a> (um Benutzern das Auffinden der im Cluster installierten Treiber zu erleichtern und es den Treibern zu erm√∂glichen, die Interaktionsprozesse von Kubernetes mit ihnen zu beeinflussen); </li><li>  Die Alpha-Version der F√§higkeit des Treibers <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, Informationen √ºber das Laufwerk zu erhalten</a> , das das Volume √ºber <code>NodePublish</code> </li></ul><br>  In der letzten Version von Kubernetes wurde der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mechanismus zur dynamischen Begrenzung von</a> Volumes auf Knoten eingef√ºhrt, der von Alpha auf Beta verschoben wurde. Sie haben es erraten, Unterst√ºtzung f√ºr CSI sowie Azure. <br><br>  Schlie√ülich wird die Funktion zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weitergabe</a> des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mount-Namespace</a> , mit der Sie das Volume als <code>rshared</code> (sodass alle gemounteten Containerverzeichnisse auf dem Host sichtbar sind) und in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Version 1.10 von K8s</a> einen Beta-Status hat, als stabil deklariert. <br><br><h2>  Planer </h2><br>  Im Scheduler verbessert Kubernetes 1.12 die Leistung dank der Alpha-Version des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Suchbeschr√§nkungsmechanismus</a> in einem Knotencluster, der zum Planen von Herden geeignet ist <i>(m√∂gliche Knoten)</i> .  Fr√ºher √ºberpr√ºfte der <i>Kube-Scheduler</i> bei jedem Versuch, jeden Pod zu planen, die Verf√ºgbarkeit aller Knoten und √ºbergab sie zur Auswertung. Jetzt findet der Scheduler nur eine bestimmte Anzahl von ihnen und beendet dann seine Arbeit.  Gleichzeitig sieht der Mechanismus die obligatorische Auswahl von Knoten aus verschiedenen Regionen und Zonen sowie die Notwendigkeit vor, verschiedene Knoten in verschiedenen Planungszyklen anzuzeigen (w√§hlen Sie nicht die ersten 100 Knoten bei jedem Start aus).  Die Entscheidung zur Implementierung dieses Mechanismus wurde unter Ber√ºcksichtigung der Ergebnisse der Analyse der Daten zur Leistung des Schedulers getroffen (wenn das 90. Perzentil eine Zeit von 30 ms f√ºr einen Herd zeigte, dann das 99. Perzentil bereits 60 ms). <br><br>  Dar√ºber hinaus sind die folgenden Funktionen des Schedulers zur Beta-Version gereift: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Taint-Knoten nach Bedingung</a> , der in K8s 1.8 angezeigt wurde und das Markieren eines Knotens mit einem bestimmten Status (f√ºr weitere Aktionen) erm√∂glicht, wenn bestimmte Ereignisse auftreten: Jetzt erstellt der Lebenszyklus-Controller des Knotens automatisch Taints, und der Scheduler √ºberpr√ºft sie (anstelle von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bedingungen</a> ). </li><li>  <code>DaemonSet</code> in <code>DaemonSet</code> mit dem <i>Kube-Scheduler</i> (anstelle des <code>DaemonSet</code> Controllers): Standardm√§√üig wurde sie ebenfalls aktiviert. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Angeben einer Priorit√§tsklasse</a> in <code>ResourceQuota</code> . </li></ul><br><h2>  Clusterknoten </h2><br>  Eine interessante Neuerung war das Erscheinungsbild (im Status der Alpha-Version) von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code><b>RuntimeClass</b></code></a> - einer neuen Ressource auf Cluster-Ebene, die die Parameter der <i>Container-Laufzeit (Container-Laufzeit)</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code><b>RuntimeClass</b></code></a> .  <code>RuntimeClasses</code> werden den Pods √ºber dasselbe Feld in <code>PodSpec</code> und implementieren die Unterst√ºtzung f√ºr die Verwendung mehrerer ausf√ºhrbarer Umgebungen innerhalb eines Clusters oder Knotens.  Warum? <br><br><blockquote>  <i>‚ÄûDas Interesse an der Verwendung unterschiedlicher Laufzeiten in einem Cluster w√§chst.</i>  <i>Hauptmotiv daf√ºr sind derzeit die Sandk√§sten und der Wunsch der Kata- und gVisor-Container, sich in Kubernetes zu integrieren.</i>  <i>Andere Laufzeitmodelle wie Windows-Container oder sogar Remote-Laufzeitumgebungen werden in Zukunft ebenfalls Unterst√ºtzung ben√∂tigen.</i>  <i>RuntimeClass bietet eine M√∂glichkeit, zwischen verschiedenen in einem Cluster konfigurierten Laufzeiten zu w√§hlen und deren Eigenschaften zu √§ndern (sowohl vom Cluster als auch vom Benutzer). ‚Äú</i> </blockquote><br>  Um zwischen den vordefinierten Konfigurationen zu w√§hlen, wird der <a href=""><code>RuntimeHandler</code></a> an das CRI (Container Runtime Interface) √ºbergeben, das die aktuellen Anmerkungen des Herdes ersetzen soll: <br><br><img src="https://habrastorage.org/webt/wm/jm/yh/wmjmyh4_fivl7msyzb0ghzeqa68.png"><br><br>  Und die Konfiguration in Containerd f√ºr Kata-Runtime sieht ungef√§hr so ‚Äã‚Äãaus: <br><br><pre> <code class="plaintext hljs">[plugins.cri.containerd.kata-runtime] runtime_type = "io.containerd.runtime.v1.linux" runtime_engine = "/opt/kata/bin/kata-runtime" runtime_root = ""</code> </pre> <br>  Das <code>RuntimeClass</code> Kriterium f√ºr die Alpha-Version ist eine erfolgreiche <a href="">CRI-Validierung</a> . <br><br>  Dar√ºber hinaus ist der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mechanismus zum Registrieren lokaler Plug-Ins</a> (einschlie√ülich CSI) in <i>Kubelet</i> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>shareProcessNamespace</code></a> (die Funktion ist standardm√§√üig aktiviert) auf den Status einer Beta-Version angewachsen. <br><br><h2>  Netzwerke </h2><br>  Die Hauptnachricht im Netzwerkteil von Kubernetes ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alpha-Version der</a> <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SCTP-</a> Unterst√ºtzung</b> (Stream Control Transmission Protocol).  Dieses Telekommunikationsprotokoll wurde in den <i>Bereichen</i> <i>Pod</i> , <i>Service</i> , <i>Endpoint</i> und <i>NetworkPolicy unterst√ºtzt</i> und geh√∂rt nun zu TCP und UDP.  Mit der neuen Funktion ‚ÄûAnwendungen, die SCTP als L4-Protokoll f√ºr ihre Schnittstellen ben√∂tigen, wird die Bereitstellung auf Kubernetes-Clustern einfacher.  Beispielsweise k√∂nnen sie die auf <i>kube-dns</i> basierende <i>Diensterkennung verwenden</i> , und ihre Interaktion wird √ºber <i>NetworkPolicy</i> gesteuert. "  Implementierungsdetails finden Sie in <a href="">diesem Dokument</a> . <br><br>  Zwei in K8s 1.8 eingef√ºhrte Netzwerkfunktionen haben ebenfalls einen stabilen Status erreicht: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterst√ºtzung f√ºr Richtlinien</a> f√ºr ausgehenden <code>EgressRules</code> Verkehr in der NetworkPolicy-API und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anwendung von</a> CIDR- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Regeln</a> f√ºr Quelle / Ziel √ºber <code>ipBlockRule</code> . <br><br><h2>  Skalieren </h2><br>  Zu den Verbesserungen des Horizontal Pod Autoscaler geh√∂ren: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aktualisierter Algorithmus</a> zum schnelleren Erreichen der richtigen Gr√∂√üe (sofort Alpha und Beta), f√ºr weitere Details lesen Sie den <a href="">neuen Abschnitt der Dokumentation</a> ; </li><li>  Entwicklung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">benutzerdefinierten / benutzerdefinierten Metriken</a> , deren zweite Beta eine neu gestaltete API und Unterst√ºtzung f√ºr Label-Selektoren erhielt. </li></ul><br>  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vertikale Skalierung der Herde</a> , bei der vor Erreichen der Beta-Version keine Benutzertests durchgef√ºhrt wurden, steht nicht still.  Die Autoren hielten es f√ºr ausreichend f√ºr die Ver√∂ffentlichung von K8s 1.12 und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erinnern daran,</a> dass diese Funktion eher eine Erg√§nzung zu Kubernetes ist (nicht im Kernel enthalten).  Die gesamte Entwicklung wird in einem separaten Repository durchgef√ºhrt, in dem die Beta-Version zeitlich auf die Ver√∂ffentlichung von Kubernetes abgestimmt wird. <br><br><img src="https://habrastorage.org/webt/sl/0e/je/sl0ejeaihoybtqm8khj5y_tkffa.png"><br>  <i>VPA-Workflow (Vertical Pod Autoscaler) f√ºr Kubernetes</i> <br><br>  Schlie√ülich enth√§lt K8s 1.12 (in Alpha-Form) die Ergebnisse der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arbeiten</a> zur "Vereinfachung der Installation mit <code>ComponentConfig</code> " (als Teil des Sig-Cluster-Lebenszyklus), die seit fast zwei Jahren durchgef√ºhrt werden.  Leider ist der Zugriff auf das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokument</a> mit den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwurfsvorschl√§gen</a> mit Details aus irgendeinem Grund (ein einfaches Versehen?) F√ºr anonyme Benutzer gesperrt. <br><br><h2>  Andere √Ñnderungen </h2><br><h3>  API </h3><br>  In der API-Maschinengruppe sind zwei neue Funktionen implementiert: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code> dry-run</code></a> f√ºr Apiserver (Alpha-Version), der die Validierung und Verarbeitung von Anforderungen imitiert; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ressourcenkontingent-API</a> (sofort Beta), die <b>standardm√§√üig begrenzte Ressourcen</b> definiert (anstelle des aktuellen Verhaltens, wenn der Ressourcenverbrauch unbegrenzt ist, wenn kein Kontingent festgelegt ist). </li></ul><br><h3>  Azure </h3><br>  F√ºr stabil erkl√§rt: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterst√ºtzung f√ºr</a> Azure Virtual Machine Scale Sets (VMSS); </li><li>  Azure- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterst√ºtzung</a> in Cluster-Autoscaler. </li></ul><br>  Die ersten Implementierungen (Alpha-Versionen) werden hinzugef√ºgt: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterst√ºtzung f√ºr</a> Azure-Verf√ºgbarkeitszonen </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterst√ºtzung f√ºr</a> Knoten wie RG ( <a href="">Cross Resource Group</a> ) und nicht verwaltete Knoten (On-Prem). </li></ul><br><h3>  Kubectl </h3><br><ul><li>  Es wurde eine Alpha-Version des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>aktualisierten Plug-In-Mechanismus</b></a> implementiert, mit der Sie neue Befehle hinzuf√ºgen oder vorhandene Unterbefehle einer beliebigen Verschachtelungsebene neu schreiben k√∂nnen.  Es √§hnelt Git und betrachtet ausf√ºhrbare Dateien, die mit <code>kubectl-</code> im <code>$PATH</code> des Benutzers beginnen.  Weitere Einzelheiten finden Sie im <a href="">Entwurfsvorschlag</a> . </li><li>  Eine Beta-Version der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Idee, das</a> <code>pkg/kubectl/genericclioptions</code> von kubectl in ein unabh√§ngiges Repository zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">isolieren,</a> wurde implementiert. </li><li>  Die <i>serverseitige Druckfunktion</i> wurde f√ºr stabil erkl√§rt. </li></ul><br><h3>  Andere </h3><br><ul><li>  Die Alpha-Version des neuen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>TTL-After-Finish-</b></a> Mechanismus, mit dem die Lebensdauer von <i>Jobs</i> und <i>Pods begrenzt werden soll, deren</i> Ausf√ºhrung abgeschlossen ist, wird <i>vorgestellt</i> .  Nach Ablauf der angegebenen TTL werden Objekte automatisch bereinigt, ohne dass ein Benutzereingriff erforderlich ist. </li><li>  Die Generierung eines privaten Schl√ºssels und eines CSR (TLS Bootstrap) zum Signieren eines Zertifikats auf Clusterebene in <i>Kubelet wird</i> als stabil deklariert. </li><li>  Die Rotation des Server-TLS-Zertifikats in <i>Kubelet</i> ging in den Beta-Status √ºber. </li></ul><br><h2>  PS </h2><br>  Lesen Sie auch in unserem Blog: <br><br><ul><li>  ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes 1.11: Ein √úberblick √ºber wichtige Innovationen</a> ‚Äú; </li><li>  "Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Integration von Containerd in Kubernetes, die Docker ersetzt, ist produktionsbereit</a> "; </li><li>  ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes 1.10: √úberblick √ºber wichtige Innovationen</a> ‚Äú; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes 1.9: Ein √úberblick √ºber wichtige Innovationen</a> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vier CNCF-Releases 1.0 und wichtige Ank√ºndigungen zu Kubernetes mit der KubeCon 2017</a> "; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes 1.8: Ein √úberblick √ºber wichtige Innovationen</a> </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Docker 17.06 und Kubernetes 1.7: Schl√ºsselinnovationen</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424331/">https://habr.com/ru/post/de424331/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424321/index.html">NetFlow billig und w√ºtend machen</a></li>
<li><a href="../de424323/index.html">Ein Beispiel f√ºr die Arbeit mit der ICE-Methode aus dem Produktmanager von Google und Microsoft</a></li>
<li><a href="../de424325/index.html">Training Splunk - ein Trainingszentrum in Russland</a></li>
<li><a href="../de424327/index.html">Zuckerberg-Fonds: Wie man optische Technologie und Biomedizin ‚Äûfindet‚Äú</a></li>
<li><a href="../de424329/index.html">Nehmen und tun: wie man Programmierung und Entwicklung einpumpt</a></li>
<li><a href="../de424333/index.html">Meine Erfahrung mit Dating und der Arbeit mit Robot Framework</a></li>
<li><a href="../de424335/index.html">Lass es Licht sein</a></li>
<li><a href="../de424337/index.html">Ruby-Code: kompetent, sch√∂n und effizient. Beispiel f√ºr Anf√§nger</a></li>
<li><a href="../de424339/index.html">Tandem des Autors und Experten: Wie macht man es effektiv?</a></li>
<li><a href="../de424341/index.html">Ulme. Bequem und umst√§ndlich. Zusammensetzung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>