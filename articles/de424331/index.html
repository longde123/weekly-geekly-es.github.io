<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔨 👢 💕 Kubernetes 1.12: Ein Überblick über die wichtigsten Innovationen 🧜🏼 🥣 👩🏻‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute ist der 27. September, was bedeutet, dass wir während der Arbeitszeit (gemäß der US-Zeitzone) mit der nächsten Veröffentlichung von Kubernetes r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kubernetes 1.12: Ein Überblick über die wichtigsten Innovationen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/424331/"><img src="https://habrastorage.org/files/48b/c2d/ec0/48bc2dec061e42928e98c92cbbadf968.png"><br><br>  Heute ist der 27. September, was <a href="">bedeutet,</a> dass wir während der Arbeitszeit (gemäß der US-Zeitzone) mit der nächsten Veröffentlichung von Kubernetes rechnen können - 1.12 (die offizielle Ankündigung wird jedoch manchmal verzögert).  Im Allgemeinen ist es an der Zeit, die glorreiche Tradition fortzusetzen und über die wichtigsten Änderungen zu berichten, die wir auf der Grundlage öffentlicher Informationen aus dem Projekt <a href="">vornehmen werden</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes bietet Tracking-Tabelle</a> , <a href="">CHANGELOG-1.12</a> , zahlreiche Probleme, Pull-Anfragen und Designvorschläge.  Was ist neu in K8s 1.12? <a name="habracut"></a><br><br><h2>  Lagereinrichtungen </h2><br>  Wenn Sie eine Sache herausgreifen, die unter allen Problemen im Zusammenhang mit der Veröffentlichung von Kubernetes 1.12 häufiger als jede andere erwähnt wird, ist dies möglicherweise die <b>Container Storage Interface (CSI)</b> , über die wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bereits neulich geschrieben haben</a> .  Beginnen wir aus diesem Grund mit den Änderungen an der Speicherunterstützung. <br><br>  Daher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">haben</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CSI-Plugins den</a> Beta-Status <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beibehalten</a> und werden voraussichtlich für die nächste Version von Kubernetes (1.13) stabil sein.  Was ist dann neu in der CSI-Unterstützung? <br><br>  Im Februar dieses Jahres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">begannen die</a> Arbeiten am <b>Topologiekonzept</b> in der CSI-Spezifikation.  Kurz gesagt, Topologie sind Informationen zur Clustersegmentierung (z. B. nach „Racks“ für lokale Installationen oder nach „Regionen“ und „Zonen“ für Cloud-Umgebungen), die Orchestrierungssysteme kennen und berücksichtigen müssen.  Warum?  Von Speicheranbietern zugewiesene Volumes sind nicht unbedingt im gesamten Cluster gleichermaßen zugänglich. Daher sind Kenntnisse der Topologie erforderlich, um Ressourcen effizient zu planen und Bereitstellungsentscheidungen zu treffen. <br><br>  Das Ergebnis der Entstehung von Topologien in CSI ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">angenommen</a> in der Spezifikation am 1. Juni) war ihre Unterstützung in Kubernetes 1.12: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterstützung als solche</a> (Registrierung der vom CSI-Treiber gemeldeten Informationen zur Volumentopologie) - Alpha-Version; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterstützung für Topologien bei der dynamischen Bereitstellung</a> (siehe die ausführliche Dokumentation im Entwurfsvorschlag mit dem Namen " <a href="">Volume Topology Aware Scheduling</a> ") - sofortige Beta-Version; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterstützung der GCE PD-Topologie</a> - Alpha-Version; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AWS EBS Topology Support</a> - Beta. </li></ul><br>  Dies endet jedoch nicht mit CSI-bezogenen Updates.  Eine weitere wichtige Neuerung in der Version Kubernetes 1.12 ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Unterstützung von Snapshots</b> für CSI</a> (im Alpha-Status).  Schnappschüsse für Volumes als solche wurden in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Version von K8s 1.8 veröffentlicht</a> .  Die Hauptimplementierung, zu der der Controller und der Provisioner (zwei separate Binärdateien) gehören, wurde beschlossen, in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein externes Repository übertragen zu werden</a> .  Seitdem wurden Volumes von GCE PD, AWS EBS, OpenStack Cinder, GlusterFS und Kubernetes <code>hostPath</code> . <br><br>  Der neue <a href="">Entwurfsvorschlag</a> zielt darauf ab, „diese Initiative fortzusetzen, indem Snapshot-Unterstützung für CSI-Volume-Treiber hinzugefügt wird“ (Snapshot-Unterstützung in der CSI-Spezifikation wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> beschrieben).  Da Kubernetes das Prinzip einhält, einen Mindestsatz an Funktionen in die Kern-API aufzunehmen, verwendet diese Implementierung (wie bei Snapshots im Volume Snapshot Controller) CRD ( <code>CustomResourceDefinitions</code> ). <br><br>  Und ein paar neue Funktionen für CSI-Treiber: <br><br><ul><li>  Die Alpha-Version der Fähigkeit des Treibers, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sich</a> in der Kubernetes-API zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">registrieren</a> (um Benutzern das Auffinden der im Cluster installierten Treiber zu erleichtern und es den Treibern zu ermöglichen, die Interaktionsprozesse von Kubernetes mit ihnen zu beeinflussen); </li><li>  Die Alpha-Version der Fähigkeit des Treibers <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, Informationen über das Laufwerk zu erhalten</a> , das das Volume über <code>NodePublish</code> </li></ul><br>  In der letzten Version von Kubernetes wurde der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mechanismus zur dynamischen Begrenzung von</a> Volumes auf Knoten eingeführt, der von Alpha auf Beta verschoben wurde. Sie haben es erraten, Unterstützung für CSI sowie Azure. <br><br>  Schließlich wird die Funktion zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weitergabe</a> des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mount-Namespace</a> , mit der Sie das Volume als <code>rshared</code> (sodass alle gemounteten Containerverzeichnisse auf dem Host sichtbar sind) und in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Version 1.10 von K8s</a> einen Beta-Status hat, als stabil deklariert. <br><br><h2>  Planer </h2><br>  Im Scheduler verbessert Kubernetes 1.12 die Leistung dank der Alpha-Version des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Suchbeschränkungsmechanismus</a> in einem Knotencluster, der zum Planen von Herden geeignet ist <i>(mögliche Knoten)</i> .  Früher überprüfte der <i>Kube-Scheduler</i> bei jedem Versuch, jeden Pod zu planen, die Verfügbarkeit aller Knoten und übergab sie zur Auswertung. Jetzt findet der Scheduler nur eine bestimmte Anzahl von ihnen und beendet dann seine Arbeit.  Gleichzeitig sieht der Mechanismus die obligatorische Auswahl von Knoten aus verschiedenen Regionen und Zonen sowie die Notwendigkeit vor, verschiedene Knoten in verschiedenen Planungszyklen anzuzeigen (wählen Sie nicht die ersten 100 Knoten bei jedem Start aus).  Die Entscheidung zur Implementierung dieses Mechanismus wurde unter Berücksichtigung der Ergebnisse der Analyse der Daten zur Leistung des Schedulers getroffen (wenn das 90. Perzentil eine Zeit von 30 ms für einen Herd zeigte, dann das 99. Perzentil bereits 60 ms). <br><br>  Darüber hinaus sind die folgenden Funktionen des Schedulers zur Beta-Version gereift: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Taint-Knoten nach Bedingung</a> , der in K8s 1.8 angezeigt wurde und das Markieren eines Knotens mit einem bestimmten Status (für weitere Aktionen) ermöglicht, wenn bestimmte Ereignisse auftreten: Jetzt erstellt der Lebenszyklus-Controller des Knotens automatisch Taints, und der Scheduler überprüft sie (anstelle von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bedingungen</a> ). </li><li>  <code>DaemonSet</code> in <code>DaemonSet</code> mit dem <i>Kube-Scheduler</i> (anstelle des <code>DaemonSet</code> Controllers): Standardmäßig wurde sie ebenfalls aktiviert. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Angeben einer Prioritätsklasse</a> in <code>ResourceQuota</code> . </li></ul><br><h2>  Clusterknoten </h2><br>  Eine interessante Neuerung war das Erscheinungsbild (im Status der Alpha-Version) von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code><b>RuntimeClass</b></code></a> - einer neuen Ressource auf Cluster-Ebene, die die Parameter der <i>Container-Laufzeit (Container-Laufzeit)</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code><b>RuntimeClass</b></code></a> .  <code>RuntimeClasses</code> werden den Pods über dasselbe Feld in <code>PodSpec</code> und implementieren die Unterstützung für die Verwendung mehrerer ausführbarer Umgebungen innerhalb eines Clusters oder Knotens.  Warum? <br><br><blockquote>  <i>„Das Interesse an der Verwendung unterschiedlicher Laufzeiten in einem Cluster wächst.</i>  <i>Hauptmotiv dafür sind derzeit die Sandkästen und der Wunsch der Kata- und gVisor-Container, sich in Kubernetes zu integrieren.</i>  <i>Andere Laufzeitmodelle wie Windows-Container oder sogar Remote-Laufzeitumgebungen werden in Zukunft ebenfalls Unterstützung benötigen.</i>  <i>RuntimeClass bietet eine Möglichkeit, zwischen verschiedenen in einem Cluster konfigurierten Laufzeiten zu wählen und deren Eigenschaften zu ändern (sowohl vom Cluster als auch vom Benutzer). “</i> </blockquote><br>  Um zwischen den vordefinierten Konfigurationen zu wählen, wird der <a href=""><code>RuntimeHandler</code></a> an das CRI (Container Runtime Interface) übergeben, das die aktuellen Anmerkungen des Herdes ersetzen soll: <br><br><img src="https://habrastorage.org/webt/wm/jm/yh/wmjmyh4_fivl7msyzb0ghzeqa68.png"><br><br>  Und die Konfiguration in Containerd für Kata-Runtime sieht ungefähr so ​​aus: <br><br><pre> <code class="plaintext hljs">[plugins.cri.containerd.kata-runtime] runtime_type = "io.containerd.runtime.v1.linux" runtime_engine = "/opt/kata/bin/kata-runtime" runtime_root = ""</code> </pre> <br>  Das <code>RuntimeClass</code> Kriterium für die Alpha-Version ist eine erfolgreiche <a href="">CRI-Validierung</a> . <br><br>  Darüber hinaus ist der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mechanismus zum Registrieren lokaler Plug-Ins</a> (einschließlich CSI) in <i>Kubelet</i> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>shareProcessNamespace</code></a> (die Funktion ist standardmäßig aktiviert) auf den Status einer Beta-Version angewachsen. <br><br><h2>  Netzwerke </h2><br>  Die Hauptnachricht im Netzwerkteil von Kubernetes ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alpha-Version der</a> <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SCTP-</a> Unterstützung</b> (Stream Control Transmission Protocol).  Dieses Telekommunikationsprotokoll wurde in den <i>Bereichen</i> <i>Pod</i> , <i>Service</i> , <i>Endpoint</i> und <i>NetworkPolicy unterstützt</i> und gehört nun zu TCP und UDP.  Mit der neuen Funktion „Anwendungen, die SCTP als L4-Protokoll für ihre Schnittstellen benötigen, wird die Bereitstellung auf Kubernetes-Clustern einfacher.  Beispielsweise können sie die auf <i>kube-dns</i> basierende <i>Diensterkennung verwenden</i> , und ihre Interaktion wird über <i>NetworkPolicy</i> gesteuert. "  Implementierungsdetails finden Sie in <a href="">diesem Dokument</a> . <br><br>  Zwei in K8s 1.8 eingeführte Netzwerkfunktionen haben ebenfalls einen stabilen Status erreicht: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterstützung für Richtlinien</a> für ausgehenden <code>EgressRules</code> Verkehr in der NetworkPolicy-API und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anwendung von</a> CIDR- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Regeln</a> für Quelle / Ziel über <code>ipBlockRule</code> . <br><br><h2>  Skalieren </h2><br>  Zu den Verbesserungen des Horizontal Pod Autoscaler gehören: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aktualisierter Algorithmus</a> zum schnelleren Erreichen der richtigen Größe (sofort Alpha und Beta), für weitere Details lesen Sie den <a href="">neuen Abschnitt der Dokumentation</a> ; </li><li>  Entwicklung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">benutzerdefinierten / benutzerdefinierten Metriken</a> , deren zweite Beta eine neu gestaltete API und Unterstützung für Label-Selektoren erhielt. </li></ul><br>  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vertikale Skalierung der Herde</a> , bei der vor Erreichen der Beta-Version keine Benutzertests durchgeführt wurden, steht nicht still.  Die Autoren hielten es für ausreichend für die Veröffentlichung von K8s 1.12 und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erinnern daran,</a> dass diese Funktion eher eine Ergänzung zu Kubernetes ist (nicht im Kernel enthalten).  Die gesamte Entwicklung wird in einem separaten Repository durchgeführt, in dem die Beta-Version zeitlich auf die Veröffentlichung von Kubernetes abgestimmt wird. <br><br><img src="https://habrastorage.org/webt/sl/0e/je/sl0ejeaihoybtqm8khj5y_tkffa.png"><br>  <i>VPA-Workflow (Vertical Pod Autoscaler) für Kubernetes</i> <br><br>  Schließlich enthält K8s 1.12 (in Alpha-Form) die Ergebnisse der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arbeiten</a> zur "Vereinfachung der Installation mit <code>ComponentConfig</code> " (als Teil des Sig-Cluster-Lebenszyklus), die seit fast zwei Jahren durchgeführt werden.  Leider ist der Zugriff auf das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokument</a> mit den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwurfsvorschlägen</a> mit Details aus irgendeinem Grund (ein einfaches Versehen?) Für anonyme Benutzer gesperrt. <br><br><h2>  Andere Änderungen </h2><br><h3>  API </h3><br>  In der API-Maschinengruppe sind zwei neue Funktionen implementiert: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code> dry-run</code></a> für Apiserver (Alpha-Version), der die Validierung und Verarbeitung von Anforderungen imitiert; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ressourcenkontingent-API</a> (sofort Beta), die <b>standardmäßig begrenzte Ressourcen</b> definiert (anstelle des aktuellen Verhaltens, wenn der Ressourcenverbrauch unbegrenzt ist, wenn kein Kontingent festgelegt ist). </li></ul><br><h3>  Azure </h3><br>  Für stabil erklärt: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterstützung für</a> Azure Virtual Machine Scale Sets (VMSS); </li><li>  Azure- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterstützung</a> in Cluster-Autoscaler. </li></ul><br>  Die ersten Implementierungen (Alpha-Versionen) werden hinzugefügt: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterstützung für</a> Azure-Verfügbarkeitszonen </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterstützung für</a> Knoten wie RG ( <a href="">Cross Resource Group</a> ) und nicht verwaltete Knoten (On-Prem). </li></ul><br><h3>  Kubectl </h3><br><ul><li>  Es wurde eine Alpha-Version des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>aktualisierten Plug-In-Mechanismus</b></a> implementiert, mit der Sie neue Befehle hinzufügen oder vorhandene Unterbefehle einer beliebigen Verschachtelungsebene neu schreiben können.  Es ähnelt Git und betrachtet ausführbare Dateien, die mit <code>kubectl-</code> im <code>$PATH</code> des Benutzers beginnen.  Weitere Einzelheiten finden Sie im <a href="">Entwurfsvorschlag</a> . </li><li>  Eine Beta-Version der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Idee, das</a> <code>pkg/kubectl/genericclioptions</code> von kubectl in ein unabhängiges Repository zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">isolieren,</a> wurde implementiert. </li><li>  Die <i>serverseitige Druckfunktion</i> wurde für stabil erklärt. </li></ul><br><h3>  Andere </h3><br><ul><li>  Die Alpha-Version des neuen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>TTL-After-Finish-</b></a> Mechanismus, mit dem die Lebensdauer von <i>Jobs</i> und <i>Pods begrenzt werden soll, deren</i> Ausführung abgeschlossen ist, wird <i>vorgestellt</i> .  Nach Ablauf der angegebenen TTL werden Objekte automatisch bereinigt, ohne dass ein Benutzereingriff erforderlich ist. </li><li>  Die Generierung eines privaten Schlüssels und eines CSR (TLS Bootstrap) zum Signieren eines Zertifikats auf Clusterebene in <i>Kubelet wird</i> als stabil deklariert. </li><li>  Die Rotation des Server-TLS-Zertifikats in <i>Kubelet</i> ging in den Beta-Status über. </li></ul><br><h2>  PS </h2><br>  Lesen Sie auch in unserem Blog: <br><br><ul><li>  „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes 1.11: Ein Überblick über wichtige Innovationen</a> “; </li><li>  "Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Integration von Containerd in Kubernetes, die Docker ersetzt, ist produktionsbereit</a> "; </li><li>  „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes 1.10: Überblick über wichtige Innovationen</a> “; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes 1.9: Ein Überblick über wichtige Innovationen</a> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vier CNCF-Releases 1.0 und wichtige Ankündigungen zu Kubernetes mit der KubeCon 2017</a> "; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes 1.8: Ein Überblick über wichtige Innovationen</a> </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Docker 17.06 und Kubernetes 1.7: Schlüsselinnovationen</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424331/">https://habr.com/ru/post/de424331/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424321/index.html">NetFlow billig und wütend machen</a></li>
<li><a href="../de424323/index.html">Ein Beispiel für die Arbeit mit der ICE-Methode aus dem Produktmanager von Google und Microsoft</a></li>
<li><a href="../de424325/index.html">Training Splunk - ein Trainingszentrum in Russland</a></li>
<li><a href="../de424327/index.html">Zuckerberg-Fonds: Wie man optische Technologie und Biomedizin „findet“</a></li>
<li><a href="../de424329/index.html">Nehmen und tun: wie man Programmierung und Entwicklung einpumpt</a></li>
<li><a href="../de424333/index.html">Meine Erfahrung mit Dating und der Arbeit mit Robot Framework</a></li>
<li><a href="../de424335/index.html">Lass es Licht sein</a></li>
<li><a href="../de424337/index.html">Ruby-Code: kompetent, schön und effizient. Beispiel für Anfänger</a></li>
<li><a href="../de424339/index.html">Tandem des Autors und Experten: Wie macht man es effektiv?</a></li>
<li><a href="../de424341/index.html">Ulme. Bequem und umständlich. Zusammensetzung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>