<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📑 🤴🏼 ❣️ Erstellen eines Sammelalbum-Layouts in CSS Grid 👩🏻‍🎤 🦁 🧑🏿‍🤝‍🧑🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kürzlich wurde mein Sohn im Vorschulunterricht angewiesen, sich eine Woche lang um einen Teddybären zu kümmern, was darauf hindeutete, dass er den Bär...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen eines Sammelalbum-Layouts in CSS Grid</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472496/"> Kürzlich wurde mein Sohn im Vorschulunterricht angewiesen, sich eine Woche lang um einen Teddybären zu kümmern, was darauf hindeutete, dass er den Bären zu einem Abenteuer mitnehmen und seine Erinnerungen daran dem Album hinzufügen musste.  Ich habe dieses Album wirklich genossen und mich ermutigt, darüber nachzudenken, wie ich so etwas mit CSS Grid machen würde! <br><br><img src="https://habrastorage.org/webt/co/84/km/co84km1cpdhbrsdnprqdgmki2tw.jpeg"><br><a name="habracut"></a><br><hr><br><h2>  Zusammengesetztes Netz </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Andy Clarke hielt</a> auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">State of the Browser-</a> Konferenz eine fantastische Präsentation „Inspiriert von CSS Grid Technology“, die für Entwickler mit Design-Wurzeln wie mich einen echten Einblick bot.  In seinem Vortrag sprach er darüber, wie Ideen aus dem Druckdesign im Web verwendet werden können, um erstaunliche Layouts zu erstellen, und wie CSS Grid dies nicht nur möglich, sondern auch viel einfacher als je zuvor macht.  Eines dieser Prinzipien war die Verwendung von Verbundnetzen. <br><br>  Die meisten von uns sind wahrscheinlich mit der Verwendung von Gittern für das Webdesign und die Webentwicklung vertraut.  Fast alle Site-Layouts, die ich entwickeln sollte, waren in ein Standardraster mit 12 Spalten (oder gelegentlich 24 Spalten) mit Spalten gleicher Breite unterteilt.  Bisher ist alles ziemlich vorhersehbar. <br><br>  Zusammengesetzte Netze werden dagegen erzeugt, indem zwei oder mehr Netze übereinander gelegt werden.  Vergleiche von beispielsweise einem 5-Spalten-Raster, das einem 4-Spalten-Raster überlagert ist, erzeugen ein rhythmisches Muster und eröffnen Möglichkeiten, ein dynamischeres Layout als ein reguläres Raster zu erstellen. <br><br><img src="https://habrastorage.org/webt/w6/po/kz/w6pokzpxipaqg6z9rvr4av1e1sy.png"><br>  <i>Abbildung 2 - Wir beginnen mit einem 4-Spalten- und 5-Spalten-Raster</i> <br><br><img src="https://habrastorage.org/webt/z8/g8/1z/z8g81zsvr_xbmvumns335rhxluu.png"><br>  <i>Abbildung 3 - Gitter überlappen sich.</i>  <i>Als Ergebnis erhalten wir ein zusammengesetztes Gitter</i> <br><br>  Dies gilt sowohl aus psychologischer als auch aus technischer Sicht - wir können trotz Verwendung eines zusammengesetzten Rasters das gängigste Layout erstellen.  Andy schrieb einen ausführlichen Artikel mit dem Titel „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Inspirierte Designentscheidungen: Pressing Matters</a> “, in dem mehr über Verbundgitter gesprochen wird.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Seine Präsentation</a> von der State of the Browser-Konferenz ist ebenfalls verfügbar. <br><br><h2>  Compound Mesh Generator </h2><br>  Die fr-Einheiten machen es sehr einfach, zusammengesetzte Netze in CSS Grid zu implementieren.  Ich mag die Idee, zusammengesetzte Gitter im Webdesign zu verwenden, aber ich hatte das Gefühl, dass der Prozess der Berechnung (insbesondere des komplexeren Gitters) ziemlich zeitaufwändig sein kann.  Ich wollte in der Lage sein, schnell und bequem zusammengesetzte Netze zu erstellen. Deshalb habe ich, inspiriert von Andys Bericht, meine Ärmel hochgekrempelt und ein kleines Werkzeug zum Erstellen und Visualisieren dieser Netze erstellt.  Geben Sie die Anzahl der Spalten für zwei Raster ein (mit jeweils maximal 10 Spalten), und der Generator kombiniert sie, um den endgültigen Wert zu erhalten, der für die Eigenschaft " <code>grid-template-columns</code> .  Beispielsweise zeigt ein vierspaltiges Raster plus ein fünfspaltiges Raster <code>4fr 1fr 3fr 2fr 2fr 3fr 1fr 4fr</code> . <br><br><img src="https://habrastorage.org/webt/hm/3e/_f/hm3e_fhzl88wxv29l8fluiq_ucg.jpeg"><br><br>  Dieses Tool wird auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Codepen</a> vorgestellt. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Sie</a> können es also verwenden oder an Ihre Bedürfnisse anpassen. <br><br><h2>  Erstellen Sie ein Raster für ein Albumlayout </h2><br>  Das zusammengesetzte Raster ist ideal für ein Album-Layout, das ich etwas unvorhersehbar machen möchte, aber dabei einen Sinn für Rhythmus und Ausgewogenheit behalten möchte.  Nach einigen Experimenten mit dem Generator entschied ich mich für ein zusammengesetztes Gitter 6/5, das, wie es mir schien, die richtige Anzahl von Spalten für weitere Manipulationen ergab.  Dies gibt mir das ursprüngliche Raster, mit dem ich arbeiten kann: <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.grid</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: grid; <span class="hljs-attribute"><span class="hljs-attribute">grid-template-columns</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>fr <span class="hljs-number"><span class="hljs-number">1</span></span>fr <span class="hljs-number"><span class="hljs-number">4</span></span>fr <span class="hljs-number"><span class="hljs-number">2</span></span>fr <span class="hljs-number"><span class="hljs-number">3</span></span>fr <span class="hljs-number"><span class="hljs-number">3</span></span>fr <span class="hljs-number"><span class="hljs-number">2</span></span>fr <span class="hljs-number"><span class="hljs-number">4</span></span>fr <span class="hljs-number"><span class="hljs-number">1</span></span>fr <span class="hljs-number"><span class="hljs-number">5</span></span>fr; <span class="hljs-attribute"><span class="hljs-attribute">gap</span></span>: <span class="hljs-number"><span class="hljs-number">1rem</span></span>; }</code> </pre><br><h3>  Rasterzeilen definieren </h3><br>  Das Definieren von Gitterlinien war schwieriger und erforderte etwas mehr Versuch und Irrtum.  Jedes Foto im Raster sollte das andere überlappen.  Es hat sich als nützlich erwiesen, ein Raster ungefähr auf Papier zu zeichnen, um zu verstehen, wie viele Linien benötigt würden. <br><br>  Um den vertikalen Rhythmus aufrechtzuerhalten, habe ich beschlossen, dass sich Fotos auf bestimmte Weise überlappen sollten.  Ich habe diese Überlagerungsgröße einer Variablen zugewiesen, damit sie auf der gesamten Seite verwendet und bei Bedarf aktualisiert werden kann (Abb. 4). <br><br><img src="https://habrastorage.org/webt/ls/ce/jo/lscejocsqud3pchqqe9bv9a-vgk.png"><br>  <i>Abbildung 4 - Vertikale Bildüberlagerung</i> <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.grid</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">--verticalPadding</span></span>: <span class="hljs-number"><span class="hljs-number">2rem</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">--overlap</span></span>: <span class="hljs-number"><span class="hljs-number">6rem</span></span>; }</code> </pre><br>  Jedes Bild hat auch Begleittext.  Dafür sollte oben und unten genügend Platz vorhanden sein, damit es nicht mit dem vorherigen Foto überlappt.  Dies beinhaltet das Hinzufügen von Gitterlinien über und unter der Beschriftung, die als „Auffüllen“ dienen.  Jetzt sollte jedes Bild mindestens vier Zeilen des Rasters abdecken - und das Bild, das sich oben und unten überlappt, sollte fünf Zeilen einnehmen. <br><br><img src="https://habrastorage.org/webt/wz/pt/uu/wzptuu4gf6wimjmchtunumelxrw.png"><br>  <i>Abbildung 5 - Zeilen, die die Rolle des "Auffüllens" übernehmen, ermöglichen es Ihnen, ein Mindestintervall zwischen dem Ende des Textblocks und dem Beginn des nächsten Bildes einzuhalten.</i> <br><br>  Wir haben das Raster jedoch noch nicht fertig entworfen: Ich habe beschlossen, ein festes Seitenverhältnis für die Bilder festzulegen.  Einige Fotos sind im Hochformat, andere im Querformat.  Ich möchte, dass das Rasterlayout unabhängig vom Seitenverhältnis der Fotos oder der Länge des Textes funktioniert. Daher war es erforderlich, dass sich die Rasterlinien anpassen können. <br><br>  Anstatt feste Werte für Zeichenfolgen zu verwenden, die als Überlagerungen oder Auffüllungen dienen, können wir diese Spuren mithilfe der Funktion minmax () flexibel gestalten.  Dies bietet eine Situation, in der die Linienspuren eine Mindestgröße haben, sich jedoch bei Bedarf für den Inhalt erweitern. <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">var</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">--padding</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>));</code> </pre><br><h2>  Platzierung von Elementen </h2><br>  Jetzt, da wir das Skelett des Gitters haben, ist es Zeit, sich mit der Platzierung von Elementen zu befassen.  Manchmal kann es schwierig sein, zu verstehen und auszuwählen, wie sie am besten in einem Raster einer beliebigen Struktur platziert werden können.  Wir haben verschiedene Optionen: Zeilennummern, das Schlüsselwort span, benannte Zeilen oder Bereiche - und einige davon funktionieren in bestimmten Situationen besser als andere.  Es gibt jedoch keine richtige oder falsche Option, und oft kommt es darauf an, die für Sie am besten geeignete Methode zu finden. <br><br>  Solange alles so funktioniert, wie es sollte, gibt es keine falschen Ansätze <br><br><h3>  Platzierung mit Gitterlinien </h3><br>  Ich beginne oft damit, Elemente mit Start- und Endwerten zu platzieren - normalerweise mit den Nummern der ersten und letzten Zeile. Wenn ich jedoch die genaue Anzahl der Spuren kenne, die das Element abdecken soll, verwende ich stattdessen das Schlüsselwort "span".  Manchmal benenne ich die Gitterlinien, um wichtige Orientierungspunkte hinzuzufügen (z. B. <code>wrapper-start</code> und <code>wrapper-end</code> ), aber ich gehe selten so weit, die Gitterlinien zu benennen oder Gitterbereiche direkt für jedes Element im Gitter zu erstellen.  Eine Strategie, die mir sehr hilft, besteht darin, negative Gitterlinien in Situationen anzugeben, in denen ich ein Element am Ende des Gitters platzieren möchte.  Ich habe darüber in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">separaten Artikel geschrieben</a> .  Ich verwende am häufigsten negative Gitterlinien in der Spaltenachse, da in den meisten Fällen (für die Gitter, mit denen ich arbeite) die Anzahl der Spalten bekannt und fest ist. <br><br>  Ein Element, das sich in der Eigenschaft <code>grid-column</code> mit dem Wert 1 / -1 befindet, deckt alle Spalten des Gitters ab, vom ersten bis zum letzten: <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.item</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> / -<span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br>  Ich bin eher geneigt, Gitterlinien in Situationen zu benennen, in denen Gitter eine sehr große Anzahl von Spuren haben.  In dem betrachteten Fall haben wir nur 10 Spaltenspuren, daher scheint es mir, dass das Platzieren von Elementen nach Zeilennummer für die weitere Bearbeitung bequemer erscheint. <br><br>  Platzieren Sie die Elemente einfach mit einer Mischung aus positiven / negativen Gitterlinien und Span-Werten entlang der Spaltenachse.  Das Aktivieren des Grid Inspector im Firefox-Entwicklerfenster hilft dabei sehr, da wir die Zeilennummern sehen können. <br><br><h3>  Platzierung unter Verwendung von Gitterbereichen </h3><br>  Wenn wir uns das Gitter ansehen.  wir können sehen, dass wir eine ziemlich große Anzahl von Zeilen haben. <br><br><img src="https://habrastorage.org/webt/nb/tq/lo/nbtqlo8iuqfsibrgjm0dhx1v8sq.jpeg"><br>  <i>Abbildung 7 - Ein Screenshot des Firefox-Rasterinspektors im Entwicklerfenster mit Rasterspalten und -zeilen</i> <br><br>  Obwohl ich angefangen habe, Elemente nach Zeilennummer auf der Zeilenachse zu platzieren, wird es schnell schwierig, sie zu steuern.  Die Elemente sollten sich überlappen, und es scheint mir schwierig zu sein, die Spur zu verfolgen, auf der ein Element enden und das andere beginnen soll.  Außerdem möchte ich keine negativen Gitterlinien verwenden, da die Möglichkeit besteht, dass ich mein Layout in Zukunft ergänzen möchte.  Wenn ich dem Raster eventuell explizitere Zeilen hinzufüge, sind negative Zeilennummern nicht mehr gültig, was möglicherweise zu vielen Layoutfehlern führt. <br><br>  Zu diesem Zeitpunkt habe ich beschlossen, benannte Gitterbereiche auf der Zeilenachse zu erstellen.  Gitterbereiche werden auf zwei Arten erstellt: <br><br><ol><li>  Verwenden der Eigenschaft "Rastervorlagenbereiche", mit der Sie ein Rasterlayout effektiv als ASCII-Zeichnung "zeichnen" können </li><li>  Verwenden Sie benannte Gitterlinien und verwenden Sie <code>-start</code> und <code>-start</code> als Suffixe für <code>-start</code> </li></ol><br>  Mit der Eigenschaft "Rastervorlagenbereiche" können wir keine Bereiche für überlappende Elemente definieren. Daher hilft sie uns bei diesem speziellen Layout nicht wirklich.  Die Verwendung benannter Gitterbereiche erleichtert die Aufgabe jedoch definitiv. <br><br>  Wenn wir die Linien sowohl für die Zeilenachse als auch für die Spaltenachse benennen, erhalten wir einen Gitterbereich (Abb. 8). <br><br><img src="https://habrastorage.org/webt/5z/1h/l8/5z1hl8xujhb6tjyljy-otd6tu9i.png"><br>  <i>Abbildung 8 - Suffixe von <code>-start</code> mit <code>-start</code> und <code>-start</code> erstellen einen Rasterbereich</i> <br><br>  Sie können dann auf diesen Bereich verweisen, wenn wir ein Element mithilfe der Eigenschaft <code>grid-area</code> : <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.item</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-area</span></span>: image; }</code> </pre><br>  Dies macht unseren Code prägnanter und lesbarer als die Verwendung der Eigenschaften für Rasterspalten und Rasterzeilen und die Auflistung der Zeilennamen: <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.item</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-row</span></span>: image-start / image-end; <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: image-start / image-end; }</code> </pre><br>  In diesem Fall benötigen wir jedoch nur einen benannten Gitterbereich auf der Zeilenachse.  Dies ist normal, da wir nur mit der Eigenschaft grid-row darauf verweisen können: <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.item</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-row</span></span>: image; }</code> </pre><br>  Da wir eine große Anzahl von Zeilen haben, schien es mir viel einfacher zu sein, die Eigenschaft <code>grid-template-rows</code> vertikal so zu schreiben, dass sie die Struktur der Seite widerspiegelt: <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">grid-template-rows</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span> 3<span class="hljs-selector-tag"><span class="hljs-selector-tag">rem</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">var</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">--verticalPadding</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">var</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">--verticalPadding</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">var</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">--overlap</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">var</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">--verticalPadding</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">var</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">--verticalPadding</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">var</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">--overlap</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">var</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">--verticalPadding</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">var</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">--verticalPadding</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>);</code> </pre><br>  Das Hinzufügen der Zeilennamen an der richtigen Stelle wird jetzt einfacher, da wir die Gitterstruktur visualisieren können: <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">grid-template-rows</span></span>: <span class="hljs-selector-attr"><span class="hljs-selector-attr">[header-start]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[fig1-start]</span></span> 3<span class="hljs-selector-tag"><span class="hljs-selector-tag">rem</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[header-end]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">var</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">--verticalPadding</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>) <span class="hljs-selector-attr"><span class="hljs-selector-attr">[p1-start]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>) <span class="hljs-selector-attr"><span class="hljs-selector-attr">[p1-end]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">var</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">--verticalPadding</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>) <span class="hljs-selector-attr"><span class="hljs-selector-attr">[fig2-start]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">var</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">--overlap</span></span>) <span class="hljs-selector-attr"><span class="hljs-selector-attr">[fig1-end]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">var</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">--verticalPadding</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>) <span class="hljs-selector-attr"><span class="hljs-selector-attr">[p2-start]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>) <span class="hljs-selector-attr"><span class="hljs-selector-attr">[p2-end]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">var</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">--verticalPadding</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>) <span class="hljs-selector-attr"><span class="hljs-selector-attr">[fig3-start]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">var</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">--overlap</span></span>) <span class="hljs-selector-attr"><span class="hljs-selector-attr">[fig2-end]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">var</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">--verticalPadding</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>) <span class="hljs-selector-attr"><span class="hljs-selector-attr">[p3-start]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>) <span class="hljs-selector-attr"><span class="hljs-selector-attr">[p3-end]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">var</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">--verticalPadding</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>) <span class="hljs-selector-attr"><span class="hljs-selector-attr">[fig3-end]</span></span>;</code> </pre><br>  Sie müssen sich nur noch auf die Namen der Bereiche auf der Zeilenachse beziehen, wenn unsere Rasterelemente platziert werden: <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.fig--1</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: span <span class="hljs-number"><span class="hljs-number">5</span></span> / -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-row</span></span>: fig1; } <span class="hljs-selector-class"><span class="hljs-selector-class">.fig--2</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> / span <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-row</span></span>: fig2; } <span class="hljs-selector-class"><span class="hljs-selector-class">.fig--3</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: span <span class="hljs-number"><span class="hljs-number">5</span></span> / -<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-row</span></span>: fig3; }</code> </pre><br>  Das Endergebnis (Abb. 10) kann auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Codepen überprüft werden</a> <br><br><img src="https://habrastorage.org/webt/yn/bf/0z/ynbf0z6bbqh5fwpwdltfdbdi-da.jpeg"><br>  <i>Abb. 10</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/michellebarker/embed/preview/gOYqmJQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Obwohl ich keine zusätzlichen Anstrengungen unternommen habe, um dieses Layout ansprechend zu gestalten, kann es auf noch kleineren Bildschirmen als Tablets verwendet werden.  Das Layout für kleine Bildschirme anzupassen wäre nicht sehr schwierig.  Persönlich würde ich für solche Situationen ein einfacheres Raster wählen, da viele visuelle Merkmale immer noch verloren gehen.  Andererseits ist daran nichts Richtiges oder Falsches. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472496/">https://habr.com/ru/post/de472496/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472484/index.html">Lücken in einem Kubernetes-Cluster schließen. Bericht und Transkription mit DevOpsConf</a></li>
<li><a href="../de472486/index.html">Langzeitdatenspeicherung. (Artikel - Diskussion)</a></li>
<li><a href="../de472488/index.html">Dreißig Berichte von DevOops 2019: Tim Lister, Hadi Hariri, Roman Shaposhnik und andere Stars der internationalen DevOps</a></li>
<li><a href="../de472490/index.html">Wie ich mithilfe der Verarbeitung natürlicher Sprache nach einem Schönheitsstandard gesucht habe (und ihn nicht gefunden habe)</a></li>
<li><a href="../de472492/index.html">Analyse des ROOT-Codes, Scientific Data Analysis Framework</a></li>
<li><a href="../de472502/index.html">SOC ist Menschen: der harte Alltag des Service Managers des Zentrums zur Überwachung und Reaktion auf Cyber-Angriffe</a></li>
<li><a href="../de472504/index.html">PHP Microservice Framework Swoft: Verwenden Sie die Datenbank Teil 1</a></li>
<li><a href="../de472506/index.html">Wo ist der Fehler, Billy? Wir brauchen einen Fehler ...</a></li>
<li><a href="../de472508/index.html">Flash-Zuverlässigkeit: erwartet und unerwartet. Teil 3. XIV. Konferenz der USENIX Association. Dateispeichertechnologien</a></li>
<li><a href="../de472514/index.html">Von der Suche nach einer Idee bis zur fertigen Bewerbung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>