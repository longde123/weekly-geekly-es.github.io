<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🎓 🐭 ☣️ 反向开发时间开关VL-76-S 👩🏿‍🤝‍👨🏾 👩🏼‍🔬 😒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="曾几何时，我遇到了VL-76-S电子数字时间开关，该开关是新包装的，但处于故障状态。 在内部的印刷电路板上未发现缺陷。 因此，工厂联姻，固件损坏。 


 继电器的一般视图。 

 使我们感到惊讶的是流行且简单的微控制器ATTiny2313的使用。 在外部，此设计包括一个具有三十个开关形式的主机和一...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>反向开发时间开关VL-76-S</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414345/"> 曾几何时，我遇到了VL-76-S电子数字时间开关，该开关是新包装的，但处于故障状态。 在内部的印刷电路板上未发现缺陷。 因此，工厂联姻，固件损坏。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cn/vj/2v/cnvj2vs2aonwmvjljydwos0ewqi.jpeg"></div><br>  <i>继电器的一般视图。</i> <br><a name="habracut"></a><br> 使我们感到惊讶的是流行且简单的微控制器ATTiny2313的使用。 在外部，此设计包括一个具有三十个开关形式的主机和一个端子，该端子上连接有220V电源和EM继电器的触点。 任务范围是0.1 ... 99.9分钟。 以0.1分钟为增量  （6秒）。 互联网上这种设计没有电路和固件，这不足为奇。 我三思而后行，决定从印刷电路板上绘制电路，以后自己在MK上编写程序。 <br><br> 该设计由三个互连的印刷电路板组成。 在第一块板上，制作了电源设备和TRA3执行继电器。 电源是根据无变压器电路制成的：使用淬火电容器来降低电压。 在第二块板上是ATTiny2313 MK和其他辅助元件。 第三块板上有开关（设定点）和控制LED。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/be/ew/4h/beew4hzen1salm0a6x7mlwhak2g.jpeg"></div><br>  <i>从背面看的第三张照片。</i> <br><br> 我将从第三块板开始描述。 开关是10位开关。 它们上没有标记，每个都有5个触点。 因此，取决于位置，某些触点以各种组合闭合。 调用触点后，我立即抓住了模式：根据与所选位置的编号相对应的数字的二进制表示形式，一个固定输出（常规）与其他四个输出（信息）关闭。 例如，如果选择位置“ 3”，则通用输出（连续第五个）与第三和第四个输出关闭，因为二进制表示中的数字“ 3”为“ 0011”。 这是一个棘手的开关。 其中有三个。 它们通过XP1和XP2连接器通过MK连接到第二块板。  XP3连接器连接LED和其他一些不必要的无焊废料，在板上需要放置这些废料。 这很可能是常见的六针DPDT开关（例如方形的，例如PB22E06）。 主板也许是通用的，但在此特定型号中并未使用。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lo/tv/rq/lotvrq9ovoeetew2zmaa6sauury.jpeg"></div><br>  <i>第二（主）板的照片。</i> <br><br> 打电话给交换机的触点，我并没有立即理解它们与MK端口的连接原理。 在主板上，立即可以看到8个SMD晶体管。 后来他发现这些晶体管与公共阳极一起用作二极管对。 它们的基极去MK端口，集电极和发射极去开关触点。 然后他们向我解释说，在这种情况下有二极管对，它们像晶体管一样响，但是它们不是晶体管。 总共，我们有16条导体，将二极管对留在第三块板上。 其中四分之三（12个）到达开关的信息触点（3到4个），还有4个保持空闲。 很容易猜测，从理论上讲，它们是为第四个开关提供的，由于某种原因，它在板上根本没有空间，因此并没有出现。 然而，为了不违反推理的逻辑，我将提到这个虚构的第四开关。 第二和第三开关的公共端以及第一和第四开关（但第四开关不提供该板）通过XS1和XS2配合连接器上的主板中的走线成对连接在一起。 这两对连接到晶体管组的输出。 这两个相同的组在晶体管BC857和BC847（不同的结构）上制成。 它们的输入连接到MK。 将逻辑“ 0”应用于该组的输入时，输出也将是逻辑“ 0”。 另外，板上有一个用于MK固件的XP2连接器，连接到MK接口的SPI端子，一个用于LED的XS3连接器，以及一个通过电缆连接到第一块板上的XP1连接器。 应当记住，某些MK端口既可以用于SPI（用于固件），也可以用于普通的输入输出（电路中的工作）。 <br><br> 以上所有内容均反映在我首先在草稿中绘制的图表中，然后在SPlan中绘制。 图中没有标出未标记的无线电元件的额定值（例如SMD电容器），它们并不是那么重要。 首先，我将给出主板和带有设置器的板的示意图（下图的签名）。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4c/r8/gr/4cr8gr6u5edycy869h9wuyprgs0.gif"></div><br>  <i>主板方案。</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pg/sx/uy/pgsxuy7cgafwqwabsx39prgwkgw.gif"></div><br><br>  <i>第三委员会与二传手的方案</i> <br><br> 考虑一下每个二传手的审问。 来自端口PB4和PB5 MK逻辑“ 0”的信号打开晶体管VT2和VT1，接着打开VT4和VT3，分别连接到开关1和2的零总线公共触点。 这是依次发生的。 首先，逻辑“ 0”来自PB4（迄今为止PB5设置为逻辑“ 1”），连接第二和第三开关。 在这种状态下，信号的值由控制器依次从输入端口PB3，PB2，PB1，PB0通过第二和缺失的第四开关的二极管组2VD1 ... 2VD4记录下来。 立即，来自引脚PD6，PD5，PD4，PD3 MK的信号值被固定，来自第一和第三开关的信号通过二极管组2VD5 ... 2VD8固定到该引脚。 但是，由于仅第二和第三开关通过公共触点连接，因此来自第二开关的信号将到达MK的第一个指定端口，而第四个将被忽略。 同样，来自第三个开关的信号将到达MK的后半部分，而第一个将被忽略。 在此阶段，控制器知道第二和第三开关安装在哪个位置。 之后，将PB4设置为“单位”，关闭第二和第三开关，将PB5设置为“零”。 在这种情况下，第一和缺少的第四开关通过公共端连接到“外壳”。 它们的询问与前面的情况完全相同，但是现在将记录上次被忽略的那些开关的信号。 因此，控制器知道所有开关的位置信息。 此过程类似于轮询矩阵键盘，但在这种情况下为4层矩阵，尺寸为2 x 2，但缺少一个元素。 <br><br> 电阻器R8 ... R15-上拉电阻。 虽然，可以“拉起” MK本身。 精确的时钟频率MK可提供10 MHz的石英。  R1和C4-MK重置电路。 该板上没有其他有趣的东西了。 <br><br><img src="https://habrastorage.org/webt/5u/u-/8s/5uu-8sh8ffhwe3qcxqs6gzppcqa.jpeg"><br>  <i>元素侧面的第一个（电源）板的照片。</i> <br><br><img src="https://habrastorage.org/webt/oe/ln/3-/oeln3-vbwunn8pr0ku2gcwloywm.jpeg"><br>  <i>背面第一个（电源）板的照片。</i> <br><br> 让我们继续第一块板的方案（上图）。 该计划似乎非常有趣，在某些地方令人难以理解。 <br><br><img src="https://habrastorage.org/webt/ku/br/ys/kubrysrquhsy3n1xfwmeuvnh8qw.gif"><br>  <i>第一（电源）板的方案。</i> <br><br>  C1C2-降低电压。  R1-放电以上。 在二极管电桥DB1之后是两种电解质。 为了使电路复杂（或出于可靠性考虑）-级联稳定方案VT3R6VD3-VT7R12VD5。  VD5类似于未使用的发射极SMD晶体管。 这样可提供稳定的12V DC电压。 接下来是5V的VR1线性稳压器。 同时，电压从DB1二极管电桥通过VD2二极管移至另一个24V VT1R3VD1稳定器。 该电压提供给EM继电器Rel1的线圈和R17。 后者不清楚原因。  R17的另一端来自晶体管组VT9VT10。 该组的电路与主板上的电路相似。 来自单独的MK PB6端口的信号通过连接器到达该晶体管组的输入。 为什么需要它？ 为什么将R17电阻连接到24V？ 最有可能的想法是，您可以通过以某种方式对PB6 MK端口进行编程来代替电阻，例如放置内部控制LED。 或其他交换节点。 但是，同样，这是胡说八道，正如我的熟人无线电工程师在看过设计板时所说的那样。  EM继电器Rel1的第二端连接到类似的晶体管组VT2VT5，并且连接到MK PD0端口。 来自该端口的信号“ 0”打开正在执行的EM继电器。 最有趣的是，外部LED通过两个连接器（通过主板）不与EM继电器并联，而是与VT2晶体管的发射极间隙相连。 在端子上，根据继电器上的标签判断，插针编号1和2保持为空。 但是在该电路中，第2号触点连接到公共线，第1号触点被馈送到晶体管组VT6VT8的输入。 该组的输出发送到PD2 MK端口。 稍后，我阅读了该继电器模型的规范，这些触点用于控制在相同情况下组装的其他继电器模型。 我正在考虑的模型不涉及控制，但是在MK上编写程序时可以实现，因为该方案提供了这种机会。 在控制之下可能意味着启动，重置（在“触发”模式和正常模式下）以及所有想到的东西。 其他继电器的规格显示了时序图，这些时序图显示了继电器的行为（取决于给定的控制信号）。 它还在下面说：应客户的要求，我们可以实现任何可能的图表。 以及计划的最后时刻。 来自端子1的控制信号也到达无用的VT4晶体管，由12V电压供电。 再次，这是该方案的复杂性。 也许还有一些想法？ 我没有深入研究。 我将很高兴收到任何评论。 <br><br> 连接器端子的标记在连接器本身的名称之后通过点号进行标记。  “〜”符号后的罗马数字表示无用和遗漏的结论。 后者在计划中并不少，但我将不再赘述。 下面，我用连接器的名称，结论和基本元素来给出每个电路板的草图。 <br><br><img src="https://habrastorage.org/webt/9g/nt/94/9gnt940dbha1c-50htijfyd3erq.gif"><br>  <i>板草图。</i> <br><br> 考虑对MK程序的源代码的描述。 该程序本身很简单，由我用CVAVR编写了20分钟。 我将讨论执行程序的算法。 对于某些人来说，这些信息似乎是很平庸的，但是对于初学者来说，这并不是多余的。 在我的算法版本中，时间继电器上的计时器将不被询问一次，而是被连续询问。 而且，即使继电器跳闸后，轮询仍将继续。 这样您就可以随时随地进行调整。 也许此算法与该继电器的操作与原始算法不一致，但是我对原始算法并不熟悉。 在上述算法的示例中，将考虑程序的描述。 <br><br><div class="spoiler">  <b class="spoiler_title">带说明的C程序的源代码。</b> <div class="spoiler_text"> 我们连接了用于ATTiny2313 MK的库，以及延迟功能的库。 <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;tiny2313.h&gt; #include &lt;delay.h&gt;</span></span></span></span></code> </pre> <br> 接下来，根据MK端口的电路分配，进行必要的宏替换。 这些替换很方便，因为您可以在程序文本中而不是例如PORTB.5中编写getAD，这更加方便。 编译getAD将解释为PORTB.5。 因此，第一个替代是用于连接第一（A）和第四（D）设定点开关的输出。 第二个用于第二个（B）和第三个（C）。 接下来是启用中继的替换。 最后，在程序和所考虑的模型中未使用的“ Ctrl”替代。 你不能写。 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> getAD PORTB.5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> getBC PORTB.4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RL PORTD.0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Ctrl PIND.2</span></span></code> </pre><br> 变量A，B，C用于存储对应的三个开关的位置编号，并采用0到9之间的值。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> A,B,C;</code> </pre><br> 变量i-十分之一分钟（6秒）的数字的当前值，即继电器最小“刻度”的数字。 变量t是从主机收到的十分之一分钟（滴答声）的数量。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>,t;</code> </pre><br> 该程序的主要功能如下所示。 在前6行中，我不了解。 它们是使用辅助实用程序CodeWizadAVR形成的，并且与10 MHz处的外部石英有关。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> optsize- CLKPR=0x80; CLKPR=0x00; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _OPTIMIZE_SIZE_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> optsize+ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br> 以下两行配置了我们的MK的端口B。 根据该方案，我们将低4位输入到输入，将最高有效位输入到输出（不使用PB7，而PB6无用，但从理论上讲是输出）。 因此，根据我将不描述的MK配置原则，我们将数字240写到DDRB寄存器（F0以十六进制表示）中。 初始输出电平为“ 1”，除了不必要的PB7以外。 为了以防万一，让我们将MK的“上拉电阻”连接到输入，即使它们已经安装在电路中。 为此，我们以十六进制表示形式将PORTB寄存器设置为7F。 <br><br><pre> <code class="cpp hljs">PORTB=<span class="hljs-number"><span class="hljs-number">0x7F</span></span>; DDRB=<span class="hljs-number"><span class="hljs-number">0xF0</span></span>;</code> </pre><br> 端口D的配置方法相同，除了下部的两个引脚外，输入上的所有引脚均如此。 输入上的“上拉电阻”与输出上的初始输出电平“ 1”相似。 <br><br><pre> <code class="cpp hljs">PORTD=<span class="hljs-number"><span class="hljs-number">0x7D</span></span>; DDRD=<span class="hljs-number"><span class="hljs-number">0x03</span></span>;</code> </pre><br> 以下五行与MK计时器之一的配置有关。 该计时器为十六位数字，也就是说，它的得分最高为2 ^ 16 = 65536。 计数频率由MK时钟频率和分频系数（五个预定义值之一）确定。 在描述的程序中，决定保留一个帐户6秒钟（最小任务步骤），然后将变量i增加1并将计时器重置为计数的开始。 为了确保上述效果，您需要采用最大除数比1024并计数为58594。后者很容易计算。  MK频率-10,000,000 Hz。 使用1024的分频比，计时器频率将为10,000,000 / 1,024 = 9,765.625 Hz，周期将为1,024,000 / 10,000,000 = 0.0001024 s。 在6秒内，将堆叠6 / 0.0001024 = 58593.75的此类时间段。 此数字位于16位定时器中，但不是整数，因此必须四舍五入为58594。在这种情况下，我们的时间继电器的误差将不明显：58594-58593.75 = 0.25；  0.25 * 0.0001024 = 0.0000256;  0.0000256 * 999 = 0.0255744。 即，对于最大可能的时间段（99.9分钟），此时间继电器的不准确性将约为25.6毫秒，这在实践中是可以接受的。 顺便说一句，制造商还规定了设备的错误，我们的错误也不会更严重。 在TCCR1B定时器配置寄存器中，写入值5。不赘述，这意味着定时器启动，并且分频系数为1024。在TCNT1寄存器中，我们写入值0。该寄存器为16位，分为两个8位，一半：最小的（L ）和高级（H）。 将值写入该值，计时器将从该值开始继续计数。 我们需要从头开始计算。 值OCR1A寄存器，定时器将在该值之前读取，之后它将调用中断功能。 此时，程序的主要功能被中断，并执行该中断功能中指定的动作。 练习完中断后，主功能将继续执行。 如上所述，该值等于58594（十六进制表示法为E4E2）。 由于OCR1A寄存器也分为两半，因此我们将上述值分批写入。 <br><br><pre> <code class="cpp hljs">TCCR1B=<span class="hljs-number"><span class="hljs-number">0x05</span></span>; TCNT1H=<span class="hljs-number"><span class="hljs-number">0x00</span></span>; TCNT1L=<span class="hljs-number"><span class="hljs-number">0x00</span></span>; OCR1AH=<span class="hljs-number"><span class="hljs-number">0xE4</span></span>; OCR1AL=<span class="hljs-number"><span class="hljs-number">0xE2</span></span>;</code> </pre><br> 接下来的两行正确配置了中断的解决方案（不赘述）。 <br><br><pre> <code class="cpp hljs">TIMSK=<span class="hljs-number"><span class="hljs-number">0x40</span></span>; <span class="hljs-meta"><span class="hljs-meta">#asm(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sei"</span></span></span><span class="hljs-meta">)</span></span></code> </pre><br> 在主周期中，将使用30 ms的延迟不断轮询设定开关（根据电路说明中的算法），以确保正确稳定的运行。 通过在PORTB.5上将值设置为“ 0”（getAD = 0），我们准备了第一个开关。 其结论是将MK的端口D连接到引脚6、5、4、3。方向是从最小到最大。 也就是说，开关的低位连接到端口MK的相对低位（位3）。 因此，为了在第一个开关的位置上从MK的端口D接收信息，必须向右移三个位置（PIND &gt;&gt; 3），使用“〜”操作将接收到的位取反（因为根据方案，信息将为“ 0”）并将接收到的8位值的不必要的高4位复位。 最后的操作是通过将结果与数字15进行逻辑按位相乘（二进制表示为00001111）来完成的。 完成该操作后，将为变量A分配第一个开关的位置值。 接下来，关闭第一开关，准备第二和第三开关。 从第二个开关到变量B的值类似地从MK的端口B获取，但没有移位操作，因为此开关的端子连接到MK的端口B的最低引脚，并且同向连接。 从第三个开关到变量C的信息以与第一个开关相同的方式删除。 此后，第二和第三开关（getBC = 1）被“关闭”，并且在变量t中计算出三个开关的设定值（十分之一分钟）。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>){ delay_ms(<span class="hljs-number"><span class="hljs-number">30</span></span>); getAD=<span class="hljs-number"><span class="hljs-number">0</span></span>; delay_ms(<span class="hljs-number"><span class="hljs-number">30</span></span>); A=(~(PIND&gt;&gt;<span class="hljs-number"><span class="hljs-number">3</span></span>)&amp;<span class="hljs-number"><span class="hljs-number">15</span></span>); delay_ms(<span class="hljs-number"><span class="hljs-number">30</span></span>); getAD=<span class="hljs-number"><span class="hljs-number">1</span></span>; getBC=<span class="hljs-number"><span class="hljs-number">0</span></span>; delay_ms(<span class="hljs-number"><span class="hljs-number">30</span></span>); B=(~PINB)&amp;<span class="hljs-number"><span class="hljs-number">15</span></span>; C=(~(PIND&gt;&gt;<span class="hljs-number"><span class="hljs-number">3</span></span>)&amp;<span class="hljs-number"><span class="hljs-number">15</span></span>); delay_ms(<span class="hljs-number"><span class="hljs-number">30</span></span>); getBC=<span class="hljs-number"><span class="hljs-number">1</span></span>; t=<span class="hljs-number"><span class="hljs-number">100</span></span>*A+<span class="hljs-number"><span class="hljs-number">10</span></span>*B+C; } }</code> </pre><br> 该变量与类似的实时变量i的比较发生在中断函数中。 <br><br><pre> <code class="cpp hljs">interrupt [TIM1_COMPA] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timer1_compa_isr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ i+=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i&gt;=t){ RL=<span class="hljs-number"><span class="hljs-number">0</span></span>; }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ RL=<span class="hljs-number"><span class="hljs-number">1</span></span>; } TCNT1H=<span class="hljs-number"><span class="hljs-number">0x00</span></span>; TCNT1L=<span class="hljs-number"><span class="hljs-number">0x00</span></span>; }</code> </pre><br> 如果最后一个变量超过设定值，则“执行继电器”（RL = 0）将打开“ 0”。 此外，如果同时将开关设置为一个大于变量i的值，它将关闭。 在相同的中断功能中，变量i加1，计时器重置为0。 <br><br> 从MK上注销了FUSE位，并保持不变。 我分析了它们，那里一切都很好。 <br><br><img src="https://habrastorage.org/webt/zv/dt/ll/zvdtllilqlufxumtsv98xelmwnc.png"><br><br><br></div></div><br> 因此，不仅复制了设备图，而且还开发了MK程序，其功能与专有程序没有区别。 此外，在软件级别可以相当灵活地（最重要的是，免费）更改设备的时间参数，并在各种功能中使用控制输出（终端上的No.1）。 该程序非常简单，可以（甚至更好）用汇编器编写，但是我还没有做。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN414345/">https://habr.com/ru/post/zh-CN414345/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN414335/index.html">背景 Roskomnadzor，你是什么？</a></li>
<li><a href="../zh-CN414337/index.html">Ramda风格思维：不变性与对象</a></li>
<li><a href="../zh-CN414339/index.html">莫斯科联合办公新地点#tceh的精彩照片之旅</a></li>
<li><a href="../zh-CN414341/index.html">＃256移动开发人员的有趣材料摘要（6月3日至12日）</a></li>
<li><a href="../zh-CN414343/index.html">Google神经机器翻译</a></li>
<li><a href="../zh-CN414347/index.html">被动侵略：它如何破坏我们的工作生活以及如何应对</a></li>
<li><a href="../zh-CN414349/index.html">获取“我的客户中心”费用统计信息：Tinkoff和Rocketbank</a></li>
<li><a href="../zh-CN414351/index.html">最不寻常的乐器：Hammond Organ，Vako Orchestron和Synclavier</a></li>
<li><a href="../zh-CN414353/index.html">基维 从创造到生产是第一步。 第二部分</a></li>
<li><a href="../zh-CN414355/index.html">爆炸后的生活</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>