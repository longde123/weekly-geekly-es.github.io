<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßï üîµ ü•ü Teil 2: Verwenden der UDB-PSoC-Controller von Cypress, um die Anzahl der Interrupts in einem 3D-Drucker zu reduzieren üëá üÜî üíç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beim letzten Mal haben wir die M√∂glichkeit in Betracht gezogen, Impulse f√ºr Schrittmotoren zu erzeugen, die teilweise aus der Software auf Firmware-Eb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Teil 2: Verwenden der UDB-PSoC-Controller von Cypress, um die Anzahl der Interrupts in einem 3D-Drucker zu reduzieren</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434742/"><img src="https://habrastorage.org/webt/vx/mr/gy/vxmrgyrhaaffninezudmxyiex9c.jpeg"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beim letzten Mal haben</a> wir die M√∂glichkeit in Betracht gezogen, Impulse f√ºr Schrittmotoren zu erzeugen, die teilweise aus der Software auf Firmware-Ebene entfernt wurden.  Im Falle eines vollst√§ndigen Erfolgs verspricht dies, dass keine Interrupts verarbeitet werden m√ºssen, die mit einer Frequenz von bis zu 40 kHz ankommen.  Diese Option weist jedoch eine Reihe offensichtlicher M√§ngel auf.  Erstens werden Beschleunigungen dort nicht unterst√ºtzt.  Zweitens betr√§gt die Granularit√§t der zul√§ssigen Schrittfrequenzen in dieser L√∂sung Hunderte von Hertz (zum Beispiel ist es m√∂glich, Frequenzen von 40.000 Hz und 39966 Hz zu erzeugen, aber es ist unm√∂glich, Frequenzen mit einer Gr√∂√üe zwischen diesen beiden Werten zu erzeugen). <br><a name="habracut"></a><br><h2>  Beschleunigungsimplementierung </h2><br>  Ist es m√∂glich, die angegebenen Nachteile mit denselben UDB-Tools zu beseitigen, ohne das System zu komplizieren?  Lass es uns richtig machen.  Beginnen wir mit dem Schwierigsten - mit Beschleunigungen.  Beschleunigungen werden am Anfang und Ende des Pfades hinzugef√ºgt.  Erstens, wenn Hochfrequenzimpulse sofort an den Schrittmotor angelegt werden, ben√∂tigt er einen gr√∂√üeren Strom, um den Betrieb zu starten.  Ein hoher zul√§ssiger Strom ist Erw√§rmung und Rauschen, daher ist es besser, ihn zu begrenzen.  Aber dann kann der Motor beim Start Schritte √ºberspringen.  Es ist also besser, den Motor sanft zu beschleunigen.  Zweitens, wenn ein schwerer Kopf abrupt stoppt, erf√§hrt er Transienten, die mit Tr√§gheit verbunden sind.  Wellen sind auf Plastik sichtbar.  Daher ist es reibungslos notwendig, den Kopf nicht nur zu zerstreuen, sondern auch anzuhalten.  Klassischerweise wird ein Diagramm der Motordrehzahl als Trapez dargestellt.  Hier ist ein Fragment aus dem Quellcode der Marlin-Firmware: <br><br><img src="https://habrastorage.org/webt/wm/gg/ce/wmggcetcc0vy5tfgs3xsr2ewwoc.png"><br><br>  Ich werde nicht einmal versuchen herauszufinden, ob es m√∂glich ist, dies mit UDB zu implementieren.  Dies liegt an der Tatsache, dass jetzt eine andere Art der Beschleunigung in Mode ist: nicht trapezf√∂rmig, sondern S-Kurve.  Ihr Zeitplan sieht folgenderma√üen aus: <br><br><img src="https://habrastorage.org/webt/rs/hy/q9/rshyq94_sz6et-lgsbrpprdmyks.png"><br><br>  Dies ist definitiv nicht f√ºr UDB.  Aufgeben?  √úberhaupt nicht!  Ich habe bereits festgestellt, dass UDB keine Hardwareschnittstelle implementiert, sondern lediglich die √úbertragung eines Teils des Codes von der Software auf die Firmware-Ebene erm√∂glicht.  Lassen Sie das Profil den Zentralprozessor berechnen, und die Bildung von Schrittimpulsen f√ºhrt immer noch UDB durch.  Der Zentralprozessor hat viel Zeit f√ºr Berechnungen.  Die Aufgabe, h√§ufige Unterbrechungen zu vermeiden, wird weiterhin recht elegant gel√∂st, und niemand hat geplant, den Prozess vollst√§ndig auf Firmware-Ebene zu bringen. <br><br>  Nat√ºrlich muss das Profil im Speicher vorbereitet werden, und UDB nimmt mit DMA Daten von dort auf.  Aber wie viel Speicher wird ben√∂tigt?  Ein Millimeter ben√∂tigt 200 Schritte.  Jetzt mit 24-Bit-Codierung sind dies 600 Bytes pro 1 mm Kopfbewegung!  Erinnern Sie sich noch einmal an nicht so h√§ufige, aber immer noch st√§ndige Unterbrechungen, um alles in Fragmenten zu √ºbertragen?  Nicht wirklich!  Tatsache ist, dass der DMA-Mechanismus von PSoC auf Deskriptoren basiert.  Nachdem die Aufgabe von einem Deskriptor ausgef√ºhrt wurde, f√§hrt der DMA-Controller mit dem n√§chsten fort.  Entlang der Kette k√∂nnen Sie also viele Deskriptoren verwenden.  Wir veranschaulichen dies anhand einer Zeichnung aus der offiziellen Dokumentation: <br><br><img src="https://habrastorage.org/webt/ju/hv/6b/juhv6bqptp3uagog5bfgxlmxw0q.png"><br><br>  Tats√§chlich kann dieser Mechanismus auch verwendet werden, indem eine Kette von drei Deskriptoren erstellt wird: <br><br><table><tbody><tr><th>  Nein, nein. </th><th>  Erkl√§rung </th></tr><tr><td>  1 </td><td>  Vom Speicher zum FIFO mit Adressinkrement.  Zeigt einen Abschnitt mit einem Beschleunigungsprofil an. </td></tr><tr><td>  2 </td><td>  Vom Speicher zum FIFO ohne Adressinkrement.  Sendet f√ºr konstante Geschwindigkeit die ganze Zeit an dasselbe Wort im Speicher. </td></tr><tr><td>  3 </td><td>  Vom Speicher zum FIFO mit Adressinkrement.  Zeigt einen Abschnitt mit einem Bremsprofil an. <br></td></tr></tbody></table><br>  Es stellt sich heraus, dass der Hauptpfad in Schritt 2 beschrieben wird und dort physikalisch dasselbe Wort verwendet wird, das die konstante Geschwindigkeit festlegt.  Der Speicherverbrauch ist nicht gro√ü.  In der Realit√§t kann der zweite Deskriptor physikalisch durch zwei oder drei Deskriptoren dargestellt werden.  Dies liegt an der Tatsache, dass die maximale Pumpl√§nge laut TRM 64 Kilobyte betragen kann (die √Ñnderung wird geringer sein).  Das sind 32.767 W√∂rter.  Das bei 200 Schritten pro Millimeter entspricht einem Weg von 163 Millimetern.  Abh√§ngig von der maximalen Entfernung, die der Motor gleichzeitig fahren kann, m√ºssen Sie m√∂glicherweise ein Segment aus zwei oder drei Teilen erstellen. <br><br>  Um Speicherplatz (und die Kosten f√ºr UDB-Bl√∂cke) zu sparen, schlage ich dennoch vor, 24-Bit-DatapPath-Bl√∂cke aufzugeben und auf wirtschaftlichere 16-Bit-Bl√∂cke umzusteigen. <br><br>  <b>Also.</b>  <b>Der erste Vorschlag zur √úberarbeitung.</b> <b><br><br></b>  <b>Im Speicher werden Arrays vorbereitet, die die Dauer der Schritte codieren.</b>  <b>Ferner gehen diese Informationen unter Verwendung von DMA an UDB.</b>  <b>Der geradlinige Abschnitt wird von einem Array aus einem Element codiert. Der DMA-Block erh√∂ht die Adresse nicht und w√§hlt immer das gleiche Element aus.</b>  <b>Beschleunigungs-, geradlinige und Bremsabschnitte werden √ºber die im DMA-Controller verf√ºgbaren Mittel verbunden.</b> <br><br><h2>  Feineinstellung des Mitteltonbereichs </h2><br>  Nun werden wir uns √ºberlegen, wie das Problem der Frequenzgranularit√§t √ºberwunden werden kann.  Nat√ºrlich kann es nicht genau eingestellt werden.  Tats√§chlich kann die urspr√ºngliche "Firmware" dies jedoch auch nicht.  Stattdessen verwenden sie den Bresenham-Algorithmus.  Einige Schritte werden um eine Ma√ünahme verz√∂gert.  Infolgedessen wird die durchschnittliche Frequenz zwischen einem kleineren und einem gr√∂√üeren Wert dazwischen.  Durch Anpassen des Verh√§ltnisses von regul√§ren und l√§ngeren Perioden k√∂nnen Sie die durchschnittliche Frequenz problemlos √§ndern.  Wenn unsere Geschwindigkeit jetzt nicht √ºber das Datenregister eingestellt, sondern √ºber FIFO √ºbertragen wird und die Anzahl der Impulse im Allgemeinen √ºber die Anzahl der √ºber DMA √ºbertragenen W√∂rter eingestellt wird, werden beide Datenregister in UDB freigegeben.  Zus√§tzlich wird eine der Batterien freigegeben, die die Anzahl der Impulse z√§hlt.  Hier werden wir eine bestimmte PWM darauf aufbauen. <br><br>  In der Regel vergleichen ALUs Register mit demselben Index und weisen sie zu.  Wenn ein Register einen Index von 0 und das andere eine 1 hat, kann nicht jede Version der Operation implementiert werden.  Aber ich habe es geschafft, den Solitaire aus den Registern zusammenzustellen, unter denen PWM durchgef√ºhrt werden kann.  Es stellte sich heraus, wie in der Abbildung gezeigt. <br><br><img src="https://habrastorage.org/webt/nc/yv/vq/ncyvvqcqptj3lm4an82idlrrl-c.png"><br><br>  Wenn die Bedingung A0 &lt;D1 erf√ºllt ist, f√ºgen wir der gegebenen Pulsl√§nge einen zus√§tzlichen Schlag hinzu.  Wenn die Bedingung nicht erf√ºllt ist, werden wir nicht. <br><br><h2>  Kugelpferd unter normalen Bedingungen </h2><br>  Daher beginnen wir, den entwickelten Block f√ºr UDB unter Ber√ºcksichtigung der neuen Architektur zu modifizieren.  Ersetzen Sie die Datapath-Bittiefe: <br><br><img src="https://habrastorage.org/webt/cj/-m/ae/cj-mae3coaxgzro0er5mkraun4q.png"><br><br>  Wir werden viel mehr Ausg√§nge von Datapath brauchen als beim letzten Mal. <br><br><img src="https://habrastorage.org/webt/ua/td/hn/uatdhnswe_uzmqinll0wyhsyifg.png"><br><br>  Wenn Sie darauf doppelklicken, sehen Sie die Details: <br><br><img src="https://habrastorage.org/webt/vq/3p/24/vq3p24frqv0uiumytbvn-ewhi1w.png"><br><br>  Es gibt mehr Ziffern f√ºr die Statusvariable. Vergessen Sie nicht, die √§ltere zu verbinden !!!  In der alten Version gab es eine Konstante 0. <br><br><img src="https://habrastorage.org/webt/0l/dm/fy/0ldmfyci2byicjdsksvkdkg8k04.png"><br><br>  Das √úbergangsdiagramm des Automaten, das ich erhalten habe, lautet wie folgt: <br><br><img src="https://habrastorage.org/webt/hb/5u/nq/hb5unqu_fmfc6sd9k7m3_x0wr7s.png"><br><br>  Wir befinden uns im Ruhezustand, w√§hrend FIFO1 leer ist.  Die Arbeit mit FIFO1 und nicht mit FIFO0 ist √ºbrigens das Ergebnis der Bildung von Solitaire.  Das Register A0 wird verwendet, um PWM zu implementieren, so dass die Impulsbreite durch das Register A1 bestimmt wird.  Und ich kann es nur von FIFO1 herunterladen (vielleicht gibt es andere geheime Methoden, aber sie sind mir nicht bekannt).  Daher l√§dt DMA Daten genau in FIFO1 hoch, und genau der Status <b>"Nicht leer"</b> f√ºr FIFO1 verl√§sst den Ruhezustand. <br><br>  ALU im <b>IDLE-</b> Status macht das Register A0 ung√ºltig: <br><br><img src="https://habrastorage.org/webt/1r/i5/-i/1ri5-iydlu00cfobufepmiaqucg.png"><br><br>  Dies ist notwendig, damit zu Beginn des PWM-Betriebs die Arbeit immer von vorne beginnt. <br>  Aber die Daten kamen in den FIFO.  Der Computer wechselt in den <b>LoadData-</b> Status: <br><br><img src="https://habrastorage.org/webt/3v/rf/dx/3vrfdxwme_jw6m69bwrpybhiots.png"><br><br>  In diesem Zustand l√§dt die ALU das n√§chste Wort vom FIFO in das Register A1.  Um keine unn√∂tigen Zust√§nde zu erzeugen, wird der Wert des Z√§hlers A0, der f√ºr die Arbeit mit PWM verwendet wird, erh√∂ht: <br><br><img src="https://habrastorage.org/webt/t4/ki/je/t4kijee95z-kbmn1n3ikcgtc9qk.png"><br><br>  Wenn der Z√§hler A0 den Wert D0 noch nicht erreicht hat ( <b>dh</b> die Bedingung A0 &lt;D0 wird ausgel√∂st, wobei das Flag <b>NoNeedReloadA0 gespannt wird</b> ), gehen wir zum Zustand <b>Eins</b> .  Andernfalls lautet der Status <b>ClearA0</b> . <br><br>  Im <b>ClearA0-</b> Zustand <b>setzt die</b> ALU einfach den Wert von A0 auf <b>Null</b> und startet einen neuen PWM-Zyklus: <br><br><img src="https://habrastorage.org/webt/0_/pj/ah/0_pjahunjhl34izkpv5k9lplxem.png"><br><br>  Danach geht die Maschine auch in <b>einen</b> Zustand √ºber, nur einen Schlag sp√§ter. <br><br>  <b>Man</b> kennt uns aus der alten Version der Maschine.  Die darin enthaltene ALU f√ºhrt keine Funktionen aus. <br><br>  Und so - in diesem Zustand wird eine Einheit am Ausgang von <b>Out_Step erzeugt</b> (hier hat der Optimierer besser funktioniert, wenn die Einheit durch die Bedingung erzeugt wird, dies wurde empirisch erkannt). <br><br><img src="https://habrastorage.org/webt/aq/mj/ml/aqmjmluzxutxzq_caddtls15hfc.png"><br><br>  Wir befinden uns in diesem Zustand, bis der uns bereits bekannte Sieben-Bit-Z√§hler auf Null zur√ºckgesetzt wird.  Aber wenn wir fr√ºher auf einem Weg aus diesem Zustand herausgekommen sind, kann es jetzt zwei Wege geben: direkt und verz√∂gert im Takt. <br><br><img src="https://habrastorage.org/webt/53/fk/qc/53fkqcxnlvsf52sxzb8e1ijnpkk.png"><br><br>  Wir werden in den ExtraTick-Status versetzt, wenn das <b>AddCycle-</b> Flag <b>gesetzt ist</b> , das zugewiesen ist, um die Bedingung A0 &lt;D1 zu erf√ºllen.  In diesem Zustand f√ºhrt die ALU keine n√ºtzlichen Aktionen aus.  Es ist nur so, dass der Zyklus 1 Schlag l√§nger dauert.  Au√üerdem konvergieren alle Pfade im <b>Verz√∂gerungszustand</b> . <br><br>  Dieser Zustand misst die Dauer des Impulses.  Das Register A1 (geladen, w√§hrend es sich noch im <b>Ladezustand befindet</b> ) wird reduziert, bis es Null erreicht. <br><br><img src="https://habrastorage.org/webt/bi/ct/jt/bictjtwgqikkvuz4pqmp7owacii.png"><br><br>  Abh√§ngig davon, ob zus√§tzliche Daten im FIFO vorhanden sind oder nicht, wechselt die Maschine zum Abrufen des n√§chsten Abschnitts im <b>Ladezustand</b> oder im <b>Ruhezustand</b> .  Schauen wir uns das nicht in der Abbildung an (es gibt lange Pfeile, alles wird klein sein), sondern in Form einer Tabelle, indem Sie auf den <b>Verz√∂gerungsstatus</b> doppelklicken: <br><br><img src="https://habrastorage.org/webt/bb/cr/dq/bbcrdq1jfhxret5vbaoexfsr-iq.png"><br><br>  Beendet jetzt UDB.  Ich habe das Flag "Im <b>Ruhezustand"</b> in einen asynchronen Vergleich umgewandelt (in der vorherigen Version gab es einen Trigger, der in verschiedenen Zust√§nden gespannt und zur√ºckgesetzt wurde), da der Optimierer daf√ºr das beste Ergebnis zeigte.  Au√üerdem wurde das <b>Hungry-</b> Flag hinzugef√ºgt, das der DMA-Einheit signalisiert, dass sie bereit ist, Daten zu empfangen.  Es ist auf der Flagge <b>‚ÄûFIFO1 ist nicht √ºberf√ºllt‚Äú</b> aufgewickelt.  Da es nicht √ºberf√ºllt ist, kann DMA dort ein anderes Datenwort laden. <br><br><img src="https://habrastorage.org/webt/w8/ea/b-/w8eab-2dwdxvtvyr3hfukjrev9w.png"><br><br>  Auf der automatischen Seite - das war's. <br><br>  F√ºgen Sie dem Hauptprojektdiagramm DMA-Bl√∂cke hinzu.  Vorerst habe ich angefangen, DMA-Beendigungsflags zu unterbrechen, aber nicht die Tatsache, dass dies korrekt ist.  Wenn der Prozess des direkten Zugriffs auf den Speicher abgeschlossen ist, k√∂nnen Sie einen neuen Prozess starten, der sich auf dasselbe Segment bezieht. Sie k√∂nnen jedoch keine Informationen √ºber das neue Segment ausf√ºllen.  FIFO hat noch drei bis vier Elemente.  Zu diesem Zeitpunkt ist es immer noch unm√∂glich, die Register D0 und D1 des Blocks basierend auf UDB neu zu programmieren, sie werden immer noch f√ºr den Betrieb ben√∂tigt.  Daher ist es m√∂glich, dass Interrupts basierend auf den <b>Out_Idle-</b> Ausg√§ngen sp√§ter hinzugef√ºgt werden.  Diese K√ºche wird sich jedoch nicht mehr auf die UDB-Blockprogrammierung beziehen, daher werden wir sie nur nebenbei erw√§hnen. <br><br><img src="https://habrastorage.org/webt/4o/g7/y2/4og7y21diqgqr6qn7_iehukiqho.png"><br><br><h2>  Software-Experimente </h2><br>  Da jetzt nicht alles bekannt ist, werden wir keine speziellen Funktionen schreiben.  Alle Kontrollen werden "Auf der Stirn" durchgef√ºhrt.  Basierend auf erfolgreichen Experimenten k√∂nnen dann API-Funktionen geschrieben werden.  Also.  Wir machen die <b>main () -</b> Funktion minimal.  Es richtet einfach das System ein und ruft den ausgew√§hlten Test auf. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ CyGlobalIntEnable; <span class="hljs-comment"><span class="hljs-comment">/* Enable global interrupts. */</span></span> <span class="hljs-comment"><span class="hljs-comment">// isr_1_StartEx(StepperFinished); StepperController_X_Start(); StepperController_Y_Start(); StepperController_Z_Start(); StepperController_E0_Start(); StepperController_E1_Start(); // TestShortSteps(); TestWithPacking (); for(;;) { }</span></span></code> </pre> <br>  Versuchen wir, ein Paket von Impulsen zu senden, indem wir eine Funktion aufrufen und die Tatsache √ºberpr√ºfen, dass ein zus√§tzlicher Impuls eingef√ºgt wird.  Der Funktionsaufruf ist einfach: <br><br><pre> <code class="plaintext hljs">TestShortSteps();</code> </pre><br>  Aber der K√∂rper bedarf einer Erkl√§rung. <div class="spoiler">  <b class="spoiler_title">Ich werde zuerst die ganze Funktion geben</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void TestShortSteps() { //   ,   //      //   ,  DMA    !!! //    ,   !!! StepperController_X_SingleVibrator_WritePeriod (6); //     //    ‚Äî   CY_SET_REG16(StepperController_X_Datapath_1_D0_PTR, 4); CY_SET_REG16(StepperController_X_Datapath_1_D1_PTR, 2); //         . //         static const uint16 steps[] = { 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001, 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001 }; //  DMA  ,      uint8 channel = DMA_X_DmaInitialize (sizeof(steps[0]),1,HI16(steps),HI16(StepperController_X_Datapath_1_F1_PTR)); CyDmaChRoundRobin (channel,true); //       ,       uint8 td = CyDmaTdAllocate(); //       .  ,    . CyDmaTdSetConfiguration(td, sizeof(steps), CY_DMA_DISABLE_TD, TD_INC_SRC_ADR | TD_AUTO_EXEC_NEXT); //       CyDmaTdSetAddress(td, LO16((uint32)steps), LO16((uint32)StepperController_X_Datapath_1_F1_PTR)); //      CyDmaChSetInitialTd(channel, td); //         CyDmaChEnable(channel, 1); }</code> </pre><br></div></div><br>  Betrachten Sie nun die wichtigen Teile. <br><br>  Wenn die L√§nge des positiven Teils des Impulses 92 Taktzyklen entspricht, kann das Oszilloskop nicht erkennen, ob sich im negativen Teil ein Einzelzyklus-Einsatz befindet oder nicht.  Die Skala wird nicht gleich sein.  Es ist notwendig, den positiven Teil so kurz wie m√∂glich zu machen, damit der Gesamtimpuls im Ma√üstab mit dem eingef√ºgten Schlag vergleichbar ist.  Daher √§ndere ich die Periode des Z√§hlers, die die Dauer des positiven Teils des Impulses festlegt, mit Nachdruck: <br><br><pre> <code class="plaintext hljs"> //   ,   //      //   ,  DMA    !!! //    ,   !!! StepperController_X_SingleVibrator_WritePeriod (6);</code> </pre><br>  Aber warum sechs ganze Ma√ünahmen?  Warum nicht drei?  Warum nicht zwei?  Warum doch keiner?  Das ist eine traurige Geschichte.  Wenn der positive Impuls k√ºrzer als 6 Zyklen ist, funktioniert das System nicht.  Langes Debuggen auf einem Oszilloskop mit der Ausgabe von Testleitungen nach au√üen zeigte, dass DMA keine schnelle Sache ist.  Wenn die Maschine weniger als eine bestimmte Dauer l√§uft, ist das FIFO zum Zeitpunkt des <b>Verlassens des Verz√∂gerungsstatus</b> meistens noch leer.  Es darf noch kein einziges neues Datenwort platziert werden!  Und nur wenn der positive Teil des Impulses eine Dauer von 6 Zyklen hat, hat FIFO garantiert Zeit zum Laden ... <br><br><h2>  Latenz Exkurs </h2><br>  Eine weitere feste Idee, die mir in den Sinn kommt, ist die Hardwarebeschleunigung bestimmter Funktionen des Kernels unseres RTOS MAX.  Aber leider sind alle meine besten Ideen √ºber die gleichen Latenzen gebrochen. <br><br>  Es gab einen Fall, in dem ich die Entwicklung von Bare-Metal-Anwendungen f√ºr Cyclone V SoC untersucht habe.  Es stellte sich jedoch heraus, dass die Arbeit mit einzelnen FPGA-Registern (wenn abwechselnd darauf geschrieben und dann von ihnen gelesen wird) die Kernoperation hunderte (!!!) Mal reduziert.  Du hast richtig geh√∂rt.  Es ist in Hunderten.  Dar√ºber hinaus ist all dies schlecht dokumentiert, aber zuerst sp√ºrte ich innerlich und bewies dann anhand von Phrasenfetzen aus der Dokumentation, dass Latenzen schuldig waren, wenn Anfragen √ºber eine Reihe von Br√ºcken weitergeleitet wurden.  Wenn Sie ein gro√ües Array austreiben m√ºssen, tritt ebenfalls eine Latenz auf, die jedoch in Bezug auf ein gepumptes Wort nicht von Bedeutung ist.  Wenn die Anforderungen einzeln sind (und die Hardwarebeschleunigung des Betriebssystemkerns nur diese impliziert), erfolgt die Verlangsamung genau hunderte Male.  Es wird viel schneller sein, alles rein programmatisch zu erledigen, wenn das Programm mit rasendem Tempo mit dem Hauptspeicher durch den Cache arbeitet. <br><br>  Auf PSoC hatte ich auch bestimmte Pl√§ne.  Im Erscheinungsbild k√∂nnen Sie mit DMA und UDB wunderbar nach Daten in einem Array suchen.  Was ist wirklich da!  Aufgrund der DMA-Deskriptorstruktur k√∂nnten diese Controller eine vollst√§ndige Hardware-Suche in verkn√ºpften Listen durchf√ºhren!  Nachdem ich den oben beschriebenen Stecker erhalten hatte, stellte ich fest, dass er auch mit Latenz verbunden ist.  Hier wird diese Latenz in der Dokumentation sehr sch√∂n beschrieben.  Sowohl in der Familie TRM als auch in einem separaten Dokument <b>AN84810 - PSoC 3 und PSoC 5LP Advanced DMA Topics</b> .  Dort ist Abschnitt 3.2 diesem Thema gewidmet.  Die n√§chste Hardwarebeschleunigung wird also abgebrochen.  Schade.  Aber wie Semyon Semyonovich Gorbunkov sagte: "Wir werden suchen." <br><br><h2>  Fortsetzung der Softwareexperimente </h2><br>  Als n√§chstes stelle ich die Parameter des Bresenham-Algorithmus ein: <br><br><pre> <code class="plaintext hljs"> //     //    ‚Äî   CY_SET_REG16(StepperController_X_Datapath_1_D0_PTR, 4); CY_SET_REG16(StepperController_X_Datapath_1_D1_PTR, 2);</code> </pre><br>  Nun, dann kommt der regul√§re Code, der ein Array von W√∂rtern √ºber DMA an FIFO1 des Motorsteuerger√§ts X √ºbertr√§gt. <br><br>  Das Ergebnis bedarf einiger Erkl√§rung.  Da ist er: <br><br><img src="https://habrastorage.org/webt/bi/hg/ie/bihgiepg_iskg-wor_g4iqnv1ti.png"><br><br>  Der Wert des Z√§hlers A0 wird rot angezeigt, wenn sich die Maschine im Zustand <b>Eins befindet</b> .  Das gr√ºne Sternchen zeigt F√§lle an, in denen die Verz√∂gerung eingef√ºgt wird, weil sich das Ger√§t im <b>ExtraTick-</b> Status befindet.  Es gibt auch Balken, bei denen die Verz√∂gerung auf den <b>ClearA0-</b> Status zur√ºckzuf√ºhren ist. Sie sind mit einem blauen Raster gekennzeichnet. <br><br>  Wie Sie sehen, geht beim ersten Eingeben die allererste Verz√∂gerung verloren.  Dies liegt an der Tatsache, dass A0 im <b>Leerlauf zur√ºckgesetzt wird</b> , sich jedoch erh√∂ht, wenn es <b>LoadData eingibt</b> .  Bis zur Analyse (Austritt aus dem Zustand <b>Eins</b> ) ist es daher bereits gleich Einheit.  Der Account beginnt bei ihr.  Im Allgemeinen wirkt sich dies jedoch nicht auf die Mittelfrequenz aus.  Es muss nur beachtet werden.  Da zu beachten ist, dass beim Zur√ºcksetzen von A0 auch die Uhr eingef√ºgt wird.  Dies muss bei der Berechnung der Durchschnittsfrequenz ber√ºcksichtigt werden. <br><br>  Im Allgemeinen ist die Anzahl der Impulse jedoch korrekt.  Ihre Dauer ist auch glaubw√ºrdig. <br>  Versuchen wir, eine realere Kette von Deskriptoren zu programmieren. <br><br><div class="spoiler">  <b class="spoiler_title">bestehend aus einer Phase des Beschleunigens, der linearen Bewegung und des Bremsens.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void TestWithPacking(int countOnLinearStage) { //   ,   //     . //   ,  DMA    !!! //    ,   !!! StepperController_X_SingleVibrator_WritePeriod (6); //     //    ‚Äî   CY_SET_REG16(StepperController_X_Datapath_1_D0_PTR, 4); CY_SET_REG16(StepperController_X_Datapath_1_D1_PTR, 2); //    static const uint16 accelerate[] = {0x0010,0x0008,0x0004}; //    static const uint16 deccelerate[] = {0x004,0x0008,0x0010}; //  .    . static const uint16 steps[] = {0x0001}; //  DMA  ,      uint8 channel = DMA_X_DmaInitialize (sizeof(steps[0]),1,HI16(steps),HI16(StepperController_X_Datapath_1_F1_PTR)); CyDmaChRoundRobin (channel,true); //   uint8 tdDeccelerate = CyDmaTdAllocate(); CyDmaTdSetConfiguration(tdDeccelerate, sizeof(deccelerate), CY_DMA_DISABLE_TD, TD_INC_SRC_ADR | TD_AUTO_EXEC_NEXT); CyDmaTdSetAddress(tdDeccelerate, LO16((uint32)deccelerate), LO16((uint32)StepperController_X_Datapath_1_F1_PTR)); //       uint8 tdSteps = CyDmaTdAllocate(); //   !!! //     !!! CyDmaTdSetConfiguration(tdSteps, countOnLinearStage, tdDeccelerate, /*TD_INC_SRC_ADR |*/ TD_AUTO_EXEC_NEXT); CyDmaTdSetAddress(tdSteps, LO16((uint32)steps), LO16((uint32)StepperController_X_Datapath_1_F1_PTR)); //   //     !!! uint8 tdAccelerate = CyDmaTdAllocate(); CyDmaTdSetConfiguration(tdAccelerate, sizeof(accelerate), tdSteps, TD_INC_SRC_ADR | TD_AUTO_EXEC_NEXT); CyDmaTdSetAddress(tdAccelerate, LO16((uint32)accelerate), LO16((uint32)StepperController_X_Datapath_1_F1_PTR)); //      CyDmaChSetInitialTd(channel, tdAccelerate); //         CyDmaChEnable(channel, 1); }</code> </pre><br></div></div><br>  Rufen Sie zun√§chst dieselben zehn Schritte auf (in DMA gehen tats√§chlich 20 Bytes): <br><br><pre> <code class="plaintext hljs">TestWithPacking (20);</code> </pre><br>  Das Ergebnis ist wie erwartet.  Zu Beginn ist eine Beschleunigung sichtbar.  Und der Ausgang zu <b>IDLE</b> (blauer Strahl) erfolgt mit einer gro√üen Verz√∂gerung vom letzten Impuls, dann war der letzte Schritt vollst√§ndig abgeschlossen, sein Wert ist ungef√§hr gleich dem Wert des ersten. <br><br><img src="https://habrastorage.org/webt/5y/tb/na/5ytbna9ixcuxv5-i35tinzixy0e.png"><br><br><h2>  Echtes Pferd unter normalen Bedingungen </h2><br>  Beim Umbau der Ausr√ºstung bin ich irgendwie von einer 24-Bit-Impulsbreite zu einem 16-Bit-Job gesprungen.  Wir haben jedoch herausgefunden, dass dies nicht m√∂glich ist: Die minimale Pulsfrequenz ist zu hoch.  Ich habe es absichtlich gemacht.  Tatsache ist, dass sich die Technik zum Erweitern der Bitkapazit√§t eines 16-Bit-Z√§hlers als so kompliziert herausstellte, dass sie, wenn ich sie zusammen mit der Hauptmaschine beschrieben h√§tte, die ganze Aufmerksamkeit abgelenkt h√§tte.  Daher betrachten wir es separat. <br><br>  Wir haben eine 16-Bit-Batterie.  Ich beschloss, den hohen Bits die Sieben-Bit-Z√§hler-Standardentit√§t hinzuzuf√ºgen.  Was ist dieser Sieben-Bit-Z√§hler?  Dies ist das Design, das in jedem UDB-Block verf√ºgbar ist (der Basis-UDB-Block hat eine Bitbreite aller 8-Bit-Register, die Zunahme der Bittiefe wird durch die Kombination von Bl√∂cken in Gruppen bestimmt).  Von denselben Ressourcen k√∂nnen <b>Steuer- / Statusregister</b> implementiert werden.  Jetzt haben wir einen Z√§hler und kein einziges <b>Steuerungs- / Statuspaar</b> f√ºr 16 Datenbits.  Wenn Sie dem System einen weiteren Z√§hler hinzuf√ºgen, werden wir die zus√§tzlichen Ressourcen nicht verz√∂gern.  Wir nehmen nur das, was uns bereits zugewiesen ist.  Das ist sch√∂n!  Wir machen das hohe Byte des Impulsbreitenz√§hlers durch diesen Mechanismus und erhalten die Gesamtbreite des Impulsbreitenz√§hlers gleich 23 Bit. <br><br><img src="https://habrastorage.org/webt/_k/nc/-h/_knc-hzlxwos6a8jdzopy3pj2ww.png"><br><br>  Zuerst werde ich sagen, was ich gedacht habe.  Ich dachte, dass ich nach dem Verlassen des <b>Verz√∂gerungsstatus</b> den Abschluss der Z√§hlung dieses zus√§tzlichen Z√§hlers √ºberpr√ºfen w√ºrde.  Wenn er nicht fertig gez√§hlt hat, werde ich seinen Wert reduzieren und wieder in den <b>Verz√∂gerungszustand</b> wechseln.  Wenn Sie gez√§hlt haben, bleibt die Logik unver√§ndert, ohne zus√§tzliche Zyklen hinzuzuf√ºgen. <br><br>  Dar√ºber hinaus besagt die Dokumentation f√ºr diesen Z√§hler, dass ich Recht habe.  W√∂rtlich hei√üt es: <br><blockquote>  Zeitraum <br>  Definiert den Anfangsperiodenregisterwert.  F√ºr eine Periode von N Takten sollte der Periodenwert auf den Wert von N-1 gesetzt werden.  Der Z√§hler z√§hlt von N-1 bis 0, was zu einer N-Taktzyklusperiode f√ºhrt.  <b><i>Ein Periodenregisterwert von 0 wird nicht unterst√ºtzt und f√ºhrt dazu, dass die Terminalz√§hlausgabe auf einem konstant hohen Zustand gehalten wird.</i></b> </blockquote>  Das Leben hat gezeigt, dass alles anders ist.  Ich habe den Zustand der <b>Terminalz√§hllinie</b> auf dem Oszilloskop abgeleitet und ihren Wert bei einer vorinstallierten Null in <b>Periode</b> und w√§hrend des Programmladens beobachtet.  Ach und ah.  Es gab keinen <b>konstant hohen Zustand</b> ! <br><br>  Durch Versuch und Irrtum gelang es mir, das System ordnungsgem√§√ü zum Laufen zu bringen, aber dazu muss mindestens eine Subtraktion vom Z√§hler erfolgen!  Der neue Zustand der <b>"Subtraktion" ist</b> nicht auf der Seite.  Es musste in den erforderlichen Pfad eingeklemmt werden.  Es befindet sich vor dem <b>Verz√∂gerungsstatus</b> und hei√üt <b>Next65536</b> . <br><br><img src="https://habrastorage.org/webt/cp/6f/oz/cp6fozy_kflvs6eu6w-ho9ebmcu.png"><br><br>  ALU f√ºhrt in diesem Zustand keine n√ºtzlichen Aktionen aus.  Tats√§chlich reagiert nur ein neuer Z√§hler auf die Tatsache, dass er sich in diesem Zustand befindet.  Hier ist es im Diagramm: <br><br><img src="https://habrastorage.org/webt/mh/tb/br/mhtbbr8strxue23n6jmg_giocjc.png"><br><br>  Hier sind seine Eigenschaften im Detail: <br><br><img src="https://habrastorage.org/webt/oo/t5/rs/oot5rs3_cdplwr94gno3poavzkq.png"><br><br>  Unter Ber√ºcksichtigung der vorherigen Artikel ist das Wesen dieses Z√§hlers im Allgemeinen klar.  Nur die <b>Enable-</b> Linie leidet.  Auch hier verstehe ich nicht ganz, warum es eingeschaltet werden sollte, wenn sich die Maschine im <b>LoadData-</b> Status befindet (dann l√§dt der Z√§hler den Periodenwert neu).  Ich habe diesen Trick aus den Eigenschaften des Z√§hlers entlehnt, der die LEDs steuert, der dem englischen Autor der Steuereinheit f√ºr diese LEDs entnommen wurde.  Ohne sie funktioniert der Nullwert der Periode nicht.  Sie arbeitet mit ihr. <br><br>  Im API-Code f√ºgen wir die Initialisierung eines neuen Z√§hlers hinzu.  Jetzt sieht die Startfunktion folgenderma√üen aus: <br><br><pre> <code class="plaintext hljs">void `$INSTANCE_NAME`_Start() { `$INSTANCE_NAME`_SingleVibrator_Start(); //"One" Generator start `$INSTANCE_NAME`_Plus65536_Start(); }</code> </pre><br>  Schauen wir uns das neue System an.  Hier ist der Funktionscode zum Testen <br><br><div class="spoiler">  <b class="spoiler_title">(darin unterscheidet sich nur die erste Zeile von der bereits bekannten):</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void JustTest(int extra65536s) { //      65536  StepperController_X_Plus65536_WritePeriod((uint8) extra65536s); //     //    ‚Äî   CY_SET_REG16(StepperController_X_Datapath_1_D0_PTR, 4); CY_SET_REG16(StepperController_X_Datapath_1_D1_PTR, 2); //         . //         static const uint16 steps[] = { 0x1000,0x1000,0x1000,0x1000 }; //  DMA  ,      uint8 channel = DMA_X_DmaInitialize (sizeof(steps[0]),1,HI16(steps),HI16(StepperController_X_Datapath_1_F1_PTR)); CyDmaChRoundRobin (channel,true); //       ,       uint8 td = CyDmaTdAllocate(); //       .  ,    . CyDmaTdSetConfiguration(td, sizeof(steps), CY_DMA_DISABLE_TD, TD_INC_SRC_ADR | TD_AUTO_EXEC_NEXT); //       CyDmaTdSetAddress(td, LO16((uint32)steps), LO16((uint32)StepperController_X_Datapath_1_F1_PTR)); //      CyDmaChSetInitialTd(channel, td); //         CyDmaChEnable(channel, 1); }</code> </pre><br></div></div><br>  Wir nennen es so: <br><br><pre> <code class="plaintext hljs"> JustTest(0);</code> </pre><br>  Auf dem Oszilloskop sehen wir Folgendes (gelber Strahl - STEP-Ausgang, blauer Wert des Z√§hler-TC-Ausgangs f√ºr die Prozesssteuerung).  Die Pulsdauer wird durch das <b>Schrittarray eingestellt</b> .  Bei jedem Schritt betr√§gt die Dauer 0x1000 Takte. <br><br><img src="https://habrastorage.org/webt/ap/q7/df/apq7dfk6t5kns3qtzjmkuzzw-44.png"><br><br>  Wechseln Sie zu einem anderen Scan, damit verschiedene Ergebnisse kompatibel sind: <br><br><img src="https://habrastorage.org/webt/zl/6s/2o/zl6s2oop2bft0ndatbawfdrtacw.png"><br><br>  √Ñndern Sie den Funktionsaufruf in: <br><br><pre> <code class="plaintext hljs"> JustTest(1);</code> </pre><br>  Das Ergebnis ist wie erwartet.  Zuerst ist der TC-Ausgang f√ºr 0x1000 Zyklen Null, dann - eine Einheit f√ºr 0x10000 (65536d) Zyklen.  Die Frequenz betr√§gt ungef√§hr 700 Hertz, wie wir im letzten Teil des Artikels herausgefunden haben, also ist alles richtig. <br><br><img src="https://habrastorage.org/webt/nm/5q/6s/nm5q6s73zb7yqxtvuxzrxis4f5i.png"><br><br>  Nun, versuchen wir es mit einer Zwei: <br><br><pre> <code class="plaintext hljs"> JustTest(2);</code> </pre><br>  Wir bekommen: <br><br><img src="https://habrastorage.org/webt/ah/sp/7y/ahsp7ymdefdyl04acuefc3ufct8.png"><br><br>  Alles ist richtig.  Der TC-Ausgang wird in den letzten 65536-Taktzyklen auf eins gestellt.  Davor war er f√ºr 0x1000 + 0x10000 Zyklen bei Null. <br><br>  Bei diesem Ansatz sollten nat√ºrlich alle Impulse den gleichen Wert wie der neue Z√§hler haben.  Es ist unm√∂glich, w√§hrend der Beschleunigung einen Impuls mit dem h√∂chsten Byte zu erzeugen, z. B. 3, dann 1, dann 0. Tats√§chlich haben Beschleunigungen bei so niedrigen Frequenzen (weniger als siebenhundert Hertz) keine physikalische Bedeutung, daher kann dieses Problem vernachl√§ssigt werden.  Bei dieser Frequenz k√∂nnen Sie linear mit dem Motor arbeiten. <br><br><h2>  Fliege in die Salbe </h2><br>  Das TRM-Dokument f√ºr die PSoC5LP-Familie lautet: <br><blockquote>  Jede Transaktion kann zwischen 1 und 64 KB gro√ü sein </blockquote>  Aber in der bereits erw√§hnten AN84810 gibt es einen solchen Satz: <br><blockquote>  1. Wie k√∂nnen Sie mit DMA mehr als 4095 Bytes puffern? <br>  Die maximale √úbertragungszahl eines TD ist auf 4095 Byte begrenzt.  Wenn Sie mehr als 4095 Bytes √ºber einen einzelnen DMA-Kanal √ºbertragen m√ºssen, verwenden Sie mehrere TDs und verketten Sie sie wie in Beispiel 5 gezeigt. </blockquote>  Wer hat recht?  Wenn Sie Experimente durchf√ºhren, werden die Ergebnisse zugunsten der schlechtesten Aussagen geneigt sein, aber das Verhalten wird v√∂llig unverst√§ndlich sein.  Der ganze Fehler ist diese √úberpr√ºfung in der API: <br><br><img src="https://habrastorage.org/webt/ib/5s/i2/ib5si2yxxn4e_idcohactjo2j-u.png"><br><br><div class="spoiler">  <b class="spoiler_title">Gleicher Text.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">cystatus CyDmaTdSetConfiguration(uint8 tdHandle, uint16 transferCount, uint8 nextTd, uint8 configuration) \ { cystatus status = CYRET_BAD_PARAM; if((tdHandle &lt; CY_DMA_NUMBEROF_TDS) &amp;&amp; (0u == (0xF000u &amp; transferCount))) { /* Set 12 bits transfer count. */ reg16 *convert = (reg16 *) &amp;CY_DMA_TDMEM_STRUCT_PTR[tdHandle].TD0[0u]; CY_SET_REG16(convert, transferCount); /* Set Next TD pointer. */ CY_DMA_TDMEM_STRUCT_PTR[tdHandle].TD0[2u] = nextTd; /* Configure the TD */ CY_DMA_TDMEM_STRUCT_PTR[tdHandle].TD0[3u] = configuration; status = CYRET_SUCCESS; } return(status); }</code> </pre><br></div></div><br>  Wenn eine Transaktion angegeben wird, die l√§nger als 4095 Byte ist, wird die vorherige Einstellung verwendet.  Ja, ich habe nicht daran gedacht, Fehlercodes zu √ºberpr√ºfen ... <br><br>  Die Experimente haben gezeigt, dass, wenn Sie diese Pr√ºfung entfernen, die tats√§chliche L√§nge mit der Maske 0xfff (4096 = 0x1000) abgeschnitten wird.  Ach und ah.  Alle Hoffnungen auf einen angenehmen Job brachen zusammen.  Sie k√∂nnen in 4K nat√ºrlich Ketten verwandter Deskriptoren erstellen.  Aber zum Beispiel sind 64K 16 Ketten.  Drei aktive Motoren (Extruder haben weniger Stufen) - 48 Ketten.  Im schlimmsten Fall sollte vor jedem Segment genau so viel gef√ºllt werden.  Vielleicht ist es rechtzeitig akzeptabel.  Es stehen mindestens 127 Deskriptoren zur Verf√ºgung, sodass auf jeden Fall gen√ºgend Speicher vorhanden ist. <br><br>  Sie k√∂nnen die fehlenden Daten nach Bedarf senden.  Es kam zu einer Unterbrechung, dass der DMA-Kanal die Arbeit abgeschlossen hatte. Wir √ºbertragen ein weiteres Segment darauf.  In diesem Fall sind keine Berechnungen erforderlich, das Segment ist bereits gebildet, alles wird schnell sein.  Und es gibt keine Leistungsanforderungen: Wenn eine Interrupt-Anforderung ausgegeben wird, gibt es 4 weitere Elemente im FIFO, die jeweils f√ºr mehrere hundert oder sogar Tausende von Taktzyklen gewartet werden.  Das hei√üt, alles ist real.  Eine bestimmte Strategie l√§sst sich w√§hrend der eigentlichen Arbeit leichter ausw√§hlen.  Ein Fehler in der Dokumentation (TRM) tr√ºbte jedoch die ganze Stimmung.  Wenn dies im Voraus bekannt w√§re, h√§tte ich die Methodik vielleicht nicht √ºberpr√ºft. <br><br><h2>  Fazit </h2><br>  In der Erscheinung wurde das entwickelte Hilfs-Firmware-Tool akzeptabel, so dass auf seiner Grundlage eine Version der ‚ÄûFirmware‚Äú erstellt werden kann, beispielsweise Marlin, die sich nicht st√§ndig im Interrupt-Handler f√ºr Schrittmotoren befindet.  Soweit ich wei√ü, gilt dies insbesondere f√ºr Delta-Drucker, bei denen der Bedarf an Computerressourcen recht hoch ist.  Vielleicht wird dadurch der Zustrom beseitigt, der in meinem Delta an Stellen auftritt, an denen der Kopf stoppt.  Auf dem MZ3D wird an denselben Stellen kein Zustrom beobachtet.  Ob es wahr ist oder nicht, wird die Zeit zeigen, und der Bericht dar√ºber muss in einer v√∂llig anderen Filiale ver√∂ffentlicht werden. <br><br>  In der Zwischenzeit haben wir gesehen, dass es auf dem UDB-Block trotz seiner Einfachheit durchaus m√∂glich ist, einen Coprozessor zu implementieren, der zusammen mit dem Hauptprozessor arbeitet und das Entladen erm√∂glicht.  Und wenn es viele dieser Einheiten gibt, k√∂nnen Coprozessoren parallel arbeiten. <br><br>  Ein Fehler in der Dokumentation f√ºr den DMA-Controller hat das Ergebnis verwischt.  Unterbrechungen sind dennoch erforderlich, jedoch nicht mit der gleichen H√§ufigkeit und nicht mit der zeitlichen Kritikalit√§t, die in der Originalversion vorhanden war.  Die Stimmung ist also verdorben, aber die Verwendung eines auf UDB basierenden ‚ÄûCoprozessors‚Äú bringt im Vergleich zur reinen Softwarearbeit immer noch einen erheblichen Gewinn. <br><br>  Auf dem Weg stellte sich heraus, dass DMA mit einer relativ geringen Geschwindigkeit arbeitet.  Infolgedessen wurden einige Messungen sowohl am PSoC5LP als auch am STM32 durchgef√ºhrt.  Die Ergebnisse ziehen einen anderen Artikel.  Vielleicht mache ich es eines Tages, wenn sich das Thema als interessant herausstellt. <br><br>  Als Ergebnis der Experimente wurden zwei Testprojekte gleichzeitig erhalten.  Das erste ist leichter zu verstehen.  Sie k√∂nnen es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier nehmen</a> .  Der zweite wird vom ersten geerbt, aber beim Hinzuf√ºgen eines Sieben-Bit-Z√§hlers und der zugeh√∂rigen Logik verwirrt.  Sie k√∂nnen es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier nehmen</a> .  Nat√ºrlich sind diese Beispiele nur Testbeispiele.  Es ist noch keine Zeit zum Einbetten in die echte ‚ÄûFirmware‚Äú.  Im Rahmen dieser Artikel ist es jedoch wichtiger, die Arbeit mit UDB zu √ºben. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de434742/">https://habr.com/ru/post/de434742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de434732/index.html">Leben bei 6200 DPI. HyperX Pulsefire Core Review</a></li>
<li><a href="../de434734/index.html">Fourier-Transformation. Das schnelle und das w√ºtende</a></li>
<li><a href="../de434736/index.html">Verwenden der Mikrotik-Protokolldatenbank zur Unterdr√ºckung von Brute Force</a></li>
<li><a href="../de434738/index.html">Verst√§rkungslernen in Python</a></li>
<li><a href="../de434740/index.html">Das neuronale Netz lehrte, Sonnenkollektoren in Satellitenbildern zu erkennen und das Ausma√ü ihrer Verteilung vorherzusagen</a></li>
<li><a href="../de434744/index.html">Samsung SSD 860 QVO 1 TB und 4 TB: der erste Consumer SATA QLC (2 Teile)</a></li>
<li><a href="../de434746/index.html">BLE unter dem Mikroskop 4</a></li>
<li><a href="../de434750/index.html">So √ºbernehmen Sie die Kontrolle √ºber Ihre Netzwerkinfrastruktur. Kapitel zwei Reinigung und Dokumentation</a></li>
<li><a href="../de434752/index.html">Robomoroz: die Zukunft der Hauptfigur des neuen Jahres</a></li>
<li><a href="../de434756/index.html">Die Zukunft von Kubernetes liegt bei virtuellen Maschinen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>