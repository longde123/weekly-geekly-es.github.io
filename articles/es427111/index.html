<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏴 🤝 🏤 Transformación de procesos de desarrollo y entrega para una aplicación heredada 🏁 🍐 📪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nuestro equipo es responsable de la operación y desarrollo de un gran producto corporativo. 
 A principios de 2017, tomando un descanso de una impleme...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Transformación de procesos de desarrollo y entrega para una aplicación heredada</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427111/"><p>  Nuestro equipo es responsable de la operación y desarrollo de un gran producto corporativo. <br>  A principios de 2017, tomando un descanso de una implementación importante y releyendo las "lecciones aprendidas", decidimos firmemente revisar el desarrollo y la entrega de nuestra aplicación.  Nos preocupaba la baja velocidad y la calidad de la entrega, lo que no nos permitía proporcionar el nivel de servicio que los clientes esperan de nosotros. </p><br><p>  Era hora de pasar de las palabras a los hechos, a cambiar los procesos. </p><br><p>  Este artículo hablará brevemente sobre dónde comenzamos, qué hicimos, cuál es la situación ahora, qué dificultades hemos encontrado, qué tenemos que dejar atrás, qué más planeamos hacer. </p><a name="habracut"></a><br><h1 id="nachalo">  Inicio </h1><br><h3 id="nemnogo-o-sisteme">  Un poco sobre el sistema. </h3><br><p>  La aplicación es un ejemplo clásico de una aplicación empresarial monolítica del "derrame arquitectónico de la década de 2000": </p><br><ul><li>  Operado y desarrollado durante 15 años. </li><li>  Es un conjunto de una docena y media de WinForms, servicios de Windows y aplicaciones ASP .Net vinculadas a una sola base de datos MS SQL. </li><li>  Tamaño de la base de código: ~ 1MLOC para C #, ~ 9000 objetos de base de datos.  Gran parte de la lógica empresarial se ejecuta en el lado de la base de datos. </li><li>  La aplicación consta de ~ 250 + soluciones para crear un cliente win / web (una solución por grupo de formularios relacionados).  Este es un legado del proceso de desarrollo anterior y la arquitectura del cliente. </li><li>  La aplicación admite varios tipos de procesos (clientes) al cambiar la configuración interna: establecer procesos, permisos, campos flexibles, etc., en las tablas de configuración de la base de datos del sistema.  Al mismo tiempo, la base del código de la aplicación es la misma para todos los clientes. </li><li>  La aplicación se implementa y admite en más de 25 sitios (cada sitio es una instancia independiente del sistema) y sirve a un total de varios miles de usuarios finales en diferentes zonas horarias. </li></ul><br><h3 id="process-dostavki-do-transformacii">  Proceso de entrega antes de la transformación. </h3><br><ol><li>  El desarrollo y montaje de la aplicación terminada y sus componentes es realizada por el contratista. </li><li>  el código se almacenó en el lado del contratista (versión local de MS TFS).  El código se transmite mensualmente al cliente en forma de archivo de la versión actual de la rama del repositorio principal. </li><li>  la entrega se llevó a cabo mediante la entrega de "actualizaciones delta": para la aplicación (conjunto de dll, exe, etc.) y componentes de la base de datos (conjunto de scripts sql create / alter).  La aplicación fue construida y los paquetes delta preparados por el contratista. </li><li>  El proceso de despliegue fue apoyado por el sistema de transporte, los cambios se aplicaron automáticamente. </li></ol><br><p>  La entrega se lleva a cabo como parte de los lanzamientos mensuales (como lo he arreglado, te lo dije anteriormente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> ). </p><br><h3 id="suschestvovavshie-problemy">  Problemas existentes </h3><br><p>  <em>Falta de control</em> </p><br><ul><li>  A pesar de la propiedad formal del código, el montaje real de la aplicación por parte del cliente fue imposible. </li><li>  Como resultado, es imposible verificar la operatividad del código transmitido al cliente. </li><li>  cambios en el código, no transparentes para el cliente.  No es posible hacer coincidir los cambios solicitados y reales en el producto. </li><li>  El análisis de código es difícil para SQL e imposible para los componentes de C # </li></ul><br><p>  <em>Aporte laboral y errores</em> </p><br><ul><li>  La preparación de "paquetes delta" es un procedimiento que lleva mucho tiempo para el desarrollo, una fuente de errores y ciertos costos del proyecto. </li><li>  La implementación de una aplicación Delta Packet requiere el seguimiento del orden de los paquetes.  Un error de paquete fuera de servicio es un importante problema de implementación y una fuente importante de incidentes. </li><li>  Las regresiones ocurren regularmente: los errores que parecen haber sido reparados y las correcciones implementadas en el producto aparecieron nuevamente. </li></ul><br><p>  <em>Limitaciones</em> </p><br><ul><li>  La capacidad de restaurar el estado del sistema en un momento anterior (cambios de retroceso) está prácticamente ausente. </li><li>  La capacidad de escalar eficazmente los recursos de desarrollo y prueba temprana mediante la atracción de empleados clientes está prácticamente ausente. </li></ul><br><h3 id="ozhidaemye-rezultaty">  Resultados esperados </h3><br><p>  Al comienzo del proyecto, establecimos objetivos obvios para resolver los problemas identificados anteriormente. </p><br><ul><li>  Transfiera el repositorio de código al control del cliente </li><li>  Mueva el proceso de compilación de la aplicación al lado del cliente </li><li>  Modificar el proceso de distribución de cambios, abandonando el "delta de cambios" en favor de una actualización completa </li></ul><br><p>  Además, utilizando las soluciones obtenidas cuando se lograron los dos primeros objetivos, calculamos: </p><br><ul><li>  Mejore la calidad técnica de las soluciones resultantes a través del control de código </li><li>  Aumente el compromiso de prueba y la usabilidad al proporcionar implementación de autoservicio. </li></ul><br><h1 id="etapy-bolshogo-puti">  Etapas de un largo camino </h1><br><h3 id="analiz-tekuschego-sostoyaniya-processov-razrabotki">  Análisis del estado actual de los procesos de desarrollo. </h3><br><p>  Primer paso: analizar el proceso de desarrollo del contratista existente.  Esto ayudó a planificar los cambios para que, si es posible, no interrumpa el trabajo. </p><br><p>  Desafortunadamente, el conocimiento del proceso de desarrollo mostró que, en la comprensión de la industria de TI en la actualidad, el proceso estaba ausente. </p><br><ol><li>  El código de la base de datos y la lógica comercial no se mantuvieron actualizados en el repositorio.  La razón principal: la falta de herramientas que implementan el ensamblaje desde el código en el repositorio y la implementación del resultado.  Entonces, el código en el repositorio es solo documentación. </li><li>  La versión "real" del código de la base de datos se encuentra en la "base de datos de desarrollo" común, en la que trabajan docenas de desarrolladores. </li><li>  El código de la aplicación del cliente (C #, ASP.NET) se mantuvo en el repositorio, pero no se garantizó la calidad y la puntualidad de las confirmaciones. </li><li>  Los componentes (no toda la aplicación) se ensamblaron en las estaciones del desarrollador.  No está del todo claro cómo se actualizó el código antes del ensamblaje.  El componente ensamblado se presentó en una carpeta compartida compartida.  A partir de ahí, se formó un "paquete delta" para el cliente. </li><li>  La completa falta de práctica de mantener ramas de desarrollo.  Por signos indirectos, sospechamos esto durante mucho tiempo, pero después de sumergirnos en el proceso, todo se hizo evidente. </li></ol><br><h3 id="perehod-na-novyy-repozitoriy-i-sistemu-kontrolya-versiy">  Cambiar a un nuevo repositorio y sistema de control de versiones </h3><br><p>  La dependencia de las plataformas de MS y los estándares corporativos determinaron la elección del entorno de desarrollo: Team Foundation Server. <br>  Sin embargo, cuando comenzamos el proyecto directamente (abril de 2017), la versión de Visual Studio Team Services acaba de ser lanzada.  El producto parecía muy interesante, fue designado como una dirección estratégica para MS, ofreció repositorios git, ensamblaje e implementación para on-prem y cloud. </p><br><p>  El TFS corporativo en la empresa se quedó atrás de la versión y la funcionalidad de VSTS, la migración a la nueva versión solo estaba en proceso de discusión.  No quisimos esperar.  Decidimos cambiar inmediatamente a VSTS, ya que esto redujo nuestros costos generales para soportar la plataforma y nos proporcionó un control total sobre cómo y qué hacemos. </p><br><p>  En el momento del comienzo de los cambios, el equipo de desarrollo tenía experiencia con TFSVC, el código de la aplicación se almacenaba en dicho repositorio.  Por otro lado, GIT se ha convertido desde hace mucho tiempo en el estándar para la comunidad de TI: el cliente y los consultores externos recomendaron cambiar a este sistema. <br>  Queríamos que el equipo de desarrollo participara en la decisión de un nuevo sistema de control de versiones y que tomara una decisión informada. </p><br><p>  Implementamos dos proyectos en VSTS con diferentes repositorios: TFSVC y GIT.  Se definió un conjunto de escenarios, que se propuso para probar y evaluar la usabilidad en cada uno de los sistemas. </p><br><p>  Entre los escenarios evaluados estaban: </p><br><ul><li>  Crear y fusionar sucursales </li><li>  Organización del trabajo conjunto (en una o diferentes ramas) </li><li>  Cambiar operaciones de cadena (commit, deshacer) </li><li>  Integración de terceros </li><li>  La capacidad de continuar trabajando cuando el servidor no está disponible. </li></ul><br><p>  Como resultado, como se esperaba, se eligió GIT, y hasta ahora nadie se ha arrepentido. </p><br><p>  Como proceso, comenzamos a usar GitFlow.  Este proceso proporcionó suficiente control sobre los cambios y permitió la entrega de versiones, como estamos acostumbrados. </p><br><ol><li>  Defendimos la rama de desarrollo con una política que exigía que todos los cambios pasaran por solicitudes de extracción. </li><li>  Intentamos adherirnos a la práctica de "un ticket: una solicitud de extracción".  Los cambios de diferentes boletos nunca se combinan en un solo cambio.  Intentamos hacer nuestro mejor esfuerzo para probar la rama de características para evitar la situación con correcciones en los posteriores requakes de extracción. </li><li>  Cuando se fusiona con el desarrollo, todos los cambios se fusionan en una sola confirmación (squash). </li><li>  Las ramas de lanzamiento se crean a partir del desarrollo. </li><li>  Si es necesario, en la rama de lanzamiento, puede agregar los últimos cambios de forma selectiva (selección de cereza) o todos (rebase).  No realizamos la corrección directamente en la rama de lanzamiento. </li><li>  Después de implementar la última versión en el producto, pasa al master a través de la fuerza de empuje (solo unas pocas personas tienen este derecho) </li></ol><br><h3 id="avtomatizaciya-sborki-produkta">  Automatización del montaje del producto. </h3><br><p>  La aplicación fue una gran cantidad de ensamblajes, cientos de soluciones.  Como resultó durante la auditoría del proceso, todo esto se recopiló por separado y "manualmente". <br>  En la primera etapa, decidimos no rehacer todo desde cero (para no detener la entrega existente), sino "envolver" el ensamblado en un conjunto de scripts de msbuild: un script por componente. <br>  Por lo tanto, rápidamente obtuvimos scripts que llevaron a cabo todos los artefactos intermedios necesarios y, al final, el producto terminado. </p><br><p>  Una historia separada es un diseño de base de datos.  Desafortunadamente, el sistema contiene varios componentes CLR que no estaban bien estructurados.  Las dependencias no permiten una base de implementación simple con contenido.  Por el momento, esto se está resolviendo mediante un script previo a la implementación. <br>  Además, debido al panorama desigual del sistema (las versiones de SQL Server 2008 y 2014 se instalaron en diferentes puntos), fue necesario organizar el ensamblaje del proyecto base para .Net versiones 2.0 y 4.0. </p><br><p>  Después de que todos los scripts estaban listos y probados, se usaron en el script de compilación VSTS. </p><br><p>  Inmediatamente antes del inicio del ensamblaje, las versiones de todos los productos se actualizaron a un número estándar común, incluido el número de compilación.  El mismo número se almacenó en el script posterior a la implementación.  Por lo tanto, todos los componentes, la base de datos y todas las aplicaciones cliente, salieron consistentes e igualmente numerados. </p><br><h3 id="razvertyvaniya-na-testovyy-stend">  Despliegue al banco de pruebas </h3><br><p>  Una vez que se completó la versión inicial del proceso de compilación, continuamos con la preparación del script de implementación. </p><br><p>  Se espera que la base de datos sea la más problemática. </p><br><p>  La implementación de una copia "superior" de una base de datos real reveló muchos conflictos entre el ensamblaje y el estado de los sistemas reales: </p><br><ul><li>  Versiones inconsistentes en GIT y en el sistema real </li><li>  Esquemas de bases de datos propiedad de usuarios que se planearon eliminar. </li></ul><br><h3 id="stabilizaciya-processa-razrabotki">  Estabilización del proceso de desarrollo. </h3><br><p>  Por supuesto, es extraño hablar de esto, y aún más escribir aquí, pero el cambio más serio para los desarrolladores fue la introducción del principio "si esto no está en git, esto no existe".  Anteriormente, el código se comprometía "para informar al cliente".  Ahora, sin esto, es imposible entregar nada. </p><br><p>  Lo más difícil fue con el código de la base de datos.  Después de cambiar a implementar la base de datos desde el repositorio, a través del ensamblaje y la implementación utilizando sqlpackage, el enfoque "delta" fue reemplazado por el enfoque "estado deseado".  Los paquetes eran cosa del pasado; todo tenía que implementarse automáticamente. </p><br><p>  Pero!  Hasta la transición completa al nuevo proceso de implementación, aún era necesario entregar los cambios.  Y era necesario hacer esto a la antigua usanza: "actualizaciones delta". </p><br><p>  Nos enfrentamos a la tarea de garantizar la coherencia completa y constante del estado del sistema al entregar paquetes delta y el contenido del repositorio. </p><br><p>  Para hacer esto, organizamos el siguiente proceso: </p><br><ol><li>  Regularmente, el código del repositorio se recopilaba y desplegaba en una base de datos "modelo" vacía. </li><li>  Sobre la base de la base "modelo", se estaba preparando un autotest especial.  Para cada objeto de la base de datos "modelo", se calcularon las sumas de verificación.  La prueba automática contiene todas estas sumas de verificación y al inicio calcula las sumas de verificación de los objetos correspondientes de la base de datos "verificada".  Cualquier discrepancia en la composición de los objetos o sus sumas de verificación conduce a una caída en la prueba. </li><li>  La prueba de "caída" prohibió automáticamente la transferencia de paquetes desde el entorno de prueba más abajo en el paisaje.  Dicha integración ya se ha implementado en el sistema de transporte anterior. </li></ol><br><p>  Por lo tanto, usando el control automático, fue posible actualizar relativamente rápido el código de la base de datos del producto en git y mantenerlo sin esfuerzo adicional por parte del equipo del proyecto.  Al mismo tiempo, los desarrolladores comenzaron a acostumbrarse a la necesidad de confirmar el código de manera correcta y oportuna en el repositorio. </p><br><h3 id="razvertyvanie-produkta-na-okruzheniya-integracionnyh-testov">  Despliegue de productos en entornos de prueba de integración </h3><br><p>  Después de completar la etapa anterior, pasamos directamente a implementar la aplicación en un entorno de prueba.  Dejamos completamente de aplicar paquetes delta a los sistemas de prueba y pasamos a la implementación automática mediante VSTS. </p><br><p>  A partir de ese momento, todo el equipo comenzó a recibir los primeros frutos de los esfuerzos realizados anteriormente: el despliegue se llevó a cabo sin ningún esfuerzo adicional.  El código personalizado se recopiló, implementó y probó automáticamente. </p><br><p>  Desafortunadamente, como lo entendimos más tarde, la "alineación del repositorio" llevó al hecho de que teníamos una versión de la versión estable de "desarrollo", pero la versión de "producción" todavía no estaba disponible.  Y por lo tanto, no había nada que ir más allá del entorno de prueba con QAS y PRD. </p><br><p>  El código de la aplicación en el lado de la base de datos podría compararse con el productivo y comprender las diferencias.  No había nada con lo que comparar las aplicaciones del cliente: solo había una versión productiva actualizada en forma de un conjunto de archivos ejecutables, y de la que se compilaron era imposible decirlo con certeza. </p><br><h3 id="testirovanie-produkta-kak-rezultata-avtomaticheskoy-sborki">  Probar el producto como resultado del ensamblaje automático </h3><br><p>  Después de cambiar el enfoque de ensamblaje, el producto tuvo que someterse a extensas pruebas de regresión.  Era necesario asegurarse de que la aplicación funcionara y que no se perdiera nada. <br>  Durante las pruebas, resultó ser más fácil con la funcionalidad ubicada en el costado de la base de datos.  Afortunadamente, hemos desarrollado un conjunto significativo de pruebas automáticas que cubren áreas críticas. </p><br><p>  Pero no hubo pruebas para C #, por lo tanto, todo se verificó a mano.  Esta fue una cantidad significativa de trabajo, y la verificación tomó algo de tiempo. </p><br><h3 id="pryzhok-very---pilotnoe-razvertyvanie-na-produktiv">  Salto de fe: implementación productiva piloto </h3><br><p>  A pesar de las pruebas, la implementación en un producto por primera vez fue aterradora. </p><br><p>  Tuvimos suerte: habíamos planeado el próximo despliegue del sistema en un nuevo sitio.  Y decidimos usar esta oportunidad para una implementación piloto. <br>  Los usuarios no vieron, los posibles errores del nuevo ensamblaje fueron fáciles de solucionar, el trabajo productivo real aún no ha comenzado. </p><br><p>  Implementamos el sistema, y ​​durante varias semanas estuvo en el modo de uso preproductivo (baja carga, un cierto patrón de uso que se puede omitir en el producto).  Durante este tiempo, se revelaron varios defectos que se perdieron durante las pruebas.  Se corrigieron a medida que se encontraban, y la nueva versión se lanzó inmediatamente para su verificación. </p><br><p>  Después del lanzamiento oficial y una semana de soporte posterior al lanzamiento, anunciamos que esta es la primera copia ensamblada y entregada "de una nueva manera". </p><br><p>  Esta versión del ensamblado se convirtió en la primera versión estable de la rama maestra, se colgó con etiquetas fisrt_deployment (no pedimos iconos con un hash de la confirmación). </p><br><h3 id="masshtabirovanie-razvertyvaniya-na-ves-produktivnyy-landshaft">  Despliegue a escala en todo un paisaje productivo </h3><br><p>  Como dijo James Bond: "La segunda vez es mucho más simple".  Después del éxito de la implementación piloto, conectamos rápidamente las instancias restantes de sistemas de un tipo similar. </p><br><p>  Pero el sistema tiene varios tipos de uso: una funcionalidad se puede usar para un tipo y no en otros casos.  En consecuencia, la funcionalidad probada en la implementación del primer tipo no garantiza necesariamente el éxito para otros casos. </p><br><p>  Para probar la funcionalidad de los tipos de uso restantes, comenzamos a usar proyectos activos que estaban en desarrollo.  La idea era similar y la primera implementación: comenzamos a usar ensamblajes automáticos, "deslizándolos" a los usuarios junto con la funcionalidad de diseño.  Por lo tanto, los usuarios, trabajando con la versión "proyecto" del producto, al mismo tiempo verificaron la funcionalidad anterior. </p><br><p>  El escalado en sí reveló problemas técnicos inesperados: </p><br><p>  <em>Paisaje del sistema no homogéneo</em> <br>  Además de implementar directamente la aplicación, primero tuvimos que asegurarnos de que todo fuera igual en todas partes: versiones .Net, Powershell y módulos.  Todo tomó una buena cantidad de tiempo. </p><br><p>  <em>Conexión de red</em> <br>  En algunos sitios, la conexión de red simplemente no permitía bombear todos los componentes del ensamblaje.  Hubo tiempos de espera, daños durante la transferencia.  Verificamos y probamos muchas cosas, no con mucho éxito. </p><br><p>  Tuve que pensar en la siguiente solución: el script de ensamblaje se finalizó para que todos los resultados se empaquetaran en un gran archivo, que luego se cortó en pequeños fragmentos (2 mb cada uno).  Finalizamos el escenario de implementación para eliminar la concurrencia al descargar artefactos, aceptamos los fragmentos de 2 megabytes y restauramos de ellos lo que ya se puede expandir. </p><br><p>  <em>Conflicto con antivirus</em> <br>  Otro problema extraño que encontramos es un conflicto entre el software antivirus y uno de los pasos de implementación: cuando todo tipo de archivos "sospechosos", como .js, .dll, se extraen de los archivos de artefactos, el antivirus comienza a mirarlos de cerca.  Y lo más extraño es que el antivirus comienza a apresurarse al archivo antes del final del desempaquetado y el proceso de desempaquetado cae con el mensaje "el archivo está ocupado por otro proceso".  Si bien estamos luchando con esto, excluir la carpeta local con artefactos del escaneo, no es muy bueno, pero no se nos ocurrió nada más. </p><br><h3 id="uluchshenie-processov">  Mejora de proceso </h3><br><p>      ,    "   " —   . </p><br><ul><li>        (service-now.com)  VSTS      Work Items.     develop —       . </li><li>  CI   feature .      —        </li><li>            "self-service"      </li><li>         —     .        ,            . </li><li>      :    , CI/CD        ,      </li><li>         (  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> ) </li><li>   -    (   )     .        —    ,      . </li><li>     VSTS     ,        ,     . </li></ul><br><h1 id="itogi">  Resumen </h1><br><h3 id="tekuschaya-situaciya">   </h3><br><ul><li>        MS VisualStudio Team Services (   — Azure Devops)  .    — GIT </li><li>          (/) </li><li>    git / GitFlow    . </li><li>   code review    . </li><li>     CI.       ,    feature ,     . </li><li>          . ,           . </li><li>          (  )    —     . -      . </li><li>  -      1 .      -  . </li><li>   ""     . </li></ul><br><h3 id="vremya-po-etapam">    </h3><br><table><thead><tr><th>  No </th><th>   </th><th>  </th></tr></thead><tbody><tr><td>  1 </td><td>    —     ,        </td><td> 6  </td></tr><tr><td>  2 </td><td>       —       </td><td> 3  </td></tr><tr><td>  3 </td><td>      —       </td><td> 5  </td></tr></tbody></table><br><p>   — 14  </p><br><p> ,    ,    ,     . </p><br><h3 id="trudozatraty">  </h3><br><p>           ,    —  250  * . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es427111/">https://habr.com/ru/post/es427111/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es427097/index.html">La aplicación móvil ayuda a detectar la depresión y otros problemas psicológicos en las primeras etapas.</a></li>
<li><a href="../es427101/index.html">Google planea cobrar a los fabricantes de dispositivos móviles hasta $ 40 por cada dispositivo vendido</a></li>
<li><a href="../es427105/index.html">Aprender a aprender: la educación continua es la clave para la competitividad en la era de la economía digital</a></li>
<li><a href="../es427107/index.html">Parsim X12 "en la rodilla"</a></li>
<li><a href="../es427109/index.html">Piratería en el espacio - El delicioso Delta-V y los Steamboats Stealth de hidrógeno - Parte 1</a></li>
<li><a href="../es427113/index.html">Matrices de puertas programables: cómo ayudan a las redes 5G</a></li>
<li><a href="../es427117/index.html">Salas de reuniones basadas en asterisco</a></li>
<li><a href="../es427123/index.html">Juego de Turing</a></li>
<li><a href="../es427129/index.html">Inteligencia de amenazas: un enfoque moderno para la seguridad de la información</a></li>
<li><a href="../es427131/index.html">Conocimiento de Audiomanía: 15 materiales temáticos sobre producción, diseño, oficinas y negocios.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>