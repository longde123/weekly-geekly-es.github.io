<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤛 ⚾️ 🛡️ SwiftUI和自动续订订阅 👖 🎅🏿 👉🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="你好 Apphud的Connected Denis-一种服务，用于分析iOS应用程序的可再生订阅。 


如您所知，Apple在WWDC 2019上宣布了其新的声明性SwiftUI框架。 在本文中，我将尝试说明如何使用SwiftUI进行付款屏幕和实现自动续订的功能。 
 如果您还不熟悉SwiftUI...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SwiftUI和自动续订订阅</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/apphud/blog/458116/"><p><img src="https://habrastorage.org/webt/uv/gw/et/uvgwetpxigh37y6ofexpjnqx6lk.png" alt="图片"></p><br><p> 你好  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Apphud的Connected Denis-</a>一种服务，用于分析iOS应用程序的可再生订阅。 </p><br><p>如您所知，Apple在WWDC 2019上宣布了其新的声明性SwiftUI框架。 在本文中，我将尝试说明如何使用SwiftUI进行付款屏幕和实现自动续订的功能。 <a name="habracut"></a></p><br><blockquote> 如果您还不熟悉SwiftUI，则可以阅读简短的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">介绍性文章</a> 。 并且，如果您想了解有关订阅以及如何正确实现订阅的更多信息，请阅读<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本文</a> 。 </blockquote><p> 您需要<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Xcode 11才能工作</a> 。 创建一个新项目，并确保<em>“ Use SwiftUI”</em>旁边有一个复选标记<em>。</em> </p><br><p>  SwiftUI是用于编写接口的框架，因此我们无法使用该接口创建采购经理。 但是，我们不会写经理，而是使用现成的解决方案，并在其中补充代码。 您可以使用例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SwiftyStoreKit</a> 。 在我们的示例中，我们将使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上一篇文章中</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">类</a> 。 </p><br><p> 产品将在主屏幕上初始化，我们订阅的到期日期和切换到购买屏幕的按钮也将在那里显示。 </p><br><pre><code class="swift hljs"><span class="hljs-type"><span class="hljs-type">ProductsStore</span></span>.shared.initializeProducts() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> windowScene = scene <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">UIWindowScene</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> window = <span class="hljs-type"><span class="hljs-type">UIWindow</span></span>(windowScene: windowScene) window.rootViewController = <span class="hljs-type"><span class="hljs-type">UIHostingController</span></span>(rootView: <span class="hljs-type"><span class="hljs-type">ContentView</span></span>(productsStore: <span class="hljs-type"><span class="hljs-type">ProductsStore</span></span>.shared)) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.window = window window.makeKeyAndVisible() }</code> </pre> <br><p> 考虑<code>SceneDelegate</code>类。 在其中，我们创建一个单例类<code>ProductsStore</code> ，在其中初始化产品。 之后，创建我们的根<code>ContentView</code>并指定singleton作为输入参数。 <br> 考虑<code>ProductsStore</code>类： </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductsStore</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObservableObject</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> shared = <span class="hljs-type"><span class="hljs-type">ProductsStore</span></span>() @<span class="hljs-type"><span class="hljs-type">Published</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> products: [<span class="hljs-type"><span class="hljs-type">SKProduct</span></span>] = [] @<span class="hljs-type"><span class="hljs-type">Published</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> anyString = <span class="hljs-string"><span class="hljs-string">"123"</span></span> <span class="hljs-comment"><span class="hljs-comment">// little trick to force reload ContentView from PurchaseView by just changing any Published value func handleUpdateStore(){ anyString = UUID().uuidString } func initializeProducts(){ IAPManager.shared.startWith(arrayOfIds: [subscription_1, subscription_2], sharedSecret: shared_secret) { products in self.products = products } } }</span></span></code> </pre> <br><p> 这个小类，是<code>IAPManager</code>上的“附加组件”，用于在更新产品列表时更新<code>ContentView</code> 。  <code>ProductsStore</code>类支持<code>ObservableObject</code>协议。 </p><br><p> 什么是<code>ObservableObject</code>和<code>@Published</code> ？ </p><br><p>  <code>ObservableObject</code>是用于观察对象并跟踪其属性变化的特殊协议。 必须使用<code>@Published</code>属性标记属性。 在该示例中，当<code>products</code>数组更改时会发送通知，但是您可以为对象的任何方法和属性添加此通知。 </p><br><p> 产品加载本身可以通过任何方式完成，但是在此请求结束时，您必须将产品数组分配给products变量。 如何聆听变化？ 这是使用<code>@ObservedObject</code>键参数完成的： </p><br><pre> <code class="swift hljs">@<span class="hljs-type"><span class="hljs-type">ObservedObject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> productsStore : <span class="hljs-type"><span class="hljs-type">ProductsStore</span></span></code> </pre> <br><p> 简而言之，这类似于通知中心。 为了使<code>View</code>接受这些通知，您必须具有<code>@ObservedObject</code>属性的此对象的变量。 </p><br><p> 让我们回到<code>ProductsStore</code>类的逻辑。 其主要目的是下载和存储产品列表。 但是产品数组已经存储在<code>IAPManager</code> ，发生重复。 这不好，但是，首先，在本文中，我想向您展示如何实现对象合并，其次，并非总是可以更改采购经理的完成的类。 例如，如果您使用第三方库，则将无法添加<code>ObservableObject</code>协议并发送通知。 </p><br><p> 值得注意的是，除了<code>@ObservedObject</code>属性之外<code>@ObservedObject</code>还有<code>@State</code>属性可以帮助跟踪简单变量（例如<code>String</code>或<code>Int</code> ）中的更改以及更具全局性的<code>@EnvironmentObject</code> ，后者可以立即更新应用程序中的所有<code>View</code>而不必在对象之间传递变量。 </p><br><p> 让我们<code>ContentView</code>开始屏幕： </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContentView</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span></span>{ @<span class="hljs-type"><span class="hljs-type">ObservedObject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> productsStore : <span class="hljs-type"><span class="hljs-type">ProductsStore</span></span> @<span class="hljs-type"><span class="hljs-type">State</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> show_modal = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body: some <span class="hljs-type"><span class="hljs-type">View</span></span> { <span class="hljs-type"><span class="hljs-type">VStack</span></span>() { <span class="hljs-type"><span class="hljs-type">ForEach</span></span> (productsStore.products, id: \.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { prod <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-type"><span class="hljs-type">Text</span></span>(prod.subscriptionStatus()).lineLimit(<span class="hljs-literal"><span class="hljs-literal">nil</span></span>).frame(height: <span class="hljs-number"><span class="hljs-number">80</span></span>) } <span class="hljs-type"><span class="hljs-type">Button</span></span>(action: { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Button Pushed"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.show_modal = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }) { <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"Present"</span></span>) }.sheet(isPresented: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.$show_modal) { <span class="hljs-type"><span class="hljs-type">PurchaseView</span></span>() } } } }</code> </pre> <br><p> 让我们找出代码。 使用<code>ForEach</code>我们创建文本<code>View</code> ，其数量等于产品的数量。 由于我们绑定了变量<code>productsStore</code> ，因此只要<code>ProductsStore</code>类中的<code>ProductsStore</code>数组发生更改，就将更新<code>View</code> 。 </p><br><p>  <code>subscriptionStatus</code>方法是<code>SKProduct</code>类<code>SKProduct</code>一部分，并根据预订的到期日期返回所需的文本： </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscriptionStatus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> expDate = <span class="hljs-type"><span class="hljs-type">IAPManager</span></span>.shared.expirationDateFor(productIdentifier) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> formatter = <span class="hljs-type"><span class="hljs-type">DateFormatter</span></span>() formatter.dateStyle = .medium formatter.timeStyle = .medium <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dateString = formatter.string(from: expDate) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-type"><span class="hljs-type">Date</span></span>() &gt; expDate { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Subscription expired: \(localizedTitle) at: \(dateString)"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Subscription active: \(localizedTitle) until:\(dateString)"</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Subscription not purchased: \(localizedTitle)"</span></span> } }</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/e00/2b1/dd8/e002b1dd8a99f04f4b70891830778068.png" alt="这是我们的开始屏幕"><br>  <em>这是我们的开始屏幕</em> </p><br><p> 现在转到订阅屏幕。 根据Apple的规定，由于付款屏幕上应包含购买条件的长文字，因此使用<code>ScrollView</code>是明智的。 </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body: some <span class="hljs-type"><span class="hljs-type">View</span></span> { <span class="hljs-type"><span class="hljs-type">ScrollView</span></span> (showsIndicators: <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { <span class="hljs-type"><span class="hljs-type">VStack</span></span> { <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"Get Premium Membership"</span></span>).font(.title) <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"Choose one of the packages above"</span></span>).font(.subheadline) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.purchaseButtons() <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.aboutText() <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.helperButtons() <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.termsText().frame(width: <span class="hljs-type"><span class="hljs-type">UIScreen</span></span>.main.bounds.size.width) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.dismissButton() }.frame(width : <span class="hljs-type"><span class="hljs-type">UIScreen</span></span>.main.bounds.size.width) }.disabled(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.isDisabled) }</code> </pre> <br><p> 在此示例中，我们创建了两个具有不同字体的文本视图。 此外，所有其他视图均以其自己的方法突出显示。 这样做有以下三个原因： </p><br><ol><li><p> 该代码变得更具可读性和可读性，可供研究。 </p><br></li><li><p> 在撰写本文时，Xcode 11 Beta通常会冻结并且无法编译代码，将部分代码放入函数中有助于编译器。 </p><br></li><li><p> 表明可以将视图分为不同的功能，从而使<code>body</code>更轻松。 </p><br></li></ol><br><p> 考虑<code>purchaseButtons()</code>方法： </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">purchaseButtons</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; some <span class="hljs-type"><span class="hljs-type">View</span></span> { <span class="hljs-comment"><span class="hljs-comment">// remake to ScrollView if has more than 2 products because they won't fit on screen. HStack { Spacer() ForEach(ProductsStore.shared.products, id: \.self) { prod in PurchaseButton(block: { self.purchaseProduct(skproduct: prod) }, product: prod).disabled(IAPManager.shared.isActive(product: prod)) } Spacer() } }</span></span></code> </pre> <br><p> 在这里，我们创建了一个水平堆栈，并在<code>ForEach</code>循环中创建了一个自定义<code>PurchaseButton</code> ，将产品和回调块传递到其中。 </p><br><p>  <code>PurchaseButton</code>类： </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PurchaseButton</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> block : <span class="hljs-type"><span class="hljs-type">SuccessBlock!</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> product : <span class="hljs-type"><span class="hljs-type">SKProduct!</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body: some <span class="hljs-type"><span class="hljs-type">View</span></span> { <span class="hljs-type"><span class="hljs-type">Button</span></span>(action: { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.block() }) { <span class="hljs-type"><span class="hljs-type">Text</span></span>(product.localizedPrice()).lineLimit(<span class="hljs-literal"><span class="hljs-literal">nil</span></span>).multilineTextAlignment(.center).font(.subheadline) }.padding().frame(height: <span class="hljs-number"><span class="hljs-number">50</span></span>).scaledToFill().border(<span class="hljs-type"><span class="hljs-type">Color</span></span>.blue, width: <span class="hljs-number"><span class="hljs-number">1</span></span>) } }</code> </pre> <br><p> 这是一个普通按钮，用于存储和调用创建对象时传递的块。 对其应用了舍入笔触。 我们在<code>localizedPrice()</code>方法中以文本形式显示产品的价格和订阅期的持续时间。 </p><br><p> 订阅购买的实现方式如下： </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">purchaseProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(skproduct : SKProduct)</span></span></span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"did tap purchase product: \(skproduct.productIdentifier)"</span></span>) isDisabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-type"><span class="hljs-type">IAPManager</span></span>.shared.purchaseProduct(product: skproduct, success: { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.isDisabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-type"><span class="hljs-type">ProductsStore</span></span>.shared.handleUpdateStore() <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.dismiss() }) { (error) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.isDisabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-type"><span class="hljs-type">ProductsStore</span></span>.shared.handleUpdateStore() } }</code> </pre> <br><p> 如您所见，购买<code>handleUpdateStore</code> ，将<code>handleUpdateStore</code>方法，并在该方法的帮助下发送通知以更新<code>ContentView</code> 。 这是为了确保在隐藏模式屏幕时<code>ContentView</code>订阅<code>ContentView</code>状态。  <code>dismiss</code>方法隐藏模式窗口。 </p><br><p> 由于SwiftUI是声明性框架，因此无法像往常一样实现隐藏模式窗口。 我们必须在<code>presentationMode</code>变量的包装器上调用<code>dismiss()</code>方法，并使用<code>@Environment</code>属性进行声明： </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PurchaseView</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span></span>{ @<span class="hljs-type"><span class="hljs-type">State</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isDisabled : <span class="hljs-type"><span class="hljs-type">Bool</span></span> = <span class="hljs-literal"><span class="hljs-literal">false</span></span> @<span class="hljs-type"><span class="hljs-type">Environment</span></span>(\.presentationMode) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> presentationMode <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dismiss</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.presentationMode.wrappedValue.dismiss() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dismissButton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; some <span class="hljs-type"><span class="hljs-type">View</span></span> { <span class="hljs-type"><span class="hljs-type">Button</span></span>(action: { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.dismiss() }) { <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"Not now"</span></span>).font(.footnote) }.padding() } ...</code> </pre> <br><p>  <code>presentationMode</code>变量是“ <em>环境值”的</em>一部分-特殊的全局方法和属性集。 在SwiftUI中，几乎所有动作都是在更改变量的值时发生的，您无法在运行时按字面意义做任何事情-一切都是预先限定的。 为了在运行时执行某些操作，您需要使用包装器。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9a5/0c8/e43/9a50c8e4315f98f4e75cabae81665c19.png" alt="订阅购买画面"><br>  <em>订阅购买画面</em> </p><br><h2 id="zaklyuchenie"> 结论 </h2><br><p> 希望本文对您有所帮助。 当开发人员使用其最新技术时，Apple会喜欢。 如果您使用SwiftUI发布适用于iOS 13的应用程序，则很有可能成为臭名昭著的Apple。 因此，不要害怕新技术-使用它们。 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>下载完整的项目代码。 </p><br><blockquote> 是否想在10分钟内在iOS应用中实现订阅？ 整合<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Apphud</a>并： <br><ul><li> 仅使用一种方法进行购买； </li><li> 自动跟踪每个用户的订阅状态； </li><li> 轻松整合订阅优惠 </li><li> 将订阅事件发送到Amplitude，Mixpanel，Slack和Telegram，并考虑到用户的本地货币； </li><li> 降低应用程序的客户流失率并返回未订阅的用户。 </li></ul><br></blockquote><br><h2 id="chto-pochitat"> 读什么？ </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在iOS应用程序中实现自动更新订阅的指南</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">您想知道的有关SwiftUI的所有信息，但又害怕问</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">适用于iOS的Apple订阅通知指南。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">他们真的好吗？</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN458116/">https://habr.com/ru/post/zh-CN458116/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN458106/index.html">在Jetpack Compose中潜水</a></li>
<li><a href="../zh-CN458108/index.html">重定向：301、302、307 | 301操作指南</a></li>
<li><a href="../zh-CN458110/index.html">现实世界中的动态编程：接缝切割</a></li>
<li><a href="../zh-CN458112/index.html">索尼Xperia 10评估</a></li>
<li><a href="../zh-CN458114/index.html">建立全球开源法律网络</a></li>
<li><a href="../zh-CN458118/index.html">适用于初学者Android开发人员的React Native指南（带有示例应用程序）</a></li>
<li><a href="../zh-CN458120/index.html">《哈勃周刊》第7期/神经网络剥夺了人们的注意力，豪华的Airbnb，在考试中将被允许谷歌，在Google Play上有很多假货</a></li>
<li><a href="../zh-CN458122/index.html">一个数据中心现代化的历史：PUE降低近一半以及现代解决方案的其他优势</a></li>
<li><a href="../zh-CN458124/index.html">斯堪的纳维亚游戏传奇中的俄罗斯足迹</a></li>
<li><a href="../zh-CN458126/index.html">数学假设的微妙艺术</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>