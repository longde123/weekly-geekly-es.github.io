<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕵🏽 🦖 🐆 Refactorizando un programa en Go: aceleración 23 veces 🚶🏼 👏🏽 🐼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Mi nombre es Marco, trabajo para Badoo en el departamento de Plataforma. Tenemos muchas cosas escritas en Go, y a menudo son críticas para el ren...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Refactorizando un programa en Go: aceleración 23 veces</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/415919/"><img src="https://habrastorage.org/webt/fw/oq/ji/fwoqjijc84e50kqfhpyzqfl-oay.jpeg"><br><br>  <i>Hola</i>  <i>Mi nombre es Marco, trabajo para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Badoo</a> en el departamento de Plataforma.</i>  <i>Tenemos muchas cosas escritas en Go, y a menudo son críticas para el rendimiento del sistema.</i>  <i>Es por eso que hoy te ofrezco una traducción de un artículo que realmente me gustó y, estoy seguro, te será muy útil.</i>  <i>El autor muestra paso a paso cómo abordó los problemas de rendimiento y cómo los resolvieron.</i>  <i>Incluyendo que se familiarizará con las ricas herramientas disponibles en Go para dicho trabajo.</i>  <i>Que tengas una buena lectura!</i> <br><br>  Hace unas semanas, leí el artículo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Código bueno contra código malo en Go</a> " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">,</a> donde el autor, paso a paso, demuestra la refactorización de una aplicación real que resuelve problemas comerciales reales.  Se enfoca en convertir el "código malo" en "código bueno": más idiomático, más comprensible, utilizando plenamente los detalles de Go.  Pero el autor también declaró la importancia del rendimiento de la aplicación en cuestión.  La curiosidad se apoderó de mí: ¡intentemos acelerarlo! <br><a name="habracut"></a><br>  El programa, en términos generales, lee el archivo de entrada, lo analiza línea por línea y llena los objetos en la memoria. <br><br><img src="https://habrastorage.org/webt/q0/ar/rr/q0arrrwx11e7qz627mj4ttz1r7y.png"><br><br>  El autor no solo publicó el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">código fuente en GitHub</a> , sino que también escribió un punto de referencia.  Esta es una gran idea  De hecho, el autor invitó a todos a jugar con el código y tratar de acelerarlo.  Para reproducir los resultados del autor, use el siguiente comando: <br><br><pre><code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> test -bench=.</code> </pre> <br><img src="https://habrastorage.org/webt/jw/x2/6w/jwx26wyngj_sqokfhrbk-3u3yeo.png"><br>  <i>μs por llamada (menos - mejor)</i> <br><br>  Resulta que en mi computadora el "buen código" es un 16% más rápido.  ¿Podemos acelerarlo? <br><br>  En mi experiencia, existe una correlación entre la calidad del código y el rendimiento.  Si refactorizó con éxito el código, lo hizo más limpio y menos conectado, probablemente lo hizo más rápido porque se volvió menos abarrotado (y no hay más instrucciones innecesarias que se ejecutaron previamente en vano).  Quizás durante la refactorización notó algunas oportunidades de optimización, o ahora solo tiene la oportunidad de aprovecharlas.  Pero, por otro lado, si desea que el código sea aún más productivo, probablemente tenga que alejarse de la simplicidad y agregar varios hacks.  Realmente ahorras milisegundos, pero la calidad del código se verá afectada: será más difícil leerlo y hablar sobre él, se volverá más frágil y flexible. <br><br><img src="https://habrastorage.org/webt/c9/lz/zd/c9lzzdc9yi73nsxn6cm93vwbvei.gif"><br>  <i>Subimos la montaña de la simplicidad, y luego bajamos de ella</i> <br><br>  Esto es una compensación: ¿hasta dónde estás dispuesto a llegar? <br><br>  Para priorizar adecuadamente el trabajo de aceleración, la estrategia óptima es encontrar cuellos de botella y concentrarse en ellos.  Para hacer esto, use las herramientas de creación de perfiles.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pprof</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">trace</a> son tus amigos: <br><br><pre> <code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> test -bench=. -cpuprofile cpu.prof $ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> tool pprof -svg cpu.prof &gt; cpu.svg</code> </pre> <br> <a href=""><img src="https://habrastorage.org/webt/dc/j4/vf/dcj4vfmpccf5k2gjyxumvbtxj-k.png"></a> <br>  <i>Un gráfico bastante grande del uso de la CPU (haga clic para SVG)</i> <br><br><pre> <code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> test -bench=. -trace trace.out $ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> tool trace trace.out</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/dd/tf/pk/ddtfpkssk98xhs_6o2ncqbxkucq.png"></a> <br>  <i>Seguimiento del arco iris: muchas tareas pequeñas (haga clic para abrir, solo funciona en Google Chrome)</i> <br><br>  El seguimiento confirma que todos los núcleos de procesador están ocupados (líneas por debajo de 0, 1, etc.) y, a primera vista, esto es bueno.  Pero también muestra miles de pequeños "cálculos" de colores y varias áreas vacías donde los núcleos estaban inactivos.  Vamos a acercarnos: <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/h3/-w/qe/h3-wqeqyb3xiiwyyvott4cwywg4.png"></a> <br>  <i>"Ventana" en 3 ms (haga clic para abrir, solo funciona en Google Chrome)</i> <br><br>  Cada núcleo está inactivo durante bastante tiempo y también "salta" entre micro tareas todo el tiempo.  Parece que la granularidad de estas tareas no es muy óptima, lo que lleva a una gran cantidad de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cambios</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">contexto</a> y a la competencia debido a la sincronización. <br><br>  Veamos qué nos dice el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">detector de vuelo</a> .  ¿Hay algún problema en el acceso síncrono a los datos (si hay alguno, entonces tenemos problemas mucho mayores que el rendimiento)? <br><br><pre> <code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> test -race PASS</code> </pre> <br>  Genial  Todo esta correcto.  No se encontraron vuelos.  Las funciones de prueba y las funciones de referencia son funciones diferentes ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">consulte la documentación</a> ), pero aquí llaman a la misma función <i>ParseAdexpMessage</i> , por lo que lo que verificamos para vuelos de datos por pruebas está bien. <br><br>  El modelo competitivo en la versión "buena" consiste en procesar cada línea desde el archivo de entrada en una rutina diferente (para usar todos los núcleos).  La intuición del autor aquí funcionó bien, ya que las gorutinas tienen fama de características fáciles y baratas.  Pero, ¿cuánto ganamos con la ejecución paralela?  Comparemos con el mismo código pero sin usar goroutines (solo elimine la palabra go que viene antes de la llamada a la función): <br><br><img src="https://habrastorage.org/webt/up/1q/0f/up1q0fy6bggo-62uevoioyo0huq.png"><br><img src="https://habrastorage.org/webt/ae/v3/go/aev3gocqbxle0pa3_lmeeyyczrg.png"><br><br>  Vaya, parece que el código se ha vuelto más rápido sin usar concurrencia.  Esto significa que la sobrecarga (distinta de cero) para lanzar gorutinas excede el tiempo que ganamos al usar varios núcleos al mismo tiempo.  El siguiente paso natural debería ser eliminar la sobrecarga (que no sea cero) para usar canales para enviar los resultados.  Vamos a reemplazarlo con un corte regular: <br><br><img src="https://habrastorage.org/webt/p_/sm/dl/p_smdl6hi439zezi4dygfvuyvtc.png"><br>  <i>μs por llamada (menos es mejor)</i> <br><br>  Obtuvimos aproximadamente un 40% de aceleración en comparación con la versión "buena", simplificando el código y eliminando la competencia ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">diff</a> ). <br><br><img src="https://habrastorage.org/webt/qr/in/pi/qrinpifpqvwgdb65z1yflyywjhg.png"><br>  <i>Con una gorutina, solo un núcleo funciona a la vez</i> <br><br>  Veamos ahora las funciones activas en el gráfico pprof: <br><br> <a href=""><img src="https://habrastorage.org/webt/89/sd/bk/89sdbk8fhme8ixv37a2hmnxpj54.png"></a> <br>  <i>Buscando cuellos de botella</i> <br><br>  El punto de referencia de la versión actual (operación secuencial, cortes) pasa el 86% del tiempo analizando mensajes, y esto es normal.  Pero notaremos rápidamente que el 43% del tiempo se gasta en usar expresiones regulares y la función <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">(* Regexp) .FindAll</a> . <br><br>  A pesar de que las expresiones regulares son una forma conveniente y flexible de obtener datos de texto plano, tienen inconvenientes, incluido el uso de una gran cantidad de recursos y un procesador y memoria.  Son una herramienta poderosa, pero a menudo su uso es innecesario. <br><br>  En nuestro programa, una plantilla <br><br><pre> <code class="go hljs">patternSubfield = <span class="hljs-string"><span class="hljs-string">"-.[^-]*"</span></span></code> </pre> <br>  Su objetivo principal es resaltar los comandos que comienzan con un guión (-), y puede haber varios en la línea.  Esto, después de haber extraído un pequeño código, se puede hacer usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bytes</a> .  Adaptemos el código ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">commit</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">commit</a> ) para cambiar las expresiones regulares a Split: <br><br><img src="https://habrastorage.org/webt/ks/8l/s2/ks8ls2upltp-tnqnpinp2tauqkc.png"><br>  <i>μs por llamada (menos</i> es <i>mejor)</i> <br><br>  Wow!  ¡Código 40% más productivo!  El gráfico de consumo de CPU ahora se ve así: <br><br> <a href=""><img src="https://habrastorage.org/webt/be/ux/dy/beuxdy132ncb8resbitn2gndy1a.png"></a> <br><br>  No más tiempo perdido en expresiones regulares.  Una parte importante (40%) se destina a la asignación de memoria de cinco funciones diferentes.  Curiosamente, ahora el 21% del tiempo se dedica a los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bytes.</a> Función de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">recorte</a> : <br><br><img src="https://habrastorage.org/webt/8f/if/md/8fifmdma-hteqqu_p85umbyo1ly.png"><br>  <i>Esta característica me intriga.</i>  <i>¿Qué podemos hacer aquí?</i> <i><br><br></i>  <i>bytes.Trim</i> espera una cadena con caracteres que "corta" como argumento, pero como esta cadena pasamos una cadena con un solo carácter: un espacio.  Este es solo un ejemplo de cómo puede obtener la aceleración debido a la complejidad: creemos nuestra función de recorte en lugar de la estándar.  Nuestra función de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">recorte</a> personalizado funcionará con un solo byte en lugar de una línea completa: <br><br><img src="https://habrastorage.org/webt/xs/cv/np/xscvnpnpkjo9ml4yq8chimeimv4.png"><br><img src="https://habrastorage.org/webt/h-/is/7x/h-is7xreexvfn_s537mdqtdkmrc.png"><br>  <i>μs por llamada (menos es mejor)</i> <br><br>  ¡Hurra, otro 20% de descuento!  La versión actual es cuatro veces más rápida que la original "mala" y al mismo tiempo usa solo un núcleo.  No esta mal! <br><br><hr><br><br>  Anteriormente, abandonamos la competitividad en el nivel de procesamiento de línea, pero sostengo que la aceleración se puede lograr utilizando la competitividad en un nivel superior.  Por ejemplo, procesar 6,000 archivos (6,000 mensajes) es más rápido en mi computadora si cada archivo se procesa en su propia rutina: <br><br><img src="https://habrastorage.org/webt/r0/lf/oo/r0lfoof3kljocawz0tjcmogrww4.png"><br>  <i>μs por llamada (menos es mejor; el morado es una solución competitiva)</i> <br><br>  La ganancia es del 66% (es decir, aceleración tres veces).  Esto es bueno, pero no mucho, teniendo en cuenta que se utilizan los 12 núcleos de procesador que tengo.  Esto puede significar que el nuevo código optimizado que procesa todo el archivo sigue siendo una "pequeña tarea", para la cual la sobrecarga para crear gorutinas y el costo de sincronización no son insignificantes.  Curiosamente, aumentar el número de mensajes de 6,000 a 120,000 no tiene ningún efecto en la versión de subproceso único y reduce el rendimiento en la versión de "una rutina por mensaje".  Esto se debe a que, a pesar del hecho de que crear una cantidad tan grande de gorutinas es posible y a veces útil, trae su propia sobrecarga en el área del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">programador de</a> tiempo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ejecución</a> . <br><br>  Podemos reducir aún más el tiempo de ejecución (no 12 veces, pero aún así) creando solo unos pocos trabajadores.  Por ejemplo, 12 gorutinas de larga vida, cada una de las cuales procesará parte de los mensajes: <br><br><img src="https://habrastorage.org/webt/re/v2/wf/rev2wf-q7cfgvhxsfj15n30l6xa.png"><br>  <i>μs por llamada (menos es mejor; el morado es una solución competitiva)</i> <br><br>  Esta opción reduce el tiempo de ejecución en un 79% en comparación con la versión de subproceso único.  Tenga en cuenta que esta estrategia solo tiene sentido si tiene muchos archivos para procesar. <br><br>  El uso óptimo de todos los núcleos de procesador es usar varias gorutinas, cada una de las cuales procesa una cantidad significativa de datos sin ninguna interacción o sincronización antes de que se complete el trabajo. <br><br>  Por lo general, toman tantos procesos (goroutine) como los núcleos del procesador, pero esta no siempre es la mejor opción: todo depende de la tarea específica.  Por ejemplo, si está leyendo algo del sistema de archivos o haciendo muchas llamadas de red, para obtener más rendimiento, debe usar más goroutines que sus núcleos. <br><br><img src="https://habrastorage.org/webt/gd/m-/ic/gdm-icxpy5qq_n2fw5-zru20gu4.png"><br>  <i>μs por llamada (menos es mejor; el morado es una solución competitiva)</i> <br><br>  Hemos llegado al punto en que el rendimiento del análisis es difícil de aumentar con algunos cambios localizados.  El tiempo de ejecución está dominado por el tiempo para la asignación de memoria y la recolección de elementos no utilizados.  Esto suena lógico ya que las funciones de administración de memoria son bastante lentas.  Una mayor optimización de los procesos asociados con las asignaciones sigue siendo una tarea para los lectores. <br><br><hr><br><br>  El uso de otros algoritmos también puede conducir a una gran ganancia de rendimiento. <br><br>  Aquí me inspiró una conferencia de Lexical Scanning en Go de Rob Pike, <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HxaD_trXwRE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  para crear un lexer personalizado ( <a href="">fuente</a> ) y un analizador personalizado ( <a href="">fuente</a> ).  Este código aún no está listo (no proceso un montón de casos de esquina), es menos claro que el algoritmo original y, a veces, es difícil escribir el manejo correcto de errores.  Pero es pequeño y 30% más rápido que la versión más optimizada. <br><br><img src="https://habrastorage.org/webt/ey/c3/n7/eyc3n7fnc1lu_szlyn2fnn0lzti.png"><br>  <i>μs por llamada (menos es mejor; el morado es una solución competitiva)</i> <br><br>  Si  Como resultado, obtuvimos una aceleración de 23 veces en comparación con el código fuente. <br><br><hr><br><br>  Eso es todo por hoy.  Espero que hayas disfrutado esta aventura.  Aquí hay algunas notas y conclusiones: <br><br><ul><li>  La productividad se puede mejorar en varios niveles de abstracción, utilizando diferentes técnicas, y la ganancia a menudo se incrementa. <br></li><li>  El ajuste debe comenzar con abstracciones de alto nivel: estructuras de datos, algoritmos, el desacoplamiento correcto de los módulos.  Tome abstracciones de bajo nivel más adelante: E / S, procesamiento por lotes, competitividad, uso de la biblioteca estándar, trabajo con memoria, asignación de memoria. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El</a> análisis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Big O</a> es muy importante, pero generalmente no es la herramienta más adecuada para acelerar un programa. <br></li><li>  Escribir puntos de referencia es un trabajo duro.  Use perfiles y puntos de referencia para encontrar cuellos de botella y obtener una comprensión más amplia de lo que está sucediendo en el programa.  Tenga en cuenta que los resultados de referencia no son los mismos que sus usuarios experimentarán en el trabajo de la vida real. <br></li><li>  Afortunadamente, un conjunto de herramientas ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bench</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pprof</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">trace</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Race Detector</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cover</a> ) hace que la investigación sobre el rendimiento del código sea asequible e interesante. <br></li><li>  Escribir buenas pruebas relevantes no es una tarea trivial.  Pero son muy importantes para no ir a la naturaleza.  Puede refactorizar, asegurándose de que el código siga siendo correcto. <br></li><li>  Detente y pregúntate qué tan rápido es "lo suficientemente rápido".  No pierdas tu tiempo optimizando algunos guiones únicos.  No olvide que la optimización no es gratuita: el tiempo, la complejidad, los errores y la deuda técnica del ingeniero. <br></li><li>  Piénselo dos veces antes de complicar el código. <br></li><li>  Los algoritmos con complejidad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ω</a> (n²) y superiores suelen ser demasiado caros. <br></li><li>  Los algoritmos con complejidad O (n) u O (n log n) y a continuación generalmente están bien. <br></li><li>  Varios <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">factores ocultos</a> no pueden ser ignorados.  Por ejemplo, todas las mejoras en el artículo se realizaron al reducir estos factores y no al cambiar la clase de complejidad del algoritmo. <br></li><li>  La E / S suele ser un cuello de botella: consultas de red, consultas de bases de datos, sistema de archivos. <br></li><li>  Las expresiones regulares son a menudo demasiado caras e innecesarias. <br></li><li>  Las asignaciones de memoria son más caras que los cálculos. <br></li><li>  Un objeto asignado en la pila es más barato que un objeto asignado en el montón. <br></li><li>  Los cortes son útiles como una alternativa a los costosos movimientos de memoria. <br></li><li>  Las cadenas son efectivas cuando son de solo lectura (incluida la reorganización).  En todos los demás casos, [] byte son más efectivos. <br></li><li>  Es muy importante que los datos que procesa estén cerca (cachés del procesador). <br></li><li>  La competitividad y el paralelismo son muy útiles, pero difíciles de preparar. <br></li><li>  Cuando caves profundo y bajo, recuerda el "piso de vidrio" en el que no quieres entrar.  Si sus manos están ansiosas por probar las instrucciones del ensamblador, las instrucciones SIMD, es posible que necesite usar Go solo para la creación de prototipos y luego cambiar a un idioma de nivel inferior para obtener el control total del hardware y cada nanosegundo. <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es415919/">https://habr.com/ru/post/es415919/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es415909/index.html">Extensión web entre navegadores para scripts personalizados Parte 2</a></li>
<li><a href="../es415911/index.html">Acceso a un índice de matriz inexistente</a></li>
<li><a href="../es415913/index.html">Calentamiento para aquellos que pueden en Python</a></li>
<li><a href="../es415915/index.html">Práctica dura: ¿qué tipo de conexión inalámbrica tenemos para los hoteleros?</a></li>
<li><a href="../es415917/index.html">La "Ley de primavera" entró en vigor: ¿qué sigue?</a></li>
<li><a href="../es415923/index.html">¿La unidad es lenta? Precaución LINQ</a></li>
<li><a href="../es415925/index.html">Tecnología de cadena de bloques anónima patentada MasterCard</a></li>
<li><a href="../es415927/index.html">Lámpara industrial Breeze 50</a></li>
<li><a href="../es415929/index.html">Optimización de la arquitectura de inteligencia artificial: comienza la carrera</a></li>
<li><a href="../es415933/index.html">Cómo construir una arquitectura IIoT de bricolaje</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>