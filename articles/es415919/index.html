<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游돗游낗 游붔 游낹 Refactorizando un programa en Go: aceleraci칩n 23 veces 游뛌游낖 游녪游낗 游냪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Mi nombre es Marco, trabajo para Badoo en el departamento de Plataforma. Tenemos muchas cosas escritas en Go, y a menudo son cr칤ticas para el ren...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Refactorizando un programa en Go: aceleraci칩n 23 veces</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/415919/"><img src="https://habrastorage.org/webt/fw/oq/ji/fwoqjijc84e50kqfhpyzqfl-oay.jpeg"><br><br>  <i>Hola</i>  <i>Mi nombre es Marco, trabajo para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Badoo</a> en el departamento de Plataforma.</i>  <i>Tenemos muchas cosas escritas en Go, y a menudo son cr칤ticas para el rendimiento del sistema.</i>  <i>Es por eso que hoy te ofrezco una traducci칩n de un art칤culo que realmente me gust칩 y, estoy seguro, te ser치 muy 칰til.</i>  <i>El autor muestra paso a paso c칩mo abord칩 los problemas de rendimiento y c칩mo los resolvieron.</i>  <i>Incluyendo que se familiarizar치 con las ricas herramientas disponibles en Go para dicho trabajo.</i>  <i>Que tengas una buena lectura!</i> <br><br>  Hace unas semanas, le칤 el art칤culo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C칩digo bueno contra c칩digo malo en Go</a> " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">,</a> donde el autor, paso a paso, demuestra la refactorizaci칩n de una aplicaci칩n real que resuelve problemas comerciales reales.  Se enfoca en convertir el "c칩digo malo" en "c칩digo bueno": m치s idiom치tico, m치s comprensible, utilizando plenamente los detalles de Go.  Pero el autor tambi칠n declar칩 la importancia del rendimiento de la aplicaci칩n en cuesti칩n.  La curiosidad se apoder칩 de m칤: 춰intentemos acelerarlo! <br><a name="habracut"></a><br>  El programa, en t칠rminos generales, lee el archivo de entrada, lo analiza l칤nea por l칤nea y llena los objetos en la memoria. <br><br><img src="https://habrastorage.org/webt/q0/ar/rr/q0arrrwx11e7qz627mj4ttz1r7y.png"><br><br>  El autor no solo public칩 el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c칩digo fuente en GitHub</a> , sino que tambi칠n escribi칩 un punto de referencia.  Esta es una gran idea  De hecho, el autor invit칩 a todos a jugar con el c칩digo y tratar de acelerarlo.  Para reproducir los resultados del autor, use el siguiente comando: <br><br><pre><code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> test -bench=.</code> </pre> <br><img src="https://habrastorage.org/webt/jw/x2/6w/jwx26wyngj_sqokfhrbk-3u3yeo.png"><br>  <i>풮s por llamada (menos - mejor)</i> <br><br>  Resulta que en mi computadora el "buen c칩digo" es un 16% m치s r치pido.  쯇odemos acelerarlo? <br><br>  En mi experiencia, existe una correlaci칩n entre la calidad del c칩digo y el rendimiento.  Si refactoriz칩 con 칠xito el c칩digo, lo hizo m치s limpio y menos conectado, probablemente lo hizo m치s r치pido porque se volvi칩 menos abarrotado (y no hay m치s instrucciones innecesarias que se ejecutaron previamente en vano).  Quiz치s durante la refactorizaci칩n not칩 algunas oportunidades de optimizaci칩n, o ahora solo tiene la oportunidad de aprovecharlas.  Pero, por otro lado, si desea que el c칩digo sea a칰n m치s productivo, probablemente tenga que alejarse de la simplicidad y agregar varios hacks.  Realmente ahorras milisegundos, pero la calidad del c칩digo se ver치 afectada: ser치 m치s dif칤cil leerlo y hablar sobre 칠l, se volver치 m치s fr치gil y flexible. <br><br><img src="https://habrastorage.org/webt/c9/lz/zd/c9lzzdc9yi73nsxn6cm93vwbvei.gif"><br>  <i>Subimos la monta침a de la simplicidad, y luego bajamos de ella</i> <br><br>  Esto es una compensaci칩n: 쯛asta d칩nde est치s dispuesto a llegar? <br><br>  Para priorizar adecuadamente el trabajo de aceleraci칩n, la estrategia 칩ptima es encontrar cuellos de botella y concentrarse en ellos.  Para hacer esto, use las herramientas de creaci칩n de perfiles.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pprof</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">trace</a> son tus amigos: <br><br><pre> <code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> test -bench=. -cpuprofile cpu.prof $ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> tool pprof -svg cpu.prof &gt; cpu.svg</code> </pre> <br> <a href=""><img src="https://habrastorage.org/webt/dc/j4/vf/dcj4vfmpccf5k2gjyxumvbtxj-k.png"></a> <br>  <i>Un gr치fico bastante grande del uso de la CPU (haga clic para SVG)</i> <br><br><pre> <code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> test -bench=. -trace trace.out $ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> tool trace trace.out</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/dd/tf/pk/ddtfpkssk98xhs_6o2ncqbxkucq.png"></a> <br>  <i>Seguimiento del arco iris: muchas tareas peque침as (haga clic para abrir, solo funciona en Google Chrome)</i> <br><br>  El seguimiento confirma que todos los n칰cleos de procesador est치n ocupados (l칤neas por debajo de 0, 1, etc.) y, a primera vista, esto es bueno.  Pero tambi칠n muestra miles de peque침os "c치lculos" de colores y varias 치reas vac칤as donde los n칰cleos estaban inactivos.  Vamos a acercarnos: <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/h3/-w/qe/h3-wqeqyb3xiiwyyvott4cwywg4.png"></a> <br>  <i>"Ventana" en 3 ms (haga clic para abrir, solo funciona en Google Chrome)</i> <br><br>  Cada n칰cleo est치 inactivo durante bastante tiempo y tambi칠n "salta" entre micro tareas todo el tiempo.  Parece que la granularidad de estas tareas no es muy 칩ptima, lo que lleva a una gran cantidad de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cambios</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">contexto</a> y a la competencia debido a la sincronizaci칩n. <br><br>  Veamos qu칠 nos dice el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">detector de vuelo</a> .  쮿ay alg칰n problema en el acceso s칤ncrono a los datos (si hay alguno, entonces tenemos problemas mucho mayores que el rendimiento)? <br><br><pre> <code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> test -race PASS</code> </pre> <br>  Genial  Todo esta correcto.  No se encontraron vuelos.  Las funciones de prueba y las funciones de referencia son funciones diferentes ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">consulte la documentaci칩n</a> ), pero aqu칤 llaman a la misma funci칩n <i>ParseAdexpMessage</i> , por lo que lo que verificamos para vuelos de datos por pruebas est치 bien. <br><br>  El modelo competitivo en la versi칩n "buena" consiste en procesar cada l칤nea desde el archivo de entrada en una rutina diferente (para usar todos los n칰cleos).  La intuici칩n del autor aqu칤 funcion칩 bien, ya que las gorutinas tienen fama de caracter칤sticas f치ciles y baratas.  Pero, 쯖u치nto ganamos con la ejecuci칩n paralela?  Comparemos con el mismo c칩digo pero sin usar goroutines (solo elimine la palabra go que viene antes de la llamada a la funci칩n): <br><br><img src="https://habrastorage.org/webt/up/1q/0f/up1q0fy6bggo-62uevoioyo0huq.png"><br><img src="https://habrastorage.org/webt/ae/v3/go/aev3gocqbxle0pa3_lmeeyyczrg.png"><br><br>  Vaya, parece que el c칩digo se ha vuelto m치s r치pido sin usar concurrencia.  Esto significa que la sobrecarga (distinta de cero) para lanzar gorutinas excede el tiempo que ganamos al usar varios n칰cleos al mismo tiempo.  El siguiente paso natural deber칤a ser eliminar la sobrecarga (que no sea cero) para usar canales para enviar los resultados.  Vamos a reemplazarlo con un corte regular: <br><br><img src="https://habrastorage.org/webt/p_/sm/dl/p_smdl6hi439zezi4dygfvuyvtc.png"><br>  <i>풮s por llamada (menos es mejor)</i> <br><br>  Obtuvimos aproximadamente un 40% de aceleraci칩n en comparaci칩n con la versi칩n "buena", simplificando el c칩digo y eliminando la competencia ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">diff</a> ). <br><br><img src="https://habrastorage.org/webt/qr/in/pi/qrinpifpqvwgdb65z1yflyywjhg.png"><br>  <i>Con una gorutina, solo un n칰cleo funciona a la vez</i> <br><br>  Veamos ahora las funciones activas en el gr치fico pprof: <br><br> <a href=""><img src="https://habrastorage.org/webt/89/sd/bk/89sdbk8fhme8ixv37a2hmnxpj54.png"></a> <br>  <i>Buscando cuellos de botella</i> <br><br>  El punto de referencia de la versi칩n actual (operaci칩n secuencial, cortes) pasa el 86% del tiempo analizando mensajes, y esto es normal.  Pero notaremos r치pidamente que el 43% del tiempo se gasta en usar expresiones regulares y la funci칩n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">(* Regexp) .FindAll</a> . <br><br>  A pesar de que las expresiones regulares son una forma conveniente y flexible de obtener datos de texto plano, tienen inconvenientes, incluido el uso de una gran cantidad de recursos y un procesador y memoria.  Son una herramienta poderosa, pero a menudo su uso es innecesario. <br><br>  En nuestro programa, una plantilla <br><br><pre> <code class="go hljs">patternSubfield = <span class="hljs-string"><span class="hljs-string">"-.[^-]*"</span></span></code> </pre> <br>  Su objetivo principal es resaltar los comandos que comienzan con un gui칩n (-), y puede haber varios en la l칤nea.  Esto, despu칠s de haber extra칤do un peque침o c칩digo, se puede hacer usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bytes</a> .  Adaptemos el c칩digo ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">commit</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">commit</a> ) para cambiar las expresiones regulares a Split: <br><br><img src="https://habrastorage.org/webt/ks/8l/s2/ks8ls2upltp-tnqnpinp2tauqkc.png"><br>  <i>풮s por llamada (menos</i> es <i>mejor)</i> <br><br>  Wow!  춰C칩digo 40% m치s productivo!  El gr치fico de consumo de CPU ahora se ve as칤: <br><br> <a href=""><img src="https://habrastorage.org/webt/be/ux/dy/beuxdy132ncb8resbitn2gndy1a.png"></a> <br><br>  No m치s tiempo perdido en expresiones regulares.  Una parte importante (40%) se destina a la asignaci칩n de memoria de cinco funciones diferentes.  Curiosamente, ahora el 21% del tiempo se dedica a los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bytes.</a> Funci칩n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">recorte</a> : <br><br><img src="https://habrastorage.org/webt/8f/if/md/8fifmdma-hteqqu_p85umbyo1ly.png"><br>  <i>Esta caracter칤stica me intriga.</i>  <i>쯈u칠 podemos hacer aqu칤?</i> <i><br><br></i>  <i>bytes.Trim</i> espera una cadena con caracteres que "corta" como argumento, pero como esta cadena pasamos una cadena con un solo car치cter: un espacio.  Este es solo un ejemplo de c칩mo puede obtener la aceleraci칩n debido a la complejidad: creemos nuestra funci칩n de recorte en lugar de la est치ndar.  Nuestra funci칩n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">recorte</a> personalizado funcionar치 con un solo byte en lugar de una l칤nea completa: <br><br><img src="https://habrastorage.org/webt/xs/cv/np/xscvnpnpkjo9ml4yq8chimeimv4.png"><br><img src="https://habrastorage.org/webt/h-/is/7x/h-is7xreexvfn_s537mdqtdkmrc.png"><br>  <i>풮s por llamada (menos es mejor)</i> <br><br>  춰Hurra, otro 20% de descuento!  La versi칩n actual es cuatro veces m치s r치pida que la original "mala" y al mismo tiempo usa solo un n칰cleo.  No esta mal! <br><br><hr><br><br>  Anteriormente, abandonamos la competitividad en el nivel de procesamiento de l칤nea, pero sostengo que la aceleraci칩n se puede lograr utilizando la competitividad en un nivel superior.  Por ejemplo, procesar 6,000 archivos (6,000 mensajes) es m치s r치pido en mi computadora si cada archivo se procesa en su propia rutina: <br><br><img src="https://habrastorage.org/webt/r0/lf/oo/r0lfoof3kljocawz0tjcmogrww4.png"><br>  <i>풮s por llamada (menos es mejor; el morado es una soluci칩n competitiva)</i> <br><br>  La ganancia es del 66% (es decir, aceleraci칩n tres veces).  Esto es bueno, pero no mucho, teniendo en cuenta que se utilizan los 12 n칰cleos de procesador que tengo.  Esto puede significar que el nuevo c칩digo optimizado que procesa todo el archivo sigue siendo una "peque침a tarea", para la cual la sobrecarga para crear gorutinas y el costo de sincronizaci칩n no son insignificantes.  Curiosamente, aumentar el n칰mero de mensajes de 6,000 a 120,000 no tiene ning칰n efecto en la versi칩n de subproceso 칰nico y reduce el rendimiento en la versi칩n de "una rutina por mensaje".  Esto se debe a que, a pesar del hecho de que crear una cantidad tan grande de gorutinas es posible y a veces 칰til, trae su propia sobrecarga en el 치rea del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">programador de</a> tiempo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ejecuci칩n</a> . <br><br>  Podemos reducir a칰n m치s el tiempo de ejecuci칩n (no 12 veces, pero a칰n as칤) creando solo unos pocos trabajadores.  Por ejemplo, 12 gorutinas de larga vida, cada una de las cuales procesar치 parte de los mensajes: <br><br><img src="https://habrastorage.org/webt/re/v2/wf/rev2wf-q7cfgvhxsfj15n30l6xa.png"><br>  <i>풮s por llamada (menos es mejor; el morado es una soluci칩n competitiva)</i> <br><br>  Esta opci칩n reduce el tiempo de ejecuci칩n en un 79% en comparaci칩n con la versi칩n de subproceso 칰nico.  Tenga en cuenta que esta estrategia solo tiene sentido si tiene muchos archivos para procesar. <br><br>  El uso 칩ptimo de todos los n칰cleos de procesador es usar varias gorutinas, cada una de las cuales procesa una cantidad significativa de datos sin ninguna interacci칩n o sincronizaci칩n antes de que se complete el trabajo. <br><br>  Por lo general, toman tantos procesos (goroutine) como los n칰cleos del procesador, pero esta no siempre es la mejor opci칩n: todo depende de la tarea espec칤fica.  Por ejemplo, si est치 leyendo algo del sistema de archivos o haciendo muchas llamadas de red, para obtener m치s rendimiento, debe usar m치s goroutines que sus n칰cleos. <br><br><img src="https://habrastorage.org/webt/gd/m-/ic/gdm-icxpy5qq_n2fw5-zru20gu4.png"><br>  <i>풮s por llamada (menos es mejor; el morado es una soluci칩n competitiva)</i> <br><br>  Hemos llegado al punto en que el rendimiento del an치lisis es dif칤cil de aumentar con algunos cambios localizados.  El tiempo de ejecuci칩n est치 dominado por el tiempo para la asignaci칩n de memoria y la recolecci칩n de elementos no utilizados.  Esto suena l칩gico ya que las funciones de administraci칩n de memoria son bastante lentas.  Una mayor optimizaci칩n de los procesos asociados con las asignaciones sigue siendo una tarea para los lectores. <br><br><hr><br><br>  El uso de otros algoritmos tambi칠n puede conducir a una gran ganancia de rendimiento. <br><br>  Aqu칤 me inspir칩 una conferencia de Lexical Scanning en Go de Rob Pike, <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HxaD_trXwRE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  para crear un lexer personalizado ( <a href="">fuente</a> ) y un analizador personalizado ( <a href="">fuente</a> ).  Este c칩digo a칰n no est치 listo (no proceso un mont칩n de casos de esquina), es menos claro que el algoritmo original y, a veces, es dif칤cil escribir el manejo correcto de errores.  Pero es peque침o y 30% m치s r치pido que la versi칩n m치s optimizada. <br><br><img src="https://habrastorage.org/webt/ey/c3/n7/eyc3n7fnc1lu_szlyn2fnn0lzti.png"><br>  <i>풮s por llamada (menos es mejor; el morado es una soluci칩n competitiva)</i> <br><br>  Si  Como resultado, obtuvimos una aceleraci칩n de 23 veces en comparaci칩n con el c칩digo fuente. <br><br><hr><br><br>  Eso es todo por hoy.  Espero que hayas disfrutado esta aventura.  Aqu칤 hay algunas notas y conclusiones: <br><br><ul><li>  La productividad se puede mejorar en varios niveles de abstracci칩n, utilizando diferentes t칠cnicas, y la ganancia a menudo se incrementa. <br></li><li>  El ajuste debe comenzar con abstracciones de alto nivel: estructuras de datos, algoritmos, el desacoplamiento correcto de los m칩dulos.  Tome abstracciones de bajo nivel m치s adelante: E / S, procesamiento por lotes, competitividad, uso de la biblioteca est치ndar, trabajo con memoria, asignaci칩n de memoria. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El</a> an치lisis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Big O</a> es muy importante, pero generalmente no es la herramienta m치s adecuada para acelerar un programa. <br></li><li>  Escribir puntos de referencia es un trabajo duro.  Use perfiles y puntos de referencia para encontrar cuellos de botella y obtener una comprensi칩n m치s amplia de lo que est치 sucediendo en el programa.  Tenga en cuenta que los resultados de referencia no son los mismos que sus usuarios experimentar치n en el trabajo de la vida real. <br></li><li>  Afortunadamente, un conjunto de herramientas ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bench</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pprof</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">trace</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Race Detector</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cover</a> ) hace que la investigaci칩n sobre el rendimiento del c칩digo sea asequible e interesante. <br></li><li>  Escribir buenas pruebas relevantes no es una tarea trivial.  Pero son muy importantes para no ir a la naturaleza.  Puede refactorizar, asegur치ndose de que el c칩digo siga siendo correcto. <br></li><li>  Detente y preg칰ntate qu칠 tan r치pido es "lo suficientemente r치pido".  No pierdas tu tiempo optimizando algunos guiones 칰nicos.  No olvide que la optimizaci칩n no es gratuita: el tiempo, la complejidad, los errores y la deuda t칠cnica del ingeniero. <br></li><li>  Pi칠nselo dos veces antes de complicar el c칩digo. <br></li><li>  Los algoritmos con complejidad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">풜</a> (n) y superiores suelen ser demasiado caros. <br></li><li>  Los algoritmos con complejidad O (n) u O (n log n) y a continuaci칩n generalmente est치n bien. <br></li><li>  Varios <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">factores ocultos</a> no pueden ser ignorados.  Por ejemplo, todas las mejoras en el art칤culo se realizaron al reducir estos factores y no al cambiar la clase de complejidad del algoritmo. <br></li><li>  La E / S suele ser un cuello de botella: consultas de red, consultas de bases de datos, sistema de archivos. <br></li><li>  Las expresiones regulares son a menudo demasiado caras e innecesarias. <br></li><li>  Las asignaciones de memoria son m치s caras que los c치lculos. <br></li><li>  Un objeto asignado en la pila es m치s barato que un objeto asignado en el mont칩n. <br></li><li>  Los cortes son 칰tiles como una alternativa a los costosos movimientos de memoria. <br></li><li>  Las cadenas son efectivas cuando son de solo lectura (incluida la reorganizaci칩n).  En todos los dem치s casos, [] byte son m치s efectivos. <br></li><li>  Es muy importante que los datos que procesa est칠n cerca (cach칠s del procesador). <br></li><li>  La competitividad y el paralelismo son muy 칰tiles, pero dif칤ciles de preparar. <br></li><li>  Cuando caves profundo y bajo, recuerda el "piso de vidrio" en el que no quieres entrar.  Si sus manos est치n ansiosas por probar las instrucciones del ensamblador, las instrucciones SIMD, es posible que necesite usar Go solo para la creaci칩n de prototipos y luego cambiar a un idioma de nivel inferior para obtener el control total del hardware y cada nanosegundo. <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es415919/">https://habr.com/ru/post/es415919/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es415909/index.html">Extensi칩n web entre navegadores para scripts personalizados Parte 2</a></li>
<li><a href="../es415911/index.html">Acceso a un 칤ndice de matriz inexistente</a></li>
<li><a href="../es415913/index.html">Calentamiento para aquellos que pueden en Python</a></li>
<li><a href="../es415915/index.html">Pr치ctica dura: 쯤u칠 tipo de conexi칩n inal치mbrica tenemos para los hoteleros?</a></li>
<li><a href="../es415917/index.html">La "Ley de primavera" entr칩 en vigor: 쯤u칠 sigue?</a></li>
<li><a href="../es415923/index.html">쯃a unidad es lenta? Precauci칩n LINQ</a></li>
<li><a href="../es415925/index.html">Tecnolog칤a de cadena de bloques an칩nima patentada MasterCard</a></li>
<li><a href="../es415927/index.html">L치mpara industrial Breeze 50</a></li>
<li><a href="../es415929/index.html">Optimizaci칩n de la arquitectura de inteligencia artificial: comienza la carrera</a></li>
<li><a href="../es415933/index.html">C칩mo construir una arquitectura IIoT de bricolaje</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>