<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§± üöΩ üßÄ Prinzip der Einzelverantwortung. Nicht so einfach wie es sich anh√∂rt ‚ôÇÔ∏è ü§πüèª üë®‚Äç‚öïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prinzip der Einzelverantwortung, er ist das Prinzip der Einzelverantwortung, 
 Er ist das Prinzip der einheitlichen Variabilit√§t - ein extrem rutschig...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Prinzip der Einzelverantwortung. Nicht so einfach wie es sich anh√∂rt</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454290/"><p><img width="500" src="https://habrastorage.org/getpro/habr/post_images/dad/c41/3d4/dadc413d4439871ac1632997daa6416c.png" alt="Bild" align="left">  Prinzip der Einzelverantwortung, er ist das Prinzip der Einzelverantwortung, <br>  Er ist das Prinzip der einheitlichen Variabilit√§t - ein extrem rutschiger Typ, den man verstehen muss, und eine so nerv√∂se Frage beim Interview mit einem Programmierer. </p><br><p>  Die erste ernsthafte Bekanntschaft mit diesem Prinzip fand f√ºr mich zu Beginn des ersten Jahres statt, als wir aus den Jungen und Gr√ºnen in den Wald gebracht wurden, um echte Sch√ºler aus den Larven zu machen. </p><br><p> Im Wald wurden wir in Gruppen von jeweils 8-9 Personen aufgeteilt und organisierten einen Wettbewerb - welche Gruppe wird schneller eine Flasche Wodka trinken, vorausgesetzt, die erste Person aus der Gruppe gie√üt Wodka in ein Glas, die zweite trinkt und die dritte nimmt einen Bissen.  Nach Abschluss des Betriebs steht das Ger√§t am Ende der Gruppenwarteschlange. </p><br><p>  Der Fall, in dem die Warteschlangengr√∂√üe ein Vielfaches von drei war und eine gute Implementierung von SRP war. </p><a name="habracut"></a><br><h2 id="opredelenie-1-edinaya-otvetstvennost">  Definition 1. Einzelverantwortung. </h2><br><p>  Die offizielle Definition des Prinzips der Einzelverantwortung (SRP) legt nahe, dass jedes Objekt seine eigene Verantwortung und seinen eigenen Existenzgrund hat, und diese Verantwortung hat nur einen. </p><br><p>  Betrachten Sie das Tippler-Objekt. <br>  Um das SRP-Prinzip zu erf√ºllen, teilen wir die Verantwortlichkeiten in drei Bereiche: </p><br><ul><li>  Man gie√üt ( <strong>PourOperation</strong> ) </li><li>  One <strong>Drinks</strong> ( <strong>DrinkUpOperation</strong> ) </li><li>  Ein Snack ( <strong>TakeBiteOperation</strong> ) </li></ul><br><p>  Jeder der Teilnehmer des Prozesses ist f√ºr eine Komponente des Prozesses verantwortlich, dh er hat eine atomare Verantwortung - zu trinken, zu gie√üen oder einen Bissen zu haben. </p><br><p>  Der Alkohol wiederum ist die Fassade f√ºr diese Operationen: </p><br><pre><code class="plaintext hljs">lass Tippler { //... void Act(){ _pourOperation.Do() //  _drinkUpOperation.Do() //  _takeBiteOperation.Do() //  } }</code> </pre> <br><div style="text-align:center;"><img width="600" src="https://habrastorage.org/getpro/habr/post_images/07b/979/ed5/07b979ed5db74fcec05254aadb60220d.png" alt="Bild"></div><br><h4 id="zachem">  Warum? </h4><br><p>  Der menschliche Programmierer schreibt den Code f√ºr den Affenmann, und der Affenmann ist unaufmerksam, dumm und hat es immer irgendwo eilig.  Er kann ungef√§hr 3 bis 7 Begriffe gleichzeitig halten und verstehen. <br>  Im Falle von Alkohol sind diese Begriffe drei.  Wenn wir den Code jedoch mit einem Blatt schreiben, erscheinen darin H√§nde, Brillen, Massaker und endlose Debatten √ºber Politik.  Und all dies wird im K√∂rper einer Methode sein.  Ich bin sicher, Sie haben einen solchen Code in Ihrer Praxis gesehen.  Nicht der humanste Test f√ºr die Psyche. </p><br><p>  Auf der anderen Seite ist der Affenmann eingesperrt, weil er reale Objekte in seinem Kopf modelliert hat.  In seiner Vorstellung kann er sie zusammenschieben, neue Objekte von ihnen sammeln und sie auf die gleiche Weise zerlegen.  Stellen Sie sich ein altes Automodell vor.  Sie k√∂nnen die T√ºr in Ihrer Fantasie √∂ffnen, die T√ºrverkleidung abschrauben und dort die Fensterhebermechanismen sehen, in denen sich Zahnr√§der befinden.  Sie k√∂nnen jedoch nicht alle Komponenten der Maschine gleichzeitig in einer "Liste" sehen.  Zumindest der "Affenmann" kann das nicht. </p><br><p>  Daher zerlegen menschliche Programmierer komplexe Mechanismen in eine Reihe weniger komplexer und funktionierender Elemente.  Die Zersetzung kann jedoch auf verschiedene Arten erfolgen: In vielen alten Autos - der Kanal geht aus der T√ºr und in modernen - verhindert das Versagen der Schlosselektronik das Starten des Motors, der w√§hrend der Reparatur liefert. </p><br><p>  <strong>SRP ist also ein Prinzip, das erkl√§rt, wie man zerlegt, dh wo die Trennlinie gezogen wird</strong> . </p><br><p>  Er sagt, dass die Zersetzung auf dem Prinzip der Trennung von "Verantwortung" beruhen sollte, dh auf den Aufgaben verschiedener Objekte. </p><br><div style="text-align:center;"><img width="400" src="https://habrastorage.org/getpro/habr/post_images/b89/d0f/3c6/b89d0f3c6434ae77a2b858e2af6374b0.png" alt="Bild"></div><br><p>  Kehren wir zum Alkohol und den Vorteilen zur√ºck, die eine Affenperson beim Zerlegen hat: </p><br><ul><li>  Der Code ist auf jeder Ebene extrem klar geworden. </li><li>  Mehrere Programmierer k√∂nnen gleichzeitig Code schreiben (jeder schreibt ein separates Element). </li><li>  Das automatisierte Testen wird vereinfacht - je einfacher das Element ist, desto einfacher ist es zu testen </li><li>  Aus diesen drei Vorg√§ngen k√∂nnen Sie in Zukunft den Vielfra√ü (nur mit <strong>TakeBitOperation</strong> ) und den Alkoholiker (nur mit <strong>DrinkUpOperation</strong> direkt aus der Flasche) <strong>addieren</strong> und viele andere Gesch√§ftsanforderungen erf√ºllen. </li></ul><br><p>  Und nat√ºrlich die Nachteile: </p><br><ul><li>  Muss mehr Typen erstellen. </li><li>  Ein Trinker wird ein paar Stunden sp√§ter zum ersten Mal trinken, als er konnte </li></ul><br><h2 id="opredelenie-2-edinaya-izmenchivost">  Definition 2. Einheitliche Variabilit√§t. </h2><br><p>  Erlauben Sie meine Herren!  Die Trinkklasse erf√ºllt auch eine einzige Verantwortung - sie trinkt!  Und im Allgemeinen ist das Wort "Verantwortung" ein √§u√üerst vages Konzept.  Jemand ist f√ºr das Schicksal der Menschheit verantwortlich, und jemand ist daf√ºr verantwortlich, die an der Stange umgekippten Pinguine aufzuziehen. </p><br><p>  Betrachten Sie zwei Bingo-Implementierungen.  Die erste, oben erw√§hnte, enth√§lt drei Klassen - gie√üen, trinken und bei√üen. </p><br><p>  Die zweite Methode basiert auf der Forward- und Only Forward-Methode und enth√§lt die gesamte Logik der <strong>Act-</strong> Methode: </p><br><pre> <code class="plaintext hljs">//      .    lass BrutTippler { //... void Act(){ //  if(!_hand.TryDischarge(from:_bottle, to:_glass, size:_glass.Capacity)) throw new OverdrunkException(); //  if(!_hand.TryDrink(from: _glass, size: _glass.Capacity)) throw new OverdrunkException(); // for(int i = 0; i&lt; 3; i++){ var food = _foodStore.TakeOrDefault(); if(food==null) throw new FoodIsOverException(); _hand.TryEat(food); } } }</code> </pre> <br><p>  Beide Klassen sehen aus Sicht eines externen Beobachters genau gleich aus und erf√ºllen die alleinige Verantwortung des ‚ÄûTrinkens‚Äú. </p><br><p>  Verlegenheit! </p><br><p>  Dann surfen wir im Internet und finden eine andere Definition von SRP heraus - das Prinzip der einheitlichen Variabilit√§t. </p><br><p>  Diese Definition besagt: " <strong>Das Modul hat nur einen Grund f√ºr √Ñnderungen</strong> ."  Das hei√üt: "Verantwortung ist Anlass f√ºr Ver√§nderungen." </p><br><p>  Jetzt passt alles zusammen.  Separat k√∂nnen Sie die Gie√ü-, Trink- und Bei√üverfahren √§ndern, und im Alkohol selbst k√∂nnen wir nur die Reihenfolge und Zusammensetzung der Vorg√§nge √§ndern, z. B. den Snack vor dem Trinken bewegen oder einen Toastwert hinzuf√ºgen. </p><br><p>  Beim Forward and Only Forward-Ansatz wird alles, was ge√§ndert werden kann, nur bei der <strong>Act-</strong> Methode ge√§ndert.  Es kann lesbar und effektiv sein, wenn es wenig Logik gibt und es sich selten √§ndert, aber es endet oft mit schrecklichen Methoden von jeweils 500 Zeilen mit mehr Wenn-Zahlen, als f√ºr den Beitritt Russlands zur NATO erforderlich sind. </p><br><h2 id="opredelenie-3-lokalizaciya-izmeneniy">  Definition 3. Lokalisierung von √Ñnderungen. </h2><br><p>  Trinker verstehen oft nicht, warum sie in der Wohnung eines anderen aufgewacht sind oder wo sich ihr Handy befindet.  Es ist Zeit, eine detaillierte Protokollierung hinzuzuf√ºgen. </p><br><p>  Beginnen wir mit der Protokollierung mit dem Gie√üvorgang: </p><br><pre> <code class="plaintext hljs">class PourOperation: IOperation{ PourOperation(ILogger log /*....*/){/*...*/} //... void Do(){ _log.Log($"Before pour with {_hand} and {_bottle}"); //Pour business logic ... _log.Log($"After pour with {_hand} and {_bottle}"); } }</code> </pre> <br><p>  Wir haben es in <strong>PourOperation zusammengefasst</strong> und in Bezug auf Verantwortung und Verkapselung klug gehandelt, aber jetzt, mit dem Prinzip der Variabilit√§t, sind wir jetzt verlegen.  Zus√§tzlich zu der Operation selbst, die sich √§ndern kann, wird die Protokollierung selbst variabel.  Wir m√ºssen uns trennen und einen speziellen Logger f√ºr den Gie√üvorgang herstellen: </p><br><pre> <code class="plaintext hljs">interface IPourLogger{ void LogBefore(IHand, IBottle){} void LogAfter(IHand, IBottle){} void OnError(IHand, IBottle, Exception){} } class PourOperation: IOperation{ PourOperation(IPourLogger log /*....*/){/*...*/} //... void Do(){ _log.LogBefore(_hand, _bottle); try{ //... business logic _log.LogAfter(_hand, _bottle"); } catch(exception e){ _log.OnError(_hand, _bottle, e) } } }</code> </pre> <br><p>  Ein akribischer Leser wird feststellen, dass <strong>LogAfter</strong> , <strong>LogBefore</strong> und <strong>OnError</strong> auch einzeln ge√§ndert werden k√∂nnen. In Analogie zu den vorherigen Schritten werden drei Klassen erstellt: <strong>PourLoggerBefore</strong> , <strong>PourLoggerAfter</strong> und <strong>PourErrorLogger</strong> . </p><br><p>  Und wenn wir uns daran erinnern, dass es drei Operationen f√ºr einen Binge gibt - wir erhalten neun Protokollierungsklassen.  Infolgedessen besteht der gesamte Alkohol aus 14 (!!!) Klassen. </p><br><p>  √úbertreibung?  Kaum!  Ein Affenmensch mit einer Zersetzungsgranate wird den ‚ÄûAusgie√üer‚Äú in einen Dekanter, ein Glas, Gie√übetreiber, einen Wasserversorgungsdienst, ein physikalisches Modell einer Kollision von Molek√ºlen zerdr√ºcken und im n√§chsten Quartal versuchen, die Abh√§ngigkeiten ohne globale Variablen zu entr√§tseln.  Und glauben Sie mir - er wird nicht aufh√∂ren. </p><br><p>  An diesem Punkt kommen viele zu dem Schluss, dass SRPs Geschichten aus den rosa K√∂nigreichen sind, und lassen die Nudeln verdrehen ... </p><br><p>  ... nie √ºber die Existenz der dritten Definition von Srp Bescheid wissen: </p><br><p>  " <strong>Dinge, die Ver√§nderungen √§hneln, sollten an einem Ort aufbewahrt werden</strong> ."  oder " <strong>Was sich gemeinsam √§ndert, muss an einem Ort aufbewahrt werden</strong> " </p><br><p>  Das hei√üt, wenn wir die Operationsprotokollierung √§ndern, m√ºssen wir sie an <strong>einer</strong> Stelle √§ndern. </p><br><p>  Dies ist ein sehr wichtiger Punkt - da alle oben genannten SRP-Erkl√§rungen besagten, dass Typen geteilt werden sollten, w√§hrend sie geteilt werden, dh die Gr√∂√üe des Objekts einer ‚Äûobersten Beschr√§nkung‚Äú unterworfen sind, und jetzt von einer ‚Äûunteren Grenze‚Äú sprechen. .  Mit anderen Worten, <strong>SRP erfordert nicht nur "Quetschen w√§hrend des Quetschens", sondern auch keine √úbertreibung - "Quetschen Sie keine verkn√ºpften Dinge".</strong>  Komplizieren Sie nicht unn√∂tig.  Dies ist die gro√üe Schlacht von Occams Rasiermesser mit dem Affenmann! </p><br><div style="text-align:center;"><img width="400" src="https://habrastorage.org/getpro/habr/post_images/778/0d3/aa2/7780d3aa2ce9b489696c55ea792adb3a.jpg" alt="Bild"></div><br><p>  Jetzt sollte der Alkohol leichter sein.  Wir k√∂nnen den IPourLogger-Logger nicht nur in drei Klassen aufteilen, sondern auch alle Logger zu einem Typ zusammenfassen: </p><br><pre> <code class="plaintext hljs">class OperationLogger{ public OperationLogger(string operationName){/*..*/} public void LogBefore(object[] args){/*...*/} public void LogAfter(object[] args){/*..*/} public void LogError(object[] args, exception e){/*..*/} }</code> </pre> <br><p>  Und wenn uns die vierte Art von Operation hinzugef√ºgt wird, ist die Protokollierung daf√ºr bereit.  Und der Code der Operationen selbst ist sauber und frei von Infrastrukturl√§rm. </p><br><p>  Als Ergebnis haben wir 5 Klassen zur L√∂sung des Trinkproblems: </p><br><ul><li>  Gie√üvorgang </li><li>  Getr√§nkebetrieb </li><li>  Staubetrieb </li><li>  Logger </li><li>  Fassade der Booler </li></ul><br><p>  Jeder von ihnen ist streng f√ºr eine Funktionalit√§t verantwortlich, hat einen Grund f√ºr √Ñnderungen.  Alle Regeln, die √Ñnderungen √§hneln, liegen in der N√§he. </p><br><h2 id="primery-iz-realnoy-zhizni">  Beispiele aus dem wirklichen Leben </h2><br><div class="spoiler">  <b class="spoiler_title">Serialisierung und Deserialisierung</b> <div class="spoiler_text"><p>  Im Rahmen der Entwicklung des Daten√ºbertragungsprotokolls ist es erforderlich, eine Art "Benutzer" zu einer Zeichenfolge zu serialisieren und zu deserialisieren. </p><br><pre> <code class="plaintext hljs">User{ String Name; Int Age; }</code> </pre> <br><p>  Sie k√∂nnten denken, dass Serialisierung und Deserialisierung in getrennten Klassen durchgef√ºhrt werden m√ºssen: </p><br><pre> <code class="plaintext hljs">UserDeserializer{ String deserialize(User){...} } UserSerializer{ User serialize(String){...} }</code> </pre> <br><p>  Da jeder von ihnen seine eigene Verantwortung und einen Grund f√ºr Ver√§nderungen hat. </p><br><p>  Sie haben jedoch einen gemeinsamen Grund f√ºr √Ñnderungen: "√Ñndern des Formats der Datenserialisierung". <br>  Und wenn Sie dieses Format √§ndern, √§ndern sich Serialisierung und Deserialisierung immer. </p><br><p>  Nach dem Prinzip der Lokalisierung von √Ñnderungen m√ºssen wir sie zu einer Klasse zusammenfassen: </p><br><pre> <code class="plaintext hljs">UserSerializer{ String deserialize(User){...} User serialize(String){...} }</code> </pre> <br><p>  Dies erspart uns unn√∂tige Komplexit√§t und die Notwendigkeit, sich daran zu erinnern, dass Sie sich bei jedem Wechsel des Serializers an den Deserializer erinnern m√ºssen. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Z√§hlen und speichern</b> <div class="spoiler_text"><p>  Sie m√ºssen den Jahresumsatz des Unternehmens berechnen und in der Datei C: \ results.txt speichern. </p><br><p>  Wir l√∂sen dies schnell mit einer Methode: </p><br><pre> <code class="plaintext hljs">void SaveGain(Company company){ //     //   }</code> </pre> <br><p>  Bereits aus der Definition der Aufgabe geht hervor, dass es zwei Unteraufgaben gibt - "Umsatz berechnen" und "Umsatz sparen".  Jeder von ihnen hat einen Grund f√ºr √Ñnderungen - "eine √Ñnderung der Berechnungsmethode" und "eine √Ñnderung des Speicherformats".  Diese √Ñnderungen √ºberschneiden sich nicht.  Au√üerdem k√∂nnen wir die Frage ‚ÄûWas macht die SaveGain-Methode?‚Äú Nicht einsilbig beantworten.  Diese <strong>AND-</strong> Methode berechnet den Umsatz <strong>UND</strong> speichert die Ergebnisse. </p><br><p>  Daher m√ºssen Sie diese Methode in zwei Teile teilen: </p><br><pre> <code class="plaintext hljs">Gain CalcGain(Company company){..} void SaveGain(Gain gain){..}</code> </pre> <br><p>  Vorteile: </p><br><ul><li>  kann separat getestet werden CalcGain </li><li>  Es ist einfacher, Fehler zu lokalisieren und √Ñnderungen vorzunehmen </li><li>  Die Lesbarkeit des Codes wurde erh√∂ht </li><li>  Das Fehlerrisiko bei jeder der Methoden wird aufgrund ihrer Vereinfachung verringert </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Anspruchsvolle Gesch√§ftslogik</b> <div class="spoiler_text"><p>  Einmal haben wir einen Service f√ºr die automatische Registrierung eines B2B-Clients geschrieben.  Und es gab eine GOTT-Methode mit 200 Zeilen √§hnlichen Inhalts: </p><br><ul><li>  Gehen Sie zu 1C und erstellen Sie ein Konto </li><li>  Gehen Sie mit diesem Konto zum Zahlungsmodul und rufen Sie es dort auf </li><li>  Stellen Sie sicher, dass auf dem Hauptserver kein Konto mit einem solchen Konto erstellt wurde </li><li>  Erstellen Sie ein neues Konto </li><li>  Das Registrierungsergebnis im Zahlungsmodul und die Nummer 1c werden dem Registrierungsergebnisdienst hinzugef√ºgt </li><li>  F√ºgen Sie dieser Tabelle Kontoinformationen hinzu </li><li>  Erstellen Sie im Punktedienst eine Punktnummer f√ºr diesen Kunden.  Geben Sie diesem Dienstkonto die Nummer 1s. </li></ul><br><p>  Es gab ungef√§hr 10 weitere Gesch√§ftsvorg√§nge mit schrecklicher Verbundenheit auf dieser Liste.  Das Kontoobjekt wurde von fast allen ben√∂tigt.  Punkt-ID und Client-Name wurden in der H√§lfte der Anrufe ben√∂tigt. </p><br><p>  Nach einer Stunde Refactoring konnten wir den Infrastrukturcode und einige Nuancen der Arbeit mit dem Konto in separate Methoden / Klassen unterteilen.  Die Gott-Methode wurde einfacher, aber es waren noch 100 Codezeilen √ºbrig, die nicht entwirrt werden wollten. </p><br><p>  Nur wenige Tage sp√§ter kam das Verst√§ndnis, dass das Wesentliche dieser "erleichterten" Methode der Gesch√§ftsalgorithmus ist.  Und dass die anf√§ngliche Beschreibung von TK ziemlich kompliziert war.  Und es ist ein Versuch, diese Methode in Teile zu zerlegen, die eine Verletzung von SRP darstellen, und nicht umgekehrt. </p></div></div><br><h2 id="formalizm">  Formalismus. </h2><br><p>  Es ist Zeit, unseren Alkohol in Ruhe zu lassen.  Wischen Sie die Tr√§nen weg - wir werden auf jeden Fall irgendwie darauf zur√ºckkommen.  Jetzt formalisieren wir das Wissen aus diesem Artikel. </p><br><h4 id="formalizm-1-opredelenie-srp">  Formalismus 1. Definition von SRP </h4><br><ol><li>  Trennen Sie die Elemente so, dass jedes f√ºr eine Sache verantwortlich ist. </li><li>  Verantwortung steht f√ºr ‚ÄûGrund zur Ver√§nderung‚Äú.  Das hei√üt, jedes Element hat nur einen Grund f√ºr √Ñnderungen in Bezug auf die Gesch√§ftslogik. </li><li>  M√∂gliche √Ñnderungen der Gesch√§ftslogik.  muss lokalisiert werden.  Elemente, die zusammen ver√§nderlich sind, m√ºssen in der N√§he sein. </li></ol><br><h4 id="formalizm-2-neobhodimye-kriterii-samoproverki">  Formalismus 2. Notwendige Kriterien f√ºr die Selbstpr√ºfung. </h4><br><p>  Ich habe nicht gen√ºgend Kriterien f√ºr die Implementierung von SRP erf√ºllt.  Aber es gibt notwendige Bedingungen: </p><br><p>  1) Stellen Sie sich eine Frage - was macht diese Klasse / Methode / Modul / Dienst.  Sie m√ºssen es mit einer einfachen Definition beantworten.  (danke an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Brightori</a> ) </p><br><div class="spoiler">  <b class="spoiler_title">Erkl√§rungen</b> <div class="spoiler_text"><p>  Manchmal ist es jedoch sehr schwierig, eine einfache Definition zu finden </p></div></div><br><p>  2) Das Beheben eines Fehlers oder das Hinzuf√ºgen einer neuen Funktion wirkt sich auf die Mindestanzahl von Dateien / Klassen aus.  Im Idealfall eine. </p><br><div class="spoiler">  <b class="spoiler_title">Erkl√§rungen</b> <div class="spoiler_text"><p>  Da die Verantwortung (f√ºr ein Feature oder einen Fehler) in einer einzelnen Datei / Klasse zusammengefasst ist, wissen Sie genau, wo Sie suchen und was Sie bearbeiten m√ºssen.  Beispiel: F√ºr die Funktion zum √Ñndern der Ausgabe der Operationsprotokollierung muss nur der Logger ge√§ndert werden.  Das Ausf√ºhren des restlichen Codes ist nicht erforderlich. </p><br><p>  Ein weiteres Beispiel ist das Hinzuf√ºgen eines neuen UI-Steuerelements √§hnlich den vorherigen.  Wenn Sie dadurch gezwungen werden, 10 verschiedene Entit√§ten und 15 verschiedene Konverter hinzuzuf√ºgen, haben Sie anscheinend "kaputt". </p></div></div><br><p>  3) Wenn mehrere Entwickler an unterschiedlichen Funktionen Ihres Projekts arbeiten, ist die Wahrscheinlichkeit eines Zusammenf√ºhrungskonflikts, dh die Wahrscheinlichkeit, dass mehrere Entwickler dieselbe Datei / Klasse gleichzeitig √§ndern, minimal. </p><br><div class="spoiler">  <b class="spoiler_title">Erkl√§rungen</b> <div class="spoiler_text"><p>  Wenn Sie beim Hinzuf√ºgen einer neuen Operation "Wodka unter den Tisch gie√üen" den Logger ber√ºhren m√ºssen, die Operation des Trinkens und Gie√üens, dann sieht es so aus, als ob die Verantwortlichkeiten schief sind.  Dies ist nat√ºrlich nicht immer m√∂glich, aber Sie m√ºssen versuchen, diese Zahl zu reduzieren. </p></div></div><br><p>  4) Wenn Sie eine Frage zur Gesch√§ftslogik (von einem Entwickler oder Manager) kl√§ren, klettern Sie streng in eine Klasse / Datei und erhalten nur von dort Informationen. </p><br><div class="spoiler">  <b class="spoiler_title">Erkl√§rungen</b> <div class="spoiler_text"><p>  Features, Regeln oder Algorithmen werden kompakt an einer Stelle geschrieben und nicht durch Flags im gesamten Codebereich verteilt. </p></div></div><br><p>  5) Die Benennung ist klar. </p><br><div class="spoiler">  <b class="spoiler_title">Erkl√§rungen</b> <div class="spoiler_text"><p>  Unsere Klasse oder Methode ist f√ºr eine Sache verantwortlich, und die Verantwortung spiegelt sich in ihrem Namen wider. </p><br><p>  AllManagersManagerService - h√∂chstwahrscheinlich Gottklasse <br>  LocalPayment - wahrscheinlich nicht </p></div></div><br><h4 id="formalizm-3-metodika-razrabotki-okkama-first">  Formalismus 3. Die Entwicklungsmethode von Occam-first. </h4><br><p>  Zu Beginn des Entwurfs kennt und sp√ºrt der Affenmensch nicht alle Feinheiten des zu l√∂senden Problems und kann einen Fehler verursachen.  Sie k√∂nnen Fehler auf verschiedene Arten machen: </p><br><ul><li>  Machen Sie Objekte zu gro√ü, indem Sie unterschiedliche Verantwortlichkeiten festlegen </li><li>  Teilen Sie eine einzelne Verantwortung in viele verschiedene Typen auf </li><li>  Falsch definierte Verantwortungsgrenzen </li></ul><br><p>  Es ist wichtig, sich an die Regel zu erinnern: "Es ist besser, einen gro√üen Fehler zu machen" oder "nicht sicher - nicht trennen".  Wenn Ihre Klasse beispielsweise zwei Verantwortlichkeiten sammelt, ist dies immer noch verst√§ndlich und kann mit einer minimalen √Ñnderung des Client-Codes in zwei Teile aufgeteilt werden.  Das Sammeln eines Glases aus Glasfragmenten ist aufgrund des √ºber mehrere Dateien verteilten Kontexts und des Fehlens notwendiger Abh√§ngigkeiten im Clientcode normalerweise schwieriger. </p><br><h2 id="pora-zakruglyatsya">  Es ist Zeit abzurunden </h2><br><p>  Der Umfang von SRP ist nicht auf OOP und SOLID beschr√§nkt.  Es gilt f√ºr Methoden, Funktionen, Klassen, Module, Microservices und Services.  Es gilt sowohl f√ºr die Entwicklung von ‚Äûfigax-figax-and-in-prod‚Äú als auch f√ºr ‚Äûrocket-sainz‚Äú, wodurch die Welt √ºberall ein wenig besser wird.  Wenn Sie dar√ºber nachdenken, ist dies fast das Grundprinzip aller Technik.  Maschinenbau, Steuerungssysteme und in der Tat alle komplexen Systeme bestehen aus Komponenten, und die ‚Äûunvollst√§ndige Fragmentierung‚Äú beraubt die Konstrukteure der Flexibilit√§t, der ‚ÄûFragmentierung‚Äú - der Effizienz und der falschen Grenzen - der Vernunft und des Seelenfriedens. </p><br><div style="text-align:center;"><img width="450" src="https://habrastorage.org/getpro/habr/post_images/5a4/13a/5ec/5a413a5ec8447752d1de83982a0fadea.jpg" alt="Bild"></div><br><p>  SRP ist nicht von Natur aus erfunden und nicht Teil der exakten Wissenschaft.  Es kriecht aus unseren biologischen und psychologischen Grenzen heraus. Dies ist nur eine M√∂glichkeit, komplexe Systeme mithilfe des Gehirns eines menschlichen Affen zu steuern und zu entwickeln.  Er sagt uns, wie wir das System zerlegen sollen.  Der urspr√ºngliche Wortlaut erforderte einiges an Telepathie, aber ich hoffe, dieser Artikel hat die Nebelwand leicht zerstreut. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454290/">https://habr.com/ru/post/de454290/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454272/index.html">Die ganze Wahrheit √ºber RTOS. Artikel 27. Systemzeit</a></li>
<li><a href="../de454274/index.html">Licht, Kamera ... Wolke: Wie Wolken die Filmindustrie ver√§ndern</a></li>
<li><a href="../de454278/index.html">Cyberversicherung auf dem russischen Markt</a></li>
<li><a href="../de454280/index.html">Fernentwicklung in VS Code: Ihr Leben wird niemals das gleiche sein</a></li>
<li><a href="../de454284/index.html">Entschuldigung, ich werde nicht zur Arbeit kommen, weil es Winter ist</a></li>
<li><a href="../de454292/index.html">JS. Proxy. Fallstricke zu wissen</a></li>
<li><a href="../de454294/index.html">"Ohne unn√∂tige Experimente" oder wie wir einen Bankbeschleuniger auf den Markt gebracht haben</a></li>
<li><a href="../de454296/index.html">Wie eine Schule in Puerto Rico mit Minecraft Chemie zum Leben erweckt: Education Edition</a></li>
<li><a href="../de454298/index.html">The Standoff: wie es war</a></li>
<li><a href="../de454300/index.html">Wie unterscheiden sich CTTs von herk√∂mmlichen Heatpipes und wie werden sie angewendet?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>