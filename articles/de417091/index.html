<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úÇÔ∏è üë®üèº‚Äçüåæ üì™ Erstellen Sie einen Cartoon-Water-Shader f√ºr das Web. Teil 3 üòê üç™ ‚òÅÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im zweiten Teil haben wir Auftriebs- und Schaumlinien untersucht. In diesem letzten Teil wenden wir Unterwasserverzerrungen als Nachbearbeitungseffekt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen Sie einen Cartoon-Water-Shader f√ºr das Web. Teil 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417091/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbd/a8e/0b0/bbda8e0b0fe175450f789f2a7ec94304.gif" alt="Bild"></div><br>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">zweiten Teil haben</a> wir Auftriebs- und Schaumlinien untersucht.  In diesem letzten Teil wenden wir Unterwasserverzerrungen als Nachbearbeitungseffekt an. <br><br><h2>  Brechungs- und Nachbearbeitungseffekte </h2><br>  Unser Ziel ist es, die Lichtbrechung im Wasser visuell zu vermitteln.  Wir haben bereits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">dar√ºber gesprochen,</a> wie diese Art von Verzerrung in einem Fragment-Shader f√ºr eine 2D-Szene erzeugt werden kann.  Hier besteht der einzige Unterschied darin, dass wir verstehen m√ºssen, welcher Bereich des Bildschirms sich unter Wasser befindet, und nur Verzerrungen anwenden m√ºssen. <br><br><h3>  Nachbearbeitung </h3><br>  Im allgemeinen Fall ist der Nachbearbeitungseffekt ein Effekt, der nach dem Rendern auf die gesamte Szene angewendet wird, z. B. Farbt√∂ne oder der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">Effekt eines alten CRT-Bildschirms</a> .  Anstatt die Szene direkt auf dem Bildschirm zu rendern, rendern wir sie zuerst in den Puffer oder in die Textur, und dann rendern wir die Szene durch unseren Shader auf den Bildschirm. <br><a name="habracut"></a><br>  In PlayCanvas k√∂nnen Sie diesen Nachbearbeitungseffekt anpassen, indem Sie ein neues Skript erstellen.  Nennen wir es <strong>Refraction.js</strong> und kopieren Sie diese Vorlage als Leerzeichen hinein: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//---------------   ------------------------// pc.extend(pc, function () { //  -      var RefractionPostEffect = function (graphicsDevice, vs, fs, buffer) { var fragmentShader = "precision " + graphicsDevice.precision + " float;\n"; fragmentShader = fragmentShader + fs; //      this.shader = new pc.Shader(graphicsDevice, { attributes: { aPosition: pc.SEMANTIC_POSITION }, vshader: vs, fshader: fs }); this.buffer = buffer; }; //      pc.PostEffect RefractionPostEffect = pc.inherits(RefractionPostEffect, pc.PostEffect); RefractionPostEffect.prototype = pc.extend(RefractionPostEffect.prototype, { //      render, //    ,    , //       render: function (inputTarget, outputTarget, rect) { var device = this.device; var scope = device.scope; //       .  ,     scope.resolve("uColorBuffer").setValue(inputTarget.colorBuffer); //       .       . //          pc.drawFullscreenQuad(device, outputTarget, this.vertexBuffer, this.shader, rect); } }); return { RefractionPostEffect: RefractionPostEffect }; }()); //---------------  ------------------------// var Refraction = pc.createScript('refraction'); Refraction.attributes.add('vs', { type: 'asset', assetType: 'shader', title: 'Vertex Shader' }); Refraction.attributes.add('fs', { type: 'asset', assetType: 'shader', title: 'Fragment Shader' }); //  initialize       Refraction.prototype.initialize = function() { var effect = new pc.RefractionPostEffect(this.app.graphicsDevice, this.vs.resource, this.fs.resource); //     postEffects var queue = this.entity.camera.postEffects; queue.addEffect(effect); this.effect = effect; //       this.savedVS = this.vs.resource; this.savedFS = this.fs.resource; }; Refraction.prototype.update = function(){ if(this.savedFS != this.fs.resource || this.savedVS != this.vs.resource){ this.swap(this); } }; Refraction.prototype.swap = function(old){ this.entity.camera.postEffects.removeEffect(old.effect); this.initialize(); };</span></span></code> </pre> <br>  Dies √§hnelt einem normalen Skript, wir definieren jedoch eine <code>RefractionPostEffect</code> Klasse, die auf die Kamera angewendet werden kann.  Zum Rendern werden Vertex- und Fragment-Shader ben√∂tigt.  Die Attribute sind bereits konfiguriert. Erstellen Sie daher <strong>Refraction.frag</strong> mit den folgenden Inhalten: <br><br><pre> <code class="javascript hljs">precision highp float; uniform sampler2D uColorBuffer; varying vec2 vUv0; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main() { vec4 color = texture2D(uColorBuffer, vUv0); gl_FragColor = color; }</code> </pre> <br>  Und <strong>Refraction.vert</strong> mit einem einfachen Vertex-Shader: <br><br><pre> <code class="javascript hljs">attribute vec2 aPosition; varying vec2 vUv0; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { gl_Position = vec4(aPosition, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); vUv0 = (aPosition.xy + <span class="hljs-number"><span class="hljs-number">1.0</span></span>) * <span class="hljs-number"><span class="hljs-number">0.5</span></span>; }</code> </pre> <br>  H√§ngen Sie nun das Skript <strong>Refraction.js</strong> an die Kamera an und weisen Sie den Shadern die entsprechenden Attribute zu.  Wenn Sie das Spiel starten, sehen Sie die Szene auf die gleiche Weise wie zuvor.  Dies ist ein leerer Post-Effekt, der die Szene einfach neu rendert.  Um sicherzustellen, dass es funktioniert, versuchen wir, der Szene einen roten Farbton zu geben. <br><br>  Versuchen Sie, die rote Komponente auf 1.0 zu setzen, anstatt die Farbe einfach auf Refraction.frag zur√ºckzugeben. Dadurch sollte das Bild das unten gezeigte Bild erhalten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/981/b78/937/981b78937b536280aeacdb3ef8c33897.png"></div><br><h3>  Verzerrungs-Shader </h3><br>  Um eine animierte Verzerrung zu erstellen, m√ºssen wir eine einheitliche Zeitvariable hinzuf√ºgen. Erstellen wir sie also in diesem Post-Effekt-Konstruktor in Refraction.js: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> RefractionPostEffect = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">graphicsDevice, vs, fs</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fragmentShader = <span class="hljs-string"><span class="hljs-string">"precision "</span></span> + graphicsDevice.precision + <span class="hljs-string"><span class="hljs-string">" float;\n"</span></span>; fragmentShader = fragmentShader + fs; <span class="hljs-comment"><span class="hljs-comment">//       this.shader = new pc.Shader(graphicsDevice, { attributes: { aPosition: pc.SEMANTIC_POSITION }, vshader: vs, fshader: fs }); // &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    this.time = 0; };</span></span></code> </pre> <br>  Jetzt √ºbergeben wir es innerhalb der Renderfunktion an unseren Shader, um es zu erh√∂hen: <br><br><pre> <code class="javascript hljs">RefractionPostEffect.prototype = pc.extend(RefractionPostEffect.prototype, { <span class="hljs-comment"><span class="hljs-comment">//      render, //      , //       render: function (inputTarget, outputTarget, rect) { var device = this.device; var scope = device.scope; //       .  ,     scope.resolve("uColorBuffer").setValue(inputTarget.colorBuffer); /// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    uniform-  scope.resolve("uTime").setValue(this.time); this.time += 0.1; //       .       . //          pc.drawFullscreenQuad(device, outputTarget, this.vertexBuffer, this.shader, rect); } });</span></span></code> </pre> <br>  Jetzt k√∂nnen wir denselben Shader-Code aus dem Tutorial zur Wasserverzerrung verwenden und unseren vollst√§ndigen Fragment-Shader wie folgt umwandeln: <br><br><pre> <code class="javascript hljs">precision highp float; uniform sampler2D uColorBuffer; uniform float uTime; varying vec2 vUv0; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main() { vec2 pos = vUv0; float X = pos.x*<span class="hljs-number"><span class="hljs-number">15.</span></span>+uTime*<span class="hljs-number"><span class="hljs-number">0.5</span></span>; float Y = pos.y*<span class="hljs-number"><span class="hljs-number">15.</span></span>+uTime*<span class="hljs-number"><span class="hljs-number">0.5</span></span>; pos.y += cos(X+Y)*<span class="hljs-number"><span class="hljs-number">0.01</span></span>*cos(Y); pos.x += sin(XY)*<span class="hljs-number"><span class="hljs-number">0.01</span></span>*sin(Y); vec4 color = texture2D(uColorBuffer, pos); gl_FragColor = color; }</code> </pre> <br>  Wenn alles richtig gemacht ist, sollte das ganze Bild so aussehen, als ob es vollst√§ndig unter Wasser w√§re. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbd/a8e/0b0/bbda8e0b0fe175450f789f2a7ec94304.gif"></div><br><blockquote>  <em>Aufgabe 1: Stellen Sie sicher, dass die Verzerrung nur am unteren Bildschirmrand auftritt.</em> </blockquote><br><h3>  Kameramasken </h3><br>  Wir sind fast fertig.  Es bleibt uns √ºberlassen, diesen Verzerrungseffekt auf den Unterwasserteil des Bildschirms anzuwenden.  Der einfachste Weg, an den ich gedacht habe, besteht darin, die Szene mit der Oberfl√§che des Wasser-Renderings in festem Wei√ü neu zu rendern, wie in der folgenden Abbildung gezeigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41e/06f/284/41e06f284290afbf768f6f615360c8bf.png"></div><br>  Es wird in die Textur gerendert, die wir als Maske verwenden.  Dann √ºbertragen wir diese Textur auf unseren Refraktions-Shader, der das Pixel im fertigen Bild nur dann verzerrt, wenn das entsprechende Pixel in der Maske wei√ü ist. <br><br>  F√ºgen wir der Wasseroberfl√§che ein boolesches Attribut hinzu, um festzustellen, ob es als Maske verwendet wird.  F√ºgen Sie Water.js Folgendes hinzu: <br><br><pre> <code class="javascript hljs">Water.attributes.add(<span class="hljs-string"><span class="hljs-string">'isMask'</span></span>, {<span class="hljs-attr"><span class="hljs-attr">type</span></span>:<span class="hljs-string"><span class="hljs-string">'boolean'</span></span>,<span class="hljs-attr"><span class="hljs-attr">title</span></span>:<span class="hljs-string"><span class="hljs-string">"Is Mask?"</span></span>});</code> </pre> <br>  Dann k√∂nnen wir es wie √ºblich mit <code>material.setParameter('isMask',this.isMask);</code> an den Shader <code>material.setParameter('isMask',this.isMask);</code>  .  Deklarieren Sie es dann in Water.frag und f√§rben Sie das Pixel wei√ü, wenn das Attribut wahr ist. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    uniform uniform bool isMask; //      ,    //    true if(isMask){ color = vec4(1.0); }</span></span></code> </pre> <br>  Stellen Sie sicher, dass dies funktioniert, indem Sie die Eigenschaft "Ist Maske?" Aktivieren.  im Editor und Neustart des Spiels.  Es sollte wei√ü aussehen, wie im Bild oben. <br><br>  Um die Szene neu zu rendern, ben√∂tigen wir eine zweite Kamera.  Erstellen Sie im Editor eine neue Kamera und nennen Sie sie <strong>CameraMask</strong> .  Wir duplizieren auch die Water-Entit√§t im Editor und benennen die doppelte <strong>WaterMask</strong> .  Stellen Sie sicher, dass f√ºr die Entit√§t "Wasser ist Maske?"  ist falsch und WaterMask ist wahr. <br><br>  Erstellen Sie ein neues <strong>CameraMask.js-</strong> Skript und h√§ngen Sie es an die neue Kamera an, damit eine neue Kamera nicht auf einem Bildschirm, sondern auf einer Textur <strong>gerendert wird</strong> .  Wir erstellen ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">RenderTarget</a> , um die Ausgabe dieser Kamera zu erfassen: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  initialize       CameraMask.prototype.initialize = function() { //  512x512x24-      var colorBuffer = new pc.Texture(this.app.graphicsDevice, { width: 512, height: 512, format: pc.PIXELFORMAT_R8_G8_B8, autoMipmap: true }); colorBuffer.minFilter = pc.FILTER_LINEAR; colorBuffer.magFilter = pc.FILTER_LINEAR; var renderTarget = new pc.RenderTarget(this.app.graphicsDevice, colorBuffer, { depth: true }); this.entity.camera.renderTarget = renderTarget; };</span></span></code> </pre> <br>  Nachdem Sie die Anwendung gestartet haben, werden Sie feststellen, dass diese Kamera nicht mehr auf dem Bildschirm angezeigt wird.  Wir k√∂nnen die Ausgabe des Ziel-Renderings in <strong>Refraction.js</strong> wie folgt <strong>abrufen</strong> : <br><br><pre> <code class="javascript hljs">Refraction.prototype.initialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cameraMask = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.app.root.findByName(<span class="hljs-string"><span class="hljs-string">'CameraMask'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskBuffer = cameraMask.camera.renderTarget.colorBuffer; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> effect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> pc.RefractionPostEffect(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.app.graphicsDevice, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.vs.resource, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fs.resource, maskBuffer); <span class="hljs-comment"><span class="hljs-comment">// ... //     ,    };</span></span></code> </pre> <br>  Beachten Sie, dass ich diese Maskentextur als Argument an den Post-Effekt-Konstruktor √ºbergebe.  Wir m√ºssen in unserem Konstruktor einen Link dazu erstellen, damit es so aussieht: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">////       var RefractionPostEffect = function (graphicsDevice, vs, fs, buffer) { var fragmentShader = "precision " + graphicsDevice.precision + " float;\n"; fragmentShader = fragmentShader + fs; //       this.shader = new pc.Shader(graphicsDevice, { attributes: { aPosition: pc.SEMANTIC_POSITION }, vshader: vs, fshader: fs }); this.time = 0; //// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;    this.buffer = buffer; };</span></span></code> </pre> <br>  Schlie√ülich √ºbergeben wir in der Renderfunktion den Puffer an unseren Shader: <br><br><pre> <code class="javascript hljs">scope.resolve(<span class="hljs-string"><span class="hljs-string">"uMaskBuffer"</span></span>).setValue(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buffer);</code> </pre> <br>  Um sicherzustellen, dass dies alles funktioniert, √ºberlasse ich es Ihnen als Aufgabe. <br><br><blockquote>  Aufgabe 2: Rendern Sie den uMaskBuffer auf dem Bildschirm, um sicherzustellen, dass er die Ausgabe der zweiten Kamera ist. </blockquote><br>  Folgendes sollte ber√ºcksichtigt werden: Das Ziel-Rendering wird bei der Initialisierung des Skripts CameraMask.js konfiguriert und sollte zum Zeitpunkt des Aufrufs von Refraction.js bereit sein.  Wenn die Skripte anders funktionieren, erhalten wir eine Fehlermeldung.  Um sicherzustellen, dass sie in der richtigen Reihenfolge funktionieren, ziehen Sie CameraMask wie unten gezeigt an den Anfang der Entit√§tsliste im Editor. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d8/093/747/2d80937472cd112108f303959c35d4c1.png"></div><br>  Die zweite Kamera sollte immer mit der gleichen Ansicht wie die urspr√ºngliche aussehen. Lassen Sie sie daher immer der Position und Drehung des Skripts CameraMask.js im Update folgen: <br><br><pre> <code class="javascript hljs">CameraMask.prototype.update = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dt</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pos = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.CameraToFollow.getPosition(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rot = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.CameraToFollow.getRotation(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.setPosition(pos.x,pos.y,pos.z); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.setRotation(rot); };</code> </pre> <br>  Definieren <code>CameraToFollow</code> Initialisieren <code>CameraToFollow</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.CameraToFollow = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.app.root.findByName(<span class="hljs-string"><span class="hljs-string">'Camera'</span></span>);</code> </pre> <br><h3>  Schnittmasken </h3><br>  Beide Kameras rendern jetzt dasselbe.  Wir m√∂chten, dass die Maskenkamera alles au√üer echtem Wasser rendert und die echte Kamera alles au√üer Maskenwasser rendert. <br><br>  Dazu k√∂nnen wir die Bit-Clipping-Maske der Kamera verwenden.  Es funktioniert √§hnlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">wie Kollisionsmasken</a> .  Ein Objekt wird abgeschnitten (d. H. Nicht gerendert), wenn das Ergebnis des bitweisen <code>AND</code> zwischen seiner Maske und der Kameramaske 1 ist. <br><br>  Angenommen, Wasser hat Bit 2, WaterMask hat Bit 3. Alle Bits au√üer 3 sollten f√ºr eine echte Kamera und alle Bits au√üer 2 f√ºr eine Maskenkamera gesetzt werden. Der einfachste Weg, ‚Äûalle Bits au√üer N‚Äú zu sagen, ist wie folgt Weg: <br><br><pre> <code class="javascript hljs">~(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; N) &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Lesen Sie hier mehr √ºber bitweise Operationen. <br><br>  Um Kamera-Clipping-Masken zu konfigurieren, k√∂nnen Sie am Ende der Initialisierung des <strong>CameraMask.js-</strong> Skripts Folgendes <strong>einf√ºgen</strong> : <br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//   ,  2 this.entity.camera.camera.cullingMask &amp;= ~(1 &lt;&lt; 2) &gt;&gt;&gt; 0; //   ,  3 this.CameraToFollow.camera.camera.cullingMask &amp;= ~(1 &lt;&lt; 3) &gt;&gt;&gt; 0; //      ,   : // console.log((this.CameraToFollow.camera.camera.cullingMask &gt;&gt;&gt; 0).toString(2));</span></span></code> </pre> <br>  Jetzt setzen wir in Water.js Bit 2 der Maske des Wassernetzes und die Maskenversion davon auf Bit 3: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      initialize  Water.js //    var bit = this.isMask ? 3 : 2; meshInstance.mask = 0; meshInstance.mask |= (1 &lt;&lt; bit);</span></span></code> </pre> <br>  Jetzt wird eine Art mit klarem Wasser und die zweite mit festem Wei√üwasser sein.  Das Bild links zeigt die Ansicht der Originalkamera und rechts die Ansicht der Maskenkamera. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d55/e1b/271/d55e1b271351df16edab549ca065837f.png"></div><br><h3>  Maskenapplikation </h3><br>  Und jetzt der letzte Schritt!  Wir wissen, dass Unterwasserbereiche mit wei√üen Pixeln markiert sind.  Wir m√ºssen nur √ºberpr√ºfen, ob wir uns in einem wei√üen Pixel befinden. Wenn nicht, deaktivieren Sie die Verzerrung in <strong>Refraction.frag</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,      vec4 maskColor = texture2D(uMaskBuffer, pos); vec4 maskColor2 = texture2D(uMaskBuffer, vUv0); //     ? if(maskColor != vec4(1.0) || maskColor2 != vec4(1.0)){ //      pos = vUv0; }</span></span></code> </pre> <br>  Und das sollte unser Problem l√∂sen! <br><br>  <em>Es ist auch erw√§hnenswert, dass die Textur f√ºr die Maske beim Start initialisiert wird und beim √Ñndern der Fenstergr√∂√üe zur Laufzeit nicht mehr der Bildschirmgr√∂√üe entspricht.</em> <br><br><h3>  Gl√§tten </h3><br>  M√∂glicherweise stellen Sie fest, dass die R√§nder der Szene jetzt etwas scharf aussehen.  Dies geschah, weil wir nach dem Anwenden des Nacheffekts die Gl√§ttung verloren haben. <br><br>  Als weiteren Nacheffekt k√∂nnen wir zus√§tzlich zu unserem Effekt eine zus√§tzliche Gl√§ttung anwenden.  Gl√ºcklicherweise gibt es im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">PlayCanvas-Store eine</a> weitere Variable, die wir verwenden k√∂nnen.  Gehen Sie zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">Seite</a> mit den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">Skript-Assets</a> , klicken Sie auf die gro√üe gr√ºne Schaltfl√§che zum Herunterladen und w√§hlen Sie Ihr Projekt aus der angezeigten Liste aus.  Das Skript wird im Stammverzeichnis des Assets-Fensters als <strong>posteffect-fxaa.js angezeigt</strong> .  H√§ngen Sie es einfach an die Kamera-Entit√§t an und Ihre Szene wird viel besser aussehen! <br><br><h2>  Gedanken zum Schluss </h2><br>  Wenn Sie hierher kommen, k√∂nnen Sie sich selbst loben!  In diesem Tutorial haben wir einige Techniken behandelt.  Jetzt m√ºssen Sie sich sicher f√ºhlen, wenn Sie mit Vertex-Shadern arbeiten, Texturen rendern, Nachbearbeitungseffekte anwenden, Objekte selektiv ausschneiden, den Tiefenpuffer verwenden und mit √úberblendung und Transparenz arbeiten.  Obwohl wir all dies in PlayCanvas implementiert haben, k√∂nnen Sie all diese allgemeinen Konzepte der Computergrafik in der einen oder anderen Form auf jeder Plattform erf√ºllen. <br><br>  Alle diese Techniken sind auch auf viele andere Effekte anwendbar.  Eine besonders interessante Anwendung f√ºr Vertex-Shader fand ich im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">Bericht √ºber das Abzu-Diagramm</a> , in dem Entwickler erkl√§ren, wie sie mit Vertex-Shadern Zehntausende von Fischen auf dem Bildschirm effektiv animieren. <br><br>  Jetzt haben Sie einen sch√∂nen Wassereffekt, den Sie in Ihren Spielen anwenden k√∂nnen!  Sie k√∂nnen es anpassen und Ihre eigenen Details hinzuf√ºgen.  Mit Wasser kann noch viel mehr getan werden (ich habe nicht einmal eine der Arten von Reflexionen erw√§hnt).  Im Folgenden finden Sie einige Ideen. <br><br><h4>  Ger√§uschwellen </h4><br>  Anstatt die Wellen nur mit einer Kombination aus Cosinus und Sinus zu animieren, k√∂nnen Sie die Textur so abtasten, dass die Wellen etwas nat√ºrlicher und weniger vorhersehbar aussehen. <br><br><h4>  Dynamische Schaumspuren </h4><br>  Anstelle von vollst√§ndig statischen Wasserlinien auf der Oberfl√§che k√∂nnen Sie beim Bewegen von Objekten in die Textur zeichnen, um dynamische Schaumspuren zu erzeugen.  Dies kann auf viele verschiedene Arten geschehen, so dass diese Aufgabe an sich zu einem Projekt werden kann. <br><br><h2>  Quellcode </h2><br>  Das fertige PlayCanvas-Projekt finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">hier</a> .  Unser Repository hat auch einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">Projektport unter Three.js</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417091/">https://habr.com/ru/post/de417091/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417081/index.html">Norden, Wille, Hoffnung, Land ohne Grenzen oder wie Projekte unter schwierigen sibirischen Bedingungen durchgef√ºhrt werden</a></li>
<li><a href="../de417083/index.html">Hohe Lasten der WM 2018</a></li>
<li><a href="../de417085/index.html">Browser schalten den Sound in Ihrer WebRTC-Anwendung stumm. H√∂r auf was?</a></li>
<li><a href="../de417087/index.html">HPE Digitalize 2018: Event und Live-Stream</a></li>
<li><a href="../de417089/index.html">Quantencomputer: Ein Photon, um alle zu regieren</a></li>
<li><a href="../de417093/index.html">Touch-Schalter mit Modbus: Warum werden sie ben√∂tigt und wie werden sie in einer intelligenten Wohnung angewendet?</a></li>
<li><a href="../de417097/index.html">JavaScript-Metaprogrammierung</a></li>
<li><a href="../de417099/index.html">Wie habe ich die Standard-C ++ 11-Bibliothek geschrieben oder warum ist Boost so be√§ngstigend? Kapitel 2</a></li>
<li><a href="../de417101/index.html">Definition von Ready - Was wir vergessen haben zu erz√§hlen</a></li>
<li><a href="../de417103/index.html">Spark SQL. Ein bisschen √ºber das Abfrageoptimierungsprogramm</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>