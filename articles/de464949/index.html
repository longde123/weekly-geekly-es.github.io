<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÇüèª #‚É£ üóæ Noch einmal √ºber GCD, den euklidischen Algorithmus und ein wenig √ºber die Geschichte der Algorithmen im Allgemeinen. Nat√ºrlich mit Swift-Beispielen üëàüèΩ ü§∂üèΩ ü¶Ö</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Algorithmen sind eines der zentralen Themen in der Programmierung , sie sind √ºberall (besonders in Interviews, haha). 


 (Kann man in einem solchen B...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Noch einmal √ºber GCD, den euklidischen Algorithmus und ein wenig √ºber die Geschichte der Algorithmen im Allgemeinen. Nat√ºrlich mit Swift-Beispielen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464949/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Algorithmen</a> sind eines der zentralen Themen in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Programmierung</a> , sie sind √ºberall (besonders in Interviews, haha). <br><br><img src="https://habrastorage.org/webt/_t/w8/av/_tw8avywasehzxdtkkheppkltuo.jpeg" alt="Bild"><br>  <i>(Kann man in einem solchen Beitrag auf ein Knopfakkordeon verzichten?)</i> <br><br>  Einer der bekanntesten ist der sogenannte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">euklidische Algorithmus</a> - vielleicht der h√§ufigste Weg, um den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gr√∂√üten gemeinsamen Teiler (GCD)</a> zweier nicht negativer Ganzzahlen zu finden.  Oft beginnt er auch, die relevanten Bereiche der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mathematik</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informatik</a> zu studieren (und zu lernen). <a name="habracut"></a><br><br>  Und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Donald Knuth</a> , der bekannte Autor der Abhandlung ‚ÄûDie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kunst des Programmierens</a> ‚Äú (und nicht nur), betrachtet den Algorithmus sogar als den ersten in der Geschichte (zumindest in Bezug auf moderne Definitionen).  Denn trotz der Tatsache, dass der Algorithmus vor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Euklid</a> erfunden und verwendet wurde, lebte er in den IV-III Jahrhunderten.  BC (es wurde bereits von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aristoteles erw√§hnt</a> , der ein Jahrhundert zuvor lebte), beschreibt Euklid den Prozess <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">iterativ</a> , was mit der modernen Bedeutung des Wortes √ºbereinstimmt. <br><br>  Das Wort ‚ÄûAlgorithmus‚Äú geht auf den Namen des persischen Mathematikers <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Al-Khwarizmi zur√ºck</a> , der um das VIII-IX Jahrhundert lebte.  schon AD.  Und der Beginn seiner Verwendung in einem modernen Sinne wird nur als das 20. Jahrhundert betrachtet, genauer gesagt - seine ersten Jahrzehnte, der Aufstieg der Informationstechnologie. <br><br><h2>  Euklidischer Algorithmus </h2><br>  Aus Neugier empfehle ich Ihnen, sich mit der euklidischen Beschreibung des Algorithmus in Knuths Bearbeitung vertraut zu machen.  Es ist ziemlich lang, daher unter dem Schnitt versteckt: <br><br><div class="spoiler">  <b class="spoiler_title">Beschreibung des euklidischen Algorithmus in der N√§he des Originals</b> <div class="spoiler_text"><blockquote>  <b>Angebot.</b>  Finden Sie f√ºr zwei positive ganze Zahlen ihren gr√∂√üten gemeinsamen Teiler. <br><br>  Sei A und C zwei gegebene positive ganze Zahlen;  Es ist erforderlich, ihre GCD zu finden.  Wenn die Zahl A durch C teilbar ist, ist die Zahl C ein gemeinsamer Teiler der Zahlen C und A, da sie sich selbst teilt.  Und nat√ºrlich wird es der gr√∂√üte Teiler sein, da es keine gr√∂√üere Zahl als die Zahl C gibt, die C teilt. <br><br>  Wenn C die Zahl A nicht teilt, subtrahieren wir kontinuierlich die kleinere der Zahlen A und C von der gr√∂√üeren, bis wir eine Zahl erhalten, die die vorherige subtrahierte Zahl vollst√§ndig teilt.  Dies sollte fr√ºher oder sp√§ter geschehen, denn wenn die Differenz gleich eins ist, teilt die Einheit den zuvor subtrahierten Wert. <br><br>  Nehmen wir nun an, dass E der positive Rest der Division der Zahl A durch C ist;  Sei F der positive Rest der Division von C durch E und sei F die Division von E. Da F E und E C - F teilt, teilt F auch C - F. Aber es teilt sich auch selbst, also teilt F C, und C teilt A - E;  daher teilt F auch A - E, aber es teilt auch E;  daher teilt F A. Folglich ist F ein gemeinsamer Teiler der Zahlen A und C. <br><br>  Jetzt best√§tige ich, dass es sich auch um eine GCD handelt.  Wenn F nicht der gr√∂√üte gemeinsame Teiler der Zahlen A und C ist, gibt es tats√§chlich eine gr√∂√üere Zahl, die diese beiden Zahlen teilt.  Sei diese Zahl G. <br><br>  Da die Zahl G die Zahl C teilt und die Zahl C A - E teilt, teilt G auch die Zahl A - E. Die Zahl G teilt auch die ganze Zahl A, so dass sie den Rest E teilt. Aber E teilt C - F, also G. teilt auch C - F. Und die Zahl G teilt auch die ganze Zahl C, da sie den Rest F teilt;  somit teilt eine gr√∂√üere Zahl eine kleinere, und dies ist unm√∂glich. <br><br>  Somit gibt es keine Zahl gr√∂√üer als F, die A und C teilt;  daher ist die Zahl F GCD. <br><br>  <b>Folge</b>  Diese Argumentation macht die Annahme offensichtlich, dass jede Zahl, die zwei Zahlen teilt, ihre GCD teilt.  Rt </blockquote></div></div><br><br>  Die Beschreibung gibt zwei M√∂glichkeiten, um GCD zu finden - durch Subtraktion und Division.  Tats√§chlich sind diese beiden Methoden zur Implementierung des Algorithmus heute weithin bekannt. <br><br>  Hier ist ein Beispiel f√ºr eine in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Swift</a> geschriebene Funktion, die die erste Methode implementiert: <br><br><pre><code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subtractionGCD</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> firstNumber: Int, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> secondNumber: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> simpleGCD = simpleCasesGCD(firstNumber, secondNumber) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> simpleGCD } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstNumber = firstNumber <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> secondNumber = secondNumber <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> firstNumber != <span class="hljs-number"><span class="hljs-number">0</span></span>, secondNumber != <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> firstNumber &gt; secondNumber { firstNumber = firstNumber - secondNumber } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { secondNumber = secondNumber - firstNumber } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> firstNumber + secondNumber <span class="hljs-comment"><span class="hljs-comment">// One of them is 0. }</span></span></code> </pre> <br>  Hier habe ich zur Wiederverwendung, um meinetwillen, die F√§lle der Suche nach GCD, wenn sie sofort bekannt sind, in eine separate Funktion gebracht, ohne dass ein Algorithmus befolgt werden muss: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">simpleCasesGCD</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> firstNumber: Int, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> secondNumber: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> firstNumber == secondNumber { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> firstNumber <span class="hljs-comment"><span class="hljs-comment">// Any. } if firstNumber == 0 { return secondNumber } if secondNumber == 0 { return firstNumber } return nil }</span></span></code> </pre> <br>  (Wenn zwei Zahlen gleich sind, ist nat√ºrlich auch ihre GCD gleich. Wenn eine der Zahlen Null ist, ist die GCD gleich der zweiten Zahl, da Null durch eine beliebige Zahl teilbar ist (mit dem Ergebnis nat√ºrlich auch Null). .) <br><br>  Als Eingabe k√∂nnen nur nicht negative Werte verwendet werden.  Dementsprechend k√∂nnen Sie f√ºr das Negativ die gleichen Methoden verwenden, jedoch die Zahlen modulo nehmen.  (Ja, der gemeinsame Faktor kann auch negativ sein, aber wir suchen speziell nach GCD, und positive Zahlen sind offensichtlich immer mehr als negativ.) <br><br>  Und hier kann es so aussehen, als w√ºrde die Version des Algorithmus nach Division implementiert: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divisionGCD</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> firstNumber: Int, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> secondNumber: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> simpleGCD = simpleCasesGCD(firstNumber, secondNumber) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> simpleGCD } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstNumber = firstNumber <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> secondNumber = secondNumber <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> firstNumber != <span class="hljs-number"><span class="hljs-number">0</span></span>, secondNumber != <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> firstNumber &gt; secondNumber { firstNumber = firstNumber % secondNumber } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { secondNumber = secondNumber % firstNumber } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> firstNumber + secondNumber <span class="hljs-comment"><span class="hljs-comment">// One of them is 0. }</span></span></code> </pre> <br>  Die zweite Version wird heute als vorzuziehen angesehen, da sie im Durchschnitt eine wesentlich geringere Anzahl von Schritten enth√§lt.  In einer Zeit, in der Computer gro√ü und langsam waren, konnte der Teilungsvorgang jedoch ein komplexer Vorgang f√ºr sich sein.  Und dann k√∂nnte die erste Version des Algorithmus effektiver sein. <br><br>  Um sie ein wenig zu vergleichen, habe ich mehrere Messungen mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>measure(_:)</code></a> -Methode meiner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>XCTestCase</code></a> Klasse des "nativen" Frameworks zum Testen von Code in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Xcode-</a> Projekten von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>XCTest</code></a> . <br><br>  Als Eingabe habe ich ein Array von Paaren von Zufallszahlen verwendet.  Die Messungen wurden nat√ºrlich unter Verwendung des gleichen Arrays f√ºr jede Methode durchgef√ºhrt.  Ich habe die Verteilung der Zahlen f√ºr Paare von null auf 9999 genommen. Die Anzahl der Berechnungen (Zahlenpaare) wurde gemessen: eins, zehn, 100, 1000, 10000, 100000, 1.000.000 und 10.000.000. Letzteres lie√ü mich das Ergebnis f√ºr einige Minuten erwarten, also entschied ich mich daf√ºr aufh√∂ren. <br><br>  Hier ist ein einfacher Code zur Eingabegenerierung: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pairs = (<span class="hljs-number"><span class="hljs-number">0</span></span>..&lt;<span class="hljs-number"><span class="hljs-number">100</span></span>).<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-type"><span class="hljs-type">Int</span></span>.random(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>..&lt;<span class="hljs-number"><span class="hljs-number">10000</span></span>), <span class="hljs-type"><span class="hljs-type">Int</span></span>.random(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>..&lt;<span class="hljs-number"><span class="hljs-number">10000</span></span>)) } <span class="hljs-comment"><span class="hljs-comment">// Generates 100 pairs.</span></span></code> </pre> <br>  Die Messung selbst sieht zum Beispiel so aus: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testSubstractionGCDPerformance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { measure() { <span class="hljs-number"><span class="hljs-number">_</span></span> = pairs.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { substractionGCD($<span class="hljs-number"><span class="hljs-number">0</span></span>, $<span class="hljs-number"><span class="hljs-number">1</span></span>) } } }</code> </pre> <br>  Und hier sind die Ergebnisse des Starts auf meinem Computer: <br><br><img src="https://habrastorage.org/webt/q0/ij/na/q0ijna2lnsd2kaw74y0xbvgjsqw.png" alt="Bild"><br>  <i>(Subtraktion - Subtraktion, Division - Division.)</i> <br><br>  Im Allgemeinen ist sehr deutlich zu erkennen, wie viel die Subtraktionsmethode auf modernen Computern verliert. <br><br><h3>  "Verbesserte" Version des euklidischen Algorithmus </h3><br>  In der Literatur finden Sie eine Version des Algorithmus, bei der eine der Zahlen in jedem Schritt anstelle des Restes der Division durch die Sekunde durch die Differenz zwischen diesem Versatz und der zweiten Zahl ersetzt wird, jedoch nur, wenn der Rest der Division mehr als die H√§lfte der zweiten Zahl betr√§gt.  Eine Implementierung dieser Version k√∂nnte folgenderma√üen aussehen: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">improvedDivisionGCD</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> firstNumber: Int, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> secondNumber: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> simpleGCD = simpleCasesGCD(firstNumber, secondNumber) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> simpleGCD } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstNumber = firstNumber <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> secondNumber = secondNumber <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> firstNumber != <span class="hljs-number"><span class="hljs-number">0</span></span>, secondNumber != <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> firstNumber &gt; secondNumber { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstNumberClaim = firstNumber % secondNumber <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> firstNumberClaim &gt; secondNumber / <span class="hljs-number"><span class="hljs-number">2</span></span> { firstNumber = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(firstNumberClaim - secondNumber) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { firstNumber = firstNumberClaim } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> secondNumberClaim = secondNumber % firstNumber <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> secondNumberClaim &gt; firstNumber / <span class="hljs-number"><span class="hljs-number">2</span></span> { secondNumber = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(secondNumberClaim - firstNumber) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { secondNumber = secondNumberClaim } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> firstNumber + secondNumber <span class="hljs-comment"><span class="hljs-comment">// One of them is 0. }</span></span></code> </pre> <br>  Eine solche √Ñnderung reduziert die Anzahl der Schritte im Algorithmus, aber nach den Ergebnissen der Messungen auf meinem Computer zu urteilen, neutralisieren zus√§tzliche Berechnungen und √úberpr√ºfungen bei jedem Schritt diesen Vorteil und noch mehr: <br><br><img src="https://habrastorage.org/webt/k-/dv/ef/k-dveffrc9dd-75z4evayxdohri.png" alt="Bild"><br>  <i>(Verbessert ist die "verbesserte" Version.)</i> <br><br><h3>  Ein bisschen mehr √ºber die Bedeutung des euklidischen Algorithmus </h3><br>  Der Algorithmus hat auch eine geometrische Version (um das gr√∂√üte Ma√ü aus zwei Segmenten zu finden). <br><br>  Der Algorithmus wurde nat√ºrlich verallgemeinert, um GCD mit einer beliebigen Anzahl von Zahlen zu finden, nicht nur mit zwei.  Kurz gesagt lautet die Idee: Wenn wir die Funktion der Suche nach der GCD von zwei Zahlen als gcd (a, b) bezeichnen, dann ist die GCD von drei Zahlen gcd (a, b, c) gleich gcd (gcd (a, b), c).  Und so weiter wird f√ºr eine beliebige Anzahl von Zahlen die GCD gefunden, indem die GCD der GCD des vorherigen Zahlenpaars und der n√§chsten Zahl nacheinander berechnet wird.  Dies betrifft nat√ºrlich die Suche nach GCD im Allgemeinen und nicht nur den euklidischen Algorithmus. <br><br>  Es gibt auch eine Verallgemeinerung des Algorithmus zum Auffinden von GCD-Polynomen.  Dies geht jedoch bereits √ºber den Rahmen dieses einfachen Beitrags und in gewissem Ma√üe √ºber meine mathematischen Kenntnisse hinaus. <br><br><h3>  Komplexit√§t des euklidischen Algorithmus </h3><br>  Die zeitliche Komplexit√§t des Algorithmus wurde lange Zeit untersucht, nicht schnell und von viel gelehrteren M√§nnern als Ihrem bescheidenen Diener.  Die Frage ist jedoch seit langem geschlossen und eine Antwort ist eingegangen.  Eigentlich schon in der Mitte des vorletzten Jahrhunderts.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gabriel Lame</a> . <br><br>  Kurz gesagt, die Antwort wird tats√§chlich durch den Lame-Satz formuliert, der sich auf diesen Algorithmus bezieht.  Die Anzahl der Schritte im Algorithmus entspricht der Sequenznummer der n√§chstgr√∂√üeren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fibonacci-Zahl, der</a> kleinsten der beiden Anzahlen von Eingabeparametern minus 2. Unter Verwendung einer etwas traditionelleren mathematischen Notation betr√§gt die Anzahl der Durchg√§nge des Algorithmus n - 2, wenn u&gt; v (und v&gt; 1) v &lt;Fn (Fn ist die n√§chste v Fibonacci-Zahl und n ist ihre Sequenznummer). <br><br>  Fibonacci-Zahlen wachsen exponentiell, wir haben eine logarithmische Funktion der Ausf√ºhrungszeit des Algorithmus (aus der kleineren der beiden Eingangszahlen). <br><br>  Dieselben Berechnungen zeigen, dass die schlechtesten Eingabedaten f√ºr den Algorithmus zwei aufeinanderfolgende Fibonacci-Zahlen sind. <br><br><h2>  Bin√§re Methode zum Auffinden von NOD </h2><br>  In Bezug auf die Suche nach GCD ist der bereits in den 60er Jahren des letzten Jahrhunderts von einem bestimmten Joseph Stein vorgeschlagene Algorithmus zu erw√§hnen, √ºber den ich im Internet √ºberhaupt keine Informationen gefunden habe.  Es (der Algorithmus) ist auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bin√§re Arithmetik ausgerichtet</a> und enth√§lt keine Divisionsoperationen.  Der Algorithmus arbeitet nur mit Parit√§tspr√ºfungen und Halbierungen, was allein mit den F√§higkeiten der bin√§ren Arithmetik m√∂glich ist. <br><br>  Der Algorithmus basiert auf vier Fakten: <br><br><ol><li>  Wenn u und v beide gerade sind, dann ist gcd (u, v) = 2 ¬∑ gcd (u / 2, v / 2); </li><li>  Wenn u gerade ist und v nicht, ist gcd (u, v) = gcd (u / 2, v); </li><li>  gcd (u, v) = gcd (u - v, v) (dies folgt aus dem euklidischen Algorithmus); </li><li>  Wenn u und v beide ungerade sind, ist u - v gerade und | u - v |  &lt;max (u, v) </li></ol><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auf Wikipedia</a> k√∂nnen Sie die rekursive Version des Algorithmus sehen (in modernen Programmiersprachen in mehreren Zeilen geschrieben). Ich habe ihn in Swift nicht umgeschrieben.  Und hier gebe ich eine iterative Implementierung: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">binaryGCD</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> firstNumber: Int, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> secondNumber: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> simpleGCD = simpleCasesGCD(firstNumber, secondNumber) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> simpleGCD } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstNumber = firstNumber <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> secondNumber = secondNumber <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shift = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (firstNumber | secondNumber) &amp; <span class="hljs-number"><span class="hljs-number">1</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { shift += <span class="hljs-number"><span class="hljs-number">1</span></span> firstNumber &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span> secondNumber &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> firstNumber &amp; <span class="hljs-number"><span class="hljs-number">1</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { firstNumber &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">repeat</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> secondNumber &amp; <span class="hljs-number"><span class="hljs-number">1</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { secondNumber &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> firstNumber &gt; secondNumber { <span class="hljs-built_in"><span class="hljs-built_in">swap</span></span>(&amp;firstNumber, &amp;secondNumber) } secondNumber -= firstNumber } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> secondNumber != <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> firstNumber &lt;&lt; shift }</code> </pre> <br>  Nachdem dieser hochentwickelte Algorithmus auf meinem Computer Messungen an denselben Daten durchgef√ºhrt hatte, entsprach er leider nicht den an ihn gestellten Erwartungen.  Nat√ºrlich arbeitet es immer noch doppelt so schnell wie der euklidische Algorithmus durch Subtraktion, ist aber seiner klassischen Divisionsversion deutlich unterlegen.  Vollst√§ndige √úbersichtstabelle: <br><br><img src="https://habrastorage.org/webt/to/na/vg/tonavg6ye_brn5roqmziys7z9ey.png" alt="Bild"><br>  <i>(Bin√§r ist ein bin√§rer Algorithmus.)</i> <br><br>  (Ich schlie√üe nicht aus, dass der Algorithmus effizienter geschrieben werden kann als ich, und dies wirkt sich auf das Ergebnis aus, aber wof√ºr brauchen wir dann Compiler?! <br><br>  √úbrigens war dieser Algorithmus, der zweifellos bereits im Zeitalter der Informationstechnologie (fr√ºher als heute) 15 Minuten lang ber√ºhmt wurde, im alten China bekannt.  Seine Beschreibung findet sich in Werken aus dem 1. Jahrhundert.  AD  Nat√ºrlich in Begriffen wie "halbe Division" und Subtraktion.  Und auch im Zusammenhang mit der Reduzierung von Br√ºchen. <br><br><h2>  Fazit </h2><br>  Ehrlich gesagt, mit dieser einfachen "Forschung" wollte ich nichts beweisen und wollte keine revolution√§ren Schlussfolgerungen ziehen (und ich tat es nicht!).  Ich wollte nur meine Neugier befriedigen, die Arbeit verschiedener Ans√§tze zur L√∂sung des klassischen Problems betrachten und meine Finger leicht strecken.  Trotzdem hoffe ich, dass Sie auch neugierig waren, die Ergebnisse zu beobachten! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464949/">https://habr.com/ru/post/de464949/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464933/index.html">Anwendungen f√ºr E-Books auf dem Android-Betriebssystem. Teil 4. Spiele</a></li>
<li><a href="../de464935/index.html">Komfortable DevOpsSec: Nemesida WAF Kostenlos f√ºr NGINX mit API und pers√∂nlichem Konto</a></li>
<li><a href="../de464937/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 312 (vom 19. bis 25. August)</a></li>
<li><a href="../de464939/index.html">Testen von @ NonNull / @ Nullable-Annotationen</a></li>
<li><a href="../de464947/index.html">Digitale Veranstaltungen in Moskau vom 25. August bis 1. September</a></li>
<li><a href="../de464951/index.html">Je einfacher die Aufgabe, desto √∂fter irre ich mich</a></li>
<li><a href="../de464955/index.html">Iron Mike Tyson und das Blockchain-Projekt Fight to Fame</a></li>
<li><a href="../de464959/index.html">Analyse des Satzes der russischen Sprache</a></li>
<li><a href="../de464961/index.html">Erstellen Sie visuelle Komponenten in der Unity-Benutzeroberfl√§che. Partikelsystem</a></li>
<li><a href="../de464963/index.html">Lokalisieren Sie schnell Microsoft SQL Server-Leistungsprobleme in Quest Foglight</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>