<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏂🏻 #⃣ 🗾 Noch einmal über GCD, den euklidischen Algorithmus und ein wenig über die Geschichte der Algorithmen im Allgemeinen. Natürlich mit Swift-Beispielen 👈🏽 🤶🏽 🦅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Algorithmen sind eines der zentralen Themen in der Programmierung , sie sind überall (besonders in Interviews, haha). 


 (Kann man in einem solchen B...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Noch einmal über GCD, den euklidischen Algorithmus und ein wenig über die Geschichte der Algorithmen im Allgemeinen. Natürlich mit Swift-Beispielen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464949/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Algorithmen</a> sind eines der zentralen Themen in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Programmierung</a> , sie sind überall (besonders in Interviews, haha). <br><br><img src="https://habrastorage.org/webt/_t/w8/av/_tw8avywasehzxdtkkheppkltuo.jpeg" alt="Bild"><br>  <i>(Kann man in einem solchen Beitrag auf ein Knopfakkordeon verzichten?)</i> <br><br>  Einer der bekanntesten ist der sogenannte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">euklidische Algorithmus</a> - vielleicht der häufigste Weg, um den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">größten gemeinsamen Teiler (GCD)</a> zweier nicht negativer Ganzzahlen zu finden.  Oft beginnt er auch, die relevanten Bereiche der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mathematik</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informatik</a> zu studieren (und zu lernen). <a name="habracut"></a><br><br>  Und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Donald Knuth</a> , der bekannte Autor der Abhandlung „Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kunst des Programmierens</a> “ (und nicht nur), betrachtet den Algorithmus sogar als den ersten in der Geschichte (zumindest in Bezug auf moderne Definitionen).  Denn trotz der Tatsache, dass der Algorithmus vor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Euklid</a> erfunden und verwendet wurde, lebte er in den IV-III Jahrhunderten.  BC (es wurde bereits von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aristoteles erwähnt</a> , der ein Jahrhundert zuvor lebte), beschreibt Euklid den Prozess <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">iterativ</a> , was mit der modernen Bedeutung des Wortes übereinstimmt. <br><br>  Das Wort „Algorithmus“ geht auf den Namen des persischen Mathematikers <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Al-Khwarizmi zurück</a> , der um das VIII-IX Jahrhundert lebte.  schon AD.  Und der Beginn seiner Verwendung in einem modernen Sinne wird nur als das 20. Jahrhundert betrachtet, genauer gesagt - seine ersten Jahrzehnte, der Aufstieg der Informationstechnologie. <br><br><h2>  Euklidischer Algorithmus </h2><br>  Aus Neugier empfehle ich Ihnen, sich mit der euklidischen Beschreibung des Algorithmus in Knuths Bearbeitung vertraut zu machen.  Es ist ziemlich lang, daher unter dem Schnitt versteckt: <br><br><div class="spoiler">  <b class="spoiler_title">Beschreibung des euklidischen Algorithmus in der Nähe des Originals</b> <div class="spoiler_text"><blockquote>  <b>Angebot.</b>  Finden Sie für zwei positive ganze Zahlen ihren größten gemeinsamen Teiler. <br><br>  Sei A und C zwei gegebene positive ganze Zahlen;  Es ist erforderlich, ihre GCD zu finden.  Wenn die Zahl A durch C teilbar ist, ist die Zahl C ein gemeinsamer Teiler der Zahlen C und A, da sie sich selbst teilt.  Und natürlich wird es der größte Teiler sein, da es keine größere Zahl als die Zahl C gibt, die C teilt. <br><br>  Wenn C die Zahl A nicht teilt, subtrahieren wir kontinuierlich die kleinere der Zahlen A und C von der größeren, bis wir eine Zahl erhalten, die die vorherige subtrahierte Zahl vollständig teilt.  Dies sollte früher oder später geschehen, denn wenn die Differenz gleich eins ist, teilt die Einheit den zuvor subtrahierten Wert. <br><br>  Nehmen wir nun an, dass E der positive Rest der Division der Zahl A durch C ist;  Sei F der positive Rest der Division von C durch E und sei F die Division von E. Da F E und E C - F teilt, teilt F auch C - F. Aber es teilt sich auch selbst, also teilt F C, und C teilt A - E;  daher teilt F auch A - E, aber es teilt auch E;  daher teilt F A. Folglich ist F ein gemeinsamer Teiler der Zahlen A und C. <br><br>  Jetzt bestätige ich, dass es sich auch um eine GCD handelt.  Wenn F nicht der größte gemeinsame Teiler der Zahlen A und C ist, gibt es tatsächlich eine größere Zahl, die diese beiden Zahlen teilt.  Sei diese Zahl G. <br><br>  Da die Zahl G die Zahl C teilt und die Zahl C A - E teilt, teilt G auch die Zahl A - E. Die Zahl G teilt auch die ganze Zahl A, so dass sie den Rest E teilt. Aber E teilt C - F, also G. teilt auch C - F. Und die Zahl G teilt auch die ganze Zahl C, da sie den Rest F teilt;  somit teilt eine größere Zahl eine kleinere, und dies ist unmöglich. <br><br>  Somit gibt es keine Zahl größer als F, die A und C teilt;  daher ist die Zahl F GCD. <br><br>  <b>Folge</b>  Diese Argumentation macht die Annahme offensichtlich, dass jede Zahl, die zwei Zahlen teilt, ihre GCD teilt.  Rt </blockquote></div></div><br><br>  Die Beschreibung gibt zwei Möglichkeiten, um GCD zu finden - durch Subtraktion und Division.  Tatsächlich sind diese beiden Methoden zur Implementierung des Algorithmus heute weithin bekannt. <br><br>  Hier ist ein Beispiel für eine in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Swift</a> geschriebene Funktion, die die erste Methode implementiert: <br><br><pre><code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subtractionGCD</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> firstNumber: Int, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> secondNumber: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> simpleGCD = simpleCasesGCD(firstNumber, secondNumber) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> simpleGCD } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstNumber = firstNumber <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> secondNumber = secondNumber <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> firstNumber != <span class="hljs-number"><span class="hljs-number">0</span></span>, secondNumber != <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> firstNumber &gt; secondNumber { firstNumber = firstNumber - secondNumber } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { secondNumber = secondNumber - firstNumber } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> firstNumber + secondNumber <span class="hljs-comment"><span class="hljs-comment">// One of them is 0. }</span></span></code> </pre> <br>  Hier habe ich zur Wiederverwendung, um meinetwillen, die Fälle der Suche nach GCD, wenn sie sofort bekannt sind, in eine separate Funktion gebracht, ohne dass ein Algorithmus befolgt werden muss: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">simpleCasesGCD</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> firstNumber: Int, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> secondNumber: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> firstNumber == secondNumber { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> firstNumber <span class="hljs-comment"><span class="hljs-comment">// Any. } if firstNumber == 0 { return secondNumber } if secondNumber == 0 { return firstNumber } return nil }</span></span></code> </pre> <br>  (Wenn zwei Zahlen gleich sind, ist natürlich auch ihre GCD gleich. Wenn eine der Zahlen Null ist, ist die GCD gleich der zweiten Zahl, da Null durch eine beliebige Zahl teilbar ist (mit dem Ergebnis natürlich auch Null). .) <br><br>  Als Eingabe können nur nicht negative Werte verwendet werden.  Dementsprechend können Sie für das Negativ die gleichen Methoden verwenden, jedoch die Zahlen modulo nehmen.  (Ja, der gemeinsame Faktor kann auch negativ sein, aber wir suchen speziell nach GCD, und positive Zahlen sind offensichtlich immer mehr als negativ.) <br><br>  Und hier kann es so aussehen, als würde die Version des Algorithmus nach Division implementiert: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divisionGCD</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> firstNumber: Int, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> secondNumber: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> simpleGCD = simpleCasesGCD(firstNumber, secondNumber) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> simpleGCD } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstNumber = firstNumber <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> secondNumber = secondNumber <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> firstNumber != <span class="hljs-number"><span class="hljs-number">0</span></span>, secondNumber != <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> firstNumber &gt; secondNumber { firstNumber = firstNumber % secondNumber } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { secondNumber = secondNumber % firstNumber } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> firstNumber + secondNumber <span class="hljs-comment"><span class="hljs-comment">// One of them is 0. }</span></span></code> </pre> <br>  Die zweite Version wird heute als vorzuziehen angesehen, da sie im Durchschnitt eine wesentlich geringere Anzahl von Schritten enthält.  In einer Zeit, in der Computer groß und langsam waren, konnte der Teilungsvorgang jedoch ein komplexer Vorgang für sich sein.  Und dann könnte die erste Version des Algorithmus effektiver sein. <br><br>  Um sie ein wenig zu vergleichen, habe ich mehrere Messungen mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>measure(_:)</code></a> -Methode meiner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>XCTestCase</code></a> Klasse des "nativen" Frameworks zum Testen von Code in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Xcode-</a> Projekten von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>XCTest</code></a> . <br><br>  Als Eingabe habe ich ein Array von Paaren von Zufallszahlen verwendet.  Die Messungen wurden natürlich unter Verwendung des gleichen Arrays für jede Methode durchgeführt.  Ich habe die Verteilung der Zahlen für Paare von null auf 9999 genommen. Die Anzahl der Berechnungen (Zahlenpaare) wurde gemessen: eins, zehn, 100, 1000, 10000, 100000, 1.000.000 und 10.000.000. Letzteres ließ mich das Ergebnis für einige Minuten erwarten, also entschied ich mich dafür aufhören. <br><br>  Hier ist ein einfacher Code zur Eingabegenerierung: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pairs = (<span class="hljs-number"><span class="hljs-number">0</span></span>..&lt;<span class="hljs-number"><span class="hljs-number">100</span></span>).<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-type"><span class="hljs-type">Int</span></span>.random(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>..&lt;<span class="hljs-number"><span class="hljs-number">10000</span></span>), <span class="hljs-type"><span class="hljs-type">Int</span></span>.random(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>..&lt;<span class="hljs-number"><span class="hljs-number">10000</span></span>)) } <span class="hljs-comment"><span class="hljs-comment">// Generates 100 pairs.</span></span></code> </pre> <br>  Die Messung selbst sieht zum Beispiel so aus: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testSubstractionGCDPerformance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { measure() { <span class="hljs-number"><span class="hljs-number">_</span></span> = pairs.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { substractionGCD($<span class="hljs-number"><span class="hljs-number">0</span></span>, $<span class="hljs-number"><span class="hljs-number">1</span></span>) } } }</code> </pre> <br>  Und hier sind die Ergebnisse des Starts auf meinem Computer: <br><br><img src="https://habrastorage.org/webt/q0/ij/na/q0ijna2lnsd2kaw74y0xbvgjsqw.png" alt="Bild"><br>  <i>(Subtraktion - Subtraktion, Division - Division.)</i> <br><br>  Im Allgemeinen ist sehr deutlich zu erkennen, wie viel die Subtraktionsmethode auf modernen Computern verliert. <br><br><h3>  "Verbesserte" Version des euklidischen Algorithmus </h3><br>  In der Literatur finden Sie eine Version des Algorithmus, bei der eine der Zahlen in jedem Schritt anstelle des Restes der Division durch die Sekunde durch die Differenz zwischen diesem Versatz und der zweiten Zahl ersetzt wird, jedoch nur, wenn der Rest der Division mehr als die Hälfte der zweiten Zahl beträgt.  Eine Implementierung dieser Version könnte folgendermaßen aussehen: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">improvedDivisionGCD</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> firstNumber: Int, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> secondNumber: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> simpleGCD = simpleCasesGCD(firstNumber, secondNumber) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> simpleGCD } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstNumber = firstNumber <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> secondNumber = secondNumber <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> firstNumber != <span class="hljs-number"><span class="hljs-number">0</span></span>, secondNumber != <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> firstNumber &gt; secondNumber { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstNumberClaim = firstNumber % secondNumber <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> firstNumberClaim &gt; secondNumber / <span class="hljs-number"><span class="hljs-number">2</span></span> { firstNumber = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(firstNumberClaim - secondNumber) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { firstNumber = firstNumberClaim } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> secondNumberClaim = secondNumber % firstNumber <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> secondNumberClaim &gt; firstNumber / <span class="hljs-number"><span class="hljs-number">2</span></span> { secondNumber = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(secondNumberClaim - firstNumber) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { secondNumber = secondNumberClaim } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> firstNumber + secondNumber <span class="hljs-comment"><span class="hljs-comment">// One of them is 0. }</span></span></code> </pre> <br>  Eine solche Änderung reduziert die Anzahl der Schritte im Algorithmus, aber nach den Ergebnissen der Messungen auf meinem Computer zu urteilen, neutralisieren zusätzliche Berechnungen und Überprüfungen bei jedem Schritt diesen Vorteil und noch mehr: <br><br><img src="https://habrastorage.org/webt/k-/dv/ef/k-dveffrc9dd-75z4evayxdohri.png" alt="Bild"><br>  <i>(Verbessert ist die "verbesserte" Version.)</i> <br><br><h3>  Ein bisschen mehr über die Bedeutung des euklidischen Algorithmus </h3><br>  Der Algorithmus hat auch eine geometrische Version (um das größte Maß aus zwei Segmenten zu finden). <br><br>  Der Algorithmus wurde natürlich verallgemeinert, um GCD mit einer beliebigen Anzahl von Zahlen zu finden, nicht nur mit zwei.  Kurz gesagt lautet die Idee: Wenn wir die Funktion der Suche nach der GCD von zwei Zahlen als gcd (a, b) bezeichnen, dann ist die GCD von drei Zahlen gcd (a, b, c) gleich gcd (gcd (a, b), c).  Und so weiter wird für eine beliebige Anzahl von Zahlen die GCD gefunden, indem die GCD der GCD des vorherigen Zahlenpaars und der nächsten Zahl nacheinander berechnet wird.  Dies betrifft natürlich die Suche nach GCD im Allgemeinen und nicht nur den euklidischen Algorithmus. <br><br>  Es gibt auch eine Verallgemeinerung des Algorithmus zum Auffinden von GCD-Polynomen.  Dies geht jedoch bereits über den Rahmen dieses einfachen Beitrags und in gewissem Maße über meine mathematischen Kenntnisse hinaus. <br><br><h3>  Komplexität des euklidischen Algorithmus </h3><br>  Die zeitliche Komplexität des Algorithmus wurde lange Zeit untersucht, nicht schnell und von viel gelehrteren Männern als Ihrem bescheidenen Diener.  Die Frage ist jedoch seit langem geschlossen und eine Antwort ist eingegangen.  Eigentlich schon in der Mitte des vorletzten Jahrhunderts.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gabriel Lame</a> . <br><br>  Kurz gesagt, die Antwort wird tatsächlich durch den Lame-Satz formuliert, der sich auf diesen Algorithmus bezieht.  Die Anzahl der Schritte im Algorithmus entspricht der Sequenznummer der nächstgrößeren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fibonacci-Zahl, der</a> kleinsten der beiden Anzahlen von Eingabeparametern minus 2. Unter Verwendung einer etwas traditionelleren mathematischen Notation beträgt die Anzahl der Durchgänge des Algorithmus n - 2, wenn u&gt; v (und v&gt; 1) v &lt;Fn (Fn ist die nächste v Fibonacci-Zahl und n ist ihre Sequenznummer). <br><br>  Fibonacci-Zahlen wachsen exponentiell, wir haben eine logarithmische Funktion der Ausführungszeit des Algorithmus (aus der kleineren der beiden Eingangszahlen). <br><br>  Dieselben Berechnungen zeigen, dass die schlechtesten Eingabedaten für den Algorithmus zwei aufeinanderfolgende Fibonacci-Zahlen sind. <br><br><h2>  Binäre Methode zum Auffinden von NOD </h2><br>  In Bezug auf die Suche nach GCD ist der bereits in den 60er Jahren des letzten Jahrhunderts von einem bestimmten Joseph Stein vorgeschlagene Algorithmus zu erwähnen, über den ich im Internet überhaupt keine Informationen gefunden habe.  Es (der Algorithmus) ist auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">binäre Arithmetik ausgerichtet</a> und enthält keine Divisionsoperationen.  Der Algorithmus arbeitet nur mit Paritätsprüfungen und Halbierungen, was allein mit den Fähigkeiten der binären Arithmetik möglich ist. <br><br>  Der Algorithmus basiert auf vier Fakten: <br><br><ol><li>  Wenn u und v beide gerade sind, dann ist gcd (u, v) = 2 · gcd (u / 2, v / 2); </li><li>  Wenn u gerade ist und v nicht, ist gcd (u, v) = gcd (u / 2, v); </li><li>  gcd (u, v) = gcd (u - v, v) (dies folgt aus dem euklidischen Algorithmus); </li><li>  Wenn u und v beide ungerade sind, ist u - v gerade und | u - v |  &lt;max (u, v) </li></ol><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auf Wikipedia</a> können Sie die rekursive Version des Algorithmus sehen (in modernen Programmiersprachen in mehreren Zeilen geschrieben). Ich habe ihn in Swift nicht umgeschrieben.  Und hier gebe ich eine iterative Implementierung: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">binaryGCD</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> firstNumber: Int, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> secondNumber: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> simpleGCD = simpleCasesGCD(firstNumber, secondNumber) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> simpleGCD } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstNumber = firstNumber <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> secondNumber = secondNumber <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shift = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (firstNumber | secondNumber) &amp; <span class="hljs-number"><span class="hljs-number">1</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { shift += <span class="hljs-number"><span class="hljs-number">1</span></span> firstNumber &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span> secondNumber &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> firstNumber &amp; <span class="hljs-number"><span class="hljs-number">1</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { firstNumber &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">repeat</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> secondNumber &amp; <span class="hljs-number"><span class="hljs-number">1</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { secondNumber &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> firstNumber &gt; secondNumber { <span class="hljs-built_in"><span class="hljs-built_in">swap</span></span>(&amp;firstNumber, &amp;secondNumber) } secondNumber -= firstNumber } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> secondNumber != <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> firstNumber &lt;&lt; shift }</code> </pre> <br>  Nachdem dieser hochentwickelte Algorithmus auf meinem Computer Messungen an denselben Daten durchgeführt hatte, entsprach er leider nicht den an ihn gestellten Erwartungen.  Natürlich arbeitet es immer noch doppelt so schnell wie der euklidische Algorithmus durch Subtraktion, ist aber seiner klassischen Divisionsversion deutlich unterlegen.  Vollständige Übersichtstabelle: <br><br><img src="https://habrastorage.org/webt/to/na/vg/tonavg6ye_brn5roqmziys7z9ey.png" alt="Bild"><br>  <i>(Binär ist ein binärer Algorithmus.)</i> <br><br>  (Ich schließe nicht aus, dass der Algorithmus effizienter geschrieben werden kann als ich, und dies wirkt sich auf das Ergebnis aus, aber wofür brauchen wir dann Compiler?! <br><br>  Übrigens war dieser Algorithmus, der zweifellos bereits im Zeitalter der Informationstechnologie (früher als heute) 15 Minuten lang berühmt wurde, im alten China bekannt.  Seine Beschreibung findet sich in Werken aus dem 1. Jahrhundert.  AD  Natürlich in Begriffen wie "halbe Division" und Subtraktion.  Und auch im Zusammenhang mit der Reduzierung von Brüchen. <br><br><h2>  Fazit </h2><br>  Ehrlich gesagt, mit dieser einfachen "Forschung" wollte ich nichts beweisen und wollte keine revolutionären Schlussfolgerungen ziehen (und ich tat es nicht!).  Ich wollte nur meine Neugier befriedigen, die Arbeit verschiedener Ansätze zur Lösung des klassischen Problems betrachten und meine Finger leicht strecken.  Trotzdem hoffe ich, dass Sie auch neugierig waren, die Ergebnisse zu beobachten! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464949/">https://habr.com/ru/post/de464949/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464933/index.html">Anwendungen für E-Books auf dem Android-Betriebssystem. Teil 4. Spiele</a></li>
<li><a href="../de464935/index.html">Komfortable DevOpsSec: Nemesida WAF Kostenlos für NGINX mit API und persönlichem Konto</a></li>
<li><a href="../de464937/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 312 (vom 19. bis 25. August)</a></li>
<li><a href="../de464939/index.html">Testen von @ NonNull / @ Nullable-Annotationen</a></li>
<li><a href="../de464947/index.html">Digitale Veranstaltungen in Moskau vom 25. August bis 1. September</a></li>
<li><a href="../de464951/index.html">Je einfacher die Aufgabe, desto öfter irre ich mich</a></li>
<li><a href="../de464955/index.html">Iron Mike Tyson und das Blockchain-Projekt Fight to Fame</a></li>
<li><a href="../de464959/index.html">Analyse des Satzes der russischen Sprache</a></li>
<li><a href="../de464961/index.html">Erstellen Sie visuelle Komponenten in der Unity-Benutzeroberfläche. Partikelsystem</a></li>
<li><a href="../de464963/index.html">Lokalisieren Sie schnell Microsoft SQL Server-Leistungsprobleme in Quest Foglight</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>