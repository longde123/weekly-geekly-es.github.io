<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚§¥Ô∏è üïì üôéüèæ Waktu presisi tinggi: cara bekerja dengan sepersekian detik di MySQL dan PHP üôå üßëüèø‚Äçü§ù‚ÄçüßëüèΩ üéΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Setelah saya menemukan diri saya berpikir bahwa ketika bekerja dengan waktu dalam database, saya hampir selalu menggunakan waktu yang akurat untuk yan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Waktu presisi tinggi: cara bekerja dengan sepersekian detik di MySQL dan PHP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/469615/"><p><img src="https://habrastorage.org/webt/uu/43/0k/uu430kx8xpmnjcelv7obc41muik.jpeg"></p><br><p>  Setelah saya menemukan diri saya berpikir bahwa ketika bekerja dengan waktu dalam database, saya hampir selalu menggunakan waktu yang akurat untuk yang kedua hanya karena saya sudah terbiasa dan bahwa ini adalah opsi yang dijelaskan dalam dokumentasi dan sejumlah besar contoh.  Namun, sekarang akurasi ini masih jauh dari cukup untuk semua tugas.  Sistem modern rumit - mereka dapat terdiri dari banyak bagian, memiliki jutaan pengguna yang berinteraksi dengan mereka - dan dalam banyak kasus lebih mudah untuk menggunakan akurasi yang lebih besar, yang dukungannya telah ada sejak lama. </p><br><p>  Pada artikel ini saya akan berbicara tentang cara-cara menggunakan waktu dengan bagian pecahan sedetik dalam MySQL dan PHP.  Itu dipahami sebagai tutorial, sehingga materi ini dirancang untuk berbagai pembaca dan di beberapa tempat mengulangi dokumentasi.  Nilai utama harus saya kumpulkan dalam satu teks, semua yang perlu Anda ketahui untuk bekerja dengan waktu seperti itu di MySQL, PHP, dan kerangka kerja Yii, dan juga menambahkan deskripsi masalah yang tidak terlihat yang mungkin Anda temui. </p><br><p>  Saya akan menggunakan istilah "waktu presisi tinggi".  Dalam dokumentasi MySQL Anda akan melihat istilah "detik fraksional", tetapi terjemahan harfiahnya terdengar aneh, tetapi saya tidak menemukan terjemahan lain yang mapan. </p><a name="habracut"></a><br><h2 id="kogda-stoit-ispolzovat-vremya-vysokoy-tochnosti">  Kapan menggunakan waktu berpresisi tinggi? </h2><br><p>  Sebagai permulaan, saya akan menunjukkan tangkapan layar kotak masuk dari kotak masuk saya yang menggambarkan ide dengan baik: </p><br><p><img src="https://habrastorage.org/webt/bc/tg/gx/bctggxr0qbeetqe9hmmb4zjmbom.png" alt="Dua surat dari satu pengirim"></p><br><p>  Surat adalah reaksi dari orang yang sama terhadap satu peristiwa.  Seorang pria tanpa sengaja menekan tombol yang salah, dengan cepat menyadari hal ini dan mengoreksi dirinya sendiri.  Akibatnya, kami menerima dua surat yang dikirim pada waktu yang bersamaan, yang penting untuk disortir dengan benar.  Jika waktu pengirimannya sama, ada kemungkinan bahwa surat-surat itu akan ditampilkan dalam urutan yang salah dan penerima akan merasa malu, karena dengan demikian ia akan menerima hasil yang salah yang akan ia hitung. </p><br><p>  Saya menemukan situasi berikut di mana waktu akurasi tinggi akan relevan: </p><br><ol><li>  Anda ingin mengukur waktu antara beberapa operasi.  Semuanya sangat sederhana di sini: semakin tinggi ketepatan cap waktu pada batas interval, semakin tinggi keakuratan hasilnya.  Jika Anda menggunakan seluruh detik, maka Anda dapat membuat kesalahan selama 1 detik (jika Anda jatuh di perbatasan detik).  Jika Anda menggunakan enam tempat desimal, maka kesalahannya adalah enam urutan lebih rendah. </li><li>  Anda memiliki koleksi yang kemungkinan ada beberapa objek dengan waktu pembuatan yang sama.  Contohnya adalah obrolan yang akrab bagi semua orang, di mana daftar kontak diurutkan berdasarkan waktu pesan terakhir.  Jika muncul navigasi halaman-demi-halaman, maka ada risiko kehilangan kontak di perbatasan halaman.  Masalah ini dapat diselesaikan tanpa waktu akurasi tinggi karena pengurutan dan pagination oleh sepasang bidang (waktu + pengidentifikasi unik suatu objek), tetapi solusi ini memiliki kelemahan (setidaknya komplikasi dari query SQL, tetapi tidak hanya itu).  Meningkatkan akurasi waktu akan membantu mengurangi kemungkinan masalah dan menghindari kerumitan sistem. </li><li> Anda harus menyimpan riwayat perubahan beberapa objek.  Ini sangat penting dalam dunia layanan, di mana modifikasi dapat terjadi secara paralel dan di tempat yang sama sekali berbeda.  Sebagai contoh, saya dapat mengutip pekerjaan dengan foto-foto pengguna kami, di mana banyak operasi berbeda dapat dilakukan secara paralel (pengguna dapat membuat foto pribadi atau menghapusnya, dapat dimoderasi di salah satu dari beberapa sistem, dipangkas untuk digunakan sebagai foto dalam obrolan, dll.) ) </li></ol><br><p>  Harus diingat bahwa seseorang tidak dapat mempercayai nilai yang diperoleh sebesar 100% dan akurasi nyata dari nilai yang diperoleh bisa kurang dari enam tempat desimal.  Ini disebabkan oleh fakta bahwa kita bisa mendapatkan nilai waktu yang tidak akurat (terutama ketika bekerja dalam sistem terdistribusi yang terdiri dari banyak server), waktu dapat berubah secara tak terduga (misalnya, saat menyinkronkan melalui NTP atau ketika mengganti jam), dll. Saya tidak akan membahas semua masalah ini, tetapi saya akan memberikan beberapa artikel di mana Anda dapat membaca lebih banyak tentang mereka: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Kesalahan programmer mengenai waktu"</a> (artikel itu sendiri sangat minimalis, tetapi selain tesis dari teks, penjelasan dapat ditemukan dalam komentar); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Beban waktu yang berat</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"</a> </li></ul><br><h2 id="rabota-so-vremenem-vysokoy-tochnosti-v-mysql">  Bekerja dengan waktu presisi tinggi di MySQL </h2><br><p> MySQL mendukung tiga jenis kolom di mana waktu dapat disimpan: <code>TIME</code> , <code>DATETIME</code> dan <code>TIMESTAMP</code> .  Awalnya, mereka hanya bisa menyimpan nilai yang merupakan kelipatan satu detik (misalnya, 2019-08-14 19:20:21).  Dalam versi 5.6.4, yang dirilis pada Desember 2011, menjadi mungkin untuk bekerja dengan bagian fraksional sedetik.  Untuk melakukan ini, saat membuat kolom, Anda harus menentukan jumlah tempat desimal, yang harus disimpan di bagian fraksional dari stempel waktu.  Jumlah maksimum karakter yang didukung adalah enam, yang memungkinkan Anda untuk menyimpan waktu secara akurat ke mikrodetik.  Jika Anda mencoba menggunakan lebih banyak karakter, Anda mendapatkan kesalahan. </p><br><p>  Contoh: </p><br><pre> <code class="sql hljs">Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-string"><span class="hljs-string">`ChatContactsList`</span></span> ( <span class="hljs-string"><span class="hljs-string">`chat_id`</span></span> <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span>(<span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> AUTO_INCREMENT PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span>, <span class="hljs-string"><span class="hljs-string">`title`</span></span> <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">`last_message_send_time`</span></span> <span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">ENGINE</span></span>=<span class="hljs-keyword"><span class="hljs-keyword">InnoDB</span></span>; Query OK, 0 rows affected (0.02 sec) Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-string"><span class="hljs-string">`ChatContactsList`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MODIFY</span></span> last_message_send_time <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">9</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; ERROR 1426 (42000): Too-big precision 9 specified for 'last_message_send_time'. Maximum is 6. Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-string"><span class="hljs-string">`ChatContactsList`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MODIFY</span></span> last_message_send_time <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; Query OK, 0 rows affected (0.09 sec) Records: 0 Duplicates: 0 Warnings: 0 Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> ChatContactsList (title, last_message_send_time) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'Chat #1'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NOW</span></span>()); Query OK, 1 row affected (0.03 sec) Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ChatContactsList; +<span class="hljs-comment"><span class="hljs-comment">---------+---------+-------------------------+ | chat_id | title | last_message_send_time | +---------+---------+-------------------------+ | 1 | Chat #1 | 2019-09-22 22:23:15.000 | +---------+---------+-------------------------+ 1 row in set (0.00 sec)</span></span></code> </pre> <br><p>  Dalam contoh ini, stempel waktu dari catatan yang dimasukkan memiliki fraksi nol.  Ini terjadi karena nilai input ditunjukkan ke detik terdekat.  Untuk memecahkan masalah, keakuratan nilai input harus sama dengan nilai dalam database.  Sarannya tampak jelas, tetapi relevan, karena masalah serupa dapat muncul dalam aplikasi nyata: kami dihadapkan pada situasi di mana nilai input memiliki tiga tempat desimal dan enam disimpan dalam database. </p><br><p>  Cara termudah untuk mencegah masalah ini terjadi adalah dengan menggunakan nilai input dengan presisi maksimum (hingga mikrodetik).  Dalam hal ini, saat menulis data ke tabel, waktu akan dibulatkan ke akurasi yang diperlukan.  Ini adalah situasi yang benar-benar normal yang tidak akan menyebabkan peringatan: </p><br><pre> <code class="sql hljs">Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> ChatContactsList <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> last_message_send_time=<span class="hljs-string"><span class="hljs-string">"2019-09-22 22:23:15.2345"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> chat_id=<span class="hljs-number"><span class="hljs-number">1</span></span>; Query OK, 1 row affected (0.00 sec) Rows matched: 1 Changed: 1 Warnings: 0 Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ChatContactsList; +<span class="hljs-comment"><span class="hljs-comment">---------+---------+-------------------------+ | chat_id | title | last_message_send_time | +---------+---------+-------------------------+ | 1 | Chat #1 | 2019-09-22 22:23:15.235 | +---------+---------+-------------------------+ 1 row in set (0.00 sec)</span></span></code> </pre> <br><p>  Saat menggunakan inisialisasi otomatis dan pembaruan otomatis kolom TIMESTAMP menggunakan struktur formulir <code>DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</code> penting bahwa nilai memiliki ketepatan yang sama dengan kolom itu sendiri: </p><br><pre> <code class="sql hljs">Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> ChatContactsList <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">updated</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CURRENT_TIMESTAMP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CURRENT_TIMESTAMP</span></span>; ERROR 1067 (42000): Invalid default value for 'updated' Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> ChatContactsList <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">updated</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CURRENT_TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CURRENT_TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">6</span></span>); ERROR 1067 (42000): Invalid default value for 'updated' Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> ChatContactsList <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">updated</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CURRENT_TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CURRENT_TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>); Query OK, 0 rows affected (0.07 sec) Records: 0 Duplicates: 0 Warnings: 0 Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> ChatContactsList <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> last_message_send_time=<span class="hljs-string"><span class="hljs-string">'2019-09-22 22:22:22'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> chat_id=<span class="hljs-number"><span class="hljs-number">1</span></span>; Query OK, 0 rows affected (0.00 sec) Rows matched: 1 Changed: 0 Warnings: 0 Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ChatContactsList; +<span class="hljs-comment"><span class="hljs-comment">---------+---------+-------------------------+-------------------------+ | chat_id | title | last_message_send_time | updated | +---------+---------+-------------------------+-------------------------+ | 1 | Chat #1 | 2019-09-22 22:22:22.000 | 2019-09-22 22:26:39.968 | +---------+---------+-------------------------+-------------------------+ 1 row in set (0.00 sec)</span></span></code> </pre> <br><p>  Fungsi MySQL untuk bekerja dari waktu ke waktu mendukung bekerja dengan bagian fraksional dari unit ukuran.  Saya tidak akan mencantumkan semuanya (saya sarankan lihat di dokumentasi), tetapi saya akan memberikan beberapa contoh: </p><br><pre> <code class="sql hljs">Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOW</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">NOW</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">NOW</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>) + <span class="hljs-built_in"><span class="hljs-built_in">INTERVAL</span></span> <span class="hljs-number"><span class="hljs-number">7.5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SECOND</span></span>; +<span class="hljs-comment"><span class="hljs-comment">------------------------+--------------------------+------------------------------+ | NOW(2) | NOW(4) | NOW(4) + INTERVAL 7.5 SECOND | +------------------------+--------------------------+------------------------------+ | 2019-09-22 21:12:23.31 | 2019-09-22 21:12:23.3194 | 2019-09-22 21:12:30.8194 | +------------------------+--------------------------+------------------------------+ 1 row in set (0.00 sec) Test&gt; SELECT SUBTIME(CURRENT_TIME(6), CURRENT_TIME(3)), CURRENT_TIME(6), CURRENT_TIME(3); +-------------------------------------------+-----------------+-----------------+ | SUBTIME(CURRENT_TIME(6), CURRENT_TIME(3)) | CURRENT_TIME(6) | CURRENT_TIME(3) | +-------------------------------------------+-----------------+-----------------+ | 00:00:00.000712 | 21:12:50.793712 | 21:12:50.793 | +-------------------------------------------+-----------------+-----------------+ 1 row in set (0.00 sec)</span></span></code> </pre> <br><p>  Masalah utama yang terkait dengan penggunaan bagian fraksional detik dalam query SQL adalah ketidakkonsistenan akurasi dalam perbandingan ( <code>&gt;</code> , <code>&lt;</code> , <code>BETWEEN</code> ).  Anda dapat menjumpainya jika data dalam database memiliki satu akurasi, dan dalam kueri - yang lain.  Berikut adalah contoh kecil yang menggambarkan masalah ini: </p><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">#         Test&gt; INSERT INTO ChatContactsList (title, last_message_send_time) VALUES ('Chat #2', '2019-09-22 21:16:39.123456'); Query OK, 0 row affected (0.00 sec) Test&gt; SELECT chat_id, title, last_message_send_time FROM ChatContactsList WHERE title='Chat #2'; +---------+---------+-------------------------+ | chat_id | title | last_message_send_time | +---------+---------+-------------------------+ | 2 | Chat #2 | 2019-09-22 21:16:39.123 | &lt;-     - ,    +---------+---------+-------------------------+ 1 row in set (0.00 sec) Test&gt; SELECT title, last_message_send_time FROM ChatContactsList WHERE last_message_send_time &gt;= '2019-09-22 21:16:39.123456'; &lt;-    ,    INSERT- +---------+-------------------------+ | title | last_message_send_time | +---------+-------------------------+ | Chat #1 | 2019-09-22 22:22:22.000 | +---------+-------------------------+ 1 row in set (0.00 sec) &lt;- Chat #2   - ,     ,    </span></span></code> </pre> <br><p>  Dalam contoh ini, keakuratan nilai dalam kueri lebih tinggi daripada keakuratan nilai dalam database, dan masalah terjadi "di perbatasan dari atas."  Dalam situasi yang berlawanan (jika nilai input memiliki akurasi lebih rendah dari nilai dalam database) tidak akan ada masalah - MySQL akan membawa nilai ke akurasi yang diinginkan di INSERT dan SELECT: </p><br><pre> <code class="sql hljs">Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> ChatContactsList (title, last_message_send_time) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'Chat #3'</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-09-03 21:20:19.1'</span></span>); Query OK, 1 row affected (0.00 sec) Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> title, last_message_send_time <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ChatContactsList <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> last_message_send_time &lt;= <span class="hljs-string"><span class="hljs-string">'2019-09-03 21:20:19.1'</span></span>; +<span class="hljs-comment"><span class="hljs-comment">---------+-------------------------+ | title | last_message_send_time | +---------+-------------------------+ | Chat #3 | 2019-09-03 21:20:19.100 | +---------+-------------------------+ 1 row in set (0.00 sec)</span></span></code> </pre> <br><p>  Konsistensi akurasi nilai harus selalu diingat ketika bekerja dengan waktu presisi tinggi.  Jika masalah batas seperti itu sangat penting bagi Anda, maka Anda perlu memastikan bahwa kode dan basis data bekerja dengan jumlah tempat desimal yang sama. </p><br><div class="spoiler">  <b class="spoiler_title">Pikiran memilih akurasi dalam kolom dengan bagian pecahan detik</b> <div class="spoiler_text"><p>  Jumlah ruang yang ditempati oleh bagian fraksional dari satuan waktu tergantung pada jumlah karakter dalam kolom.  Tampaknya wajar untuk memilih makna yang akrab: tiga atau enam tempat desimal.  Tetapi dalam kasus tiga karakter, itu tidak begitu sederhana.  Bahkan, MySQL menggunakan satu byte untuk menyimpan dua tempat desimal: </p><br><blockquote><div class="scrollable-table"><table><thead><tr><th>  Presisi detik pecahan </th><th>  Persyaratan penyimpanan </th></tr></thead><tbody><tr><td>  0 </td><td>  0 byte </td></tr><tr><td>  1, 2 </td><td>  1 byte </td></tr><tr><td>  3, 4 </td><td>  2 byte </td></tr><tr><td>  5, 6 </td><td>  3 byte </td></tr></tbody></table></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Persyaratan Penyimpanan Tipe Tanggal dan Waktu</a> </blockquote><p>  Ternyata jika Anda memilih tiga tempat desimal, maka Anda tidak sepenuhnya memanfaatkan ruang yang ditempati dan untuk overhead yang sama Anda bisa mengambil empat karakter.  Secara umum, saya sarankan Anda selalu menggunakan jumlah karakter genap dan, jika perlu, "potong" karakter yang tidak perlu saat menghasilkan.  Pilihan yang ideal adalah tidak serakah dan mengambil enam tempat desimal.  Dalam kasus terburuk (dengan tipe DATETIME) kolom ini akan menempati 8 byte, yaitu, sama dengan integer di kolom BIGINT. </p></div></div><br><p>  Lihat juga: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Detik Pecahan dalam Nilai Waktu"</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">‚ÄúInisialisasi dan Pembaruan Otomatis untuk TIMESTAMP dan DATETIME‚Äù</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Tanggal dan Fungsi Waktu"</a> . </li></ul><br><h2 id="rabota-so-vremenem-vysokoy-tochnosti-v-php">  Bekerja dengan waktu presisi tinggi di PHP </h2><br><p>  Tidak cukup memiliki waktu presisi tinggi dalam basis data - Anda harus dapat bekerja dengannya dalam kode program Anda.  Pada bagian ini saya akan berbicara tentang tiga poin utama: </p><br><ol><li>  Menerima dan memformat waktu: Saya akan menjelaskan cara mendapatkan cap waktu sebelum memasukkannya ke dalam database, mendapatkannya dari sana dan melakukan semacam manipulasi. </li><li>  Bekerja dengan waktu dalam PDO: Saya akan menunjukkan kepada Anda contoh bagaimana PHP mendukung waktu pemformatan di pustaka database. </li><li>  Bekerja dengan waktu dalam kerangka kerja: Saya akan berbicara tentang menggunakan waktu dalam migrasi untuk mengubah struktur basis data. </li></ol><br><h3 id="poluchenie-i-formatirovanie-vremeni">  Mendapatkan dan memformat waktu </h3><br><p>  Ketika bekerja dengan waktu, ada beberapa operasi dasar yang perlu Anda lakukan: </p><br><ul><li>  mendapatkan titik saat ini dalam waktu; </li><li>  mendapatkan momen dalam waktu dari beberapa string yang diformat; </li><li>  menambahkan periode ke titik waktu (atau mengurangi periode); </li><li>  mendapatkan string yang diformat untuk suatu titik waktu. </li></ul><br><p>  Pada bagian ini saya akan memberi tahu Anda apa kemungkinan untuk melakukan operasi ini dalam PHP. </p><br><p>  Cara pertama adalah bekerja dengan <strong>cap waktu sebagai angka</strong> .  Dalam hal ini, dalam kode PHP kami bekerja dengan variabel numerik, yang kami operasikan melalui fungsi-fungsi seperti <code>time</code> , <code>date</code> , <code>strtotime</code> .  Metode ini tidak dapat digunakan untuk bekerja dengan waktu presisi tinggi, karena dalam semua fungsi ini cap waktu adalah bilangan bulat (yang berarti bahwa bagian fraksional di dalamnya akan hilang). </p><br><p>  Berikut adalah tanda tangan dari fungsi-fungsi utama dari dokumentasi resmi: </p><br><blockquote> <code>time ( void ) : int</code> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.php.net/manual/ru/function.time.php</a> <br><br> <code>strtotime ( string $time [, int $now = time() ] ) : int</code> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://php.net/manual/ru/function.strtotime.php</a> <br><br> <code>date ( string $format [, int $timestamp = time() ] ) : string</code> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://php.net/manual/ru/function.date.php</a> <br><br> <code>strftime ( string $format [, int $timestamp = time() ] ) : string</code> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.php.net/manual/ru/function.strftime.php</a> </blockquote><br><div class="spoiler">  <b class="spoiler_title">Poin yang menarik tentang fungsi tanggal</b> <div class="spoiler_text"><p>  Meskipun tidak mungkin untuk melewatkan bagian pecahan dari satu detik ke input dari fungsi-fungsi ini, di garis templat pemformatan diteruskan ke input dari fungsi <code>date</code> , Anda dapat mengatur karakter untuk menampilkan milidetik dan mikrodetik.  Saat memformat, nol akan selalu dikembalikan pada tempatnya. </p><br><div class="scrollable-table"><table><thead><tr><th>  Karakter dalam format string </th><th>  Deskripsi </th><th>  Contoh Nilai Pengembalian </th></tr></thead><tbody><tr><td>  kamu </td><td>  Microseconds (ditambahkan dalam PHP 5.2.2).  Perhatikan bahwa tanggal () akan selalu mengembalikan 000000, sebagai  dibutuhkan parameter integer, sedangkan DateTime :: format () mendukung mikrodetik jika DateTime dibuat dengan mereka. </td><td>  Misalnya: 654321 </td></tr><tr><td>  v </td><td>  Milidetik (ditambahkan dalam PHP 7.0.0).  Pernyataan itu sama dengan untuk Anda. </td><td>  Misalnya: 654 </td></tr></tbody></table></div><br><p>  Contoh: </p><br><pre> <code class="php hljs">$now = time(); <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> date(<span class="hljs-string"><span class="hljs-string">'Ymd H:i:s.u'</span></span>, $now); <span class="hljs-comment"><span class="hljs-comment">// 2019-09-11 21:27:18.000000 print date('Ymd H:i:s.v', $now); // 2019-09-11 21:27:18.000</span></span></code> </pre> </div></div><br><p>  Juga untuk metode ini termasuk <code>hrtime</code> <code>microtime</code> dan <code>hrtime</code> , yang memungkinkan Anda untuk mendapatkan <code>hrtime</code> waktu dengan bagian fraksional untuk momen saat ini.  Masalahnya adalah bahwa tidak ada cara yang siap pakai untuk memformat label seperti itu dan mendapatkannya dari serangkaian format tertentu.  Ini dapat diselesaikan dengan mengimplementasikan fungsi-fungsi ini secara independen, tetapi saya tidak akan mempertimbangkan opsi seperti itu. </p><br><blockquote>  Jika Anda hanya perlu bekerja dengan timer, maka pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HRTime</a> adalah pilihan yang baik, yang saya tidak akan pertimbangkan secara lebih rinci karena keterbatasan penggunaannya.  Saya hanya bisa mengatakan bahwa itu memungkinkan Anda untuk bekerja dengan waktu ke nanosecond dan menjamin monoton timer, yang menghilangkan beberapa masalah yang dapat ditemui ketika bekerja dengan perpustakaan lain. </blockquote><p>  Untuk sepenuhnya bekerja dengan bagian pecahan sedetik, Anda harus menggunakan modul <strong>DateTime</strong> .  Dengan pemesanan tertentu, ini memungkinkan Anda untuk melakukan semua operasi yang tercantum di atas: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//    : $time = new \DateTimeImmutable(); //      : $time = new \DateTimeImmutable('2019-09-12 21:32:43.908502'); $time = \DateTimeImmutable::createFromFormat('Ymd H:i:s.u', '2019-09-12 21:32:43.9085'); // / : $period = \DateInterval::createFromDateString('5 seconds'); $timeBefore = $time-&gt;add($period); $timeAfter = $time-&gt;sub($period); //      : print $time-&gt;format('Ymd H:i:s.v'); // '2019-09-12 21:32:43.908' print $time-&gt;format("Ymd H:i:su"); // '2019-09-12 21:32:43.908502'</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Poin tidak jelas saat menggunakan `DateTimeImmutable :: createFromFormat`</b> <div class="spoiler_text"><p>  Huruf <code>u</code> dalam format string berarti mikrodetik, tetapi juga berfungsi dengan benar jika bagian fraksional kurang presisi.  Selain itu, ini adalah satu-satunya cara untuk menentukan bagian pecahan detik dalam string format.  Contoh: </p><br><pre> <code class="php hljs">$time = \DateTimeImmutable::createFromFormat(<span class="hljs-string"><span class="hljs-string">'Ymd H:i:s.u'</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-09-12 21:32:43.9085'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// =&gt;   DateTimeImmutable    2019-09-12 21:32:43.908500 $time = \DateTimeImmutable::createFromFormat('Ymd H:i:s.u', '2019-09-12 21:32:43.90'); // =&gt;   DateTimeImmutable    2019-09-12 21:32:43.900000 $time = \DateTimeImmutable::createFromFormat('Ymd H:i:s.u', '2019-09-12 21:32:43'); // =&gt;  false</span></span></code> </pre> </div></div><br><p>  Masalah utama dari modul ini adalah ketidaknyamanan ketika bekerja dengan interval yang mengandung detik fraksional (atau bahkan ketidakmungkinan kerja seperti itu).  Kelas <code>\DateInterval</code> meskipun berisi bagian pecahan dari satu detik yang akurat untuk enam tempat desimal yang sama, Anda hanya dapat menginisialisasi bagian fraksional ini melalui <code>DateTime::diff</code> .  Konstruktor kelas DateInterval dan metode pabrik <code>\DateInterval::createFromDateString</code> hanya dapat bekerja dengan seluruh detik dan tidak memungkinkan untuk menentukan bagian fraksional: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//     -   $buggyPeriod1 = new \DateInterval('PT7.500S'); //       ,    $buggyPeriod2 = \DateInterval::createFromDateString('2 minutes 7.5 seconds'); print $buggyPeriod2-&gt;format('%R%H:%I:%S.%F') . PHP_EOL; //  "+00:02:00.000000"</span></span></code> </pre> <br><p>  Masalah lain mungkin muncul ketika menghitung perbedaan antara dua titik dalam waktu menggunakan metode <code>\DateTimeImmutable::diff</code> .  Dalam PHP sebelum versi 7.2.12, ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bug</a> karena bagian pecahan dari yang kedua ada secara terpisah dari digit lainnya dan dapat menerima tanda mereka sendiri: </p><br><pre> <code class="php hljs">$timeBefore = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \DateTimeImmutable(<span class="hljs-string"><span class="hljs-string">'2019-09-12 21:20:19.987654'</span></span>); $timeAfter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \DateTimeImmutable(<span class="hljs-string"><span class="hljs-string">'2019-09-14 12:13:14.123456'</span></span>); $diff = $timeBefore-&gt;diff($timeAfter); <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $diff-&gt;format(<span class="hljs-string"><span class="hljs-string">'%R%a days %H:%I:%S.%F'</span></span>) . PHP_EOL; <span class="hljs-comment"><span class="hljs-comment">//  PHP  7.2.12+   "+1 days 14:52:54.135802" //       "+1 days 14:52:55.-864198"</span></span></code> </pre> <br><p>  Secara umum, saya menyarankan Anda untuk berhati-hati ketika bekerja dengan interval dan hati-hati menutup kode tersebut dengan tes. </p><br><p>  Lihat juga: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Tanggal dan waktu"</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Fungsi Hrtime."</a> </li></ul><br><h3 id="rabota-so-vremenem-vysokoy-tochnosti-v-pdo">  Bekerja dengan waktu presisi tinggi di PDO </h3><br><p>  PDO dan mysqli adalah dua antarmuka utama untuk query database MySQL dari kode PHP.  Dalam konteks percakapan tentang waktu, mereka mirip satu sama lain, jadi saya hanya akan berbicara tentang salah satunya - PDO. </p><br><p>  Saat bekerja dengan database di PDO, waktu muncul di dua tempat: </p><br><ul><li>  sebagai parameter yang diteruskan ke kueri yang dieksekusi; </li><li>  sebagai nilai yang datang sebagai respons terhadap pertanyaan SELECT. </li></ul><br><p>  Merupakan praktik yang baik untuk meneruskan placeholder ketika menyampaikan parameter ke permintaan.  Placeholder dapat mentransfer nilai dari serangkaian tipe yang sangat kecil: Nilai Boolean, string, dan bilangan bulat.  Tidak ada tipe yang cocok untuk tanggal dan waktu, jadi Anda harus secara manual mengonversi nilai dari objek DateTime / DateTimeImmutable kelas ke string. </p><br><pre> <code class="php hljs">$now = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \DateTimeImmutable(); $db = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \PDO(<span class="hljs-string"><span class="hljs-string">'mysql:...'</span></span>, <span class="hljs-string"><span class="hljs-string">'user'</span></span>, <span class="hljs-string"><span class="hljs-string">'password'</span></span>, [\PDO::ATTR_ERRMODE =&gt; \PDO::ERRMODE_EXCEPTION]); $stmt = $db-&gt;prepare(<span class="hljs-string"><span class="hljs-string">'INSERT INTO Test.ChatContactsList (title, last_message_send_time) VALUES (:title, :date)'</span></span>); $result = $stmt-&gt;execute([<span class="hljs-string"><span class="hljs-string">':title'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"Test #1"</span></span>, <span class="hljs-string"><span class="hljs-string">':date'</span></span> =&gt; $now-&gt;format(<span class="hljs-string"><span class="hljs-string">'Ymd H:i:s.u'</span></span>)]);</code> </pre> <br><p>  Menggunakan kode semacam itu sangat tidak nyaman, karena setiap kali Anda perlu memformat nilai yang dikirimkan.  Oleh karena itu, dalam basis kode Badoo, kami menerapkan dukungan untuk placeholder yang diketikkan dalam pembungkus kami untuk bekerja dengan database.  Dalam hal tanggal, ini sangat nyaman, karena memungkinkan Anda untuk mentransfer nilai dalam format yang berbeda (objek yang mengimplementasikan DateTimeInterface, string yang diformat atau angka dengan cap waktu), dan semua transformasi yang diperlukan dan pemeriksaan kebenaran dari nilai yang ditransfer sudah dilakukan di dalamnya.  Sebagai bonus, saat mentransfer nilai yang salah, kami segera belajar tentang kesalahan, dan tidak setelah menerima kesalahan dari MySQL saat menjalankan kueri. </p><br><p>  Mengambil data dari hasil kueri terlihat sangat sederhana.  Saat melakukan operasi ini, PDO mengembalikan data dalam bentuk string, dan dalam kode kita perlu memproses lebih lanjut hasil jika kita ingin bekerja dengan objek waktu (dan di sini kita memerlukan fungsionalitas untuk mendapatkan waktu dari string yang diformat, yang saya bicarakan di bagian sebelumnya). </p><br><pre> <code class="php hljs">$stmt = $db-&gt;prepare(<span class="hljs-string"><span class="hljs-string">'SELECT * FROM Test.ChatContactsList ORDER BY last_message_send_time DESC, chat_id DESC LIMIT 5'</span></span>); $stmt-&gt;execute(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($row = $stmt-&gt;fetch(PDO::FETCH_ASSOC)) { $row[<span class="hljs-string"><span class="hljs-string">'last_message_send_time'</span></span>] = is_null($row[<span class="hljs-string"><span class="hljs-string">'last_message_send_time'</span></span>]) ? <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \DateTimeImmutable($row[<span class="hljs-string"><span class="hljs-string">'last_message_send_time'</span></span>]); <span class="hljs-comment"><span class="hljs-comment">//  -  }</span></span></code> </pre> <br><blockquote>  Catatan <br><br>  Fakta bahwa PDO mengembalikan data sebagai string tidak sepenuhnya benar.  Saat menerima nilai, dimungkinkan untuk mengatur tipe nilai untuk kolom menggunakan metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>PDOStatement::bindColumn</code></a> .  Saya tidak membicarakan hal ini karena ada rangkaian terbatas jenis yang sama yang tidak membantu kencan. </blockquote><p>  Sayangnya, ada masalah yang harus diperhatikan.  Dalam PHP sebelum versi 7.3, ada bug karena PDO yang mana, ketika atribut <code>PDO::ATTR_EMULATE_PREPARES</code> "memotong" bagian fraksional detik ketika diterima dari database.  Detail dan contoh dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">deskripsi bug di php.net</a> .  Di PHP 7.3, kesalahan ini diperbaiki dan memperingatkan bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perubahan ini merusak kompatibilitas ke belakang</a> . </p><br><p>  Jika Anda menggunakan PHP versi 7.2 atau lebih tua dan tidak dapat memperbaruinya atau mengaktifkan <code>PDO::ATTR_EMULATE_PREPARES</code> , maka Anda dapat menyiasati bug ini dengan mengoreksi kueri SQL yang mengembalikan waktu dengan bagian fraksional sehingga kolom ini memiliki tipe string.  Ini bisa dilakukan, misalnya, seperti ini: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> *, <span class="hljs-keyword"><span class="hljs-keyword">CAST</span></span>(last_message_send_time <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CHAR</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> last_message_send_time_fixed <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ChatContactsList <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> last_message_send_time <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><p>  Masalah ini juga dapat ditemui ketika bekerja dengan modul <code>mysqli</code> : jika Anda menggunakan kueri yang disiapkan melalui panggilan ke metode <code>mysqli::prepare</code> , maka dalam PHP sebelum versi 7.3, bagian fraksional dari detik tidak akan dikembalikan.  Seperti halnya PDO, Anda dapat memperbaikinya dengan memperbarui PHP, atau melewati konversi waktu ke tipe string. </p><br><p>  Lihat juga: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Permintaan yang disiapkan dan prosedur tersimpan di PDO"</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Permintaan yang disiapkan di mysqli"</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumentasi tentang metode mysqli_stmt :: bind_param</a> (di sini jenis placeholder yang didukung dalam mysqli dijelaskan); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pool meminta ke PHP, di mana mereka memperbaiki "pemotongan" dari bagian pecahan detik</a> . </li></ul><br><h3 id="rabota-so-vremenem-vysokoy-tochnosti-v-yii-2">  Bekerja dengan waktu presisi tinggi di Yii 2 </h3><br><p>  Sebagian besar kerangka kerja modern menyediakan fungsionalitas migrasi yang memungkinkan Anda untuk menyimpan riwayat perubahan skema database dalam kode dan mengubahnya secara bertahap.  Jika Anda menggunakan migrasi dan ingin menggunakan waktu presisi tinggi, maka kerangka kerja Anda harus mendukungnya.  Untungnya, ini bekerja di luar kotak di semua kerangka kerja utama. </p><br><p>  Di bagian ini, saya akan menunjukkan bagaimana dukungan ini diimplementasikan dalam Yii (dalam contoh saya menggunakan versi 2.0.26).  Tentang Laravel, Symfony, dan lainnya, saya tidak akan menulis agar tidak membuat artikel ini tidak ada habisnya, tetapi saya akan senang jika Anda menambahkan rincian dalam komentar atau artikel baru tentang topik ini. </p><br><p>  Dalam migrasi, kami menulis kode yang menjelaskan perubahan pada skema data.  Saat membuat tabel baru, kami menjelaskan semua kolomnya menggunakan metode khusus dari kelas \ yii \ db \ Migration (mereka dideklarasikan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">baki SchemaBuilderTrait</a> ).  Metode <code>time</code> , <code>timestamp</code> dan <code>datetime</code> yang dapat mengambil nilai input akurasi bertanggung jawab untuk deskripsi kolom yang berisi tanggal dan waktu. </p><br><p>  Contoh migrasi tempat tabel baru dibuat dengan kolom waktu presisi tinggi: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">yii</span></span>\<span class="hljs-title"><span class="hljs-title">db</span></span>\<span class="hljs-title"><span class="hljs-title">Migration</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m190914_141123_create_news_table</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Migration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">up</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;createTable(<span class="hljs-string"><span class="hljs-string">'news'</span></span>, [ <span class="hljs-string"><span class="hljs-string">'id'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;primaryKey(), <span class="hljs-string"><span class="hljs-string">'title'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;string()-&gt;notNull(), <span class="hljs-string"><span class="hljs-string">'content'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;text(), <span class="hljs-string"><span class="hljs-string">'published'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;timestamp(<span class="hljs-number"><span class="hljs-number">6</span></span>), <span class="hljs-comment"><span class="hljs-comment">//     ]); } public function down() { $this-&gt;dropTable('news'); } }</span></span></code> </pre> <br><p>  Dan ini adalah contoh migrasi di mana keakuratan dalam kolom yang ada berubah: </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m190916_045702_change_news_time_precision</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Migration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">up</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;alterColumn( <span class="hljs-string"><span class="hljs-string">'news'</span></span>, <span class="hljs-string"><span class="hljs-string">'published'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;timestamp(<span class="hljs-number"><span class="hljs-number">6</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">down</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;alterColumn( <span class="hljs-string"><span class="hljs-string">'news'</span></span>, <span class="hljs-string"><span class="hljs-string">'published'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;timestamp(<span class="hljs-number"><span class="hljs-number">3</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } }</code> </pre> <br><p>       ActiveRecord     -  :          ,         DateTime-.  ,     ‚Äî    ¬´¬ª      <code>PDO::ATTR_EMULATE_PREPARES</code> .   Yii    ,        .   ,       ,        PDO. </p><br><p> . : </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">    Yii 2</a> ; </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  SchemaBuilderTrait</a> . </li></ul><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p> ,   ,     ‚Äî  ,     .                 ,    ,    . ,    ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id469615/">https://habr.com/ru/post/id469615/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id469599/index.html">Pembekalan pengembangan mesin 2D pada WinForms</a></li>
<li><a href="../id469605/index.html">Masa depan Li-Fi: polaritons, excitons, photon dan beberapa tungsten disulfide</a></li>
<li><a href="../id469607/index.html">Kesadaran manusia. Tidak dapat mentransfer salinan?</a></li>
<li><a href="../id469609/index.html">Harap online</a></li>
<li><a href="../id469613/index.html">Tentang sistem manajemen data nasional</a></li>
<li><a href="../id469617/index.html">Hancurkan monopoli Amerika di EDA. Innopolis mengambil langkah pertama</a></li>
<li><a href="../id469619/index.html">Penelitian: jika pembeli mengerti bahwa ia sedang berbicara dengan bot obrolan, maka pembelian tidak akan terjadi sama sekali</a></li>
<li><a href="../id469623/index.html">GitLab 12.3 dengan firewall aplikasi web dan analisis kinerja</a></li>
<li><a href="../id469625/index.html">Bagaimana kami mengumpulkan data tentang kampanye iklan dari platform online (jalur sulit ke produk)</a></li>
<li><a href="../id469629/index.html">Atom yang damai tidak ada di setiap rumah: pilihan tak terduga untuk sumber energi radionuklida</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>