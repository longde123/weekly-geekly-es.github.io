<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ ğŸ’‡ğŸ¾ ğŸšµğŸ½ Model generik dan metaprogram: Go, Rust, Swift, D, dan lainnya ğŸ‘¨â€ğŸ‘§â€ğŸ‘¦ â­•ï¸ ğŸ—ºï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di beberapa bidang pemrograman, adalah normal untuk ingin menulis struktur data atau algoritma yang dapat bekerja dengan elemen dari tipe yang berbeda...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Model generik dan metaprogram: Go, Rust, Swift, D, dan lainnya</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/461321/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/cs/o5/zc/cso5zcp78nxxi31mspfvdat89w4.jpeg"></div><br>  Di beberapa bidang pemrograman, adalah normal untuk ingin menulis struktur data atau algoritma yang dapat bekerja dengan elemen dari tipe yang berbeda.  Misalnya, daftar obat generik atau algoritma pengurutan yang hanya membutuhkan fungsi perbandingan.  Dalam berbagai bahasa, berbagai cara untuk memecahkan masalah ini ditawarkan: mulai dari sekadar menunjukkan fungsi umum yang sesuai (C, Go) hingga programmer ke sistem generik yang sangat kuat sehingga mereka menjadi Turing lengkap ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rust</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">C ++</a> ).  Pada artikel ini saya akan berbicara tentang sistem generik dari berbagai bahasa dan implementasinya.  Saya akan mulai dengan memecahkan masalah dalam bahasa tanpa sistem seperti itu (seperti C), dan kemudian saya akan menunjukkan bagaimana penambahan ekstensi secara bertahap mengarah ke sistem dari bahasa lain. <br><a name="habracut"></a><br>  Saya menemukan obat generik menjadi pilihan yang menarik karena mereka adalah kasus khusus sederhana dari tugas metaprogramming umum: menulis program yang dapat menghasilkan kelas dari program lain.  Sebagai bukti, saya akan menunjukkan bagaimana tiga metode metaprogramming yang berbeda dan sepenuhnya umum dapat dianggap sebagai ekstensi multi arah dalam ruang sistem generik: bahasa dinamis seperti Python, sistem makro prosedural seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Template Haskel,</a> dan kompilasi bertahap seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Zig</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Terra</a> . <br><br><h2>  Ulasan </h2><br>  Saya menggambar diagram blok semua sistem yang dijelaskan dalam artikel sehingga Anda dapat membayangkan isinya dan bagaimana sistem ini saling berhubungan: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5fa/259/577/5fa259577cd99685d90ab7912710e348.png"><br><br><h2>  Ide utama </h2><br>  Misalkan kita menulis dalam bahasa tanpa sistem generik, dan kami ingin membuat struktur data stack struktur data generik yang bekerja dengan data jenis apa pun.  Masalahnya adalah bahwa setiap definisi fungsi dan tipe hanya akan bekerja dengan data dengan ukuran yang sama dan disalin dalam satu cara, dan umumnya bekerja dengan cara yang sama. <br><br>  Ada dua cara untuk menyiasatinya: pastikan semua tipe data bertindak dengan cara yang sama dalam struktur kami, atau buat banyak salinan struktur data dengan perubahan kecil agar berfungsi dengan benar untuk setiap tipe data.  Ide-ide ini membentuk dasar dari dua kelompok besar solusi dengan obat generik: tinju dan monomorfisasi. <br><br>  Pengemasan berarti menempatkan segala sesuatu dalam satu baris ke dalam "kotak" terpadu yang bekerja dengan cara yang sama.  Ini biasanya dilakukan seperti ini: data diletakkan di heap, dan pointer ke sana ditempatkan di struktur data.  Anda dapat membuat pointer ke semua jenis yang akan bekerja dengan cara yang sama, sehingga kode yang sama akan bekerja dengan data jenis apa pun!  Namun, ini mengarah pada peningkatan konsumsi memori, pencarian dinamis, dan kehilangan cache.  Dalam C, ini berarti bahwa struktur data Anda menyimpan <code>void*</code> pointer dan hanya cache data ke dan dari <code>void*</code> (jika data tidak ada di heap, itu menempatkannya di sana). <br><br>  Monomorphization berarti berulang kali menyalin kode untuk berbagai jenis data yang ingin kami simpan.  Kemudian setiap instance kode dapat langsung menggunakan metode ukuran dan data yang berfungsi tanpa pencarian dinamis.  Dengan pendekatan ini, kode berjalan paling cepat, tetapi ukuran dan waktu kompilasi meningkat, karena kami berulang kali mengkompilasi kode yang sama dengan perubahan kecil.  Dalam C, ini sesuai dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">definisi seluruh struktur data sebagai makro</a> , diikuti dengan pemanggilannya untuk setiap tipe data. <br><br>  Secara umum, selama kompilasi, kode mengkompilasi lebih cepat, tetapi kinerjanya dapat memburuk selama eksekusi, sementara selama monomorphization kami menghasilkan kode cepat, tetapi butuh lebih banyak waktu untuk mengkompilasi dan mengoptimalkan semua contoh kode.  Perbedaan lainnya adalah ketika ekstensi kemasan memungkinkan Anda membuat perilaku yang lebih dinamis dari kode yang dapat dieksekusi, dan monomorfisasi memungkinkan Anda untuk secara lebih fleksibel memisahkan berbagai contoh kode generik.  Perlu juga dicatat bahwa dalam beberapa program besar, manfaat monomorfisasi dapat diimbangi dengan meleset dalam cache instruksi tambahan dari kode yang dihasilkan. <br><br>  Setiap skema yang dijelaskan untuk bekerja dengan obat generik dapat diperluas ke arah yang berbeda, jika Anda memerlukan lebih banyak fitur atau keamanan, dan penulis berbagai bahasa telah menghasilkan solusi yang sangat menarik.  Sebagai contoh, kedua pendekatan dapat digunakan di Rust dan C #! <br><br><h2>  Pengepakan </h2><br>  Mari kita mulai dengan contoh kemasan dasar di Go: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Stack <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { values []<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(this *Stack)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { this.values = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(this.values, value) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(this *Stack)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{} { x := this.values[<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(this.values)<span class="hljs-number"><span class="hljs-number">-1</span></span>] this.values = this.values[:<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(this.values)<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x }</code> </pre> <br>  Juga, kemasan digunakan dalam C ( <code>void*</code> ), Go ( <code>interface{}</code> ), Java pra-generik ( <code>Object</code> ) dan Objective-C ( <code>id</code> ) pra-generik. <br><br><h2>  Generik yang Dikemas dengan Jenis Penghancuran </h2><br>  Metode pengemasan utama memiliki kelemahan: <br><br><ul><li>  Bergantung pada bahasanya, kita sering harus memberikan nilai ke atau dari tipe yang benar setiap kali kita membaca atau menulis ke struktur data. <br></li><li>  Tidak ada yang mencegah kita memasukkan elemen dari tipe yang berbeda ke dalam struktur, yang dapat memancing bug yang terlihat seperti macet selama eksekusi kode. <br></li></ul><br>  Kedua masalah dapat diselesaikan dengan menambahkan obat generik ke sistem jenis fungsionalitas, sambil menggunakan metode pengemasan utama dengan cara yang sama seperti sebelumnya selama eksekusi kode.  Pendekatan ini sering disebut tipe erasure, karena tipe dalam sistem generik ditimpa dan menjadi satu tipe di bawah tenda (seperti <code>Object</code> ). <br><br>  Java dan Objective-C mulai dengan kemasan biasa, dan kemudian memperoleh alat bahasa untuk generik dengan tipe mashing, demi kompatibilitas, menggunakan tipe koleksi yang sama seperti sebelumnya, tetapi dengan parameter opsional tipe generik.  Pertimbangkan contoh dari artikel Wikipedia tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">obat generik di Jawa</a> : <br><br><pre> <code class="java hljs">List v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); v.add(<span class="hljs-string"><span class="hljs-string">"test"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// A String that cannot be cast to an Integer Integer i = (Integer)v.get(0); // Run time error List&lt;String&gt; v = new ArrayList&lt;String&gt;(); v.add("test"); Integer i = v.get(0); // (type error) compilation-time error</span></span></code> </pre><br><h3>  Turunan Generik Paket dengan Kinerja Terpadu </h3><br>  OCaml lebih lanjut mengembangkan gagasan pandangan terpadu.  Tidak ada tipe primitif yang membutuhkan penempatan kemasan tambahan (karena sebuah <code>int</code> harus berubah menjadi <code>Integer</code> untuk masuk ke dalam <code>ArrayList</code> di Jawa), karena semuanya sudah dikemas atau diwakili oleh nilai integer ukuran pointer, yaitu semuanya cocok menjadi satu kata mesin.  Tetapi ketika pengumpul sampah melihat data yang disimpan dalam struktur generik, ia perlu membedakan pointer dari angka, sehingga angka-angka tersebut ditandai dengan satu bit, ditempatkan di mana pointer yang tepat tidak memiliki satu bit, meninggalkan kisaran hanya 31 atau 63 bit. <br><br>  OCaml juga memiliki sistem inferensi tipe, sehingga Anda dapat menulis suatu fungsi dan kompiler akan menampilkan tipe generik yang paling cocok jika Anda tidak membubuhi keterangan, dan fungsi tersebut akan terlihat seperti itu adalah bahasa yang diketik secara dinamis: <br><br><pre> <code class="plaintext hljs">let first (head :: tail) = head (* inferred type: 'a list -&gt; 'a *)</code> </pre> <br>  Tipe yang diberikan dapat disebut "fungsi dari daftar elemen tipe <code>'a</code> menjadi sesuatu dengan tipe <code>'a</code> ".  Ini berarti bahwa tipe pengembalian akan sama dengan tipe daftar, dan itu bisa berupa tipe apa pun. <br><br><h2>  Antarmuka </h2><br>  Keterbatasan lain dari kemasan konvensional adalah jenis kemasannya <i>benar</i> - <i>benar</i> buram.  Ini bukan masalah untuk struktur data seperti tumpukan, tetapi alat seperti pengurutan fungsi generik memerlukan fitur tambahan, seperti fungsi perbandingan tipe-spesifik.  Ada banyak cara untuk mengimplementasikan ini dalam runtime dan mencerminkan dalam bahasa, secara teknis ini adalah arah yang berbeda, dan Anda dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menerapkan bahasa yang sama dengan beberapa pendekatan serupa</a> .  Namun, fitur-fitur dari bahasa yang berbeda memengaruhi implementasinya, dan hanya dengan demikian ekstensi meningkatkan kekuatan implementasi yang dipilih.  Ini berarti bahwa ada dua keluarga bahasa berdasarkan pendekatan yang berbeda untuk runtime: tabel metode virtual (vtables) dan transfer kamus. <br><br><h3>  Tabel Metode Antarmuka </h3><br>  Jika kita ingin menyediakan fungsi tipe-spesifik, mengikuti strategi pengemasan demi pekerjaan terpadu dengan segalanya, maka cukup memiliki cara terpadu untuk menemukan fungsi serupa yang perlu kita dapatkan dari objek.  Pendekatan ini disebut "tabel metode virtual" (vtables, tabel metode virtual), meskipun tidak ada yang menggunakan nama lengkap.  Diimplementasikan sebagai berikut: pada nol offset di setiap objek struktur generik, ada pointer ke tabel pointer fungsi dengan sirkuit yang konsisten.  Dalam tabel ini, kode umum mencari pointer untuk mengetik fungsi-fungsi spesifik dengan mengindeks pointer spesifik pada offset tetap. <br><br>  Ini adalah bagaimana tipe <code>interface</code> diimplementasikan dalam Go dan <code>dyn trait</code> objects di Rust.  Saat Anda melemparkan sebuah tipe ke tipe antarmuka dari apa yang diterapkannya, pembungkus dibuat untuk antarmuka yang berisi pointer ke objek sumber dan pointer ke vtable fungsi tipe-spesifik.  Tetapi ini membutuhkan tingkat tambahan dari pengalamatan pointer secara tidak langsung dan skema lain.  Oleh karena itu, pengurutan dalam Go menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">antarmuka untuk wadah dengan metode Swap</a> , dan tidak mengambil sepotong antarmuka Sebanding, karena ini akan membutuhkan menempatkan sepotong memori yang sama sekali baru dari jenis antarmuka yang akan diurutkan alih-alih potongan asli! <br><br><h3>  Pemrograman berorientasi objek </h3><br>  OOP adalah properti bahasa yang memanfaatkan kemampuan tabel tipe virtual.  Alih-alih memisahkan objek antarmuka dengan vtables, bahasa OOP seperti Java cukup menyisipkan pointer ke tabel jenis virtual di awal setiap objek.  Bahasa seperti Java memiliki sistem warisan dan antarmuka yang dapat sepenuhnya diimplementasikan menggunakan tabel objek tipe virtual ini. <br><br>  Selain menyediakan fitur-fitur tambahan, menanamkan vtable di setiap objek memecahkan masalah kebutuhan untuk membangun tipe antarmuka baru dengan pengalamatan tidak langsung (tipuan).  Tidak seperti Go, di Java <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">, fungsi sortir</a> dapat menerapkan antarmuka <code>Comparable</code> dengan tipe yang diimplementasikan. <br><br><h3>  Refleksi </h3><br>  Jika Anda memiliki tabel tipe virtual, maka tidak akan sulit bagi Anda untuk memaksa kompiler untuk menghasilkan tabel dari tipe informasi lain, misalnya, nama bidang, tipe, dan lokasi.  Ini akan memungkinkan akses ke semua data jenis ini menggunakan kode yang dapat melihat semua data dari jenis lain.  Perilaku ini dapat digunakan untuk menambahkan "refleksi" ke bahasa, yang memungkinkan serialisasi dan tampilan yang indah dari jenis sewenang-wenang.  Refleksi, sebagai perpanjangan dari paradigma pengemasan, memiliki kelemahan: untuk itu, hanya satu salinan kode yang cukup, tetapi Anda perlu melakukan banyak pencarian dinamis, yang mengurangi kecepatan serialisasi. <br><br>  Bahasa yang menggunakan refleksi untuk serialisasi dan fungsi lainnya: Java, C # dan Go. <br><br><h3>  Bahasa yang diketik secara dinamis </h3><br>  Refleksi adalah alat yang sangat kuat yang memungkinkan Anda untuk menyelesaikan banyak tugas pemrograman metap berbeda.  Tetapi itu tidak memungkinkan Anda untuk membuat tipe baru atau mengedit informasi tentang tipe nilai yang ada.  Jika kami menambahkan fitur ini dan membuat akses data dan sintaks modifikasi menggunakan refleksi secara default, kami mendapatkan bahasa yang diketik secara dinamis!  Fleksibilitas yang luar biasa dari metaprogramming dalam bahasa seperti Python dan Ruby telah muncul berkat sistem refleksi yang efektif dan kuat yang digunakan untuk menyelesaikan masalah. <br><br>  Anda bisa mengatakan: "Tapi bahasa dinamis tidak berfungsi seperti itu, mereka hanya mengimplementasikan semuanya menggunakan tabel hash!"  Tabel hash hanyalah struktur data yang bagus untuk membuat tabel yang dapat diedit dengan informasi tipe.  Selain itu, beberapa penerjemah, seperti CPython, bekerja dengan cara ini.  Dalam JIT berkinerja tinggi, katakanlah V8, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ada banyak tabel tipe virtual dan</a> informasi refleksi.  Di V8, kelas tersembunyi (vtable dan informasi refleksi) dan struktur objek mirip dengan apa yang dapat Anda lihat di Java VM, dengan kemampuan untuk mengganti objek dengan tabel tipe virtual baru saat runtime.  Ini bukan kebetulan, karena tidak ada kebetulan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pencipta V8</a> digunakan untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bekerja pada Java VM kinerja tinggi</a> . <br><br><h3>  Transfer Kamus </h3><br>  Cara lain untuk mengimplementasikan antarmuka dinamis adalah mentransfer tabel dengan pointer fungsi yang diperlukan ke fungsi generik yang membutuhkannya.  Ini agak mirip dengan membangun objek antarmuka berbentuk Go di tempat panggilan, hanya dalam kasus kami tabel dilewatkan sebagai argumen tersembunyi, dan tidak dikemas ke dalam bundel sebagai salah satu argumen yang ada. <br><br>  Pendekatan ini digunakan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kelas tipe di Haskell</a> , meskipun GHC memungkinkan Anda untuk melakukan beberapa jenis monomorphization menggunakan inlining dan spesialisasi.  OCaml menggunakan transfer kamus dengan argumen eksplisit dalam bentuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">modul kelas satu</a> , tetapi telah diusulkan untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menambah kemampuan untuk membuat parameter implisit</a> . <br><br><h3>  Meja saksi di Swift </h3><br>  Penulis Swift menggunakan solusi yang menarik: mentransfer kamus, serta menempatkan data pada ukuran jenis dan cara memindahkan, menyalin, dan melepaskannya ke dalam tabel, memungkinkan Anda untuk memberikan semua informasi yang diperlukan untuk pekerjaan terpadu dengan jenis apa pun tanpa mengemasnya.  Dengan demikian, Swift dapat mengimplementasikan obat generik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tanpa monomorfisasi dan penempatan dalam memori dalam representasi terpadu dari</a> semua entitas!  Ya, Anda harus membayar untuk pencarian dinamis, seperti karakteristik seluruh keluarga yang menggunakan kemasan, tetapi menghemat sumber daya untuk penempatan dalam memori, konsumsi dan inkonsistensi cache.  Menggunakan fungsi yang <a href="">dijelaskan sebagai @inlinable</a> , kompiler Swift juga dapat mengkhususkan (monomorf) dan inline generik di dalam modul atau antar modul untuk menghindari biaya yang disebutkan.  Mungkin penilaian heuristik dari efek pada ukuran kode digunakan. <br><br>  Ini juga menjelaskan bagaimana Swift dapat <a href="">menerapkan stabilitas ABI</a> , sambil tetap memungkinkan Anda untuk menambah dan mendistribusikan kembali bidang dalam struktur, meskipun penulis menyediakan atribut <code>@frozen</code> untuk menolak pencarian dinamis untuk kinerja yang lebih baik. <br><br><h3>  Analisis Jenis Intensional </h3><br>  Ada cara lain untuk mengimplementasikan antarmuka untuk tipe paket.  Kami menambahkan pengenal tipe ke bagian tertentu dari objek, mengikuti contoh dari pointer vtable, dan kemudian menghasilkan fungsi untuk setiap metode antarmuka yang memiliki ekspresi <code>switch</code> besar untuk semua jenis yang menerapkan metode ini dan meneruskannya ke metode spesifik tipe yang benar. <br><br>  Saya tidak memperingatkan untuk tidak menggunakan bahasa yang menggunakan pendekatan ini, tetapi kompiler C ++ dan mesin virtual Java bertindak dengan cara yang sama, ketika menggunakan optimasi berdasarkan profil, mereka mengetahui bahwa suatu tempat panggilan generik kebanyakan bekerja dengan objek dari tipe tertentu.  Compiler dan VM mengganti titik panggilan dengan cek untuk setiap jenis biasa, dan kemudian mengirim jenis ini secara statis, sebagai fallback menggunakan pengiriman dinamis konvensional.  Oleh karena itu, algoritma prediksi cabang dapat memprediksi cabang mana yang akan melanjutkan kode, dan akan terus mengirim instruksi menggunakan panggilan statis. <br><br><h2>  Monomorisasi </h2><br>  Ini adalah alternatif untuk pengemasan.  Dengan monomorphization, kita perlu menemukan cara untuk menghasilkan beberapa versi kode untuk setiap jenis yang ingin kita gunakan.  Compiler memiliki beberapa fase presentasi yang dilalui oleh kode, dan, secara teoritis, dapat disalin ke salah satu tahapan ini. <br><br><h3>  Pembuatan kode sumber </h3><br>  Cara termudah untuk membuat monomorf adalah menyalin pada tahap presentasi pertama: salin kode sumber!  Maka kompiler bahkan tidak harus mendukung generik, dan ini kadang-kadang dilakukan oleh pengguna bahasa C dan Go, yang kompilernya tidak memiliki dukungan seperti itu. <br><br>  Di C, Anda bisa menggunakan preprocessor dan menentukan struktur data di makro atau header dengan memasukkannya berulang kali dengan <code>#define</code> berbeda.  Go memiliki skrip seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jin</a> yang membuatnya mudah untuk menghasilkan kode. <br><br>  Kerugian dari menduplikasi kode sumber adalah bahwa, tergantung pada bahasanya, mungkin perlu untuk berurusan dengan banyak masalah dan kasus tepi, apalagi, kompiler mem-parsing dan memeriksa berkali-kali untuk jenis sebenarnya untuk kode yang sama.  Sekali lagi, tergantung pada bahasa dan alat-alatnya, metode-metode umum ini mungkin sulit untuk ditulis dan digunakan, seolah-olah di dalam makro-C setiap baris diakhiri dengan garis miring terbalik dan semua jenis dan nama fungsi harus secara manual direkatkan ke dalam pengidentifikasi mereka untuk menghindari tabrakan. <br><br><h3>  Mixin string dalam D </h3><br>  Namun, pembuatan kode memiliki kelebihan, seperti fakta bahwa Anda dapat menghasilkan kode menggunakan bahasa pemrograman lengkap, serta menggunakan tampilan yang familier bagi pengguna. <br><br>  Beberapa bahasa di mana obat generik diimplementasikan secara berbeda juga memungkinkan Anda untuk menghasilkan kode untuk kasus pemrograman metam yang lebih umum yang tidak dipertimbangkan dalam sistem generiknya, misalnya, untuk serialisasi.  Contoh yang paling dimengerti adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">string mixin dalam D</a> , yang memungkinkan kompilasi D-code dalam bentuk nilai-nilai string di tengah kompilasi, menggunakan semua fitur bahasa. <br><br><h3>  Macro prosedural karat </h3><br>  Contoh serupa, hanya dengan representasi dalam kompiler hanya pada satu tahap.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Makro prosedural karat</a> menggunakan aliran token sebagai input dan output, menyediakan utilitas untuk mengubah aliran ini menjadi string dan sebaliknya.  Keuntungan dari pendekatan ini adalah bahwa token stream dapat menyimpan informasi lokasi dari kode sumber.  Kode yang ditulis oleh pengguna, makro dapat dimasukkan sebagai token langsung dari input hingga akhir pekan.  Dan jika kode ini menyebabkan kesalahan kompilasi dalam output dari makro, kompiler akan menampilkan pesan dan secara akurat menunjuk ke file, baris dan kolom dari bagian kode yang rusak.  Tetapi jika makro menghasilkan kode yang rusak, maka pesan kesalahan akan menunjukkan panggilan makro.  Misalnya, jika Anda menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">makro yang membungkus suatu fungsi dalam mencatat panggilan</a> dan membuat kesalahan dalam menerapkan fungsi yang dibungkus, maka pesan kesalahan akan langsung menunjuk ke kesalahan dalam file, dan bukan ke kode yang dihasilkan oleh makro. <br><br><h3>  Sintaks Pohon Makro </h3><br>  Beberapa bahasa bahkan melangkah lebih jauh dan menawarkan alat untuk menggunakan dan membuat berbagai jenis pohon sintaksis abstrak dalam makro (Abstract Syntax Tree, AST).  Contohnya termasuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Template Haskell</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">makro Nim</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OCaml PPX,</a> dan hampir semua <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lisp</a> . <br><br>  Kelemahan dari makro AST adalah Anda tidak ingin memaksa pengguna untuk mempelajari banyak fungsi untuk membangun tipe AST, serta bahasa dasar.  Dalam keluarga Lisp bahasa, ini diselesaikan dengan bantuan penyederhanaan yang kuat dan korespondensi maksimum antara sintaks dan struktur AST, namun, membuat struktur tidak selalu mudah. <br><br>  Jadi, dalam semua bahasa yang saya sebutkan, dalam satu atau lain bentuk ada "kutipan" primitif yang Anda berikan sepotong kode dalam bahasa, dan yang mengembalikan pohon sintaksis.  Primitif ini dapat menggabungkan nilai-nilai pohon sintaksis menggunakan kesamaan interpolasi string.  Berikut ini adalah contoh pada Template Haskell: <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- using AST construction functions genFn :: Name -&gt; Q Exp genFn f = do x &lt;- newName "x" lamE [varP x] (appE (varE f) (varE x)) -- using quotation with $() for splicing genFn' :: Name -&gt; Q Exp genFn' f = [| \x -&gt; $(varE f) x |]</span></span></code> </pre> <br>         ,     ,   ,           .      .  ,  PPX  OCaml  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">     </a> /  ,  .  Rust  ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">parsing</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">quotation</a> ,          ,       .    Rust  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> ,    ,  </a> ! <br><br><h3>  Pola </h3><br>    â€”        .   ++  D    ,         Â« Â».        ,     ,      ,        ,   . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myMax</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a&gt;b?a:b); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pair</span></span></span><span class="hljs-class"> {</span></span> T values[<span class="hljs-number"><span class="hljs-number">2</span></span>]; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ myMax(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); Pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; p { {<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>} }; <span class="hljs-comment"><span class="hljs-comment">// This would give us a compile error inside myMax // about Pair being an invalid operand to `&gt;`: // myMax(p, p); }</span></span></code> </pre> <br>       ,                 ,        .     ,         ,     .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">D</a>     ,  ,       :       ,    ,       .    D;    <code>if</code>       ( <code>!</code>     ): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// We're going to use the isNumeric function in std.traits import std.traits; // The `if` is optional (without it you'll get an error inside like C++) // The `if` is also included in docs and participates in overloading! T myMax(T)(T a, T b) if(isNumeric!T) { return (a&gt;b?a:b); } struct Pair(T) { T[2] values; } void main() { myMax(5, 6); Pair!int p = {[5,6]}; // This would give a compile error saying that `(Pair!int, Pair!int)` // doesn't match the available instance `myMax(T a, T b) if(isNumeric!T)`: // myMax(p, p); }</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">C++20  Â«Â»</a> ,      ,           . <br><br><h3>    </h3><br>    D   ,        (compile time function evaluation)  <code>static if</code> , ,  ,    ,          - runtime-.          , ,   ,    ++    ,    . <br><br>  ,      Â«    Â». , Zig: <br><br><pre> <code class="plaintext hljs">fn Stack(comptime T: type) type { return struct { items: []T, len: usize, const Self = @This(); pub fn push(self: Self, item: T) { // ... } }; }</code> </pre> <br>  Zig            ,      ,  <code>comptime</code> .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Terra</a>    ,   . Terra â€”   Lua,     -  ,     Lua API    ,    quoting  splicing: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeStack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> struct Stack { items : &amp;T; <span class="hljs-comment"><span class="hljs-comment">-- &amp;T is a pointer to T len : int; } terra Stack:push(item : T) -- ... end return Stack end</span></span></code> </pre> <br>     Terra  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">        - (domain specific) </a> ,       <a href="">Java</a>  <a href="">Go</a>      .    Terra      runtime     ,   . <br><br><h3>   Rust </h3><br>           ,   .  ,    ,      ++,       .   ,    ,  ,     ,   .      ,                  .     Rust,     â€”  Swift  Haskell. <br><br>  Rust      Â« Â» (trait bounds). <code>Trait</code> â€”      ,    ,  .  Rust ,     -    ,   ,      ,      .   -  Rust <i></i>         .  ,           -. <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_max</span></span></span></span>&lt;T: <span class="hljs-built_in"><span class="hljs-built_in">PartialOrd</span></span>&gt;(a: T, b: T) -&gt; T { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a &gt; b { a } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { b } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pair</span></span></span></span>&lt;T&gt; { values: [T; <span class="hljs-number"><span class="hljs-number">2</span></span>], } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { my_max(<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p: Pair&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; = Pair { values: [<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>] }; <span class="hljs-comment"><span class="hljs-comment">// Would give a compile error saying that // PartialOrd is not implemented for Pair&lt;i32&gt;: // my_max(p,p); }</span></span></code> </pre> <br>           ,            .  Rust       .  Rust 2018    ,    <code>v: &amp;impl SomeTrait</code>  ,   <code>v: &amp;dyn SomeTrait</code>  .      GHC  Swift  Haskell     ,       . <br><br><h3>    </h3><br>        â€”          ,  .      ,    (placeholders)  -,           ,    .            <code>memcpy</code>   ,  !   ,       .          .         JIT,            ,     . <br><br>   ,      ,    ,   ,        ,     ,        !  ,              ,   ,       .  ,        ,              . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461321/">https://habr.com/ru/post/id461321/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461307/index.html">Kami mengundang Anda ke VK Hackathon 2019. Kelompok hadiah tahun ini adalah dua juta rubel.</a></li>
<li><a href="../id461309/index.html">Semuanya kecuali Kotlin: Andrei Breslav tentang keseimbangan gender dalam IT, emosi dan banyak lagi</a></li>
<li><a href="../id461313/index.html">Zimbra 8.8.15 LTS Dirilis</a></li>
<li><a href="../id461317/index.html">9 Prinsip untuk Membuat Aplikasi iOS yang Berkualitas</a></li>
<li><a href="../id461319/index.html">Apa yang dilakukan seorang desainer game?</a></li>
<li><a href="../id461323/index.html">Penjelasan yang dapat diakses dari algoritma runtuhnya fungsi gelombang</a></li>
<li><a href="../id461325/index.html">Victory at PHDays 9. Kami berbagi hacks kehidupan dalam tiga bagian. Bagian 3</a></li>
<li><a href="../id461327/index.html">Krisis front-end?</a></li>
<li><a href="../id461329/index.html">Segmentasi organ pernapasan otomatis</a></li>
<li><a href="../id461333/index.html">ITX5 mitap: JAVA hidup, sulap Kotlin dan tomat tomat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>