<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßúüèΩ üëèüèº ‚ô£Ô∏è Pensamiento de estilo Ramda: inmutabilidad y objetos üìü üëù üë©‚Äçüëß‚Äçüëß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Primeros pasos 
 2. Combina las funciones 
 3. Uso parcial (curry) 
 4. Programaci√≥n declarativa 
 5. Notaci√≥n por excelencia 
 6. Inmutabilidad y ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pensamiento de estilo Ramda: inmutabilidad y objetos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414337/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1. Primeros pasos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2. Combina las funciones</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3. Uso parcial (curry)</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4. Programaci√≥n declarativa</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">5. Notaci√≥n por excelencia</a> <br>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">6. Inmutabilidad y objetos.</a></strong> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">7. Inmutabilidad y matrices</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">8. lentes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">9. Conclusi√≥n</a> </p><br><p>  Esta publicaci√≥n es la sexta parte de una serie de art√≠culos sobre programaci√≥n funcional llamada Ramda Style Thinking. </p><br><p>  En la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">quinta parte,</a> hablamos sobre escribir funciones en el estilo de notaci√≥n sin sentido, donde el argumento principal con los datos para nuestra funci√≥n no se especifica expl√≠citamente. </p><br><p>  En ese momento, no pod√≠amos reescribir todas nuestras funciones en un estilo sin bits, porque no ten√≠amos algunas herramientas necesarias para esto.  Es hora de estudiarlos. <a name="habracut"></a></p><br><h2 id="chtenie-svoystv-obekta">  Lectura de propiedades de objeto </h2><br><p> Veamos nuevamente el ejemplo de la definici√≥n de personas que tienen derecho a votar, que examinamos en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">quinta parte</a> : </p><br><pre><code class="plaintext hljs">const wasBornInCountry = person =&gt; person.birthCountry === OUR_COUNTRY const wasNaturalized = person =&gt; Boolean(person.naturalizationDate) const isOver18 = person =&gt; person.age &gt;= 18 const isCitizen = either(wasBornInCountry, wasNaturalized) const isEligibleToVote = both(isOver18, isCitizen)</code> </pre> <br><p>  Como puede ver, creamos que <code>isCitizen</code> y <code>isEligibleToVote</code> , pero no podemos hacer esto con las tres primeras funciones. </p><br><p>  Como aprendimos en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cuarta parte</a> , podemos hacer que nuestras funciones sean m√°s declarativas mediante el uso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">equals</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">gte</a> .  Comencemos con esto: </p><br><pre> <code class="plaintext hljs">const wasBornInCountry = person =&gt; equals(person.birthCountry, OUR_COUNTRY) const wasNaturalized = person =&gt; Boolean(person.naturalizationDate) const isOver18 = person =&gt; gte(person.age, 18)</code> </pre> <br><p>  Para que estas funciones no tengan sentido, necesitamos una forma de construir la funci√≥n para que apliquemos la variable <code>person</code> al final de la expresi√≥n.  El problema es que necesitamos acceder a las propiedades de la <code>person</code> , ahora sabemos la √∫nica forma de hacerlo, y es imprescindible. </p><br><h2 id="prop">  apoyo </h2><br><p>  Afortunadamente, Ramda una vez m√°s viene en nuestra ayuda.  Proporciona una funci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">prop</a> para acceder a las propiedades de los objetos. </p><br><p>  Usando <code>prop</code> , podemos reescribir <code>person.birthCountry</code> para <code>prop('birthCountry', person)</code> .  Hag√°moslo: </p><br><pre> <code class="plaintext hljs">const wasBornInCountry = person =&gt; equals(prop('birthCountry', person), OUR_COUNTRY) const wasNaturalized = person =&gt; Boolean(prop('naturalizationDate', person)) const isOver18 = person =&gt; gte(prop('age', person), 18)</code> </pre> <br><p>  Wow, ahora se ve mucho peor.  Pero continuemos nuestra refactorizaci√≥n.  Cambiemos el orden de los argumentos que pasamos a <code>equals</code> para que el <code>prop</code> sea ‚Äã‚Äãel √∫ltimo.  <code>equals</code> funciona exactamente de la misma manera a la inversa, por lo que no romperemos nada: </p><br><pre> <code class="plaintext hljs">const wasBornInCountry = person =&gt; equals(OUR_COUNTRY, prop('birthCountry', person)) const wasNaturalized = person =&gt; Boolean(prop('naturalizationDate', person)) const isOver18 = person =&gt; gte(prop('age', person), 18)</code> </pre> <br><p>  A continuaci√≥n, usemos curry, la propiedad natural de <code>equals</code> y <code>gte</code> , para crear nuevas funciones a las que se aplicar√° el resultado de la llamada <code>prop</code> : </p><br><pre> <code class="plaintext hljs">const wasBornInCountry = person =&gt; equals(OUR_COUNTRY)(prop('birthCountry', person)) const wasNaturalized = person =&gt; Boolean(prop('naturalizationDate', person)) const isOver18 = person =&gt; gte(__, 18)(prop('age', person))</code> </pre> <br><p>  Todav√≠a parece la peor opci√≥n, pero sigamos.  Aprovechemos el curry nuevamente para todas las llamadas de <code>prop</code> : </p><br><pre> <code class="plaintext hljs">const wasBornInCountry = person =&gt; equals(OUR_COUNTRY)(prop('birthCountry')(person)) const wasNaturalized = person =&gt; Boolean(prop('naturalizationDate')(person)) const isOver18 = person =&gt; gte(__, 18)(prop('age')(person))</code> </pre> <br><p>  De nuevo, de alguna manera no muy.  Pero ahora vemos un patr√≥n familiar.  Todas nuestras funciones tienen la misma imagen <code>f(g(person))</code> , y como sabemos por la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">segunda parte</a> , esto es equivalente a <code>compose(f, g)(person)</code> . </p><br><p>  Apliquemos esta ventaja a nuestro c√≥digo: </p><br><pre> <code class="plaintext hljs">const wasBornInCountry = person =&gt; compose(equals(OUR_COUNTRY), prop('birthCountry'))(person) const wasNaturalized = person =&gt; compose(Boolean, prop('naturalizationDate'))(person) const isOver18 = person =&gt; compose(gte(__, 18), prop('age'))(person)</code> </pre> <br><p>  Ahora tenemos algo.  Todas nuestras funciones se ven como <code>person =&gt; f(person)</code> .  Y ya sabemos por la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">quinta parte</a> que podemos hacer que estas funciones no tengan sentido. </p><br><pre> <code class="plaintext hljs">const wasBornInCountry = compose(equals(OUR_COUNTRY), prop('birthCountry')) const wasNaturalized = compose(Boolean, prop('naturalizationDate')) const isOver18 = compose(gte(__, 18), prop('age'))</code> </pre> <br><p>  Cuando comenzamos, no era obvio que nuestros m√©todos hicieran dos cosas.  Se volvieron hacia la propiedad del objeto y prepararon algunas operaciones con su valor.  Esta refactorizaci√≥n en un estilo sin sentido lo hizo muy expl√≠cito. </p><br><p>  Echemos un vistazo a algunas de las otras herramientas que Ramda proporciona para trabajar con objetos. </p><br><h2 id="pick">  recoger </h2><br><p>  Cuando <code>prop</code> lee una propiedad de un objeto y devuelve su valor, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pick</a> lee muchas propiedades del objeto y devuelve un nuevo objeto solo con ellas. </p><br><p>  Por ejemplo, si solo necesitamos los nombres y a√±os de personas, podemos usar <code>pick(['name','age'], person)</code> . </p><br><h2 id="has">  tiene </h2><br><p>  Si solo queremos saber que nuestro objeto tiene una propiedad, sin leer su valor, podemos usar la funci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">has</a> para verificar sus propiedades, as√≠ como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hasIn</a> para verificar la cadena del prototipo: <code>has('name', person)</code> . </p><br><h2 id="path">  camino </h2><br><p>  Donde <code>prop</code> una propiedad de objeto, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ruta se</a> adentra en objetos anidados.  Por ejemplo, queremos extraer el c√≥digo postal de una estructura m√°s profunda: <code>path(['address','zipCode'], person)</code> . </p><br><p>  Tenga en cuenta que el <code>path</code> m√°s indulgente que el <code>prop</code> .  <code>path</code> volver√° <code>undefined</code> si algo en el camino (incluido el argumento original) es <code>null</code> o <code>undefined</code> , mientras que <code>prop</code> causar√° un error en tales situaciones. </p><br><h2 id="propor--pathor">  propOr / pathOr </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">propOr</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pathOr</a> son similares a <code>prop</code> y <code>path</code> combinados con <code>defaultTo</code> .  Le proporcionan la capacidad de especificar un valor predeterminado para una propiedad o ruta que no se puede encontrar en el objeto en estudio. </p><br><p>  Por ejemplo, podemos proporcionar un marcador de posici√≥n cuando no sabemos el nombre de la persona: <code>propOr('&lt;Unnamed&gt;, 'name', person)</code> .  Tenga en cuenta que a diferencia de <code>prop</code> , <code>propOr</code> no causar√° un error si la <code>person</code> es <code>null</code> o <code>undefined</code> ;  en su lugar, devolver√° el valor predeterminado. </p><br><h2 id="keys--values">  claves / valores </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">keys</a> devuelve una matriz que contiene todos los nombres de todas las propiedades conocidas del objeto.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los valores</a> devolver√°n los valores de estas propiedades.  Estas funciones pueden ser √∫tiles cuando se combinan con las funciones de iteraci√≥n para colecciones, que aprendimos en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primera parte</a> . </p><br><h2 id="dobavlenie-obnovlenie-i-udalenie-svoystv">  Agregar, actualizar y eliminar propiedades </h2><br><p>  Ahora tenemos muchas herramientas para leer desde objetos en un estilo declarativo, pero ¬øqu√© hay de hacer cambios? </p><br><p>  Dado que la inmutabilidad es importante para nosotros, no queremos modificar objetos directamente.  En cambio, queremos devolver nuevos objetos que han cambiado de la manera que queremos. </p><br><p>  Una vez m√°s, Ramda nos brinda muchos beneficios. </p><br><h2 id="assoc--assocpath">  assoc / assocPath </h2><br><p>  Cuando programamos en un estilo imperativo, podemos establecer o cambiar el nombre de la persona a trav√©s del operador de asignaci√≥n: <code>person.name = 'New name'</code> . </p><br><p>  En nuestro mundo funcional e inmutable, podemos usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">assoc</a> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">su</a> lugar: <code>const updatedPerson = assoc('name', 'newName', person)</code> . </p><br><p>  <code>assoc</code> devuelve un nuevo objeto con un valor de propiedad agregado o actualizado, dejando el objeto original sin cambios. </p><br><p>  Tambi√©n tenemos a nuestra disposici√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">assocPath</a> para actualizar la propiedad adjunta: <code>const updatedPerson = assocPath(['address', 'zipCode'], '97504', person)</code> . </p><br><h2 id="dissoc--dissocpath--omit">  dissoc / dissocPath / omit </h2><br><p>  ¬øQu√© pasa con la eliminaci√≥n de propiedades?  Imperativamente, podemos querer decir <code>delete person.age</code> .  En Ramda, usaremos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dissoc</a> : `const updatedPerson = dissoc ('age', person) </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dissocPath es</a> casi lo mismo, pero funciona en estructuras de objetos m√°s profundas: <code>dissocPath(['address', 'zipCode'], person)</code> . </p><br><p>  Y tambi√©n tenemos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">omitir</a> , que puede eliminar varias propiedades a la vez: <code>const updatedPerson = omit(['age', 'birthCountry'], person)</code> . </p><br><p>  Tenga en cuenta que <code>pick</code> y <code>omit</code> poco similares y se complementan muy bien.  Son muy convenientes para incluir en la lista blanca (guardar solo un cierto conjunto de propiedades usando <code>pick</code> ) y listas negras (deshacerse de ciertas propiedades mediante el uso de <code>omit</code> ). </p><br><h2 id="transformaciya-obektov">  Transformaci√≥n de objetos </h2><br><p>  Ahora sabemos lo suficiente como para trabajar con objetos en un estilo declarativo e inmutable.  Escribamos una funci√≥n de <code>celebrateBirthday</code> que actualice la edad de la persona en su cumplea√±os. </p><br><pre> <code class="plaintext hljs">const nextAge = compose(inc, prop('age')) const celebrateBirthday = person =&gt; assoc('age', nextAge(person), person)</code> </pre> <br><p>  Este es un patr√≥n muy com√∫n.  En lugar de actualizar la propiedad con un nuevo valor, realmente queremos cambiar el valor aplicando la funci√≥n al valor anterior, como lo hicimos aqu√≠. </p><br><p>  No conozco una buena manera de escribir esto con menos duplicaci√≥n y en un estilo menos riguroso, con esas herramientas que aprendimos anteriormente. </p><br><p>  Ramda una vez m√°s nos salva con la funci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">evolucionar</a> .  <code>evolve</code> acepta un objeto y le permite especificar funciones de transformaci√≥n para aquellas propiedades que queremos cambiar.  Refractemos <code>celebrateBirthday</code> el <code>celebrateBirthday</code> sobre el uso de <code>evolve</code> : </p><br><pre> <code class="plaintext hljs">const celebrateBirthday = evolve({ age: inc })</code> </pre> <br><p>  Este c√≥digo dice que convertiremos el objeto especificado (que no se muestra debido al estilo brutal) creando un nuevo objeto con las mismas propiedades y valores, pero la propiedad <code>age</code> se obtendr√° aplicando <code>inc</code> al valor original de la propiedad <code>age</code> . </p><br><p>  <code>evolve</code> puede transformar muchas propiedades a la vez, e incluso en m√∫ltiples niveles de anidamiento.  La transformaci√≥n del objeto puede tener la misma imagen que tendr√° el objeto mutable, y <code>evolve</code> pasar√° recursivamente entre las estructuras, utilizando las funciones de transformaci√≥n en la forma especificada. </p><br><p>  Tenga en cuenta que <code>evolve</code> no agrega nuevas propiedades;  si especifica una transformaci√≥n para una propiedad que no ocurre en el objeto que se procesa, <code>evolve</code> simplemente la ignorar√°. </p><br><p>  Descubr√≠ que <code>evolve</code> convirtiendo r√°pidamente en un caballo de batalla en mis aplicaciones. </p><br><h2 id="sliyanie-obektov">  Fusionar objetos </h2><br><p>  A veces necesitas combinar dos objetos juntos.  Un caso t√≠pico es cuando tiene una funci√≥n que toma opciones con nombre y desea combinarlas con las opciones predeterminadas.  Ramda proporciona una funci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fusi√≥n</a> para este prop√≥sito. </p><br><pre> <code class="plaintext hljs">function f(a, b, options = {}) { const defaultOptions = { value: 42, local: true } const finalOptions = merge(defaultOptions, options) }</code> </pre> <br><p>  <code>merge</code> devuelve un nuevo objeto que contiene todas las propiedades y valores de ambos objetos.  Si ambos objetos tienen la misma propiedad, se obtendr√° el valor del segundo argumento. </p><br><p>  La presencia de esta regla con un segundo argumento ganador hace que sea significativo usar la <code>merge</code> como una herramienta aut√≥noma, pero menos significativo en situaciones de transporte.  En este caso, a menudo necesita preparar una serie de transformaciones para un objeto, y una de esas transformaciones es la uni√≥n de algunos valores de propiedad nuevos.  En este caso, querr√° que gane el primer argumento en lugar del segundo. </p><br><p>  Intentar usar <code>merge(newValues)</code> en la tuber√≠a no dar√° lo que nos gustar√≠a obtener. </p><br><p>  Para esta situaci√≥n, generalmente creo mi propia utilidad llamada <code>reverseMerge</code> .  Se puede escribir como <code>const reverseMerge = flip(merge)</code> .  La llamada invertida intercambia los dos primeros argumentos de la funci√≥n que le corresponde. </p><br><p>  <code>merge</code> realiza una fusi√≥n de superficie.  Si los objetos, cuando se combinan, tienen una propiedad cuyo valor es un subobjeto, entonces estos subobjetos no se fusionan. <del>  Ramda actualmente no tiene una habilidad de fusi√≥n profunda </del>  (El <em>art√≠culo original que estoy traduciendo ya tiene informaci√≥n desactualizada sobre este tema. Hoy Ramda tiene funciones como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mergeDeepLeft</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mergeDeepRight</a> para fusionar objetos recursivamente profundos y otros m√©todos para fusionar</em> ). </p><br><p>  Tenga en cuenta que la <code>merge</code> solo acepta dos argumentos.  Si desea combinar muchos objetos en uno, puede usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mergeAll</a> , que toma una matriz de objetos para combinar. </p><br><h2 id="zaklyuchenie">  Conclusi√≥n </h2><br><p>  Hoy tenemos un maravilloso conjunto de herramientas para trabajar con objetos en un estilo declarativo e inmutable.  Ahora podemos leer, agregar, actualizar, eliminar y transformar propiedades en objetos sin cambiar los objetos originales.  Y podemos hacer todas estas cosas en un estilo que facilite combinar funciones entre s√≠. </p><br><h2 id="dalee">  Siguiente </h2><br><p>  Ahora podemos trabajar con objetos en un estilo inmutable, pero ¬øqu√© pasa con las matrices?  "Inmunidad y matrices" nos dir√° qu√© hacer con ellos. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es414337/">https://habr.com/ru/post/es414337/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es414325/index.html">Preg√∫ntele a Ethan: ¬øtal vez la antimateria perdida est√° escondida dentro de los agujeros negros?</a></li>
<li><a href="../es414327/index.html">¬øQu√© es la depresi√≥n y por qu√© ocurre con m√°s frecuencia?</a></li>
<li><a href="../es414329/index.html">¬øPara qu√© se preparan exactamente los "sobrevivientes"?</a></li>
<li><a href="../es414331/index.html">¬øEncontrar√°n los cient√≠ficos alguna vez vida que no haya aparecido en el planeta?</a></li>
<li><a href="../es414335/index.html">Antecedentes Roskomnadzor, ¬øqu√© eres?</a></li>
<li><a href="../es414339/index.html">Gran recorrido fotogr√°fico por el nuevo sitio de coworking de Mosc√∫ #tceh</a></li>
<li><a href="../es414341/index.html">El resumen de materiales interesantes para el desarrollador m√≥vil # 256 (del 3 al 12 de junio)</a></li>
<li><a href="../es414343/index.html">Traducci√≥n Autom√°tica Neural de Google</a></li>
<li><a href="../es414345/index.html">Desarrollo inverso del interruptor de tiempo VL-76-S</a></li>
<li><a href="../es414349/index.html">Obtenga estad√≠sticas de costos de MCC: Tinkoff y Rocketbank</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>