<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎦 💍 🌃 Apache Kafka和Spark Streaming的流式传输 💴 👨🏼‍🔬 🛸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 今天，我们将构建一个系统，该系统将使用Apark Kafka使用Spark Streaming处理消息流，并将处理结果写入AWS RDS云数据库。 

 想象一下，某个信贷机构将我们的任务设置为在其所有分支机构中即时处理传入交易。 可以执行此操作，以便快速计算国库的未平仓货币头寸，限额或交...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apache Kafka和Spark Streaming的流式传输</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451160/"> 哈Ha！ 今天，我们将构建一个系统，该系统将使用Apark Kafka使用Spark Streaming处理消息流，并将处理结果写入AWS RDS云数据库。 <br><br> 想象一下，某个信贷机构将我们的任务设置为在其所有分支机构中即时处理传入交易。 可以执行此操作，以便快速计算国库的未平仓货币头寸，限额或交易的财务结果等。 <br><br> 如何在不使用魔术和魔术的情况下实施此案例-我们在删节下阅读！ 走吧 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5w/sb/8v/5wsb8vvncrzhysct-pd6oqraqky.jpeg"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">（图片来源）</a> <br><a name="habracut"></a><br><h2> 引言 </h2><br> 当然，实时处理大型数据阵列为在现代系统中使用提供了充足的机会。 最受欢迎的组合之一是Apache Kafka和Spark Streaming串联，其中Kafka创建传入消息包的流，Spark Streaming在指定的时间间隔处理这些包。 <br><br> 为了提高应用程序的容错能力，我们将使用检查点-检查点。 使用此机制，当Spark Streaming模块需要恢复丢失的数据时，它仅需要返回到最后一个控制点并从该点恢复计算。 <br><br><h2> 正在开发的系统架构 </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/od/ef/zc/odefzciug8ckvim4-ei6pdg49tw.png"></div><br><br> 使用的组件： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b>Apache Kafka</b></a>是具有发布和订阅功能的分布式消息系统。 适用于离线和在线消息消费。 为了防止数据丢失，Kafka消息存储在磁盘上，并在群集内复制。  Kafka系统建立在ZooKeeper同步服务之上； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b>Apache Spark Streaming-</b></a>用于处理流数据的Spark组件。 当数据流被解释为小数据包的连续序列时，使用微批处理体系结构构建Spark Streaming模块。  Spark Streaming从各种来源接收数据，并将它们组合成小数据包。 定期创建新软件包。 在每个时间间隔的开始，都会创建一个新的数据包，并且在此时间间隔内接收到的所有数据都将包含在该数据包中。 在间隔结束时，数据包停止增长。 间隔的大小由称为批处理间隔的参数确定。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b>Apache Spark SQL-</b></a>将关系处理与Spark功能编程结合在一起。 结构化数据是指具有模式的数据，即所有记录的一组字段。  Spark SQL支持来自各种结构化数据源的输入，并且由于提供了架构信息，它可以有效地仅检索所需的记录字段，并提供DataFrame API； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b>AWS RDS</b></a>是一种相对便宜的基于云的关系数据库，一种简化了配置，操作和扩展的Web服务，由Amazon直接管理。 </li></ul><br><h2> 安装并启动Kafka服务器 </h2><br> 在直接使用Kafka之前，您需要确保Java可用，因为  JVM用于工作： <br><br><pre><code class="bash hljs">sudo apt-get update sudo apt-get install default-jre java -version</code> </pre> <br> 创建一个新用户以使用Kafka： <br><br><pre> <code class="bash hljs">sudo useradd kafka -m sudo passwd kafka sudo adduser kafka sudo</code> </pre><br> 接下来，从Apache Kafka官方网站下载发行版： <br><br><pre> <code class="bash hljs">wget -P /YOUR_PATH <span class="hljs-string"><span class="hljs-string">"http://apache-mirror.rbc.ru/pub/apache/kafka/2.2.0/kafka_2.12-2.2.0.tgz"</span></span></code> </pre> <br> 解压缩下载的档案： <br><pre> <code class="bash hljs">tar -xvzf /YOUR_PATH/kafka_2.12-2.2.0.tgz ln -s /YOUR_PATH/kafka_2.12-2.2.0 kafka</code> </pre><br> 下一步是可选的。 事实是默认设置不允许完全使用Apache Kafka的所有功能。 例如，删除可以向其发布消息的主题，类别，组。 要更改此设置，请编辑配置文件： <br><br><pre> <code class="bash hljs">vim ~/kafka/config/server.properties</code> </pre> <br> 将以下内容添加到文件末尾： <br><br><pre> <code class="bash hljs">delete.topic.enable = <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br> 在启动Kafka服务器之前，您需要启动ZooKeeper服务器，我们将使用Kafka发行版随附的辅助脚本： <br><br><pre> <code class="bash hljs">Cd ~/kafka bin/zookeeper-server-start.sh config/zookeeper.properties</code> </pre><br>  ZooKeeper成功启动后，在另一个终端中，我们启动Kafka服务器： <br><br><pre> <code class="bash hljs">bin/kafka-server-start.sh config/server.properties</code> </pre> <br> 创建一个名为Transaction的新主题： <br><br><pre> <code class="bash hljs">bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 3 --topic transaction</code> </pre> <br> 确保已创建具有正确数量的分区和复制的主题： <br><br><pre> <code class="bash hljs">bin/kafka-topics.sh --describe --zookeeper localhost:2181</code> </pre> <br><img src="https://habrastorage.org/webt/s5/gh/bu/s5ghbuswhb0dcc0pmlvu_uloes4.png"><br><br> 我们将错过为新创建的主题测试生产者和消费者的时间。 有关如何测试发送和接收消息的更多详细信息，请参阅官方文档- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">发送一些消息</a> 。 好吧，我们继续使用KafkaProducer API用Python编写生产器。 <br><br><h2> 制片人写作 </h2><br> 生产者将生成随机数据-每秒100条消息。 随机数据是指由三个字段组成的字典： <br><br><ul><li>  <b>分支机构</b> -信贷机构的销售点名称； </li><li>  <b>货币</b> -交易货币； </li><li>  <b>金额</b> -交易金额。 如果该金额是银行购买的货币，则金额将为正数；如果是销售，则金额将为负数。 </li></ul><br> 生产者的代码如下： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numpy.random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> choice, randint <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_random_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> new_dict = {} branch_list = [<span class="hljs-string"><span class="hljs-string">'Kazan'</span></span>, <span class="hljs-string"><span class="hljs-string">'SPB'</span></span>, <span class="hljs-string"><span class="hljs-string">'Novosibirsk'</span></span>, <span class="hljs-string"><span class="hljs-string">'Surgut'</span></span>] currency_list = [<span class="hljs-string"><span class="hljs-string">'RUB'</span></span>, <span class="hljs-string"><span class="hljs-string">'USD'</span></span>, <span class="hljs-string"><span class="hljs-string">'EUR'</span></span>, <span class="hljs-string"><span class="hljs-string">'GBP'</span></span>] new_dict[<span class="hljs-string"><span class="hljs-string">'branch'</span></span>] = choice(branch_list) new_dict[<span class="hljs-string"><span class="hljs-string">'currency'</span></span>] = choice(currency_list) new_dict[<span class="hljs-string"><span class="hljs-string">'amount'</span></span>] = randint(<span class="hljs-number"><span class="hljs-number">-100</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new_dict</code> </pre><br> 接下来，使用send方法，以所需的主题，以JSON格式将消息发送到服务器： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> kafka <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> KafkaProducer producer = KafkaProducer(bootstrap_servers=[<span class="hljs-string"><span class="hljs-string">'localhost:9092'</span></span>], value_serializer=<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x:dumps(x).encode(<span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>), compression_type=<span class="hljs-string"><span class="hljs-string">'gzip'</span></span>) my_topic = <span class="hljs-string"><span class="hljs-string">'transaction'</span></span> data = get_random_value() <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: future = producer.send(topic = my_topic, value = data) record_metadata = future.get(timeout=<span class="hljs-number"><span class="hljs-number">10</span></span>) print(<span class="hljs-string"><span class="hljs-string">'--&gt; The message has been sent to a topic: \ {}, partition: {}, offset: {}'</span></span> \ .format(record_metadata.topic, record_metadata.partition, record_metadata.offset )) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> Exception <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: print(<span class="hljs-string"><span class="hljs-string">'--&gt; It seems an Error occurred: {}'</span></span>.format(e)) <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>: producer.flush()</code> </pre><br> 运行脚本时，我们在终端中收到以下消息： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_e/3g/zj/_e3gzjrmsycjb8ntjmur6ztaspw.png"></div><br> 这意味着一切都可以按照我们想要的方式工作-生产者生成并发送消息到我们需要的主题。 <br><br> 下一步是安装Spark并处理此消息流。 <br><br><h2> 安装Apache Spark </h2><br>  <b>Apache Spark</b>是一个多功能的高性能集群计算平台。 <br><br> 在性能方面，Spark超越了MapReduce模型的流行实现，同时为更广泛的计算类型提供了支持，包括交互式查询和流处理。 速度在处理大量数据中起着重要作用，因为速度使您无需花费几分钟或几个小时就可以进行交互式工作。  Spark如此高速的最大优势之一就是其执行内存中计算的能力。 <br><br> 该框架是用Scala编写的，因此必须首先安装它： <br><br><pre> <code class="bash hljs">sudo apt-get install scala</code> </pre> <br> 从官方网站下载Spark发行版： <br><br><pre> <code class="bash hljs">wget <span class="hljs-string"><span class="hljs-string">"http://mirror.linux-ia64.org/apache/spark/spark-2.4.2/spark-2.4.2-bin-hadoop2.7.tgz"</span></span></code> </pre> <br> 解压缩档案： <br><br><pre> <code class="bash hljs">sudo tar xvf spark-2.4.2/spark-2.4.2-bin-hadoop2.7.tgz -C /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/spark</code> </pre> <br> 在bash文件中添加Spark的路径： <br><br><pre> <code class="bash hljs">vim ~/.bashrc</code> </pre> <br> 通过编辑器添加以下行： <br><br><pre> <code class="bash hljs">SPARK_HOME=/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/spark <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> PATH=<span class="hljs-variable"><span class="hljs-variable">$SPARK_HOME</span></span>/bin:<span class="hljs-variable"><span class="hljs-variable">$PATH</span></span></code> </pre><br> 对bashrc进行更改后，运行以下命令： <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">source</span></span> ~/.bashrc</code> </pre> <br><h2>  AWS PostgreSQL部署 </h2><br> 剩下的工作就是部署数据库，在这里我们将从流中上传已处理的信息。 为此，我们将使用AWS RDS服务。 <br><br> 转到控制台AWS-&gt; AWS RDS-&gt;数据库-&gt;创建数据库： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dg/os/m7/dgosm7dwnh3fr-uksjdt_xpltsk.png"></div><br> 选择PostgreSQL，然后单击下一步按钮： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3y/d_/8r/3yd_8rsz2swfgaxaafpkyizthac.png"></div><br> 因为 本示例仅出于教育目的而理解，我们将“至少”使用免费服务器（Free Tier）： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fn/6p/5b/fn6p5bjyitndy_ozs2cdcw_ssi0.png"></div><br> 接下来，在Free Tier块中打勾，然后将自动为我们提供t2.micro类的实例-尽管很弱，但它是免费的，非常适合我们的任务： <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mj/jh/wg/mjjhwg3cknoehrq8wyxk3uw5v74.png"></div><br> 接下来是非常重要的事情：数据库实例的名称，主用户的名称及其密码。 让我们命名实例：myHabrTest，主用户： <b>habr</b> ，密码： <b>habr12345</b> ，然后单击下一步按钮： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lg/jt/mf/lgjtmfdfst0pvqthojb_bdpeohc.png"></div><br><br> 下一页包含从外部负责我们的数据库服务器可用性（公共可访问性）和端口可用性的参数： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/40/z9/q7/40z9q7owar5kpnimyzrdj5laqgs.png"></div><br> 让我们为VPC安全组创建一个新配置，这将使我们能够从外部通过端口5432（PostgreSQL）访问我们的数据库服务器。 <br><br> 在单独的浏览器窗口中，转到VPC仪表板-&gt;安全组-&gt;创建安全组部分中的AWS控制台： <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fl/2i/ne/fl2inejlgnghwsh3itdrlcywdsu.png"></div><br> 设置安全组的名称-PostgreSQL，一个描述，指示该组应与哪个VPC关联，然后单击创建按钮： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/js/8r/tv/js8rtvp8tudwjtpgso6xota5h-g.png"></div><br> 填写端口5432的新创建的入站规则组，如下图所示。 您不必指定手动端口，而是从“类型”下拉列表中选择PostgreSQL。 <br><br> 严格来说，值:: / 0表示来自世界各地的服务器的传入流量的可用性，这并不完全正确，但是为了分析示例，让我们使用以下方法： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ge/8j/bn/ge8jbntssnooajc8so36h0tjo80.png"></div><br> 返回浏览器页面，打开“配置高级设置”，然后在“ VPC安全组-&gt;选择现有VPC安全组-&gt; PostgreSQL”部分中进行选择： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nk/ae/-s/nkae-ste1tp3wgvmyilicvwlk8e.png"></div><br> 接下来，在数据库选项-&gt;数据库名称-&gt;部分中，设置名称<b>-habrDB</b> 。 <br><br> 默认情况下，除了禁用备份（备份保留期-0天），监视和Performance Insights外，我们可以保留其余参数。 单击<b>创建数据库</b>按钮： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ex/1p/po/ex1ppogq_vdsk3nnvywm7l8vq8i.png"></div><br><h2> 流处理程序 </h2><br> 最后一步将是Spark-jobs的开发，它将每两秒钟处理一次从Kafka收到的新数据，并将结果输入数据库。 <br><br> 如上所述，检查点是SparkStreaming中的主要机制，必须对其进行配置以提供容错能力。 我们将使用控制点，并且在过程丢失的情况下，Spark Streaming模块将仅需要返回到最后一个控制点并从该控制点恢复计算以恢复丢失的数据。 <br><br> 您可以通过在容错，可靠的文件系统（例如HDFS，S3等）中设置目录来启用检查点，在该文件系统中将保存检查点信息。 例如，使用以下方法完成此操作： <br><br><pre> <code class="python hljs">streamingContext.checkpoint(checkpointDirectory)</code> </pre> <br> 在我们的示例中，我们将使用以下方法，即，如果存在checkpointDirectory，则将从控制点数据重新创建上下文。 如果目录不存在（即首次执行），则调用functionToCreateContext函数以创建新上下文并配置DStreams： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pyspark.streaming <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> StreamingContext context = StreamingContext.getOrCreate(checkpointDirectory, functionToCreateContext)</code> </pre><br> 使用KafkaUtils库的createDirectStream方法创建一个DirectStream对象以连接到“事务”主题： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pyspark.streaming.kafka <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> KafkaUtils sc = SparkContext(conf=conf) ssc = StreamingContext(sc, <span class="hljs-number"><span class="hljs-number">2</span></span>) broker_list = <span class="hljs-string"><span class="hljs-string">'localhost:9092'</span></span> topic = <span class="hljs-string"><span class="hljs-string">'transaction'</span></span> directKafkaStream = KafkaUtils.createDirectStream(ssc, [topic], {<span class="hljs-string"><span class="hljs-string">"metadata.broker.list"</span></span>: broker_list})</code> </pre><br> 解析JSON格式的传入数据： <br><br><pre> <code class="python hljs">rowRdd = rdd.map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> w: Row(branch=w[<span class="hljs-string"><span class="hljs-string">'branch'</span></span>], currency=w[<span class="hljs-string"><span class="hljs-string">'currency'</span></span>], amount=w[<span class="hljs-string"><span class="hljs-string">'amount'</span></span>])) testDataFrame = spark.createDataFrame(rowRdd) testDataFrame.createOrReplaceTempView(<span class="hljs-string"><span class="hljs-string">"treasury_stream"</span></span>)</code> </pre><br> 使用Spark SQL，我们进行了简单的分组并将结果打印到控制台： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> from_unixtime(<span class="hljs-keyword"><span class="hljs-keyword">unix_timestamp</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> curr_time, t.branch <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> branch_name, t.currency <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> currency_code, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(amount) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> batch_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> treasury_stream t <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> t.branch, t.currency</code> </pre><br> 获取查询文本并通过Spark SQL运行它： <br><br><pre> <code class="python hljs">sql_query = get_sql_query() testResultDataFrame = spark.sql(sql_query) testResultDataFrame.show(n=<span class="hljs-number"><span class="hljs-number">5</span></span>)</code> </pre><br> 然后，我们将接收到的聚合数据保存到AWS RDS中的表中。 要将聚合结果保存到数据库表中，我们将使用DataFrame对象的write方法： <br><br><pre> <code class="python hljs">testResultDataFrame.write \ .format(<span class="hljs-string"><span class="hljs-string">"jdbc"</span></span>) \ .mode(<span class="hljs-string"><span class="hljs-string">"append"</span></span>) \ .option(<span class="hljs-string"><span class="hljs-string">"driver"</span></span>, <span class="hljs-string"><span class="hljs-string">'org.postgresql.Driver'</span></span>) \ .option(<span class="hljs-string"><span class="hljs-string">"url"</span></span>,<span class="hljs-string"><span class="hljs-string">"jdbc:postgresql://myhabrtest.ciny8bykwxeg.us-east-1.rds.amazonaws.com:5432/habrDB"</span></span>) \ .option(<span class="hljs-string"><span class="hljs-string">"dbtable"</span></span>, <span class="hljs-string"><span class="hljs-string">"transaction_flow"</span></span>) \ .option(<span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-string"><span class="hljs-string">"habr"</span></span>) \ .option(<span class="hljs-string"><span class="hljs-string">"password"</span></span>, <span class="hljs-string"><span class="hljs-string">"habr12345"</span></span>) \ .save()</code> </pre><br><blockquote> 关于建立与AWS RDS的连接的几句话。 我们在“部署AWS PostgreSQL”步骤中为其创建了用户和密码。 对于数据库服务器URL，请使用“端点”，该端点显示在“连接性和安全性”部分中： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9n/sj/jd/9nsjjdun0hdy5qtwqub0xhvzunk.png"></div></blockquote><br> 为了正确连接Spark和Kafka，您应该使用<b>spark-streaming-kafka-0-8_2.11工件</b>通过smark-submit运行作业。 此外，我们还将工件与PostgreSQL数据库进行交互，我们将通过--packages进行传输。 <br><br> 为了提高脚本的灵活性，我们还提取了消息服务器的名称以及要从中接收数据作为输入参数的主题。 <br><br> 因此，该启动并测试系统了： <br><br><pre> <code class="bash hljs">spark-submit \ --packages org.apache.spark:spark-streaming-kafka-0-8_2.11:2.0.2,\ org.postgresql:postgresql:9.4.1207 \ spark_job.py localhost:9092 transaction</code> </pre><br> 一切顺利！ 如下图所示，在应用程序工作期间，每2秒显示一次新的聚合结果，因为在创建StreamingContext对象时，我们将批处理间隔设置为2秒： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cf/q1/25/cfq125zpzkyldktsuvdo175fazy.png"></div><br> 接下来，我们对数据库进行简单查询，以检查<b>transaction_flow</b>表中的记录： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7j/j9/qm/7jj9qmf4zpter3jkbblrmiqni2s.png"></div><br><h2> 结论 </h2><br> 本文研究了使用Spark Streaming以及Apache Kafka和PostgreSQL进行流信息处理的示例。 随着来自各种来源的数据的增长，很难高估Spark Streaming对于创建流应用程序和实时运行的应用程序的实用价值。 <br><br> 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub的</a>我的存储库中找到完整的源代码。 <br><br> 我准备愉快地讨论本文，期待您的评论，也希望对所有相关读者提出建设性的批评。 <br><br> 祝你成功！ <br><br>  <b>PS</b>最初计划使用本地PostgreSQL数据库，但是由于我对AWS的热爱，我决定将数据库放在云中。 在关于该主题的下一篇文章中，我将展示如何使用AWS Kinesis和AWS EMR在AWS中实现上述整个系统。 关注新闻！ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN451160/">https://habr.com/ru/post/zh-CN451160/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN451148/index.html">图形语言中的面向对象编程</a></li>
<li><a href="../zh-CN451150/index.html">如果可以的话，赶上我。 管理员版本</a></li>
<li><a href="../zh-CN451152/index.html">门电路中的电阻或正确的方法</a></li>
<li><a href="../zh-CN451154/index.html">本地自治数据采集系统（续）</a></li>
<li><a href="../zh-CN451158/index.html">电路。 电路类型</a></li>
<li><a href="../zh-CN451162/index.html">纠错-国际单位制（SI）当前和新版本中的物理常数</a></li>
<li><a href="../zh-CN451164/index.html">使用Python寻找免费的停车位</a></li>
<li><a href="../zh-CN451166/index.html">用于AI和MO系统的新存储库将提供什么？</a></li>
<li><a href="../zh-CN451170/index.html">杰夫·贝佐斯（Jeff Bezos）宣布了征服月球的计划</a></li>
<li><a href="../zh-CN451172/index.html">朱莉娅：功能和结构即功能</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>