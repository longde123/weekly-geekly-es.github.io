<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçü§ù‚Äçüë©üèæ ‚Ü™Ô∏è üé∏ ¬øC√≥mo se organizaron los gr√°ficos NES? ‚úäüèº üêù üå©Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lanzada en 1983, la consola dom√©stica de Nintendo Entertainment System (NES) era una m√°quina barata pero poderosa que logr√≥ un √©xito fenomenal. Usando...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬øC√≥mo se organizaron los gr√°ficos NES?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470614/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ad/f22/f28/9adf22f2804a300f6f3e9a98fe15c13b.gif" alt="imagen"></div><br>  Lanzada en 1983, la consola dom√©stica de Nintendo Entertainment System (NES) era una m√°quina barata pero poderosa que logr√≥ un √©xito fenomenal.  Usando la unidad de procesamiento de im√°genes (PPU), el sistema podr√≠a crear gr√°ficos bastante impresionantes para esos tiempos, que incluso hoy se ven bastante bien en el contexto correcto.  El aspecto m√°s importante era la eficiencia de la memoria: al crear gr√°ficos, ten√≠amos que administrar con la menor cantidad de bytes posible.  Sin embargo, junto con esto, NES proporcion√≥ a los desarrolladores caracter√≠sticas potentes y f√°ciles de usar que le permitieron destacarse de las consolas dom√©sticas m√°s antiguas.  Habiendo entendido los principios de la creaci√≥n de gr√°ficos NES, puede sentir la perfecci√≥n t√©cnica del sistema y darse cuenta de lo f√°cil que es para los desarrolladores de juegos modernos trabajar. <br><br>  Los gr√°ficos de fondo de NES se ensamblaron a partir de cuatro componentes separados, cuya combinaci√≥n form√≥ la imagen que vemos en la pantalla.  Cada componente era responsable de un aspecto separado;  color, dise√±o, gr√°ficos de p√≠xeles en bruto, etc.  Tal sistema puede parecer innecesariamente complicado y engorroso, pero al final utiliz√≥ la memoria de manera mucho m√°s eficiente y permiti√≥ crear efectos simples en una peque√±a cantidad de c√≥digo.  Si desea comprender los gr√°ficos NES, estos cuatro componentes ser√°n informaci√≥n clave. <br><br>  Este art√≠culo asume que est√° familiarizado con las matem√°ticas de la computadora, y en particular con el hecho de que 8 bits = 1 byte y 8 bits pueden representar 256 valores.  Tambi√©n es necesario comprender c√≥mo funciona la notaci√≥n hexadecimal.  Pero incluso sin este conocimiento t√©cnico, el art√≠culo puede parecer interesante. <br><a name="habracut"></a><br><h1>  Breve rese√±a </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca1/6f8/9a7/ca16f89a75e658d68c28f81e9794ff86.png" width="512" height="480"></div><br>  Arriba hay una imagen de la primera escena de Castlevania (1986): la puerta que conduce al castillo, donde tendr√° lugar el juego.  Esta imagen tiene un tama√±o de 256 √ó 240 p√≠xeles y utiliza 10 colores diferentes.  Para describir esta imagen en la memoria, debemos aprovechar la paleta de colores limitada y ahorrar espacio almacenando solo una cantidad m√≠nima de informaci√≥n.  Uno de los enfoques ingenuos es utilizar una paleta indexada en la que cada p√≠xel tiene un volumen de 4 bits, es decir, 2 p√≠xeles se colocan en un byte.  Esto requerir√° 256 * 240/2 = 30720 bytes, pero como veremos pronto, NES puede hacer frente a esta tarea de manera mucho m√°s eficiente. <br><br>  Los conceptos principales en el tema de gr√°ficos NES son mosaicos y bloques [1].  Un mosaico es un √°rea de 8 √ó 8 p√≠xeles, y un bloque es un √°rea de 16 √ó 16 p√≠xeles, y cada uno de ellos est√° vinculado a una cuadr√≠cula con el mismo tama√±o de celda.  Despu√©s de agregar estas cuadr√≠culas, podemos ver la estructura de los gr√°ficos.  Aqu√≠ est√° la entrada al castillo con una cuadr√≠cula con doble aumento. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uz/de/sk/uzdeskry1wkruscxe8xsyephbnc.png"></div><br>  En esta cuadr√≠cula, los bloques se muestran en verde claro y los mosaicos en verde oscuro.  Las reglas a lo largo de los ejes tienen valores hexadecimales que se pueden agregar para encontrar una posici√≥n;  por ejemplo, el coraz√≥n en la barra de estado est√° en $ 15 + $ 60 = $ 75, que en decimal es 117. Cada pantalla contiene 16 √ó 15 bloques (240) y 32 √ó 30 fichas (960).  Ahora veamos c√≥mo se describe esta imagen y comencemos con los gr√°ficos de p√≠xeles sin procesar. <br><br><h1>  CHR </h1><br>  La estructura CHR describe gr√°ficos de p√≠xeles "en bruto" sin su color y posici√≥n, y se configura en mosaicos.  Toda la p√°gina de memoria contiene 256 mosaicos CHR, y cada mosaico tiene una profundidad de 2 bits.  Aqu√≠ est√°n los gr√°ficos del coraz√≥n: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad9/d14/fb3/ad9d14fb3cc4321c5ae65e1e7f61dd52.png" width="128" height="128"></div><br>  Y as√≠ es como se describe en CHR [2]: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/162/974/e0f/162974e0fe800447c8edecf9157d1763.png" alt="pixel-heart-chr" width="128" height="128"></div><br>  Dicha descripci√≥n toma 2 bits por p√≠xel, es decir, con un tama√±o de 8 √ó 8 resulta 8 * 8 * 2 = 128 bits = 16 bytes.  Entonces toda la p√°gina toma 16 * 256 = 4096 bytes.  Aqu√≠ est√°n todos los CHR utilizados en la imagen de Castlevania. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5da/3ef/83d/5da3ef83d0e339ca2d91d799745157e9.png" width="271" height="101"></div><br>  Recuerde que completar una imagen requiere 960 mosaicos, pero CHR le permite usar solo 256. Esto significa que la mayor√≠a de los mosaicos se repiten, en promedio, 3.75 veces, pero con mayor frecuencia solo se usa un peque√±o n√∫mero de ellos (por ejemplo, fondo vac√≠o, mosaicos monocromos o patrones repetitivos).  La imagen de Castlevania usa muchos mosaicos vac√≠os, as√≠ como tambi√©n azul s√≥lido.  Para ver c√≥mo se asignan los mosaicos, utilizamos tablas de nombres. <br><br><h1>  NOMBRABLE </h1><br>  La tabla de nombres asigna un archivo CHR a cada posici√≥n en la pantalla, y hay un total de 960. Cada posici√≥n se especifica en un byte, es decir, la tabla de nombres completa ocupa hasta 960 bytes.  Los mosaicos se asignan en orden de izquierda a derecha, de arriba a abajo, y corresponden a la posici√≥n calculada encontrada al agregar los valores de las reglas que se muestran arriba.  Es decir, la posici√≥n en la esquina superior izquierda es $ 0, a la derecha de la misma es $ 1, y debajo est√° $ 20. <br><br>  Los valores en la tabla de nombres dependen del orden en que se rellena el CHR.  Aqu√≠ est√° una de las opciones [3]: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h_/vs/qc/h_vsqc5mxdu8ydb1o8cu4mflf9e.png"></div><br>  <i>En este caso, el coraz√≥n (en la posici√≥n $ 75) tiene un valor de $ 13.</i> <br><br>  Luego, para agregar color, debemos seleccionar una paleta. <br><br><h1>  Paleta </h1><br>  NES tiene una paleta de sistema de 64 colores [4], y de ella seleccionamos las paletas que se utilizar√°n en el renderizado.  Cada paleta contiene 3 colores √∫nicos m√°s el color de fondo general.  La imagen tiene un m√°ximo de 4 paletas, que en total ocupan 16 bytes.  Aqu√≠ est√°n las paletas para la imagen de Castlevania: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f03/59a/259/f0359a259c032b5f6c9048c0231ffb85.png" alt="Castlevania-pal" width="168" height="24"></div><br>  Las paletas no pueden usarse arbitrariamente.  Solo se aplica una paleta por bloque.  Es por esta necesidad de separar cada √°rea de 16 √ó 16 de acuerdo con la paleta de colores del juego para que NES tenga ese aspecto de "bloque".  Los gr√°ficos ejecutados con maestr√≠a, por ejemplo, desde la pantalla de inicio de Castlevania, se pueden evitar mezclando colores en los bordes de los bloques, lo que oculta la presencia de una cuadr√≠cula. <br><br>  La selecci√≥n de una paleta para cada bloque se realiza utilizando el √∫ltimo componente: atributos. <br><br><h1>  Atributos </h1><br>  Los atributos ocupan 2 bits por bloque.  Determinan cu√°l de las 4 paletas usar.  Esta imagen muestra qu√© paletas definidas por los atributos usan diferentes bloques [5]: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k4/kj/3i/k4kj3imqlxxbwnasjcz3t60abym.png"></div><br>  Como puede ver, las paletas se dividen en secciones, pero esto es complicado debido al uso de los mismos colores en diferentes √°reas.  Rojo en el centro de la puerta se funde con las paredes que lo rodean, y un fondo negro desdibuja la l√≠nea entre el castillo <br>  y puertas <br><br>  Con 2 bits por bloque o 4 bloques por byte, los atributos de imagen ocupan solo 240/4 = 60 bytes, pero debido a la forma en que est√°n codificados, se desperdician otros 4 bytes, es decir, se obtienen un total de 64 bytes.  Esto significa que toda la imagen, incluidos CHR, tabla de nombres, paletas y atributos, ocupa 4096 + 960 + 16 + 64 = 5136 bytes, mucho mejor que el 30720 mencionado anteriormente. <br><br><h1>  MAKECHR </h1><br>  Crear estos cuatro componentes para gr√°ficos NES es m√°s dif√≠cil que usar las API de mapa de bits normales, pero las herramientas vienen al rescate.  Los desarrolladores de NES probablemente ten√≠an alg√∫n tipo de cadena de herramientas, pero fuera lo que fuera, la historia no lo salv√≥.  Hoy en d√≠a, los desarrolladores suelen escribir programas para convertir gr√°ficos al formato NES deseado. <br><br>  Todas las im√°genes en esta publicaci√≥n fueron creadas usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">makechr</a> , una herramienta reescrita utilizada por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Star Versus</a> .  Esta es una herramienta de l√≠nea de comandos dise√±ada para compilaciones automatizadas y dirigida a la velocidad, mensajes de error de calidad, portabilidad y comprensi√≥n.  Tambi√©n crea visualizaciones interesantes como las utilizadas en la publicaci√≥n. <br><br><h1>  Referencias </h1><br>  Principalmente conocimiento sobre programaci√≥n para NES, y especialmente sobre creaci√≥n de gr√°ficos, obtuve de las siguientes fuentes: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nintendo Age Nerdy Nights</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wiki de NesDev</a> </li></ul><br><h1>  Notas </h1><br>  [1] Terminolog√≠a: en algunos documentos, los bloques se denominan "meta-mosaicos", que personalmente me parecen menos √∫tiles. <br><br>  [2] Codificaci√≥n CHR: 2 bits por p√≠xel no se almacenan uno al lado del otro.  La imagen completa se guarda primero solo con los bits bajos, y luego nuevamente se guarda solo con los bits altos. <br><br>  Es decir, el coraz√≥n se almacenar√° as√≠: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc5/68c/f95/cc568cf959b148d1d11a408876806ae8.png" alt="pixel-heart-low" width="128" height="128"><img src="https://habrastorage.org/getpro/habr/post_images/f87/947/070/f879470703605322e98a2582241b071e.png" alt="pixel-heart-high" width="128" height="128"><br><br>  Cada l√≠nea es un byte.  Es decir, 01100110 es $ 66, 01111111 es $ 7f.  En total, los bytes del coraz√≥n se ven as√≠: <br><br>  $ 66 $ 7f $ ff $ ff $ ff $ 7e $ 3c $ 18 $ 66 $ 5f $ bf $ bf $ ff $ 7e $ 3c $ 18 <br><br>  [3] Tabla de nombres: en esta tabla del juego, la tabla de nombres se usa de manera diferente.  Por lo general, las letras del alfabeto se guardan en la memoria del vecindario, incluido Castlevania. <br><br>  [4] Paleta del sistema: NES no utiliza una paleta RGB, y los colores reales que representa dependen del televisor en particular.  Los emuladores generalmente usan paletas RGB completamente diferentes.  Los colores en este art√≠culo corresponden a la paleta enunciada en makechr. <br><br>  [5] Codificaci√≥n de atributos: los atributos se almacenan en un orden extra√±o.  No van de izquierda a derecha, de arriba a abajo: el √°rea del bloque 2 √ó 2 est√° codificada con un byte, en forma de letra Z. Es por eso que se desperdician 4 bytes;  el resultado final es un total de 8 bytes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/71a/951/0db/71a9510db28128bca1841689ce909c27.png" alt="grupo-bloque-pal" width="64" height="64"></div><br>  Por ejemplo, un bloque de $ 308 se almacena con $ 30a, $ 348 y $ 34a.  Sus valores de paleta son 1, 2, 3 y 3, y se almacenan en orden desde la posici√≥n m√°s baja hasta la posici√≥n m√°s alta, o 11 :: 11 :: 10 :: 01 = 11111001. Por lo tanto, el valor de byte de estos atributos es $ f9. <br><br><h2>  Parte 2 </h2><br>  En la primera parte, hablamos sobre los componentes de los gr√°ficos de fondo de NES: CHR, tabla de nombres, paletas y atributos.  Pero esto es solo la mitad de la historia. <br><br>  Para empezar, en realidad hay dos tablas de nombres [6].  Cada uno de ellos tiene sus propios atributos para establecer el color, pero tienen el mismo CHR.  El equipo de cartucho determina su posici√≥n: ya sea uno al lado del otro o uno encima del otro.  Los siguientes son ejemplos de dos tipos diferentes de ubicaciones: Lode Runner (1984) y Bubble Bobble (1988). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/759/7ef/7c9/7597ef7c97f3e31ed3bb4198727dee37.png" width="512" height="500"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e7/035/72a/0e703572ad771478c13bffa254a86579.png" alt="Bubble-bobble-scrolling" width="532" height="480"></div><br><h1>  Desplazamiento </h1><br>  Para aprovechar la presencia de dos tablas de nombres, PPU admite la capacidad de desplazarse por p√≠xel a la vez a lo largo de los ejes X e Y. Est√° controlado por un registro con pantalla de memoria a $ 2005: al escribir solo dos bytes en esta direcci√≥n, la pantalla completa se mueve al n√∫mero deseado de p√≠xeles [7] .  En el momento del lanzamiento de NES, esta era la principal ventaja sobre otras consolas dom√©sticas, en las que para el desplazamiento a menudo hab√≠a que reescribir toda la memoria de video.  Tal esquema f√°cil de usar condujo a la aparici√≥n de una gran cantidad de plataformas y tiradores, y se convirti√≥ en la raz√≥n principal de un gran √©xito del sistema. <br><br>  Para un juego simple, cuyo campo tiene solo dos pantallas de ancho, por ejemplo, Load Runner, fue suficiente para completar ambas tablas de nombres y cambiar el desplazamiento en consecuencia.  Pero en la mayor√≠a de los juegos de desplazamiento, los niveles ten√≠an un ancho arbitrario.  Para implementarlos, el juego debe actualizar la parte fuera de la pantalla de las tablas de nombres antes de que aparezcan en la pantalla.  El valor de desplazamiento se repite, pero dado que la tabla de nombres se actualiza constantemente, esto crea la ilusi√≥n de un tama√±o infinito. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/829/936/ab4/829936ab4b2855cd7f824ebd01941bb3.gif" width="512" height="500"></div><br><h1>  Sprites </h1><br>  Adem√°s de desplazarse por las tablas de nombres, NES tambi√©n ten√≠a un aspecto completamente diferente de los gr√°ficos: sprites.  A diferencia de las tablas de nombres que deben alinearse en cuadr√≠culas, los sprites se pueden colocar de forma arbitraria, por lo que se pueden usar para mostrar personajes de jugadores, obst√°culos, proyectiles y cualquier objeto con movimientos complejos.  Por ejemplo, en la escena anterior de Mega Man (1987) para mostrar el personaje de un jugador.  los puntos y las tiras de energ√≠a son sprites utilizados, lo que les permite salir de la cuadr√≠cula de tablas de nombres al desplazarse por la pantalla. <br><br>  Los sprites tienen su propia p√°gina CHR [8] y un conjunto de 4 paletas.  Adem√°s, ocupan una p√°gina de memoria de 256 bytes.  que enumera la posici√≥n y la apariencia de cada sprite (como resultado, la memoria de video NES es dos veces y media m√°s grande que la mencionada en la primera parte del art√≠culo).  El formato de estos registros es bastante inusual: contienen primero una posici√≥n en Y, luego un n√∫mero de mosaico, luego un atributo, luego una posici√≥n en X [9].  Como cada registro tiene 4 bytes, hay una restricci√≥n estricta: en la pantalla no puede haber m√°s de 256/4 = 64 sprites a la vez. <br><br>  Los bytes Y y X especifican el p√≠xel superior izquierdo del sprite dibujado.  Por lo tanto, en el lado derecho de la pantalla, el sprite se puede recortar, pero en el lado izquierdo deja un espacio vac√≠o.  El byte del mosaico es similar al valor en la tabla de nombres, solo para estos mosaicos los sprites usan su propio CHR.  Un byte de atributo es un paquete de bits que realiza tres tareas: se asignan dos bits a la paleta, se usan dos bits para reflejar el sprite horizontal o verticalmente, y un bit determina si se representa el sprite bajo las tablas de nombres [10]. <br><br><h1>  Limitaciones </h1><br>  Los sistemas modernos permiten trabajar con sprites de cualquier tama√±o arbitrario, pero en NES el sprite debido a limitaciones de CHR ten√≠a que tener un tama√±o de 8 √ó 8 [11].  Los objetos m√°s grandes est√°n formados por varios sprites, y el programa debe asegurarse de que todas las partes individuales se representen una al lado de la otra.  Por ejemplo, un tama√±o de personaje de Megaman puede alcanzar 10 sprites, lo que tambi√©n le permite usar m√°s colores, en particular para sus ojos blancos y el tono de su piel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd8/fea/3dc/dd8fea3dc4880761b52885c8ff83acdd.png"></div><br>  La principal limitaci√≥n asociada con el uso de sprites es que no debe haber m√°s de 8 sprites por l√≠nea de trama.  Si aparecen m√°s de 8 sprites en cualquier l√≠nea horizontal de la pantalla, entonces los que aparecieron m√°s tarde simplemente no se procesar√°n.  Esta es la raz√≥n para parpadear en juegos con muchos sprites;  el programa intercambia las direcciones de los sprites en la memoria para que cada uno de ellos se represente al menos ocasionalmente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5f0/b67/13c/5f0b6713c1be1837d0da2d8213253932.gif" alt="megaman-parpadeo" width="332" height="128"></div><br>  Finalmente, el desplazamiento no afecta a los sprites: la posici√≥n del sprite en la pantalla est√° determinada por sus valores Y y X, independientemente de la posici√≥n del desplazamiento.  A veces esto es una ventaja, por ejemplo, cuando el nivel se mueve en relaci√≥n con el jugador o la interfaz permanece en una posici√≥n fija.  Sin embargo, en otros casos, esto es un signo negativo: debe mover el objeto en movimiento y luego cambiar su posici√≥n seg√∫n la cantidad de cambio en el desplazamiento. <br><br><h1>  Notas </h1><br>  [6] En teor√≠a, en realidad hay cuatro tablas de nombres, pero est√°n reflejadas de tal manera que solo 2 de ellas contienen gr√°ficos √∫nicos.  Cuando se colocan lado a lado, esto se llama reflejo vertical, y cuando las tablas de nombres se encuentran una encima de la otra, reflejo horizontal. <br><br>  [7] Tambi√©n hay un registro que selecciona con qu√© tabla de nombres comenzar a renderizar, es decir, el desplazamiento es en realidad un valor de 10 bits, o 9 bits, considerando la duplicaci√≥n. <br><br>  [8] Este no es siempre el caso.  PPU se puede configurar para usar la misma p√°gina CHR para tablas de nombres que para sprites. <br><br>  [9] Quiz√°s este orden se utiliz√≥ porque corresponde a los datos que la PPU necesita procesar para una representaci√≥n eficiente. <br><br>  [10] Este bit se usa para varios efectos, por ejemplo, para mover a Mario debajo de los bloques blancos en Super Mario Bros 3, o para generar niebla sobre sprites en Castlevania 3. <br><br>  [11] PPU tambi√©n tiene una opci√≥n para habilitar sprites de 8 √ó 16, que se usa en juegos como Contra, donde hay personajes altos.  Sin embargo, se aplican todas las dem√°s restricciones. <br><br><h2>  Parte 3 </h2><br>  En las partes anteriores, hablamos sobre datos de CHR, fondos basados ‚Äã‚Äãen tablas de nombres, sprites y desplazamiento.  Y eso es pr√°cticamente todo lo que un simple cartucho NES puede hacer sin hardware adicional.  Pero para ir m√°s all√°, necesitamos explicar en detalle c√≥mo funciona el renderizado. <br><br><h1>  Renderizado </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/12b/0d4/0ad/12b0d40ad74d27ce6d8ff2499c6df163.gif" width="200" height="200"></div><br>  <i>Representaci√≥n r√°ster con una pausa para vblank</i> <br><br>  Al igual que otras computadoras viejas, NES fue dise√±ado para funcionar con televisores CRT.  Dibujan l√≠neas de exploraci√≥n en la pantalla, una a la vez, de izquierda a derecha, de arriba a abajo, utilizando una pistola de electrones que se mueve f√≠sicamente hasta el punto de la pantalla donde se dibujan estas l√≠neas.  Despu√©s de llegar a la esquina inferior, se establece un per√≠odo de tiempo llamado "blanco vertical" (o vblank): la pistola de electrones regresa a la esquina superior izquierda para prepararse para dibujar el siguiente cuadro.  Dentro de NES, la unidad de procesamiento de im√°genes (PPU) realiza la representaci√≥n r√°ster autom√°ticamente, en cada cuadro, y el c√≥digo que funciona en la CPU realiza todas las tareas que debe realizar el juego.  Vblank permite que el programa reemplace los datos en la memoria PPU, porque de lo contrario, estos datos se utilizar√°n para la representaci√≥n.  Muy a menudo, los cambios en la tabla de nombres y paletas PPU se realizan durante esta peque√±a ventana. <br><br>  Sin embargo, se pueden hacer algunos cambios en el estado de la PPU durante el renderizado de la pantalla.  Se llaman "efectos de trama".  La acci√≥n m√°s com√∫n realizada durante el renderizado de pantalla es establecer la posici√≥n de desplazamiento.  Gracias a esto, parte de la imagen permanece est√°tica (por ejemplo, la interfaz del juego), y todo lo dem√°s contin√∫a desplaz√°ndose.  Para lograr este efecto, es necesario seleccionar con precisi√≥n el tiempo para cambiar el valor de desplazamiento para que ocurra en la l√≠nea r√°ster deseada.  Existen muchas t√©cnicas para implementar este tipo de sincronizaci√≥n entre el c√≥digo del juego y la PPU. <br><br><h1>  Pantalla dividida </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36e/4bf/c1e/36e4bfc1e8e92ae1dbfb83225946dc0f.png" width="512" height="480"></div><br>  <i>El nivel se desplaza y la interfaz en la parte superior de la pantalla permanece estacionaria</i> <br><br>  En primer lugar, PPU tiene un hardware incorporado que procesa sprites en la posici√≥n de memoria cero de una manera especial.  Al representar este sprite, si uno de sus p√≠xeles se superpone a la parte visible del fondo, se establece un bit llamado "bandera sprite0".  El c√≥digo del juego puede colocar primero este sprite donde deber√≠a ocurrir la divisi√≥n de la pantalla, y luego esperar en un bucle, verificando el valor de la bandera sprite0.  Por lo tanto, cuando se sale del bucle, el juego sabr√° con certeza qu√© l√≠nea de trama se est√° representando actualmente.  Esta t√©cnica se utiliza para implementar el uso compartido de pantalla simple en muchos juegos de NES, incluido Ninja Gaiden (1989), que se muestra arriba [12] <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/66b/acd/f19/66bacdf196bab83b91ea70c2657dd497.png" alt="ninja-hud" width="256" height="240"></div><br>  <i>Sprite0 se encuentra en Y $ 26, X $ a0.</i>  <i>Cuando se representa su fila inferior de p√≠xeles, se establece el indicador sprite0</i> <br><br>  En algunos juegos, el indicador sprite0 se combina con otra t√©cnica: bucle de tiempo predecible ("un ciclo con tiempo predecible"): el programa espera hasta que se procesen algunas l√≠neas adicionales para dividir la pantalla en m√°s partes.  Por ejemplo, esta t√©cnica se usa en muchos protectores de pantalla de Ninja Gaiden para crear efectos dram√°ticos, por ejemplo, un campo impulsado por el viento o una imagen de un castillo en la distancia.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El juego realiza tareas como reproducir m√∫sica y esperar a que el jugador ingrese, al comienzo de la representaci√≥n del cuadro, luego usa sprite0 para buscar la primera divisi√≥n, y para todos los dem√°s usa bucles temporizados.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf9/19a/bfd/cf919abfdd1c0d786440e0af2c99bb24.gif" alt="ninjas en el campo" width="512" height="480"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f77/fab/d51/f77fabd51c4431db2c98ee1bf64e0eb2.gif" alt="vista del castillo" width="512" height="480"></div><br>             ,    ,      .          ( ,         (memory mapping)),          [13],       .             ,     .      NES,      ,    . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/618/9c3/f4f/6189c3f4fa79e5c31b80b2c14df75dcb.gif" alt="nivel de tren" width="512" height="480"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ hay un ejemplo de Ninja Gaiden 2, que utiliza un mapeador para realizar varias particiones y simular el desplazamiento de paralaje, lo que crea una sensaci√≥n de gran velocidad, a pesar de la naturaleza est√°tica del nivel. </font><font style="vertical-align: inherit;">Tenga en cuenta que todas las partes m√≥viles individuales ocupan franjas estrictamente horizontales; </font><font style="vertical-align: inherit;">es decir, ninguna de las capas de fondo puede superponerse con otra. </font><font style="vertical-align: inherit;">Esto se debe a que las separaciones se implementan realmente cambiando el desplazamiento de las l√≠neas de trama individuales.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cambio de banco </font></font></h1><br>       ,        .  ,       ,      [14].        (        ),     CHR,      ,       .      ,       .                 .    Ninja Gaiden             ,     ,           CHR. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69f/896/804/69f8968042bded347183e35af32c16ae.gif" alt="goofall-bg" width="512" height="480"></div><br> <i> ,     </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/290/882/f90/290882f90bb731af9e98f7ee65b4e64f.png" alt="goofall-nt" width="512" height="480"></div><br> <i>  ,        </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf7/077/b23/cf7077b23ea5242b4f27d308b7514077.png" width="512" height="480"></div><br> <i>      CHR.     ,     </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a2/335/28e/7a233528e53b01341d21112b3651310e.png" alt="¬øQui√©nes son ellos?" width="512" height="480"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la parte inferior, se utiliza otro banco CHR. Al cambiar de banco, el valor de desplazamiento tambi√©n se restablece.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La conmutaci√≥n de banco tambi√©n se puede utilizar para el desplazamiento de paralaje, en una forma limitada (pero a√∫n impresionante). Si la escena tiene una parte del fondo compuesta por un patr√≥n repetitivo corto, entonces este mismo patr√≥n puede estar contenido en varios bancos con una compensaci√≥n por una cantidad diferente. Luego, este patr√≥n puede desplazarse a un cierto valor cambiando al banco con el desplazamiento correspondiente. Dicha t√©cnica se puede utilizar para el desplazamiento de paralaje incluso con una superposici√≥n de fondo debido a la presencia de mosaicos que no se ven afectados por el cambio de memoria [15]. La desventaja de este m√©todo es que, en total, todos los bancos necesitan ocupar mucho espacio CHR.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/501/6b4/281/5016b4281a88523177dffef3f8de4250.gif" alt="tormenta de metal bg" width="512" height="464"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metal Storm (1991) utiliza el cambio de banco para el desplazamiento de capa por lado</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c05/7d4/6cb/c057d46cbf7f4d2cfb3e401d1658692f.png" alt="tormenta de metal" width="512" height="464"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La repetici√≥n de la tabla de nombres le permite crear este efecto</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CHR con el cambio de bancos: esta es una herramienta muy poderosa, pero tiene sus limitaciones. </font><font style="vertical-align: inherit;">Aunque es √∫til para animar la pantalla completa, esta t√©cnica no es muy adecuada para reemplazar solo una peque√±a parte de la pantalla; </font><font style="vertical-align: inherit;">Esto tambi√©n requiere cambios en la tabla de nombres. </font><font style="vertical-align: inherit;">Adem√°s, la cantidad de CHR en el cartucho es limitada, y para cambiar a datos, primero deben existir. </font><font style="vertical-align: inherit;">Finalmente, con la excepci√≥n de los efectos de trama basados ‚Äã‚Äãen desplazamiento, el juego siempre tiene una grilla estricta de tablas de nombres, lo que limita el rango din√°mico de los efectos gr√°ficos.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Otros ejemplos </font></font></h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ad/f22/f28/9adf22f2804a300f6f3e9a98fe15c13b.gif" alt="vicio de fuego" width="512" height="480"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El juego Vice: Project Doom (1991) crea este efecto de llama al configurar repetidamente la posici√≥n de desplazamiento en cada l√≠nea de trama. </font><font style="vertical-align: inherit;">El personaje en primer plano se crea a partir de sprites que no se ven afectados por el desplazamiento.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/253/25b/9b9/25325b9b935359508dc420aa35ef1748.gif" alt="maestro de espada" width="512" height="480"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sword Master (1990) utiliza el cambio de banco para desplazarse monta√±as en la distancia, y tambi√©n al dividir la pantalla para la interfaz y la hierba en primer plano.</font></font></i> <br><br><h1>  Agradecimientos </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No podr√≠a generar todos estos gr√°ficos para un art√≠culo sin las potentes funciones de depuraci√≥n proporcionadas por el emulador FCEUX. </font><font style="vertical-align: inherit;">Adem√°s, el wiki del sitio NesDev se ha convertido en una fuente √∫til de informaci√≥n sobre sprite0:</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fceux</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wiki NesDev</font></font></a> </li></ul><br><h1>  Notas </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[12] De hecho, la situaci√≥n con Ninja Gaiden es un poco m√°s complicada. El juego utiliza sprites de sprites de 8 √ó 16, un modo especial proporcionado por la PPU que representa los sprites como pares superpuestos verticalmente. Es decir, sprite0 es completamente transparente y sprite1 tiene una fila de p√≠xeles en la parte inferior. Tambi√©n establece la capa z de estos sprites para que se representen detr√°s de la oscuridad de la interfaz, lo que hace que todo sea invisible. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[13] Esto es bastante dif√≠cil de implementar. El c√≥digo del juego escribe la l√≠nea r√°ster deseada en el espacio de direcciones del mapeador. El mapeador intercepta las solicitudes de acceso a la memoria PPU, contando cu√°ndo se representa una nueva l√≠nea de trama. Al llegar a la l√≠nea r√°ster deseada, genera una interrupci√≥n de programa (IRQ), durante la cual se ejecuta el c√≥digo del juego, haciendo lo que se necesita durante esta l√≠nea r√°ster particular.</font></font><br><br> [14]      ,         ,    .   ,    , -      4   8 . <br><br> [15]     CHR        :      ,      .        , ,  1   ,     . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/470614/">https://habr.com/ru/post/470614/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../470602/index.html">C√≥mo se ver√≠a el metro de Mosc√∫ en un mundo tridimensional</a></li>
<li><a href="../470604/index.html">Velocidad de carga de sitios en comercio electr√≥nico: an√°lisis de las 48 mejores tiendas en l√≠nea en Rusia</a></li>
<li><a href="../470608/index.html">Optimizaci√≥n de la interfaz de usuario de Unity</a></li>
<li><a href="../470610/index.html">Un d√≠a en la vida de un desarrollador.</a></li>
<li><a href="../470612/index.html">Lo que muestra un volt√≠metro, o enchufes matem√°ticos</a></li>
<li><a href="../470616/index.html">Una nueva soluci√≥n a la paradoja de Fermi (por qu√© estamos solos en el universo)</a></li>
<li><a href="../470618/index.html">Modelado tem√°tico de noticias usando an√°lisis factorial</a></li>
<li><a href="../470620/index.html">Infraestructura como c√≥digo: c√≥mo superar problemas con XP</a></li>
<li><a href="../470622/index.html">Descripci√≥n general de los m√©todos de selecci√≥n de funciones</a></li>
<li><a href="../470628/index.html">Simulador de naves espaciales construcci√≥n naval</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>