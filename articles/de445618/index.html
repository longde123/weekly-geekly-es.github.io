<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Ⓜ️ ❎ 😕 Wir schreiben ein Betriebssystem auf Rust. Implementieren des Seitenspeichers (neu) 🐯 👭 👂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel erfahren Sie, wie Sie die Unterstützung des Seitenspeichers in unserem Kern implementieren. Zunächst werden wir verschiedene Methode...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir schreiben ein Betriebssystem auf Rust. Implementieren des Seitenspeichers (neu)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445618/">  In diesem Artikel erfahren Sie, wie Sie die Unterstützung des Seitenspeichers in unserem Kern implementieren.  Zunächst werden wir verschiedene Methoden untersuchen, damit die Frames der physischen Seitentabelle für den Kernel verfügbar werden, und ihre Vor- und Nachteile diskutieren.  Dann implementieren wir die Adressübersetzungsfunktion und die Funktion zum Erstellen eines neuen Mappings. <br><br>  Diese Artikelserie wurde auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub veröffentlicht</a> .  Wenn Sie Fragen oder Probleme haben, öffnen Sie dort das entsprechende Ticket.  Alle Quellen für den Artikel befinden sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in diesem Thread</a> . <br><br>  <i><b>Ein weiterer Artikel über Paging?</b></i> <i><br></i>  <i>Wenn Sie diesem Zyklus folgen, haben Sie Ende Januar den Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Seitenspeicher: Fortgeschrittene Ebene“ gesehen</a> .</i>  <i>Aber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ich wurde</a> für rekursive Seitentabellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kritisiert</a> .</i>  <i>Aus diesem Grund habe ich beschlossen, den Artikel neu zu schreiben und einen anderen Ansatz für den Zugriff auf Frames zu verwenden.</i> <br><a name="habracut"></a><br>  <i>Hier ist eine neue Option.</i>  <i>Der Artikel erklärt immer noch, wie rekursive Seitentabellen funktionieren, aber wir verwenden eine einfachere und leistungsfähigere Implementierung.</i>  <i>Wir werden den vorherigen Artikel nicht löschen, sondern als veraltet markieren und nicht aktualisieren.</i> <i><br><br></i>  <i>Ich hoffe, Sie genießen die neue Option!</i> <br><br><h1>  Inhalt </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einführung</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abhängigkeitsaktualisierungen</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zugriff auf Seitentabellen</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Identitätszuordnung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Versetzte Karte korrigiert</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vollständige Zuordnung des physischen Speichers</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Temporäre Anzeige</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rekursive Seitentabellen</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bootloader-Unterstützung</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Boot-Informationen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einstiegspunktmakro</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implementierung</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zugriff auf Seitentabellen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Adressübersetzung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwenden von MappedPageTable</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erstellen Sie eine neue Zuordnung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rahmenauswahl</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zusammenfassung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was weiter?</a> </li></ul><br><a name="1"></a><h1>  Einführung </h1><br>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letzten Artikel haben</a> wir die Prinzipien des Paging-Speichers und die Funktionsweise der vierstufigen Seitentabellen unter <code>x86_64</code> .  Wir haben auch festgestellt, dass der Loader bereits die Seitentabellenhierarchie für unseren Kernel eingerichtet hat, sodass der Kernel auf virtuellen Adressen ausgeführt wird.  Dies erhöht die Sicherheit, da nicht autorisierter Zugriff auf den Speicher einen Seitenfehler verursacht, anstatt den physischen Speicher zufällig zu ändern. <br><br>  Der Artikel konnte von unserem Kernel aus nicht auf Seitentabellen zugreifen, da diese im physischen Speicher gespeichert sind und der Kernel bereits auf virtuellen Adressen ausgeführt wird.  Hier setzen wir das Thema fort und untersuchen verschiedene Optionen für den Zugriff auf die Frames der Seitentabelle vom Kernel aus.  Wir werden die Vor- und Nachteile jedes einzelnen von ihnen diskutieren und dann die geeignete Option für unseren Kern auswählen. <br><br>  Bootloader-Unterstützung ist erforderlich, daher werden wir sie zuerst konfigurieren.  Anschließend implementieren wir eine Funktion, die die gesamte Hierarchie der Seitentabellen durchläuft, um virtuelle Adressen in physische Adressen zu übersetzen.  Schließlich lernen wir, wie Sie neue Zuordnungen in Seitentabellen erstellen und nicht verwendete Speicherrahmen zum Erstellen neuer Tabellen finden. <br><br><a name="1_1"></a><h3>  Abhängigkeitsaktualisierungen </h3><br>  In diesem Artikel müssen Sie den <code>bootloader</code> Version 0.4.0 oder höher und <code>x86_64</code> Version 0.5.2 oder höher in den Abhängigkeiten registrieren.  Sie können die Abhängigkeiten in <code>Cargo.toml</code> : <br><br><pre> <code class="plaintext hljs">[dependencies] bootloader = "0.4.0" x86_64 = "0.5.2"</code> </pre> <br>  Änderungen in diesen Versionen finden Sie <a href="">im Bootloader-Protokoll</a> und im <a href="">x86_64-Protokoll</a> . <br><br><a name="2"></a><h1>  Zugriff auf Seitentabellen </h1><br>  Der Zugriff auf Seitentabellen über den Kernel ist nicht so einfach, wie es scheint.  Um das Problem zu verstehen, werfen Sie einen weiteren Blick auf die vierstufige Tabellenhierarchie aus dem vorherigen Artikel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c8/5e8/a14/9c85e8a145a9078cfcfd92e204f69a5b.svg"></div><br><br>  Wichtig ist, dass in jedem Seiteneintrag die <i>physikalische</i> Adresse der nächsten Tabelle gespeichert wird.  Dies vermeidet die Übersetzung dieser Adressen, was die Leistung verringert und leicht zu Endlosschleifen führt. <br><br>  Das Problem ist, dass wir vom Kernel nicht direkt auf physische Adressen zugreifen können, da dies auch für virtuelle Adressen funktioniert.  Wenn wir beispielsweise zur Adresse <code>4 KiB</code> , erhalten wir Zugriff auf die <i>virtuelle</i> Adresse <code>4 KiB</code> und nicht auf die <i>physische</i> Adresse, an der die Seitentabelle der 4. Ebene gespeichert ist.  Wenn wir auf die physische Adresse von <code>4 KiB</code> zugreifen möchten, müssen wir eine virtuelle Adresse verwenden, die in diese übersetzt wird. <br><br>  Um auf die Frames der Seitentabellen zuzugreifen, müssen Sie diesen Frames einige virtuelle Seiten zuordnen.  Es gibt verschiedene Möglichkeiten, solche Zuordnungen zu erstellen. <br><br><a name="2_1"></a><h3>  Identitätszuordnung </h3><br>  Eine einfache Lösung ist die <b>identische Anzeige aller Seitentabellen</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/813/916/8f3813916cd0a5b5174c8d14dabedb7a.svg"></div><br><br>  In diesem Beispiel sehen wir die identische Anzeige von Frames.  Die physischen Adressen der Seitentabellen sind gleichzeitig gültige virtuelle Adressen, so dass wir ab dem Register CR3 problemlos auf die Seitentabellen aller Ebenen zugreifen können. <br><br>  Dieser Ansatz überfüllt jedoch den virtuellen Adressraum und macht es schwierig, große zusammenhängende Bereiche des freien Speichers zu finden.  Angenommen, wir möchten in der obigen Abbildung einen virtuellen Speicherbereich von 1000 KB erstellen, um beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine Datei im Speicher anzuzeigen</a> .  Wir können nicht mit der <code>28 KiB</code> Region beginnen, da sie bei <code>1004  KiB</code> auf einer bereits belegten Seite liegt.  Daher müssen Sie weiter suchen, bis wir ein geeignetes großes Fragment finden, beispielsweise mit <code>1008  KiB</code> .  Es gibt das gleiche Fragmentierungsproblem wie im segmentierten Speicher. <br><br>  Darüber hinaus ist die Erstellung neuer Seitentabellen viel komplizierter, da physische Frames gefunden werden müssen, deren entsprechende Seiten noch nicht verwendet werden.  Für unsere Datei haben wir beispielsweise einen Bereich von 1000 KB <i>virtuellem</i> Speicher reserviert, beginnend bei der Adresse <code>1008  KiB</code> .  Jetzt können wir keinen Frame mit einer physischen Adresse zwischen <code>1000  KiB</code> und <code>2008  KiB</code> , da dieser nicht identisch angezeigt werden kann. <br><br><a name="2_2"></a><h3>  Versetzte Karte korrigiert </h3><br>  Um eine Überlastung des virtuellen Adressraums zu vermeiden, können Sie die Seitentabellen in einem <b>separaten Speicherbereich</b> anzeigen.  Anstatt die Zuordnung zu identifizieren, ordnen wir daher Frames mit einem festen Versatz im virtuellen Adressraum zu.  Zum Beispiel kann der Versatz 10 TiB betragen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f4a/c8a/5ea/f4ac8a5ea64fd215de176248b5f74e20.svg"><br><br>  Indem wir diesen Bereich des virtuellen Speichers ausschließlich für die Anzeige von Seitentabellen zuweisen, vermeiden wir die Probleme einer identischen Anzeige.  Das Reservieren eines so großen Bereichs des virtuellen Adressraums ist nur möglich, wenn der virtuelle Adressraum viel größer als der physische Speicher ist.  Unter <code>x86_64</code> dies kein Problem, da der 48-Bit-Adressraum 256 TiB beträgt. <br><br>  Dieser Ansatz hat jedoch den Nachteil, dass Sie beim Erstellen jeder Seitentabelle eine neue Zuordnung erstellen müssen.  Darüber hinaus ist der Zugriff auf Tabellen in anderen Adressräumen nicht zulässig, was beim Erstellen eines neuen Prozesses hilfreich wäre. <br><br><a name="2_3"></a><h3>  Vollständige Zuordnung des physischen Speichers </h3><br>  Wir können diese Probleme lösen, indem wir den <b>gesamten physischen Speicher</b> und nicht nur Seitentabellenrahmen <b>anzeigen</b> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c39/3cf/7df/c393cf7df76515739e1d9274160c4b5d.svg"><br><br>  Dieser Ansatz ermöglicht es dem Kernel, auf einen beliebigen physischen Speicher zuzugreifen, einschließlich Seitentabellenrahmen anderer Adressräume.  Ein Bereich des virtuellen Speichers ist in der gleichen Größe wie zuvor reserviert, es sind jedoch nur keine nicht übereinstimmenden Seiten vorhanden. <br><br>  Der Nachteil dieses Ansatzes besteht darin, dass zusätzliche Seitentabellen erforderlich sind, um den physischen Speicher anzuzeigen.  Diese Seitentabellen sollten irgendwo gespeichert werden, damit sie einen Teil des physischen Speichers belegen, was bei Geräten mit wenig RAM ein Problem sein kann. <br><br>  Auf x86_64 können wir jedoch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">riesige</a> 2-MiB- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Seiten</a> anstelle der Standardgröße von 4 KiB für die Anzeige verwenden.  Um 32 GB physischen Speicher anzuzeigen, sind daher nur 132 KB pro Seitentabelle erforderlich: nur eine Tabelle der dritten Ebene und 32 Tabellen der zweiten Ebene.  Riesige Seiten werden auch effizienter zwischengespeichert, da sie weniger Einträge im TLB (Dynamic Translation Buffer) verwenden. <br><br><a name="2_4"></a><h3>  Temporäre Anzeige </h3><br>  Bei Geräten mit sehr wenig physischem Speicher können Sie <b>Seitentabellen</b> nur <b>vorübergehend anzeigen,</b> wenn Sie darauf zugreifen müssen.  Für temporäre Vergleiche ist eine identische Anzeige nur der Tabelle der ersten Ebene erforderlich: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00a/3ab/5ce/00a3ab5ce85057d3679a48379d3d2297.svg"></div><br><br>  In dieser Abbildung verwaltet eine Tabelle der Ebene 1 die ersten 2 MiB des virtuellen Adressraums.  Dies ist möglich, weil der Zugriff vom CR3-Register über Null-Einträge in den Tabellen der Ebenen 4, 3 und 2 erfolgt. Der Datensatz mit Index <code>8</code> übersetzt die virtuelle Seite mit <code>32 KiB</code> in einen physischen Rahmen mit <code>32 KiB</code> , wodurch die Tabelle der Ebene 1 selbst identifiziert wird. In der Abbildung ist dies durch einen horizontalen Pfeil dargestellt. <br><br>  Durch Schreiben in die identisch zugeordnete Tabelle der Ebene 1 kann unser Kernel bis zu 511 Zeitvergleiche erstellen (512 abzüglich des für die Identitätszuordnung erforderlichen Datensatzes).  Im obigen Beispiel erstellt der Kernel zwei Zeitvergleiche: <br><br><ul><li>  Zuordnen eines Nulleintrags in einer Tabelle der Ebene 1 zu einem Frame mit <code>24 KiB</code> .  Dadurch wird eine temporäre Zuordnung der virtuellen Seite bei <code>0 KiB</code> zu dem physischen Rahmen der Tabelle der Seitenebene 2 erstellt, der durch den gepunkteten Pfeil angezeigt wird. </li><li>  Ordnen Sie den 9. Datensatz eines Level 1-Tisches einem Frame von <code>4 KiB</code> .  Dadurch wird eine temporäre Zuordnung der virtuellen Seite mit <code>36 KiB</code> zum physischen Rahmen der Tabelle der Seitenebene 4 erstellt, die durch den gepunkteten Pfeil gekennzeichnet ist. </li></ul><br>  Jetzt kann der Kernel auf eine Tabelle der Ebene 2 zugreifen, indem er auf eine Seite schreibt, die bei <code>0 KiB</code> beginnt, und auf eine Tabelle der Ebene 4, indem er auf eine Seite schreibt, die bei <code>33 KiB</code> beginnt. <br><br>  Der Zugriff auf einen beliebigen Rahmen der Seitentabelle mit temporären Zuordnungen besteht daher aus den folgenden Aktionen: <br><br><ul><li>  Suchen Sie einen freien Eintrag in der identisch angezeigten Tabelle der Ebene 1. <br></li><li>  Ordnen Sie diesen Eintrag dem physischen Rahmen der Seitentabelle zu, auf die wir zugreifen möchten. <br></li><li>  Greifen Sie über die dem Eintrag zugeordnete virtuelle Seite auf diesen Frame zu. <br></li><li>  Setzen Sie den Datensatz wieder auf nicht verwendet, wodurch die temporäre Zuordnung entfernt wird. </li></ul><br>  Bei diesem Ansatz bleibt der virtuelle Adressraum sauber, da ständig dieselben 512 virtuellen Seiten verwendet werden.  Der Nachteil ist eine gewisse Umständlichkeit, insbesondere da für einen neuen Vergleich möglicherweise mehrere Tabellenebenen geändert werden müssen, dh der beschriebene Vorgang mehrmals wiederholt werden muss. <br><br><a name="2_5"></a><h3>  Rekursive Seitentabellen </h3><br>  Ein weiterer interessanter Ansatz, für den überhaupt keine zusätzlichen Seitentabellen erforderlich sind, ist der <b>rekursive Abgleich</b> . <br><br>  Die Idee ist, einige Datensätze aus der Tabelle der vierten Ebene in sie selbst zu übersetzen.  Daher reservieren wir tatsächlich einen Teil des virtuellen Adressraums und ordnen diesem Raum alle aktuellen und zukünftigen Tabellenrahmen zu. <br><br>  Schauen wir uns ein Beispiel an, um zu verstehen, wie das alles funktioniert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/779/ee6/d9b/779ee6d9bf771dec8e6d22c0440e503d.png"></div><br><br>  Der einzige Unterschied zum Beispiel am Anfang des Artikels besteht in einem zusätzlichen Datensatz mit dem Index <code>511</code> in der Tabelle der Ebene 4, der dem physischen Frame <code>4 KiB</code> , der sich in dieser Tabelle selbst befindet. <br><br>  Wenn die CPU in diesen Datensatz wechselt, bezieht sie sich nicht auf die Tabelle der Ebene 3, sondern erneut auf die Tabelle der Ebene 4. Dies ähnelt einer rekursiven Funktion, die sich selbst aufruft.  Es ist wichtig, dass der Prozessor davon ausgeht, dass jeder Eintrag in der Tabelle der Ebene 4 auf eine Tabelle der Ebene 3 verweist. Daher wird die Tabelle der Ebene 4 jetzt als Tabelle der Ebene 3 behandelt. Dies funktioniert, da Tabellen aller Ebenen in x86_64 dieselbe Struktur haben. <br><br>  Indem Sie einem rekursiven Datensatz ein oder mehrere Male folgen, bevor Sie mit der eigentlichen Konvertierung beginnen, können Sie die Anzahl der Ebenen, die der Prozessor durchläuft, effektiv reduzieren.  Wenn wir beispielsweise dem rekursiven Datensatz einmal folgen und dann zur Tabelle der Ebene 3 wechseln, denkt der Prozessor, dass die Tabelle der Ebene 3 eine Tabelle der Ebene 2 ist. Im weiteren Verlauf betrachtet er die Tabelle der Ebene 2 als Tabelle der Ebene 1 und die Tabelle der Ebene 1 als zugeordnet Frame im physischen Speicher.  Dies bedeutet, dass wir jetzt in die Tabelle der Seitenebene 1 lesen und schreiben können, da der Prozessor dies für einen zugeordneten Frame hält.  Die folgende Abbildung zeigt die fünf Schritte einer solchen Übersetzung: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/ac7/191/bdaac719103c574c655efa3604d0b842.png"></div><br><br>  Ebenso können wir einem rekursiven Eintrag zweimal folgen, bevor wir mit der Konvertierung beginnen, um die Anzahl der übergebenen Ebenen auf zwei zu reduzieren: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f4/b9a/c47/7f4b9ac47fce9552dead4e551b804256.png"></div><br><br>  Lassen Sie uns diese Prozedur Schritt für Schritt durchgehen.  Zuerst folgt die CPU einem rekursiven Eintrag in der Tabelle der Ebene 4 und denkt, dass sie die Tabelle der Ebene 3 erreicht hat. Dann folgt sie erneut dem rekursiven Datensatz und denkt, dass sie die Ebene 2 erreicht hat. In Wirklichkeit befindet sie sich jedoch immer noch auf Ebene 4. Dann geht die CPU zur neuen Adresse und gelangt in die Level 3-Tabelle, denkt jedoch, dass sie sich bereits in der Level 1-Tabelle befindet. Schließlich glaubt der Prozessor am nächsten Einstiegspunkt in der Level 2-Tabelle, auf den physischen Speicherrahmen zugegriffen zu haben.  Dies ermöglicht uns das Lesen und Schreiben in eine Tabelle der Ebene 2. <br><br>  Auf die Tabellen der Ebenen 3 und 4 wird ebenfalls zugegriffen. Um auf die Tabelle der Ebenen 3 zuzugreifen, folgen wir dreimal einem rekursiven Eintrag: Der Prozessor glaubt, dass er sich bereits in der Tabelle der Ebene 1 befindet, und im nächsten Schritt erreichen wir die Ebene 3, die die CPU als zugeordneten Frame betrachtet.  Um auf die Level 4-Tabelle selbst zuzugreifen, folgen wir einfach viermal dem rekursiven Datensatz, bis der Prozessor die Level 4-Tabelle selbst als zugeordneten Frame verarbeitet (in der folgenden Abbildung blau). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/487/a82/92c/487a8292cf8fe673f1914f5f198c0956.png"></div><br><br>  Das Konzept ist zunächst schwer zu verstehen, aber in der Praxis funktioniert es ziemlich gut. <br><br><h4>  Adressberechnung </h4><br>  Wir können also auf Tabellen aller Ebenen zugreifen, indem wir einem oder mehreren rekursiven Datensätzen folgen.  Da Indizes in Tabellen mit vier Ebenen direkt von der virtuellen Adresse abgeleitet werden, müssen für diese Methode spezielle virtuelle Adressen erstellt werden.  Wie wir uns erinnern, werden Seitentabellenindizes wie folgt aus der Adresse extrahiert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c44/33c/8f9/c4433c8f99b6fcb54d4b79983ca35dbc.svg"></div><br><br>  Angenommen, wir möchten auf eine Tabelle der Ebene 1 zugreifen, in der eine bestimmte Seite angezeigt wird.  Wie wir oben erfahren haben, müssen Sie einmal einen rekursiven Datensatz und dann die Indizes der 4., 3. und 2. Ebene durchlaufen.  Dazu verschieben wir alle Adressblöcke einen Block nach rechts und setzen den Index des rekursiven Datensatzes an die Stelle des Anfangsindex der Ebene 4: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62a/d82/b54/62ad82b54b233a37e40b964953a16bf8.svg"></div><br><br>  Um auf die Tabelle der Ebene 2 dieser Seite zuzugreifen, verschieben wir alle Indexblöcke zwei Blöcke nach rechts und setzen den rekursiven Index an die Stelle beider Quellblöcke: Ebene 4 und Ebene 3: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d9/ae5/7c8/1d9ae57c8c68a0b239e5b37397a4d0f7.svg"></div><br><br>  Um auf die Tabelle der Ebene 3 zuzugreifen, machen wir dasselbe, wir verschieben einfach bereits drei Adressblöcke nach rechts. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b8/6ee/c9f/4b86eec9fd1df3445718ed8246fd4473.svg"></div><br><br>  Um auf die Tabelle der Ebene 4 zuzugreifen, verschieben Sie alle vier Blöcke nach rechts. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36b/6b0/29b/36b6b029b31578b143ff1e7605e358fb.svg"></div><br><br>  Jetzt können Sie virtuelle Adressen für Seitentabellen aller vier Ebenen berechnen.  Wir können sogar eine Adresse berechnen, die genau auf einen bestimmten Seitentabelleneintrag verweist, indem wir dessen Index mit 8 multiplizieren, der Größe des Seitentabelleneintrags. <br><br>  Die folgende Tabelle zeigt die Struktur der Adressen für den Zugriff auf verschiedene Arten von Frames: <br><br><table><thead><tr><th>  Virtuelle Adresse für </th><th>  Adressstruktur ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">oktal</a> ) </th></tr></thead><tbody><tr><td>  Seite </td><td> <code>0o_SSSSSS_AAA_BBB_CCC_DDD_EEEE</code> </td> </tr><tr><td>  Eintrag in Level 1 Tabelle </td><td> <code>0o_SSSSSS_RRR_AAA_BBB_CCC_DDDD</code> </td> </tr><tr><td>  Eintrag in eine Level 2 Tabelle </td><td> <code>0o_SSSSSS_RRR_RRR_AAA_BBB_CCCC</code> </td> </tr><tr><td>  Eintrag in eine Level 3 Tabelle </td><td> <code>0o_SSSSSS_RRR_RRR_RRR_AAA_BBBB</code> </td> </tr><tr><td>  Eintrag in Level 4 Tabelle </td><td> <code>0o_SSSSSS_RRR_RRR_RRR_RRR_AAAA</code> </td> </tr></tbody></table><br>  Hier ist <code></code> der Level 4-Index, <code></code> ist Level 3, <code></code> ist Level 2 und <code>DDD</code> ist Level 1-Index für den angezeigten Frame, <code>EEEE</code> ist sein Offset.  <code>RRR</code> ist der Index des rekursiven Datensatzes.  Ein Index (drei Ziffern) wird durch Multiplikation mit 8 (der Größe des Seitentabelleneintrags) in einen Versatz (vier Ziffern) umgewandelt.  Mit diesem Versatz zeigt die resultierende Adresse direkt auf den entsprechenden Seitentabelleneintrag. <br><br>  <code>SSSS</code> sind Erweiterungsbits der vorzeichenbehafteten Ziffer, <code>SSSS</code> sie sind alle Kopien von Bit 47. Dies ist eine spezielle Anforderung für gültige Adressen in der x86_64-Architektur, die wir in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Artikel</a> erörtert haben. <br><br>  Die Adressen sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">oktal</a> , da jedes Oktalzeichen drei Bits darstellt, wodurch Sie die 9-Bit-Indizes von Tabellen auf verschiedenen Ebenen klar trennen können.  Dies ist im Hexadezimalsystem nicht möglich, bei dem jedes Zeichen vier Bits darstellt. <br><br><h4>  Rostcode </h4><br>  Sie können solche Adressen im Rust-Code mithilfe bitweiser Operationen erstellen: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// the virtual address whose corresponding page tables you want to access let addr: usize = […]; let r = 0o777; // recursive index let sign = 0o177777 &lt;&lt; 48; // sign extension // retrieve the page table indices of the address that we want to translate let l4_idx = (addr &gt;&gt; 39) &amp; 0o777; // level 4 index let l3_idx = (addr &gt;&gt; 30) &amp; 0o777; // level 3 index let l2_idx = (addr &gt;&gt; 21) &amp; 0o777; // level 2 index let l1_idx = (addr &gt;&gt; 12) &amp; 0o777; // level 1 index let page_offset = addr &amp; 0o7777; // calculate the table addresses let level_4_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (r &lt;&lt; 21) | (r &lt;&lt; 12); let level_3_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (r &lt;&lt; 21) | (l4_idx &lt;&lt; 12); let level_2_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (l4_idx &lt;&lt; 21) | (l3_idx &lt;&lt; 12); let level_1_table_addr = sign | (r &lt;&lt; 39) | (l4_idx &lt;&lt; 30) | (l3_idx &lt;&lt; 21) | (l2_idx &lt;&lt; 12);</span></span></code> </pre> <br>  Dieser Code setzt voraus, dass eine rekursive Zuordnung des letzten Datensatzes der Ebene 4 mit dem Index <code>0o777</code> (511) rekursiv übereinstimmt.  Dies ist derzeit nicht der Fall, sodass der Code noch nicht funktioniert.  Im Folgenden erfahren Sie, wie Sie den Loader anweisen, eine rekursive Zuordnung einzurichten. <br><br>  Alternativ zur manuellen Ausführung bitweiser Operationen können Sie den Typ <code>RecursivePageTable</code> der <code>x86_64</code> Kiste verwenden, der sichere Abstraktionen für verschiedene Tabellenoperationen bietet.  Der folgende Code zeigt beispielsweise, wie eine virtuelle Adresse in die entsprechende physische Adresse konvertiert wird: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::{Mapper, Page, PageTable, RecursivePageTable}; use x86_64::{VirtAddr, PhysAddr}; /// Creates a RecursivePageTable instance from the level 4 address. let level_4_table_addr = […]; let level_4_table_ptr = level_4_table_addr as *mut PageTable; let recursive_page_table = unsafe { let level_4_table = &amp;mut *level_4_table_ptr; RecursivePageTable::new(level_4_table).unwrap(); } /// Retrieve the physical address for the given virtual address let addr: u64 = […] let addr = VirtAddr::new(addr); let page: Page = Page::containing_address(addr); // perform the translation let frame = recursive_page_table.translate_page(page); frame.map(|frame| frame.start_address() + u64::from(addr.page_offset()))</span></span></code> </pre> <br>  Auch dieser Code erfordert eine korrekte rekursive Zuordnung.  Bei dieser Zuordnung wird die fehlende <code>level_4_table_addr</code> wie im ersten Codebeispiel berechnet. <br><br><hr><br>  Rekursives Mapping ist eine interessante Methode, die zeigt, wie leistungsfähig Matching durch eine einzelne Tabelle sein kann.  Es ist relativ einfach zu implementieren und erfordert nur eine minimale Einrichtung (nur ein rekursiver Eintrag), daher ist dies eine gute Wahl für die ersten Experimente. <br><br>  Aber es hat einige Nachteile: <br><br><ul><li>  Eine große Menge an virtuellem Speicher (512 GiB).  Dies ist in einem großen 48-Bit-Adressraum kein Problem, kann jedoch zu einem suboptimalen Cache-Verhalten führen. <br></li><li>  Es bietet nur Zugriff auf den aktuell aktiven Adressraum.  Der Zugriff auf andere Adressräume ist weiterhin möglich, indem der rekursive Eintrag geändert wird. Für die Umschaltung ist jedoch ein temporärer Abgleich erforderlich.  Wie das geht, haben wir in einem früheren (veralteten) Artikel beschrieben. <br></li><li>  Dies hängt stark vom Format der x86-Seitentabelle ab und funktioniert möglicherweise nicht auf anderen Architekturen. </li></ul><br><a name="3"></a><h1>  Bootloader-Unterstützung </h1><br>  Alle oben beschriebenen Ansätze erfordern Änderungen an den Seitentabellen und den entsprechenden Einstellungen.  Zum Beispiel, um den physischen Speicher identisch oder rekursiv Datensätze einer Tabelle der vierten Ebene zuzuordnen.  Das Problem ist, dass wir diese Einstellungen nicht ohne Zugriff auf die Seitentabellen vornehmen können. <br><br>  Also brauche ich Hilfe vom Bootloader.  Er hat Zugriff auf Seitentabellen, sodass er alle erforderlichen Anzeigen erstellen kann.  In der aktuellen Implementierung unterstützt die <code>bootloader</code> Kiste die beiden oben genannten Ansätze mithilfe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Frachtfunktionen</a> : <br><br><ul><li>  Die Funktion <code>map_physical_memory</code> ordnet den gesamten physischen Speicher irgendwo im virtuellen Adressraum zu.  Somit erhält der Kernel Zugriff auf den gesamten physischen Speicher und kann einen Ansatz mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anzeige des vollständigen physischen Speichers</a> anwenden. <br></li><li>  Mit der Funktion recursive_page_table zeigt der Loader rekursiv einen Seitentabelleneintrag der vierten Ebene an.  Dadurch kann der Kernel gemäß der im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abschnitt "Rekursive Seitentabellen"</a> beschriebenen Methode arbeiten. </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für unseren Kernel wählen wir die erste Option, da dies ein einfacher, plattformunabhängiger und leistungsfähigerer Ansatz ist (er ermöglicht auch den Zugriff auf andere Frames, nicht nur auf Seitentabellen). </font><font style="vertical-align: inherit;">Fügen Sie zur Unterstützung des Bootloaders die Funktion zu den Abhängigkeiten hinzu </font></font><code>map_physical_memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="plaintext hljs">[dependencies] bootloader = { version = "0.4.0", features = ["map_physical_memory"]}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn diese Funktion aktiviert ist, ordnet der Bootloader den gesamten physischen Speicher einem nicht verwendeten Bereich virtueller Adressen zu. </font><font style="vertical-align: inherit;">Um einen Bereich virtueller Adressen an den Kernel zu übergeben, übergibt der Bootloader die Struktur der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Startinformationen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><a name="3_1"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Boot-Informationen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Kiste </font></font><code>bootloader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definiert die Struktur von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BootInfo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit allen Informationen, die an den Kernel übergeben werden. </font><font style="vertical-align: inherit;">Die Struktur wird noch finalisiert, daher kann es beim Upgrade auf zukünftige Versionen, die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht mit Semver kompatibel sind, zu Fehlern kommen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Derzeit hat die Struktur zwei Felder: </font></font><code>memory_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Feld </font></font><code>memory_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bietet einen Überblick über den verfügbaren physischen Speicher. </font><font style="vertical-align: inherit;">Es teilt dem Kernel mit, wie viel physischer Speicher auf dem System verfügbar ist und welche Speicherbereiche für Geräte wie VGA reserviert sind. </font><font style="vertical-align: inherit;">Eine Speicherkarte kann vom BIOS oder der UEFI-Firmware angefordert werden, jedoch nur zu Beginn des Startvorgangs. </font><font style="vertical-align: inherit;">Aus diesem Grund muss der Loader dies bereitstellen, da der Kernel diese Informationen dann nicht mehr empfangen kann. </font><font style="vertical-align: inherit;">Eine Speicherkarte wird später in diesem Artikel nützlich sein.</font></font><br></li><li> <code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">meldet die virtuelle Startadresse der physischen Speicherzuordnung. </font><font style="vertical-align: inherit;">Wenn wir diesen Offset zur physischen Adresse hinzufügen, erhalten wir die entsprechende virtuelle Adresse. </font><font style="vertical-align: inherit;">Dies ermöglicht den Zugriff vom Kernel auf einen beliebigen physischen Speicher.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Loader übergibt die Struktur </font></font><code>BootInfo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">als Argument </font></font><code>&amp;'static BootInfo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an die Funktion </font><font style="vertical-align: inherit;">an den </font><font style="vertical-align: inherit;">Kernel </font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Fügen Sie es hinzu:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs use bootloader::BootInfo; #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start(boot_info: &amp;'static BootInfo) -&gt; ! { // new argument […] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es ist wichtig, den richtigen Argumenttyp anzugeben, da der Compiler den richtigen Signaturtyp unserer Einstiegspunktfunktion nicht kennt. </font></font><br><br><a name="3_2"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Einstiegspunktmakro </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da die Funktion </font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">extern vom Loader aufgerufen wird, wird die Signatur der Funktion nicht überprüft. Dies bedeutet, dass wir beliebige Argumente ohne Kompilierungsfehler akzeptieren können, dies jedoch abstürzt oder ein undefiniertes Laufzeitverhalten verursacht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um sicherzustellen, dass die Einstiegspunktfunktion immer die richtige Signatur hat, stellt die Kiste </font></font><code>bootloader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein Makro bereit </font></font><code>entry_point</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wir schreiben unsere Funktion mit diesem Makro neu:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs use bootloader::{BootInfo, entry_point}; entry_point!(kernel_main); #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie müssen nicht mehr für den Einstiegspunkt </font></font><code>extern "C"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder </font></font><code>no_mangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, da das Makro für uns den realen Einstiegspunkt der unteren Ebene definiert, verwenden </font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Die Funktion ist </font></font><code>kernel_main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jetzt zu einer völlig normalen Rust-Funktion geworden, sodass wir einen beliebigen Namen dafür wählen können. Wichtig ist, dass es nach Typ überprüft wird. Wenn Sie also die falsche Signatur verwenden, z. B. indem Sie ein Argument hinzufügen oder seinen Typ ändern, tritt ein Kompilierungsfehler auf</font></font><br><br><a name="4"></a><h1>  Implementierung </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt haben wir Zugriff auf den physischen Speicher und können endlich mit der Implementierung des Systems beginnen. </font><font style="vertical-align: inherit;">Betrachten Sie zunächst die aktuell aktiven Seitentabellen, auf denen der Kernel ausgeführt wird. </font><font style="vertical-align: inherit;">Erstellen Sie im zweiten Schritt eine Übersetzungsfunktion, die die physische Adresse zurückgibt, der diese virtuelle Adresse zugeordnet ist. </font><font style="vertical-align: inherit;">Im letzten Schritt werden wir versuchen, die Seitentabellen zu ändern, um eine neue Zuordnung zu erstellen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie zunächst ein neues Modul im Code </font></font><code>memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/lib.rs pub mod memory;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie für das Modul eine leere Datei </font></font><code>src/memory.rs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><a name="4_1"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zugriff auf Seitentabellen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Am Ende des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vorherigen Artikels haben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir versucht, die Seitentabelle zu betrachten, auf der der Kernel arbeitet, konnten jedoch nicht auf den physischen Frame zugreifen, auf den das Register zeigt </font></font><code>CR3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Jetzt können wir von diesem Ort aus weiterarbeiten: Die Funktion </font></font><code>active_level_4_table</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gibt einen Link zur aktiven Seitentabelle der vierten Ebene zurück:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::PageTable; /// Returns a mutable reference to the active level 4 table. /// /// This function is unsafe because the caller must guarantee that the /// complete physical memory is mapped to virtual memory at the passed /// `physical_memory_offset`. Also, this function must be only called once /// to avoid aliasing `&amp;mut` references (which is undefined behavior). pub unsafe fn active_level_4_table(physical_memory_offset: u64) -&gt; &amp;'static mut PageTable { use x86_64::{registers::control::Cr3, VirtAddr}; let (level_4_table_frame, _) = Cr3::read(); let phys = level_4_table_frame.start_address(); let virt = VirtAddr::new(phys.as_u64() + physical_memory_offset); let page_table_ptr: *mut PageTable = virt.as_mut_ptr(); &amp;mut *page_table_ptr // unsafe }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuerst lesen wir den physischen Rahmen der aktiven Tabelle der 4. Ebene aus dem Register </font></font><code>CR3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dann nehmen wir die physische Startadresse und konvertieren sie durch Hinzufügen in eine virtuelle Adresse </font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Konvertieren Sie schließlich die Adresse </font></font><code>*mut PageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">durch die Methode </font><font style="vertical-align: inherit;">in einen </font></font><code>as_mut_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rohzeiger und erstellen Sie dann unsicher einen Link daraus </font></font><code>&amp;mut PageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wir erstellen </font></font><code>&amp;mut</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stattdessen </font><font style="vertical-align: inherit;">den Link </font></font><code>&amp;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, da wir später in diesem Artikel diese Seitentabellen ändern werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier muss kein unsicherer Block eingefügt werden, da Rust den gesamten Körper </font></font><code>unsafe fn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">als einen großen, unsicheren Block betrachtet. Dies erhöht die Risiken, da es möglich ist, in den vorherigen Zeilen versehentlich einen unsicheren Betrieb einzuführen. Es macht es auch schwierig, unsichere Vorgänge zu erkennen. Es </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wurde</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bereits ein </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">RFC</font></a><font style="vertical-align: inherit;"> erstellt </font><font style="vertical-align: inherit;">, um dieses Verhalten von Rust zu ändern.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir diese Funktion verwenden, um die Datensätze der Tabelle der vierten Ebene auszugeben:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] // initialize GDT, IDT, PICS use blog_os::memory::active_level_4_table; let l4_table = unsafe { active_level_4_table(boot_info.physical_memory_offset) }; for (i, entry) in l4_table.iter().enumerate() { if !entry.is_unused() { println!("L4 Entry {}: {:?}", i, entry); } } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir </font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">übergeben das entsprechende Feld der Struktur </font></font><code>BootInfo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dann verwenden wir eine Funktion </font></font><code>iter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um die Seitentabelleneinträge zu durchlaufen, und einen Kombinator </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">enumerate</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um </font></font><code>i</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jedem Element </font><font style="vertical-align: inherit;">einen Index hinzuzufügen </font><font style="vertical-align: inherit;">. Es werden nur nicht leere Einträge angezeigt, da nicht alle 512 Einträge auf den Bildschirm passen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir den Code ausführen, sehen wir folgendes Ergebnis: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a33/def/50d/a33def50db528880395b665882aabe75.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sehen mehrere nicht leere Datensätze, die verschiedenen Tabellen der dritten Ebene zugeordnet sind. Es werden so viele Speicherbereiche verwendet, weil separate Bereiche für Kernelcode, Kernelstapel, physische Speicherübersetzung und Startinformationen benötigt werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Seitentabellen durchzugehen und die Tabelle der dritten Ebene zu betrachten, können wir den angezeigten Frame erneut in eine virtuelle Adresse konvertieren:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in the for loop in src/main.rs use x86_64::{structures::paging::PageTable, VirtAddr}; if !entry.is_unused() { println!("L4 Entry {}: {:?}", i, entry); // get the physical address from the entry and convert it let phys = entry.frame().unwrap().start_address(); let virt = phys.as_u64() + boot_info.physical_memory_offset; let ptr = VirtAddr::new(virt).as_mut_ptr(); let l3_table: &amp;PageTable = unsafe { &amp;*ptr }; // print non-empty entries of the level 3 table for (i, entry) in l3_table.iter().enumerate() { if !entry.is_unused() { println!(" L3 Entry {}: {:?}", i, entry); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wiederholen Sie diesen Vorgang für Datensätze der dritten und zweiten Ebene, um die Tabellen der zweiten und ersten Ebene anzuzeigen. </font><font style="vertical-align: inherit;">Wie Sie sich vorstellen können, wächst die Menge an Code sehr schnell, sodass wir nicht die vollständige Liste veröffentlichen werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das manuelle Durchlaufen von Tabellen ist interessant, da es hilft zu verstehen, wie der Prozessor Adressen übersetzt. </font><font style="vertical-align: inherit;">Normalerweise sind wir jedoch nur daran interessiert, eine physische Adresse für eine bestimmte virtuelle Adresse anzuzeigen. Erstellen wir daher eine Funktion dafür.</font></font><br><br><a name="4_2"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adressübersetzung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um eine virtuelle Adresse in eine physische Adresse zu übersetzen, müssen wir eine vierstufige Seitentabelle durchgehen, bis wir den zugeordneten Frame erreichen. </font><font style="vertical-align: inherit;">Erstellen wir eine Funktion, die diese Adressübersetzung ausführt:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::{PhysAddr, VirtAddr}; /// Translates the given virtual address to the mapped physical address, or /// `None` if the address is not mapped. /// /// This function is unsafe because the caller must guarantee that the /// complete physical memory is mapped to virtual memory at the passed /// `physical_memory_offset`. pub unsafe fn translate_addr(addr: VirtAddr, physical_memory_offset: u64) -&gt; Option&lt;PhysAddr&gt; { translate_addr_inner(addr, physical_memory_offset) }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verweisen auf eine sichere Funktion </font></font><code>translate_addr_inner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um die Menge an unsicherem Code zu begrenzen. Wie oben erwähnt, betrachtet Rust den gesamten Körper </font></font><code>unsafe fn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">als einen großen unsicheren Block. Durch Aufrufen einer sicheren Funktion machen wir jede Operation erneut explizit </font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine spezielle interne Funktion hat echte Funktionalität:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs /// Private function that is called by `translate_addr`. /// /// This function is safe to limit the scope of `unsafe` because Rust treats /// the whole body of unsafe functions as an unsafe block. This function must /// only be reachable through `unsafe fn` from outside of this module. fn translate_addr_inner(addr: VirtAddr, physical_memory_offset: u64) -&gt; Option&lt;PhysAddr&gt; { use x86_64::structures::paging::page_table::FrameError; use x86_64::registers::control::Cr3; // read the active level 4 frame from the CR3 register let (level_4_table_frame, _) = Cr3::read(); let table_indexes = [ addr.p4_index(), addr.p3_index(), addr.p2_index(), addr.p1_index() ]; let mut frame = level_4_table_frame; // traverse the multi-level page table for &amp;index in &amp;table_indexes { // convert the frame into a page table reference let virt = frame.start_address().as_u64() + physical_memory_offset; let table_ptr: *const PageTable = VirtAddr::new(virt).as_ptr(); let table = unsafe {&amp;*table_ptr}; // read the page table entry and update `frame` let entry = &amp;table[index]; frame = match entry.frame() { Ok(frame) =&gt; frame, Err(FrameError::FrameNotPresent) =&gt; return None, Err(FrameError::HugeFrame) =&gt; panic!("huge pages not supported"), }; } // calculate the physical address by adding the page offset Some(frame.start_address() + u64::from(addr.page_offset())) }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstatt die Funktion </font></font><code>active_level_4_table</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wiederzuverwenden, lesen wir den Frame der vierten Ebene erneut aus dem Register </font></font><code>CR3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, da dies die Implementierung des Prototyps vereinfacht. Keine Sorge, wir werden die Lösung bald verbessern. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Struktur </font></font><code>VirtAddr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bietet bereits Methoden zur Berechnung von Indizes in Seitentabellen mit vier Ebenen. Wir speichern diese Indizes in einem kleinen Array, da Sie so alle Tabellen durchlaufen können </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Außerhalb der Schleife erinnern wir uns an den zuletzt besuchten Frame, um die physikalische Adresse später zu berechnen. </font></font><code>frame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zeigt auf die Frames der Seitentabelle während der Iteration und auf den zugehörigen Frame nach der letzten Iteration, dh nach dem Übergeben des Level 1-Datensatzes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Innerhalb der Schleife wenden wir erneut an</font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um einen Frame in einen Seitentabellenlink zu konvertieren. Dann lesen wir den Datensatz der aktuellen Seitentabelle und verwenden die Funktion </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>PageTableEntry::frame</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um den übereinstimmenden Frame abzurufen. Wenn der Datensatz keinem Frame zugeordnet ist, kehren Sie zurück </font></font><code>None</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn der Datensatz eine riesige Seite von 2 MiB oder 1 GiB anzeigt, haben wir bisher eine Panik. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Überprüfen wir also die Übersetzungsfunktion an einigen Adressen:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] // initialize GDT, IDT, PICS use blog_os::memory::translate_addr; use x86_64::VirtAddr; let addresses = [ // the identity-mapped vga buffer page 0xb8000, // some code page 0x20010a, // some stack page 0x57ac_001f_fe48, // virtual address mapped to physical address 0 boot_info.physical_memory_offset, ]; for &amp;address in &amp;addresses { let virt = VirtAddr::new(address); let phys = unsafe { translate_addr(virt, boot_info.physical_memory_offset) }; println!("{:?} -&gt; {:?}", virt, phys); } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir den Code ausführen, erhalten wir das folgende Ergebnis: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a0b/e32/db8/a0be32db8b6353452f9d40d7b1d350ad.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie erwartet wird bei einer identischen Zuordnung die Adresse </font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in dieselbe physikalische Adresse konvertiert. </font><font style="vertical-align: inherit;">Die Codepage und die Stapelseite werden in beliebige physische Adressen konvertiert, die davon abhängen, wie der Loader die anfängliche Zuordnung für unseren Kernel erstellt hat. </font><font style="vertical-align: inherit;">Die Zuordnung </font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sollte auf die physische Adresse verweisen </font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, schlägt jedoch fehl, da die Übersetzung aus Effizienzgründen große Seiten verwendet. </font><font style="vertical-align: inherit;">Eine zukünftige Version des Bootloaders wendet möglicherweise dieselbe Optimierung für die Kernel- und Stack-Seiten an.</font></font><br><br><a name="4_3"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verwenden von MappedPageTable </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Übersetzung virtueller Adressen in physische Adressen ist eine typische Aufgabe des Betriebssystemkerns, daher </font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bietet </font><font style="vertical-align: inherit;">die Kiste </font><font style="vertical-align: inherit;">eine Abstraktion dafür. </font><font style="vertical-align: inherit;">Es unterstützt bereits große Seiten und einige andere Funktionen, außer dass </font></font><code>translate_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir es verwenden, anstatt unserer eigenen Implementierung Unterstützung für große Seiten hinzuzufügen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Basis der Abstraktion sind zwei Merkmale, die verschiedene Übersetzungsfunktionen der Seitentabelle definieren:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Merkmal </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Mapper</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bietet Funktionen, die auf Seiten funktionieren. </font><font style="vertical-align: inherit;">Zum Beispiel, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>translate_page</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um diese Seite in einen Rahmen derselben Größe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>map_to</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zu übersetzen und eine neue Zuordnung in der Tabelle zu erstellen.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Merkmal </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>MapperAllSizes</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">impliziert die Anwendung </font></font><code>Mapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">für alle Seitengrößen. </font><font style="vertical-align: inherit;">Darüber hinaus bietet es Funktionen, die mit Seiten unterschiedlicher Größe arbeiten, einschließlich </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>translate_addr</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder allgemein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>translate</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Merkmale definieren nur die Schnittstelle, bieten jedoch keine Implementierung. </font><font style="vertical-align: inherit;">Jetzt </font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bietet </font><font style="vertical-align: inherit;">die Kiste </font><font style="vertical-align: inherit;">zwei Typen, die Merkmale implementieren: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>MappedPageTable</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>RecursivePageTable</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Das erste erfordert, dass jeder Frame der Seitentabelle irgendwo angezeigt wird (z. B. mit einem Versatz). </font><font style="vertical-align: inherit;">Der zweite Typ kann verwendet werden, wenn die Tabelle der vierten Ebene rekursiv angezeigt wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben den gesamten physischen Speicher zugeordnet </font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sodass Sie den Typ MappedPageTable verwenden können. </font><font style="vertical-align: inherit;">Erstellen Sie zum Initialisieren eine neue Funktion </font></font><code>init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im Modul </font></font><code>memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> x86_64::structures::paging::{PhysFrame, MapperAllSizes, MappedPageTable}; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> x86_64::PhysAddr; <span class="hljs-comment"><span class="hljs-comment">/// Initialize a new MappedPageTable. /// /// This function is unsafe because the caller must guarantee that the /// complete physical memory is mapped to virtual memory at the passed /// `physical_memory_offset`. Also, this function must be only called once /// to avoid aliasing `&amp;mut` references (which is undefined behavior). pub unsafe fn init(physical_memory_offset: u64) -&gt; impl MapperAllSizes { let level_4_table = active_level_4_table(physical_memory_offset); let phys_to_virt = move |frame: PhysFrame| -&gt; *mut PageTable { let phys = frame.start_address().as_u64(); let virt = VirtAddr::new(phys + physical_memory_offset); virt.as_mut_ptr() }; MappedPageTable::new(level_4_table, phys_to_virt) } // make private unsafe fn active_level_4_table(physical_memory_offset: u64) -&gt; &amp;'static mut PageTable {…}</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können nicht direkt </font></font><code>MappedPageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von einer Funktion zurückkehren, da dies für einen Verschlusstyp üblich ist. Wir werden dieses Problem mit einem Syntaxkonstrukt umgehen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>impl Trait</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ein weiterer Vorteil ist, dass Sie den Kernel dann wechseln können, </font></font><code>RecursivePageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ohne die Signatur der Funktion zu ändern. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Funktion </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>MappedPageTable::new</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erwartet zwei Parameter: eine veränderbare Verknüpfung zur Seitentabelle der Ebene 4 und einen Abschluss </font></font><code>phys_to_virt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der den physischen Frame in einen Seitentabellenzeiger konvertiert </font></font><code>*mut PageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Für den ersten Parameter können wir die Funktion wiederverwenden </font></font><code>active_level_4_table</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Zum zweiten erstellen wir einen Abschluss, mit </font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dem die Konvertierung durchgeführt wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir machen es auch zu einer </font></font><code>active_level_4_table</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">privaten Funktion, da es von nun an nur noch von aufgerufen wird </font></font><code>init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So verwenden Sie die Methode</font></font><code>MapperAllSizes::translate_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstelle unserer eigenen Funktion </font></font><code>memory::translate_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">müssen wir nur ein paar Zeilen ändern in </font></font><code>kernel_main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] // initialize GDT, IDT, PICS // new: different imports use blog_os::memory; use x86_64::{structures::paging::MapperAllSizes, VirtAddr}; // new: initialize a mapper let mapper = unsafe { memory::init(boot_info.physical_memory_offset) }; let addresses = […]; // same as before for &amp;address in &amp;addresses { let virt = VirtAddr::new(address); // new: use the `mapper.translate_addr` method let phys = mapper.translate_addr(virt); println!("{:?} -&gt; {:?}", virt, phys); } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach dem Start sehen wir die gleichen Übersetzungsergebnisse wie zuvor, aber jetzt funktionieren nur noch große Seiten: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/51d/5ed/d9c/51d5edd9c004e1238b321dee51fdf8b3.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie erwartet wird die virtuelle Adresse </font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in eine physische Adresse konvertiert </font></font><code>0x0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Durch die Verwendung der Übersetzungsfunktion für den Typ </font></font><code>MappedPageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entfällt die Notwendigkeit, die Unterstützung für große Seiten zu implementieren. </font><font style="vertical-align: inherit;">Wir haben auch Zugriff auf andere Seitenfunktionen, wie </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir sie im nächsten Abschnitt verwenden werden. </font><font style="vertical-align: inherit;">Zu diesem Zeitpunkt benötigen wir die Funktion nicht mehr </font></font><code>memory::translate_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sie können sie löschen, wenn Sie möchten.</font></font><br><br><a name="4_4"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erstellen Sie eine neue Zuordnung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher haben wir uns nur Seitentabellen angesehen, aber nichts geändert. </font><font style="vertical-align: inherit;">Erstellen wir eine neue Zuordnung für eine zuvor nicht angezeigte Seite. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden die Funktion </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>map_to</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus dem Merkmal verwenden </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Mapper</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, also werden wir zuerst diese Funktion betrachten. </font><font style="vertical-align: inherit;">Die Dokumentation besagt, dass vier Argumente erforderlich sind: die Seite, die wir anzeigen möchten; </font><font style="vertical-align: inherit;">Der Rahmen, dem die Seite zugeordnet werden soll. </font><font style="vertical-align: inherit;">Satz von Flags zum Schreiben von Seitentabellen und Rahmenverteilern </font></font><code>frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ein Frame-Allokator ist erforderlich, da für die Zuordnung dieser Seite möglicherweise zusätzliche Tabellen erstellt werden müssen, für die nicht verwendete Frames als Sicherungsspeicher erforderlich sind.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font></font><code>create_example_mapping</code> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der erste Schritt in unserer Implementierung besteht darin, eine neue Funktion zu erstellen </font></font><code>create_example_mapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die diese Seite dem </font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">physischen Frame des VGA-Textpuffers zuordnet. Wir wählen diesen Rahmen aus, weil es einfach ist zu überprüfen, ob die Anzeige korrekt erstellt wurde: Wir müssen nur auf die zuletzt angezeigte Seite schreiben und sehen, ob sie auf dem Bildschirm angezeigt wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Funktion </font></font><code>create_example_mapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sieht folgendermaßen aus:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::{Page, Size4KiB, Mapper, FrameAllocator}; /// Creates an example mapping for the given page to frame `0xb8000`. pub fn create_example_mapping( page: Page, mapper: &amp;mut impl Mapper&lt;Size4KiB&gt;, frame_allocator: &amp;mut impl FrameAllocator&lt;Size4KiB&gt;, ) { use x86_64::structures::paging::PageTableFlags as Flags; let frame = PhysFrame::containing_address(PhysAddr::new(0xb8000)); let flags = Flags::PRESENT | Flags::WRITABLE; let map_to_result = unsafe { mapper.map_to(page, frame, flags, frame_allocator) }; map_to_result.expect("map_to failed").flush(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusätzlich zu der Seite, die </font></font><code>page</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie zuordnen möchten, erwartet die Funktion eine Instanz von </font></font><code>mapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Der Typ </font></font><code>mapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementiert das Merkmal </font></font><code>Mapper&lt;Size4KiB&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das die Methode bereitstellt </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Gemeinsame Parameter </font></font><code>Size4KiB</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">notwendig , </font><font style="vertical-align: inherit;">weil Merkmal </font></font><code>Mapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">häufig</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für das Merkmal </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PageSize</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das </font><font style="vertical-align: inherit;">Arbeiten mit Standard - </font><font style="vertical-align: inherit;">4 KiB Seiten und mit enormen Seiten 2 und MiB 1 GiB. Wir möchten nur 4 KiB-Seiten erstellen, damit wir sie </font></font><code>Mapper&lt;Size4KiB&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anstelle der Anforderung verwenden können </font></font><code>MapperAllSizes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setzen Sie zum Vergleich das Flag </font></font><code>PRESENT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, da alle gültigen Einträge erforderlich sind, und das Flag </font></font><code>WRITABLE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um die angezeigte Seite beschreibbar zu machen. Herausforderung</font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsicher: Sie können die Speichersicherheit mit ungültigen Argumenten verletzen, daher müssen Sie einen Block verwenden </font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Eine Liste aller möglichen Flags finden Sie im Abschnitt „Seitentabellenformat“ des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vorherigen Artikels</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Funktion </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann fehlschlagen und kehrt daher zurück </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Result</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Da dies nur ein Beispiel für Code ist, der nicht zuverlässig sein sollte, verwenden wir ihn einfach, um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>expect</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im Fehlerfall in Panik zu geraten. </font><font style="vertical-align: inherit;">Bei Erfolg gibt die Funktion einen Typ zurück </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>MapperFlush</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mit dem die zuletzt angezeigte Seite mithilfe der Methode auf einfache Weise aus dem dynamischen Übersetzungspuffer (TLB) gelöscht werden kann </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>flush</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Da </font></font><code>Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diese Art von Attribut verwendet [ </font></font><code>#[must_use]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">] für</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine Warnung ausgeben, wenn wir versehentlich vergessen, sie zu verwenden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fiktiv </font></font><code>FrameAllocator</code> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um anzurufen </font></font><code>create_example_mapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, müssen Sie zuerst erstellen </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wie oben erwähnt, hängt die Komplexität beim Erstellen einer neuen Anzeige von der virtuellen Seite ab, die angezeigt werden soll. </font><font style="vertical-align: inherit;">Im einfachsten Fall ist bereits eine Tabelle der Ebene 1 für die Seite vorhanden, und wir müssen nur einen Datensatz erstellen. </font><font style="vertical-align: inherit;">Im schwierigsten Fall befindet sich die Seite in einem Speicherbereich, für den noch keine Ebene 3 erstellt wurde. Zunächst müssen Sie Seitentabellen der Ebenen 3, 2 und 1 erstellen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginnen wir mit einem einfachen Fall und gehen davon aus, dass Sie keine neuen Seitentabellen erstellen müssen. </font><font style="vertical-align: inherit;">Ein Rahmenverteiler, der immer zurückgibt, reicht dafür aus </font></font><code>None</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir erstellen eine solche </font></font><code>EmptyFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anzeigefunktion zum Testen:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs /// A FrameAllocator that always returns `None`. pub struct EmptyFrameAllocator; impl FrameAllocator&lt;Size4KiB&gt; for EmptyFrameAllocator { fn allocate_frame(&amp;mut self) -&gt; Option&lt;PhysFrame&gt; { None } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt müssen Sie eine Seite finden, die angezeigt werden kann, ohne neue Seitentabellen zu erstellen. Der Loader wird in das erste Megabyte des virtuellen Adressraums geladen, sodass wir wissen, dass für diesen Bereich eine gültige Tabelle der Ebene 1 vorhanden ist. In unserem Beispiel können wir jede nicht verwendete Seite in diesem Speicherbereich auswählen, z. B. die Seite an der Adresse </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Funktion zu testen, zeigen wir zuerst die Seite </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und dann den Inhalt des Speichers an:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] // initialize GDT, IDT, PICS use blog_os::memory; use x86_64::{structures::paging::Page, VirtAddr}; let mut mapper = unsafe { memory::init(boot_info.physical_memory_offset) }; let mut frame_allocator = memory::EmptyFrameAllocator; // map a previously unmapped page let page = Page::containing_address(VirtAddr::new(0x1000)); memory::create_example_mapping(page, &amp;mut mapper, &amp;mut frame_allocator); // write the string `New!` to the screen through the new mapping let page_ptr: *mut u64 = page.start_address().as_mut_ptr(); unsafe { page_ptr.offset(400).write_volatile(0x_f021_f077_f065_f04e)}; println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuerst erstellen wir eine Zuordnung für die Seite in </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und rufen eine Funktion </font></font><code>create_example_mapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit einem veränderlichen Link zu Instanzen </font></font><code>mapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und auf </font></font><code>frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dadurch wird die Seite </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dem VGA-Textpufferrahmen zugeordnet, sodass wir sehen sollten, was dort auf dem Bildschirm geschrieben steht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konvertieren Sie dann die Seite in einen Rohzeiger und schreiben Sie den Wert in den Versatz </font></font><code>400</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wir schreiben nicht an den Anfang der Seite, da die oberste Zeile des VGA-Puffers wie folgt direkt vom Bildschirm verschoben wird </font></font><code>println</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Schreiben Sie den Wert </font></font><code>0x_f021_f077_f065_f04e</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der der Zeichenfolge </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Neu!" Entspricht.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf einem weißen Hintergrund. Wie wir im Artikel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">„VGA-Textmodus“</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erfahren haben </font><font style="vertical-align: inherit;">, muss das Schreiben in den VGA-Puffer flüchtig sein, daher verwenden wir die Methode </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>write_volatile</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir den Code in QEMU ausführen, sehen wir das folgende Ergebnis: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4cf/248/1a0/4cf2481a07f40c681954ff4954dce866.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach dem Schreiben auf die Seite </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird die Aufschrift </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Neu!"</font></font></i>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher haben wir erfolgreich eine neue Zuordnung in Seitentabellen erstellt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Sortierung funktionierte, da bereits eine Tabelle der Ebene 1 für die Sortierung vorhanden war </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn wir versuchen, eine Seite zuzuordnen, für die noch keine Tabelle der Ebene 1 vorhanden ist, </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">schlägt </font><font style="vertical-align: inherit;">die Funktion </font><font style="vertical-align: inherit;">fehl, da versucht wird, Frames zuzuweisen </font></font><code>EmptyFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um neue Tabellen zu erstellen. </font><font style="vertical-align: inherit;">Wir sehen, dass dies passiert, wenn wir versuchen, die Seite anzuzeigen, </font></font><code>0xdeadbeaf000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anstatt </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] let page = Page::containing_address(VirtAddr::new(0xdeadbeaf000)); […] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn dies gestartet wird, tritt eine Panik mit der folgenden Fehlermeldung auf: </font></font><br><br><pre> <code class="plaintext hljs">panicked at 'map_to failed: FrameAllocationFailed', /…/result.rs:999:5</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um Seiten anzuzeigen, die noch keine Tabelle der Seitenebene 1 haben, müssen Sie die richtige erstellen </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aber woher wissen Sie, welche Frames frei sind und wie viel physischer Speicher verfügbar ist?</font></font><br><br><a name="4_5"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rahmenauswahl </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für neue Seitentabellen müssen Sie den richtigen Rahmenverteiler erstellen. </font><font style="vertical-align: inherit;">Beginnen wir mit dem allgemeinen Skelett:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs pub struct BootInfoFrameAllocator&lt;I&gt; where I: Iterator&lt;Item = PhysFrame&gt; { frames: I, } impl&lt;I&gt; FrameAllocator&lt;Size4KiB&gt; for BootInfoFrameAllocator&lt;I&gt; where I: Iterator&lt;Item = PhysFrame&gt; { fn allocate_frame(&amp;mut self) -&gt; Option&lt;PhysFrame&gt; { self.frames.next() } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Feld </font></font><code>frames</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann mit einem beliebigen Frame-Iterator initialisiert werden. Auf diese Weise können Sie Aufrufe einfach an die </font></font><code>alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode </font><font style="vertical-align: inherit;">delegieren </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Iterator::next</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für die Initialisierung verwenden wir </font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Speicherkarte, </font></font><code>memory_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die der Bootloader als Teil der Struktur überträgt </font></font><code>BootInfo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wie im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abschnitt Startinformationen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erläutert </font><font style="vertical-align: inherit;">, wird die Speicherkarte von der BIOS / UEFI-Firmware bereitgestellt. Es kann nur zu Beginn des Startvorgangs angefordert werden, sodass der Bootloader die erforderlichen Funktionen bereits aufgerufen hat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Speicherkarte besteht aus einer Liste von Strukturen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>MemoryRegion</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die die Startadresse, Länge und den Typ (z. B. nicht verwendet, reserviert usw.) jedes Speicherbereichs enthalten. Durch Erstellen eines Iterators, der Frames aus nicht verwendeten Bereichen erzeugt, können wir einen gültigen erstellen </font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Initialisierung </font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erfolgt in einer neuen Funktion </font></font><code>init_frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use bootloader::bootinfo::{MemoryMap, MemoryRegionType}; /// Create a FrameAllocator from the passed memory map pub fn init_frame_allocator( memory_map: &amp;'static MemoryMap, ) -&gt; BootInfoFrameAllocator&lt;impl Iterator&lt;Item = PhysFrame&gt;&gt; { // get usable regions from memory map let regions = memory_map .iter() .filter(|r| r.region_type == MemoryRegionType::Usable); // map each region to its address range let addr_ranges = regions.map(|r| r.range.start_addr()..r.range.end_addr()); // transform to an iterator of frame start addresses let frame_addresses = addr_ranges.flat_map(|r| r.step_by(4096)); // create `PhysFrame` types from the start addresses let frames = frame_addresses.map(|addr| { PhysFrame::containing_address(PhysAddr::new(addr)) }); BootInfoFrameAllocator { frames } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Funktion verwendet einen Kombinator, um die anfängliche Zuordnung </font></font><code>MemoryMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in einen Iterator der verwendeten physischen Frames </font><font style="vertical-align: inherit;">zu konvertieren </font><font style="vertical-align: inherit;">:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuerst rufen wir die Methode </font></font><code>iter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf, um die Speicherkarte in einen Iterator umzuwandeln </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>MemoryRegion</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dann verwenden wir die Methode </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>filter</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um reservierte oder unzugängliche Regionen zu überspringen. </font><font style="vertical-align: inherit;">Der Loader aktualisiert die Speicherkarte für alle von ihm erstellten Zuordnungen, sodass die vom Kernel (Code, Daten oder Stapel) oder zum Speichern von Informationen über den Start verwendeten Frames bereits als </font></font><code>InUse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder ähnlich </font><font style="vertical-align: inherit;">markiert sind </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Somit können wir sicher sein, dass Frames </font></font><code>Usable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht </font><font style="vertical-align: inherit;">anderweitig </font><font style="vertical-align: inherit;">verwendet </font><font style="vertical-align: inherit;">werden </font><font style="vertical-align: inherit;">.</font></font><br></li><li>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>map</code></a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">range</a>  Rust         . <br></li><li>    :         <code>into_iter</code> ,     4096-    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>step_by</code></a> .  4096  (= 4 ) —   ,      .      ,         .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>flat_map</code></a>  <code>map</code> ,   <code>Iterator&lt;Item = u64&gt;</code>  <code>Iterator&lt;Item = Iterator&lt;Item = u64&gt;&gt;</code> . <br></li><li>         <code>PhysFrame</code> ,    <code>Iterator&lt;Item = PhysFrame&gt;</code> .          <code>BootInfoFrameAllocator</code> . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir unsere Funktion ändern </font></font><code>kernel_main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um </font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stattdessen </font><font style="vertical-align: inherit;">eine Instanz </font><font style="vertical-align: inherit;">zu übergeben </font></font><code>EmptyFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] let mut frame_allocator = memory::init_frame_allocator(&amp;boot_info.memory_map); […] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diesmal war die Adresszuordnung erfolgreich und wir sehen wieder das schwarz-weiße </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Neu!"</font></font></i>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinter den Kulissen erstellt die Methode </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fehlende Seitentabellen wie folgt:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wählen Sie einen nicht verwendeten Frame aus dem übertragenen aus </font></font><code>frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Null Frame zum Erstellen einer neuen leeren Seitentabelle. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ordnen Sie diesem Frame einen übergeordneten Tabelleneintrag zu. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gehen Sie zur nächsten Ebene der Tabelle. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl unsere Funktion </font></font><code>create_example_mapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur Beispielcode ist, können wir jetzt neue Zuordnungen für beliebige Seiten erstellen. </font><font style="vertical-align: inherit;">Dies ist erforderlich, um Speicher zuzuweisen und Multithreading in zukünftigen Artikeln zu implementieren.</font></font><br><br><a name="5"></a><h1>  Zusammenfassung </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Artikel haben wir verschiedene Methoden für den Zugriff auf die physischen Frames von Seitentabellen kennengelernt, darunter Identitätszuordnung, Zuordnung des gesamten physischen Speichers, temporäre Zuordnung und rekursive Seitentabellen. Wir haben uns dafür entschieden, den vollständigen physischen Speicher als einfache und leistungsstarke Methode anzuzeigen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können den physischen Speicher des Kernels nicht ohne Zugriff auf die Seitentabelle zuordnen, daher ist Bootloader-Unterstützung erforderlich. Das Rack </font></font><code>bootloader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erstellt die erforderlichen Zuordnungen durch zusätzliche Ladefunktionen. Es übergibt die erforderlichen Informationen als Argument </font></font><code>&amp;BootInfo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an die Einstiegspunktfunktion </font><font style="vertical-align: inherit;">an den Kernel </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für unsere Implementierung haben wir zuerst die Seitentabellen manuell durchgesehen, eine Übersetzungsfunktion erstellt und dann den </font></font><code>MappedPageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kistentyp verwendet</font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir haben auch gelernt, wie man neue Zuordnungen in der Seitentabelle erstellt und wie man sie </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf einer vom Bootloader übertragenen Speicherkarte erstellt.</font></font><br><br><a name="6"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Was weiter? </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im nächsten Artikel erstellen wir einen Heap-Speicherbereich für unseren Kernel, in dem wir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speicher zuweisen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und verschiedene </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arten von Sammlungen verwenden können</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445618/">https://habr.com/ru/post/de445618/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445596/index.html">Tipps und Tricks von Kubernetes: Personalisierte Fehlerseiten in NGINX Ingress</a></li>
<li><a href="../de445600/index.html">[Umfrage und böse] Hostings, seien sie falsch</a></li>
<li><a href="../de445602/index.html">PHP Russland 2019: sein "Stadion" für die Sprache der ersten Liga</a></li>
<li><a href="../de445608/index.html">Spielende: Analysten berichten von einem Anstieg der Anzahl von DDoS-Angriffen auf das Spielesegment</a></li>
<li><a href="../de445612/index.html">Clusterspeicher für kleine Webcluster basierend auf drbd + ocfs2</a></li>
<li><a href="../de445620/index.html">Was macht ein UX-Writer?</a></li>
<li><a href="../de445622/index.html">Neu in Java 12: The Teeing Collector</a></li>
<li><a href="../de445626/index.html">Wie tief ist das Kaninchenloch? CLRium # 5: Garbage Collector</a></li>
<li><a href="../de445632/index.html">Vom Parser des Python-Theaterplakats bis zum Telegrammbot. Teil 2</a></li>
<li><a href="../de445638/index.html">Blindpraktikum im Garage Museum of Modern Art</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>