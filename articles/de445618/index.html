<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ìÇÔ∏è ‚ùé üòï Wir schreiben ein Betriebssystem auf Rust. Implementieren des Seitenspeichers (neu) üêØ üë≠ üëÇ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel erfahren Sie, wie Sie die Unterst√ºtzung des Seitenspeichers in unserem Kern implementieren. Zun√§chst werden wir verschiedene Methode...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir schreiben ein Betriebssystem auf Rust. Implementieren des Seitenspeichers (neu)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445618/">  In diesem Artikel erfahren Sie, wie Sie die Unterst√ºtzung des Seitenspeichers in unserem Kern implementieren.  Zun√§chst werden wir verschiedene Methoden untersuchen, damit die Frames der physischen Seitentabelle f√ºr den Kernel verf√ºgbar werden, und ihre Vor- und Nachteile diskutieren.  Dann implementieren wir die Adress√ºbersetzungsfunktion und die Funktion zum Erstellen eines neuen Mappings. <br><br>  Diese Artikelserie wurde auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub ver√∂ffentlicht</a> .  Wenn Sie Fragen oder Probleme haben, √∂ffnen Sie dort das entsprechende Ticket.  Alle Quellen f√ºr den Artikel befinden sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in diesem Thread</a> . <br><br>  <i><b>Ein weiterer Artikel √ºber Paging?</b></i> <i><br></i>  <i>Wenn Sie diesem Zyklus folgen, haben Sie Ende Januar den Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûSeitenspeicher: Fortgeschrittene Ebene‚Äú gesehen</a> .</i>  <i>Aber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ich wurde</a> f√ºr rekursive Seitentabellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kritisiert</a> .</i>  <i>Aus diesem Grund habe ich beschlossen, den Artikel neu zu schreiben und einen anderen Ansatz f√ºr den Zugriff auf Frames zu verwenden.</i> <br><a name="habracut"></a><br>  <i>Hier ist eine neue Option.</i>  <i>Der Artikel erkl√§rt immer noch, wie rekursive Seitentabellen funktionieren, aber wir verwenden eine einfachere und leistungsf√§higere Implementierung.</i>  <i>Wir werden den vorherigen Artikel nicht l√∂schen, sondern als veraltet markieren und nicht aktualisieren.</i> <i><br><br></i>  <i>Ich hoffe, Sie genie√üen die neue Option!</i> <br><br><h1>  Inhalt </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einf√ºhrung</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abh√§ngigkeitsaktualisierungen</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zugriff auf Seitentabellen</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Identit√§tszuordnung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Versetzte Karte korrigiert</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vollst√§ndige Zuordnung des physischen Speichers</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tempor√§re Anzeige</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rekursive Seitentabellen</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bootloader-Unterst√ºtzung</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Boot-Informationen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einstiegspunktmakro</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implementierung</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zugriff auf Seitentabellen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Adress√ºbersetzung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwenden von MappedPageTable</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erstellen Sie eine neue Zuordnung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rahmenauswahl</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zusammenfassung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was weiter?</a> </li></ul><br><a name="1"></a><h1>  Einf√ºhrung </h1><br>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letzten Artikel haben</a> wir die Prinzipien des Paging-Speichers und die Funktionsweise der vierstufigen Seitentabellen unter <code>x86_64</code> .  Wir haben auch festgestellt, dass der Loader bereits die Seitentabellenhierarchie f√ºr unseren Kernel eingerichtet hat, sodass der Kernel auf virtuellen Adressen ausgef√ºhrt wird.  Dies erh√∂ht die Sicherheit, da nicht autorisierter Zugriff auf den Speicher einen Seitenfehler verursacht, anstatt den physischen Speicher zuf√§llig zu √§ndern. <br><br>  Der Artikel konnte von unserem Kernel aus nicht auf Seitentabellen zugreifen, da diese im physischen Speicher gespeichert sind und der Kernel bereits auf virtuellen Adressen ausgef√ºhrt wird.  Hier setzen wir das Thema fort und untersuchen verschiedene Optionen f√ºr den Zugriff auf die Frames der Seitentabelle vom Kernel aus.  Wir werden die Vor- und Nachteile jedes einzelnen von ihnen diskutieren und dann die geeignete Option f√ºr unseren Kern ausw√§hlen. <br><br>  Bootloader-Unterst√ºtzung ist erforderlich, daher werden wir sie zuerst konfigurieren.  Anschlie√üend implementieren wir eine Funktion, die die gesamte Hierarchie der Seitentabellen durchl√§uft, um virtuelle Adressen in physische Adressen zu √ºbersetzen.  Schlie√ülich lernen wir, wie Sie neue Zuordnungen in Seitentabellen erstellen und nicht verwendete Speicherrahmen zum Erstellen neuer Tabellen finden. <br><br><a name="1_1"></a><h3>  Abh√§ngigkeitsaktualisierungen </h3><br>  In diesem Artikel m√ºssen Sie den <code>bootloader</code> Version 0.4.0 oder h√∂her und <code>x86_64</code> Version 0.5.2 oder h√∂her in den Abh√§ngigkeiten registrieren.  Sie k√∂nnen die Abh√§ngigkeiten in <code>Cargo.toml</code> : <br><br><pre> <code class="plaintext hljs">[dependencies] bootloader = "0.4.0" x86_64 = "0.5.2"</code> </pre> <br>  √Ñnderungen in diesen Versionen finden Sie <a href="">im Bootloader-Protokoll</a> und im <a href="">x86_64-Protokoll</a> . <br><br><a name="2"></a><h1>  Zugriff auf Seitentabellen </h1><br>  Der Zugriff auf Seitentabellen √ºber den Kernel ist nicht so einfach, wie es scheint.  Um das Problem zu verstehen, werfen Sie einen weiteren Blick auf die vierstufige Tabellenhierarchie aus dem vorherigen Artikel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c8/5e8/a14/9c85e8a145a9078cfcfd92e204f69a5b.svg"></div><br><br>  Wichtig ist, dass in jedem Seiteneintrag die <i>physikalische</i> Adresse der n√§chsten Tabelle gespeichert wird.  Dies vermeidet die √úbersetzung dieser Adressen, was die Leistung verringert und leicht zu Endlosschleifen f√ºhrt. <br><br>  Das Problem ist, dass wir vom Kernel nicht direkt auf physische Adressen zugreifen k√∂nnen, da dies auch f√ºr virtuelle Adressen funktioniert.  Wenn wir beispielsweise zur Adresse <code>4 KiB</code> , erhalten wir Zugriff auf die <i>virtuelle</i> Adresse <code>4 KiB</code> und nicht auf die <i>physische</i> Adresse, an der die Seitentabelle der 4. Ebene gespeichert ist.  Wenn wir auf die physische Adresse von <code>4 KiB</code> zugreifen m√∂chten, m√ºssen wir eine virtuelle Adresse verwenden, die in diese √ºbersetzt wird. <br><br>  Um auf die Frames der Seitentabellen zuzugreifen, m√ºssen Sie diesen Frames einige virtuelle Seiten zuordnen.  Es gibt verschiedene M√∂glichkeiten, solche Zuordnungen zu erstellen. <br><br><a name="2_1"></a><h3>  Identit√§tszuordnung </h3><br>  Eine einfache L√∂sung ist die <b>identische Anzeige aller Seitentabellen</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/813/916/8f3813916cd0a5b5174c8d14dabedb7a.svg"></div><br><br>  In diesem Beispiel sehen wir die identische Anzeige von Frames.  Die physischen Adressen der Seitentabellen sind gleichzeitig g√ºltige virtuelle Adressen, so dass wir ab dem Register CR3 problemlos auf die Seitentabellen aller Ebenen zugreifen k√∂nnen. <br><br>  Dieser Ansatz √ºberf√ºllt jedoch den virtuellen Adressraum und macht es schwierig, gro√üe zusammenh√§ngende Bereiche des freien Speichers zu finden.  Angenommen, wir m√∂chten in der obigen Abbildung einen virtuellen Speicherbereich von 1000 KB erstellen, um beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine Datei im Speicher anzuzeigen</a> .  Wir k√∂nnen nicht mit der <code>28 KiB</code> Region beginnen, da sie bei <code>1004  KiB</code> auf einer bereits belegten Seite liegt.  Daher m√ºssen Sie weiter suchen, bis wir ein geeignetes gro√ües Fragment finden, beispielsweise mit <code>1008  KiB</code> .  Es gibt das gleiche Fragmentierungsproblem wie im segmentierten Speicher. <br><br>  Dar√ºber hinaus ist die Erstellung neuer Seitentabellen viel komplizierter, da physische Frames gefunden werden m√ºssen, deren entsprechende Seiten noch nicht verwendet werden.  F√ºr unsere Datei haben wir beispielsweise einen Bereich von 1000 KB <i>virtuellem</i> Speicher reserviert, beginnend bei der Adresse <code>1008  KiB</code> .  Jetzt k√∂nnen wir keinen Frame mit einer physischen Adresse zwischen <code>1000  KiB</code> und <code>2008  KiB</code> , da dieser nicht identisch angezeigt werden kann. <br><br><a name="2_2"></a><h3>  Versetzte Karte korrigiert </h3><br>  Um eine √úberlastung des virtuellen Adressraums zu vermeiden, k√∂nnen Sie die Seitentabellen in einem <b>separaten Speicherbereich</b> anzeigen.  Anstatt die Zuordnung zu identifizieren, ordnen wir daher Frames mit einem festen Versatz im virtuellen Adressraum zu.  Zum Beispiel kann der Versatz 10 TiB betragen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f4a/c8a/5ea/f4ac8a5ea64fd215de176248b5f74e20.svg"><br><br>  Indem wir diesen Bereich des virtuellen Speichers ausschlie√ülich f√ºr die Anzeige von Seitentabellen zuweisen, vermeiden wir die Probleme einer identischen Anzeige.  Das Reservieren eines so gro√üen Bereichs des virtuellen Adressraums ist nur m√∂glich, wenn der virtuelle Adressraum viel gr√∂√üer als der physische Speicher ist.  Unter <code>x86_64</code> dies kein Problem, da der 48-Bit-Adressraum 256 TiB betr√§gt. <br><br>  Dieser Ansatz hat jedoch den Nachteil, dass Sie beim Erstellen jeder Seitentabelle eine neue Zuordnung erstellen m√ºssen.  Dar√ºber hinaus ist der Zugriff auf Tabellen in anderen Adressr√§umen nicht zul√§ssig, was beim Erstellen eines neuen Prozesses hilfreich w√§re. <br><br><a name="2_3"></a><h3>  Vollst√§ndige Zuordnung des physischen Speichers </h3><br>  Wir k√∂nnen diese Probleme l√∂sen, indem wir den <b>gesamten physischen Speicher</b> und nicht nur Seitentabellenrahmen <b>anzeigen</b> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c39/3cf/7df/c393cf7df76515739e1d9274160c4b5d.svg"><br><br>  Dieser Ansatz erm√∂glicht es dem Kernel, auf einen beliebigen physischen Speicher zuzugreifen, einschlie√ülich Seitentabellenrahmen anderer Adressr√§ume.  Ein Bereich des virtuellen Speichers ist in der gleichen Gr√∂√üe wie zuvor reserviert, es sind jedoch nur keine nicht √ºbereinstimmenden Seiten vorhanden. <br><br>  Der Nachteil dieses Ansatzes besteht darin, dass zus√§tzliche Seitentabellen erforderlich sind, um den physischen Speicher anzuzeigen.  Diese Seitentabellen sollten irgendwo gespeichert werden, damit sie einen Teil des physischen Speichers belegen, was bei Ger√§ten mit wenig RAM ein Problem sein kann. <br><br>  Auf x86_64 k√∂nnen wir jedoch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">riesige</a> 2-MiB- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Seiten</a> anstelle der Standardgr√∂√üe von 4 KiB f√ºr die Anzeige verwenden.  Um 32 GB physischen Speicher anzuzeigen, sind daher nur 132 KB pro Seitentabelle erforderlich: nur eine Tabelle der dritten Ebene und 32 Tabellen der zweiten Ebene.  Riesige Seiten werden auch effizienter zwischengespeichert, da sie weniger Eintr√§ge im TLB (Dynamic Translation Buffer) verwenden. <br><br><a name="2_4"></a><h3>  Tempor√§re Anzeige </h3><br>  Bei Ger√§ten mit sehr wenig physischem Speicher k√∂nnen Sie <b>Seitentabellen</b> nur <b>vor√ºbergehend anzeigen,</b> wenn Sie darauf zugreifen m√ºssen.  F√ºr tempor√§re Vergleiche ist eine identische Anzeige nur der Tabelle der ersten Ebene erforderlich: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00a/3ab/5ce/00a3ab5ce85057d3679a48379d3d2297.svg"></div><br><br>  In dieser Abbildung verwaltet eine Tabelle der Ebene 1 die ersten 2 MiB des virtuellen Adressraums.  Dies ist m√∂glich, weil der Zugriff vom CR3-Register √ºber Null-Eintr√§ge in den Tabellen der Ebenen 4, 3 und 2 erfolgt. Der Datensatz mit Index <code>8</code> √ºbersetzt die virtuelle Seite mit <code>32 KiB</code> in einen physischen Rahmen mit <code>32 KiB</code> , wodurch die Tabelle der Ebene 1 selbst identifiziert wird. In der Abbildung ist dies durch einen horizontalen Pfeil dargestellt. <br><br>  Durch Schreiben in die identisch zugeordnete Tabelle der Ebene 1 kann unser Kernel bis zu 511 Zeitvergleiche erstellen (512 abz√ºglich des f√ºr die Identit√§tszuordnung erforderlichen Datensatzes).  Im obigen Beispiel erstellt der Kernel zwei Zeitvergleiche: <br><br><ul><li>  Zuordnen eines Nulleintrags in einer Tabelle der Ebene 1 zu einem Frame mit <code>24 KiB</code> .  Dadurch wird eine tempor√§re Zuordnung der virtuellen Seite bei <code>0 KiB</code> zu dem physischen Rahmen der Tabelle der Seitenebene 2 erstellt, der durch den gepunkteten Pfeil angezeigt wird. </li><li>  Ordnen Sie den 9. Datensatz eines Level 1-Tisches einem Frame von <code>4 KiB</code> .  Dadurch wird eine tempor√§re Zuordnung der virtuellen Seite mit <code>36 KiB</code> zum physischen Rahmen der Tabelle der Seitenebene 4 erstellt, die durch den gepunkteten Pfeil gekennzeichnet ist. </li></ul><br>  Jetzt kann der Kernel auf eine Tabelle der Ebene 2 zugreifen, indem er auf eine Seite schreibt, die bei <code>0 KiB</code> beginnt, und auf eine Tabelle der Ebene 4, indem er auf eine Seite schreibt, die bei <code>33 KiB</code> beginnt. <br><br>  Der Zugriff auf einen beliebigen Rahmen der Seitentabelle mit tempor√§ren Zuordnungen besteht daher aus den folgenden Aktionen: <br><br><ul><li>  Suchen Sie einen freien Eintrag in der identisch angezeigten Tabelle der Ebene 1. <br></li><li>  Ordnen Sie diesen Eintrag dem physischen Rahmen der Seitentabelle zu, auf die wir zugreifen m√∂chten. <br></li><li>  Greifen Sie √ºber die dem Eintrag zugeordnete virtuelle Seite auf diesen Frame zu. <br></li><li>  Setzen Sie den Datensatz wieder auf nicht verwendet, wodurch die tempor√§re Zuordnung entfernt wird. </li></ul><br>  Bei diesem Ansatz bleibt der virtuelle Adressraum sauber, da st√§ndig dieselben 512 virtuellen Seiten verwendet werden.  Der Nachteil ist eine gewisse Umst√§ndlichkeit, insbesondere da f√ºr einen neuen Vergleich m√∂glicherweise mehrere Tabellenebenen ge√§ndert werden m√ºssen, dh der beschriebene Vorgang mehrmals wiederholt werden muss. <br><br><a name="2_5"></a><h3>  Rekursive Seitentabellen </h3><br>  Ein weiterer interessanter Ansatz, f√ºr den √ºberhaupt keine zus√§tzlichen Seitentabellen erforderlich sind, ist der <b>rekursive Abgleich</b> . <br><br>  Die Idee ist, einige Datens√§tze aus der Tabelle der vierten Ebene in sie selbst zu √ºbersetzen.  Daher reservieren wir tats√§chlich einen Teil des virtuellen Adressraums und ordnen diesem Raum alle aktuellen und zuk√ºnftigen Tabellenrahmen zu. <br><br>  Schauen wir uns ein Beispiel an, um zu verstehen, wie das alles funktioniert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/779/ee6/d9b/779ee6d9bf771dec8e6d22c0440e503d.png"></div><br><br>  Der einzige Unterschied zum Beispiel am Anfang des Artikels besteht in einem zus√§tzlichen Datensatz mit dem Index <code>511</code> in der Tabelle der Ebene 4, der dem physischen Frame <code>4 KiB</code> , der sich in dieser Tabelle selbst befindet. <br><br>  Wenn die CPU in diesen Datensatz wechselt, bezieht sie sich nicht auf die Tabelle der Ebene 3, sondern erneut auf die Tabelle der Ebene 4. Dies √§hnelt einer rekursiven Funktion, die sich selbst aufruft.  Es ist wichtig, dass der Prozessor davon ausgeht, dass jeder Eintrag in der Tabelle der Ebene 4 auf eine Tabelle der Ebene 3 verweist. Daher wird die Tabelle der Ebene 4 jetzt als Tabelle der Ebene 3 behandelt. Dies funktioniert, da Tabellen aller Ebenen in x86_64 dieselbe Struktur haben. <br><br>  Indem Sie einem rekursiven Datensatz ein oder mehrere Male folgen, bevor Sie mit der eigentlichen Konvertierung beginnen, k√∂nnen Sie die Anzahl der Ebenen, die der Prozessor durchl√§uft, effektiv reduzieren.  Wenn wir beispielsweise dem rekursiven Datensatz einmal folgen und dann zur Tabelle der Ebene 3 wechseln, denkt der Prozessor, dass die Tabelle der Ebene 3 eine Tabelle der Ebene 2 ist. Im weiteren Verlauf betrachtet er die Tabelle der Ebene 2 als Tabelle der Ebene 1 und die Tabelle der Ebene 1 als zugeordnet Frame im physischen Speicher.  Dies bedeutet, dass wir jetzt in die Tabelle der Seitenebene 1 lesen und schreiben k√∂nnen, da der Prozessor dies f√ºr einen zugeordneten Frame h√§lt.  Die folgende Abbildung zeigt die f√ºnf Schritte einer solchen √úbersetzung: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/ac7/191/bdaac719103c574c655efa3604d0b842.png"></div><br><br>  Ebenso k√∂nnen wir einem rekursiven Eintrag zweimal folgen, bevor wir mit der Konvertierung beginnen, um die Anzahl der √ºbergebenen Ebenen auf zwei zu reduzieren: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f4/b9a/c47/7f4b9ac47fce9552dead4e551b804256.png"></div><br><br>  Lassen Sie uns diese Prozedur Schritt f√ºr Schritt durchgehen.  Zuerst folgt die CPU einem rekursiven Eintrag in der Tabelle der Ebene 4 und denkt, dass sie die Tabelle der Ebene 3 erreicht hat. Dann folgt sie erneut dem rekursiven Datensatz und denkt, dass sie die Ebene 2 erreicht hat. In Wirklichkeit befindet sie sich jedoch immer noch auf Ebene 4. Dann geht die CPU zur neuen Adresse und gelangt in die Level 3-Tabelle, denkt jedoch, dass sie sich bereits in der Level 1-Tabelle befindet. Schlie√ülich glaubt der Prozessor am n√§chsten Einstiegspunkt in der Level 2-Tabelle, auf den physischen Speicherrahmen zugegriffen zu haben.  Dies erm√∂glicht uns das Lesen und Schreiben in eine Tabelle der Ebene 2. <br><br>  Auf die Tabellen der Ebenen 3 und 4 wird ebenfalls zugegriffen. Um auf die Tabelle der Ebenen 3 zuzugreifen, folgen wir dreimal einem rekursiven Eintrag: Der Prozessor glaubt, dass er sich bereits in der Tabelle der Ebene 1 befindet, und im n√§chsten Schritt erreichen wir die Ebene 3, die die CPU als zugeordneten Frame betrachtet.  Um auf die Level 4-Tabelle selbst zuzugreifen, folgen wir einfach viermal dem rekursiven Datensatz, bis der Prozessor die Level 4-Tabelle selbst als zugeordneten Frame verarbeitet (in der folgenden Abbildung blau). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/487/a82/92c/487a8292cf8fe673f1914f5f198c0956.png"></div><br><br>  Das Konzept ist zun√§chst schwer zu verstehen, aber in der Praxis funktioniert es ziemlich gut. <br><br><h4>  Adressberechnung </h4><br>  Wir k√∂nnen also auf Tabellen aller Ebenen zugreifen, indem wir einem oder mehreren rekursiven Datens√§tzen folgen.  Da Indizes in Tabellen mit vier Ebenen direkt von der virtuellen Adresse abgeleitet werden, m√ºssen f√ºr diese Methode spezielle virtuelle Adressen erstellt werden.  Wie wir uns erinnern, werden Seitentabellenindizes wie folgt aus der Adresse extrahiert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c44/33c/8f9/c4433c8f99b6fcb54d4b79983ca35dbc.svg"></div><br><br>  Angenommen, wir m√∂chten auf eine Tabelle der Ebene 1 zugreifen, in der eine bestimmte Seite angezeigt wird.  Wie wir oben erfahren haben, m√ºssen Sie einmal einen rekursiven Datensatz und dann die Indizes der 4., 3. und 2. Ebene durchlaufen.  Dazu verschieben wir alle Adressbl√∂cke einen Block nach rechts und setzen den Index des rekursiven Datensatzes an die Stelle des Anfangsindex der Ebene 4: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62a/d82/b54/62ad82b54b233a37e40b964953a16bf8.svg"></div><br><br>  Um auf die Tabelle der Ebene 2 dieser Seite zuzugreifen, verschieben wir alle Indexbl√∂cke zwei Bl√∂cke nach rechts und setzen den rekursiven Index an die Stelle beider Quellbl√∂cke: Ebene 4 und Ebene 3: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d9/ae5/7c8/1d9ae57c8c68a0b239e5b37397a4d0f7.svg"></div><br><br>  Um auf die Tabelle der Ebene 3 zuzugreifen, machen wir dasselbe, wir verschieben einfach bereits drei Adressbl√∂cke nach rechts. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b8/6ee/c9f/4b86eec9fd1df3445718ed8246fd4473.svg"></div><br><br>  Um auf die Tabelle der Ebene 4 zuzugreifen, verschieben Sie alle vier Bl√∂cke nach rechts. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36b/6b0/29b/36b6b029b31578b143ff1e7605e358fb.svg"></div><br><br>  Jetzt k√∂nnen Sie virtuelle Adressen f√ºr Seitentabellen aller vier Ebenen berechnen.  Wir k√∂nnen sogar eine Adresse berechnen, die genau auf einen bestimmten Seitentabelleneintrag verweist, indem wir dessen Index mit 8 multiplizieren, der Gr√∂√üe des Seitentabelleneintrags. <br><br>  Die folgende Tabelle zeigt die Struktur der Adressen f√ºr den Zugriff auf verschiedene Arten von Frames: <br><br><table><thead><tr><th>  Virtuelle Adresse f√ºr </th><th>  Adressstruktur ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">oktal</a> ) </th></tr></thead><tbody><tr><td>  Seite </td><td> <code>0o_SSSSSS_AAA_BBB_CCC_DDD_EEEE</code> </td> </tr><tr><td>  Eintrag in Level 1 Tabelle </td><td> <code>0o_SSSSSS_RRR_AAA_BBB_CCC_DDDD</code> </td> </tr><tr><td>  Eintrag in eine Level 2 Tabelle </td><td> <code>0o_SSSSSS_RRR_RRR_AAA_BBB_CCCC</code> </td> </tr><tr><td>  Eintrag in eine Level 3 Tabelle </td><td> <code>0o_SSSSSS_RRR_RRR_RRR_AAA_BBBB</code> </td> </tr><tr><td>  Eintrag in Level 4 Tabelle </td><td> <code>0o_SSSSSS_RRR_RRR_RRR_RRR_AAAA</code> </td> </tr></tbody></table><br>  Hier ist <code></code> der Level 4-Index, <code></code> ist Level 3, <code></code> ist Level 2 und <code>DDD</code> ist Level 1-Index f√ºr den angezeigten Frame, <code>EEEE</code> ist sein Offset.  <code>RRR</code> ist der Index des rekursiven Datensatzes.  Ein Index (drei Ziffern) wird durch Multiplikation mit 8 (der Gr√∂√üe des Seitentabelleneintrags) in einen Versatz (vier Ziffern) umgewandelt.  Mit diesem Versatz zeigt die resultierende Adresse direkt auf den entsprechenden Seitentabelleneintrag. <br><br>  <code>SSSS</code> sind Erweiterungsbits der vorzeichenbehafteten Ziffer, <code>SSSS</code> sie sind alle Kopien von Bit 47. Dies ist eine spezielle Anforderung f√ºr g√ºltige Adressen in der x86_64-Architektur, die wir in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Artikel</a> er√∂rtert haben. <br><br>  Die Adressen sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">oktal</a> , da jedes Oktalzeichen drei Bits darstellt, wodurch Sie die 9-Bit-Indizes von Tabellen auf verschiedenen Ebenen klar trennen k√∂nnen.  Dies ist im Hexadezimalsystem nicht m√∂glich, bei dem jedes Zeichen vier Bits darstellt. <br><br><h4>  Rostcode </h4><br>  Sie k√∂nnen solche Adressen im Rust-Code mithilfe bitweiser Operationen erstellen: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// the virtual address whose corresponding page tables you want to access let addr: usize = [‚Ä¶]; let r = 0o777; // recursive index let sign = 0o177777 &lt;&lt; 48; // sign extension // retrieve the page table indices of the address that we want to translate let l4_idx = (addr &gt;&gt; 39) &amp; 0o777; // level 4 index let l3_idx = (addr &gt;&gt; 30) &amp; 0o777; // level 3 index let l2_idx = (addr &gt;&gt; 21) &amp; 0o777; // level 2 index let l1_idx = (addr &gt;&gt; 12) &amp; 0o777; // level 1 index let page_offset = addr &amp; 0o7777; // calculate the table addresses let level_4_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (r &lt;&lt; 21) | (r &lt;&lt; 12); let level_3_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (r &lt;&lt; 21) | (l4_idx &lt;&lt; 12); let level_2_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (l4_idx &lt;&lt; 21) | (l3_idx &lt;&lt; 12); let level_1_table_addr = sign | (r &lt;&lt; 39) | (l4_idx &lt;&lt; 30) | (l3_idx &lt;&lt; 21) | (l2_idx &lt;&lt; 12);</span></span></code> </pre> <br>  Dieser Code setzt voraus, dass eine rekursive Zuordnung des letzten Datensatzes der Ebene 4 mit dem Index <code>0o777</code> (511) rekursiv √ºbereinstimmt.  Dies ist derzeit nicht der Fall, sodass der Code noch nicht funktioniert.  Im Folgenden erfahren Sie, wie Sie den Loader anweisen, eine rekursive Zuordnung einzurichten. <br><br>  Alternativ zur manuellen Ausf√ºhrung bitweiser Operationen k√∂nnen Sie den Typ <code>RecursivePageTable</code> der <code>x86_64</code> Kiste verwenden, der sichere Abstraktionen f√ºr verschiedene Tabellenoperationen bietet.  Der folgende Code zeigt beispielsweise, wie eine virtuelle Adresse in die entsprechende physische Adresse konvertiert wird: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::{Mapper, Page, PageTable, RecursivePageTable}; use x86_64::{VirtAddr, PhysAddr}; /// Creates a RecursivePageTable instance from the level 4 address. let level_4_table_addr = [‚Ä¶]; let level_4_table_ptr = level_4_table_addr as *mut PageTable; let recursive_page_table = unsafe { let level_4_table = &amp;mut *level_4_table_ptr; RecursivePageTable::new(level_4_table).unwrap(); } /// Retrieve the physical address for the given virtual address let addr: u64 = [‚Ä¶] let addr = VirtAddr::new(addr); let page: Page = Page::containing_address(addr); // perform the translation let frame = recursive_page_table.translate_page(page); frame.map(|frame| frame.start_address() + u64::from(addr.page_offset()))</span></span></code> </pre> <br>  Auch dieser Code erfordert eine korrekte rekursive Zuordnung.  Bei dieser Zuordnung wird die fehlende <code>level_4_table_addr</code> wie im ersten Codebeispiel berechnet. <br><br><hr><br>  Rekursives Mapping ist eine interessante Methode, die zeigt, wie leistungsf√§hig Matching durch eine einzelne Tabelle sein kann.  Es ist relativ einfach zu implementieren und erfordert nur eine minimale Einrichtung (nur ein rekursiver Eintrag), daher ist dies eine gute Wahl f√ºr die ersten Experimente. <br><br>  Aber es hat einige Nachteile: <br><br><ul><li>  Eine gro√üe Menge an virtuellem Speicher (512 GiB).  Dies ist in einem gro√üen 48-Bit-Adressraum kein Problem, kann jedoch zu einem suboptimalen Cache-Verhalten f√ºhren. <br></li><li>  Es bietet nur Zugriff auf den aktuell aktiven Adressraum.  Der Zugriff auf andere Adressr√§ume ist weiterhin m√∂glich, indem der rekursive Eintrag ge√§ndert wird. F√ºr die Umschaltung ist jedoch ein tempor√§rer Abgleich erforderlich.  Wie das geht, haben wir in einem fr√ºheren (veralteten) Artikel beschrieben. <br></li><li>  Dies h√§ngt stark vom Format der x86-Seitentabelle ab und funktioniert m√∂glicherweise nicht auf anderen Architekturen. </li></ul><br><a name="3"></a><h1>  Bootloader-Unterst√ºtzung </h1><br>  Alle oben beschriebenen Ans√§tze erfordern √Ñnderungen an den Seitentabellen und den entsprechenden Einstellungen.  Zum Beispiel, um den physischen Speicher identisch oder rekursiv Datens√§tze einer Tabelle der vierten Ebene zuzuordnen.  Das Problem ist, dass wir diese Einstellungen nicht ohne Zugriff auf die Seitentabellen vornehmen k√∂nnen. <br><br>  Also brauche ich Hilfe vom Bootloader.  Er hat Zugriff auf Seitentabellen, sodass er alle erforderlichen Anzeigen erstellen kann.  In der aktuellen Implementierung unterst√ºtzt die <code>bootloader</code> Kiste die beiden oben genannten Ans√§tze mithilfe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Frachtfunktionen</a> : <br><br><ul><li>  Die Funktion <code>map_physical_memory</code> ordnet den gesamten physischen Speicher irgendwo im virtuellen Adressraum zu.  Somit erh√§lt der Kernel Zugriff auf den gesamten physischen Speicher und kann einen Ansatz mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anzeige des vollst√§ndigen physischen Speichers</a> anwenden. <br></li><li>  Mit der Funktion recursive_page_table zeigt der Loader rekursiv einen Seitentabelleneintrag der vierten Ebene an.  Dadurch kann der Kernel gem√§√ü der im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abschnitt "Rekursive Seitentabellen"</a> beschriebenen Methode arbeiten. </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr unseren Kernel w√§hlen wir die erste Option, da dies ein einfacher, plattformunabh√§ngiger und leistungsf√§higerer Ansatz ist (er erm√∂glicht auch den Zugriff auf andere Frames, nicht nur auf Seitentabellen). </font><font style="vertical-align: inherit;">F√ºgen Sie zur Unterst√ºtzung des Bootloaders die Funktion zu den Abh√§ngigkeiten hinzu </font></font><code>map_physical_memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="plaintext hljs">[dependencies] bootloader = { version = "0.4.0", features = ["map_physical_memory"]}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn diese Funktion aktiviert ist, ordnet der Bootloader den gesamten physischen Speicher einem nicht verwendeten Bereich virtueller Adressen zu. </font><font style="vertical-align: inherit;">Um einen Bereich virtueller Adressen an den Kernel zu √ºbergeben, √ºbergibt der Bootloader die Struktur der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Startinformationen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><a name="3_1"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Boot-Informationen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Kiste </font></font><code>bootloader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definiert die Struktur von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BootInfo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit allen Informationen, die an den Kernel √ºbergeben werden. </font><font style="vertical-align: inherit;">Die Struktur wird noch finalisiert, daher kann es beim Upgrade auf zuk√ºnftige Versionen, die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht mit Semver kompatibel sind, zu Fehlern kommen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Derzeit hat die Struktur zwei Felder: </font></font><code>memory_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Feld </font></font><code>memory_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bietet einen √úberblick √ºber den verf√ºgbaren physischen Speicher. </font><font style="vertical-align: inherit;">Es teilt dem Kernel mit, wie viel physischer Speicher auf dem System verf√ºgbar ist und welche Speicherbereiche f√ºr Ger√§te wie VGA reserviert sind. </font><font style="vertical-align: inherit;">Eine Speicherkarte kann vom BIOS oder der UEFI-Firmware angefordert werden, jedoch nur zu Beginn des Startvorgangs. </font><font style="vertical-align: inherit;">Aus diesem Grund muss der Loader dies bereitstellen, da der Kernel diese Informationen dann nicht mehr empfangen kann. </font><font style="vertical-align: inherit;">Eine Speicherkarte wird sp√§ter in diesem Artikel n√ºtzlich sein.</font></font><br></li><li> <code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">meldet die virtuelle Startadresse der physischen Speicherzuordnung. </font><font style="vertical-align: inherit;">Wenn wir diesen Offset zur physischen Adresse hinzuf√ºgen, erhalten wir die entsprechende virtuelle Adresse. </font><font style="vertical-align: inherit;">Dies erm√∂glicht den Zugriff vom Kernel auf einen beliebigen physischen Speicher.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Loader √ºbergibt die Struktur </font></font><code>BootInfo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">als Argument </font></font><code>&amp;'static BootInfo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an die Funktion </font><font style="vertical-align: inherit;">an den </font><font style="vertical-align: inherit;">Kernel </font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">F√ºgen Sie es hinzu:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs use bootloader::BootInfo; #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start(boot_info: &amp;'static BootInfo) -&gt; ! { // new argument [‚Ä¶] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es ist wichtig, den richtigen Argumenttyp anzugeben, da der Compiler den richtigen Signaturtyp unserer Einstiegspunktfunktion nicht kennt. </font></font><br><br><a name="3_2"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Einstiegspunktmakro </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da die Funktion </font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">extern vom Loader aufgerufen wird, wird die Signatur der Funktion nicht √ºberpr√ºft. Dies bedeutet, dass wir beliebige Argumente ohne Kompilierungsfehler akzeptieren k√∂nnen, dies jedoch abst√ºrzt oder ein undefiniertes Laufzeitverhalten verursacht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um sicherzustellen, dass die Einstiegspunktfunktion immer die richtige Signatur hat, stellt die Kiste </font></font><code>bootloader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein Makro bereit </font></font><code>entry_point</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wir schreiben unsere Funktion mit diesem Makro neu:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs use bootloader::{BootInfo, entry_point}; entry_point!(kernel_main); #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie m√ºssen nicht mehr f√ºr den Einstiegspunkt </font></font><code>extern "C"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder </font></font><code>no_mangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, da das Makro f√ºr uns den realen Einstiegspunkt der unteren Ebene definiert, verwenden </font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Die Funktion ist </font></font><code>kernel_main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jetzt zu einer v√∂llig normalen Rust-Funktion geworden, sodass wir einen beliebigen Namen daf√ºr w√§hlen k√∂nnen. Wichtig ist, dass es nach Typ √ºberpr√ºft wird. Wenn Sie also die falsche Signatur verwenden, z. B. indem Sie ein Argument hinzuf√ºgen oder seinen Typ √§ndern, tritt ein Kompilierungsfehler auf</font></font><br><br><a name="4"></a><h1>  Implementierung </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt haben wir Zugriff auf den physischen Speicher und k√∂nnen endlich mit der Implementierung des Systems beginnen. </font><font style="vertical-align: inherit;">Betrachten Sie zun√§chst die aktuell aktiven Seitentabellen, auf denen der Kernel ausgef√ºhrt wird. </font><font style="vertical-align: inherit;">Erstellen Sie im zweiten Schritt eine √úbersetzungsfunktion, die die physische Adresse zur√ºckgibt, der diese virtuelle Adresse zugeordnet ist. </font><font style="vertical-align: inherit;">Im letzten Schritt werden wir versuchen, die Seitentabellen zu √§ndern, um eine neue Zuordnung zu erstellen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie zun√§chst ein neues Modul im Code </font></font><code>memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/lib.rs pub mod memory;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie f√ºr das Modul eine leere Datei </font></font><code>src/memory.rs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><a name="4_1"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zugriff auf Seitentabellen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Am Ende des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vorherigen Artikels haben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir versucht, die Seitentabelle zu betrachten, auf der der Kernel arbeitet, konnten jedoch nicht auf den physischen Frame zugreifen, auf den das Register zeigt </font></font><code>CR3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Jetzt k√∂nnen wir von diesem Ort aus weiterarbeiten: Die Funktion </font></font><code>active_level_4_table</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gibt einen Link zur aktiven Seitentabelle der vierten Ebene zur√ºck:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::PageTable; /// Returns a mutable reference to the active level 4 table. /// /// This function is unsafe because the caller must guarantee that the /// complete physical memory is mapped to virtual memory at the passed /// `physical_memory_offset`. Also, this function must be only called once /// to avoid aliasing `&amp;mut` references (which is undefined behavior). pub unsafe fn active_level_4_table(physical_memory_offset: u64) -&gt; &amp;'static mut PageTable { use x86_64::{registers::control::Cr3, VirtAddr}; let (level_4_table_frame, _) = Cr3::read(); let phys = level_4_table_frame.start_address(); let virt = VirtAddr::new(phys.as_u64() + physical_memory_offset); let page_table_ptr: *mut PageTable = virt.as_mut_ptr(); &amp;mut *page_table_ptr // unsafe }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuerst lesen wir den physischen Rahmen der aktiven Tabelle der 4. Ebene aus dem Register </font></font><code>CR3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dann nehmen wir die physische Startadresse und konvertieren sie durch Hinzuf√ºgen in eine virtuelle Adresse </font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Konvertieren Sie schlie√ülich die Adresse </font></font><code>*mut PageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">durch die Methode </font><font style="vertical-align: inherit;">in einen </font></font><code>as_mut_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rohzeiger und erstellen Sie dann unsicher einen Link daraus </font></font><code>&amp;mut PageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wir erstellen </font></font><code>&amp;mut</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stattdessen </font><font style="vertical-align: inherit;">den Link </font></font><code>&amp;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, da wir sp√§ter in diesem Artikel diese Seitentabellen √§ndern werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier muss kein unsicherer Block eingef√ºgt werden, da Rust den gesamten K√∂rper </font></font><code>unsafe fn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">als einen gro√üen, unsicheren Block betrachtet. Dies erh√∂ht die Risiken, da es m√∂glich ist, in den vorherigen Zeilen versehentlich einen unsicheren Betrieb einzuf√ºhren. Es macht es auch schwierig, unsichere Vorg√§nge zu erkennen. Es </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wurde</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bereits ein </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">RFC</font></a><font style="vertical-align: inherit;"> erstellt </font><font style="vertical-align: inherit;">, um dieses Verhalten von Rust zu √§ndern.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir diese Funktion verwenden, um die Datens√§tze der Tabelle der vierten Ebene auszugeben:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS use blog_os::memory::active_level_4_table; let l4_table = unsafe { active_level_4_table(boot_info.physical_memory_offset) }; for (i, entry) in l4_table.iter().enumerate() { if !entry.is_unused() { println!("L4 Entry {}: {:?}", i, entry); } } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir </font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ºbergeben das entsprechende Feld der Struktur </font></font><code>BootInfo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dann verwenden wir eine Funktion </font></font><code>iter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um die Seitentabelleneintr√§ge zu durchlaufen, und einen Kombinator </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">enumerate</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um </font></font><code>i</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jedem Element </font><font style="vertical-align: inherit;">einen Index hinzuzuf√ºgen </font><font style="vertical-align: inherit;">. Es werden nur nicht leere Eintr√§ge angezeigt, da nicht alle 512 Eintr√§ge auf den Bildschirm passen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir den Code ausf√ºhren, sehen wir folgendes Ergebnis: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a33/def/50d/a33def50db528880395b665882aabe75.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sehen mehrere nicht leere Datens√§tze, die verschiedenen Tabellen der dritten Ebene zugeordnet sind. Es werden so viele Speicherbereiche verwendet, weil separate Bereiche f√ºr Kernelcode, Kernelstapel, physische Speicher√ºbersetzung und Startinformationen ben√∂tigt werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Seitentabellen durchzugehen und die Tabelle der dritten Ebene zu betrachten, k√∂nnen wir den angezeigten Frame erneut in eine virtuelle Adresse konvertieren:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in the for loop in src/main.rs use x86_64::{structures::paging::PageTable, VirtAddr}; if !entry.is_unused() { println!("L4 Entry {}: {:?}", i, entry); // get the physical address from the entry and convert it let phys = entry.frame().unwrap().start_address(); let virt = phys.as_u64() + boot_info.physical_memory_offset; let ptr = VirtAddr::new(virt).as_mut_ptr(); let l3_table: &amp;PageTable = unsafe { &amp;*ptr }; // print non-empty entries of the level 3 table for (i, entry) in l3_table.iter().enumerate() { if !entry.is_unused() { println!(" L3 Entry {}: {:?}", i, entry); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wiederholen Sie diesen Vorgang f√ºr Datens√§tze der dritten und zweiten Ebene, um die Tabellen der zweiten und ersten Ebene anzuzeigen. </font><font style="vertical-align: inherit;">Wie Sie sich vorstellen k√∂nnen, w√§chst die Menge an Code sehr schnell, sodass wir nicht die vollst√§ndige Liste ver√∂ffentlichen werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das manuelle Durchlaufen von Tabellen ist interessant, da es hilft zu verstehen, wie der Prozessor Adressen √ºbersetzt. </font><font style="vertical-align: inherit;">Normalerweise sind wir jedoch nur daran interessiert, eine physische Adresse f√ºr eine bestimmte virtuelle Adresse anzuzeigen. Erstellen wir daher eine Funktion daf√ºr.</font></font><br><br><a name="4_2"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adress√ºbersetzung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um eine virtuelle Adresse in eine physische Adresse zu √ºbersetzen, m√ºssen wir eine vierstufige Seitentabelle durchgehen, bis wir den zugeordneten Frame erreichen. </font><font style="vertical-align: inherit;">Erstellen wir eine Funktion, die diese Adress√ºbersetzung ausf√ºhrt:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::{PhysAddr, VirtAddr}; /// Translates the given virtual address to the mapped physical address, or /// `None` if the address is not mapped. /// /// This function is unsafe because the caller must guarantee that the /// complete physical memory is mapped to virtual memory at the passed /// `physical_memory_offset`. pub unsafe fn translate_addr(addr: VirtAddr, physical_memory_offset: u64) -&gt; Option&lt;PhysAddr&gt; { translate_addr_inner(addr, physical_memory_offset) }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verweisen auf eine sichere Funktion </font></font><code>translate_addr_inner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um die Menge an unsicherem Code zu begrenzen. Wie oben erw√§hnt, betrachtet Rust den gesamten K√∂rper </font></font><code>unsafe fn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">als einen gro√üen unsicheren Block. Durch Aufrufen einer sicheren Funktion machen wir jede Operation erneut explizit </font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine spezielle interne Funktion hat echte Funktionalit√§t:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs /// Private function that is called by `translate_addr`. /// /// This function is safe to limit the scope of `unsafe` because Rust treats /// the whole body of unsafe functions as an unsafe block. This function must /// only be reachable through `unsafe fn` from outside of this module. fn translate_addr_inner(addr: VirtAddr, physical_memory_offset: u64) -&gt; Option&lt;PhysAddr&gt; { use x86_64::structures::paging::page_table::FrameError; use x86_64::registers::control::Cr3; // read the active level 4 frame from the CR3 register let (level_4_table_frame, _) = Cr3::read(); let table_indexes = [ addr.p4_index(), addr.p3_index(), addr.p2_index(), addr.p1_index() ]; let mut frame = level_4_table_frame; // traverse the multi-level page table for &amp;index in &amp;table_indexes { // convert the frame into a page table reference let virt = frame.start_address().as_u64() + physical_memory_offset; let table_ptr: *const PageTable = VirtAddr::new(virt).as_ptr(); let table = unsafe {&amp;*table_ptr}; // read the page table entry and update `frame` let entry = &amp;table[index]; frame = match entry.frame() { Ok(frame) =&gt; frame, Err(FrameError::FrameNotPresent) =&gt; return None, Err(FrameError::HugeFrame) =&gt; panic!("huge pages not supported"), }; } // calculate the physical address by adding the page offset Some(frame.start_address() + u64::from(addr.page_offset())) }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstatt die Funktion </font></font><code>active_level_4_table</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wiederzuverwenden, lesen wir den Frame der vierten Ebene erneut aus dem Register </font></font><code>CR3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, da dies die Implementierung des Prototyps vereinfacht. Keine Sorge, wir werden die L√∂sung bald verbessern. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Struktur </font></font><code>VirtAddr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bietet bereits Methoden zur Berechnung von Indizes in Seitentabellen mit vier Ebenen. Wir speichern diese Indizes in einem kleinen Array, da Sie so alle Tabellen durchlaufen k√∂nnen </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Au√üerhalb der Schleife erinnern wir uns an den zuletzt besuchten Frame, um die physikalische Adresse sp√§ter zu berechnen. </font></font><code>frame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zeigt auf die Frames der Seitentabelle w√§hrend der Iteration und auf den zugeh√∂rigen Frame nach der letzten Iteration, dh nach dem √úbergeben des Level 1-Datensatzes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Innerhalb der Schleife wenden wir erneut an</font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um einen Frame in einen Seitentabellenlink zu konvertieren. Dann lesen wir den Datensatz der aktuellen Seitentabelle und verwenden die Funktion </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>PageTableEntry::frame</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um den √ºbereinstimmenden Frame abzurufen. Wenn der Datensatz keinem Frame zugeordnet ist, kehren Sie zur√ºck </font></font><code>None</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn der Datensatz eine riesige Seite von 2 MiB oder 1 GiB anzeigt, haben wir bisher eine Panik. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úberpr√ºfen wir also die √úbersetzungsfunktion an einigen Adressen:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS use blog_os::memory::translate_addr; use x86_64::VirtAddr; let addresses = [ // the identity-mapped vga buffer page 0xb8000, // some code page 0x20010a, // some stack page 0x57ac_001f_fe48, // virtual address mapped to physical address 0 boot_info.physical_memory_offset, ]; for &amp;address in &amp;addresses { let virt = VirtAddr::new(address); let phys = unsafe { translate_addr(virt, boot_info.physical_memory_offset) }; println!("{:?} -&gt; {:?}", virt, phys); } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir den Code ausf√ºhren, erhalten wir das folgende Ergebnis: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a0b/e32/db8/a0be32db8b6353452f9d40d7b1d350ad.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie erwartet wird bei einer identischen Zuordnung die Adresse </font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in dieselbe physikalische Adresse konvertiert. </font><font style="vertical-align: inherit;">Die Codepage und die Stapelseite werden in beliebige physische Adressen konvertiert, die davon abh√§ngen, wie der Loader die anf√§ngliche Zuordnung f√ºr unseren Kernel erstellt hat. </font><font style="vertical-align: inherit;">Die Zuordnung </font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sollte auf die physische Adresse verweisen </font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, schl√§gt jedoch fehl, da die √úbersetzung aus Effizienzgr√ºnden gro√üe Seiten verwendet. </font><font style="vertical-align: inherit;">Eine zuk√ºnftige Version des Bootloaders wendet m√∂glicherweise dieselbe Optimierung f√ºr die Kernel- und Stack-Seiten an.</font></font><br><br><a name="4_3"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verwenden von MappedPageTable </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die √úbersetzung virtueller Adressen in physische Adressen ist eine typische Aufgabe des Betriebssystemkerns, daher </font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bietet </font><font style="vertical-align: inherit;">die Kiste </font><font style="vertical-align: inherit;">eine Abstraktion daf√ºr. </font><font style="vertical-align: inherit;">Es unterst√ºtzt bereits gro√üe Seiten und einige andere Funktionen, au√üer dass </font></font><code>translate_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir es verwenden, anstatt unserer eigenen Implementierung Unterst√ºtzung f√ºr gro√üe Seiten hinzuzuf√ºgen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Basis der Abstraktion sind zwei Merkmale, die verschiedene √úbersetzungsfunktionen der Seitentabelle definieren:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Merkmal </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Mapper</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bietet Funktionen, die auf Seiten funktionieren. </font><font style="vertical-align: inherit;">Zum Beispiel, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>translate_page</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um diese Seite in einen Rahmen derselben Gr√∂√üe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>map_to</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zu √ºbersetzen und eine neue Zuordnung in der Tabelle zu erstellen.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Merkmal </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>MapperAllSizes</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">impliziert die Anwendung </font></font><code>Mapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√ºr alle Seitengr√∂√üen. </font><font style="vertical-align: inherit;">Dar√ºber hinaus bietet es Funktionen, die mit Seiten unterschiedlicher Gr√∂√üe arbeiten, einschlie√ülich </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>translate_addr</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder allgemein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>translate</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Merkmale definieren nur die Schnittstelle, bieten jedoch keine Implementierung. </font><font style="vertical-align: inherit;">Jetzt </font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bietet </font><font style="vertical-align: inherit;">die Kiste </font><font style="vertical-align: inherit;">zwei Typen, die Merkmale implementieren: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>MappedPageTable</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>RecursivePageTable</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Das erste erfordert, dass jeder Frame der Seitentabelle irgendwo angezeigt wird (z. B. mit einem Versatz). </font><font style="vertical-align: inherit;">Der zweite Typ kann verwendet werden, wenn die Tabelle der vierten Ebene rekursiv angezeigt wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben den gesamten physischen Speicher zugeordnet </font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sodass Sie den Typ MappedPageTable verwenden k√∂nnen. </font><font style="vertical-align: inherit;">Erstellen Sie zum Initialisieren eine neue Funktion </font></font><code>init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im Modul </font></font><code>memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> x86_64::structures::paging::{PhysFrame, MapperAllSizes, MappedPageTable}; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> x86_64::PhysAddr; <span class="hljs-comment"><span class="hljs-comment">/// Initialize a new MappedPageTable. /// /// This function is unsafe because the caller must guarantee that the /// complete physical memory is mapped to virtual memory at the passed /// `physical_memory_offset`. Also, this function must be only called once /// to avoid aliasing `&amp;mut` references (which is undefined behavior). pub unsafe fn init(physical_memory_offset: u64) -&gt; impl MapperAllSizes { let level_4_table = active_level_4_table(physical_memory_offset); let phys_to_virt = move |frame: PhysFrame| -&gt; *mut PageTable { let phys = frame.start_address().as_u64(); let virt = VirtAddr::new(phys + physical_memory_offset); virt.as_mut_ptr() }; MappedPageTable::new(level_4_table, phys_to_virt) } // make private unsafe fn active_level_4_table(physical_memory_offset: u64) -&gt; &amp;'static mut PageTable {‚Ä¶}</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen nicht direkt </font></font><code>MappedPageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von einer Funktion zur√ºckkehren, da dies f√ºr einen Verschlusstyp √ºblich ist. Wir werden dieses Problem mit einem Syntaxkonstrukt umgehen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>impl Trait</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ein weiterer Vorteil ist, dass Sie den Kernel dann wechseln k√∂nnen, </font></font><code>RecursivePageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ohne die Signatur der Funktion zu √§ndern. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Funktion </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>MappedPageTable::new</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erwartet zwei Parameter: eine ver√§nderbare Verkn√ºpfung zur Seitentabelle der Ebene 4 und einen Abschluss </font></font><code>phys_to_virt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der den physischen Frame in einen Seitentabellenzeiger konvertiert </font></font><code>*mut PageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. F√ºr den ersten Parameter k√∂nnen wir die Funktion wiederverwenden </font></font><code>active_level_4_table</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Zum zweiten erstellen wir einen Abschluss, mit </font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dem die Konvertierung durchgef√ºhrt wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir machen es auch zu einer </font></font><code>active_level_4_table</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">privaten Funktion, da es von nun an nur noch von aufgerufen wird </font></font><code>init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So verwenden Sie die Methode</font></font><code>MapperAllSizes::translate_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstelle unserer eigenen Funktion </font></font><code>memory::translate_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√ºssen wir nur ein paar Zeilen √§ndern in </font></font><code>kernel_main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS // new: different imports use blog_os::memory; use x86_64::{structures::paging::MapperAllSizes, VirtAddr}; // new: initialize a mapper let mapper = unsafe { memory::init(boot_info.physical_memory_offset) }; let addresses = [‚Ä¶]; // same as before for &amp;address in &amp;addresses { let virt = VirtAddr::new(address); // new: use the `mapper.translate_addr` method let phys = mapper.translate_addr(virt); println!("{:?} -&gt; {:?}", virt, phys); } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach dem Start sehen wir die gleichen √úbersetzungsergebnisse wie zuvor, aber jetzt funktionieren nur noch gro√üe Seiten: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/51d/5ed/d9c/51d5edd9c004e1238b321dee51fdf8b3.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie erwartet wird die virtuelle Adresse </font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in eine physische Adresse konvertiert </font></font><code>0x0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Durch die Verwendung der √úbersetzungsfunktion f√ºr den Typ </font></font><code>MappedPageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entf√§llt die Notwendigkeit, die Unterst√ºtzung f√ºr gro√üe Seiten zu implementieren. </font><font style="vertical-align: inherit;">Wir haben auch Zugriff auf andere Seitenfunktionen, wie </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir sie im n√§chsten Abschnitt verwenden werden. </font><font style="vertical-align: inherit;">Zu diesem Zeitpunkt ben√∂tigen wir die Funktion nicht mehr </font></font><code>memory::translate_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sie k√∂nnen sie l√∂schen, wenn Sie m√∂chten.</font></font><br><br><a name="4_4"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erstellen Sie eine neue Zuordnung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher haben wir uns nur Seitentabellen angesehen, aber nichts ge√§ndert. </font><font style="vertical-align: inherit;">Erstellen wir eine neue Zuordnung f√ºr eine zuvor nicht angezeigte Seite. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden die Funktion </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>map_to</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus dem Merkmal verwenden </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Mapper</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, also werden wir zuerst diese Funktion betrachten. </font><font style="vertical-align: inherit;">Die Dokumentation besagt, dass vier Argumente erforderlich sind: die Seite, die wir anzeigen m√∂chten; </font><font style="vertical-align: inherit;">Der Rahmen, dem die Seite zugeordnet werden soll. </font><font style="vertical-align: inherit;">Satz von Flags zum Schreiben von Seitentabellen und Rahmenverteilern </font></font><code>frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ein Frame-Allokator ist erforderlich, da f√ºr die Zuordnung dieser Seite m√∂glicherweise zus√§tzliche Tabellen erstellt werden m√ºssen, f√ºr die nicht verwendete Frames als Sicherungsspeicher erforderlich sind.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font></font><code>create_example_mapping</code> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der erste Schritt in unserer Implementierung besteht darin, eine neue Funktion zu erstellen </font></font><code>create_example_mapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die diese Seite dem </font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">physischen Frame des VGA-Textpuffers zuordnet. Wir w√§hlen diesen Rahmen aus, weil es einfach ist zu √ºberpr√ºfen, ob die Anzeige korrekt erstellt wurde: Wir m√ºssen nur auf die zuletzt angezeigte Seite schreiben und sehen, ob sie auf dem Bildschirm angezeigt wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Funktion </font></font><code>create_example_mapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sieht folgenderma√üen aus:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::{Page, Size4KiB, Mapper, FrameAllocator}; /// Creates an example mapping for the given page to frame `0xb8000`. pub fn create_example_mapping( page: Page, mapper: &amp;mut impl Mapper&lt;Size4KiB&gt;, frame_allocator: &amp;mut impl FrameAllocator&lt;Size4KiB&gt;, ) { use x86_64::structures::paging::PageTableFlags as Flags; let frame = PhysFrame::containing_address(PhysAddr::new(0xb8000)); let flags = Flags::PRESENT | Flags::WRITABLE; let map_to_result = unsafe { mapper.map_to(page, frame, flags, frame_allocator) }; map_to_result.expect("map_to failed").flush(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zus√§tzlich zu der Seite, die </font></font><code>page</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie zuordnen m√∂chten, erwartet die Funktion eine Instanz von </font></font><code>mapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Der Typ </font></font><code>mapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementiert das Merkmal </font></font><code>Mapper&lt;Size4KiB&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das die Methode bereitstellt </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Gemeinsame Parameter </font></font><code>Size4KiB</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">notwendig , </font><font style="vertical-align: inherit;">weil Merkmal </font></font><code>Mapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">h√§ufig</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√ºr das Merkmal </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PageSize</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das </font><font style="vertical-align: inherit;">Arbeiten mit Standard - </font><font style="vertical-align: inherit;">4 KiB Seiten und mit enormen Seiten 2 und MiB 1 GiB. Wir m√∂chten nur 4 KiB-Seiten erstellen, damit wir sie </font></font><code>Mapper&lt;Size4KiB&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anstelle der Anforderung verwenden k√∂nnen </font></font><code>MapperAllSizes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setzen Sie zum Vergleich das Flag </font></font><code>PRESENT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, da alle g√ºltigen Eintr√§ge erforderlich sind, und das Flag </font></font><code>WRITABLE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um die angezeigte Seite beschreibbar zu machen. Herausforderung</font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsicher: Sie k√∂nnen die Speichersicherheit mit ung√ºltigen Argumenten verletzen, daher m√ºssen Sie einen Block verwenden </font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Eine Liste aller m√∂glichen Flags finden Sie im Abschnitt ‚ÄûSeitentabellenformat‚Äú des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vorherigen Artikels</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Funktion </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann fehlschlagen und kehrt daher zur√ºck </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Result</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Da dies nur ein Beispiel f√ºr Code ist, der nicht zuverl√§ssig sein sollte, verwenden wir ihn einfach, um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>expect</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im Fehlerfall in Panik zu geraten. </font><font style="vertical-align: inherit;">Bei Erfolg gibt die Funktion einen Typ zur√ºck </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>MapperFlush</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mit dem die zuletzt angezeigte Seite mithilfe der Methode auf einfache Weise aus dem dynamischen √úbersetzungspuffer (TLB) gel√∂scht werden kann </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>flush</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Da </font></font><code>Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diese Art von Attribut verwendet [ </font></font><code>#[must_use]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">] f√ºr</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine Warnung ausgeben, wenn wir versehentlich vergessen, sie zu verwenden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fiktiv </font></font><code>FrameAllocator</code> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um anzurufen </font></font><code>create_example_mapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, m√ºssen Sie zuerst erstellen </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wie oben erw√§hnt, h√§ngt die Komplexit√§t beim Erstellen einer neuen Anzeige von der virtuellen Seite ab, die angezeigt werden soll. </font><font style="vertical-align: inherit;">Im einfachsten Fall ist bereits eine Tabelle der Ebene 1 f√ºr die Seite vorhanden, und wir m√ºssen nur einen Datensatz erstellen. </font><font style="vertical-align: inherit;">Im schwierigsten Fall befindet sich die Seite in einem Speicherbereich, f√ºr den noch keine Ebene 3 erstellt wurde. Zun√§chst m√ºssen Sie Seitentabellen der Ebenen 3, 2 und 1 erstellen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginnen wir mit einem einfachen Fall und gehen davon aus, dass Sie keine neuen Seitentabellen erstellen m√ºssen. </font><font style="vertical-align: inherit;">Ein Rahmenverteiler, der immer zur√ºckgibt, reicht daf√ºr aus </font></font><code>None</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir erstellen eine solche </font></font><code>EmptyFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anzeigefunktion zum Testen:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs /// A FrameAllocator that always returns `None`. pub struct EmptyFrameAllocator; impl FrameAllocator&lt;Size4KiB&gt; for EmptyFrameAllocator { fn allocate_frame(&amp;mut self) -&gt; Option&lt;PhysFrame&gt; { None } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt m√ºssen Sie eine Seite finden, die angezeigt werden kann, ohne neue Seitentabellen zu erstellen. Der Loader wird in das erste Megabyte des virtuellen Adressraums geladen, sodass wir wissen, dass f√ºr diesen Bereich eine g√ºltige Tabelle der Ebene 1 vorhanden ist. In unserem Beispiel k√∂nnen wir jede nicht verwendete Seite in diesem Speicherbereich ausw√§hlen, z. B. die Seite an der Adresse </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Funktion zu testen, zeigen wir zuerst die Seite </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und dann den Inhalt des Speichers an:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS use blog_os::memory; use x86_64::{structures::paging::Page, VirtAddr}; let mut mapper = unsafe { memory::init(boot_info.physical_memory_offset) }; let mut frame_allocator = memory::EmptyFrameAllocator; // map a previously unmapped page let page = Page::containing_address(VirtAddr::new(0x1000)); memory::create_example_mapping(page, &amp;mut mapper, &amp;mut frame_allocator); // write the string `New!` to the screen through the new mapping let page_ptr: *mut u64 = page.start_address().as_mut_ptr(); unsafe { page_ptr.offset(400).write_volatile(0x_f021_f077_f065_f04e)}; println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuerst erstellen wir eine Zuordnung f√ºr die Seite in </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und rufen eine Funktion </font></font><code>create_example_mapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit einem ver√§nderlichen Link zu Instanzen </font></font><code>mapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und auf </font></font><code>frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dadurch wird die Seite </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dem VGA-Textpufferrahmen zugeordnet, sodass wir sehen sollten, was dort auf dem Bildschirm geschrieben steht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konvertieren Sie dann die Seite in einen Rohzeiger und schreiben Sie den Wert in den Versatz </font></font><code>400</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wir schreiben nicht an den Anfang der Seite, da die oberste Zeile des VGA-Puffers wie folgt direkt vom Bildschirm verschoben wird </font></font><code>println</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Schreiben Sie den Wert </font></font><code>0x_f021_f077_f065_f04e</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der der Zeichenfolge </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Neu!" Entspricht.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf einem wei√üen Hintergrund. Wie wir im Artikel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄûVGA-Textmodus‚Äú</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erfahren haben </font><font style="vertical-align: inherit;">, muss das Schreiben in den VGA-Puffer fl√ºchtig sein, daher verwenden wir die Methode </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>write_volatile</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir den Code in QEMU ausf√ºhren, sehen wir das folgende Ergebnis: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4cf/248/1a0/4cf2481a07f40c681954ff4954dce866.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach dem Schreiben auf die Seite </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird die Aufschrift </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Neu!"</font></font></i>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher haben wir erfolgreich eine neue Zuordnung in Seitentabellen erstellt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Sortierung funktionierte, da bereits eine Tabelle der Ebene 1 f√ºr die Sortierung vorhanden war </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn wir versuchen, eine Seite zuzuordnen, f√ºr die noch keine Tabelle der Ebene 1 vorhanden ist, </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">schl√§gt </font><font style="vertical-align: inherit;">die Funktion </font><font style="vertical-align: inherit;">fehl, da versucht wird, Frames zuzuweisen </font></font><code>EmptyFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um neue Tabellen zu erstellen. </font><font style="vertical-align: inherit;">Wir sehen, dass dies passiert, wenn wir versuchen, die Seite anzuzeigen, </font></font><code>0xdeadbeaf000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anstatt </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] let page = Page::containing_address(VirtAddr::new(0xdeadbeaf000)); [‚Ä¶] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn dies gestartet wird, tritt eine Panik mit der folgenden Fehlermeldung auf: </font></font><br><br><pre> <code class="plaintext hljs">panicked at 'map_to failed: FrameAllocationFailed', /‚Ä¶/result.rs:999:5</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um Seiten anzuzeigen, die noch keine Tabelle der Seitenebene 1 haben, m√ºssen Sie die richtige erstellen </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aber woher wissen Sie, welche Frames frei sind und wie viel physischer Speicher verf√ºgbar ist?</font></font><br><br><a name="4_5"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rahmenauswahl </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr neue Seitentabellen m√ºssen Sie den richtigen Rahmenverteiler erstellen. </font><font style="vertical-align: inherit;">Beginnen wir mit dem allgemeinen Skelett:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs pub struct BootInfoFrameAllocator&lt;I&gt; where I: Iterator&lt;Item = PhysFrame&gt; { frames: I, } impl&lt;I&gt; FrameAllocator&lt;Size4KiB&gt; for BootInfoFrameAllocator&lt;I&gt; where I: Iterator&lt;Item = PhysFrame&gt; { fn allocate_frame(&amp;mut self) -&gt; Option&lt;PhysFrame&gt; { self.frames.next() } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Feld </font></font><code>frames</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann mit einem beliebigen Frame-Iterator initialisiert werden. Auf diese Weise k√∂nnen Sie Aufrufe einfach an die </font></font><code>alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode </font><font style="vertical-align: inherit;">delegieren </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Iterator::next</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr die Initialisierung verwenden wir </font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Speicherkarte, </font></font><code>memory_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die der Bootloader als Teil der Struktur √ºbertr√§gt </font></font><code>BootInfo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wie im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abschnitt Startinformationen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erl√§utert </font><font style="vertical-align: inherit;">, wird die Speicherkarte von der BIOS / UEFI-Firmware bereitgestellt. Es kann nur zu Beginn des Startvorgangs angefordert werden, sodass der Bootloader die erforderlichen Funktionen bereits aufgerufen hat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Speicherkarte besteht aus einer Liste von Strukturen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>MemoryRegion</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die die Startadresse, L√§nge und den Typ (z. B. nicht verwendet, reserviert usw.) jedes Speicherbereichs enthalten. Durch Erstellen eines Iterators, der Frames aus nicht verwendeten Bereichen erzeugt, k√∂nnen wir einen g√ºltigen erstellen </font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Initialisierung </font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erfolgt in einer neuen Funktion </font></font><code>init_frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use bootloader::bootinfo::{MemoryMap, MemoryRegionType}; /// Create a FrameAllocator from the passed memory map pub fn init_frame_allocator( memory_map: &amp;'static MemoryMap, ) -&gt; BootInfoFrameAllocator&lt;impl Iterator&lt;Item = PhysFrame&gt;&gt; { // get usable regions from memory map let regions = memory_map .iter() .filter(|r| r.region_type == MemoryRegionType::Usable); // map each region to its address range let addr_ranges = regions.map(|r| r.range.start_addr()..r.range.end_addr()); // transform to an iterator of frame start addresses let frame_addresses = addr_ranges.flat_map(|r| r.step_by(4096)); // create `PhysFrame` types from the start addresses let frames = frame_addresses.map(|addr| { PhysFrame::containing_address(PhysAddr::new(addr)) }); BootInfoFrameAllocator { frames } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Funktion verwendet einen Kombinator, um die anf√§ngliche Zuordnung </font></font><code>MemoryMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in einen Iterator der verwendeten physischen Frames </font><font style="vertical-align: inherit;">zu konvertieren </font><font style="vertical-align: inherit;">:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuerst rufen wir die Methode </font></font><code>iter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf, um die Speicherkarte in einen Iterator umzuwandeln </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>MemoryRegion</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dann verwenden wir die Methode </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>filter</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um reservierte oder unzug√§ngliche Regionen zu √ºberspringen. </font><font style="vertical-align: inherit;">Der Loader aktualisiert die Speicherkarte f√ºr alle von ihm erstellten Zuordnungen, sodass die vom Kernel (Code, Daten oder Stapel) oder zum Speichern von Informationen √ºber den Start verwendeten Frames bereits als </font></font><code>InUse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder √§hnlich </font><font style="vertical-align: inherit;">markiert sind </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Somit k√∂nnen wir sicher sein, dass Frames </font></font><code>Usable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht </font><font style="vertical-align: inherit;">anderweitig </font><font style="vertical-align: inherit;">verwendet </font><font style="vertical-align: inherit;">werden </font><font style="vertical-align: inherit;">.</font></font><br></li><li>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>map</code></a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">range</a>  Rust         . <br></li><li>    :         <code>into_iter</code> ,     4096-    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>step_by</code></a> .  4096  (= 4 ) ‚Äî   ,      .      ,         .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>flat_map</code></a>  <code>map</code> ,   <code>Iterator&lt;Item = u64&gt;</code>  <code>Iterator&lt;Item = Iterator&lt;Item = u64&gt;&gt;</code> . <br></li><li>         <code>PhysFrame</code> ,    <code>Iterator&lt;Item = PhysFrame&gt;</code> .          <code>BootInfoFrameAllocator</code> . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir unsere Funktion √§ndern </font></font><code>kernel_main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um </font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stattdessen </font><font style="vertical-align: inherit;">eine Instanz </font><font style="vertical-align: inherit;">zu √ºbergeben </font></font><code>EmptyFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] let mut frame_allocator = memory::init_frame_allocator(&amp;boot_info.memory_map); [‚Ä¶] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diesmal war die Adresszuordnung erfolgreich und wir sehen wieder das schwarz-wei√üe </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Neu!"</font></font></i>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinter den Kulissen erstellt die Methode </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fehlende Seitentabellen wie folgt:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§hlen Sie einen nicht verwendeten Frame aus dem √ºbertragenen aus </font></font><code>frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Null Frame zum Erstellen einer neuen leeren Seitentabelle. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ordnen Sie diesem Frame einen √ºbergeordneten Tabelleneintrag zu. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gehen Sie zur n√§chsten Ebene der Tabelle. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl unsere Funktion </font></font><code>create_example_mapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur Beispielcode ist, k√∂nnen wir jetzt neue Zuordnungen f√ºr beliebige Seiten erstellen. </font><font style="vertical-align: inherit;">Dies ist erforderlich, um Speicher zuzuweisen und Multithreading in zuk√ºnftigen Artikeln zu implementieren.</font></font><br><br><a name="5"></a><h1>  Zusammenfassung </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Artikel haben wir verschiedene Methoden f√ºr den Zugriff auf die physischen Frames von Seitentabellen kennengelernt, darunter Identit√§tszuordnung, Zuordnung des gesamten physischen Speichers, tempor√§re Zuordnung und rekursive Seitentabellen. Wir haben uns daf√ºr entschieden, den vollst√§ndigen physischen Speicher als einfache und leistungsstarke Methode anzuzeigen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen den physischen Speicher des Kernels nicht ohne Zugriff auf die Seitentabelle zuordnen, daher ist Bootloader-Unterst√ºtzung erforderlich. Das Rack </font></font><code>bootloader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erstellt die erforderlichen Zuordnungen durch zus√§tzliche Ladefunktionen. Es √ºbergibt die erforderlichen Informationen als Argument </font></font><code>&amp;BootInfo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an die Einstiegspunktfunktion </font><font style="vertical-align: inherit;">an den Kernel </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr unsere Implementierung haben wir zuerst die Seitentabellen manuell durchgesehen, eine √úbersetzungsfunktion erstellt und dann den </font></font><code>MappedPageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kistentyp verwendet</font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir haben auch gelernt, wie man neue Zuordnungen in der Seitentabelle erstellt und wie man sie </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf einer vom Bootloader √ºbertragenen Speicherkarte erstellt.</font></font><br><br><a name="6"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Was weiter? </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im n√§chsten Artikel erstellen wir einen Heap-Speicherbereich f√ºr unseren Kernel, in dem wir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speicher zuweisen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und verschiedene </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arten von Sammlungen verwenden k√∂nnen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445618/">https://habr.com/ru/post/de445618/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445596/index.html">Tipps und Tricks von Kubernetes: Personalisierte Fehlerseiten in NGINX Ingress</a></li>
<li><a href="../de445600/index.html">[Umfrage und b√∂se] Hostings, seien sie falsch</a></li>
<li><a href="../de445602/index.html">PHP Russland 2019: sein "Stadion" f√ºr die Sprache der ersten Liga</a></li>
<li><a href="../de445608/index.html">Spielende: Analysten berichten von einem Anstieg der Anzahl von DDoS-Angriffen auf das Spielesegment</a></li>
<li><a href="../de445612/index.html">Clusterspeicher f√ºr kleine Webcluster basierend auf drbd + ocfs2</a></li>
<li><a href="../de445620/index.html">Was macht ein UX-Writer?</a></li>
<li><a href="../de445622/index.html">Neu in Java 12: The Teeing Collector</a></li>
<li><a href="../de445626/index.html">Wie tief ist das Kaninchenloch? CLRium # 5: Garbage Collector</a></li>
<li><a href="../de445632/index.html">Vom Parser des Python-Theaterplakats bis zum Telegrammbot. Teil 2</a></li>
<li><a href="../de445638/index.html">Blindpraktikum im Garage Museum of Modern Art</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>