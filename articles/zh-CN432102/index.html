<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⬛️ ☔️ 🛌🏽 显式JavaScript功能 👷🏻 🧖 ♊️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="当我读到另一篇有关JavaScript语言鲜为人知的功能的文章，并在浏览器控制台中悄悄撒尿一些疯狂的解决方案时，我经常在脑海中说，当然，产品上肯定不是这样！ 毕竟，该语言早已获得了庞大的社区，并且具有令人惊讶的工业发展范围。 如果是这样，那为什么我们经常忘记他被所有人理解并真正促进所有这些具体和“令...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>显式JavaScript功能</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432102/"><p><img src="https://habrastorage.org/webt/f_/vy/_s/f_vy_sw3-w-pyxs4zrpqejzpkq4.jpeg" alt="图片"></p><br><p> 当我读到另一篇有关<strong>JavaScript</strong>语言鲜为人知的功能的文章，并在浏览器控制台中悄悄撒尿一些疯狂的解决方案时，我经常在脑海中说，当然，产品上肯定不是这样！ 毕竟，该语言早已获得了庞大的社区，并且具有令人惊讶的工业发展范围。 如果是这样，那为什么我们经常忘记他被所有人理解并真正促进所有这些具体和“令人难忘”的解释的能力？  <em>使其显而易见！</em> </p><a name="habracut"></a><br><h2 id="rassuzhdeniya-na-temu"> 关于该主题的推理 </h2><br><p>  <em>您可以跳过此纸质狂。</em> </p><br><p>如果说到工业发展，那么在大多数情况下，支持代码的要求比解决企业提出的任务更为重要。 对于许多人来说，这在某些情况下是显而易见的-部分（当然，还发现了罕见的D'Artagnans）。 我们的代码越清晰，进入尘土飞扬的架子的风险就越小，并且我们和我们的继任者会在神经系统中遇到问题。 </p><br><p> 众所周知，JavaScript的灵活性惊人，这既是其最大的优点，也是令人讨厌的诅咒。  JavaScript开发人员的道路漫长且极为有趣：我们逐本书，逐篇文章地学习，并获得独特的经验，但有时它确实是特定于语言的。 该语言的分布最广，同时又有大量累积的和不可食用的非显而易见性，这有助于形成两个阵线：几乎将这种语言偶像化的人，以及将其视为笨拙和摇摆不定的权利低头的人。 </p><br><p> 一切都会好起来的，但是通常这两个阵线的代表都在同一个项目上工作。 通常，所有被接受的做法都是对彼此的代码的误解（不愿意理解甚至忽略）。 实际上， <em>“我有一个Java开发人员，而这不是您的！”</em>  。  Java语言的追随者们自己为火上加油，说： <em>“没有人真正了解JavaScript！”</em> 是的<em>“我可以在js中一行编写它！”</em>  。 我承认我自己闲暇时都在滥用异常编程... </p><br><p> 当您代替边缘人并获得在路障两边与人及其代码打交道的经验时，就会开始感到这个问题。 当所有开发人员不仅在业务线层次上相互了解，而且在实施水平上至少相互了解时，计划会议和其他会议也会更有成效。 臭名昭著的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">低音因素</a>对项目的影响较小，当一个前锋患病时，团队的其他成员都不会轻视纠正<em>.js</em>文件的某些行。 当每个人都有更详细的情况时，在团队内外共享知识的过程将对每个人变得更加透明。 好吧，一切都在同一条脉线上。 </p><br><p> 我不敦促任何人“全杯”或“ T形”（现在怎么说）？但是，如果仅来自JavaScript社区，为什么我们不把这个帷幕抬高一点呢？ 为此，只需使用语言的灵活性而不是炫耀，而是易于理解，就可以使我们的代码更加清晰。 </p><br><h2 id="vzroslenie-i-prinyatie-otvetstvennosti"> 成长并承担责任 </h2><br><p> 就其本身而言，JavaScript早就意识到了它的作用，而不是作为一种用于Internet页面交互和“粘贴”其资源的语言，而是作为一种功能强大且足够的工具来创建完整的跨平台且通常具有高度可伸缩性的应用程序。 </p><br><p> 尽管这种流行度和相关性迅速增长，但这种“最易被误解的编程语言”最初是为网页设计师设计的，它已经投入了很长时间。 在ECMAScript 5.1发行之前的13至14年中，很难回忆起标准中的任何重要更改或了解其发展的方向。 当时，他的社区为语言生态系统的形成做出了巨大贡献：原型，jQuery，MooTools等。 在收到开发者的反馈后，JavaScript进行了重大的错误工作：由于TC39委员会重新设计了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">向</a>规范<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">引入新功能的</a>流程，因此在2015年大声发布了6年的ES6，现在是ECMAScript的年度版本。 </p><br><p> 好吧，当我们的应用程序变得足够大时，由于一种不寻常的方法，用于描述用户类型的原型OOP模型不再合理。 说真的，这是什么？ </p><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Animal</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Call me via new and I will be the constructor ;) */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Rabbit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} Rabbit.prototype = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(Animal.prototype); Rabbit.prototype.constructor = Rabbit;</code> </pre> <br><p> 类没有出现在语言中，但是出现了语法。 这些代码已可供传统的面向类的范例的拥护者使用： </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-comment"><span class="hljs-comment">/* Obviously, the constructor is here! */</span></span> } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rabbit</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{}</code> </pre> <br><p> 现在，要发布的候选<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">者是</a>该类的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">私有字段</a> 。 很难相信，我们早晚会通过下划线命名私有财产的协议而停止彼此开怀大笑。 </p><br><p> 同时，在一种函数是一阶对象且发生常量事件的语言中，这很常见： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> that = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ that.n += <span class="hljs-number"><span class="hljs-number">1</span></span>; }, <span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre> <br><p> 然后开始<em>对此</em>上下文的解释以及JavaScript的闭包，这使第二个外部开发人员感到恐惧。 但是在许多情况下，该语言通过显式使用<em>Function.prototype.bind</em>甚至这样避免了不必要的意外： </p><br><pre> <code class="javascript hljs">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.n += <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre> <br><p> 我们还获得了箭头函数，它们实际上是函数，而不是函数接口（是，Java吗？）。 结合使用一组扩展的数组处理方法，它们还有助于编写通常的声明式支付线： </p><br><pre> <code class="javascript hljs">[<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">-3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] .filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.pow(<span class="hljs-number"><span class="hljs-number">2</span></span>, x)) .reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s, x</span></span></span><span class="hljs-function">) =&gt;</span></span> s + x, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p> 语言正确地认为自己是多范式的。 但是这是一个有关某些函数签名的简单示例： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ping</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">host, count</span></span></span><span class="hljs-function">) </span></span>{ count = count || <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* send ping to host count times */</span></span> }</code> </pre> <br><p> 首先，一个路过的人会问一个问题，即一个函数可能只能接受第一个参数，然后说在这种情况下，到底是什么， <em>count</em>变成布尔值！ 实际上，该函数有两个用途：有<em>计数</em>和无<em>计数</em> 。 但这是完全不明显的：您必须查看实现并理解。 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JSDoc</a>可以提供帮助，但这不是常见的做法。  JavaScript向前发展，不增加对重载的支持，至少对默认参数增加了支持： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ping</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">host, count = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p> 总而言之，JavaScript有很多熟悉的东西：生成器，迭代器， <em>Set</em>集合和<em>Map</em>字典，类型数组，甚至正则表达式也开始令人欣喜。 语言会做所有事情以适合许多事物并变得对所有人友好。 </p><br><h2 id="blagopriyatnyy-put-k-ochevidnomu"> 通往显而易见的有利之路 </h2><br><p> 语言本身当然做得很好，很难与之抗争！ 但是，我们怎么了？ 为什么我们不断提醒全世界JavaScript有所不同？ 让我们看一些广泛使用的技术的例子，并询问它们的适当性。 </p><br><h3 id="privedenie-tipov"> 型铸 </h3><br><p> 是的，JavaScript具有动态弱类型系统，可让您对任何内容执行操作，从而为我们隐式执行转换。 但是通常，显式强制转换对于我们仍然是必需的，并且可以观察到以下内容： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bool = !!(expr); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> numb = +(expr); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> str = <span class="hljs-string"><span class="hljs-string">''</span></span>+(expr);</code> </pre> <br><p> 这些技巧对每个JavaScript开发人员都是众所周知的，它们的动机是因为它们说您可以“快速”将某些东西变成某种东西：这里所说的速度表示简短记录。 它也可以立即将<em>false</em>写入<em>！1</em>吗？ 如果开发人员非常担心可打印字符，那么在他最喜欢的IDE中，您可以轻松配置必要的<em>实时模板</em>或自动完成。 而且，如果-对于已发布代码的大小，那么我们总是通过混淆器来运行它，谁比我们更了解如何对所有这些代码进行非人性化处理。 为什么不呢？ </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bool = <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>(expr); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> numb = <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(expr); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> str = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(expr);</code> </pre> <br><p> 结果是相同的，只有所有人都知道。 </p><br><p> 对于字符串转换，我们有<em>toString</em> ，但是对于数字转换，有一个有趣的<em>valueOf</em> ，它也可以被覆盖。 一个经典示例，将“未启动”引入到木僵器中： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timestamp = +<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>;</code> </pre> <br><p> 但是<em>Date</em>确实有一个已知的<em>getTime</em>方法，让我们使用它： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timestamp = (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>()).getTime();</code> </pre> <br><p> 或现成的功能： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timestamp = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now();</code> </pre> <br><p> 绝对不需要利用隐式类型转换。 </p><br><h3 id="logicheskie-operatory"> 逻辑运算符 </h3><br><p> 要特别注意逻辑运算符AND（&amp;&amp;&amp;）和OR（||），它们在JavaScript中不是很逻辑：它们接受并返回任何类型的值。 我们不会<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">详细讨论</a>逻辑表达式<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">计算器的操作；</a>我们将考虑示例。 先前提供的带有功能的选项： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ping</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">host, count</span></span></span><span class="hljs-function">) </span></span>{ count = count || <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p> 它可能看起来像这样： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ping</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">host, count</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// OR arguments.length? if (typeof count == 'undefined') { count = 5; } /* ... */ }</span></span></code> </pre> <br><p> 这种验证更加熟悉，并且在某些情况下可以帮助避免错误。 </p><br><p> 而是，对于最初选择JavaScript路径的开发人员来说，这似乎很野蛮。 但是对于大多数其他人来说，这段代码确实很疯狂： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> root = (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> self == <span class="hljs-string"><span class="hljs-string">'object'</span></span> &amp;&amp; self.self === self &amp;&amp; self) || (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> global == <span class="hljs-string"><span class="hljs-string">'object'</span></span> &amp;&amp; global.global === global &amp;&amp; global);</code> </pre> <br><p> 是的，它很紧凑，是的，流行的图书馆可以负担得起。 但是，请不要滥用它，因为我们的代码不会被JavaScript的贡献者读取，而是由能够在一定时间内解决业务问题的开发人员读取。 </p><br><p> 这种模式可能完全发生： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> count = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> opts == <span class="hljs-string"><span class="hljs-string">'object'</span></span> &amp;&amp; opts.count || <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><p> 这绝对比通常的三元运算符短，但是在读取此类代码时，您记住的第一件事是所使用操作的优先级。 </p><br><p> 如果我们编写一个谓词函数，并将其传递给相同的<em>Array.prototype.filter</em> ，则将返回值包装在<em>Boolean中</em>是一个很好的基调。 此功能的目的立即变得显而易见，并且在其语言具有“正确的”逻辑运算符的开发人员之间没有任何不协调。 </p><br><h3 id="pobitovye-operacii"> 按位运算 </h3><br><p> 一个使用按位NOT（NOT）检查数组中的元素或字符串中的子字符串是否存在的常见示例，甚至某些教程也提供了该示例： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (~[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>].indexOf(<span class="hljs-number"><span class="hljs-number">1</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'yes'</span></span>); }</code> </pre> <br><p> 这能解决什么问题？ 我们不必检查<em>！== -1</em> ，因为<em>indexOf</em>将获取元素的索引或-1，而代字号将添加1并更改符号。 因此，在索引为-1的情况下，该表达式将变为“ false”。 </p><br><p> 但是可以通过另一种方式避免重复代码：就像每个人一样，将检查放入某些utils-object的单独函数中，而不是将按位运算用于其他目的。 在lodash中有一个<a href="">include</a>函数可以解决这个问题， <del> 搞砸了 </del> 波浪号。 您可以高兴，因为在ECMAScript 2016中， <em>Array.prototype.includes</em>方法已得到<em>修复</em> （行也有一个）。 </p><br><p> 但是就在这里！ 另一个波浪号（以及XOR）用于舍入数字，舍去小数部分： </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(~~<span class="hljs-number"><span class="hljs-number">3.14</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 3 console.log(2.72^0); // 2</span></span></code> </pre> <br><p> 但是出于这些目的有<em>parseInt</em>或<em>Math.floor</em> 。 此处的按位运算对于在控制台中快速键入代码非常方便，因为它们的优先级比其他算法低。 但是，在进行代码审查时，最好不要错过它。 </p><br><h3 id="sintaksis-i-konstrukcii-yazyka"> 语法和语言构造 </h3><br><p> 一些奇怪的做法很难归因于任何特定部分。 例如，他们说括号在调用构造函数时是可选的，并且以下两个表达式相同： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rabbit = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rabbit(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rabbit = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rabbit;</code> </pre> <br><p> 确实是！ 但是为什么要从头开始提出问题？ 并非每种语言都可以拥有这种“功能”。 而且，如果您仍然愿意，那么请就整个项目达成协议。 否则，就会有一种虚假的感觉，即存在一些差异。 </p><br><p> 声明一组变量的情况与此类似。  <em>var</em>和<em>let</em>指令的语法允许您一次声明（和定义）多个变量，以逗号分隔： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> count = <span class="hljs-number"><span class="hljs-number">5</span></span>, host, retry = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre> <br><p> 有人使用换行符来提高可读性，但是无论如何，这种语法在流行语言中并不常见。 没有人会伸出援手，问你是否这样写： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> count = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> retry = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> host;</code> </pre> <br><p> 同样，如果在项目/公司级别就良好风格达成协议，那么就没有问题了。 只是您不必为自己的情绪而结合太多语法。 </p><br><p> 该语言有一些特定的构造，例如IIFE，它使您可以在其定义位置立即调用一个函数。 诀窍是让解析器识别函数表达式，而不是函数声明。 这可以通过许多不同的方式来完成：经典地通过<em>void</em>或任何其他一元运算符将其包装在括号中。 并没有什么奇妙的事情！ 有必要选择唯一的选项，并且不要不需离开它： </p><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }());</code> </pre> <br><p> 无需使用运算符来破解解析器。 当一个新手来到该项目时，我想将其沉浸在应用程序的业务逻辑中，而不是向其提供间谍发现所有这些感叹号和空白的解释。 还有第二个经典括号内的条目， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Crockford</a>对此主题<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">发表</a>了有趣的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">评论</a> 。 </p><br><p>  ES6中类语法的出现并没有常见的访问修饰符。 有时，开发人员想在课堂上撒尿并观察隐私。 这导致科学怪人代码： </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> _name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getName = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _name; } } toString() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Hello, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.getName()}</span></span></span><span class="hljs-string">`</span></span>; } }</code> </pre> <br><p> 也就是说，访问器是在构造函数中为该实例创建的，而隐私是通过它们通过闭包访问局部属性变量来实现的。 该示例看起来甚至与Lacconcino相当，但这是一种完全不可扩展的方法，除非您围绕它构建了文档化的框架解决方案。 先生们，让我们使用可用的类（并等待私有字段的标准化）或流行的模式模块。 在这里创建某种中间混合解决方案对您来说是一件容易的事，因为类不再是类，并且代码是可理解的。 </p><br><p> 总结一下，他将与项目中采用的样式指南，lint的配置或与为项目贡献其非JavaScript组件的同事简单地编写代码片段，分享他的常识。 该语言为每个典型任务提供了几种选择，因此增进彼此之间的理解并陷入共同点并不困难（或几乎没有困难）。 </p><br><h2 id="zloklyuchenie"> 冒险 </h2><br><p> 这个主题肯定是整体的，并且有更多示例，但是本文的主要信息是，您不应滥用JavaScript中的非显而易见性，而这可以避免这种情况。 语言的本质是独特的：它使您既可以编写优雅又富于表现力的（适度的“针对性”）解决方案，并且每个人都可以理解和访问。 我从根本上不同意JavaScript会“惩罚自己”或“被埋在一堆好的意图和错误中”的传统观点。 因为现在大多数的陌生性不是由语言证明的，而是由开发人员的文化和（而不是）对语言的冷漠形成的。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN432102/">https://habr.com/ru/post/zh-CN432102/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN432092/index.html">编写单元测试时出现令人不快的错误</a></li>
<li><a href="../zh-CN432094/index.html">来自OpenGift和Credits区块链平台的联合在线黑客马拉松</a></li>
<li><a href="../zh-CN432096/index.html">完整的CMake指南。 第二部分：构建系统</a></li>
<li><a href="../zh-CN432098/index.html">道路运输中的自动驾驶仪，如何与特价商品进行交互。 通过运输？</a></li>
<li><a href="../zh-CN432100/index.html">我们如何改善帐单转换</a></li>
<li><a href="../zh-CN432104/index.html">12月IT活动摘要（第一部分）</a></li>
<li><a href="../zh-CN432106/index.html">食品设计文摘，2018年11月</a></li>
<li><a href="../zh-CN432108/index.html">Kubernetes的密集注册将于2月1-3日在圣彼得堡开放</a></li>
<li><a href="../zh-CN432110/index.html">设计师的Web技术-偿还债务</a></li>
<li><a href="../zh-CN432112/index.html">英特尔XMM 8160-通用多模式5G调制解调器</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>