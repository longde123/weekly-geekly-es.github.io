<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõµ üë©‚Äçüë©‚Äçüëß‚Äçüë¶ üë®üèº‚Äçüè≠ Como transformar imagens de sat√©lite em mapas. Vis√£o computacional em Yandex üï∫üèæ üïµüèæ üëΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Uma das principais fontes de dados do servi√ßo Yandex.Maps √© a imagem de sat√©lite. Para facilitar o trabalho com o mapa, os objetos s√£o marcados com po...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como transformar imagens de sat√©lite em mapas. Vis√£o computacional em Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/431108/">  Uma das principais fontes de dados do servi√ßo Yandex.Maps √© a imagem de sat√©lite.  Para facilitar o trabalho com o mapa, os objetos s√£o marcados com pol√≠gonos nas imagens: florestas, lagoas, ruas, casas, etc. Geralmente, os cart√≥grafos est√£o envolvidos na marca√ß√£o.  Decidimos ajud√°-los e ensinar o computador a adicionar pol√≠gonos de casas sem a participa√ß√£o de pessoas. <br><br>  Para opera√ß√µes com imagens, o campo de TI se chama vis√£o de computador.  Nos √∫ltimos anos, a maioria das tarefas nessa √°rea foi resolvida com muito sucesso usando redes neurais.  Hoje contaremos aos leitores de Habr sobre nossa experi√™ncia no uso de redes neurais no mapeamento. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rn/xz/e2/rnxze2-1b6bobojodppliybmehe.jpeg"></div><a name="habracut"></a><br>  Primeiro, treinaremos uma grade neural que se envolver√° na segmenta√ß√£o sem√¢ntica, ou seja, determinar√° se cada ponto na imagem de sat√©lite est√° relacionado √† casa.  Por que a segmenta√ß√£o sem√¢ntica e n√£o apenas a detec√ß√£o de objetos?  Quando o problema de detec√ß√£o for resolvido, obteremos na sa√≠da um conjunto de ret√¢ngulos, al√©m de espec√≠ficos: dois lados s√£o verticais, dois s√£o horizontais.  E as casas geralmente s√£o giradas em rela√ß√£o aos eixos da imagem, e alguns edif√≠cios tamb√©m t√™m uma forma complexa. <br><br>  A tarefa de segmenta√ß√£o sem√¢ntica agora est√° sendo resolvida por v√°rias redes ( <a href="">FCN</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SegNet</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">UNet</a> , etc.).  Voc√™ s√≥ precisa escolher qual √© o melhor para n√≥s. <br><br>  Depois de receber a m√°scara da imagem de sat√©lite, selecionamos grupos de pontos grandes o suficiente pertencentes √†s casas, os coletamos em √°reas conectadas e apresentamos os limites das √°reas em forma de vetor na forma de pol√≠gonos. <br><br>  √â claro que a m√°scara n√£o ser√° absolutamente precisa, o que significa que casas pr√≥ximas podem se unir em uma √°rea conectada.  Para lidar com esse problema, decidimos treinar ainda mais a rede.  Ela encontrar√° na imagem as costelas (os limites das casas) e separar√° os pr√©dios que est√£o colados. <br><br>  Ent√£o, esse esquema apareceu: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7z/dw/lt/7zdwlt1z0orhy2i9fhkgifjwkcw.jpeg"></div><br>  N√£o descartamos completamente as redes de detec√ß√£o e tentamos o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mask R-CNN</a> .  Sua vantagem em compara√ß√£o com a segmenta√ß√£o usual √© que o Mask R-CNN detecta objetos e gera uma m√°scara, portanto, n√£o h√° necessidade de mexer na divis√£o da m√°scara comum em √°reas conectadas.  Bem, menos (como sem ele) na resolu√ß√£o fixa da m√°scara de cada objeto, ou seja, para casas grandes com uma borda complexa, essa borda obviamente se tornar√° simplificada. <br><br><h2>  As ferramentas </h2><br>  Ent√£o foi necess√°rio decidir sobre as ferramentas.  Tudo era bem √≥bvio aqui: o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">OpenCV</a> √© mais adequado para tarefas de vis√£o computacional.  A escolha de redes neurais √© um pouco mais ampla.  N√≥s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">decidimos</a> pelo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tensorflow</a> .  Suas vantagens: <br><br><ul><li>  um conjunto bastante desenvolvido de "cubos" prontos a partir dos quais voc√™ pode montar suas redes; </li><li>  API Python, conveniente para criar rapidamente uma estrutura de rede e para treinamento; </li><li>  Uma rede treinada pode ser usada em seu programa por meio de uma interface C ++ (muito ruim em compara√ß√£o com a parte Python, mas suficiente para executar redes prontas). </li></ul><br>  Para treinamento e outra computa√ß√£o pesada, planejamos usar o Nirvana - a maravilhosa plataforma Yandex da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">qual j√° falamos</a> . <br><br><h2>  Datacet </h2><br>  Oitenta por cento de sucesso no trabalho com uma rede neural consiste em um bom conjunto de dados.  Portanto, para iniciantes, dever√≠amos ter reunido esse conjunto de dados.  O Yandex possui um grande n√∫mero de imagens de sat√©lite com objetos j√° marcados.  Tudo parece ser simples: basta fazer o upload desses dados e colet√°-los em um conjunto de dados.  No entanto, h√° uma ressalva. <br><br><h3>  Refinar o conjunto de dados </h3><br>  Quando uma pessoa procura uma casa em uma imagem de sat√©lite, a primeira coisa que v√™ √© o telhado.  Mas a altura das casas varia, o sat√©lite pode tomar o mesmo terreno de diferentes √¢ngulos - e se colocarmos um pol√≠gono correspondente ao telhado no mapa vetorial, n√£o h√° garantia de que o telhado n√£o saia quando a imagem for atualizada.  Mas a funda√ß√£o √© cavada no ch√£o e, de qualquer √¢ngulo que voc√™ a retire, o tempo todo permanece em um s√≥ lugar.  √â por isso que as casas no vetor Yandex.Map est√£o marcadas "nas funda√ß√µes".  Isso est√° correto, mas para a tarefa de segmentar imagens, √© melhor ensinar a rede a procurar telhados: a esperan√ßa de que a rede seja treinada para reconhecer as funda√ß√µes √© muito pequena.  Portanto, no conjunto de dados, tudo deve ser marcado nos telhados.  Portanto, para criar um bom conjunto de dados, precisamos aprender como mudar o layout vetorial das casas das funda√ß√µes para os telhados. <br><br>  <i>Tentamos n√£o mudar, mas a qualidade n√£o era muito boa, e isso √© compreens√≠vel: os √¢ngulos de disparo do sat√©lite s√£o diferentes, as alturas das casas s√£o diferentes, como resultado, nas fotografias, a funda√ß√£o foi deslocada em diferentes dire√ß√µes e em diferentes dist√¢ncias do telhado.</i>  <i>A rede se perde dessa variedade e, na melhor das hip√≥teses, treina para algo intermedi√°rio, na pior das hip√≥teses - para algo incompreens√≠vel.</i>  <i>Al√©m disso, a rede de segmenta√ß√£o sem√¢ntica produz um resultado semelhante a algo aceit√°vel, mas ao procurar arestas, a qualidade diminui drasticamente.</i> <br><br><h4>  Abordagem raster </h4><br>  Desde que entramos no campo da vis√£o computacional, a primeira coisa que fizemos foi tentar uma abordagem relevante para essa mesma vis√£o computacional.  Primeiro, o mapa vetorial √© rasterizado (os pol√≠gonos das casas s√£o desenhados com linhas brancas sobre fundo preto), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o filtro Sobel</a> seleciona as bordas da imagem de sat√©lite.  E ent√£o h√° um deslocamento de duas imagens uma em rela√ß√£o √† outra, o que maximiza a correla√ß√£o entre elas.  As arestas ap√≥s o filtro Sobel s√£o bastante barulhentas, portanto, se essa abordagem √© aplicada a um edif√≠cio, nem sempre um resultado aceit√°vel √© obtido.  No entanto, o m√©todo funciona bem em territ√≥rios com edif√≠cios da mesma altura: se voc√™ procurar um deslocamento imediatamente em uma grande √°rea da imagem, o resultado ser√° mais est√°vel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7q/re/nq/7qrenqshfovrbc1y84j0y_5q7do.jpeg"></div><br><h4>  Abordagem "geom√©trica" </h4><br>  Se o territ√≥rio for constru√≠do n√£o com o mesmo tipo, mas com v√°rias casas, o m√©todo anterior n√£o funcionar√°.  Felizmente, √†s vezes sabemos a altura dos pr√©dios no mapa vetorial Yandex e a posi√ß√£o do sat√©lite durante as filmagens.  Assim, podemos usar o conhecimento escolar de geometria e calcular onde e a que dist√¢ncia o telhado se mover√° em rela√ß√£o √† funda√ß√£o.  Este m√©todo melhorou o conjunto de dados em √°reas com arranha-c√©us. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/in/v3/wp/inv3wppmsi5dhhk5jcbmiwymqas.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yq/kj/_h/yqkj_h0okr891jlbdoaljqfhfsu.jpeg"></div><br><h4>  Abordagem "manual" </h4><br>  A maneira mais demorada: arregace as mangas, descubra o mouse, olhe fixamente para o monitor e mude manualmente o layout vetorial das casas das funda√ß√µes para os telhados.  A t√©cnica traz um resultado que √© simplesmente incr√≠vel em termos de qualidade, mas n√£o √© recomend√°vel us√°-lo em grandes quantidades: os desenvolvedores envolvidos nessas tarefas rapidamente caem em apatia e perdem o interesse pela vida. <br><br><h4>  Rede neural </h4><br>  No final, conseguimos imagens de sat√©lite suficientes, bem marcadas nos telhados.  Portanto, houve uma chance de treinar a rede neural (por enquanto, n√£o para segmenta√ß√£o, mas para melhorar o layout de outras imagens de sat√©lite).  E n√≥s fizemos isso. <br><br>  Os dados de entrada da rede neural convolucional eram uma imagem de sat√©lite e marcavam rasterizadas.  Na sa√≠da, recebemos um vetor bidimensional: deslocamentos verticais e horizontais. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ad/qy/i9/adqyi95ityf_cueqvd-f2krrknk.png"></div><br>  Com a ajuda de uma rede neural, encontramos o deslocamento necess√°rio, o que nos permitiu obter bons resultados em edif√≠cios para os quais a altura n√£o √© indicada.  Como resultado, reduzimos significativamente a corre√ß√£o manual da marca√ß√£o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/s6/tj/v1/s6tjv13fffnmhkxrs7etzhiv1g0.jpeg"></div><br><h3>  Territ√≥rios diferentes - casas diferentes </h3><br>  Existem muitos territ√≥rios e estados interessantes no Yandex.Maps.  Mas, mesmo na R√∫ssia, as casas s√£o extremamente diversas, o que afeta a apar√™ncia das imagens de sat√©lite.  Portanto, voc√™ precisa refletir a diversidade no conjunto de dados.  E, inicialmente, n√£o entendemos realmente como lidar com todo esse esplendor.  Colete um grande conjunto de dados e treine uma rede nele?  Crie seu pr√≥prio conjunto de dados para cada tipo (condicional) de desenvolvimento e treine uma rede separada?  Treinar uma determinada rede principal e trein√°-la para um tipo espec√≠fico de desenvolvimento? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ny/pa/fd/nypafdcjqd3vny1_uqpujrfn0ci.jpeg"></div><br>  Empiricamente, descobrimos que: <br><br><ol><li>  Sem d√∫vida, √© necess√°rio expandir o conjunto de dados para diferentes tipos de edif√≠cios nos quais est√° planejado usar a ferramenta.  Uma rede treinada em um tipo √© capaz de distinguir edif√≠cios de outro tipo, embora muito mal. </li><li>  √â melhor treinar uma rede grande em todo o conjunto de dados.  Generaliza bastante bem para v√°rios territ√≥rios.  Se voc√™ treinar redes separadas para cada tipo de desenvolvimento, a qualidade permanecer√° a mesma ou apenas melhorar√°.  Portanto, n√£o faz sentido implementar redes diferentes para diferentes territ√≥rios.  Al√©m disso, isso requer mais dados e um classificador adicional do tipo de desenvolvimento. </li><li>  Se voc√™ usar redes antigas ao adicionar novos territ√≥rios aos dados, as redes aprender√£o muito mais rapidamente.  A reciclagem de redes antigas em dados estendidos leva a aproximadamente o mesmo resultado que o treinamento de uma rede a partir do zero, mas requer muito menos tempo. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vk/_v/zq/vk_vzq0fxfhcjlusrbqjjqhnfre.jpeg"></div><br><h2>  Op√ß√µes de solu√ß√£o </h2><br><h3>  Segmenta√ß√£o sem√¢ntica </h3><br>  A segmenta√ß√£o sem√¢ntica √© uma tarefa bastante bem pesquisada.  Ap√≥s o aparecimento do artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Redes totalmente convolucionais</a> , ele √© resolvido principalmente usando redes neurais.  Resta apenas escolher uma rede (consideramos <a href="">FCN</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SegNet</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">UNet</a> ), pensar se precisamos de truques adicionais como CRF na sa√≠da e determinar como e com que fun√ß√£o de erro o treinamento ser√° treinado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/un/ay/gn/unaygnyzsdhk_2dbk4qq2-2m340.png"></div><br>  Como resultado, adotamos uma arquitetura do tipo U-Net com uma fun√ß√£o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Intersec√ß√£o sobre uni√£o generalizada</a> como uma fun√ß√£o de erro.  Para o treinamento, cortamos imagens de sat√©lite e suas marca√ß√µes correspondentes (√© claro, rasterizadas) em quadrados e montadas em conjuntos de dados.  Acabou bem legal, e √†s vezes muito bem. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z1/rv/ub/z1rvubhjv5xcruynmvarimca3zy.jpeg"></div><br>  Em territ√≥rios com edif√≠cios √∫nicos, a segmenta√ß√£o sem√¢ntica era suficiente para passar para o pr√≥ximo est√°gio - a vetoriza√ß√£o.  Onde o pr√©dio √© denso, as casas √†s vezes ficam presas em uma √°rea coesa.  Demorou para separ√°-los. <br><br><h3>  Detec√ß√£o de borda </h3><br>  Para lidar com esta tarefa, voc√™ pode encontrar as bordas da imagem.  Para detectar arestas, tamb√©m decidimos treinar a rede (algoritmos de busca de arestas que n√£o usam redes neurais s√£o claramente coisa do passado).  Treina uma rede do tipo HED, descrita em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Detec√ß√£o de Borda Aninhada Holisticamente</a> .  No artigo original, a rede foi treinada no conjunto de dados BSDS-500, no qual todas as bordas est√£o marcadas nas imagens.  Uma rede treinada encontra todas as arestas pronunciadas: os limites de casas, estradas, lagos etc. Isso j√° √© suficiente para separar os pr√©dios pr√≥ximos.  Mas decidimos ir al√©m e usar o mesmo conjunto de dados para treinamento e para segmenta√ß√£o sem√¢ntica, mas ao rasterizar, n√£o pinte os pol√≠gonos inteiros dos edif√≠cios, mas apenas trave seus limites. <br><br>  O resultado foi t√£o impressionante que decidimos vetorizar os edif√≠cios diretamente pelas bordas recebidas da rede.  E aconteceu bastante. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/am/uz/h-/amuzh-xo7mzssz9jtzkppm3_nag.jpeg"></div><br><h3>  Detec√ß√£o de v√©rtices </h3><br>  Como uma rede como o HED deu um excelente resultado nas arestas, decidimos trein√°-la para detectar v√©rtices.  De fato, temos uma rede com pesos gerais em camadas convolucionais.  Ela tinha duas sa√≠das ao mesmo tempo: para bordas e picos.  Como resultado, fizemos outra vers√£o da vetoriza√ß√£o dos edif√≠cios e, em alguns casos, apresentou resultados bastante s√£os. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fj/50/wl/fj50wlerknjc02f8cnhgguizu2o.jpeg"></div><br><h3>  M√°scara r-cnn </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O Mask R-CNN</a> √© uma expans√£o relativamente nova de redes como o Faster R-CNN.  M√°scara O R-CNN procura objetos e seleciona uma m√°scara para cada um deles.  Como resultado, para casas, obtemos n√£o apenas ret√¢ngulos delimitadores, mas tamb√©m uma estrutura refinada.  Essa abordagem se compara favoravelmente com a detec√ß√£o simples (n√£o sabemos como o edif√≠cio est√° localizado dentro do ret√¢ngulo) e a segmenta√ß√£o normal (v√°rias casas podem se unir em uma, e n√£o est√° claro como separ√°-las).  Com o Mask R-CNN, voc√™ n√£o precisa mais pensar em truques adicionais: basta vetorizar a borda da m√°scara para cada objeto e obter o resultado imediatamente.  H√° tamb√©m um sinal de menos: o tamanho da m√°scara para o objeto √© sempre fixo, ou seja, para edif√≠cios grandes, a precis√£o do layout de pixels ser√° baixa.  O resultado do Mask R-CNN √© assim: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/it/8v/4w/it8v4wy0axix-hpi2gfxkomo3nk.jpeg"></div><br>  Tentamos o Mask R-CNN por √∫ltimo e garantimos que, para alguns tipos de edif√≠cios, essa abordagem supere outras. <br><br><h2>  Vetoriza√ß√£o </h2><br><h3>  Vetoriza√ß√£o de ret√¢ngulos </h3><br>  Com toda a diversidade arquitet√¥nica moderna, casas em imagens de sat√©lite ainda mais parecem ret√¢ngulos.  Al√©m disso, para a massa de territ√≥rios, a marca√ß√£o com pol√≠gonos complexos n√£o √© necess√°ria.  Mas ainda quero que as casas no mapa sejam marcadas.  (Bem, por exemplo, uma parceria hort√≠cola: geralmente h√° muitas casas l√°, marcar manualmente n√£o √© t√£o importante, mas marcar com ret√¢ngulos no mapa √© muito bom.) Portanto, a primeira abordagem √† vetoriza√ß√£o foi extremamente simples. <br><br><ol><li>  Pegue a regi√£o raster correspondente √† "casa". </li><li>  Localize o ret√¢ngulo da √°rea m√≠nima que cont√©m essa √°rea (por exemplo, assim: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">OpenCV :: minAreaRect</a> ).  O problema est√° resolvido. </li></ol><br>  √â claro que a qualidade dessa abordagem est√° longe de ser ideal.  No entanto, o algoritmo √© bastante simples e, em muitos casos, est√° funcionando. <br><br><h3>  Vetoriza√ß√£o de pol√≠gonos </h3><br>  Se a qualidade da segmenta√ß√£o for boa o suficiente, voc√™ poder√° recriar com mais precis√£o o contorno da casa.  Na maioria dos edif√≠cios de formas complexas, os √¢ngulos s√£o geralmente corretos, por isso decidimos reduzir o problema √† tarefa de construir um pol√≠gono com lados ortogonais.  Para resolv√™-lo, queremos atingir dois objetivos ao mesmo tempo: encontrar o pol√≠gono mais simples e repetir a forma dos edif√≠cios com a maior precis√£o poss√≠vel.  Esses objetivos conflitam entre si; portanto, √© necess√°rio introduzir condi√ß√µes adicionais: limitar o comprimento m√≠nimo das paredes, o desvio m√°ximo da regi√£o de varredura etc. <br><br>  O algoritmo que nos ocorreu pela primeira vez foi baseado na constru√ß√£o da proje√ß√£o de pontos em linhas retas: <br><br><ol><li>  Encontre o contorno da regi√£o raster correspondente a uma casa. </li><li>  Reduza o n√∫mero de pontos no circuito, simplificando-o, por exemplo, com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o algoritmo Douglas-Pecker</a> . </li><li>  Encontre o lado mais longo no contorno.  √â o seu √¢ngulo de inclina√ß√£o que determinar√° o √¢ngulo de todo o futuro pol√≠gono ortogonal. </li><li>  Construa uma proje√ß√£o do pr√≥ximo ponto de contorno para o lado anterior. </li><li>  Estenda o lado para o ponto de proje√ß√£o.  Se a dist√¢ncia do ponto at√© a proje√ß√£o for maior que a parede mais curta do edif√≠cio, adicione o segmento resultante ao contorno do edif√≠cio. </li><li>  Repita as etapas 4 e 5 at√© o circuito fechar. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ey/ok/y5/eyoky5b1d4ayzcflogdwsxfyi8g.png"></div><br>  Esse algoritmo √© extremamente simples e traz resultados rapidamente, mas ainda assim o contorno do edif√≠cio √†s vezes acaba sendo bastante barulhento.  Tentando lidar com esse problema, encontramos uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">solu√ß√£o</a> bastante interessante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">para o</a> problema, que usa uma grade quadrada no espa√ßo para aproximar o pol√≠gono.  Resumidamente, o algoritmo consiste em tr√™s a√ß√µes: <br><br><ol><li>  Crie uma grade quadrada no espa√ßo centralizado em zero. </li><li>  Em pontos da grade localizados a uma dist√¢ncia maior do contorno original, construa pol√≠gonos diferentes. </li><li>  Selecione um pol√≠gono com um n√∫mero m√≠nimo de v√©rtices. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5f/em/ti/5femtieuuectay9wjhoncxi2rh4.png"></div><br>  Como o √¢ngulo de rota√ß√£o necess√°rio da grade n√£o √© conhecido antecipadamente, √© necess√°rio classificar v√°rios valores, o que afeta mal o desempenho.  No entanto, o algoritmo permite alcan√ßar resultados visualmente mais bonitos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yz/rb/u1/yzrbu1in149ocfxxmdv_h6gctug.jpeg"></div><br><h2>  Melhoria da vetoriza√ß√£o </h2><br>  Enquanto n√≥s trabalhamos com cada casa separadamente.  Quando a primeira etapa estiver conclu√≠da, voc√™ j√° poder√° trabalhar com a imagem como um todo e melhorar o resultado.  Para isso, foi adicionado um algoritmo para p√≥s-processamento de um conjunto de pol√≠gonos.  Usamos as seguintes heur√≠sticas: <br><br><ul><li>  Geralmente as paredes das casas adjacentes s√£o paralelas.  Al√©m disso: na maioria das vezes, as casas podem ser combinadas em conjuntos, dentro dos quais todos os elementos est√£o alinhados. </li><li>  Se as ruas j√° estiverem marcadas na imagem, √© muito prov√°vel que os lados dos pol√≠gonos sejam paralelos √†s ruas. </li><li>  Se os pol√≠gonos se cruzarem, √© mais prov√°vel que fa√ßa sentido mover as paredes para que a interse√ß√£o desapare√ßa. </li></ul><br>  Como resultado, o seguinte algoritmo apareceu: <br><br><ol><li>  Agrupamos as casas encontradas pela dist√¢ncia entre elas e pelo √¢ngulo de rota√ß√£o.  Calculamos a m√©dia das voltas dos edif√≠cios em cada cluster.  Repetimos at√© que a posi√ß√£o dos edif√≠cios deixe de mudar ou at√© que as casas comecem a se desviar muito da posi√ß√£o inicial. </li><li>  Escolhemos casas pr√≥ximas √†s estradas, encontramos as mais longas e pr√≥ximas da beira da estrada.  Transformamos a casa no paralelismo do lado selecionado e da estrada. </li><li>  Removemos as interse√ß√µes entre os pol√≠gonos, deslocando os lados de dois edif√≠cios que se cruzam na propor√ß√£o do tamanho dos lados. </li></ol><br><h2>  Resultado </h2><br>  Como resultado, obtivemos uma ferramenta que pode reconhecer edif√≠cios de v√°rios tipos de edif√≠cios.  Ajuda os cart√≥grafos em seu trabalho √°rduo: acelera significativamente a busca por casas desaparecidas e o preenchimento de novas √°reas ainda n√£o cultivadas.  Atualmente, mais de 800 mil novos objetos foram adicionados ao Mapa do Povo usando essa ferramenta. <br><br>  Abaixo voc√™ ver√° alguns exemplos de reconhecimento. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bn/pk/o0/bnpko0puk1vcvnd1oxanqo7pvty.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nr/qi/q5/nrqiq5mdh2wl8fjaqmr28sn0oys.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xz/3a/iw/xz3aiwhlc_g1lo_huyb8yml_6ms.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rn/xz/e2/rnxze2-1b6bobojodppliybmehe.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jm/_j/cv/jm_jcvdv8pxm60tlwmoj2hmcgjc.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9x/k_/u3/9xk_u3nlc82ymdbtht8ebtbx6ue.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mw/zk/8g/mwzk8g2ga_798vg986flckxculo.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ue/37/gu/ue37gu16xwfvt3zqh0akmtmxnyi.jpeg"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt431108/">https://habr.com/ru/post/pt431108/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt431096/index.html">Como criar um produto de bot de bate-papo</a></li>
<li><a href="../pt431098/index.html">Mesmo um inc√™ndio n√£o √© um obst√°culo ou o Zimbra Speed ‚Äã‚ÄãRecovery ap√≥s um desastre</a></li>
<li><a href="../pt431102/index.html">Como o endere√ßo f√≠sico √© exibido nas cadeias e bancos de DRAM</a></li>
<li><a href="../pt431104/index.html">Como desenvolvemos a Neoflex Expertise em DevOps</a></li>
<li><a href="../pt431106/index.html">Quanto dinheiro os americanos gastaram nesta sexta-feira negra e o que os smartphones t√™m a ver com isso?</a></li>
<li><a href="../pt431110/index.html">Pare de alimentar os editores. A UE est√° desenvolvendo regras para o livre acesso obrigat√≥rio √† pesquisa</a></li>
<li><a href="../pt431112/index.html">Como usar m√©todos de m√≠nimos quadrados para avaliar recursos e monitorar bancos de dados Oracle</a></li>
<li><a href="../pt431116/index.html">Quero estranho: an√°lise da pr√≥xima confer√™ncia DartUP em S√£o Petersburgo</a></li>
<li><a href="../pt431118/index.html">Toda a verdade sobre o RTOS. Artigo 22. Caixas de correio: servi√ßos auxiliares e estruturas de dados</a></li>
<li><a href="../pt431120/index.html">Sofrer no trabalho n√£o √© necess√°rio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>