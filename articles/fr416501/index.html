<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔃 ♎️ 👨🏿‍💼 Écrivez-moi un serveur GraphQL en C # 🈹 👩🏻‍🤝‍👨🏽 👨🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="D'une manière ou d'une autre, j'ai eu quelques jours de congé et j'ai dessiné le serveur GraphQL sur notre plate-forme Docsvision. Ci-dessous, je vais...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Écrivez-moi un serveur GraphQL en C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/docsvision/blog/416501/"><p>  D'une manière ou d'une autre, j'ai eu quelques jours de congé et j'ai dessiné le serveur GraphQL sur notre plate-forme Docsvision.  Ci-dessous, je vais vous dire comment cela s'est passé. </p><br><p><img src="https://habrastorage.org/webt/ol/gu/2p/olgu2pfxvycejlhj4z_o5o0q9ru.jpeg" alt="Affiche - à la demande"></p><a name="habracut"></a><br><h4 id="chto-za-platforma-docsvision">  Qu'est-ce que la plateforme Docsvision </h4><br><p> La plate-forme Docsvision comprend de nombreux outils différents pour créer des systèmes de workflow, mais son composant clé est quelque chose comme ORM.  Il existe un éditeur de métadonnées dans lequel vous pouvez décrire la structure des champs de la carte.  Il peut y avoir des sections structurelles, de collection et d'arbre, qui, de plus, peuvent être imbriquées, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">en général, tout est compliqué</a> .  Une base de données est générée par des métadonnées, puis vous pouvez l'utiliser avec une API C #.  En un mot - une option idéale pour construire un serveur GraphQL. </p><br><h4 id="kakie-est-varianty">  Quelles sont les options </h4><br><p>  Honnêtement, il n'y a pas beaucoup d'options et elles sont telles.  J'ai réussi à trouver seulement deux bibliothèques: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">graphql-dotnet</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">graphql-net</a> </li></ul><br><p>  UPD: dans les commentaires, ils ont suggéré qu'il y avait encore <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hotchocolate</a> . </p><br><p>  Sur README, au début, j'ai aimé le second, et j'ai même commencé à faire quelque chose avec.  Mais il a rapidement découvert que son API était trop pauvre et qu'elle ne pouvait pas faire face à la tâche de générer un schéma de métadonnées.  Cependant, il semble déjà avoir été abandonné (le dernier commit il y a un an). </p><br><p> L'API <code>graphql-dotnet</code> est assez flexible, mais en même temps, elle est terriblement documentée, déroutante et peu intuitive.  Pour comprendre comment travailler avec, j'ai dû regarder le code source ... Vrai, j'ai travaillé avec la version <code>0.16</code> , alors que la dernière est <code>0.17.3</code> , et 7 versions beta <code>2.0</code> ont déjà été publiées.  Je suis donc désolé si le matériel est un peu dépassé. </p><br><p>  Je dois également mentionner que les bibliothèques sont livrées avec des assemblages non signés.  J'ai dû les reconstruire manuellement à partir de la source afin de les utiliser dans notre application ASP.NET avec des assemblys signés. </p><br><h4 id="struktura-graphql-servera">  Structure du serveur GraphQL </h4><br><p>  Si vous n'êtes pas familier avec GraphQL, vous pouvez essayer l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">explorateur github</a> .  Un petit secret - vous pouvez appuyer sur Ctrl + espace pour obtenir l'auto-complétion.  La partie client n'y est rien de plus que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GraphiQL</a> , qui peut être facilement vissé sur votre serveur.  Prenez simplement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">index.html</a> , ajoutez des scripts à partir du package npm et changez l'url dans la fonction graphQLFetcher à l'adresse de votre serveur - c'est tout, vous pouvez jouer. </p><br><p>  Considérez une requête simple: </p><br><pre> <code class="hljs pgsql">query { viewer { <span class="hljs-keyword"><span class="hljs-keyword">login</span></span>, company } }</code> </pre> <br><p>  Ici, nous voyons un ensemble de champs - visionneuse, connexion, entreprise.  Notre tâche, comme le backend GraphQL, est de construire sur le serveur un "schéma" dans lequel tous ces champs seront traités.  En fait, il suffit de créer la structure appropriée des objets de service avec la description des champs et de définir des fonctions de rappel pour le calcul des valeurs. </p><br><p>  Le schéma peut être généré automatiquement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur la base des classes C #</a> , mais nous passerons par le hardcore - nous ferons tout avec nos mains.  Mais ce n'est pas parce que je suis un gars fringant, la simple génération d'un schéma basé sur les métadonnées est un script non standard dans graphql-dotnet qui n'est pas pris en charge par la documentation officielle.  Donc, nous creusons un peu dans son intestin, dans une zone non documentée. </p><br><p>  Après avoir créé le schéma, il nous reste à livrer la chaîne de requête (et les paramètres) du client au serveur de toute manière pratique (peu importe comment GET, POST, SignalR, TCP ...), et à alimenter son moteur avec le schéma.  Le moteur crachera un objet avec un résultat que nous transformerons en JSON et le retournerons au client.  Ça ressemblait à ça pour moi: </p><br><pre> <code class="hljs pgsql"> //  ,        var schema = GraphQlService.GetCardsSchema(sessionContext); //    (  ) var executer = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> DocumentExecuter(); //   ,  var dict = await executer.ExecuteAsync(<span class="hljs-keyword"><span class="hljs-keyword">schema</span></span>, sessionContext, request.Query, request.MethodName).ConfigureAwait(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); // -   :) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dict.Errors != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; dict.Errors.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> InvalidOperationException(dict.Errors.First().Message); } //    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">Json</span></span>(dict.Data);</code> </pre> <br><p>  Vous pouvez prêter attention à <code>sessionContext</code> .  Il s'agit de notre objet spécifique à Docsvision à travers lequel la plateforme est accessible.  Lors de la création d'un schéma, nous travaillons toujours avec un contexte particulier, mais plus à ce sujet plus tard. </p><br><h4 id="generaciya-shemy">  Génération de circuits </h4><br><p>  Tout commence de manière touchante: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Schema</span></span> schema = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Schema</span></span>();</code> </pre> <br><p>  Malheureusement, c'est là que se termine le code simple.  Pour ajouter un champ au schéma, nous avons besoin de: </p><br><ol><li>  Décrivez son type - créez un objet ObjectGraphType, StringGraphType, BooleanGraphType, IdGraphType, IntGraphType, DateGraphType ou FloatGraphType. </li><li>  Décrivez le champ lui-même (nom, gestionnaire) - créez un objet GraphQL.Types.FieldType </li></ol><br><p>  Essayons de décrire cette simple demande que j'ai citée ci-dessus.  Dans la demande, nous avons un visualiseur de champ.  Pour l'ajouter à une requête, vous devez d'abord décrire son type.  Son type est simple - un objet, avec deux champs de chaîne - login et company.  Nous décrivons le champ de connexion: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loginField = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GraphQL.Types.FieldType(); loginField.Name = <span class="hljs-string"><span class="hljs-string">"login"</span></span>; loginField.ResolvedType = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringGraphType(); loginField.Type = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>); loginField.Resolver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyViewerLoginResolver(); <span class="hljs-comment"><span class="hljs-comment">// ... class MyViewerLoginResolver : GraphQL.Resolvers.IFieldResolver { public object Resolve(ResolveFieldContext context) { // ,       -   UserInfo //      viewer return (context.Source as UserInfo).AccountName; } }</span></span></code> </pre> <br><p>  Nous créons l'objet companyField de la même manière - excellent, nous sommes prêts à décrire le type du champ de visualisation. </p><br><pre> <code class="hljs pgsql">ObjectGraphType&lt;UserInfo&gt; viewerType = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ObjectGraphType&lt;UserInfo&gt;(); viewerType.Name = "Viewer"; viewerType.AddField(loginField); viewerType.AddField(companyField);</code> </pre> <br><p>  Il existe un type, maintenant nous pouvons décrire le champ du visualiseur lui-même: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> viewerField = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GraphQL.Types.FieldType(); viewerField.Name = <span class="hljs-string"><span class="hljs-string">"viewer"</span></span>; viewerField.ResolvedType = viewerType; viewerField.Type = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(UserInfo); viewerField.Resolver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyViewerResolver(); <span class="hljs-comment"><span class="hljs-comment">// ... class MyViewerResolver : GraphQL.Resolvers.IFieldResolver { public object Resolve(ResolveFieldContext context) { //     sessionContext   ? // ,         (login  company) return (context.Source as SessionContext).UserInfo; } }</span></span></code> </pre> <br><p>  Eh bien, et la touche finale, ajoutez notre champ au type de requête: </p><br><pre> <code class="hljs erlang">var <span class="hljs-keyword"><span class="hljs-keyword">query</span></span>Type = new ObjectGraphType(); <span class="hljs-keyword"><span class="hljs-keyword">query</span></span>Type.AddField(viewerField); schema.Query = <span class="hljs-keyword"><span class="hljs-keyword">query</span></span>Type;</code> </pre> <br><p>  C'est tout, notre plan est prêt. </p><br><h4 id="kollekcii-peydzhinaciya-obrabotka-parametrov">  Collections, pagination, traitement des paramètres </h4><br><p>  Si le champ ne renvoie pas un objet, mais une collection, vous devez le spécifier explicitement.  Pour ce faire, enveloppez simplement le type de propriété dans une instance de la classe ListGraphType.  Supposons que si un spectateur retourne une collection, nous écrirons simplement ceci: </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//  ( ) viewerField.ResolvedType = viewerType; //  () viewerField.ResolvedType = new ListGraphType(viewerType);</span></span></code> </pre> <br><p>  En conséquence, dans le résolveur MyViewerResolver, il serait alors nécessaire de renvoyer la liste. </p><br><p>  Lorsque des champs de collecte apparaissent, il est important de prendre soin de la pagination immédiatement.  Il n'y a pas de mécanisme prêt à l'emploi ici, tout se fait à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">travers les paramètres</a> .  Vous pouvez remarquer un exemple d'utilisation du paramètre dans l'exemple ci-dessus (cardDocument a un paramètre id).  Ajoutons un tel paramètre au visualiseur: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idArgument = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QueryArgument(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IdGraphType)); idArgument.Name = <span class="hljs-string"><span class="hljs-string">"id"</span></span>; idArgument.ResolvedType = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IdGraphType(); idArgument.DefaultValue = Guid.Empty; viewerField.Arguments = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QueryArguments(idArgument);</code> </pre> <br><p>  Ensuite, vous pouvez obtenir la valeur du paramètre dans le résolveur comme ceci: </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Resolve</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ResolveFieldContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idArgStr = context.Arguments?[<span class="hljs-string"><span class="hljs-string">"id"</span></span>].ToString() ?? Guid.Empty.ToString(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idArg = Guid.Parse(idArgStr);</code> </pre> <br><p>  GraphQL est si typé que Guid, bien sûr, n'a pas pu analyser.  Et bien, ce n’est pas difficile pour nous. </p><br><h4 id="zapros-kartochek-docsvision">  Demande de carte Docsvision </h4><br><p>  Dans l'implémentation de GrapqhQL pour la plateforme Docsvision, je passe donc simplement par le code de métadonnées ( <code>sessionContext.Session.CardManager.CardTypes</code> ), et pour toutes les cartes et leurs sections, je crée automatiquement ces objets avec les résolveurs correspondants.  Le résultat est quelque chose comme ceci: </p><br><pre> <code class="hljs objectivec">query { cardDocument(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>: <span class="hljs-string"><span class="hljs-string">"{AF652E55-7BCF-E711-8308-54A05079B7BF}"</span></span>) { mainInfo { name instanceID } } }</code> </pre> <br><p>  Ici cardDocument est le type de carte, mainInfo est le nom de la section, nom et instanceID sont les champs de la section.  Les résolveurs correspondants pour la carte, la section et le champ utilisent l'API CardManager comme suit: </p><br><pre> <code class="hljs kotlin"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CardDataResolver</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQL.Resolvers.IFieldResolver { public object Resolve</span></span></span></span>(ResolveFieldContext context) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sessionContext = (context.Source <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> SessionContext); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idArg = Guid.Parse(context.Arguments?[<span class="hljs-string"><span class="hljs-string">"id"</span></span>].ToString() ?? Guid.Empty.ToString()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sessionContext.Session.CardManager.GetCardData(idArg); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SectionResolver</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQL.Resolvers.IFieldResolver { CardSection section; public SectionFieldResolver</span></span></span></span>(CardSection section) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.section = section; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Resolve(ResolveFieldContext context) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idArg = Guid.Parse(context.Arguments?[<span class="hljs-string"><span class="hljs-string">"id"</span></span>].ToString() ?? Guid.Empty.ToString()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> skipArg = (int?)context.Arguments?[<span class="hljs-string"><span class="hljs-string">"skip"</span></span>] ?? <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> takeArg = (int?)context.Arguments?[<span class="hljs-string"><span class="hljs-string">"take"</span></span>] ?? <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sectionData = (context.Source <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> CardData).Sections[section.Id]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> idArg == Guid.Empty ? sectionData.GetAllRows().Skip(skipArg).Take(takeArg) : new List&lt;RowData&gt; { sectionData.GetRow(idArg) }; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RowFieldResolver</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQL.Resolvers.IFieldResolver { Field field; public RowFieldResolver</span></span></span></span>(Field field) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.field = field; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Resolve(ResolveFieldContext context) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (context.Source <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> RowData)[field.Alias]; } }</code> </pre> <br><p>  Bien sûr, ici, vous ne pouvez demander des cartes que par identifiant, mais il est facile de générer un schéma de la même manière pour accéder aux rapports avancés, aux services et à toute autre chose.  Avec cette API, vous pouvez obtenir toutes les données de la base de données Docsvision en écrivant simplement le code JavaScript approprié - c'est très pratique pour écrire vos propres scripts et extensions. </p><br><h4 id="zaklyuchenie">  Conclusion </h4><br><p>  Avec GrapqhQL dans .NET, les choses ne sont pas faciles.  Il existe une bibliothèque quelque peu animée, sans fournisseur fiable et avec un avenir incompréhensible, une API instable et étrange, inconnue quant à son comportement sous charge et à sa stabilité.  Mais nous avons ce que nous avons, cela semble fonctionner, mais les failles dans la documentation et le reste sont compensées par l'ouverture du code source. </p><br><p>  Ce que j'ai décrit dans cet article est une API de plus en plus non documentée, que j'ai explorée en tapant et en étudiant la source.  C'est juste que les auteurs de la bibliothèque ne pensaient pas que quelqu'un aurait besoin de générer le circuit automatiquement - eh bien, que pouvez-vous faire, c'est open source. </p><br><p>  Il a été écrit tout cela pendant le week-end, et à lui seul, jusqu'à présent, pas plus qu'un prototype.  Dans le package Docsvision standard, cela est susceptible d'apparaître, mais quand - c'est encore difficile à dire.  Cependant, si vous aimez l'idée d'accéder à la base de données Docsvision directement à partir de JavaScrpit sans écrire d'extensions de serveur, écrivez.  Plus l'intérêt des partenaires est élevé, plus nous y accorderons d'attention. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr416501/">https://habr.com/ru/post/fr416501/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr416489/index.html">La vie extraterrestre: sur la correction de l'équation de Drake et du grand filtre</a></li>
<li><a href="../fr416491/index.html">Activiti - Moteur de processus métier</a></li>
<li><a href="../fr416493/index.html">Lancer SIIG MiniSys S286</a></li>
<li><a href="../fr416495/index.html">SamsPcbGuide Partie 6: Traçage des lignes de signal. Modèles de perte et de diaphonie</a></li>
<li><a href="../fr416497/index.html">Un exemple de calcul de la réaction du signal à l'aide de la transformée de Fourier dans MATLAB</a></li>
<li><a href="../fr416505/index.html">Nous écrivons une machine virtuelle de pile sur Rust'e</a></li>
<li><a href="../fr416507/index.html">Comment vérifier la fiabilité du centre de données: 3 points principaux auxquels vous devez faire attention</a></li>
<li><a href="../fr416511/index.html">Les erreurs les plus courantes dans votre code React que vous faites (éventuellement)</a></li>
<li><a href="../fr416513/index.html">Le condensé de matériaux intéressants pour le développeur mobile # 260 (2 juillet - 8 juillet)</a></li>
<li><a href="../fr416515/index.html">Articles d'évaluation à ajouter aux favoris</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>