<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤰🏼 🚧 👩🏾‍🎓 Qt：基于矢量图形绘制 🤦🏾 🕴🏿 🐭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Qt为程序员提供了非常丰富的功能，但是小部件的集合是有限的。 如果没有合适的选择，则必须自己绘制一些东西。 最简单的方法-使用现成的图片-存在严重的缺陷：需要将图像存储在文件或资源中，可伸缩性问题以及图像格式的可移植性。 下面描述了矢量图形原理的使用，而不使用实际的矢量图像。 
 前言 


 一切...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Qt：基于矢量图形绘制</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425547/"><p><img src="https://habrastorage.org/webt/kp/7v/oi/kp7voi6ve63y4yxzdtthd-dxs80.png" align="right">  Qt为程序员提供了非常丰富的功能，但是小部件的集合是有限的。 如果没有合适的选择，则必须自己绘制一些东西。 最简单的方法-使用现成的图片-存在严重的缺陷：需要将图像存储在文件或资源中，可伸缩性问题以及图像格式的可移植性。 下面描述了矢量图形原理的使用，而不使用实际的矢量图像。 </p><a name="habracut"></a><br><h2 id="preambula"> 前言 </h2><br><p> 一切始于这样的事实，即一次需要指示一位符号。 某些应用程序在某些端口上接收到一些数据，必须拆开包装并将其显示在屏幕上。 同时以某种方式模仿熟悉的仪表板会很好。 为了显示数字数据，Qt提供了“开箱即用”的QLCDNumber类，类似于熟悉的七段指示器，但是在单个灯中看不到某些东西。 </p><br><p> 为此目的使用标志（它们是复选框）和开关（它们是单选按钮）是不好的，下面列出了原因： </p><br><ul><li> 这在语义上是错误的。 按钮-它们是按钮，用于用户输入，而不是向用户显示任何内容。 </li><li> 这意味着第二点：用户努力在这些按钮上进行戳戳。 如果同时信息更新不是特别快，则指示将隐藏，并且用户将恶作剧地报告程序故障。 </li><li> 如果锁定按钮以按下（setEnabled（false）），则该按钮将变为难看的灰色。 我记得在版本6的Delphi中，耳朵有些假冒：您可以在面板上放置一个标志，并禁用面板的可用性，而不是该标志，然后该标志既不是灰色也不是活动的。 这个技巧在这里不起作用。 </li><li> 这些按钮具有输入焦点。 因此，如果窗口中有输入元素，并且用户使用Tab键沿着它们走动，则他将不得不沿着输出元素走动，这是不便且丑陋的。 </li><li> 最后，这些按钮看上去看上去并不美观，尤其是在七段式按钮旁边。 </li></ul><br><p> 结论：您需要自己画一个灯泡。 </p><br><h2 id="muki-vybora"> 选择的面粉 </h2><br><p> 首先，我寻找现成的解决方案。 在那段时间里，当我使用Delphi时，您可以找到大量的成品零件，这些零件既来自严肃的公司，也来自业余制造商。  Qt对此有很多麻烦。  QWT有一些要素，但并非如此。 我根本没有看到业余爱好。 也许，如果您在Github上正确挖掘，可以找到一些东西，但是我自己可能会做得更快。 </p><br><p> 自制的第一件事是使用两个图像文件，分别打开和关闭灯光图像。 不好： </p><br><ul><li> 有必要找到精美的图片（或绘画，但我不是画家）； </li><li> 原则上的问题是：打结不好，甚至是图片，甚至躺在你的脚下； </li><li> 它们必须存储在某个地方。 文件非常糟糕：意外删除-而且没有按钮。 资源比较好，但是我也觉得不可以。 </li><li> 没有可扩展性； </li><li> 可定制性（例如颜色）只能通过添加文件来实现。 也就是说，资源密集且僵化。 </li></ul><br><p> 从第一件事开始的第二件事是使用矢量图像而不是图片。 而且，Qt可以渲染SVG。 在这里搜索图片本身已经有点容易了：网络中的矢量图形课程很多，您可以找到更多或更少的适合自己的东西并使其适应您的需求。 但是问题仍然在于存储和自定义，并且渲染不是免费的资源。 便士，当然，但仍然... </p><br><p> 第三个是第二个：您可以使用矢量图形原理绘制自绘图像！ 文本格式的矢量图像文件指示绘制内容以及绘制方式。 我可以使用矢量教程指定相同的代码。 幸运的是，QPainter对象具有必要的工具：钢笔，画笔，渐变和绘制图元，甚至还有纹理填充。 是的，工具远非所有：没有遮罩，混合模式，但绝对不需要照片写实。 </p><br><p> 我在网上寻找了一些例子。 他上了第一课：“我们很容易绘制”网站上的“我们在Inkscape图形编辑器中绘制了一个按钮”。 本课中的按钮比按钮更像一个灯泡，非常适合我。 我正在草稿：Qt中的一个项目，而不是Inkscape。 </p><br><h2 id="proba-pera"> 羽毛测试 </h2><br><p> 我正在创建一个新项目。 我选择项目rgbled的名称（因为我想做一个RGB LED之类的东西）及其路径。 我选择基类QWidget和名称RgbLed，但我拒绝创建表单文件。 默认情况下，启动后的项目将创建一个空窗口，但仍然没有兴趣。 </p><br><h3 id="podgotovka-k-risovaniyu"> 图纸准备 </h3><br><p> 有一个空白。 现在，您需要获取类的私有成员，这将确定图片的几何形状。 矢量图形的一个基本优点是它的可伸缩性，因此应该有最小数量的常数，并且它们只能设置比例。 尺寸将在resizeEvent（）事件中重新计算，需要重新定义。 </p><br><p> 在所使用的图形教程中，尺寸随即以像素为单位指定。 我需要事先确定我将使用什么以及如何重新计数。 </p><br><p> 绘制的图片包含以下元素： </p><br><ul><li> 外圈（向外倾斜，部分凸边） </li><li> 内圈（向内倾斜） </li><li>  LED灯罩，“玻璃” </li><li> 玻璃边缘上的阴影 </li><li> 最高亮点 </li><li> 底部耀斑 </li></ul><br><p> 同心圆，即除眩光以外的所有东西，都由中心的位置和半径确定。 眩光由中心，宽度和高度决定，X眩光中心的位置与整个图片X中心的位置一致。 </p><br><p> 要计算几何元素，您需要确定哪个更大-宽度或高度，因为灯泡是圆形的，并且必须适合边长等于两个维度中较小者的正方形。 因此，我将相应的私有成员添加到头文件中。 </p><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minDim; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> half; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerY; QRect drawingRect; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outerBorderWidth; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> innerBorderWidth; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outerBorderRadius; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> innerBorderRadius; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> topReflexY; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bottomReflexY; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> topReflexWidth; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> topReflexHeight; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bottomReflexWidth; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bottomReflexHeight;</code> </pre> </div></div><br><p> 然后，我重新定义了调整窗口小部件大小时调用的受保护函数。 </p><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: void resizeEvent(QResizeEvent *event); void RgbLed::resizeEvent(QResizeEvent *event) { QWidget::resizeEvent(event); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;height = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;size().height(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;width = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;size().width(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;minDim = (height &gt; width) ? width : height; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;half = minDim / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;centerX = width / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;centerY = height / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;outerBorderWidth = minDim / <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;innerBorderWidth = minDim / <span class="hljs-number"><span class="hljs-number">14</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;outerBorderRadius = half - outerBorderWidth; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;innerBorderRadius = half - (outerBorderWidth + innerBorderWidth); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;topReflexY = centerY - (half - outerBorderWidth - innerBorderWidth) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;bottomReflexY = centerY + (half - outerBorderWidth - innerBorderWidth) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;topReflexHeight = half / <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;topReflexWidth = half / <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;bottomReflexHeight = half / <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;bottomReflexWidth = half / <span class="hljs-number"><span class="hljs-number">3</span></span>; drawingRect.setTop((height - minDim) / <span class="hljs-number"><span class="hljs-number">2</span></span>); drawingRect.setLeft((width - minDim) / <span class="hljs-number"><span class="hljs-number">2</span></span>); drawingRect.setHeight(minDim); drawingRect.setWidth(minDim); }</code> </pre> </div></div><br><p> 在此，计算出灯泡所在的正方形的一面，该正方形的中心，边缘的半径占据最大可能面积，边缘的宽度，边缘的外部应为直径的1/10和内部的1.14。 然后计算位于上，下半径中间的眩光的位置，用眼睛选择宽度和高度。 </p><br><p> 另外，在受保护的字段中，我将立即添加一组要使用的颜色。 </p><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> ledColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> lightColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> shadowColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> ringShadowDarkColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> ringShadowMedColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> ringShadowLightColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> topReflexUpColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> topReflexDownColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> bottomReflexCenterColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> bottomReflexSideColor;</code> </pre> </div></div><br><p> 顾名思义，这些是灯泡的颜色，阴影的亮部分，阴影的暗部分，灯泡周围的环形阴影的三种颜色以及眩光渐变的颜色。 </p><br><p> 颜色应该被初始化，以便我补充设计师的作品。 </p><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="hljs php">RgbLed::RgbLed(QWidget *<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>) : QWidget(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>), ledColor(Qt::green), lightColor(QColor(<span class="hljs-number"><span class="hljs-number">0xE0</span></span>, <span class="hljs-number"><span class="hljs-number">0xE0</span></span>, <span class="hljs-number"><span class="hljs-number">0xE0</span></span>)), shadowColor(QColor(<span class="hljs-number"><span class="hljs-number">0x70</span></span>, <span class="hljs-number"><span class="hljs-number">0x70</span></span>, <span class="hljs-number"><span class="hljs-number">0x70</span></span>)), ringShadowDarkColor(QColor(<span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>)), ringShadowMedColor(QColor(<span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x20</span></span>)), ringShadowLightColor(QColor(<span class="hljs-number"><span class="hljs-number">0xEE</span></span>, <span class="hljs-number"><span class="hljs-number">0xEE</span></span>, <span class="hljs-number"><span class="hljs-number">0xEE</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>)), topReflexUpColor(QColor(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xA0</span></span>)), topReflexDownColor(QColor(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>)), bottomReflexCenterColor(QColor(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>)), bottomReflexSideColor(QColor(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0x70</span></span>)) { }</code> </pre> </div></div><br><p> 同样，不要忘记在头文件中插入绘图时将需要的类的包含。 </p><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta">#include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QPainter&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QPen&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QBrush&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QColor&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QGradient&gt;</span></span></span></span></code> </pre> </div></div><br><p> 该代码可以成功编译，但是窗口小部件窗口中没有任何更改。 是时候开始绘图了。 </p><br><h3 id="risovanie"> 画图 </h3><br><p> 我进入一个封闭的功能 </p><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawLed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QColor &amp;color</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><p> 并重新定义受保护的功能 </p><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">paintEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">QPaintEvent *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">event</span></span></span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><p> 重绘事件将导致实际绘制，“玻璃”的颜色作为参数传递到该绘制。 </p><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RgbLed::paintEvent(QPaintEvent *event) { QWidget::paintEvent(event); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;drawLed(ledColor); }</code> </pre> </div></div><br><p> 到目前为止。 然后我们开始逐步填写绘图功能。 </p><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RgbLed::drawLed(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QColor &amp;color) { <span class="hljs-function"><span class="hljs-function">QPainter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; QPen pen; pen.setStyle(Qt::NoPen); p.setPen(pen); }</code> </pre> </div></div><br><p> 首先，创建一个艺术家对象，将其用于绘图。 然后创建了需要的铅笔，因此没有铅笔：在此图像中，不仅不需要轮廓笔画，而且根本不需要。 </p><br><p> 然后，按照矢量图形上的课程大致绘制第一个圆：一个大的圆，上面填充了径向渐变。 渐变在顶部（而不是在边缘）处有一个浅锚点，在底部（但不是在边缘）处有一个暗锚点。 根据渐变创建画笔，用此画笔画家绘制一个圆（即，刻在正方形上的椭圆）。 原来是这样的代码 </p><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="hljs lisp"> QRadialGradient outerRingGradient(<span class="hljs-name"><span class="hljs-name">QPoint</span></span>(<span class="hljs-name"><span class="hljs-name">centerX</span></span>, centerY - outerBorderRadius - (<span class="hljs-name"><span class="hljs-name">outerBorderWidth</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>)), minDim - (<span class="hljs-name"><span class="hljs-name">outerBorderWidth</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>))<span class="hljs-comment"><span class="hljs-comment">; outerRingGradient.setColorAt(0, lightColor); outerRingGradient.setColorAt(1, shadowColor); QBrush outerRingBrush(outerRingGradient); p.setBrush(outerRingBrush); p.drawEllipse(this-&gt;drawingRect); qDebug() &lt;&lt; "draw";</span></span></code> </pre> </div></div><br><p> 环境强调了drawLed函数的color参数，因为未使用它。 让他宽容，还不需要他，但是他很快就会需要它。 启动的项目将产生以下结果： </p><br><div class="spoiler">  <b class="spoiler_title">画图</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/tr/d5/w4/trd5w4j8fbipcfgzjzhgydbxln8.png"></p></div></div><br><p> 添加另一批代码。 </p><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="hljs lisp"> QRadialGradient innerRingGradient(<span class="hljs-name"><span class="hljs-name">QPoint</span></span>(<span class="hljs-name"><span class="hljs-name">centerX</span></span>, centerY + innerBorderRadius + (<span class="hljs-name"><span class="hljs-name">innerBorderWidth</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>)), minDim - (<span class="hljs-name"><span class="hljs-name">innerBorderWidth</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>))<span class="hljs-comment"><span class="hljs-comment">; innerRingGradient.setColorAt(0, lightColor); innerRingGradient.setColorAt(1, shadowColor); QBrush innerRingBrush(innerRingGradient); p.setBrush(innerRingBrush); p.drawEllipse(QPoint(centerX, centerY), outerBorderRadius, outerBorderRadius);</span></span></code> </pre> </div></div><br><p> 几乎相同的圆圈，但尺寸较小且倒置。 我们得到以下图片： </p><br><div class="spoiler">  <b class="spoiler_title">画图</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/sl/qa/-p/slqa-p1yxoytsvbaw86hsqniexw.png"></p></div></div><br><p> 最后，您需要玻璃的颜色： </p><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">QColor</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">dark</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.darker</span></span>(120)); <span class="hljs-selector-tag"><span class="hljs-selector-tag">QRadialGradient</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">glassGradient</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QPoint</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">centerX</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">centerY</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">glassGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">glassGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(1, <span class="hljs-selector-tag"><span class="hljs-selector-tag">dark</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">QBrush</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">glassBrush</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">glassGradient</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setBrush</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">glassBrush</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.drawEllipse</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QPoint</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">centerX</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">centerY</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>);</code> </pre> </div></div><br><p> 在这里，使用透射色的较暗功能，可以获得相同的颜色，但较暗，以组织渐变。 肉眼选择的系数120。 结果如下： </p><br><div class="spoiler">  <b class="spoiler_title">画图</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/hs/wq/dl/hswqdl5hkf_fxabxawraf8alsgq.png"></p></div></div><br><p> 在玻璃周围添加环形阴影。 这是在关于矢量图形的课程中完成的，这应该增加体积和真实感： </p><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">QRadialGradient</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QPoint</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">centerX</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">centerY</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">ringShadowLightColor</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(0<span class="hljs-selector-class"><span class="hljs-selector-class">.85</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">ringShadowMedColor</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(1, <span class="hljs-selector-tag"><span class="hljs-selector-tag">ringShadowDarkColor</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">QBrush</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowBrush</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setBrush</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowBrush</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.drawEllipse</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QPoint</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">centerX</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">centerY</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>);</code> </pre> </div></div><br><p> 有一个三步渐变，因此阴影的边缘变粗，向中心变浅。 原来是这样的： </p><br><div class="spoiler">  <b class="spoiler_title">画图</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ga/0n/wj/ga0nwjnp8vjh6yupym3d_yyo5lc.png"></p></div></div><br><p> 一次添加高光。 与下部（和所有其他元素）不同，上部高光是线性渐变。 我的画家很一般，我谨代表本课的作者。 也许有些道理，我不会尝试不同类型的渐变。 </p><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="hljs lisp"> QLinearGradient topTeflexGradient(<span class="hljs-name"><span class="hljs-name">QPoint</span></span>(<span class="hljs-name"><span class="hljs-name">centerX</span></span>, (<span class="hljs-name"><span class="hljs-name">innerBorderWidth</span></span> + outerBorderWidth)), QPoint(<span class="hljs-name"><span class="hljs-name">centerX</span></span>, centerY))<span class="hljs-comment"><span class="hljs-comment">; topTeflexGradient.setColorAt(0, topReflexUpColor); topTeflexGradient.setColorAt(1, topReflexDownColor); QBrush topReflexbrush(topTeflexGradient); p.setBrush(topReflexbrush); p.drawEllipse(QPoint(centerX, topReflexY), topReflexWidth, topReflexHeight); QRadialGradient bottomReflexGradient(QPoint(centerX, bottomReflexY + (bottomReflexHeight / 2)), bottomReflexWidth); bottomReflexGradient.setColorAt(0, bottomReflexSideColor); bottomReflexGradient.setColorAt(1, bottomReflexCenterColor); QBrush bottomReflexBrush(bottomReflexGradient); p.setBrush(bottomReflexBrush); p.drawEllipse(QPoint(centerX, bottomReflexY), bottomReflexWidth, bottomReflexHeight);</span></span></code> </pre> </div></div><br><p> 实际上，就像KDPV一样，这就是一个现成的灯泡。 </p><br><div class="spoiler">  <b class="spoiler_title">画图</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/99/xx/bm/99xxbmwsmy1r6fo-dht2pif7wdg.png"></p></div></div><br><p> 玻璃的眩光和凸起的可见性受颜色（或多深）的影响。 根据黑暗情况，在暗功能中增加眩光的亮度和调光系数的调整可能很有意义，但这是完美主义。 </p><br><p> 下面是在程序窗口中使用的示例。 </p><br><div class="spoiler">  <b class="spoiler_title">画图</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/xy/tt/ix/xyttix1vqiabybl7-no-9d2dgk8.png"></p></div></div><br><h3 id="balovstvo"> 呵护 </h3><br><p> 为了娱乐，您可以玩花。 例如，覆盖受保护的鼠标单击事件 </p><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mousePressEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">QMouseEvent *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">event</span></span></span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><p> 这样： </p><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="hljs axapta"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RgbLed::mousePressEvent(QMouseEvent *event) { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event-&gt;button() == Qt::LeftButton) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">count</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: ledColor = Qt::red; <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: ledColor = Qt::green; <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: ledColor = Qt::blue; <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: ledColor = Qt::gray; <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: ledColor = QColor(<span class="hljs-number"><span class="hljs-number">220</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">count</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;repaint(); } QWidget::mousePressEvent(event); }</code> </pre> </div></div><br><p> 不要忘记将鼠标事件添加到标题中： </p><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QMouseEvent&gt;</span></span></span></span></code> </pre> <br><p> 现在，在组件上单击鼠标将切换灯泡的颜色：红色，绿色，蓝色，灰色以及灯泡发出的一些随机光。 </p><br><h2 id="epilog"> 结语 </h2><br><p> 至于绘图，仅此而已。 并且小部件应添加功能。 在我的情况下，添加了一个布尔字段“使用状态”，另一个布尔字段定义了状态“开”或“关”以及这些状态的默认颜色，以及所有这些的开放式吸气剂和吸气剂。 paintEvent（）函数选择传递给drawLed（）的颜色作为参数，因此，您可以根据事件关闭状态的使用并将灯泡设置为任何颜色，或者根据事件打开状态并打开或关闭灯泡。连体 与必须进行监控的信号是它。 </p><br><p> 使用mousePressEvent演示了不仅可以使小部件成为指示器，而且还可以使其成为按钮，从而使其可以被按下，释放，弯曲，扭曲，着色以及任何您想要的指向，单击和释放事件。 </p><br><p> 但这已不再是根本。 目的是显示在绘制自己的窗口小部件时可以在何处扮演角色模型，以及如何在资源或文件中无需使用光栅或矢量图像的情况下轻松实现此绘制。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN425547/">https://habr.com/ru/post/zh-CN425547/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN425531/index.html">液制动冷却。 系统开发选项</a></li>
<li><a href="../zh-CN425533/index.html">如何在云中工作：从检查数据中心的可靠性到管理虚拟基础架构</a></li>
<li><a href="../zh-CN425537/index.html">如何将Java，Js和图形与艺术结合起来，或如何创建交互式剧院的故事</a></li>
<li><a href="../zh-CN425541/index.html">如何快速且没有不必要的芯片来规避HTU21传感器的地址不变性</a></li>
<li><a href="../zh-CN425545/index.html">您应该考虑几个小时的练习。</a></li>
<li><a href="../zh-CN425549/index.html">在对中国间谍芯片部署进行调查后，Supermicro股票暴跌</a></li>
<li><a href="../zh-CN425551/index.html">谁应该从出售AI创作的艺术品中获得收益？</a></li>
<li><a href="../zh-CN425553/index.html">基督山伯爵能告诉我们什么有关网络安全的信息</a></li>
<li><a href="../zh-CN425555/index.html">Charles Nutter在jug.msk.ru上探讨了JVM中的动态语言</a></li>
<li><a href="../zh-CN425557/index.html">麻省理工学院的课程“计算机系统安全”。 第10课：符号执行，第1部分</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>