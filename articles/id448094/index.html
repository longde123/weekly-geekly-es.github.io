<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✊🏻 ⚕️ 🧖🏾 Docker: cara menggunakan aplikasi tumpukan penuh dan tidak berubah menjadi abu-abu ⛩️ 📿 🥌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Kita membutuhkan DevOps!" 
 (frasa paling populer di akhir hackathon apa pun) 

 Pertama, beberapa lirik. 

 Ketika seorang pengembang adalah devo ya...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Docker: cara menggunakan aplikasi tumpukan penuh dan tidak berubah menjadi abu-abu</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448094/"> <i>"Kita membutuhkan DevOps!"</i> <br>  <i>(frasa paling populer di akhir hackathon apa pun)</i> <br><img src="https://habrastorage.org/webt/yy/k1/0q/yyk10qsi8ayqzxsnwqua1nwyzrk.jpeg"><br>  Pertama, beberapa lirik. <br><br>  Ketika seorang pengembang adalah devo yang sangat baik yang dapat menyebarkan gagasannya pada mesin apa pun di bawah OC apa pun, ini merupakan nilai tambah.  Namun, jika ia tidak memahami apa pun lebih jauh dari IDE-nya, ini bukan minus - pada akhirnya, ia dibayar untuk kode tersebut, dan bukan karena kemampuan untuk menyebarkannya.  Spesialis dalam yang sempit di pasar dihargai lebih tinggi daripada keterampilan rata-rata "jack of all trade".  Bagi orang-orang seperti kami, "pengguna IDE," orang-orang baik datang dengan Docker. <br><br>  Prinsip Docker adalah sebagai berikut: "itu bekerja untuk saya - itu bekerja di mana-mana."  Satu-satunya program yang diperlukan untuk menyebarkan salinan aplikasi Anda di mana saja adalah Docker.  Jika Anda menjalankan aplikasi di buruh pelabuhan pada mesin Anda, itu dijamin berjalan dengan sukses yang sama di buruh pelabuhan lainnya.  Dan tidak ada apa-apa selain buruh pelabuhan yang perlu diinstal.  Misalnya, saya bahkan tidak memiliki Java di server virtual. <a name="habracut"></a><br><br><h2>  Bagaimana cara kerja buruh pelabuhan? </h2><br>  Docker menciptakan gambar mesin virtual dengan aplikasi yang diinstal di dalamnya.  Selanjutnya, gambar ini terungkap sebagai mesin virtual yang sepenuhnya otonom.  Salinan gambar yang sedang berjalan disebut "wadah".  Anda dapat menjalankan sejumlah gambar di server, dan masing-masing gambar akan menjadi mesin virtual terpisah dengan lingkungannya sendiri. <br><br>  Apa itu mesin virtual?  Ini adalah lokasi enkapsulasi pada server dengan OS di mana aplikasi diinstal.  Dalam sistem operasi apa pun, sejumlah besar aplikasi biasanya berputar, di kita ada satu. <br><br>  Skema penyebaran kontainer dapat direpresentasikan sebagai berikut: <br><br><img src="https://habrastorage.org/webt/9p/vq/ya/9pvqyam6ckaxqvihopwdoynhf4y.jpeg"><br><br>  Untuk setiap aplikasi, kami membuat gambar kami sendiri, dan kemudian menggunakan setiap wadah secara terpisah.  Anda juga dapat meletakkan semua aplikasi dalam satu gambar dan menggunakan sebagai satu wadah.  Selain itu, agar tidak menyebarkan masing-masing wadah secara terpisah, kita dapat menggunakan utilitas pembuat docker terpisah yang mengkonfigurasi wadah dan hubungan antara mereka melalui file terpisah.  Maka struktur seluruh aplikasi mungkin terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/ga/ft/fm/gaftfmbyumgesqldxv1pphh6ati.jpeg"><br><br>  Saya sengaja tidak berkontribusi database ke majelis Docker umum, karena beberapa alasan.  Pertama, basis data benar-benar independen dari aplikasi yang bekerja dengannya.  Bisa jauh dari satu aplikasi, bisa juga permintaan manual dari konsol.  Secara pribadi, saya tidak melihat alasan untuk membuat basis data bergantung pada perakitan Docker di mana ia berada.  Karena itu, saya menanggungnya.  Namun, pendekatan sering dipraktikkan di mana basis data ditempatkan dalam gambar terpisah dan diluncurkan dalam wadah terpisah.  Kedua, saya ingin menunjukkan bagaimana wadah Docker berinteraksi dengan sistem di luar wadah. <br><br>  Namun, cukup liriknya, mari kita menulis kodenya.  Kami akan menulis aplikasi paling sederhana pada musim semi dan bereaksi, yang akan merekam panggilan kami ke depan ke dalam database, dan kami akan mengangkat semua ini melalui Docker.  Struktur aplikasi kita akan terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/k4/pp/lg/k4pplgvwba46vygymrasjctmrkm.jpeg"><br><br>  Ada banyak cara untuk menerapkan struktur seperti itu.  Kami menerapkan salah satunya.  Kami akan membuat dua gambar, meluncurkan dua wadah dari mereka, dan backend akan terhubung ke database yang diinstal pada server tertentu di suatu tempat di Internet (ya, permintaan database seperti itu tidak akan berjalan dengan cepat, tetapi kami tidak didorong oleh kehausan untuk optimasi, tetapi minat ilmiah). <br><br>  Pos akan dibagi menjadi beberapa bagian: <br><br>  0. Pasang Docker. <br>  1. Kami menulis aplikasi. <br>  2. Kami mengumpulkan gambar dan meluncurkan wadah. <br>  3. Kumpulkan gambar dan luncurkan wadah di server jauh. <br>  4. Memecahkan masalah jaringan. <br><br><h2>  0. Pasang Docker </h2><br>  Untuk menginstal Docker, Anda harus pergi ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs</a> dan mengikuti apa yang tertulis di sana.  Saat memasang Docker di server jarak jauh, bersiaplah untuk kenyataan bahwa Docker mungkin tidak bekerja dengan server di OpenVZ.  Serta mungkin ada masalah jika Anda tidak mengaktifkan iptables.  Dianjurkan untuk memulai server pada KVM dengan iptables.  Tapi ini rekomendasi saya.  Jika semuanya bekerja untuk Anda, maka saya akan senang Anda tidak menghabiskan banyak waktu mencari tahu mengapa itu tidak berhasil, bagaimana saya harus melakukannya. <br><br><h2>  1. Kami menulis aplikasi </h2><br>  Mari kita menulis aplikasi sederhana dengan backend paling primitif di Spring Boot, frontend yang sangat sederhana pada ReactJS dan database MySQL.  Aplikasi akan memiliki Halaman Tunggal dengan satu tombol yang akan mencatat waktu diklik di dalam basis data. <br><br>  Saya harap Anda sudah tahu cara menulis aplikasi pada boot, tetapi jika tidak, Anda dapat mengkloning proyek yang sudah selesai.  Semua tautan di akhir artikel. <br><br><h3>  Backend pada Boot Musim Semi </h3><br>  build.gradle: <br><br><pre><code class="java hljs">plugins { id <span class="hljs-string"><span class="hljs-string">'org.springframework.boot'</span></span> version <span class="hljs-string"><span class="hljs-string">'2.1.4.RELEASE'</span></span> id <span class="hljs-string"><span class="hljs-string">'java'</span></span> } apply plugin: <span class="hljs-string"><span class="hljs-string">'io.spring.dependency-management'</span></span> group = <span class="hljs-string"><span class="hljs-string">'ru.xpendence'</span></span> version = <span class="hljs-string"><span class="hljs-string">'0.0.2'</span></span> sourceCompatibility = <span class="hljs-string"><span class="hljs-string">'1.8'</span></span> repositories { mavenCentral() } dependencies { implementation <span class="hljs-string"><span class="hljs-string">'org.springframework.boot:spring-boot-starter-data-jpa'</span></span> implementation <span class="hljs-string"><span class="hljs-string">'org.springframework.boot:spring-boot-starter-web'</span></span> runtimeOnly <span class="hljs-string"><span class="hljs-string">'mysql:mysql-connector-java'</span></span> testImplementation <span class="hljs-string"><span class="hljs-string">'org.springframework.boot:spring-boot-starter-test'</span></span> }</code> </pre> <br>  Entitas Log: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> ru.xpendence.rebounder.entity; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.fasterxml.jackson.annotation.JsonFormat; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.persistence.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.Serializable; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.time.LocalDateTime; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Objects; <span class="hljs-comment"><span class="hljs-comment">/** * Author: Vyacheslav Chernyshov * Date: 14.04.19 * Time: 21:20 * e-mail: 2262288@gmail.com */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"request_logs"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Log</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Long id; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> LocalDateTime created; <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span>(strategy = GenerationType.IDENTITY) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Long </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> id; } <span class="hljs-meta"><span class="hljs-meta">@Column</span></span> <span class="hljs-meta"><span class="hljs-meta">@JsonFormat</span></span>(shape = JsonFormat.Shape.STRING, pattern = <span class="hljs-string"><span class="hljs-string">"yyyy-MM-dd HH:mm:ss.SSS"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> LocalDateTime </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> created; } <span class="hljs-meta"><span class="hljs-meta">@PrePersist</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prePersist</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.created = LocalDateTime.now(); } <span class="hljs-comment"><span class="hljs-comment">//setters, toString, equals, hashcode, constructors</span></span></code> </pre> <br>  LogController, yang akan bekerja pada logika yang disederhanakan dan segera menulis ke database.  Kami menghilangkan layanan. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> ru.xpendence.rebounder.controller; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.fasterxml.jackson.core.JsonProcessingException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.fasterxml.jackson.databind.ObjectMapper; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.beans.factory.annotation.Autowired; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.http.ResponseEntity; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.web.bind.annotation.GetMapping; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.web.bind.annotation.RequestMapping; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.web.bind.annotation.RestController; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ru.xpendence.rebounder.entity.Log; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ru.xpendence.rebounder.repository.LogRepository; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.logging.Logger; <span class="hljs-comment"><span class="hljs-comment">/** * Author: Vyacheslav Chernyshov * Date: 14.04.19 * Time: 22:24 * e-mail: 2262288@gmail.com */</span></span> <span class="hljs-meta"><span class="hljs-meta">@RestController</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequestMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"/log"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LogController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Logger LOG = Logger.getLogger(LogController.class.getName()); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> LogRepository repository; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LogRepository repository)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.repository = repository; } <span class="hljs-meta"><span class="hljs-meta">@GetMapping</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ResponseEntity&lt;Log&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Log log = repository.save(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Log()); LOG.info(<span class="hljs-string"><span class="hljs-string">"saved new log: "</span></span> + log.toString()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ResponseEntity.ok(log); } }</code> </pre><br>  Semuanya, seperti yang kita lihat, sangat sederhana.  Dengan permintaan GET, kami menulis ke database dan mengembalikan hasilnya. <br><br>  Kami akan membahas file pengaturan aplikasi secara terpisah.  Mereka ada dua. <br><br>  application.yml: <br><br><pre> <code class="java hljs">spring: profiles: active: remote</code> </pre> <br>  application-remote.yml: <br><br><pre> <code class="java hljs">spring: datasource: driver-<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">com</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mysql</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cj</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">jdbc</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Driver</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">url</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">jdbc</span></span></span><span class="hljs-class">:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mysql</span></span></span><span class="hljs-class">://</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">remote</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">server</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">database</span></span></span><span class="hljs-class">:3306/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rebounder_database</span></span></span><span class="hljs-class">?</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">useUnicode</span></span></span></span>=<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>&amp;useJDBCCompliantTimezoneShift=<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>&amp;useLegacyDatetimeCode=<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>&amp;serverTimezone=UTC username: admin password: <span class="hljs-number"><span class="hljs-number">12345</span></span> jpa: hibernate: ddl-auto: update show-sql: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> properties: hibernate.dialect: org.hibernate.dialect.MySQL5Dialect server: port: <span class="hljs-number"><span class="hljs-number">8099</span></span></code> </pre> <br>  Cara kerjanya, Anda mungkin tahu bahwa Spring pertama memindai file application.properties atau application.yml - mana yang ditemukannya.  Di dalamnya kami menunjukkan satu pengaturan tunggal - profil mana yang akan kami gunakan.  Biasanya, selama pengembangan, saya mengumpulkan beberapa profil, dan sangat nyaman untuk beralih menggunakan profil default.  Selanjutnya, Spring menemukan application.yml dengan akhiran yang diinginkan dan menggunakannya. <br><br>  Kami menentukan sumber data, pengaturan JPA dan, yang penting, port eksternal backend kami. <br><br><h3>  Frontend ReactJS </h3><br>  Anda juga dapat melihat frontend dalam sebuah proyek di git, atau Anda bahkan tidak bisa menonton, tetapi mengkloning dan menjalankannya. <br><br>  Anda dapat memeriksa pekerjaan individu dari frontend dengan mengunduh proyek, pergi ke folder root proyek di terminal (di mana file package.json berada) dan menjalankan dua perintah secara berurutan: <br><br><pre> <code class="bash hljs">npm install //      ,  maven npm start //  </code> </pre> <br>  Tentu saja, untuk ini Anda memerlukan Node Package Manager (npm) yang diinstal, dan ini adalah cara paling sulit yang kami hindari menggunakan Docker.  Jika Anda masih memulai proyek, Anda akan melihat jendela berikut: <br><br><img src="https://habrastorage.org/webt/aq/m7/t4/aqm7t4txa2g_rqbuswo3uiibjpq.png"><br><br>  Oh well, sudah waktunya untuk melihat kode.  Saya hanya akan menunjukkan bagian yang merujuk ke backend. <br><br><pre> <code class="java hljs">export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Api</span></span></span><span class="hljs-class"> </span></span>{ _apiPath = <span class="hljs-string"><span class="hljs-string">'http://localhost:8099'</span></span>; _logUrl = <span class="hljs-string"><span class="hljs-string">'/log'</span></span>; getResource = async () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res = <span class="hljs-function"><span class="hljs-function">await </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(`${</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">._apiPath}${</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">._logUrl}`)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!res.ok) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(`Could not fetch ${<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._logUrl}` + `, received ${res.status}`) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> await res.json(); }; };</code> </pre> <br>  Frontend berfungsi dengan baik.  Kami mengikuti tautan, menunggu jawabannya dan menampilkannya di layar. <br><br><img src="https://habrastorage.org/webt/xz/vy/qd/xzvyqdrh7akd1c1flu-gnjhcxok.png"><br><br>  Perlu memfokuskan pada hal-hal berikut: <br><br><ol><li>  Bagian depan terbuka ke dunia luar melalui port 3000. Ini adalah port default untuk React. </li><li>  Bagian belakang dibuka pada port 8099. Kami mengaturnya di pengaturan aplikasi. </li><li>  Bagian belakang mengetuk database melalui Internet eksternal. </li></ol><br>  Aplikasi sudah siap. <br><br><h2>  2. Kumpulkan gambar dan luncurkan wadah </h2><br>  Struktur perakitan kami adalah sebagai berikut.  Kami akan membuat dua gambar - frontend dan backend, yang akan berkomunikasi satu sama lain melalui port eksternal.  Untuk basis, kami tidak akan membuat gambar, kami akan menginstalnya secara terpisah.  Kenapa begitu  Mengapa kita tidak membuat gambar untuk basis?  Kami memiliki dua aplikasi yang terus berubah dan tidak menyimpan data dalam diri kami.  Basis data menyimpan data itu sendiri, dan ini mungkin hasil dari beberapa bulan operasi aplikasi.  Selain itu, database ini dapat diakses tidak hanya oleh aplikasi backend kami, tetapi juga oleh banyak orang lain - untuk itu juga merupakan database, dan kami tidak akan terus-menerus merakitnya.  Sekali lagi, ini adalah kesempatan untuk bekerja dengan API eksternal, yang, tentu saja, terhubung ke database kami. <br><br><h4>  Perakitan ujung depan </h4><br>  Untuk menjalankan setiap aplikasi (baik itu depan atau belakang), Anda memerlukan urutan tindakan tertentu.  Untuk menjalankan aplikasi pada React, kita perlu melakukan hal berikut (asalkan kita sudah memiliki Linux): <br><br><ol><li>  Instal NodeJS. </li><li>  Salin aplikasi ke folder tertentu. </li><li>  Instal paket yang diperlukan (perintah install npm). </li><li>  Luncurkan aplikasi dengan perintah mulai npm. </li></ol><br>  Ini adalah urutan tindakan yang harus kita lakukan di buruh pelabuhan.  Untuk melakukan ini, di root proyek (di tempat yang sama dengan package.json berada), kita harus menempatkan Dockerfile dengan konten berikut: <br><br><pre> <code class="javascript hljs">FROM node:alpine WORKDIR /usr/app/front EXPOSE <span class="hljs-number"><span class="hljs-number">3000</span></span> COPY ./ ./ RUN npm install CMD [<span class="hljs-string"><span class="hljs-string">"npm"</span></span>, <span class="hljs-string"><span class="hljs-string">"start"</span></span>]</code> </pre> <br>  Mari kita lihat apa arti setiap baris. <br><br><pre> <code class="javascript hljs">FROM node:alpine</code> </pre> <br>  Dengan baris ini, kami membuatnya jelas kepada buruh pelabuhan bahwa ketika Anda memulai wadah, hal pertama yang perlu Anda lakukan adalah mengunduh Docker dari repositori dan menginstal NodeJS, dan yang paling ringan (semua versi paling ringan dari kerangka kerja populer dan perpustakaan di buruh pelabuhan biasanya disebut alpine). <br><br><pre> <code class="javascript hljs">WORKDIR /usr/app/front</code> </pre> <br>  Dalam wadah Linux, folder standar yang sama akan dibuat seperti di Linux lainnya - / opt, / home, / etc, / usr dan seterusnya.  Kami mengatur direktori kerja yang dengannya kami akan bekerja - / usr / app / depan. <br><br><pre> <code class="javascript hljs">EXPOSE <span class="hljs-number"><span class="hljs-number">3000</span></span></code> </pre> <br>  Kami membuka port 3000. Komunikasi lebih lanjut dengan aplikasi yang berjalan dalam wadah akan terjadi melalui port ini. <br><br><pre> <code class="javascript hljs">COPY ./ ./</code> </pre> <br>  Salin konten proyek sumber ke folder kerja wadah. <br><br><pre> <code class="javascript hljs">RUN npm install</code> </pre> <br>  Instal semua paket yang diperlukan untuk menjalankan aplikasi. <br><br><pre> <code class="javascript hljs">CMD [<span class="hljs-string"><span class="hljs-string">"npm"</span></span>, <span class="hljs-string"><span class="hljs-string">"start"</span></span>]</code> </pre> <br>  Kami memulai aplikasi dengan perintah mulai npm. <br><br>  Skenario ini akan dieksekusi di aplikasi kita ketika wadah dimulai. <br><br>  Mari kita luruskan.  Untuk melakukan ini, di terminal, berada di folder root proyek (di mana Dockerfile berada), jalankan perintah: <br><br><pre> <code class="java hljs">docker build -t rebounder-chain-frontend .</code> </pre> <br>  Nilai Perintah: <br><br>  buruh pelabuhan adalah panggilan ke aplikasi buruh pelabuhan, Anda tahu itu. <br>  membangun - membangun gambar dari bahan target. <br>  -t &lt;name&gt; - di masa depan, aplikasi akan tersedia dengan tag yang ditentukan di sini.  Anda dapat menghilangkan ini, maka Docker akan menghasilkan tag sendiri, tetapi tidak mungkin untuk membedakannya dari yang lain. <br>  .  - menunjukkan bahwa Anda perlu mengumpulkan proyek dari folder saat ini. <br><br><img src="https://habrastorage.org/webt/ro/fc/nz/rofcnzucfn0207jnqulzpjrgxw4.jpeg"><br><br>  Akibatnya, majelis harus diakhiri dengan teks: <br><br><pre> <code class="java hljs">Step <span class="hljs-number"><span class="hljs-number">7</span></span>/<span class="hljs-number"><span class="hljs-number">7</span></span> : CMD [<span class="hljs-string"><span class="hljs-string">"npm"</span></span>, <span class="hljs-string"><span class="hljs-string">"start"</span></span>] ---&gt; Running in ee0e8a9066dc Removing intermediate container ee0e8a9066dc ---&gt; b208c4184766 Successfully built b208c4184766 Successfully tagged rebounder-chain-frontend:latest</code> </pre> <br>  Jika kita melihat bahwa langkah terakhir telah selesai dan semuanya berhasil, maka kita memiliki gambar.  Kami dapat memverifikasi ini dengan menjalankannya: <br><br><pre> <code class="java hljs">docker run -p <span class="hljs-number"><span class="hljs-number">8080</span></span>:<span class="hljs-number"><span class="hljs-number">3000</span></span> rebounder-chain-frontend</code> </pre> <br>  Arti dari perintah ini, saya pikir, secara umum dipahami, dengan pengecualian -p 8080: 3000 entri. <br>  docker run rebounder-chain-frontend - artinya kita meluncurkan citra buruh pelabuhan seperti itu, yang kita sebut rebounder-chain-frontend.  Tapi wadah seperti itu tidak akan memiliki jalan keluar ke luar, perlu mengatur port.  Tim di bawah inilah yang menentukannya.  Kita ingat bahwa aplikasi Bereaksi kita berjalan pada port 3000. Perintah -p 8080: 3000 memberitahu buruh pelabuhan untuk mengambil port 3000 dan meneruskannya ke port 8080 (yang akan terbuka).  Dengan demikian, aplikasi yang berjalan pada port 3000 akan dibuka pada port 8080, dan itu akan tersedia pada mesin lokal pada port tersebut. <br><br><pre> <code class="bash hljs">,       : Mac-mini-Vaceslav:rebounder-chain-frontend xpendence$ docker run -p 8080:3000 rebounder-chain-frontend &gt; rebounder-chain-frontend@0.1.0 start /usr/app/front &gt; react-scripts start Starting the development server... Compiled successfully! You can now view rebounder-chain-frontend <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the browser. Local: http://localhost:3000/ On Your Network: http://172.17.0.2:3000/ Note that the development build is not optimized. To create a production build, use npm run build.</code> </pre> <br>  Jangan sampai catatan mengganggu Anda <br><br><pre> <code class="bash hljs"> Local: http://localhost:3000/ On Your Network: http://172.17.0.2:3000/</code> </pre> <br>  Bereaksi berpikir begitu.  Ini benar-benar tersedia di dalam wadah pada port 3000, tetapi kami meneruskan port ini ke port 8080, dan dari wadah aplikasi berjalan pada port 8080. Anda dapat menjalankan aplikasi secara lokal dan memeriksa ini. <br><br>  Jadi, kami memiliki wadah siap pakai dengan aplikasi front-end, sekarang mari kita kumpulkan backend. <br><br><h4>  Membangun back-end. </h4><br>  Skrip untuk meluncurkan aplikasi di Jawa berbeda secara signifikan dari perakitan sebelumnya.  Ini terdiri dari item berikut: <br><br><ol><li>  Instal JVM. </li><li>  Kami mengumpulkan arsip jar. </li><li>  Kami meluncurkannya. </li></ol><br>  Di Dockerfile, proses ini terlihat seperti ini: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># back #     JVM FROM openjdk:8-jdk-alpine #  . ,    .  . LABEL maintainer="2262288@gmail.com" #         (  ,  ) VOLUME /tmp #  ,        EXPOSE 8099 # ,       ARG JAR_FILE=build/libs/rebounder-chain-backend-0.0.2.jar #       rebounder-chain-backend.jar ADD ${JAR_FILE} rebounder-chain-backend.jar #    ENTRYPOINT ["java","-jar","/rebounder-chain-backend.jar"]</span></span></code> </pre> <br>  Proses menyusun gambar dengan masuknya dzharnik pada beberapa titik menyerupai itu untuk front kita. <br><br>  Proses merakit dan meluncurkan gambar kedua pada dasarnya sama dengan merakit dan meluncurkan gambar pertama. <br><br><pre> <code class="bash hljs">docker build -t rebounder-chain-backend . docker run -p 8099:8099 rebounder-chain-backend</code> </pre> <br>  Sekarang, jika Anda memiliki kedua kontainer berjalan dan backend terhubung ke database, semuanya akan berfungsi.  Saya mengingatkan Anda bahwa Anda harus mendaftarkan koneksi ke database dari backend sendiri, dan itu harus bekerja melalui jaringan eksternal. <br><br><h2>  3. Kumpulkan gambar dan jalankan wadah di server jauh </h2><br>  Agar semuanya berfungsi pada server jarak jauh, kita perlu Docker sudah diinstal di atasnya, setelah itu, jalankan saja gambar.  Kami akan pergi dengan cara yang benar dan mengkomit gambar kami ke akun kami di cloud Docker, setelah itu mereka akan tersedia dari mana saja di dunia.  Tentu saja, ada banyak alternatif untuk pendekatan ini, serta segala sesuatu yang dijelaskan dalam posting ini, tetapi mari kita dorong sedikit lagi dan lakukan pekerjaan kita dengan baik.  Buruk, seperti yang dikatakan Andrei Mironov, kita selalu punya waktu untuk melakukannya. <br><br><h4>  Membuat akun di hub Docker </h4><br>  Hal pertama yang harus Anda lakukan adalah mendapatkan akun di hub Docker.  Untuk melakukan ini, buka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hub</a> dan daftar.  Itu tidak sulit. <br><br>  Selanjutnya, kita harus pergi ke terminal dan masuk ke Docker. <br><br><pre> <code class="bash hljs">docker login</code> </pre> <br>  Anda akan diminta memasukkan nama pengguna dan kata sandi.  Jika semuanya baik-baik saja, pemberitahuan akan muncul di terminal yang Login Berhasil. <br><br><h4>  Mengkomit Gambar ke Hub Docker </h4><br>  Selanjutnya, kita perlu memberi tag pada gambar kita dan mengkomitnya ke hub.  Ini dilakukan oleh tim sesuai dengan skema berikut: <br><br><pre> <code class="bash hljs">docker tag   /_:</code> </pre> <br>  Jadi, kita perlu menentukan nama gambar kita, login / repositori dan tag di mana gambar kita akan dikomit ke hub. <br><br>  Dalam kasus saya, terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/wu/pv/fh/wupvfhs3za_nws2wwsicgfgm2z4.jpeg"><br><br>  Kami dapat memeriksa keberadaan gambar ini di repositori lokal menggunakan perintah: <br><br><pre> <code class="bash hljs">Mac-mini-Vaceslav:rebounder-chain-backend xpendence$ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE xpendence/rebounder-chain-backend 0.0.2 c8f5b99e15a1 About an hour ago 141MB</code> </pre> <br>  Gambar kami siap berkomitmen.  Berkomitmen: <br><br><pre> <code class="bash hljs">docker push xpendence/rebounder-chain-backend:0.0.2</code> </pre> <br>  Catatan komit yang berhasil akan muncul. <br>  Lakukan hal yang sama dengan frontend: <br><br><pre> <code class="bash hljs">docker tag rebounder-chain-frontend xpendence/rebounder-chain-frontend:0.0.1 docker push xpendence/rebounder-chain-frontend:0.0.1</code> </pre> <br>  Sekarang, jika kita pergi ke hub.docker.com, kita akan melihat dua gambar yang terkunci.  Yang tersedia dari mana saja. <br><br><img src="https://habrastorage.org/webt/ur/zs/hk/urzshkc3j1ivikyhu4cxvcm43yk.png"><br><br><img src="https://habrastorage.org/webt/cr/if/rb/crifrbda12uxdq6habx6nfeablm.png"><br><br>  Selamat  Kami hanya harus beralih ke bagian akhir pekerjaan kami - untuk meluncurkan gambar di server jauh. <br><br><h4>  Jalankan gambar di server jauh </h4><br>  Sekarang kita dapat menjalankan gambar kita pada mesin apa pun dengan Docker dengan menyelesaikan hanya satu baris di terminal (dalam kasus kami, kita perlu menjalankan dua baris secara berurutan di terminal yang berbeda - satu untuk setiap gambar). <br><br><pre> <code class="bash hljs">docker run -p 8099:8099 xpendence/rebounder-chain-backend:0.0.2 docker run -p 8080:3000 xpendence/rebounder-chain-frontend:0.0.1</code> </pre> <br>  Namun, peluncuran ini memiliki satu minus.  Ketika terminal ditutup, proses akan berakhir dan aplikasi akan berhenti bekerja.  Untuk menghindari ini, kita dapat menjalankan aplikasi dalam mode "terlepas": <br><br><pre> <code class="bash hljs">docker run -d -p 8099:8099 xpendence/rebounder-chain-backend:0.0.2 docker run -d -p 8080:3000 xpendence/rebounder-chain-frontend:0.0.1</code> </pre> <br>  Sekarang aplikasi tidak akan mengeluarkan log ke terminal (ini dapat, sekali lagi, dikonfigurasi secara terpisah), tetapi bahkan ketika terminal ditutup, itu tidak akan berhenti bekerja. <br><br><h2>  4. Memecahkan masalah jaringan </h2><br>  Jika Anda melakukan semuanya dengan benar, Anda mungkin mengharapkan kekecewaan terbesar sepanjang jalan untuk mengikuti posting ini - mungkin ternyata tidak ada yang berhasil.  Sebagai contoh, semuanya bekerja dengan baik untuk Anda dan bekerja pada mesin lokal (seperti, misalnya, pada Mac saya), tetapi ketika digunakan pada server jarak jauh, wadah berhenti saling melihat (seperti, misalnya, pada server jarak jauh saya di Linux).  Apa masalahnya?  Tetapi masalahnya adalah ini, dan pada awalnya saya mengisyaratkan tentang hal itu.  Seperti yang disebutkan sebelumnya, ketika wadah dimulai, Docker membuat mesin virtual yang terpisah, menggulung Linux di sana, dan kemudian menginstal aplikasi di Linux itu.  Ini berarti bahwa localhost bersyarat untuk wadah yang berjalan terbatas pada wadah itu sendiri, dan aplikasi tidak menyadari keberadaan jaringan lain.  Tetapi kita perlu: <br><br>  a) wadah saling bertemu. <br>  b) backend melihat database. <br><br>  Ada dua solusi untuk masalah ini. <br><br>  1. Membuat jaringan internal. <br>  2. Membawa kontainer ke level tuan rumah. <br><br>  1. Pada tingkat Docker, Anda dapat membuat jaringan, apalagi, tiga di antaranya secara default - <i>jembatan</i> , <i>tidak ada</i> , dan <i>host</i> . <br><br>  <i>Bridge</i> adalah jaringan internal Docker yang diisolasi dari jaringan host.  Anda dapat mengakses kontainer hanya melalui port yang Anda buka ketika wadah mulai dengan perintah <i>-p</i> .  Anda dapat membuat sejumlah jaringan seperti <i>jembatan</i> . <br><br><img src="https://habrastorage.org/webt/ld/sp/pf/ldsppf06sqnpf6cumhqodzsiiga.jpeg"><br><br>  <i>Tidak</i> ada jaringan terpisah untuk wadah tertentu. <br><br>  <i>Host</i> adalah jaringan host.  Saat memilih jaringan ini, kontainer Anda sepenuhnya dapat diakses melalui host - perintah <i>-p</i> tidak berfungsi di sini, dan jika Anda menggunakan kontainer ke jaringan ini, maka Anda tidak perlu menentukan port eksternal - kontainer dapat diakses oleh port internal.  Misalnya, jika Dockerfile EXPOSE diatur ke 8090, melalui port ini aplikasi akan tersedia. <br><br><img src="https://habrastorage.org/webt/ve/6r/rw/ve6rrwnis25uarwrfudc_xlps4o.jpeg"><br><br>  Karena kita perlu memiliki akses ke database server, kita akan menggunakan metode yang terakhir dan meletakkan kontainer di jaringan server jauh. <br><br>  Ini dilakukan dengan sangat sederhana, kami menghapus penyebutan port dari perintah peluncuran kontainer dan menentukan jaringan host: <br><br><pre> <code class="bash hljs">docker run --net=host xpendence/rebounder-chain-frontend:0.0.8</code> </pre> <br>  Koneksi ke pangkalan yang saya sebutkan <br><br><pre> <code class="bash hljs">localhost:3306</code> </pre> <br>  Koneksi dari depan ke belakang harus ditentukan seluruhnya, eksternal: <br><br><pre> <code class="bash hljs">http://&lt;__:__&gt;</code> </pre> <br>  Jika Anda meneruskan port internal ke port eksternal, yang sering terjadi pada server jauh, Anda perlu menentukan port internal untuk database, dan port eksternal untuk kontainer. <br><br>  Jika Anda ingin bereksperimen dengan koneksi, Anda dapat mengunduh dan membangun proyek yang saya tulis khusus untuk menguji koneksi antar kontainer.  Cukup masukkan alamat yang diinginkan, tekan Kirim dan dalam mode debug, lihat apa yang terbang kembali. <br><br>  Proyeknya ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h2>  Kesimpulan </h2><br>  Ada banyak cara untuk membangun dan menjalankan gambar Docker.  Bagi mereka yang tertarik, saya menyarankan Anda untuk belajar menulis buruh pelabuhan.  Di sini kami telah memeriksa hanya salah satu cara untuk bekerja dengan buruh pelabuhan.  Tentu saja, pendekatan ini pada awalnya tampaknya tidak begitu sederhana.  Tapi di sini adalah contoh - selama penulisan posting, saya punya koneksi keluar pada server jauh.  Dan selama proses debugging, saya harus mengubah pengaturan koneksi database beberapa kali.  Seluruh perakitan dan penyebaran sesuai dengan 4 baris saya, setelah memasukkan yang saya lihat hasilnya di server jauh.  Dalam mode pemrograman ekstrem, Docker sangat diperlukan. <br><br>  Seperti yang dijanjikan, saya memposting sumber aplikasi: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">backend</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">frontend</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id448094/">https://habr.com/ru/post/id448094/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id448080/index.html">Pemain sepak bola Robo dari pemula. Kompetisi di MIPT. Android & Arduino & Bluetooth</a></li>
<li><a href="../id448082/index.html">[Sebelum Senin] Sindrom Mata Kering</a></li>
<li><a href="../id448084/index.html">Foto lubang hitam - apakah bisa digunakan?</a></li>
<li><a href="../id448088/index.html">Produksi mesin plasma di Rusia</a></li>
<li><a href="../id448090/index.html">Frontend Weekly Digest (8 - 14 Apr 2019)</a></li>
<li><a href="../id448096/index.html">Julia dalam lateks</a></li>
<li><a href="../id448098/index.html">GHIDRA, executables Playstation 1, tanda tangan FLIRT, dan PsyQ</a></li>
<li><a href="../id448100/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 360 (7-14 April, 2019)</a></li>
<li><a href="../id448102/index.html">Tim impian dari nol: mempekerjakan profesional TI</a></li>
<li><a href="../id448106/index.html">Pelatihan pengembang 1C-Bitrix: bagikan pendekatan kami pada "pertumbuhan" personel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>