<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéì üïñ üç® Web Scraping f√ºr Webentwickler: eine kurze Zusammenfassung ‚òØÔ∏è üë©‚Äç‚úàÔ∏è üé£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie nur einen Ansatz f√ºr das Web-Scraping kennen, wird das Problem kurzfristig gel√∂st, aber alle Methoden haben ihre St√§rken und Schw√§chen. Das B...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Web Scraping f√ºr Webentwickler: eine kurze Zusammenfassung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442258/">  Wenn Sie nur einen Ansatz f√ºr das Web-Scraping kennen, wird das Problem kurzfristig gel√∂st, aber alle Methoden haben ihre St√§rken und Schw√§chen.  Das Bewusstsein daf√ºr spart Zeit und hilft, das Problem effizienter zu l√∂sen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/063/b97/2ea/063b972eae7ba278cd3b26851d97fe24.jpg" alt="Bild"><br><br>  Zahlreiche Ressourcen sprechen von der einzig wahren Methode zum Abrufen von Daten von einer Webseite.  Die Realit√§t ist jedoch, dass Sie hierf√ºr verschiedene L√∂sungen und Tools verwenden k√∂nnen. <br><br><ul><li>  Welche M√∂glichkeiten gibt es, um programmgesteuert Daten von einer Webseite abzurufen? </li><li>  Vor- und Nachteile jedes Ansatzes? </li><li>  Wie k√∂nnen Cloud-Ressourcen verwendet werden, um den Automatisierungsgrad zu erh√∂hen? </li></ul><br>  Der Artikel hilft, Antworten auf diese Fragen zu erhalten. <br><a name="habracut"></a><br>  Ich <b>gehe</b> davon aus, dass Sie bereits wissen, was <b>HTTP-</b> Anforderungen, <b>DOM</b> (Document Object Model), <b>HTML</b> , <b>CSS-Selektoren</b> und <b>Async JavaScript sind</b> . <br><br>  Wenn nicht, rate ich Ihnen, sich mit der Theorie zu befassen und dann zum Artikel zur√ºckzukehren. <br><br><h3>  Statischer Inhalt </h3><br>  <b>HTML-Quellen</b> <br><br>  Beginnen wir mit dem einfachsten Ansatz. <br><br>  Wenn Sie Webseiten verschrotten m√∂chten, ist dies das erste, mit dem Sie beginnen.  Es erfordert wenig Computerleistung und ein Minimum an Zeit. <br><cut></cut><br>  Dies funktioniert jedoch nur, wenn der HTML-Quellcode die Daten enth√§lt, auf die Sie abzielen.  Um dies in Chrome zu testen, klicken Sie mit der rechten Maustaste auf die Seite und w√§hlen Sie Seitencode anzeigen.  Sie sollten jetzt den HTML-Quellcode sehen. <br><br>  Wenn Sie die Daten gefunden haben, schreiben Sie einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CSS-Selektor</a> , der zum Wrapping-Element geh√∂rt, damit Sie sp√§ter einen Link haben. <br><br>  Zur Implementierung k√∂nnen Sie eine HTTP-GET-Anforderung an die URL der Seite senden und den HTML-Quellcode zur√ºckerhalten. <br><br>  In <b>Node k√∂nnen</b> Sie das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CheerioJS-</a> Tool verwenden, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">um</a> Roh-HTML zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">analysieren</a> und Daten mithilfe eines Selektors abzurufen.  Der Code sieht folgenderma√üen aus: <br><cut></cut><br><pre><code class="plaintext hljs">const fetch = require('node-fetch'); const cheerio = require('cheerio'); const url = 'https://example.com/'; const selector = '.example'; fetch(url) .then(res =&gt; res.text()) .then(html =&gt; { const $ = cheerio.load(html); const data = $(selector); console.log(data.text()); });</code> </pre> <br><h3>  Dynamischer Inhalt </h3><br>  In vielen F√§llen k√∂nnen Sie nicht auf Informationen aus rohem HTML-Code zugreifen, da das DOM von JavaScript gesteuert wurde, das im Hintergrund ausgef√ºhrt wird.  Ein typisches Beispiel hierf√ºr ist ein SPA (Single-Page-Anwendung), bei dem ein HTML-Dokument nur minimale Informationen enth√§lt und diese zur Laufzeit von JavaScript ausgef√ºllt werden. <br><br>  In dieser Situation besteht die L√∂sung darin, das DOM zu erstellen und die im HTML-Quellcode enthaltenen Skripts auszuf√ºhren, wie dies der Browser tut.  Danach k√∂nnen Daten mit Selektoren aus diesem Objekt extrahiert werden. <br><cut></cut><br>  <b>Headless Browser</b> <br><br>  Der kopflose Browser ist der gleiche wie ein normaler Browser, nur ohne Benutzeroberfl√§che.  Es wird im Hintergrund ausgef√ºhrt und kann programmgesteuert gesteuert werden, anstatt √ºber die Tastatur zu klicken und zu tippen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Puppenspieler ist</a> einer der beliebtesten Headless-Browser.  Dies ist eine benutzerfreundliche Knotenbibliothek, die eine allgemeine API f√ºr die Offline-Verwaltung von Chrome bietet.  Es kann so konfiguriert werden, dass es ohne Header ausgef√ºhrt wird, was w√§hrend der Entwicklung sehr praktisch ist.  Der folgende Code macht dasselbe wie zuvor, funktioniert jedoch mit dynamischen Seiten: <br><br><pre> <code class="plaintext hljs">const puppeteer = require('puppeteer'); async function getData(url, selector){ const browser = await puppeteer.launch(); const page = await browser.newPage(); await page.goto(url); const data = await page.evaluate(selector =&gt; { return document.querySelector(selector).innerText; }, selector); await browser.close(); return data; } const url = 'https://example.com'; const selector = '.example'; getData(url,selector) .then(result =&gt; console.log(result));</code> </pre> <br>  Nat√ºrlich k√∂nnen Sie mit Puppeteer interessantere Dinge tun, lesen Sie also die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> .  Hier ist ein Codeausschnitt, der durch die URL navigiert, einen Screenshot macht und ihn speichert: <br><br><pre> <code class="plaintext hljs">const puppeteer = require('puppeteer'); async function takeScreenshot(url,path){ const browser = await puppeteer.launch(); const page = await browser.newPage(); await page.goto(url); await page.screenshot({path: path}); await browser.close(); } const url = 'https://example.com'; const path = 'example.png'; takeScreenshot(url, path);</code> </pre> <br>  Der Browser ben√∂tigt viel mehr Rechenleistung als das Senden einer einfachen GET-Anfrage und das Analysieren der Antwort.  Daher ist die Ausf√ºhrung relativ langsam.  Nicht nur das, sondern auch das Hinzuf√ºgen eines Browsers als Abh√§ngigkeit macht das Paket massiv. <br><cut></cut><br>  Andererseits ist diese Methode sehr flexibel.  Sie k√∂nnen damit Seiten navigieren, Klicks und Mausbewegungen simulieren und die Tastatur verwenden, Formulare ausf√ºllen, Screenshots erstellen oder PDF-Seiten erstellen, Befehle in der Konsole ausf√ºhren und Elemente zum Extrahieren von Textinhalten ausw√§hlen.  Grunds√§tzlich alles, was manuell in einem Browser erledigt werden kann. <br><br>  <b>Ein DOM bauen</b> <br><br>  Sie werden denken, dass es nicht notwendig ist, einen ganzen Browser zu simulieren, nur um ein DOM zu erstellen.  Tats√§chlich ist dies zumindest unter bestimmten Umst√§nden der Fall. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jsdom</a> ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Knotenbibliothek</a> , die das √ºbertragene HTML analysiert, genau wie ein Browser.  Dies ist jedoch kein Browser, sondern ein <i>Tool zum Erstellen des DOM aus einem bestimmten HTML-Quellcode</i> sowie zum Ausf√ºhren von JavaScript-Code in diesem HTML. <br><br>  Dank dieser Abstraktion kann Jsdom schneller als ein kopfloser Browser ausgef√ºhrt werden.  Wenn es schneller ist, warum nicht die ganze Zeit anstelle von Headless-Browsern verwenden? <br><cut></cut><br>  <i>Zitat aus der Dokumentation</i> : <br><blockquote>  Bei der Verwendung von jsdom treten h√§ufig Probleme beim asynchronen Laden von Skripten auf.  Viele Seiten laden Skripte asynchron, aber es ist unm√∂glich zu bestimmen, wann dies passiert ist und wann der Code ausgef√ºhrt und die resultierende DOM-Struktur √ºberpr√ºft werden muss.  Dies ist eine grundlegende Einschr√§nkung. </blockquote><br>  Diese L√∂sung ist im Beispiel dargestellt.  Alle 100 ms wird √ºberpr√ºft, ob ein Element aufgetreten ist oder eine Zeit√ºberschreitung aufgetreten ist (nach 2 Sekunden). <br><br>  Es werden auch h√§ufig Fehlermeldungen ausgegeben, wenn Jsdom einige Browserfunktionen auf der Seite nicht implementiert, z. <i>B</i> .: " <i>Fehler: Nicht implementiert: window.alert ..." oder "Fehler: Nicht implementiert: window.scrollTo ...</i> ".  Dieses Problem kann auch mit einigen Problemumgehungen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">virtuellen Konsolen</a> ) gel√∂st werden. <br><br>  Dies ist normalerweise eine API auf niedrigerer Ebene als Puppeteer, daher m√ºssen Sie einige Dinge selbst implementieren. <br><br>  Dies erschwert die Verwendung ein wenig, wie aus dem Beispiel hervorgeht.  <i>Jsdom</i> bietet eine schnelle L√∂sung f√ºr denselben Job. <br><cut></cut><br>  Schauen wir uns das gleiche Beispiel an, aber mit <i>Jsdom</i> : <br><br><pre> <code class="plaintext hljs">const jsdom = require("jsdom"); const { JSDOM } = jsdom; async function getData(url,selector,timeout) { const virtualConsole = new jsdom.VirtualConsole(); virtualConsole.sendTo(console, { omitJSDOMErrors: true }); const dom = await JSDOM.fromURL(url, { runScripts: "dangerously", resources: "usable", virtualConsole }); const data = await new Promise((res,rej)=&gt;{ const started = Date.now(); const timer = setInterval(() =&gt; { const element = dom.window.document.querySelector(selector) if (element) { res(element.textContent); clearInterval(timer); } else if(Date.now()-started &gt; timeout){ rej("Timed out"); clearInterval(timer); } }, 100); }); dom.window.close(); return data; } const url = "https://example.com/"; const selector = ".example"; getData(url,selector,2000).then(result =&gt; console.log(result));</code> </pre> <br>  <b>Reverse Engineering</b> <br><br>  Jsdom ist eine schnelle und einfache L√∂sung, aber Sie k√∂nnen es noch einfacher machen. <br><br>  M√ºssen wir das DOM modellieren? <br><cut></cut><br>  Die Webseite, die Sie verschrotten m√∂chten, besteht aus demselben HTML und JavaScript, denselben Technologien, die Sie bereits kennen.  <i>Wenn Sie also einen Code finden, aus dem die Zieldaten abgerufen wurden, k√∂nnen Sie denselben Vorgang wiederholen, um dasselbe Ergebnis zu erzielen</i> . <br><br>  Zur Vereinfachung k√∂nnen folgende Daten gesucht werden: <br><br><ul><li>  Teil des HTML-Quellcodes (wie aus dem ersten Teil des Artikels ersichtlich), </li><li>  Teil einer statischen Datei, auf die in einem HTML-Dokument verwiesen wird (z. B. eine Zeile in einer Javascript-Datei), </li><li>  Antwort auf eine Netzwerkanforderung (z. B. hat ein JavaScript-Code eine AJAX-Anforderung an einen Server gesendet, der mit einer JSON-Zeichenfolge geantwortet hat). </li></ul><br>  <i>Auf diese Datenquellen kann √ºber Netzwerkabfragen zugegriffen werden</i> .  Es spielt keine Rolle, ob die Webseite HTTP, WebSockets oder ein anderes Kommunikationsprotokoll verwendet, da alle theoretisch reproduzierbar sind. <br><br>  Sobald Sie eine Ressource mit Daten gefunden haben, k√∂nnen Sie eine √§hnliche Netzwerkanforderung an denselben Server wie auf der Originalseite senden.  Als Ergebnis erhalten Sie eine Antwort mit den Zieldaten, die einfach mit regul√§ren Ausdr√ºcken, Zeichenfolgenmethoden, JSON.parse usw. extrahiert werden k√∂nnen. <br><cut></cut><br>  Mit einfachen Worten, Sie k√∂nnen die Ressource verwenden, auf der sich die Daten befinden, anstatt das gesamte Material zu verarbeiten und zu laden.  Somit kann das in den vorherigen Beispielen gezeigte Problem mit einer einzelnen HTTP-Anforderung gel√∂st werden, anstatt einen Browser oder ein komplexes JavaScript-Objekt zu steuern. <br><br>  Diese L√∂sung scheint theoretisch einfach zu sein, kann jedoch in den meisten F√§llen zeitaufw√§ndig sein und erfordert Erfahrung mit Webseiten und Servern. <br><br>  Beginnen Sie mit der √úberwachung des Netzwerkverkehrs.  Ein gro√üartiges Tool hierf√ºr ist die Registerkarte " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Netzwerk" in Chrome DevTools</a> .  Sie sehen alle ausgehenden Anforderungen mit Antworten (einschlie√ülich statischer Dateien, AJAX-Anforderungen usw.), um sie zu durchlaufen und nach Daten zu suchen. <br><br>  Wenn die Antwort durch einen Code ge√§ndert wird, bevor sie auf dem Bildschirm angezeigt wird, ist der Vorgang langsamer.  In diesem Fall m√ºssen Sie diesen Teil des Codes finden und verstehen, was los ist. <br><br>  Wie Sie sehen k√∂nnen, erfordert eine solche Methode m√∂glicherweise viel mehr Arbeit als die oben beschriebenen Methoden.  Auf der anderen Seite bietet es die beste Leistung. <br><br>  Das Diagramm zeigt die erforderliche Laufzeit und Paketgr√∂√üe im Vergleich zu Jsdom und Puppeteer: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/90f/d44/8a2/90fd448a2eff0e71b2980b20b1ef0936.jpg" alt="Bild"><br><br>  Die Ergebnisse basieren nicht auf genauen Messungen und k√∂nnen variieren, zeigen jedoch gute ungef√§hre Unterschiede zwischen diesen Methoden. <br><br><h3>  Cloud-Service-Integration </h3><br>  Angenommen, Sie haben eine dieser L√∂sungen implementiert.  Eine M√∂glichkeit, das Skript auszuf√ºhren, besteht darin, den Computer einzuschalten, das Terminal zu √∂ffnen und manuell zu starten. <br><br>  Es wird jedoch √§rgerlich und ineffizient. Daher ist es besser, wenn Sie das Skript einfach auf den Server hochladen und den Code abh√§ngig von den Einstellungen regelm√§√üig ausf√ºhren. <br><cut></cut><br>  Dies kann durch Starten des eigentlichen Servers und Festlegen der Regeln f√ºr die Ausf√ºhrung des Skripts erfolgen.  In anderen F√§llen ist die Cloud-Funktion einfacher. <br><br>  Cloud-Funktionen sind Speicher, in denen heruntergeladener Code ausgef√ºhrt wird, wenn ein Ereignis eintritt.  Dies bedeutet, dass Sie die Server nicht verwalten m√ºssen. Dies wird automatisch von Ihrem Cloud-Anbieter durchgef√ºhrt. <br><br>  Ein Ausl√∂ser kann ein Zeitplan, eine Netzwerkanforderung und viele andere Ereignisse sein.  Sie k√∂nnen die gesammelten Daten in einer Datenbank speichern, in ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Google-Blatt</a> schreiben oder per <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">E-Mail</a> senden.  Es h√§ngt alles von Ihrer Vorstellungskraft ab. <br><br>  Beliebte Cloud-Anbieter - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Amazon Web Services</a> (AWS), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Google Cloud Platform</a> (GCP) und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Microsoft Azure</a> : <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AWS Lambda</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gcp Cloud-Funktionen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Azure-Funktionen</a> </li></ul><br>  Sie k√∂nnen diese Dienste kostenlos, aber nicht lange nutzen. <br><br>  Wenn Sie Puppeteer verwenden, sind <i>Google</i> Cloud- <i>Funktionen</i> die einfachste L√∂sung.  Die Paketgr√∂√üe im Headless Chrome-Format (~ 130 MB) √ºberschreitet die maximal zul√§ssige Archivgr√∂√üe in AWS Lambda (50 MB).  Es gibt verschiedene Methoden, damit es mit Lambda funktioniert, aber GCP-Funktionen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unterst√ºtzen</a> standardm√§√üig <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chrome ohne Header</a> . Sie m√ºssen Puppeteer lediglich als Abh√§ngigkeit in <i>package.json einf√ºgen</i> . <br><br>  Wenn Sie mehr √ºber Cloud-Funktionen im Allgemeinen erfahren m√∂chten, lesen Sie die Architekturinformationen ohne Server.  Zu diesem Thema wurden bereits viele gute Tutorials geschrieben, und die meisten Anbieter verf√ºgen √ºber eine leicht verst√§ndliche Dokumentation. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442258/">https://habr.com/ru/post/de442258/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442244/index.html">Rust 1.33 Release</a></li>
<li><a href="../de442248/index.html">Die NASA genehmigte den unbemannten Teststart von Dragon-2</a></li>
<li><a href="../de442250/index.html">Reagieren und Vue: St√§rken</a></li>
<li><a href="../de442252/index.html">Python-Code-Lebenszyklus - CPython-Laufzeitmodell</a></li>
<li><a href="../de442256/index.html">Digitale Verteidigung vor der Plastikwelt der heimischen Internetregulierungsbeh√∂rden</a></li>
<li><a href="../de442260/index.html">10 Git-Befehle, die ein Entwickler kennen sollte</a></li>
<li><a href="../de442262/index.html">Geheimnis der Firmware</a></li>
<li><a href="../de442264/index.html">Beseitigung von M√∂glichkeiten zur Entf√ºhrung von Verkehr</a></li>
<li><a href="../de442266/index.html">Delta Chat - dezentraler Messenger √ºber E-Mail</a></li>
<li><a href="../de442268/index.html">AsyncIO Micropython: Synchronisationsmethoden in der asynchronen Programmierung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>