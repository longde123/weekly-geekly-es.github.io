<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛍️ 🚣🏽 🙅🏿 Die Architektur des verteilten Nachrichtenwarteschlangendienstes in Yandex.Cloud 🎅🏾 ⏺️ 👶🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo, ich heiße Vasily Bogonatov. Ich bin einer von denen, die meine Hand und meinen Kopf legen und meine Seele in den Dienst verteilter persistenter...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Architektur des verteilten Nachrichtenwarteschlangendienstes in Yandex.Cloud</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/455642/"> Hallo, ich heiße Vasily Bogonatov.  Ich bin einer von denen, die meine Hand und meinen Kopf legen und meine Seele in den Dienst verteilter persistenter Nachrichtenwarteschlangen der Yandex Message Queue stellen.  Der Dienst ging Ende Mai an die Börse, wurde jedoch in Yandex seit langem aktiv in verschiedenen Produkten eingesetzt. <br><br>  Heute möchte ich Habrs Lesern von Nachrichtenwarteschlangen im Allgemeinen und von Yandex Message Queue im Besonderen erzählen.  Zunächst möchte ich erklären, was eine "verteilte Warteschlange für persistente Nachrichten" ist und warum sie benötigt wird.  Zeigen Sie den praktischen Wert, die Mechanik der Arbeit mit Nachrichten, sprechen Sie über die API und die Benutzerfreundlichkeit.  In der zweiten Hälfte des Artikels werden wir uns mit der technischen Seite befassen: Wie wird die Yandex-Datenbank in unseren Warteschlangen verwendet (dies ist eine zuverlässige Grundlage unseres Service), wie sieht ein naiver und verbesserter Ansatz zum Erstellen einer Architektur aus, welche Probleme werden durch die Verteilung verursacht und wie können sie gelöst werden. <br><br><img src="https://habrastorage.org/webt/xy/ht/eb/xyhtebqslkofciotlmohtwlopb4.png"><br><a name="habracut"></a><br><h3>  Was ist eine verteilte Warteschlange für persistente Nachrichten? </h3><br>  Wikipedia definiert die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nachrichtenwarteschlange</a> als "Software-Engineering-Komponente, die für die Interprozess- oder Inter-Thread-Interaktion innerhalb eines Prozesses verwendet wird".  Tatsächlich ist dieses Konzept etwas umfassender: Prozesse, die über eine Warteschlange interagieren, können sich auf verschiedenen Servern und sogar in verschiedenen Rechenzentren befinden. <br><br>  Wir werden die Begriffe etwas klären. <br><br>  <b>Eine Nachrichtenwarteschlange</b> ist ein Repository, das das Platzieren und Lesen von Daten in einer bestimmten Reihenfolge ermöglicht. <br><br>  Zwei Arten von Entitäten interagieren normalerweise mit einer Warteschlange: <br><br><ul><li>  <b>Autoren (Produzenten)</b> - Nachrichten an die Warteschlange senden; </li><li>  <b>Leser (Verbraucher)</b> - Empfangen (Lesen) von Nachrichten aus der Warteschlange. </li></ul><br>  Bei Verwendung der Warteschlange sind Leser und Schreiber unabhängig voneinander.  Sie können mit unterschiedlicher Leistung, Zuverlässigkeit und Verfügbarkeit arbeiten und können sogar in verschiedenen Programmiersprachen geschrieben werden. <br><br>  Das Hauptszenario für die Warteschlange: Nachrichten vom Schreiber zuverlässig und schnell an den Leser übertragen.  Im Gegensatz zur Datenbank ist die Warteschlange nicht für die Langzeitspeicherung von Nachrichten vorgesehen.  In vielen gängigen Implementierungen gibt es einen entsprechenden Parameter - "Nachrichtenaufbewahrungszeitraum".  Es bestimmt, wie lange die Nachricht gespeichert wird, bis sie dauerhaft gelöscht wird. <br><br>  Wir haben das Konzept der Warteschlange herausgefunden, gehen zu "Verteilung" und "Persistenz". <br><br><ul><li>  <b>Verteilung bedeutet</b> in unserem Fall das Vorhandensein eines Clusters, der Daten und Warteschlangenmetadaten speichert und verarbeitet und alle seine Knoten mithilfe eines Computernetzwerks zu einem Ganzen zusammenfasst. </li><li>  <b>Persistenz</b> bedeutet, dass alle Nachrichten in der Warteschlange auf die Festplatte geschrieben werden und der Schreiber erst nach erfolgreicher Aufzeichnung eine Bestätigung des Sendens erhält. </li></ul><br>  Verteilung und Persistenz wirken sich nicht auf die Hauptfunktionalität der Warteschlange aus, sondern bieten Fehlertoleranz und Zuverlässigkeit der Datenspeicherung.  Welche Arten von Fehlern in unserem System auftreten können, werden wir etwas später prüfen.  Ich kann mir jedoch das Vergnügen nicht verweigern und die Karten ein wenig öffnen: In der gesamten Geschichte der Existenz des Dienstes haben wir keine einzige gespeicherte Nachricht vom Kunden verloren. <br><br><h3>  Wofür ist die Nachrichtenwarteschlange? </h3><br>  Die Warteschlange ermöglicht es Ihnen, die logisch unabhängigen Teile von Diensten voneinander zu trennen, dh sie bietet eine <b>Entkopplung</b> , die in den heute gängigen Mikrodiensten so gefragt ist.  Dies erhöht die Skalierbarkeit und Zuverlässigkeit: Sie können jederzeit den Datenstrom in der Warteschlange erhöhen und mehr Leser hinzufügen - Nachrichtenhandler, während der Ausfall von Lesern die Arbeit der Autoren nicht beeinträchtigt. <br><br>  Warteschlangen glätten Spitzenlasten: Sie dienen als Puffer für Leser.  Wenn die aktuellen Leserkapazitäten nicht für die sofortige Verarbeitung aller eingehenden Nachrichten ausreichen, werden die Nachrichten in der Warteschlange später verarbeitet, wenn die Last abnimmt.  Das Puffern ist nützlich für Dienste mit einer instabilen Last, bei denen keine sofort eingehenden Ereignisse erforderlich sind. <br><br>  Lassen Sie uns am Beispiel eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Suchroboters</a> (schließlich hat Yandex mit einer Suche begonnen!) Sehen, wie Webseiten heruntergeladen, verarbeitet und in eine Datenbank gestellt werden.  Nehmen wir eine solche Architektur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zo/oe/dh/zooedh0t0qs4uu1lhpdc0psa2qi.png" width="600" height="778"></div><br><br>  Die Nachrichtenwarteschlange löst hier die folgenden Probleme: <br><br><ol><li>  Der Roboter arbeitet viel schneller als die Mitarbeiter, die für das Parsen und Laden von Seiten in die Datenbank verantwortlich sind.  Außerhalb der Linie würden sich Links ansammeln und den verfügbaren Speicher oder die verfügbare Festplatte füllen.  Das gleiche würde passieren, wenn die Arbeiter vorübergehend nicht verfügbar wären. </li><li>  Ohne Warteschlange muss der Roboter die Arbeitsoberfläche der Mitarbeiter „kennen“, um ihnen Aufgaben zuweisen zu können.  Die Benutzeroberfläche kann sich während der Produktentwicklung ändern. </li><li>  Ein einzelner Mitarbeiter hat eine relativ geringe Zuverlässigkeit, daher gibt es keine Garantie dafür, dass die übertragene Verbindung von ihm vollständig verarbeitet wird. </li></ol><br>  Die Warteschlange bietet zuverlässige Datenspeicherung mit Skalierung und ermöglicht es Ihnen, die Verarbeitung von Links zu verzögern.  Wenn ein Mitarbeiter ausfällt, wird die unformatierte Verknüpfung nach einer bestimmten Zeit zur Verarbeitung durch einen anderen Mitarbeiter in die Warteschlange zurückgeführt.  Die Warteschlange verfügt über eine eigene Schnittstelle, die in der Dokumentation getestet und beschrieben wird, sodass Suchroboter- und Arbeitersysteme unterschiedliche Teams in unterschiedlichen Programmiersprachen entwickeln können.  Dies hat keinen Einfluss auf die Gesamtleistung. <br><br><h3>  Funktionsweise der Yandex Message Queue mit Nachrichten </h3><br>  Hier können drei Hauptstufen unterschieden werden: <br><br><ul><li>  <b>Schreiben einer</b> Nachricht in die Warteschlange; </li><li>  <b>Lesen einer</b> Nachricht aus der Warteschlange; </li><li>  <b>Entfernen einer</b> Nachricht aus der Warteschlange. </li></ul><br>  Ein Datensatz gilt als erfolgreich, wenn die Nachricht sicher gespeichert wurde und den Lesern bald zur Verfügung steht.  Eine Deduplizierungsaufzeichnung ist möglich: Wenn ein wiederholter Versuch, eine gesendete Nachricht aufzuzeichnen, ignoriert wird. <br><br>  Zum Zeitpunkt des Lesens wird die Nachricht für einen Zeitraum, der als Sichtbarkeitszeitlimit bezeichnet wird, aus der Warteschlange ausgeblendet und ist für andere Leser nicht mehr zugänglich.  Wenn das Sichtbarkeitszeitlimit abläuft, kehrt die Nachricht in die Warteschlange zurück und steht wieder zur Verarbeitung zur Verfügung.  Die Reihenfolge, in der Nachrichten gelesen werden, wird von der Warteschlange und nicht vom Leser bestimmt. <br><br>  Der Leser selbst und die Netzwerkverbindung mit ihm sind möglicherweise unzuverlässig.  Ein Sichtbarkeitszeitlimit ist erforderlich, um eine Nachricht an die Warteschlange zurückgeben zu können, wenn der Reader abstürzt oder die Verbindung getrennt wird.  Andernfalls ist es wahrscheinlich, dass eine einzelne Nachricht niemals korrekt verarbeitet wird. <br><br>  Nach erfolgreichem Lesen wird die Nachricht mit der Kennung ReceiptHandle an den Client übertragen.  Ein Bezeichner gibt bestimmte Daten an, die aus der Nachrichtenwarteschlange entfernt werden sollen. <br><br><h3>  Warteschlangentypen in der Yandex-Nachrichtenwarteschlange </h3><br>  Der erste und am häufigsten verwendete Typ ist die Standardwarteschlange.  Es zeichnet sich durch einen hohen Durchsatz (Tausende von Nachrichten pro Sekunde), eine hervorragende Leistung und eine kurze Ausführungszeit für grundlegende Vorgänge aus.  Standardwarteschlangen bestehen aus logischen Shards und unterstützen eine nahezu lineare Bandbreitenskalierung. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wy/p0/jp/wyp0jpi_pmhorpq2mikwm_mgl-u.png"></div><br>  Standardwarteschlangen unterstützen keine Deduplizierung von Nachrichten beim Schreiben in eine Warteschlange und garantieren keine Lesereihenfolge.  Aufgrund der Verwendung von Sharding gibt eine Leseanforderung möglicherweise keine einzelne Nachricht zurück, selbst wenn sie sich in der Warteschlange befindet.  Meistens geschieht dies im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kurzabfragemodus</a> , wenn das Lesen von einem zufällig ausgewählten Shard stammt. <br><br>  Der zweite Typ - <abbr title="First in first out">FIFO</abbr> - ist das Gegenteil der Standardwarteschlange.  Es bietet eine strikte Lesereihenfolge, unterstützt die Deduplizierung beim Schreiben und wiederholte Versuche, Nachrichten zu lesen.  Leistung und Skalierbarkeit sind niedriger als Standard.  Die Leistung der FIFO-Warteschlange ist auf 30 Anforderungen pro Sekunde begrenzt.  Es wird empfohlen, FIFO zu verwenden, wenn Sie versuchen müssen, die Übermittlungssemantik „genau einmal“ sicherzustellen.  Normalerweise bedeutet das Wort "Warteschlange" FIFO. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yr/jy/l5/yrjyl5kbyfzqzkruqhaoqdrsxzs.png" width="421" height="801"></div><br><h3>  Yandex Message Queue API </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">API</a> ist ein äußerst wichtiger Bestandteil jedes Produkts.  Eine gute Softwareschnittstelle sollte einfach und unkompliziert sein und für eine effektive Verwendung nur minimale Kenntnisse der Dokumentation erfordern.  Sollte es nicht zulassen, seltsame oder unnötige Handlungen durchzuführen und sich vor dummen Fehlern zu schützen, sollte die Verletzung des „Vertrags“ rechtzeitig gemeldet werden. <br><br>  Wenn das System über eine solche API verfügt, empfängt es schnell treue Benutzer und ist von praktischen „Wrappern“ für verschiedene Plattformen und Programmiersprachen umgeben. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Amazon Simple Queue Service-API (AWS SQS-API)</a> ist ein Beispiel für eine solche Schnittstelle, die nach Zeit und einer großen Anzahl von Clients getestet wurde.  Aus diesem Grund haben wir beschlossen, keine eindeutige Schnittstelle für die Yandex Message Queue zu erfinden, sondern die Unterstützung für die AWS SQS-API sehr sorgfältig implementiert. <br><br>  In den meisten Fällen reicht es für den SQS-Benutzer aus, den Endpunkt (Dienstadresse) und die Region zu ändern (derzeit verwenden wir nur "ru-central1") und neue Anmeldeinformationen in Yandex.Cloud abzurufen.  Alles andere, z. B. ein Skript, das die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AWS-Befehlszeile verwendet</a> , Code, der das AWS SDK verwendet, oder ein vorgefertigter Dienst für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sellerie</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Boto</a> , wird höchstwahrscheinlich nicht berührt.  Die Logik und Funktionalität des Warteschlangendienstes bleiben unverändert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_r/td/kn/_rtdknyixiytyqo63khne5gz4uq.png"></div><br>  Eine ausführliche Beschreibung der Yandex Message Queue-API-Methoden finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Servicedokumentation</a> . <br><br><h3>  Ein wenig über Bequemlichkeit </h3><br>  Yandex Message Queue ist ein verwalteter Dienst, dh Yandex. Die Cloud ist für den Betrieb von Servern und Software verantwortlich.  Das Serviceteam überwacht den Zustand der Warteschlangen, ersetzt ausgefallene Festplatten schnell, beseitigt Netzwerkunterbrechungen und führt Aktualisierungen durch.  Das Update beendet den Dienst nicht: Während wir die neue Version von YMQ auf einer Gruppe von Servern installieren, leitet der Load Balancer den Datenverkehr sorgfältig an andere weiter.  Benutzer bemerken also nichts. <br><br>  Um Ihnen die Steuerung des Betriebs der Warteschlangen zu erleichtern, haben wir YMQ eine große Anzahl visueller Diagramme hinzugefügt. Nur ein kleiner Teil davon wird hier angezeigt.  Diagramme befinden sich in der Yandex.Cloud-Konsole im Abschnitt "Statistik". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bi/cp/nn/bicpnn5tjwzqustzy9ye5abnrho.png"></div><br>  Wir werden Sie über die vier unserer Meinung nach nützlichsten Grafiken informieren: <br><br><ul><li>  Mit dem <b>Diagramm „Nachrichten</b> in der Warteschlange <b>“ können</b> Sie die Ansammlung von Daten in der Warteschlange überwachen.  Ein Wachstum im Diagramm kann bedeuten, dass die Handler die Last nicht verwalten oder die Verarbeitung gestoppt wurde. </li><li>  Grafik <b>"Alter der ältesten Nachricht in der Warteschlange"</b> : Große Werte weisen auf Probleme bei der Nachrichtenverarbeitung hin.  Wenn alles richtig funktioniert, sollten Nachrichten nicht lange in der Warteschlange stehen. </li><li>  Die Grafik <b>„Anzahl der Leseversuche einer Nachricht“</b> zeigt, wann Nachrichten mehrmals gelesen werden.  Dies kann bedeuten, dass die Handler abstürzen, wenn sie einige Nachrichten empfangen. </li><li>  Das Diagramm <b>"Warteschlangenzeit"</b> gibt an, wie viel Zeit vom Senden der Nachricht an die Warteschlange bis zum Empfang durch den Handler vergeht. </li></ul><br>  Mithilfe von Diagrammen können Sie die Dynamik der Warteschlange und das Vorhandensein von Fehlern sofort bewerten, ohne dass Protokolle angezeigt werden müssen. <br><br>  Wir haben mehr oder weniger allgemeine Punkte besprochen. Kommen wir nun zu den Details. <br><br><h3>  Wie die Yandex-Datenbankwarteschlange die Yandex-Datenbank verwendet </h3><br>  Der Yandex Message Queue-Dienst basiert auf der geoverteilten fehlertoleranten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Yandex Database (YDB) -Datenbank</a> , die strikte Konsistenz und Unterstützung für ACID-Transaktionen bietet.  Wir werden das Gerät und die Eigenschaften jetzt nicht zerlegen, sondern uns auf das allgemeine Schema beschränken. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uq/5m/o3/uq5mo3fm83hovqxkgt7no-yjevg.png" width="742" height="860"></div><br>  Eine Warteschlange in YMQ besteht aus logischen Shards, die durch einen festen Satz von YDB-Tabellen dargestellt werden.  Jede Tabelle speichert ihre eigenen Informationen.  Beispielsweise gibt es eine allgemeine Statustabelle namens State, in der Offs und die tatsächliche Anzahl von Nachrichten gespeichert sind.  Es gibt eine Tabelle mit Daten- und Nachrichtenmetadaten.  Es gibt eine Tabelle mit verwandten Attributen. <br><br>  Alle Hauptoperationen mit der Warteschlange - Arbeiten mit Nachrichten, Ändern von Attributen, Erstellen und Löschen - funktionieren mit der Hierarchie von Tabellen und YDB-Verzeichnissen oder mit Transaktionsabfragen an eine oder mehrere Tabellen der Warteschlange.  Die Daten in den Warteschlangentabellen sind die Quelle der absoluten Wahrheit.  Daher ist es neben dem korrekten und stabilen Betrieb der Datenbank erforderlich, eine zuverlässige Speicherung und eine hohe Datenverfügbarkeit sicherzustellen. <br><br>  Unsere Informationen werden in mehreren Replikaten gespeichert: eine Kopie in jedem der drei Yandex-Rechenzentren.  Wenn eines der Rechenzentren nicht verfügbar ist, verdoppelt sich die Anzahl der Replikate in den verbleibenden.  Somit wird das erforderliche Maß an Zuverlässigkeit wiederhergestellt.  Selbst wenn ein gesamtes Rechenzentrum und ein Service Desk in einem anderen ausfallen, sind die Daten vollständig zugänglich. <br><br><h3>  Die erste Version der Yandex Message Queue-Architektur </h3><br>  So sah die erste Version der YMQ-Architektur aus, die wir selbst als naiv bezeichneten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/aj/qc/eu/ajqceuaoisynocw4u3ffek3epjo.png"></div><br>  Das Diagramm zeigt den Pfad der HTTPS-Anforderung vom YMQ-Client zum YDB-Repository.  Schauen wir uns die Hauptkomponenten an: <br><br><ol><li>  Der L3-Balancer sendet eine Anfrage an das Yandex-Rechenzentrum, das dem Benutzer am nächsten liegt.  Dies reduziert die Netzwerklatenz, obwohl die Last ungleichmäßig verteilt ist. </li><li>  Nginx auf der virtuellen Yandex.Cloud-Maschine beendet HTTPS-Verbindungen, bietet Schutz vor Netzwerkangriffen und leitet die Anforderung weiter an den YMQ-Server weiter, der sich bereits in HTTP befindet. </li><li>  Der YMQ-HTTP-Server implementiert die SQS-HTTP-API-Logik, validiert die Anforderung und übersetzt sie in ein stark typisiertes Protobuf-Format. </li><li>  YMQ Akteursystem - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Akteursystem</a> .  Gleichzeitig wurden Tausende verschiedener Akteure ins Leben gerufen, die Informationen austauschen.  Das Akteursystem jedes Hosts ist Teil eines Clusters.  Alle Akteure im Cluster leben und agieren als Ganzes.  Die YMQ-Geschäftslogik ist in verschiedenen Akteuren implementiert, die an Transaktionsanforderungen an YDB beteiligt sind. </li><li>  YDB-Tablets ("Tablets") - Teil der Kern-YDB, die für die Arbeit mit Tabellen in Abfragen und Transaktionen verantwortlich ist.  Die Tablets selbst speichern keine Daten.  Dies sind Kontrollstrukturen im Speicher, die bei einem Hardwarefehler den Status wiederherstellen können. </li><li>  Speicher ist ein zuverlässiger, verteilter und fehlertoleranter Speicher. </li></ol><br>  Diese Architektur hat einen Nachteil: Alle Server im Cluster arbeiten unabhängig voneinander mit Tabellen derselben Warteschlange.  Dies wirkt sich negativ auf die Leistung aus und verhindert die Organisation zuverlässiger Caches für versteckte und lesbare Nachrichten.  Es ist schwierig, den Anforderungsfluss zu begrenzen, und dies ist für jeden hoch ausgelasteten Dienst sehr wichtig. <br><br><h3>  Yandex Message Queue-Architektur mit Warteschlangenmastern </h3><br>  Das Auslösen von Lasten zeigte, dass die erste Version der Architektur mit einem Shard etwa 450 Nachrichten pro Sekunde und Warteschlange standhält.  Es war sehr klein. <br>  Das Hauptproblem waren Streitfragen.  Eine große Anzahl logisch widersprüchlicher Transaktionen brachte versteckte Nachrichten-Caches schnell in einen inkonsistenten Zustand.  Um das Problem zu lösen, haben wir eine spezielle Entität eingeführt - den Warteschlangenmaster. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gc/b4/om/gcb4omkmhk28uhwe2hrlewhzsig.png"></div><br>  <b>Ein Warteschlangenmaster</b> ist ein Akteur, der unter normalen Bedingungen in einem Cluster in einer einzelnen Instanz vorhanden ist und alle Anforderungen durchläuft, die einer bestimmten Warteschlange zugeordnet sind.  Wenn eine Anforderung an die Warteschlange bei einem Server ankommt, auf dem der gewünschte Master fehlt, leitet ein spezieller Proxy-Akteur die Anforderung um und übersetzt dann die vom Master empfangene Antwort zurück. <br><br>  Bei Verwendung des Warteschlangenassistenten reduziert der korrekte Cache entsperrter Nachrichten die Konflikte bei der Arbeit mit Tabellen.  Die Implementierung der Einschränkung des Anforderungsflusses wird beispielsweise durch den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Leaky-Bucket</a> vereinfacht.  Es stehen schnelle und genaue Warteschlangenmetriken zur Verfügung: Anzahl der Nachrichten, Gesamtverkehr und dergleichen.  Sie können ähnliche Anforderungen gruppieren. <br><br>  Theoretisch hat eine solche Architektur bestimmte Nachteile, die mit der Zentralisierung verbunden sind: <br><br><ol><li>  Reduzieren der Fehlertoleranz: Wenn eine virtuelle Maschine mit einem Master ausfällt, sind alle Warteschlangen mit Master nicht verfügbar.  Mit den speziellen Mechanismen von YDB können Sie jedoch innerhalb weniger Sekunden neue Master innerhalb des Clusters erstellen.  Dies löst das Problem weitgehend. </li><li>  Eingeschränkte Skalierbarkeit: Alle Anforderungen werden über einen Host gesendet.  Der Nachteil sind ebene YDB-Tabletten.  Sie machen die ganze harte Arbeit mit den Daten.  Der Master sendet asynchron Anforderungen und verarbeitet die empfangenen Ergebnisse.  Dies macht es zu einer „leichten“ Einheit, die beim Stresstest keinen „Engpass“ -Effekt erzeugt. </li></ol><br><h3>  Warteschlange des Abfrage-Assistenten </h3><br>  Verteilte Transaktionen mit Datenbanktabellen führen zu bestimmten zusätzlichen Kosten, sodass die Idee, die Anzahl der Abfragen zu reduzieren, für uns logisch erschien.  Einhundert Transaktionen zum Aufzeichnen von Nachrichten nacheinander lassen sich besser in eine Transaktion zum gleichzeitigen Aufzeichnen von hundert Nachrichten umwandeln.  Mit Warteschlangenmastern ist die Implementierung einer solchen Stapelverarbeitung (Stapelverarbeitung) viel einfacher. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yc/rn/0j/ycrn0j7obrbg0_cimvkyzj5izr4.png"></div><br>  Durch das Stapeln wird die Latenz während des Betriebs geringfügig erhöht.  Stattdessen wird die Bandbreite erheblich erhöht.  Beim Batching kann eine Single-Shard-Warteschlange bis zu 30.000 Anforderungen pro Sekunde verarbeiten. <br><br>  Im Allgemeinen kann das Laden von Warteschlangen sehr unterschiedlich sein: Tausende von Nachrichten pro Sekunde und mehrere Nachrichten pro Tag.  Wir mussten die Arbeit mit Warteschlangen mithilfe eines flexiblen Algorithmus optimieren.  Frontaloptionen mit der Anhäufung von Nachrichten im Puffer auf die Schwellennummer oder einem Timer-Reset passten nicht zu uns.  Aus diesem Grund haben wir einen adaptiven Batching-Algorithmus für YMQ entwickelt, der in beiden Fällen gut funktioniert.  Seine Arbeiten werden im Zeitdiagrammformat gezeigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qm/g2/rx/qmg2rx2e8pllaxuajav0gyxe2kg.png"></div><br>  Wenn eine neue Nachricht eintrifft, ist hier eines von drei Szenarien möglich: <br><br><ol><li>  Eine Transaktion wird sofort gestartet, wenn keine anderen Transaktionen dieses Typs ausgeführt werden. </li><li>  Wenn bereits Transaktionen ausgeführt werden, wird die Nachricht zum Puffer hinzugefügt und wartet auf den Abschluss der Transaktionen. </li><li>  Wenn die Puffergröße den Schwellenwert überschreitet, wird eine weitere parallele Transaktion gestartet.  Die Anzahl der gleichzeitigen Transaktionen ist begrenzt. </li></ol><br>  Die Idee des adaptiven Batchings ähnelt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dem Nagle-Algorithmus</a> für TCP / IP.    :      ,      latency .    ,        .               . <br><br><h3>        </h3><br>  Yandex Message Queue,      ,    .  ,  ,      -. <br><br>    YDB               .   YMQ     . <br><br>           ,   ,     ,      . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ol/yb/ay/olybayeljh8jcdbcmod9dpylopw.png" width="808" height="712"></div><br>  YMQ   .                    .   «»        . <br><br><h3>        </h3><br>  YDB           .    ,  ,     ,   «».             ,       .          . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/eg/em/eg/egemegamvnhmv-c5t8pw4im73u0.png" width="661" height="685"></div><br>   :              .    ,    «»      .  -,   «»  ,   «»,    . <br><br>     «  »               .    ,  ,     . <br><br><h3>   Yandex Message Queue     </h3><br> Yandex Message Queue –  - .      .       ,  .     . <br><br><ul><li> <b>-</b>    ,  ,   .      . </li><li> <b> </b>       API   ,    .  ,        . </li><li> <b> </b>  ,     :    ,           . ,       .          .     boto,    24/7,     -    . </li><li> <b> </b>    ,   ,         .        . </li></ul><br>        .       -         .   .       . <br><br>     : <br><br><ul><li>     5,       ; </li><li>    YDB; </li><li>  , , ,   ; </li><li>      ,    ; </li><li>    .       . </li></ul><br>                  . <br><br><h3>  Abschließend </h3><br>      –    ,    ,          ,    .              ., ., ., .   . <br><br>      .            .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>  ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> Yandex Message Queue  . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455642/">https://habr.com/ru/post/de455642/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455632/index.html">Achtung! Gefährlicher Fehler in der C ++ - Implementierung std :: map :: merge und std :: set :: merge in Visual Studio 2017</a></li>
<li><a href="../de455634/index.html">Mathematik und das Spiel "Set"</a></li>
<li><a href="../de455636/index.html">Die erste Welle, die von der Exim-Sicherheitsanfälligkeit betroffen ist. Das Skript für die Behandlung</a></li>
<li><a href="../de455638/index.html">Alan Kay hat keine Objekte erfunden</a></li>
<li><a href="../de455640/index.html">Marvin Minskys „The Emotion Machine“: Kapitel 4. „Wie wir Bewusstsein erkennen“</a></li>
<li><a href="../de455644/index.html">Wir verwenden Daten in der Praxis</a></li>
<li><a href="../de455646/index.html">Sicherheitswoche 24: Werks-Backdoors auf Android-Smartphones</a></li>
<li><a href="../de455648/index.html">Lebenszyklus ML</a></li>
<li><a href="../de455650/index.html">Wie wir ein neuronales Netzwerk trainiert haben, um Schrauben zu klassifizieren</a></li>
<li><a href="../de455652/index.html">Deep Learning gegen gesunden Menschenverstand: Entwicklung eines Chat-Bots</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>