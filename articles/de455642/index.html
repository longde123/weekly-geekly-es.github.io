<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ›ï¸ ğŸš£ğŸ½ ğŸ™…ğŸ¿ Die Architektur des verteilten Nachrichtenwarteschlangendienstes in Yandex.Cloud ğŸ…ğŸ¾ âºï¸ ğŸ‘¶ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo, ich heiÃŸe Vasily Bogonatov. Ich bin einer von denen, die meine Hand und meinen Kopf legen und meine Seele in den Dienst verteilter persistenter...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Architektur des verteilten Nachrichtenwarteschlangendienstes in Yandex.Cloud</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/455642/"> Hallo, ich heiÃŸe Vasily Bogonatov.  Ich bin einer von denen, die meine Hand und meinen Kopf legen und meine Seele in den Dienst verteilter persistenter Nachrichtenwarteschlangen der Yandex Message Queue stellen.  Der Dienst ging Ende Mai an die BÃ¶rse, wurde jedoch in Yandex seit langem aktiv in verschiedenen Produkten eingesetzt. <br><br>  Heute mÃ¶chte ich Habrs Lesern von Nachrichtenwarteschlangen im Allgemeinen und von Yandex Message Queue im Besonderen erzÃ¤hlen.  ZunÃ¤chst mÃ¶chte ich erklÃ¤ren, was eine "verteilte Warteschlange fÃ¼r persistente Nachrichten" ist und warum sie benÃ¶tigt wird.  Zeigen Sie den praktischen Wert, die Mechanik der Arbeit mit Nachrichten, sprechen Sie Ã¼ber die API und die Benutzerfreundlichkeit.  In der zweiten HÃ¤lfte des Artikels werden wir uns mit der technischen Seite befassen: Wie wird die Yandex-Datenbank in unseren Warteschlangen verwendet (dies ist eine zuverlÃ¤ssige Grundlage unseres Service), wie sieht ein naiver und verbesserter Ansatz zum Erstellen einer Architektur aus, welche Probleme werden durch die Verteilung verursacht und wie kÃ¶nnen sie gelÃ¶st werden. <br><br><img src="https://habrastorage.org/webt/xy/ht/eb/xyhtebqslkofciotlmohtwlopb4.png"><br><a name="habracut"></a><br><h3>  Was ist eine verteilte Warteschlange fÃ¼r persistente Nachrichten? </h3><br>  Wikipedia definiert die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nachrichtenwarteschlange</a> als "Software-Engineering-Komponente, die fÃ¼r die Interprozess- oder Inter-Thread-Interaktion innerhalb eines Prozesses verwendet wird".  TatsÃ¤chlich ist dieses Konzept etwas umfassender: Prozesse, die Ã¼ber eine Warteschlange interagieren, kÃ¶nnen sich auf verschiedenen Servern und sogar in verschiedenen Rechenzentren befinden. <br><br>  Wir werden die Begriffe etwas klÃ¤ren. <br><br>  <b>Eine Nachrichtenwarteschlange</b> ist ein Repository, das das Platzieren und Lesen von Daten in einer bestimmten Reihenfolge ermÃ¶glicht. <br><br>  Zwei Arten von EntitÃ¤ten interagieren normalerweise mit einer Warteschlange: <br><br><ul><li>  <b>Autoren (Produzenten)</b> - Nachrichten an die Warteschlange senden; </li><li>  <b>Leser (Verbraucher)</b> - Empfangen (Lesen) von Nachrichten aus der Warteschlange. </li></ul><br>  Bei Verwendung der Warteschlange sind Leser und Schreiber unabhÃ¤ngig voneinander.  Sie kÃ¶nnen mit unterschiedlicher Leistung, ZuverlÃ¤ssigkeit und VerfÃ¼gbarkeit arbeiten und kÃ¶nnen sogar in verschiedenen Programmiersprachen geschrieben werden. <br><br>  Das Hauptszenario fÃ¼r die Warteschlange: Nachrichten vom Schreiber zuverlÃ¤ssig und schnell an den Leser Ã¼bertragen.  Im Gegensatz zur Datenbank ist die Warteschlange nicht fÃ¼r die Langzeitspeicherung von Nachrichten vorgesehen.  In vielen gÃ¤ngigen Implementierungen gibt es einen entsprechenden Parameter - "Nachrichtenaufbewahrungszeitraum".  Es bestimmt, wie lange die Nachricht gespeichert wird, bis sie dauerhaft gelÃ¶scht wird. <br><br>  Wir haben das Konzept der Warteschlange herausgefunden, gehen zu "Verteilung" und "Persistenz". <br><br><ul><li>  <b>Verteilung bedeutet</b> in unserem Fall das Vorhandensein eines Clusters, der Daten und Warteschlangenmetadaten speichert und verarbeitet und alle seine Knoten mithilfe eines Computernetzwerks zu einem Ganzen zusammenfasst. </li><li>  <b>Persistenz</b> bedeutet, dass alle Nachrichten in der Warteschlange auf die Festplatte geschrieben werden und der Schreiber erst nach erfolgreicher Aufzeichnung eine BestÃ¤tigung des Sendens erhÃ¤lt. </li></ul><br>  Verteilung und Persistenz wirken sich nicht auf die HauptfunktionalitÃ¤t der Warteschlange aus, sondern bieten Fehlertoleranz und ZuverlÃ¤ssigkeit der Datenspeicherung.  Welche Arten von Fehlern in unserem System auftreten kÃ¶nnen, werden wir etwas spÃ¤ter prÃ¼fen.  Ich kann mir jedoch das VergnÃ¼gen nicht verweigern und die Karten ein wenig Ã¶ffnen: In der gesamten Geschichte der Existenz des Dienstes haben wir keine einzige gespeicherte Nachricht vom Kunden verloren. <br><br><h3>  WofÃ¼r ist die Nachrichtenwarteschlange? </h3><br>  Die Warteschlange ermÃ¶glicht es Ihnen, die logisch unabhÃ¤ngigen Teile von Diensten voneinander zu trennen, dh sie bietet eine <b>Entkopplung</b> , die in den heute gÃ¤ngigen Mikrodiensten so gefragt ist.  Dies erhÃ¶ht die Skalierbarkeit und ZuverlÃ¤ssigkeit: Sie kÃ¶nnen jederzeit den Datenstrom in der Warteschlange erhÃ¶hen und mehr Leser hinzufÃ¼gen - Nachrichtenhandler, wÃ¤hrend der Ausfall von Lesern die Arbeit der Autoren nicht beeintrÃ¤chtigt. <br><br>  Warteschlangen glÃ¤tten Spitzenlasten: Sie dienen als Puffer fÃ¼r Leser.  Wenn die aktuellen LeserkapazitÃ¤ten nicht fÃ¼r die sofortige Verarbeitung aller eingehenden Nachrichten ausreichen, werden die Nachrichten in der Warteschlange spÃ¤ter verarbeitet, wenn die Last abnimmt.  Das Puffern ist nÃ¼tzlich fÃ¼r Dienste mit einer instabilen Last, bei denen keine sofort eingehenden Ereignisse erforderlich sind. <br><br>  Lassen Sie uns am Beispiel eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Suchroboters</a> (schlieÃŸlich hat Yandex mit einer Suche begonnen!) Sehen, wie Webseiten heruntergeladen, verarbeitet und in eine Datenbank gestellt werden.  Nehmen wir eine solche Architektur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zo/oe/dh/zooedh0t0qs4uu1lhpdc0psa2qi.png" width="600" height="778"></div><br><br>  Die Nachrichtenwarteschlange lÃ¶st hier die folgenden Probleme: <br><br><ol><li>  Der Roboter arbeitet viel schneller als die Mitarbeiter, die fÃ¼r das Parsen und Laden von Seiten in die Datenbank verantwortlich sind.  AuÃŸerhalb der Linie wÃ¼rden sich Links ansammeln und den verfÃ¼gbaren Speicher oder die verfÃ¼gbare Festplatte fÃ¼llen.  Das gleiche wÃ¼rde passieren, wenn die Arbeiter vorÃ¼bergehend nicht verfÃ¼gbar wÃ¤ren. </li><li>  Ohne Warteschlange muss der Roboter die ArbeitsoberflÃ¤che der Mitarbeiter â€kennenâ€œ, um ihnen Aufgaben zuweisen zu kÃ¶nnen.  Die BenutzeroberflÃ¤che kann sich wÃ¤hrend der Produktentwicklung Ã¤ndern. </li><li>  Ein einzelner Mitarbeiter hat eine relativ geringe ZuverlÃ¤ssigkeit, daher gibt es keine Garantie dafÃ¼r, dass die Ã¼bertragene Verbindung von ihm vollstÃ¤ndig verarbeitet wird. </li></ol><br>  Die Warteschlange bietet zuverlÃ¤ssige Datenspeicherung mit Skalierung und ermÃ¶glicht es Ihnen, die Verarbeitung von Links zu verzÃ¶gern.  Wenn ein Mitarbeiter ausfÃ¤llt, wird die unformatierte VerknÃ¼pfung nach einer bestimmten Zeit zur Verarbeitung durch einen anderen Mitarbeiter in die Warteschlange zurÃ¼ckgefÃ¼hrt.  Die Warteschlange verfÃ¼gt Ã¼ber eine eigene Schnittstelle, die in der Dokumentation getestet und beschrieben wird, sodass Suchroboter- und Arbeitersysteme unterschiedliche Teams in unterschiedlichen Programmiersprachen entwickeln kÃ¶nnen.  Dies hat keinen Einfluss auf die Gesamtleistung. <br><br><h3>  Funktionsweise der Yandex Message Queue mit Nachrichten </h3><br>  Hier kÃ¶nnen drei Hauptstufen unterschieden werden: <br><br><ul><li>  <b>Schreiben einer</b> Nachricht in die Warteschlange; </li><li>  <b>Lesen einer</b> Nachricht aus der Warteschlange; </li><li>  <b>Entfernen einer</b> Nachricht aus der Warteschlange. </li></ul><br>  Ein Datensatz gilt als erfolgreich, wenn die Nachricht sicher gespeichert wurde und den Lesern bald zur VerfÃ¼gung steht.  Eine Deduplizierungsaufzeichnung ist mÃ¶glich: Wenn ein wiederholter Versuch, eine gesendete Nachricht aufzuzeichnen, ignoriert wird. <br><br>  Zum Zeitpunkt des Lesens wird die Nachricht fÃ¼r einen Zeitraum, der als Sichtbarkeitszeitlimit bezeichnet wird, aus der Warteschlange ausgeblendet und ist fÃ¼r andere Leser nicht mehr zugÃ¤nglich.  Wenn das Sichtbarkeitszeitlimit ablÃ¤uft, kehrt die Nachricht in die Warteschlange zurÃ¼ck und steht wieder zur Verarbeitung zur VerfÃ¼gung.  Die Reihenfolge, in der Nachrichten gelesen werden, wird von der Warteschlange und nicht vom Leser bestimmt. <br><br>  Der Leser selbst und die Netzwerkverbindung mit ihm sind mÃ¶glicherweise unzuverlÃ¤ssig.  Ein Sichtbarkeitszeitlimit ist erforderlich, um eine Nachricht an die Warteschlange zurÃ¼ckgeben zu kÃ¶nnen, wenn der Reader abstÃ¼rzt oder die Verbindung getrennt wird.  Andernfalls ist es wahrscheinlich, dass eine einzelne Nachricht niemals korrekt verarbeitet wird. <br><br>  Nach erfolgreichem Lesen wird die Nachricht mit der Kennung ReceiptHandle an den Client Ã¼bertragen.  Ein Bezeichner gibt bestimmte Daten an, die aus der Nachrichtenwarteschlange entfernt werden sollen. <br><br><h3>  Warteschlangentypen in der Yandex-Nachrichtenwarteschlange </h3><br>  Der erste und am hÃ¤ufigsten verwendete Typ ist die Standardwarteschlange.  Es zeichnet sich durch einen hohen Durchsatz (Tausende von Nachrichten pro Sekunde), eine hervorragende Leistung und eine kurze AusfÃ¼hrungszeit fÃ¼r grundlegende VorgÃ¤nge aus.  Standardwarteschlangen bestehen aus logischen Shards und unterstÃ¼tzen eine nahezu lineare Bandbreitenskalierung. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wy/p0/jp/wyp0jpi_pmhorpq2mikwm_mgl-u.png"></div><br>  Standardwarteschlangen unterstÃ¼tzen keine Deduplizierung von Nachrichten beim Schreiben in eine Warteschlange und garantieren keine Lesereihenfolge.  Aufgrund der Verwendung von Sharding gibt eine Leseanforderung mÃ¶glicherweise keine einzelne Nachricht zurÃ¼ck, selbst wenn sie sich in der Warteschlange befindet.  Meistens geschieht dies im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kurzabfragemodus</a> , wenn das Lesen von einem zufÃ¤llig ausgewÃ¤hlten Shard stammt. <br><br>  Der zweite Typ - <abbr title="First in first out">FIFO</abbr> - ist das Gegenteil der Standardwarteschlange.  Es bietet eine strikte Lesereihenfolge, unterstÃ¼tzt die Deduplizierung beim Schreiben und wiederholte Versuche, Nachrichten zu lesen.  Leistung und Skalierbarkeit sind niedriger als Standard.  Die Leistung der FIFO-Warteschlange ist auf 30 Anforderungen pro Sekunde begrenzt.  Es wird empfohlen, FIFO zu verwenden, wenn Sie versuchen mÃ¼ssen, die Ãœbermittlungssemantik â€genau einmalâ€œ sicherzustellen.  Normalerweise bedeutet das Wort "Warteschlange" FIFO. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yr/jy/l5/yrjyl5kbyfzqzkruqhaoqdrsxzs.png" width="421" height="801"></div><br><h3>  Yandex Message Queue API </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">API</a> ist ein Ã¤uÃŸerst wichtiger Bestandteil jedes Produkts.  Eine gute Softwareschnittstelle sollte einfach und unkompliziert sein und fÃ¼r eine effektive Verwendung nur minimale Kenntnisse der Dokumentation erfordern.  Sollte es nicht zulassen, seltsame oder unnÃ¶tige Handlungen durchzufÃ¼hren und sich vor dummen Fehlern zu schÃ¼tzen, sollte die Verletzung des â€Vertragsâ€œ rechtzeitig gemeldet werden. <br><br>  Wenn das System Ã¼ber eine solche API verfÃ¼gt, empfÃ¤ngt es schnell treue Benutzer und ist von praktischen â€Wrappernâ€œ fÃ¼r verschiedene Plattformen und Programmiersprachen umgeben. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Amazon Simple Queue Service-API (AWS SQS-API)</a> ist ein Beispiel fÃ¼r eine solche Schnittstelle, die nach Zeit und einer groÃŸen Anzahl von Clients getestet wurde.  Aus diesem Grund haben wir beschlossen, keine eindeutige Schnittstelle fÃ¼r die Yandex Message Queue zu erfinden, sondern die UnterstÃ¼tzung fÃ¼r die AWS SQS-API sehr sorgfÃ¤ltig implementiert. <br><br>  In den meisten FÃ¤llen reicht es fÃ¼r den SQS-Benutzer aus, den Endpunkt (Dienstadresse) und die Region zu Ã¤ndern (derzeit verwenden wir nur "ru-central1") und neue Anmeldeinformationen in Yandex.Cloud abzurufen.  Alles andere, z. B. ein Skript, das die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AWS-Befehlszeile verwendet</a> , Code, der das AWS SDK verwendet, oder ein vorgefertigter Dienst fÃ¼r <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sellerie</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Boto</a> , wird hÃ¶chstwahrscheinlich nicht berÃ¼hrt.  Die Logik und FunktionalitÃ¤t des Warteschlangendienstes bleiben unverÃ¤ndert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_r/td/kn/_rtdknyixiytyqo63khne5gz4uq.png"></div><br>  Eine ausfÃ¼hrliche Beschreibung der Yandex Message Queue-API-Methoden finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Servicedokumentation</a> . <br><br><h3>  Ein wenig Ã¼ber Bequemlichkeit </h3><br>  Yandex Message Queue ist ein verwalteter Dienst, dh Yandex. Die Cloud ist fÃ¼r den Betrieb von Servern und Software verantwortlich.  Das Serviceteam Ã¼berwacht den Zustand der Warteschlangen, ersetzt ausgefallene Festplatten schnell, beseitigt Netzwerkunterbrechungen und fÃ¼hrt Aktualisierungen durch.  Das Update beendet den Dienst nicht: WÃ¤hrend wir die neue Version von YMQ auf einer Gruppe von Servern installieren, leitet der Load Balancer den Datenverkehr sorgfÃ¤ltig an andere weiter.  Benutzer bemerken also nichts. <br><br>  Um Ihnen die Steuerung des Betriebs der Warteschlangen zu erleichtern, haben wir YMQ eine groÃŸe Anzahl visueller Diagramme hinzugefÃ¼gt. Nur ein kleiner Teil davon wird hier angezeigt.  Diagramme befinden sich in der Yandex.Cloud-Konsole im Abschnitt "Statistik". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bi/cp/nn/bicpnn5tjwzqustzy9ye5abnrho.png"></div><br>  Wir werden Sie Ã¼ber die vier unserer Meinung nach nÃ¼tzlichsten Grafiken informieren: <br><br><ul><li>  Mit dem <b>Diagramm â€Nachrichten</b> in der Warteschlange <b>â€œ kÃ¶nnen</b> Sie die Ansammlung von Daten in der Warteschlange Ã¼berwachen.  Ein Wachstum im Diagramm kann bedeuten, dass die Handler die Last nicht verwalten oder die Verarbeitung gestoppt wurde. </li><li>  Grafik <b>"Alter der Ã¤ltesten Nachricht in der Warteschlange"</b> : GroÃŸe Werte weisen auf Probleme bei der Nachrichtenverarbeitung hin.  Wenn alles richtig funktioniert, sollten Nachrichten nicht lange in der Warteschlange stehen. </li><li>  Die Grafik <b>â€Anzahl der Leseversuche einer Nachrichtâ€œ</b> zeigt, wann Nachrichten mehrmals gelesen werden.  Dies kann bedeuten, dass die Handler abstÃ¼rzen, wenn sie einige Nachrichten empfangen. </li><li>  Das Diagramm <b>"Warteschlangenzeit"</b> gibt an, wie viel Zeit vom Senden der Nachricht an die Warteschlange bis zum Empfang durch den Handler vergeht. </li></ul><br>  Mithilfe von Diagrammen kÃ¶nnen Sie die Dynamik der Warteschlange und das Vorhandensein von Fehlern sofort bewerten, ohne dass Protokolle angezeigt werden mÃ¼ssen. <br><br>  Wir haben mehr oder weniger allgemeine Punkte besprochen. Kommen wir nun zu den Details. <br><br><h3>  Wie die Yandex-Datenbankwarteschlange die Yandex-Datenbank verwendet </h3><br>  Der Yandex Message Queue-Dienst basiert auf der geoverteilten fehlertoleranten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Yandex Database (YDB) -Datenbank</a> , die strikte Konsistenz und UnterstÃ¼tzung fÃ¼r ACID-Transaktionen bietet.  Wir werden das GerÃ¤t und die Eigenschaften jetzt nicht zerlegen, sondern uns auf das allgemeine Schema beschrÃ¤nken. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uq/5m/o3/uq5mo3fm83hovqxkgt7no-yjevg.png" width="742" height="860"></div><br>  Eine Warteschlange in YMQ besteht aus logischen Shards, die durch einen festen Satz von YDB-Tabellen dargestellt werden.  Jede Tabelle speichert ihre eigenen Informationen.  Beispielsweise gibt es eine allgemeine Statustabelle namens State, in der Offs und die tatsÃ¤chliche Anzahl von Nachrichten gespeichert sind.  Es gibt eine Tabelle mit Daten- und Nachrichtenmetadaten.  Es gibt eine Tabelle mit verwandten Attributen. <br><br>  Alle Hauptoperationen mit der Warteschlange - Arbeiten mit Nachrichten, Ã„ndern von Attributen, Erstellen und LÃ¶schen - funktionieren mit der Hierarchie von Tabellen und YDB-Verzeichnissen oder mit Transaktionsabfragen an eine oder mehrere Tabellen der Warteschlange.  Die Daten in den Warteschlangentabellen sind die Quelle der absoluten Wahrheit.  Daher ist es neben dem korrekten und stabilen Betrieb der Datenbank erforderlich, eine zuverlÃ¤ssige Speicherung und eine hohe DatenverfÃ¼gbarkeit sicherzustellen. <br><br>  Unsere Informationen werden in mehreren Replikaten gespeichert: eine Kopie in jedem der drei Yandex-Rechenzentren.  Wenn eines der Rechenzentren nicht verfÃ¼gbar ist, verdoppelt sich die Anzahl der Replikate in den verbleibenden.  Somit wird das erforderliche MaÃŸ an ZuverlÃ¤ssigkeit wiederhergestellt.  Selbst wenn ein gesamtes Rechenzentrum und ein Service Desk in einem anderen ausfallen, sind die Daten vollstÃ¤ndig zugÃ¤nglich. <br><br><h3>  Die erste Version der Yandex Message Queue-Architektur </h3><br>  So sah die erste Version der YMQ-Architektur aus, die wir selbst als naiv bezeichneten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/aj/qc/eu/ajqceuaoisynocw4u3ffek3epjo.png"></div><br>  Das Diagramm zeigt den Pfad der HTTPS-Anforderung vom YMQ-Client zum YDB-Repository.  Schauen wir uns die Hauptkomponenten an: <br><br><ol><li>  Der L3-Balancer sendet eine Anfrage an das Yandex-Rechenzentrum, das dem Benutzer am nÃ¤chsten liegt.  Dies reduziert die Netzwerklatenz, obwohl die Last ungleichmÃ¤ÃŸig verteilt ist. </li><li>  Nginx auf der virtuellen Yandex.Cloud-Maschine beendet HTTPS-Verbindungen, bietet Schutz vor Netzwerkangriffen und leitet die Anforderung weiter an den YMQ-Server weiter, der sich bereits in HTTP befindet. </li><li>  Der YMQ-HTTP-Server implementiert die SQS-HTTP-API-Logik, validiert die Anforderung und Ã¼bersetzt sie in ein stark typisiertes Protobuf-Format. </li><li>  YMQ Akteursystem - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Akteursystem</a> .  Gleichzeitig wurden Tausende verschiedener Akteure ins Leben gerufen, die Informationen austauschen.  Das Akteursystem jedes Hosts ist Teil eines Clusters.  Alle Akteure im Cluster leben und agieren als Ganzes.  Die YMQ-GeschÃ¤ftslogik ist in verschiedenen Akteuren implementiert, die an Transaktionsanforderungen an YDB beteiligt sind. </li><li>  YDB-Tablets ("Tablets") - Teil der Kern-YDB, die fÃ¼r die Arbeit mit Tabellen in Abfragen und Transaktionen verantwortlich ist.  Die Tablets selbst speichern keine Daten.  Dies sind Kontrollstrukturen im Speicher, die bei einem Hardwarefehler den Status wiederherstellen kÃ¶nnen. </li><li>  Speicher ist ein zuverlÃ¤ssiger, verteilter und fehlertoleranter Speicher. </li></ol><br>  Diese Architektur hat einen Nachteil: Alle Server im Cluster arbeiten unabhÃ¤ngig voneinander mit Tabellen derselben Warteschlange.  Dies wirkt sich negativ auf die Leistung aus und verhindert die Organisation zuverlÃ¤ssiger Caches fÃ¼r versteckte und lesbare Nachrichten.  Es ist schwierig, den Anforderungsfluss zu begrenzen, und dies ist fÃ¼r jeden hoch ausgelasteten Dienst sehr wichtig. <br><br><h3>  Yandex Message Queue-Architektur mit Warteschlangenmastern </h3><br>  Das AuslÃ¶sen von Lasten zeigte, dass die erste Version der Architektur mit einem Shard etwa 450 Nachrichten pro Sekunde und Warteschlange standhÃ¤lt.  Es war sehr klein. <br>  Das Hauptproblem waren Streitfragen.  Eine groÃŸe Anzahl logisch widersprÃ¼chlicher Transaktionen brachte versteckte Nachrichten-Caches schnell in einen inkonsistenten Zustand.  Um das Problem zu lÃ¶sen, haben wir eine spezielle EntitÃ¤t eingefÃ¼hrt - den Warteschlangenmaster. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gc/b4/om/gcb4omkmhk28uhwe2hrlewhzsig.png"></div><br>  <b>Ein Warteschlangenmaster</b> ist ein Akteur, der unter normalen Bedingungen in einem Cluster in einer einzelnen Instanz vorhanden ist und alle Anforderungen durchlÃ¤uft, die einer bestimmten Warteschlange zugeordnet sind.  Wenn eine Anforderung an die Warteschlange bei einem Server ankommt, auf dem der gewÃ¼nschte Master fehlt, leitet ein spezieller Proxy-Akteur die Anforderung um und Ã¼bersetzt dann die vom Master empfangene Antwort zurÃ¼ck. <br><br>  Bei Verwendung des Warteschlangenassistenten reduziert der korrekte Cache entsperrter Nachrichten die Konflikte bei der Arbeit mit Tabellen.  Die Implementierung der EinschrÃ¤nkung des Anforderungsflusses wird beispielsweise durch den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Leaky-Bucket</a> vereinfacht.  Es stehen schnelle und genaue Warteschlangenmetriken zur VerfÃ¼gung: Anzahl der Nachrichten, Gesamtverkehr und dergleichen.  Sie kÃ¶nnen Ã¤hnliche Anforderungen gruppieren. <br><br>  Theoretisch hat eine solche Architektur bestimmte Nachteile, die mit der Zentralisierung verbunden sind: <br><br><ol><li>  Reduzieren der Fehlertoleranz: Wenn eine virtuelle Maschine mit einem Master ausfÃ¤llt, sind alle Warteschlangen mit Master nicht verfÃ¼gbar.  Mit den speziellen Mechanismen von YDB kÃ¶nnen Sie jedoch innerhalb weniger Sekunden neue Master innerhalb des Clusters erstellen.  Dies lÃ¶st das Problem weitgehend. </li><li>  EingeschrÃ¤nkte Skalierbarkeit: Alle Anforderungen werden Ã¼ber einen Host gesendet.  Der Nachteil sind ebene YDB-Tabletten.  Sie machen die ganze harte Arbeit mit den Daten.  Der Master sendet asynchron Anforderungen und verarbeitet die empfangenen Ergebnisse.  Dies macht es zu einer â€leichtenâ€œ Einheit, die beim Stresstest keinen â€Engpassâ€œ -Effekt erzeugt. </li></ol><br><h3>  Warteschlange des Abfrage-Assistenten </h3><br>  Verteilte Transaktionen mit Datenbanktabellen fÃ¼hren zu bestimmten zusÃ¤tzlichen Kosten, sodass die Idee, die Anzahl der Abfragen zu reduzieren, fÃ¼r uns logisch erschien.  Einhundert Transaktionen zum Aufzeichnen von Nachrichten nacheinander lassen sich besser in eine Transaktion zum gleichzeitigen Aufzeichnen von hundert Nachrichten umwandeln.  Mit Warteschlangenmastern ist die Implementierung einer solchen Stapelverarbeitung (Stapelverarbeitung) viel einfacher. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yc/rn/0j/ycrn0j7obrbg0_cimvkyzj5izr4.png"></div><br>  Durch das Stapeln wird die Latenz wÃ¤hrend des Betriebs geringfÃ¼gig erhÃ¶ht.  Stattdessen wird die Bandbreite erheblich erhÃ¶ht.  Beim Batching kann eine Single-Shard-Warteschlange bis zu 30.000 Anforderungen pro Sekunde verarbeiten. <br><br>  Im Allgemeinen kann das Laden von Warteschlangen sehr unterschiedlich sein: Tausende von Nachrichten pro Sekunde und mehrere Nachrichten pro Tag.  Wir mussten die Arbeit mit Warteschlangen mithilfe eines flexiblen Algorithmus optimieren.  Frontaloptionen mit der AnhÃ¤ufung von Nachrichten im Puffer auf die Schwellennummer oder einem Timer-Reset passten nicht zu uns.  Aus diesem Grund haben wir einen adaptiven Batching-Algorithmus fÃ¼r YMQ entwickelt, der in beiden FÃ¤llen gut funktioniert.  Seine Arbeiten werden im Zeitdiagrammformat gezeigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qm/g2/rx/qmg2rx2e8pllaxuajav0gyxe2kg.png"></div><br>  Wenn eine neue Nachricht eintrifft, ist hier eines von drei Szenarien mÃ¶glich: <br><br><ol><li>  Eine Transaktion wird sofort gestartet, wenn keine anderen Transaktionen dieses Typs ausgefÃ¼hrt werden. </li><li>  Wenn bereits Transaktionen ausgefÃ¼hrt werden, wird die Nachricht zum Puffer hinzugefÃ¼gt und wartet auf den Abschluss der Transaktionen. </li><li>  Wenn die PuffergrÃ¶ÃŸe den Schwellenwert Ã¼berschreitet, wird eine weitere parallele Transaktion gestartet.  Die Anzahl der gleichzeitigen Transaktionen ist begrenzt. </li></ol><br>  Die Idee des adaptiven Batchings Ã¤hnelt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dem Nagle-Algorithmus</a> fÃ¼r TCP / IP.    :      ,      latency .    ,        .               . <br><br><h3>        </h3><br>  Yandex Message Queue,      ,    .  ,  ,      -. <br><br>    YDB               .   YMQ     . <br><br>           ,   ,     ,      . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ol/yb/ay/olybayeljh8jcdbcmod9dpylopw.png" width="808" height="712"></div><br>  YMQ   .                    .   Â«Â»        . <br><br><h3>        </h3><br>  YDB           .    ,  ,     ,   Â«Â».             ,       .          . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/eg/em/eg/egemegamvnhmv-c5t8pw4im73u0.png" width="661" height="685"></div><br>   :              .    ,    Â«Â»      .  -,   Â«Â»  ,   Â«Â»,    . <br><br>     Â«  Â»               .    ,  ,     . <br><br><h3>   Yandex Message Queue     </h3><br> Yandex Message Queue â€“  - .      .       ,  .     . <br><br><ul><li> <b>-</b>    ,  ,   .      . </li><li> <b> </b>       API   ,    .  ,        . </li><li> <b> </b>  ,     :    ,           . ,       .          .     boto,    24/7,     -    . </li><li> <b> </b>    ,   ,         .        . </li></ul><br>        .       -         .   .       . <br><br>     : <br><br><ul><li>     5,       ; </li><li>    YDB; </li><li>  , , ,   ; </li><li>      ,    ; </li><li>    .       . </li></ul><br>                  . <br><br><h3>  AbschlieÃŸend </h3><br>      â€“    ,    ,          ,    .              ., ., ., .   . <br><br>      .            .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>  ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> Yandex Message Queue  . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455642/">https://habr.com/ru/post/de455642/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455632/index.html">Achtung! GefÃ¤hrlicher Fehler in der C ++ - Implementierung std :: map :: merge und std :: set :: merge in Visual Studio 2017</a></li>
<li><a href="../de455634/index.html">Mathematik und das Spiel "Set"</a></li>
<li><a href="../de455636/index.html">Die erste Welle, die von der Exim-SicherheitsanfÃ¤lligkeit betroffen ist. Das Skript fÃ¼r die Behandlung</a></li>
<li><a href="../de455638/index.html">Alan Kay hat keine Objekte erfunden</a></li>
<li><a href="../de455640/index.html">Marvin Minskys â€The Emotion Machineâ€œ: Kapitel 4. â€Wie wir Bewusstsein erkennenâ€œ</a></li>
<li><a href="../de455644/index.html">Wir verwenden Daten in der Praxis</a></li>
<li><a href="../de455646/index.html">Sicherheitswoche 24: Werks-Backdoors auf Android-Smartphones</a></li>
<li><a href="../de455648/index.html">Lebenszyklus ML</a></li>
<li><a href="../de455650/index.html">Wie wir ein neuronales Netzwerk trainiert haben, um Schrauben zu klassifizieren</a></li>
<li><a href="../de455652/index.html">Deep Learning gegen gesunden Menschenverstand: Entwicklung eines Chat-Bots</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>