<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ê üíí üë©üèæ‚Äçüíº Multiproceso .NET: cuando falta rendimiento üë©üèª‚Äç‚öïÔ∏è üë∞üèø üèê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La plataforma .NET proporciona muchas primitivas de sincronizaci√≥n preconstruidas y colecciones seguras para subprocesos. Si necesita implementar, por...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Multiproceso .NET: cuando falta rendimiento</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/468611/"><img src="https://habrastorage.org/webt/rn/su/tj/rnsutjjvg7sllluahknu8brlnbc.jpeg"><br><br>  La plataforma .NET proporciona muchas primitivas de sincronizaci√≥n preconstruidas y colecciones seguras para subprocesos.  Si necesita implementar, por ejemplo, una memoria cach√© segura para subprocesos o una cola de solicitudes al desarrollar una aplicaci√≥n, generalmente se usan estas soluciones listas, a veces varias a la vez.  En algunos casos, esto lleva a problemas de rendimiento: una larga espera en bloqueos, consumo excesivo de memoria y larga recolecci√≥n de basura. <br><br>  Estos problemas pueden resolverse si tenemos en cuenta que las soluciones est√°ndar se hacen bastante generales: pueden tener una sobrecarga en nuestros escenarios que es redundante.  En consecuencia, puede escribir, por ejemplo, su propia colecci√≥n efectiva segura para subprocesos para un caso espec√≠fico. <br><br>  Debajo de la escena hay un video y una transcripci√≥n de mi informe de la conferencia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DotNext</a> , donde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">analizo</a> algunos ejemplos cuando uso herramientas de la biblioteca est√°ndar .NET (Task.Delay, SemaphoreSlim, ConcurrentDictionary) condujo a ca√≠das en el rendimiento, y propongo soluciones adaptadas para tareas espec√≠ficas y carentes de Estas deficiencias. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/-tNeYjRNJtY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  En el momento del informe, √©l trabajaba en Kontur.  Kontur desarrolla varias aplicaciones para negocios, y el equipo con el que trabaj√© se ocupa de la infraestructura y desarrolla varios servicios de soporte y bibliotecas para ayudar a los desarrolladores de otros equipos a crear servicios de productos. <br><br>  El equipo de Infraestructura construye su almac√©n de datos, un sistema de alojamiento de aplicaciones para Windows y varias bibliotecas para el desarrollo de microservicios.  Nuestras aplicaciones se basan en la arquitectura de microservicios: todos los servicios interact√∫an entre s√≠ a trav√©s de la red y, por supuesto, utilizan una gran cantidad de c√≥digo asincr√≥nico y multiproceso.  Algunas de estas aplicaciones son bastante cr√≠ticas para el rendimiento; necesitan poder manejar muchas solicitudes. <br><br>  ¬øDe qu√© vamos a hablar hoy? <br><br><ul><li>  Multithreading y asincron√≠a en .NET; </li><li>  Relleno de primitivas de sincronizaci√≥n y colecciones; </li><li>  ¬øQu√© hacer si los enfoques est√°ndar no pueden hacer frente a la carga? </li></ul><br>  Analicemos algunas caracter√≠sticas de trabajar con c√≥digo multiproceso y as√≠ncrono en .NET.  Veamos algunas primitivas de sincronizaci√≥n y colecciones concurrentes, veamos c√≥mo se organizan en su interior.  Discutiremos qu√© hacer si no hay suficiente rendimiento, si las clases est√°ndar no pueden hacer frente a la carga y si se puede hacer algo en esta situaci√≥n. <br><br>  Te contar√© cuatro historias que sucedieron en nuestro sitio de producci√≥n. <br><br><h2>  Historial 1: Tarea, Retardo y Temporizador </h2><br>  Esta historia ya es bastante conocida, incluso sobre ella en DotNext anterior.  Sin embargo, obtuvo una secuela bastante interesante, as√≠ que la agregu√©.  Entonces, ¬øcu√°l es el punto? <br><br><h3>  1.1 Encuestas y encuestas largas </h3><br>  El servidor realiza operaciones largas, el cliente las espera. <br>  <b>Sondeo: el</b> cliente pregunta peri√≥dicamente al servidor sobre el resultado. <br>  <b>Sondeo largo: el</b> cliente env√≠a una solicitud con un tiempo de espera prolongado y el servidor responde cuando se completa la operaci√≥n. <br><br>  Ventajas: <br><br><ul><li>  Menos tr√°fico </li><li>  El cliente aprende sobre el resultado m√°s r√°pido. </li></ul><br>  Imagine que tenemos un servidor que puede manejar algunas solicitudes largas, por ejemplo, una aplicaci√≥n que convierte archivos XML a PDF, y hay clientes que ejecutan estas tareas para el procesamiento y desean esperar su resultado de forma asincr√≥nica.  ¬øC√≥mo puede realizarse tal expectativa? <br><br>  La primera forma es el <b>sondeo</b> .  El cliente inicia la tarea en el servidor, luego verifica peri√≥dicamente el estado de esta tarea, mientras el servidor devuelve el estado de la tarea ("completado" / "fallido" / "completado con un error").  El cliente env√≠a peri√≥dicamente solicitudes hasta que aparece el resultado. <br><br>  La segunda forma es una <b>larga votaci√≥n</b> .  La diferencia aqu√≠ es que el cliente env√≠a solicitudes con largos tiempos de espera.  El servidor, al recibir dicha solicitud, no informar√° de inmediato que la tarea no se ha completado, pero intentar√° esperar un momento para que aparezca el resultado. <br>  Entonces, ¬øcu√°l es la ventaja de las encuestas largas sobre las encuestas regulares?  En primer lugar, se genera menos tr√°fico.  Hacemos menos solicitudes de red: se persigue menos tr√°fico a trav√©s de la red.  Adem√°s, el cliente podr√° conocer el resultado m√°s r√°pido que con un sondeo regular, ya que no necesita esperar el intervalo entre varias solicitudes de sondeo.  Lo que queremos obtener es comprensible.  ¬øC√≥mo implementaremos esto en el c√≥digo? <br><blockquote>  Tarea: tiempo de espera <br>  Queremos esperar a la tarea con un tiempo de espera <br>  esperar SendAsync (); </blockquote>  Por ejemplo, tenemos una Tarea que env√≠a una solicitud al servidor y queremos esperar su resultado con un tiempo de espera, es decir, devolveremos el resultado de esta Tarea o enviaremos alg√∫n tipo de error.  El c√≥digo C # se ver√° as√≠: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sendTask = SendAsync(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> delayTask = Task.Delay(timeout); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> task = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.WhenAny(sendTask, delayTask); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (task == delayTask) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Timeout;</code> </pre> <br>  Este c√≥digo lanza nuestra tarea, cuyo resultado queremos esperar, y Task.Delay.  Luego, usando Task.WhenAny, estamos esperando ya sea nuestra Task o Task.Delay.  Si resulta que Task.Delay se ejecuta primero, entonces se acab√≥ el tiempo y tenemos un tiempo de espera, debemos devolver un error. <br><br>  Este c√≥digo, por supuesto, no es perfecto y se puede mejorar.  Por ejemplo, no estar√≠a mal cancelar Task.Delay si SendAsync regres√≥ antes, pero esto no es muy interesante para nosotros ahora.  La conclusi√≥n es que si escribimos dicho c√≥digo y lo aplicamos para encuestas largas con tiempos de espera prolongados, tendremos algunos problemas de rendimiento. <br><br><h3>  1.2 Problemas con encuestas largas </h3><br><ul><li>  Grandes tiempos de espera </li><li>  Muchas consultas concurrentes </li><li>  =&gt; Alta utilizaci√≥n de CPU </li></ul><br>  En este caso, el problema es el alto consumo de recursos del procesador.  Puede suceder que el procesador est√© completamente cargado al 100%, y la aplicaci√≥n generalmente deja de funcionar.  Parece que no consumimos los recursos del procesador en absoluto: hacemos algunas operaciones asincr√≥nicas, esperamos una respuesta del servidor y el procesador todav√≠a est√° cargado con nosotros. <br><br>  Cuando nos enfrentamos a esta situaci√≥n, eliminamos un volcado de memoria de nuestra aplicaci√≥n: <br><br><pre> <code class="cs hljs"> ~*e!clrstack System.Threading.Monitor.Enter(System.Object) System.Threading.TimerQueueTimer.Change(‚Ä¶) System.Threading.Timer.TimerSetup(‚Ä¶) System.Threading.Timer..ctor(‚Ä¶) System.Threading.Tasks.Task.Delay(‚Ä¶)</code> </pre> <br>  Para analizar el volcado, utilizamos la herramienta WinDbg.  Ingresamos un comando que muestra los rastros de la pila de todos los subprocesos administrados y vimos ese resultado.  Tenemos muchos subprocesos en proceso que esperan alg√∫n bloqueo.  El m√©todo Monitor.Enter es en lo que se expande la construcci√≥n de bloqueo en C #.  Este bloqueo se captura dentro de las clases llamadas Timer y TimerQueueTimer.  En Timer, venimos de Task.Delay cuando intentamos crearlos.  Que es  Cuando se inicia Task.Delay, se captura el bloqueo dentro de TimerQueue. <br><br><h3>  1.3 Bloquear convoy </h3><br><ul><li>  Muchos hilos intentan bloquear una cerradura </li><li>  Debajo del candado, se ejecuta un peque√±o c√≥digo </li><li>  Se dedica tiempo a la sincronizaci√≥n de subprocesos, no a la ejecuci√≥n de c√≥digo. </li><li>  Los bloques de hilos est√°n bloqueados, no son infinitos </li></ul><br>  Ten√≠amos un convoy de bloqueo en la aplicaci√≥n.  Muchos hilos intentan capturar el mismo bloqueo.  Bajo este bloqueo, se ejecuta bastante c√≥digo.  Los recursos del procesador aqu√≠ no se gastan en el c√≥digo de la aplicaci√≥n en s√≠, sino en operaciones para sincronizar subprocesos entre ellos en este bloqueo.  Tambi√©n vale la pena se√±alar una caracter√≠stica relacionada con .NET: los hilos que participan en el convoy de bloqueo son hilos del grupo de hilos. <br><br>  En consecuencia, si los subprocesos del conjunto de subprocesos est√°n bloqueados, pueden finalizar: el n√∫mero de subprocesos en el conjunto de subprocesos es limitado.  Se puede configurar, pero todav√≠a hay un l√≠mite superior.  Una vez alcanzado, todos los hilos del conjunto de subprocesos participar√°n en el convoy de bloqueo, y cualquier c√≥digo que involucre al conjunto de subprocesos dejar√° de ejecutarse en la aplicaci√≥n.  Esto empeora mucho la situaci√≥n. <br><br><h3>  1.4 TimerQueue </h3><br><ul><li>  Gestiona temporizadores en una aplicaci√≥n .NET. </li><li>  Los temporizadores se usan en: <br>  - Tarea. Retraso <br>  - CancellationTocken.CancelAfter <br>  - HttpClient </li></ul><br>  TimerQueue es una clase que administra todos los temporizadores en una aplicaci√≥n .NET.  Si una vez program√≥ en WinForms, es posible que haya creado temporizadores manualmente.  Para aquellos que no saben qu√© son los temporizadores: se usan en Task.Delay (este es solo nuestro caso), tambi√©n se usan dentro de CancellationToken, en el m√©todo CancelAfter.  Es decir, reemplazar Task.Delay con CancellationToken.CancelAfter no nos ayudar√≠a de ninguna manera.  Adem√°s, los temporizadores se usan en muchas clases internas de .NET, por ejemplo, en HttpClient. <br><br>  Hasta donde yo s√©, algunas implementaciones de controladores HttpClient tienen temporizadores.  Incluso si no los usa expl√≠citamente, no inicie Task.Delay, lo m√°s probable es que los use de todos modos. <br><br>  Ahora veamos c√≥mo se organiza TimerQueue en su interior. <br><br><ul><li>  Estado global (por dominio de aplicaci√≥n): <br>  - Lista doblemente vinculada de TimerQueueTimer <br>  - Bloquear objeto </li><li>  Devoluci√≥n de llamada de temporizador de rutina </li><li>  Temporizadores no ordenados por tiempo de respuesta </li><li>  Agregar un temporizador: O (1) + bloqueo </li><li>  Eliminaci√≥n del temporizador: O (1) + bloqueo </li><li>  Temporizadores de inicio: O (N) + bloqueo </li></ul><br>  Dentro de TimerQueue hay un estado global, es una lista doblemente vinculada de objetos de tipo TimerQueueTimer.  TimerQueueTimer contiene un enlace a otro TimerQueueTimer, contiguo a una lista vinculada, tambi√©n contiene la hora del temporizador y la devoluci√≥n de llamada, que se llamar√° cuando se active el temporizador.  Esta lista doblemente vinculada est√° protegida por un objeto de bloqueo, justo en el que ocurri√≥ el convoy de bloqueo en nuestra aplicaci√≥n.  Tambi√©n dentro de TimerQueue hay una rutina que lanza devoluciones de llamada vinculadas a nuestros temporizadores. <br><br>  Los temporizadores no est√°n ordenados por tiempo de respuesta, toda la estructura est√° optimizada para agregar / eliminar nuevos temporizadores.  Cuando se inicia Rutina, recorre toda la lista doblemente vinculada, selecciona los temporizadores que deber√≠an funcionar y los devuelve la llamada. <br><br>  La complejidad de la operaci√≥n aqu√≠ es tal.  Agregar o quitar un temporizador ocurre O por unidad, y el inicio de los temporizadores ocurre por l√≠nea.  Adem√°s, si todo es aceptable con la complejidad algor√≠tmica, hay un problema: todas estas operaciones capturan el bloqueo, lo que no es muy bueno. <br><br>  ¬øQu√© situaci√≥n puede pasar?  Tenemos demasiados temporizadores acumulados en TimerQueue, por lo que cuando se inicia Routine, bloquea su larga operaci√≥n lineal, en ese momento aquellos que intentan iniciar o eliminar temporizadores de TimerQueue no pueden hacer nada al respecto.  Debido a esto, se produce el bloqueo de convoy.  Este problema se ha solucionado en .NET Core. <br><blockquote>  Reducir la contenci√≥n de bloqueo del temporizador (coreclr # 14527) <br><ul><li>  Fragmento de bloqueo <br>  - Environment.ProcessorCount TimerQueue's TimerQueueTimer </li><li>  Colas separadas para temporizadores de corta / larga vida </li><li>  Temporizador corto: tiempo &lt;= 1/3 segundo </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/dotnet/coreclr/issues/14462</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/dotnet/coreclr/pull/14527</a> <br></blockquote>  ¬øC√≥mo se solucion√≥?  Asaltaron TimerQueue: en lugar de un TimerQueue, que era est√°tico para todo el AppDomain, para toda la aplicaci√≥n, se hicieron varios TimerQueue.  Cuando los hilos llegan all√≠ e intentan iniciar sus temporizadores, estos temporizadores caer√°n en un TimerQueue aleatorio, y los hilos tendr√°n menos posibilidades de colisionar en una cerradura. <br><br>  Tambi√©n en .NET Core aplic√≥ algunas optimizaciones.  Los temporizadores se dividieron en de larga duraci√≥n y de corta duraci√≥n, ahora se usan TimerQueue separados para ellos.  El temporizador de corta duraci√≥n se selecciona para que sea inferior a 1/3 de segundo.  No s√© por qu√© se eligi√≥ esa constante.  En .NET Core, no pudimos detectar problemas con los temporizadores. <br><br><img src="https://habrastorage.org/webt/f_/am/cv/f_amcv6bohiq54ciyuunvtrr0ei.jpeg"><br><br>  <a href="">https://github.com/Microsoft/dotnet-framework-early-access/blob/master/release-notes/NET48/dotnet-48-changes.md</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/dotnet/coreclr/labels/netfx-port-consider</a> <br><br>  Esta revisi√≥n se hizo backport a .NET Framework, versi√≥n 4.8.  La etiqueta netfx-port-consider se indica en el enlace anterior, si va al repositorio de .NET Core, CoreCLR, CoreFX, puede buscar este problema que se transferir√° a .NET Framework, ahora hay alrededor de cincuenta de ellos.  Es decir, el .NET de c√≥digo abierto ayud√≥ mucho, se corrigieron bastantes errores.  Puede leer el registro de cambios .NET Framework 4.8: se han corregido muchos errores, mucho m√°s que en otras versiones de .NET.  Curiosamente, esta soluci√≥n est√° desactivada de forma predeterminada en .NET Framework 4.8.  Se incluye en todo el archivo que conoce llamado App.config <br><br>  La configuraci√≥n en App.config que habilita esta correcci√≥n se llama UseNetCoreTimer.  Antes de que apareciera .NET Framework 4.8, para que nuestra aplicaci√≥n funcionara y no entrara en el convoy de bloqueo, ten√≠a que usar su implementaci√≥n de Task.Delay.  En √©l, intentamos usar un mont√≥n binario para comprender de manera m√°s eficiente qu√© temporizadores deber√≠an llamarse ahora. <br><br><h3>  1.5 Tarea. Retraso: implementaci√≥n nativa </h3><br><ul><li>  Binaryheap </li><li>  Sharding </li><li>  Ayud√≥, pero no en todos los casos. </li></ul><br>  El uso de un almacenamiento din√°mico binario le permite optimizar la Rutina, que llama a las devoluciones de llamada, pero empeora el tiempo que lleva eliminar un temporizador arbitrario de la cola; para esto necesita reconstruir el almacenamiento din√°mico.  Esto es muy probable por qu√© .NET utiliza una lista doblemente vinculada.  Por supuesto, solo usar un mont√≥n binario no nos ayudar√≠a aqu√≠, tambi√©n tuvimos que resolver TimerQueue.  Esta soluci√≥n funcion√≥ durante un tiempo, pero a√∫n as√≠ todo volvi√≥ a caer en el convoy de bloqueo debido al hecho de que los temporizadores se usan no solo donde se ejecutan expl√≠citamente en el c√≥digo, sino tambi√©n en bibliotecas de terceros y c√≥digo .NET.  Para solucionar completamente este problema, debe actualizar a .NET Framework versi√≥n 4.8 y habilitar la soluci√≥n de los desarrolladores de .NET. <br><br><h3>  1.6 Tarea. Retraso: conclusiones </h3><br><ul><li>  Errores en todas partes, incluso en las cosas m√°s utilizadas </li><li>  Haz pruebas de estr√©s </li><li>  Cambie a Core, obtenga correcciones de errores (y nuevos errores) primero :) </li></ul><br>  ¬øCu√°les son las conclusiones de toda esta historia?  En primer lugar, las trampas se pueden ubicar realmente en todas partes, incluso en las clases que usa todos los d√≠as sin pensar, por ejemplo, en la misma Tarea, Tarea. Retraso. <br><br>  Recomiendo realizar pruebas de estr√©s de sus propuestas.  Este problema lo acabamos de identificar en la etapa de prueba de carga.  Luego lo filmamos varias veces en producci√≥n en otras aplicaciones, pero, sin embargo, las pruebas de estr√©s nos ayudaron a retrasar el tiempo antes de encontrar este problema en la realidad. <br><br>  Cambie a .NET Core: ser√° el primero en recibir correcciones de errores (y nuevos errores).  ¬øD√≥nde sin nuevos errores? <br><br>  La historia sobre los temporizadores ha terminado y pasamos a la siguiente. <br><br><h2>  Historia 2: SemaphoreSlim </h2><br>  La siguiente historia es sobre el conocido SemaphoreSlim. <br><br><h3>  2.1 Limitaci√≥n del servidor </h3><br><ul><li>  Se requiere limitar el n√∫mero de solicitudes procesadas simult√°neamente en el servidor </li></ul><br>  Quer√≠amos implementar la limitaci√≥n en el servidor.  Que es esto  Probablemente todos conozcan la aceleraci√≥n de la CPU: cuando el procesador se sobrecalienta, disminuye su frecuencia para enfriarse, y esto limita su rendimiento.  Entonces est√° aqu√≠.  Sabemos que nuestro servidor puede procesar N solicitudes en paralelo y no caerse.  Que queremos hacer  Limite el n√∫mero de solicitudes procesadas simult√°neamente a esta constante y aseg√∫rese de que, si llegan m√°s solicitudes, hagan cola y esperen hasta que se ejecuten las solicitudes anteriores.  ¬øC√≥mo se puede resolver este problema?  Es necesario utilizar alg√∫n tipo de sincronizaci√≥n primitiva. <br><br>  Semaphore es una primitiva de sincronizaci√≥n en la que puede esperar N veces, despu√©s de lo cual el que llega N + primero y as√≠ sucesivamente esperar√° hasta que aquellos que ingresaron antes liberen Semaphore.  Resulta algo como esto: dos hilos de ejecuci√≥n, dos trabajadores fueron bajo Sem√°foro, el resto estaba en l√≠nea. <br><br><img src="https://habrastorage.org/webt/6s/bu/h7/6sbuh77p4temzi5yiofjlh-rxoi.png"><br><br>  Por supuesto, es solo que Semaphore no es muy adecuado para nosotros, est√° en .NET sincr√≥nico, as√≠ que tomamos SemaphoreSlim y escribimos este c√≥digo: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> semaphore = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SemaphoreSlim(N); ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> semaphore.WaitAsync(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> HandleRequestAsync(request); semaphore.Release();</code> </pre> <br>  Creamos SemaphoreSlim, espere, bajo Semaphore procesamos su solicitud, luego de eso lanzamos Semaphore.  Parece que esta es una implementaci√≥n ideal de la limitaci√≥n del servidor, y ya no puede ser mejor.  Pero todo es mucho m√°s complicado. <br><br><h3>  2.2 Regulaci√≥n del servidor: complicaci√≥n </h3><br><ul><li>  Procesando solicitudes en orden LIFO </li><li>  Sem√°foroSlim </li><li>  Pila concurrente </li><li>  TaskCompletionSource </li></ul><br>  Nos olvidamos un poco de la l√≥gica empresarial.  Las solicitudes que llegan a la aceleraci√≥n son solicitudes http reales.  Como regla, tienen un tiempo de espera establecido por aquellos que enviaron esta solicitud autom√°ticamente o un tiempo de espera del usuario que presiona F5 despu√©s de un tiempo.  En consecuencia, si procesa solicitudes en un orden de cola, como un sem√°foro normal, entonces, en primer lugar, las solicitudes de la cola que han excedido el tiempo de espera ya pueden procesarse.  Si trabaja en orden de pila, primero procese las solicitudes que llegaron por √∫ltima vez, tal problema no surgir√°. <br><br>  Adem√°s de SemaphoreSlim, tuvimos que usar ConcurrentStack, TaskCompletionSource, para envolver mucho c√≥digo alrededor de todo esto, de modo que todo funcionara en el orden que necesit√°bamos.  TaskCompletionSource es tal cosa, que es similar a CancellationTokenSource, pero no para CancellationToken, sino para Task.  Puede crear una TaskCompletionSource, extraer una Tarea de ella, entregarla y luego decirle a TaskCompletionSource que necesita establecer el resultado para esta Tarea, y aquellos que est√©n esperando esta Tarea se enterar√°n de este resultado. <br><br>  Todos lo hemos implementado.  El c√≥digo es horrible.  y, lo peor de todo, result√≥ no funcionar. <br><br>  Unos meses despu√©s del inicio de su uso en una aplicaci√≥n bastante cargada, encontramos un problema.  De la misma manera que en el caso anterior, el consumo de CPU ha aumentado al 100%.  Hicimos lo mismo, retiramos el basurero, lo miramos en WinDbg y nuevamente encontramos el convoy de la cerradura. <br><br><img src="https://habrastorage.org/webt/h_/ef/as/h_efasuul34r0fm7vwopo2hm1bc.jpeg"><br><br>  Esta vez, el convoy de bloqueo se produjo dentro de SemaphoreSlim.WaitAsync y SemaphoreSlim.Release.  Result√≥ que hay un bloqueo dentro de SemaphoreSlim, no est√° libre de bloqueo.  Esto result√≥ ser un inconveniente bastante serio para nosotros. <br><br><img src="https://habrastorage.org/webt/0h/-k/qq/0h-kqqxojlujm3dglokmacabvwq.jpeg"><br><br>  Dentro de SemaphoreSlim hay un estado interno (un contador de cu√°ntos trabajadores a√∫n pueden pasar por debajo de √©l), y una lista doblemente vinculada de aquellos que esperan en este Sem√°foro.  Las ideas aqu√≠ son m√°s o menos las mismas: puede esperar en este sem√°foro, puede cancelar su expectativa para abandonar esta fila.  Hay una cerradura que acaba de arruinar nuestras vidas. <br><br>  Decidimos: abajo con todo el terrible c√≥digo que ten√≠amos que escribir. <br><br><img src="https://habrastorage.org/webt/ax/ls/3i/axls3iseuxmgjt-vqkeiqs7hvtq.jpeg"><br><br>  Escribamos nuestro sem√°foro, que estar√° inmediatamente libre de bloqueos y que funcionar√° inmediatamente en orden de pila.  Cancelar la espera no es importante para nosotros. <br><br><img src="https://habrastorage.org/webt/rv/rg/wv/rvrgwv8apebibtiymhxpvm5giti.jpeg"><br><br>  Define esta condici√≥n.  Aqu√≠ estar√° el n√∫mero currentCount: esta es la cantidad de lugares que quedan en el sem√°foro.  Si no quedan asientos en Semaphore, este n√∫mero ser√° negativo y mostrar√° cu√°ntos trabajadores hay en la cola.  Tambi√©n habr√° un ConcurrentStack, que consiste en TaskCompletionSource'ov, que es solo una pila de waiter'ov del que se extraer√°n si es necesario.  Escribamos el m√©todo WaitAsync. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> decrementedCount = Interlocked.Decrement(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> currentCount); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (decrementedCount &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.CompletedTask; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> waiter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;(); waiters.Push(waiter); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> waiter.Task;</code> </pre> <br>  Primero, disminuimos el contador, tomamos un lugar en el sem√°foro para nosotros, si tuvi√©ramos lugares libres, y luego decimos: "Eso es, te metiste debajo del sem√°foro". <br><br>  Si no hab√≠a lugares en Semaphore, creamos una TaskCompletionSource, la lanzamos a la pila de waiter'ov y devolvemos la Task al mundo exterior.  Cuando llegue el momento, esta tarea funcionar√°, y el trabajador podr√° continuar su trabajo y pasar√° a Sem√°foro. <br><br>  Ahora escribamos el m√©todo Release. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> countBefore = Interlocked.Increment(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> currentCount) - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (countBefore &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (waiters.TryPop(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> waiter)) waiter.TrySetResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre> <br>  El m√©todo de lanzamiento es el siguiente: <br><br><ul><li>  Un asiento libre en sem√°foro </li><li>  Incremento currentCount </li></ul><br>  Si podemos saber por currentCount si hay un camarero dentro de la pila sobre el que necesitamos se√±alizar, sacamos a dicho camarero de la pila y la se√±al.  Aqu√≠ el camarero es una TaskCompletionSource.  Pregunta a este c√≥digo: parece ser l√≥gico, pero ¬øfunciona?  Que problemas hay  Hay un matiz relacionado con d√≥nde se inician continuation'y y TaskCompletionSource'y. <br><br><img src="https://habrastorage.org/webt/_1/zo/hu/_1zohu07rqeiemrkwrcubv7gwhe.png"><br><br>  Considera este c√≥digo.  Creamos una TaskCompletionSource y lanzamos dos Task's.  La primera tarea muestra una unidad, establece el resultado en una TaskCompletionSource y luego muestra un deuce en la consola.  La segunda tarea espera en este TaskCompletionSource, en su tarea, y luego bloquea para siempre su hilo del grupo de hilos. <br><br>  ¬øQu√© pasar√° aqu√≠?  La tarea 2 en la compilaci√≥n se dividir√° en dos m√©todos, el segundo de los cuales es una continuaci√≥n que contiene Thread.Sleep.  Despu√©s de configurar el resultado de TaskCompletionSource, esta continuaci√≥n se ejecutar√° en el mismo hilo en el que se ejecut√≥ la primera tarea.  En consecuencia, el flujo de la primera Tarea se bloquear√° para siempre y el deuce a la consola ya no se imprimir√°. <br><br>  Curiosamente, intent√© cambiar este c√≥digo, y si elimin√© la salida a la unidad de consola, se inici√≥ la continuaci√≥n en otro hilo del grupo de hilos y se imprimi√≥ el deuce.  En cuyo caso, la continuaci√≥n se ejecutar√° en el mismo hilo, y en el cual - llegar√° al grupo de hilos - una pregunta para los lectores. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tcs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;( TaskCreationOptions.RunContinuationsAsynchronously); <span class="hljs-comment"><span class="hljs-comment">/* OR */</span></span> Task.Run(() =&gt; tcs.TrySetResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>));</code> </pre> <br>  Para resolver este problema, podemos crear un TaskCompletionSource con el indicador RunContinuationsAsynchronously correspondiente, o llamar al m√©todo TrySetResult dentro de Task.Run/ThreadPool.QueueUserWorkItem para que no se ejecute en nuestro hilo.  Si se ejecuta en nuestro hilo, podemos tener efectos secundarios no deseados.  Adem√°s, hay un segundo problema, nos detendremos en √©l con m√°s detalle. <br><br><img src="https://habrastorage.org/webt/m9/x8/gx/m9x8gxz7x5tw3mjcps7nygdmkjs.jpeg"><br><br>  Mire los m√©todos WaitAsync y Release e intente encontrar otro problema en el m√©todo Release. <br><br>  Muy probablemente, encontrarla tan simplemente imposible.  Hay una carrera aqu√≠. <br><br><img src="https://habrastorage.org/webt/cs/1e/4q/cs1e4q3yaz4d3084_24z2ucsd6y.jpeg"><br><br>  Se debe al hecho de que en el m√©todo WaitAsync el cambio de estado no es at√≥mico.  Primero disminuimos el mostrador y solo luego empujamos al camarero hacia la pila.  Si sucede que Release se ejecuta entre decremento y push, puede salir para que no saque nada de la pila.  Esto debe tenerse en cuenta y, en el m√©todo Release, espere a que aparezca el camarero en la pila. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> countBefore = Interlocked.Increment(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> currentCount) - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (countBefore &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Waiter waiter; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> spinner = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpinWait(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!waiter.TryPop(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> waiter)) spinner.SpinOnce(); waiter.TrySetResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre> <br>  Aqu√≠ lo hacemos en un bucle hasta que logramos sacarlo.  Para no volver a desperdiciar los ciclos del procesador, usamos SpinWait. <br><br>  En las primeras iteraciones, girar√° en un bucle.  Si hay muchas iteraciones, el camarero no aparecer√° durante mucho tiempo, entonces nuestro hilo ir√° a Thread.Sleep, para no desperdiciar recursos de la CPU una vez m√°s. <br><br>  De hecho, el sem√°foro de orden LIFO no es solo nuestra idea. <br><blockquote>  <b>LowLevelLifoSemaphore</b> <br><ul><li>  S√≠ncrono </li><li>  En Windows usa el puerto IO Completion como una pila de Windows </li></ul><br>  <a href="">https://github.com/dotnet/corert/blob/master/src/System.Private.CoreLib/src/System/Threading/LowLevelLifoSemaphore.cs</a> </blockquote>  Existe tal sem√°foro en .NET en s√≠, pero no en CoreCLR, no en CoreFX, sino en CoreRT.  A veces es bastante √∫til echar un vistazo al repositorio .NET.  Hay un sem√°foro llamado LowLevelLifoSemaphore.  Este sem√°foro no nos convendr√≠a de todos modos: es sincr√≥nico. <br><br>  Sorprendentemente, en Windows funciona a trav√©s de puertos IO Completion.  Tienen la propiedad de que los subprocesos pueden esperarlos, y estos subprocesos se liberar√°n solo en el orden LIFO.  Esta caracter√≠stica se usa all√≠, es realmente de bajo nivel. <br><br><h3>  2.3 Conclusiones: </h3><br><ul><li>  No esperes que el relleno del marco sobreviva bajo tu carga </li><li>  Es m√°s f√°cil resolver un problema espec√≠fico que el caso general. </li><li>  La prueba de esfuerzo no siempre ayuda </li><li>  Cuidado con el bloqueo </li></ul><br>  ¬øCu√°les son las conclusiones de toda esta historia?  En primer lugar, no espere que algunas clases del marco que utiliza de la biblioteca est√°ndar puedan hacer frente a su carga.  No quiero decir que SemaphoreSlim es malo, simplemente result√≥ ser inadecuado espec√≠ficamente en este escenario. <br><br>  Result√≥ ser mucho m√°s f√°cil para nosotros escribir nuestro sem√°foro para una tarea espec√≠fica.  Por ejemplo, no admite la cancelaci√≥n de la espera.  Esta caracter√≠stica est√° disponible en el SemaphoreSlim habitual, no la tenemos, pero esto nos permiti√≥ simplificar el c√≥digo. <br><br>  La prueba de carga, aunque ayuda, puede no siempre ayudar. <br><br> .NET  ,           ‚Äî   .        lock,  : ¬´    ?¬ª     CPU 100%,     lock', , ,   -  .NET.      . <br><br>    . <br><br><h2>  3: (A)sync IO </h2><br>    /,      . <br><br><img src="https://habrastorage.org/webt/84/qh/sz/84qhsz9je7twmgbswt5so0dfx2q.jpeg"><br><br>    lock convoy,    stack trace     Overlapped  PinnableBufferCache.   lock.     : Overlapped  PinnableBufferCache? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OVERLAPPED</a> ‚Äî    Windows,      /.      ,        .        ,  .       ,     lock convoy.   ,      lock convoy,    ,   . <br><br><img src="https://habrastorage.org/webt/if/j_/fc/ifj_fclqmvkfgfff7zedxpj63mo.jpeg"><br><br>  ,       ,   .NET 4.5.1  4.5.2.     .NET 4.5.2,     ,    .NET 4.5.2.  .NET 4.5.1     OverlappedDataCache,      Overlapped ‚Äî ,       ,   .    ,  lock-free,   ConcurrentStack,       .  .NET 4.5.2     :  OverlappedDataCache   PinnableBufferCache. <br><br>   ? PinnableBufferCache     ,   Overlapped     ,    ,       ‚Äî      . ,     ,      . PinnableBufferCache     .   , lock-free,   ConcurrentStack.     ,      .        ,        ,  -    lock-free    list  lock'. <br><br><h3> 3.1 PinnableBufferCache </h3><br> LockConvoy: <br><br><ul><li>    </li><li>      </li></ul><br>  lock convoy  ,   -     .        list      ,     lock   ,  ,                . <br><br>     PinnableBufferCache  ,         .    : <br><br><pre> <code class="plaintext hljs">PinnableBufferCache_System.ThreadingOverlappedData_MinCount</code> </pre> <br>      ,      .  : ¬´ !         -  ¬ª.         -: <br><br><pre> <code class="cs hljs">Environment.SetEnvironmentVariable( <span class="hljs-string"><span class="hljs-string">"PinnableBufferCache_System.Threading.OverlappedData_MinCount"</span></span>, <span class="hljs-string"><span class="hljs-string">"10000"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Overlapped().GetHashCode(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) GC.Collect(GC.MaxGeneration, GCCollectionMode.Forced);</code> </pre> <br>    ?     ,    Overlapped  ,   ,        .     ,   ,     ,     ,  PinnableBufferCache      lock convoy'.    ,           . <br><br>  .NET Core  PinnableBufferCache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> ,   OverlappedData   . ,        , Garbage collector     ,      .     .NET Core  .  .NET Framework,   ,     . <br><br><h3> 3.2 : </h3><br><ul><li>      </li><li>      </li><li>   .NET Core </li></ul><br>      ,     .   ,   .NET            ,       . ,  ,  .NET Core. ,     ,         -. <br><br>    key-value . <br><br><h2>  4: Concurrent key-value collections </h2><br>  .NET   concurrent-.  lock-free  ConcurrentStack  ConcurrentQueu,       .   ConcurrentDictionary,    .   lock-free  ,   ,      .    ConcurrentDictionary? <br><br><h3> 4.1 ConcurrentDictionary </h3><br> : <br><br><ul><li>  </li><li>  </li></ul><br>  Pros: <br><br><ul><li>     </li><li>   (TryAdd/TryUpdate/AddOrUpdate) </li><li> Lock-free  </li><li> Lock-free enumeration </li></ul><br>      , memory-,  ,        .    ,    ,    .NET Framework.            . ,  ,      (enumeration) lock-free. ,   . <br><br>  ,   ,   -  .NET.  key-value    -    : <br><br><img src="https://habrastorage.org/webt/ff/9f/g_/ff9fg_qzzuzvafep8c-p3seyigm.jpeg"><br><br>  -,     bucket'.      bucket',    .   ,    bucket   ,       . <br><br>    ‚Äî   ,  ConcurrentDictionary.  ConcurrentDictionary    ¬´-¬ª   .    ,      ,   ,       memory traffic.     ConcurrentDictionary,   lock'.   ‚Äî   . <br><br>    ,    Dictionary. <br><br><img src="https://habrastorage.org/webt/-_/dw/jo/-_dwjoxswmd1kecoi3aln8m7bow.jpeg"><br><br>  Dictionary  ,  Concurrent,      .     :  buckets,  entries.   buckets       bucket'   entries.   ¬´-¬ª    entries.          .      ¬´-¬ª   int,     bucket'. <br><br>   memory overhead,     ConcurrentDictionary   Dictionary. <br><br><img src="https://habrastorage.org/webt/em/aa/ch/emaachor-z_xxt7m_1wc7ntqupm.jpeg"><br><br>    Dictionary. Memory overhea'    ,       .    Dictionary  overhead  -    ,  int'.  8 . <br><br>    ConcurrentDictionary.  ConcurrentDictionary     ConcurrentDictionary.Node.   , .     int hashCode        .       ,    table (  16 ),  int hashCode     .      ,   64-    28  overhead'.       Dictionary. <br><br>  memory overhead', ConcurrentDictionary     GC   ,       .     Benchmark.   ConcurrentDictionary  ,       GC.Collect.    ? <br><br><img src="https://habrastorage.org/webt/on/yj/uq/onyjuq1rqgfkv8iav5x4z8nrnq8.jpeg"><br><br>     .       ConcurrentDictionary  10  ,        ,             ,      .   Dictionary   .      ,   ,  ,    .       . <br><br>     ,     ConcurrentDictionary? <br><br><h3> 4.2   </h3><br><ul><li>    </li><li> TTL </li><li> Dictionary+lock </li><li> Sharding </li></ul><br>     .      ConcurrentDictionary.        10  .   ,     .   TTL  ,    .        Dictionary  lock'. ,  ,  lock    .       Dictionary  lock'      ,   -     ,           lock.      ,     . <br><br><h3> 4.3  </h3><br><ul><li>   in-memory  &lt;Guid,Guid&gt; </li><li>   &gt;10 <sup>6</sup>  </li><li>       </li><li>   </li><li>        </li></ul><br>     .      ‚Äî      ,       in-memory   Guid'  Guid,     .       .     - - ,     .  ,            15    .   .     Semaphore     ConcurrentDictionary. <br><br><img src="https://habrastorage.org/webt/u4/kw/kt/u4kwkttmxwpyelqlqoqp9zxahaa.jpeg"><br><br> ,    lock-free    ,    overhead      GC.   ,          .      ,    ,       ,   .   ,     -  ,       ,    .  ,  ,      Large Object Heap.  Por que no <br><br>       ,     ,     Dictionary   . <br><br><img src="https://habrastorage.org/webt/kx/yn/oi/kxynoiatsy8zcyrc5dei-xohlk4.jpeg"><br><br>   Dictionary   bucket',  Entry.  Entry  , ,   ,   . <br><br><img src="https://habrastorage.org/webt/n8/7a/5r/n87a5rlkgdk62nw82qysi3fmi18.png"><br><br>  Dictionary   ,   ,      . ,     - . <br><br>      ,  -     ? -,  ,       ,     ,      .     .    Dictionary,     , buckets, entries,              Interlocked. ,         . <br><blockquote> <b>Dictionary</b> <br><ul><li>   ,    </li><li>     ,   ? <br> ‚Äî  Resize  buckets  entries   <br> ‚Äî      - <br> ‚Äî    Dictionary.Entry <br> ‚Äî   -   </li></ul><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://blogs.msdn.microsoft.com/tess/2009/12/21/high-cpu-in-net-app-using-a-static-generic-dictionary/</a> </blockquote>     ,       Dictionary       -  bucket'.       ,      .    ,     ,        .       ,       ,    . <br><br>      Entry  Dictionary.     - -    .  ,     . <br><br><img src="https://habrastorage.org/webt/4p/xb/aq/4pxbaqil2cd4jaxnayxjqz-5yae.jpeg"><br><br>    .NET Framework  1.1.     Hashtable,   Dictionary,    object'.     MSDN ,      .  ,             -.   .  ,  Hashtable  .  ,      . <br><br><h3> 4.4    Dictionary.Entry </h3><br><img src="https://habrastorage.org/webt/y2/ww/rs/y2wwrslyuqpioqcalmpnt8dh6cw.jpeg"><br>    ? Dictionary.Entry ,  ,  8 , ,  ,   ,     .   ? <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> writing; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> version; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.writing = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; buckets[index] = ‚Ä¶; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.version++; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.writing = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>   :  (    ,    )  int-.   ,  .   ,     , ,  ,  . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> writing; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> version; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> version = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.version; bucket = bickets[index]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.writing || version != <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.version) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br>    ,     ,         .       ,   .       ,  8 . <br><br><h3> 4.5   -   </h3><br>  ,   . <br><br><img src="https://habrastorage.org/webt/hh/bp/0l/hhbp0leb95qndz4bmg-2gtvmeue.jpeg"><br><br>  Dictionary     bucket    ,     . <br><br>  Dictionary,    .      : 0  2.   bucket, 1       2.   ?     0.   ,       ,    2.     .   ,  2,       , , 1. 1       2 ‚Äî     bucket.   ,      ,   .    1 ‚Äî ,     bucket.  Hashtable     ,     bucket'  -.        ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">double hashing</a> . <br><br><h3> 4.6   </h3><br><ul><li>     </li><li>      </li></ul><br> <b></b> <br><br><ul><li>        </li><li>    ,  resize </li></ul><br> <b></b> <br><br><ul><li>     ,      </li></ul><br>        .         ,       Buckets,     Entries (   Buckets,     Entries).   -  ,       ,   ,          ,    . <br><br>             .    ,    . <br><br>  :     ,      ,    ,     ,     . ,       ,   . <br><br><img src="https://habrastorage.org/webt/pm/lo/ah/pmloah0wlfbq7ilvlnrvbh3pyuu.png"><br><br>     ,   , ‚Äî  . <br><br>   ?   ,  -    2.   -   Capacity  ,            .    ‚Äî 2.       ,   .      2.    ?  ,  ,     ,   .    -  ,        ,       3. ,    ,  ,    ,  ,  . <br><br>  ,    Hashtable,  .   ,     double hashing.     ,       ,   ,     . <br><br>   ,      ,     ‚Äî   ,            .     Hashtable.   ,    ‚Äî     ‚Äî       .                 .  ,     bucket',       -  ,       .  . <br><br>     ,  ,   lock-free      LOH. <br><br><img src="https://habrastorage.org/webt/pg/2b/6b/pg2b6bbfkm_3nnkds27g2krziz8.jpeg"><br><br>   lock-free ?  MSDN    Hashtable ,      .    ,            ,            . <br><br><img src="https://habrastorage.org/webt/yu/sg/he/yusghe0crfu9ywaic0aozpr7wri.jpeg"><br><br>      ,     ,        ,   bucket'.         Dictionary  bucket',  -,   bucket'      .    -    bucket,  bucket  .      ,     . <br><br>  ,       Large Object Heap. <br><br><img src="https://habrastorage.org/webt/wf/po/8o/wfpo8ou1_fpzhdkgcdbjzw-7u9q.jpeg"><br><br>      .  CustomDictionary  CustomDictionarySegment    .   Dictionary,    ,      .   ‚Äî   Dictionary,      .       ,      Large Object Heap.        ,   bucket'   . ,      ,    ,   bucket,     - - . <br><br>           .       ConcurrentDictionary,     .NET,        ,      . <br><br><h3> 4.7  </h3><br><ul><li> .NET   </li><li>    </li><li>   </li><li> ,     </li><li>   </li><li>   </li></ul><br>     ? .NET  .   .   ,     ,       .    -   ‚Äî   - .   ,  , ,     . <br><br>  -   , ,   ,     ,   .   ,   ,   ,        , ,          .   ‚Äî   , ,   . <br><br><h3>   </h3><br><ul><li>   ConcurrentDictionary: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://habr.com/ru/company/skbkontur/blog/348508/</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/vostok/commons.threading</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/epeshk/dotnext-2019-threading</a> </li></ul><br>   ‚Äî          ConcurrentDictionary. ,      ,   ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Diafilm</a> ),       . <br><br>      GitHub.   ‚Äî     ,    ,    LIFO-Semaphore,    .       ,    . <br><blockquote> 6-7     <b>DotNext 2019 Moscow</b>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬´.NET:  ¬ª</a>    ,        .NET Framework  .NET Core,  ,        . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/468611/">https://habr.com/ru/post/468611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../468601/index.html">Estimaci√≥n del plazo del proyecto. ¬øPor qu√© es casi siempre muy discreto y qu√© hacer al respecto?</a></li>
<li><a href="../468603/index.html">Rutracker ha incluido eSNI. Fin de la era DPI y fin de las cerraduras</a></li>
<li><a href="../468605/index.html">Punteros constantes a punteros a punteros ...</a></li>
<li><a href="../468607/index.html">Android para el ingeniero de radio (segunda parte)</a></li>
<li><a href="../468609/index.html">El rendimiento incomprensible de la programaci√≥n m√∫ltiple</a></li>
<li><a href="../468615/index.html">Los 10 idiomas principales para la localizaci√≥n de aplicaciones</a></li>
<li><a href="../468621/index.html">Traducimos la red dom√©stica a DoH u otro clic en el filtro de nariz</a></li>
<li><a href="../468623/index.html">Quiero comentarios sobre Habr</a></li>
<li><a href="../468625/index.html">Sin servidor: 15% m√°s lento y ocho veces m√°s caro</a></li>
<li><a href="../468627/index.html">M√≥dulos de E / S ADAM-6200</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>