<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏂🏼 🆔 👩🏾‍🍳 Wir zeigen einen digitalen Fotorahmen im Internet an ◻️ 🧘🏼 🕵️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wahrscheinlich haben sich viele beim Betrachten des digitalen Fotorahmens Gedanken darüber gemacht, ob es möglich ist, ihre eigenen Informationen anzu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir zeigen einen digitalen Fotorahmen im Internet an</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/384177/"><img src="https://habrastorage.org/getpro/geektimes/post_images/6e0/7f6/558/6e07f655878fd2feef35f5e53bb87465.jpg" alt="Bild" align="right"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wahrscheinlich haben sich viele beim Betrachten des digitalen Fotorahmens Gedanken darüber gemacht, ob es möglich ist, ihre eigenen Informationen anzuzeigen, die sich im Laufe der Zeit ändern. </font><font style="vertical-align: inherit;">Da ich seit mehreren Jahren Eigentümer des Fotorahmens bin, kam mir eine solche Idee: Der Rahmen eignet sich perfekt für die Anzeige von Wettervorhersagen und Informationen aus dem „Smart Home“. </font><font style="vertical-align: inherit;">Informationen zum Implementieren solcher Funktionen, ohne das Design des Rahmens zu beeinträchtigen - lesen Sie unter der Katze.</font></font><br>
<a name="habracut"></a><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementierungsmethoden</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die einfachste Möglichkeit, das auf dem digitalen Fotorahmen angezeigte Bild zu steuern, besteht darin, vorbereitete Bilder, die in seinem Speicher gespeichert sind, auf die erforderliche Weise umzuschalten. Hier ist </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine Beispielimplementierung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dieser Methode. Offensichtlich ist diese Methode nicht sehr flexibel - Sie können eine einzelne Variablennummer anzeigen, und das Ändern dieser Nummer ist recht langsam.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sofern es nicht möglich ist, den Rahmen zu zerlegen, müssen nur die externen Speicherschnittstellen verwendet werden - SPI (für die Arbeit mit SD-Karte) und USB. Es reicht aus, ein Gerät zu erstellen, das ein externes Laufwerk simuliert, es mit dem Frame zu verbinden - und es fordert selbst Bilder von einem solchen Gerät an. Die Verwendung eines Mikrocontrollers zum Emulieren einer SD-Karte ist ziemlich schwierig, und der Formfaktor der Karte selbst ist ziemlich schwer zu wiederholen. Man könnte eine fertige WiFi-SD-Karte verwenden, aber alle mir bekannten Karten waren zu teuer (&gt; 40 US-Dollar, was nahe an den Kosten des Frames selbst liegt). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Verwendung von USB zur Lösung dieses Problems ist besser geeignet. Es ist kein Problem, einen produktiven Mikrocontroller mit USB-Unterstützung zu finden. Der Anschluss an den Rahmen erfolgt über einen Standardstecker. Darüber hinaus gab es bereits eine </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Veröffentlichung</font></a><font style="vertical-align: inherit;"> zu Habré</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">speziell für die Emulation eines USB-Laufwerks mit dem stm32-Mikrocontroller. </font><font style="vertical-align: inherit;">In den Kommentaren zu diesem Artikel wurde die Möglichkeit der Übertragung dynamisch wechselnder Daten mit dieser Methode erörtert. </font><font style="vertical-align: inherit;">Da das Betriebssystem beim Lesen einer Datei Daten zwischenspeichert, ist es nicht sinnvoll, den Inhalt emulierter Dateien zu ändern. Das Betriebssystem fordert sie einfach nicht an, da es nicht feststellen kann, dass sie geändert wurden. </font><font style="vertical-align: inherit;">Fotorahmen zwischenspeichern jedoch keine Dateien (sie haben einfach nicht die richtige Menge an RAM)! </font><font style="vertical-align: inherit;">Sie können dies überprüfen, indem Sie ein beliebiges USB-Flash-Laufwerk an den Fotorahmen anschließen. Beim Lesen von Dateien blinkt eine LED. Beim Lesen von Dateien blinkt sie ständig. </font><font style="vertical-align: inherit;">Deshalb habe ich mich für diese spezielle Methode entschieden.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Software-Teil</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich hatte bereits das STM32F4DISCOVERY-Debugboard, daher habe ich beschlossen, den Betrieb der im obigen Artikel vorgeschlagenen Emfat-Bibliothek zu überprüfen. Es gab keine Probleme mit Windows 7, aber der Fotorahmen konnte die Dateien auf der „virtuellen“ Festplatte nicht erkennen. Wie sich später herausstellte, hat das Android-Tablet das Laufwerk ebenfalls nicht erkannt. Ein anderer Ubuntu-Computer hat ein USB-Gerät erkannt, konnte das Laufwerk jedoch nicht mounten. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich musste das Problem tiefer angehen. Wie sich herausstellte, konnte TestDisk trotz der Tatsache, dass Windows das Laufwerk erkannte und Dateien daraus lesen konnte, das darauf befindliche Dateisystem nicht bestimmen:</font></font><br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/f3b/e67/bf7/f3be67bf7a36fcf33544e192e9ac1849.png" alt="Bild"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach und nach erkannte ich die Ergebnisse der von TestDisk bereitgestellten Rohdaten und untersuchte den Quellcode dieses Programms. Eines der Kriterien, anhand derer TestDisk das verwendete Dateisystem bestimmt, ist die Festplattengröße. In emfat hängt die Größe der emulierten Festplatte von der Datenmenge ab. Wenn sich also eine oder mehrere kleine Dateien auf der Festplatte befinden, wird die Festplattengröße 16 MB nicht überschreiten. Gleichzeitig legt FAT32 Beschränkungen für die Mindestvolumengröße fest - mindestens 65527 Cluster. Wenn man bedenkt, dass in "emfat" ein Cluster 4096 Bytes belegt, sollte die Festplattengröße für die FAT32-Konformität 65527 * 4096 ~ 268 MB betragen. In der Realität ist dies nicht der Fall, was zu Fehlern bei der Bestimmung des Dateisystemtyps führt. Ein Versuch, die Festplattenkapazität durch Erhöhen des Volumens der emulierten Datei auf 400 MB zu erhöhen, schlug fehl - möglicherweise passte dort etwas anderes nicht.Also habe ich beschlossen, "emfat" zu wiederholen, um das FAT16-Dateisystem zu emulieren.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Letztendlich gelang dies, und das Laufwerk wurde von allen Geräten korrekt erkannt: </font></font><br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/2af/9f5/214/2af9f52140870a70b7db4c4c268557ac.png" alt="Bild"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist erwähnenswert, dass FAT16 auch eine Beschränkung der Festplattengröße aufweist - mindestens 4087 Cluster, d. H. 16 MB in diesem Fall. Um diese Bedingung zu erfüllen, muss eine virtuelle Datei mit 20 MB in emfat erstellt werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Überprüfung mit dem Fotorahmen verlief einwandfrei. Der Rahmen zeigte erfolgreich das im Flash-Speicher des Controllers gespeicherte Testbild an. Der nächste Schritt besteht darin, benutzerdefinierte Bilder anzuzeigen. Der einfachste Weg, BMP-Dateien zu emulieren, besteht darin, dass sie eine ziemlich einfache Struktur haben. Das Bild kann 256 Farben haben, d. H. Es gibt ein Byte pro Pixel. Aber nur in diesem Fall benötigen Sie 480 KB RAM, um ein Bild der Größe 800 * 600 zu speichern. Der Mikrocontroller verfügt nicht über eine solche Speicherkapazität, sodass nur noch eine Option übrig bleibt - das Bild im laufenden Betrieb zu erstellen. Das Funktionsprinzip lautet wie folgt: Wenn das Host-Gerät Daten aus einer Datei vom Laufwerk anfordert, ruft emfat die dieser Datei entsprechende Rückruffunktion auf. Die Nummer des Sektors, von dem Daten angefordert werden, und der Zeiger, mit dem diese Daten geschrieben werden sollen, werden an diese Funktion übertragen. Kenntnis der Sektornummer,Sie können bestimmen, welcher Teil des Bildes angefordert wird, und es formen.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Während der Experimente wurde eine unangenehme Tatsache entdeckt - Windows kann Daten von Sektoren anfordern, die nicht in Ordnung sind. Warum dies geschieht, ist nicht klar, aber dies erschwert die Bildung des Bildes im laufenden Betrieb, da nur die Sektornummer berechnet werden muss - welche Daten werden gerade angefordert. Ein weiteres Problem besteht darin, dass die Zeilen in BMP-Dateien von unten nach oben verlaufen, was die Berechnung der Position weiter erschwert. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um den Text anzuzeigen, habe ich die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mcufont-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bibliothek verwendet </font><font style="vertical-align: inherit;">. Dies ist praktisch, da Sie komprimierte Schriftarten verwenden können, wodurch die Verwendung von Flash-Speicher erheblich reduziert wird. Da ich ausreichend große Schriftarten verwendet habe, ist diese Funktion sehr wichtig.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Bibliothek schreibt das generierte Bild direkt in den Speicher. Damit die Bibliothek funktioniert, müssen Sie ein separates Array im RAM zuweisen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe auch das Rendern von Bildern aus dem Controller-Speicher implementiert. </font><font style="vertical-align: inherit;">Alle Bilder werden wie Text in Schwarzweiß angezeigt, wodurch Informationen zu 8 Pixeln in einem Byte des Bildes gespeichert werden können. </font><font style="vertical-align: inherit;">Um gewöhnliche Bilder in eine Ansicht zu konvertieren, die für die Verbindung mit einem Projekt geeignet ist, wurde das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LCD Assistant-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Programm verwendet </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infolgedessen wird auf dem angeschlossenen USB-Laufwerk ein Bild der folgenden Form erstellt:</font></font><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Überschrift</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/files/16a/699/689/16a699689e3f49efaf6ce6ba7dd1658d.png"></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem das Programm auf STM32F4DISCOVERY getestet wurde, habe ich das Gerät selbst hergestellt, bei dem es sich um einen Mikrocontroller handelt, an den ein WiFi-Modul auf dem ESP8266 angeschlossen ist. Von den geeigneten hatte ich nur den STM32F107RCT7-Controller. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Schaltung des resultierenden Geräts erwies sich als recht einfach: </font><font style="vertical-align: inherit;">
Aufgrund der Einschränkungen bei der Platinengröße - 17 x 36 mm (ich wollte es im fertigen Gehäuse installieren) und der Größe des Controllers war die Leiterplatte jedoch nicht am einfachsten herzustellen - doppelseitig, mit beidseitig montierten Teilen. Gleichzeitig mussten einige Stromleitungen mit einem Draht hergestellt werden. </font><font style="vertical-align: inherit;">
Ansicht der resultierenden Karte (während des Debuggens mit dem ESP-01-Modul):</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/geektimes/post_images/d32/edb/b4d/d32edbb4d3ec41ea2c94d465f7d0185e.png"></a><br><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/geektimes/post_images/a05/143/39b/a0514339b6515e7ccf6077d8f6b1ecaf.jpg"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit den angegebenen Kartengrößen war das WiFi-Modul ESP-03 am besten geeignet. So sieht die resultierende Karte mit dem bereits installierten Modul aus: </font><font style="vertical-align: inherit;">
Und von der Controllerseite: </font><font style="vertical-align: inherit;">
Während der Experimente stellte sich heraus, dass die Empfindlichkeit der Keramikantenne eindeutig nicht ausreichte - das Modul war kaum mit dem Router verbunden. Nach dem Anschließen eines 31-mm-Drahtstücks an den WIFI_ANT-Pin verbesserte sich die Empfindlichkeit deutlich und ähnelte der Empfindlichkeit des ESP-01. Der Ort, an dem der Fotorahmen fest installiert ist, befindet sich nur wenige Meter vom Router entfernt. Die native Antenne des Moduls funktioniert ebenfalls normal, sodass das Foto keine zusätzliche Antenne enthält.</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/geektimes/post_images/620/187/625/6201876252f2d5cf82453a382a6b2d6f.jpg"></a><br><font style="vertical-align: inherit;"></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/geektimes/post_images/297/73f/e0e/29773fe0ef0eda55b05038b15fe54ca1.jpg"></a><br>
<br><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da der ESP8266 im Dauerbetrieb ziemlich heiß war, habe ich beschlossen, ihn nur bei Informationsanfragen einzuschalten. Die Energieverwaltung kann über den Ausgang des CH_PD-Moduls erfolgen. Wenn Sie diesen Pin auf 0 setzen, wechselt der ESP8266 in den Energiesparmodus. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um das Testen des Betriebs des ESP8266 zu vereinfachen, habe ich eine separate Firmware für den Mikrocontroller geschrieben, der die USB-UART-Brücke implementiert. Dadurch wird das Modul so konfiguriert, dass es mit dem Router zusammenarbeitet, sodass der ESP8266 nach dem Einschalten automatisch eine Verbindung zu ihm herstellt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Funktionsprinzip des resultierenden Geräts ist recht einfach: Alle 10 Minuten versucht der Controller, Daten vom Server anzufordern. Wenn dies erfolgreich ist, werden die Wetterdaten aktualisiert. </font><font style="vertical-align: inherit;">Daten zur aktuellen Temperatur und zur Vorhersage für 3 Tage im Voraus werden von der Website openweathermap.org abgerufen. Informationen zur Temperatur außerhalb und innerhalb des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Balkons werden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vom </font><font style="vertical-align: inherit;">Majordomo-Server </font><font style="vertical-align: inherit;">abgerufen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Gleichzeitig fordert der Fotorahmen alle 6 Sekunden ein Bild an, während aktuelle Informationen angezeigt werden. </font><font style="vertical-align: inherit;">Da beide Prozesse gleichzeitig ablaufen können, wird DMA zum Empfangen von Daten vom ESP8266 verwendet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infolgedessen wird das folgende Bild auf dem Fotorahmen angezeigt: </font><font style="vertical-align: inherit;">
Quellcode des Projekts: </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">github.com/iliasam/USB_Photoframe</font></a></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/100/6b7/3fd/1006b73fd6d7be30e91c1412b8035d9d.jpg"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de384177/">https://habr.com/ru/post/de384177/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de384163/index.html">Quadcopter - wie hat alles angefangen?</a></li>
<li><a href="../de384165/index.html">Warum den Mars bombardieren?</a></li>
<li><a href="../de384171/index.html">Стюарт, Миньон Стюарт</a></li>
<li><a href="../de384173/index.html">DrinkMate: Ein Miniatur-Alkoholtester, mit dem Sie die richtigen Entscheidungen treffen können</a></li>
<li><a href="../de384175/index.html">Lichtsteuerung LC-07</a></li>
<li><a href="../de384179/index.html">Die Gesamtkosten aller Komponenten des iPhone 6s betragen 234 US-Dollar</a></li>
<li><a href="../de384181/index.html">Verlassene Einkaufskörbe</a></li>
<li><a href="../de384183/index.html">Научный семинар «Лазерная стереолитография и аддитивные технологии»</a></li>
<li><a href="../de384185/index.html">Die Moskauer Staatsuniversität liegt in der Nähe der hundert besten Universitäten</a></li>
<li><a href="../de384191/index.html">AR / VR kennenlernen: Nützliche Ressourcen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>