<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游뱞游낗 游뱣游 游녧 C칩mo crear formas personalizadas con MaterialShapeDrawable 游댮 鮫勇 游</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Material Design 2.0 introdujo varios conceptos nuevos. Una de ellas es la atenci칩n especial a las formas geom칠tricas de los elementos de la interfaz. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C칩mo crear formas personalizadas con MaterialShapeDrawable</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mobileup/blog/426997/"><img src="https://habrastorage.org/getpro/habr/post_images/585/f26/743/585f267433530ce6e9add3c7de072e35.jpg" alt="imagen"><br><br><p>  Material Design 2.0 introdujo varios conceptos nuevos.  Una de ellas es la atenci칩n especial a las formas geom칠tricas de los elementos de la interfaz.  Y hay una manera f치cil de hacer hermosas formas personalizadas.  Se llama MaterialShapeDrawable.  Veamos qu칠 tan 칰til y f치cil es usarlo. </p><a name="habracut"></a><br><p>  Hay varias formas de agregar elementos gr치ficos a la pantalla de una aplicaci칩n de Android.  Lo m치s sencillo es importar mapas de bits en formato webp o png.  Otra opci칩n es usar VectorDrawable, que le permite estirar la imagen al tama침o que necesita.  Otra forma de agregar gr치ficos a la pantalla es usar ShapeDrawable.  Estas 칰ltimas son la forma m치s f치cil de agregar un fondo simple o incluso crear un 칤cono.  Las im치genes creadas con ShapeDrawable son independientes de la densidad de p칤xeles en la pantalla.  Se pueden describir en un archivo xml, formar parte de otro recurso gr치fico (por ejemplo, StateListDrawable) y est치n presentes en el SDK de Android, comenzando con API v.1. </p><br><p>  Para cambiar la apariencia de una figura, podemos cambiar varias propiedades de ShapeDrawable: el nombre de la figura, el color de relleno (o degradado) y el color del borde de la figura.  Para los rect치ngulos, tambi칠n puede establecer el radio de las esquinas.  Con estas propiedades, puede crear gr치ficos que se utilizar치n como im치genes individuales en la pantalla, divisores, fondos de botones o para cualquier otro prop칩sito.  Si la aplicaci칩n usa la API v.21 + y ShapeDrawable como fondo para elementos con elevaci칩n, entonces la sombra debajo de estos elementos tambi칠n tendr치 la forma correcta: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/456/6b3/fd7/4566b3fd778a1edfdcce710510d1a2c4.png" alt="imagen"></p><br><p>  ShapeDrawable es una herramienta pr치ctica que casi siempre hace bien su trabajo, pero con la llegada de Material Design 2.0, los desarrolladores necesitan algo m치s flexible.  El nuevo sistema de dise침o fomenta el uso de diferentes formas para enfatizar su significado, condici칩n y estilo de aplicaci칩n individual.  Escrib칤 anteriormente que hay varias formas de hacer lo deseado, pero la m치s simple ya no es relevante.  쯉ignifica esto que necesitamos comenzar a usar gr치ficos vectoriales y as칤 perder la capacidad de "liberar" crear sombras para elementos de interfaz con elevaci칩n?  쯆 vale la pena volver a usar im치genes r치ster y crear recursos gr치ficos para seis posibles densidades de p칤xeles en la pantalla?  Afortunadamente, con el advenimiento de Material Design 2.0, apareci칩 una biblioteca de componentes completamente nueva. </p><br><p>  Esta biblioteca fue creada para unificar la apariencia y el comportamiento de la interfaz de usuario de Material Design en todas las versiones de Android y otras plataformas (hay versiones de esta biblioteca para iOS, la web y para Flutter).  La biblioteca de componentes implementa muchas caracter칤sticas para el nuevo dise침o de materiales.  Por ejemplo, incluye el componente BottomAppBar con el comportamiento esperado.  Entre otros componentes y utilidades, est치 la clase MaterialShapeDrawable.  En mi opini칩n, esta es una herramienta necesaria para resolver las tareas que el nuevo sistema de dise침o plantea para los desarrolladores. </p><br><p> Aunque MaterialShapeDrawable todav칤a se considera experimental en la versi칩n 1.0.0 de la biblioteca, se puede usar para crear efectos geniales en la aplicaci칩n.  En la clase MaterialShapeDrawable, puede describir una forma especificando la apariencia de sus lados y cada uno de sus 치ngulos.  Estas propiedades especificadas pueden ser controladas por un interpolador, que les permite animar. </p><br><p>  Para crear su propio MaterialShapeDrawable, puede usar el constructor al que necesita pasar un objeto de tipo ShapePathModel en los par치metros.  Almacena informaci칩n sobre cada lado y cada esquina de la figura en las clases EdgeTreatment y CornerTreatment, respectivamente (siempre hay exactamente cuatro lados y 치ngulos, pero esto no interfiere con la descripci칩n de casi cualquier figura con su ayuda).  Puede especificar descripciones personalmente para cada lado y esquina, o configurarlas de una vez para toda la figura llamando a un m칠todo. </p><br><p>  La biblioteca ya tiene varias descripciones listas para usar del tratamiento de los lados y 치ngulos, que incluyen la mayor칤a de las innovaciones con respecto a la forma de los componentes introducidos en Material Design 2.0.  Ya presente: RoundedCornerTreatment - para esquinas redondeadas, CutCornerTreatment - para esquinas cortadas, TriangleEdgeTreatment - para cortar o agregar un tri치ngulo a un lado.  Para demostrar su trabajo, hay un ejemplo simple: </p><br><pre><code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> shapePathModel = ShapePathModel().apply { setAllCorners(CutCornerTreatment(dip(<span class="hljs-number"><span class="hljs-number">5</span></span>).toFloat())) setAllEdges(TriangleEdgeTreatment(dip(<span class="hljs-number"><span class="hljs-number">5</span></span>).toFloat(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> backgroundDrawable = MaterialShapeDrawable(shapePathModel).apply { setTint(ContextCompat.getColor(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span><span class="hljs-symbol"><span class="hljs-symbol">@MainActivity</span></span>, R.color.colorPrimary)) paintStyle = Paint.Style.FILL } textView.background = backgroundDrawable</code> </pre> <br><p>  Se ver치 as칤: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/02b/b43/168/02bb431689af8046223fd77e58fd0f2a.png" alt="imagen"></p><br><p>  Por supuesto, simplemente puede crear sus propias descripciones de caras y 치ngulos.  La forma siempre se establece para el elemento superior izquierdo, y Drawable realizar치 las operaciones de rotaci칩n / reflexi칩n para obtener la forma terminada.  Hay un peque침o ejemplo para demostrar esto: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CutoutCornersTreatment</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> size: <span class="hljs-built_in"><span class="hljs-built_in">Float</span></span>) : CornerTreatment() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCornerPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(angle: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-function"><span class="hljs-params">, interpolation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-function"><span class="hljs-params">, shapePath: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ShapePath</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { shapePath.reset(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, size * interpolation) shapePath.lineTo(size * interpolation, size * interpolation) shapePath.lineTo(size * interpolation, <span class="hljs-number"><span class="hljs-number">0f</span></span>) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CurvedEdgeTreatment</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> size: <span class="hljs-built_in"><span class="hljs-built_in">Float</span></span>) : EdgeTreatment() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getEdgePath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(length: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-function"><span class="hljs-params">, interpolation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-function"><span class="hljs-params">, shapePath: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ShapePath</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { shapePath.quadToPoint(length / <span class="hljs-number"><span class="hljs-number">2f</span></span>, size * interpolation, length, <span class="hljs-number"><span class="hljs-number">0f</span></span>) } }</code> </pre> <br><p>  Si este MaterialShapeDrawable se usa como fondo, el resultado ser치 as칤: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/98a/5b5/671/98a5b56711a7a3cec44ed62c459deaf2.png" alt="imagen"></p><br><p>  El paquete bottomappbar de la nueva Biblioteca de componentes de material tiene un BottomAppBarTopEdgeTreatment.  Describe el recorte en BottomAppBar para el bot칩n FloatingActionButton.  Su parte superior se puede animar dependiendo de la posici칩n y el tama침o del bot칩n.  Le aconsejo que lea el c칩digo de estas clases para ver con sus propios ojos que MaterialShapeDrawable es muy flexible de usar y que casi todo se puede hacer con 칠l. </p><br><p>  Si hablamos del ShapeDrawable habitual, hay otro detalle que vale la pena mencionar: la capacidad de proyectar una sombra de la forma correspondiente al contorno.  Dado que ahora puede crear contornos de formas muy inusuales con MaterialShapeDrawable, ser칤a una decepci칩n no llevar la forma de la sombra a la forma de la imagen, especialmente cuando estas sombras se pueden ver en todas partes en Matarial Design 2.0.  MaterialShapeDrawable tambi칠n calcula la apariencia de la sombra.  Usando la propiedad shadowEnabled, puede habilitar la sombra, que seguir치 exactamente el contorno de la figura, tambi칠n es posible determinar el radio, la elevaci칩n y el color de la sombra.  쯉uena demasiado bueno para ser verdad?  Lamentablemente si.  Si usa la sombra de MaterialShapeDrawable, obtendr치 una sombra normal (dibujada por el m칠todo setShadowLayer () de la clase Paint, que fue creada para dibujar sombras en el texto), pero recortada en los bordes del componente UI en el que se muestra el resultado: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5aa/e8b/134/5aae8b1341f9adabf86daaefeccb09fa.png" alt="imagen"></p><br><p>  Tenga en cuenta que MaterialShapeDrawable todav칤a se considera experimental, como su API, y puede cambiar en el futuro.  Tambi칠n vale la pena se침alar que el c칩digo para la nueva biblioteca de Componentes de materiales est치 abierto, por lo que es muy bienvenido crear tickets en un rastreador de errores o incluso solicitar solicitudes para solucionar problemas conocidos.  De hecho, cuando lee estas l칤neas, la API ya es ligeramente diferente en la rama maestra de la biblioteca (por ejemplo, se usar치 ShapeAppearanceModel en lugar de ShapePathModel), lo que indica trabajo activo.  Una de las caracter칤sticas prometedoras en la pr칩xima versi칩n puede ser la capacidad de determinar los lados / 치ngulos predeterminados para todo el tema de la aplicaci칩n.  Puede obtener m치s informaci칩n sobre esto en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci칩n oficial</a> o en las fuentes de la biblioteca. </p><br><blockquote>  <em>Del traductor:</em> <br>  <em>Es genial que haya herramientas que agreguen nuevas caracter칤sticas al ShapeDrawable habitual y ayuden a crear no los gr치ficos m치s simples.</em>  <em>Esto permite al desarrollador no atraer al dise침ador por cada peque침a cosa, sino resolver el problema por s칤 mismo, y requiere mucho menos tiempo.</em>  <em>Estamos a la espera de las pr칩ximas versiones de la biblioteca de Componentes de materiales para probar en la pr치ctica nuevas formas de resolver problemas existentes.</em> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es426997/">https://habr.com/ru/post/es426997/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es426985/index.html">Kubebox y otros cascos de consola para Kubernetes</a></li>
<li><a href="../es426987/index.html">Aprende OpenGL. Lecci칩n 6.3 - Iluminaci칩n basada en im치genes. Irradiaci칩n difusa</a></li>
<li><a href="../es426991/index.html">Startup Digest: 10 pr칩ximos eventos de TI en Mosc칰</a></li>
<li><a href="../es426993/index.html">쯅ecesito aprender C para entender c칩mo funciona una computadora?</a></li>
<li><a href="../es426995/index.html">El reciclaje perjudica tanto a los productos como a los empleados.</a></li>
<li><a href="../es426999/index.html">Seguir las tendencias o avanzar hacia RxJava y LiveData</a></li>
<li><a href="../es427003/index.html">Mapas hexagonales en Unity: niebla de guerra, investigaci칩n cartogr치fica, generaci칩n de procedimientos</a></li>
<li><a href="../es427005/index.html">Desarrolladores de IA: 쯟a profesi칩n de millonarios?</a></li>
<li><a href="../es427009/index.html">"Caminando" de un electr칩n: manipulaciones con una carga dentro de la estructura de enlaces insaturados</a></li>
<li><a href="../es427011/index.html">Mi "Hola Mundo!" en FPGA o la pr칩xima versi칩n de UART</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>