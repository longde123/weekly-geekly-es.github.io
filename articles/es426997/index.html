<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤴🏽 🤹🏾 👌 Cómo crear formas personalizadas con MaterialShapeDrawable 🔴 ♋️ 🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Material Design 2.0 introdujo varios conceptos nuevos. Una de ellas es la atención especial a las formas geométricas de los elementos de la interfaz. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cómo crear formas personalizadas con MaterialShapeDrawable</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mobileup/blog/426997/"><img src="https://habrastorage.org/getpro/habr/post_images/585/f26/743/585f267433530ce6e9add3c7de072e35.jpg" alt="imagen"><br><br><p>  Material Design 2.0 introdujo varios conceptos nuevos.  Una de ellas es la atención especial a las formas geométricas de los elementos de la interfaz.  Y hay una manera fácil de hacer hermosas formas personalizadas.  Se llama MaterialShapeDrawable.  Veamos qué tan útil y fácil es usarlo. </p><a name="habracut"></a><br><p>  Hay varias formas de agregar elementos gráficos a la pantalla de una aplicación de Android.  Lo más sencillo es importar mapas de bits en formato webp o png.  Otra opción es usar VectorDrawable, que le permite estirar la imagen al tamaño que necesita.  Otra forma de agregar gráficos a la pantalla es usar ShapeDrawable.  Estas últimas son la forma más fácil de agregar un fondo simple o incluso crear un ícono.  Las imágenes creadas con ShapeDrawable son independientes de la densidad de píxeles en la pantalla.  Se pueden describir en un archivo xml, formar parte de otro recurso gráfico (por ejemplo, StateListDrawable) y están presentes en el SDK de Android, comenzando con API v.1. </p><br><p>  Para cambiar la apariencia de una figura, podemos cambiar varias propiedades de ShapeDrawable: el nombre de la figura, el color de relleno (o degradado) y el color del borde de la figura.  Para los rectángulos, también puede establecer el radio de las esquinas.  Con estas propiedades, puede crear gráficos que se utilizarán como imágenes individuales en la pantalla, divisores, fondos de botones o para cualquier otro propósito.  Si la aplicación usa la API v.21 + y ShapeDrawable como fondo para elementos con elevación, entonces la sombra debajo de estos elementos también tendrá la forma correcta: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/456/6b3/fd7/4566b3fd778a1edfdcce710510d1a2c4.png" alt="imagen"></p><br><p>  ShapeDrawable es una herramienta práctica que casi siempre hace bien su trabajo, pero con la llegada de Material Design 2.0, los desarrolladores necesitan algo más flexible.  El nuevo sistema de diseño fomenta el uso de diferentes formas para enfatizar su significado, condición y estilo de aplicación individual.  Escribí anteriormente que hay varias formas de hacer lo deseado, pero la más simple ya no es relevante.  ¿Significa esto que necesitamos comenzar a usar gráficos vectoriales y así perder la capacidad de "liberar" crear sombras para elementos de interfaz con elevación?  ¿O vale la pena volver a usar imágenes ráster y crear recursos gráficos para seis posibles densidades de píxeles en la pantalla?  Afortunadamente, con el advenimiento de Material Design 2.0, apareció una biblioteca de componentes completamente nueva. </p><br><p>  Esta biblioteca fue creada para unificar la apariencia y el comportamiento de la interfaz de usuario de Material Design en todas las versiones de Android y otras plataformas (hay versiones de esta biblioteca para iOS, la web y para Flutter).  La biblioteca de componentes implementa muchas características para el nuevo diseño de materiales.  Por ejemplo, incluye el componente BottomAppBar con el comportamiento esperado.  Entre otros componentes y utilidades, está la clase MaterialShapeDrawable.  En mi opinión, esta es una herramienta necesaria para resolver las tareas que el nuevo sistema de diseño plantea para los desarrolladores. </p><br><p> Aunque MaterialShapeDrawable todavía se considera experimental en la versión 1.0.0 de la biblioteca, se puede usar para crear efectos geniales en la aplicación.  En la clase MaterialShapeDrawable, puede describir una forma especificando la apariencia de sus lados y cada uno de sus ángulos.  Estas propiedades especificadas pueden ser controladas por un interpolador, que les permite animar. </p><br><p>  Para crear su propio MaterialShapeDrawable, puede usar el constructor al que necesita pasar un objeto de tipo ShapePathModel en los parámetros.  Almacena información sobre cada lado y cada esquina de la figura en las clases EdgeTreatment y CornerTreatment, respectivamente (siempre hay exactamente cuatro lados y ángulos, pero esto no interfiere con la descripción de casi cualquier figura con su ayuda).  Puede especificar descripciones personalmente para cada lado y esquina, o configurarlas de una vez para toda la figura llamando a un método. </p><br><p>  La biblioteca ya tiene varias descripciones listas para usar del tratamiento de los lados y ángulos, que incluyen la mayoría de las innovaciones con respecto a la forma de los componentes introducidos en Material Design 2.0.  Ya presente: RoundedCornerTreatment - para esquinas redondeadas, CutCornerTreatment - para esquinas cortadas, TriangleEdgeTreatment - para cortar o agregar un triángulo a un lado.  Para demostrar su trabajo, hay un ejemplo simple: </p><br><pre><code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> shapePathModel = ShapePathModel().apply { setAllCorners(CutCornerTreatment(dip(<span class="hljs-number"><span class="hljs-number">5</span></span>).toFloat())) setAllEdges(TriangleEdgeTreatment(dip(<span class="hljs-number"><span class="hljs-number">5</span></span>).toFloat(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> backgroundDrawable = MaterialShapeDrawable(shapePathModel).apply { setTint(ContextCompat.getColor(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span><span class="hljs-symbol"><span class="hljs-symbol">@MainActivity</span></span>, R.color.colorPrimary)) paintStyle = Paint.Style.FILL } textView.background = backgroundDrawable</code> </pre> <br><p>  Se verá así: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/02b/b43/168/02bb431689af8046223fd77e58fd0f2a.png" alt="imagen"></p><br><p>  Por supuesto, simplemente puede crear sus propias descripciones de caras y ángulos.  La forma siempre se establece para el elemento superior izquierdo, y Drawable realizará las operaciones de rotación / reflexión para obtener la forma terminada.  Hay un pequeño ejemplo para demostrar esto: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CutoutCornersTreatment</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> size: <span class="hljs-built_in"><span class="hljs-built_in">Float</span></span>) : CornerTreatment() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCornerPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(angle: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-function"><span class="hljs-params">, interpolation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-function"><span class="hljs-params">, shapePath: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ShapePath</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { shapePath.reset(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, size * interpolation) shapePath.lineTo(size * interpolation, size * interpolation) shapePath.lineTo(size * interpolation, <span class="hljs-number"><span class="hljs-number">0f</span></span>) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CurvedEdgeTreatment</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> size: <span class="hljs-built_in"><span class="hljs-built_in">Float</span></span>) : EdgeTreatment() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getEdgePath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(length: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-function"><span class="hljs-params">, interpolation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-function"><span class="hljs-params">, shapePath: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ShapePath</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { shapePath.quadToPoint(length / <span class="hljs-number"><span class="hljs-number">2f</span></span>, size * interpolation, length, <span class="hljs-number"><span class="hljs-number">0f</span></span>) } }</code> </pre> <br><p>  Si este MaterialShapeDrawable se usa como fondo, el resultado será así: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/98a/5b5/671/98a5b56711a7a3cec44ed62c459deaf2.png" alt="imagen"></p><br><p>  El paquete bottomappbar de la nueva Biblioteca de componentes de material tiene un BottomAppBarTopEdgeTreatment.  Describe el recorte en BottomAppBar para el botón FloatingActionButton.  Su parte superior se puede animar dependiendo de la posición y el tamaño del botón.  Le aconsejo que lea el código de estas clases para ver con sus propios ojos que MaterialShapeDrawable es muy flexible de usar y que casi todo se puede hacer con él. </p><br><p>  Si hablamos del ShapeDrawable habitual, hay otro detalle que vale la pena mencionar: la capacidad de proyectar una sombra de la forma correspondiente al contorno.  Dado que ahora puede crear contornos de formas muy inusuales con MaterialShapeDrawable, sería una decepción no llevar la forma de la sombra a la forma de la imagen, especialmente cuando estas sombras se pueden ver en todas partes en Matarial Design 2.0.  MaterialShapeDrawable también calcula la apariencia de la sombra.  Usando la propiedad shadowEnabled, puede habilitar la sombra, que seguirá exactamente el contorno de la figura, también es posible determinar el radio, la elevación y el color de la sombra.  ¿Suena demasiado bueno para ser verdad?  Lamentablemente si.  Si usa la sombra de MaterialShapeDrawable, obtendrá una sombra normal (dibujada por el método setShadowLayer () de la clase Paint, que fue creada para dibujar sombras en el texto), pero recortada en los bordes del componente UI en el que se muestra el resultado: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5aa/e8b/134/5aae8b1341f9adabf86daaefeccb09fa.png" alt="imagen"></p><br><p>  Tenga en cuenta que MaterialShapeDrawable todavía se considera experimental, como su API, y puede cambiar en el futuro.  También vale la pena señalar que el código para la nueva biblioteca de Componentes de materiales está abierto, por lo que es muy bienvenido crear tickets en un rastreador de errores o incluso solicitar solicitudes para solucionar problemas conocidos.  De hecho, cuando lee estas líneas, la API ya es ligeramente diferente en la rama maestra de la biblioteca (por ejemplo, se usará ShapeAppearanceModel en lugar de ShapePathModel), lo que indica trabajo activo.  Una de las características prometedoras en la próxima versión puede ser la capacidad de determinar los lados / ángulos predeterminados para todo el tema de la aplicación.  Puede obtener más información sobre esto en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación oficial</a> o en las fuentes de la biblioteca. </p><br><blockquote>  <em>Del traductor:</em> <br>  <em>Es genial que haya herramientas que agreguen nuevas características al ShapeDrawable habitual y ayuden a crear no los gráficos más simples.</em>  <em>Esto permite al desarrollador no atraer al diseñador por cada pequeña cosa, sino resolver el problema por sí mismo, y requiere mucho menos tiempo.</em>  <em>Estamos a la espera de las próximas versiones de la biblioteca de Componentes de materiales para probar en la práctica nuevas formas de resolver problemas existentes.</em> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es426997/">https://habr.com/ru/post/es426997/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es426985/index.html">Kubebox y otros cascos de consola para Kubernetes</a></li>
<li><a href="../es426987/index.html">Aprende OpenGL. Lección 6.3 - Iluminación basada en imágenes. Irradiación difusa</a></li>
<li><a href="../es426991/index.html">Startup Digest: 10 próximos eventos de TI en Moscú</a></li>
<li><a href="../es426993/index.html">¿Necesito aprender C para entender cómo funciona una computadora?</a></li>
<li><a href="../es426995/index.html">El reciclaje perjudica tanto a los productos como a los empleados.</a></li>
<li><a href="../es426999/index.html">Seguir las tendencias o avanzar hacia RxJava y LiveData</a></li>
<li><a href="../es427003/index.html">Mapas hexagonales en Unity: niebla de guerra, investigación cartográfica, generación de procedimientos</a></li>
<li><a href="../es427005/index.html">Desarrolladores de IA: ¿la profesión de millonarios?</a></li>
<li><a href="../es427009/index.html">"Caminando" de un electrón: manipulaciones con una carga dentro de la estructura de enlaces insaturados</a></li>
<li><a href="../es427011/index.html">Mi "Hola Mundo!" en FPGA o la próxima versión de UART</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>