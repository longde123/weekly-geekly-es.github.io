<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ™‡ ğŸ£ âœ‹ğŸ¾ Muat pengujian proyek web - tanpa uang tunai ğŸ’¬ ğŸ––ğŸ½ ğŸ¤¸ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teman-teman, selamat sore! 

 Kami melanjutkan serangkaian publikasi "tanpa potongan" tentang proyek yang terkait dengan pengembangan, seringkali deng...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Muat pengujian proyek web - tanpa uang tunai</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/bitrix/blog/456904/">  Teman-teman, selamat sore! <br><br>  Kami melanjutkan serangkaian publikasi "tanpa potongan" tentang proyek yang terkait dengan pengembangan, seringkali dengan awalan "web".  Mari kita bicara hari ini tentang stress test.  Masalahnya adalah bahwa seringkali klien maupun manajer proyek tidak memahami mengapa diperlukan, risiko apa yang dapat dikurangi, bagaimana mengaturnya dan bagaimana, dan ini, saya pikir, sulit, untuk menginterpretasikan hasil-hasilnya untuk kepentingan bisnis.  Kami menuangkan kopi dan mari kita pergi ... <br><a name="habracut"></a><br><h2>  Mengapa memuat pengujian proyek web? </h2><br>  Faktanya adalah bahwa sementara autostests masih ditulis dalam beberapa proyek web untuk menjaga kualitas, beberapa orang terlibat dalam pengendalian kinerja pada tahap pengembangan.  Sangat jarang melihat proyek web dengan autotests dan tolok ukur kode.  Lebih sering dan untuk alasan yang masuk akal, heuristik berikut dipatuhi selama pengembangan, yang memiliki rasio manfaat-biaya yang baik: <br><br><ul><li>  pertanyaan ke MySQL (kami akan menggunakan database populer ini sebagai contoh) melalui API yang cukup memadai yang menggunakan indeks (meskipun kami tidak melihat bagaimana tepatnya indeks digunakan oleh penjadwal, apa kardinalitas mereka) </li><li>  hasil mengeksekusi query database dan potongan kode yang berat di-cache </li><li>  pengembang 3,14 kali memeriksa pembangunan halaman web di browser dan jika itu tidak memperlambat mata, maka semuanya OK </li></ul><br>  Heuristik sering bekerja dengan baik, tetapi semakin besar dan lebih berat proyek, sesuatu <b>mungkin salah</b> dengan kemungkinan yang meningkat secara eksponensial. <br><br>  Ambil caching.  Saat berkembang, seringkali tidak ada waktu untuk memikirkan seberapa sering cache dapat dibangun kembali.  Namun sia-sia.  Jika membangun kembali cache, katakanlah, katalog produk, membutuhkan waktu lama dan cache diatur ulang ketika satu produk ditambahkan, maka cache akan lebih berbahaya daripada manfaatnya. <br><br>  Karena itu, omong-omong, tidak disarankan untuk menggunakan cache kueri MySQL bawaan, yang mengalami masalah serupa: jika Anda mengubah setidaknya satu catatan tabel, cache tabel sepenuhnya diatur ulang (bayangkan tabel 100k garis dan absurditas situasi menjadi jelas). <br><br>  Situasi serupa dengan permintaan MySQL.  Jika kueri dieksekusi oleh indeks, maka, secara umum, kueri akan dieksekusi ... "lebih cepat."  Anda dapat percaya bahwa waktu eksekusi dari pertanyaan seperti itu tergantung secara logaritma pada jumlah data (O (log (n))).  Tetapi dalam praktiknya sering ternyata beberapa permintaan mempengaruhi yang lain, menggunakan pada saat yang sama subsistem umum dari basis data (mengurutkan pada disk yang mulai melambat) dan Anda tidak dapat langsung memprediksi ini. <br><br>  Juga, sering selama memuat, fitur menarik dari sistem operasi terungkap, khususnya, meluapnya rentang port TCP / IP klien keluar selama pekerjaan intensif dengan memcached.  Atau apache akan tersumbat dengan permintaan untuk pemrosesan gambar, karena  selama konfigurasi, mereka lupa mengkonfigurasi pemrosesan mereka oleh server proxy nginx caching. <br><br>  Kadang-kadang mereka lupa menginstal di MySQL jalur untuk tabel sementara ke disk yang memetakan data ke RAM ("/ dev / shm"), karena itu, ketika beban meningkat, server database meletakkan dari penyortiran intensif. <br><br>  Juga, ketika data ditambahkan ke proyek web, dalam volume yang dekat dengan pertempuran, pertanyaan dan algoritma mulai secara agresif menampilkan "notasi-O" mereka: jika kartesius tidak terlihat untuk sejumlah kecil data, maka ketika volume pertempuran muncul, server database menjadi merah karena tegangan. <br><br>  Ada banyak contoh lagi, mari kita bahas ini sekarang.  Hal utama yang perlu dipahami adalah bahwa pengujian beban diperlukan.  Karena itu sangat mahal, sangat lama dan tidak praktis secara ekonomis untuk meramalkan semua opsi yang memungkinkan untuk "mengerem" sistem web berukuran sedang sebelumnya. <br><br><h2>  Bagaimana cara mengidentifikasi target pengujian stres? </h2><br>  Di sini penting untuk memahami apa yang sebenarnya menunjukkan kepada Anda dan klien tingkat kualitas sistem web selama pengujian stres.  Tidak ada yang lebih baik dari contoh konkret target pengujian stres, baik dan buruk: <br><br><ul><li>  <b>Membuat 1 juta hit.</b>  <b>Waktu pembuatan laman web rata-rata = 1 detik.</b>  Apa yang ditunjukkan oleh ini?  Tidak ada  Berapa lama pengujian muat berlangsung?  Waktu pelaksanaan satu permintaan dapat berupa 1 ms atau 600 detik, dan tidak jelas proporsi mana yang lebih besar.  Dan berapa banyak kesalahan yang ada (respons nginx dengan gaya "Kesalahan 50x") juga tidak jelas :-) </li><li>  <b>Membuat 1 juta hit.</b>  <b>Rata-rata waktu pembuatan halaman web = 1 detik, jumlah kesalahan HTTP adalah 0,5%</b> Apa yang ditampilkan?  Sejauh ini, sedikit bermanfaat, tetapi lebih baik.  Bagian kesalahan yang tidak memadai yang dapat ditangkap klien, kami sudah tahu bahwa itu hebat dan Anda dapat mulai mempersiapkan dan pergi ke apotek.  Median adalah metrik yang lebih tahan terhadap "outlier" daripada rata-rata (lebih "kuat" perkiraan), oleh karena itu, tidak diragukan lagi lebih baik daripada rata-rata aritmatika.  Tapi mari kita buat metrik lebih berguna. </li><li>  <b>1 juta hit dilakukan per hari.</b>  <b>25% hit dibuat dalam waktu kurang dari 10 ms, 50% hit dibuat dalam waktu kurang dari 1 detik (ini median atau 50 persentil), 75% hit dibuat dalam waktu kurang dari 1,5 detik, 95% hit dibuat dalam waktu kurang dari 1 detik 5 detik dan jumlah kesalahan HTTP adalah 0,5%</b> Itu saja!  Kami melihat proporsi kesalahan tidak memadai yang dapat ditangkap klien, tetapi kami juga melihat proporsi permintaan yang melebihi batas tertentu. </li></ul><br>  Seperti yang Anda lihat, pilihan metrik yang memadai untuk menilai kecepatan proyek web selama pengujian beban sangat, sangat penting.  Hanya ada satu prinsip - metrik harus benar-benar jelas bagi klien dan Anda dan untuk menunjukkan kualitas dengan baik dan jelas.  Bahkan, metrik yang paling jelas dan benar adalah distribusi kecepatan pemrosesan hit dari waktu ke waktu.  Jika Anda berhasil melakukan ini pada pengujian stres Anda - itu akan menjadi super.  Selain itu, Anda dapat membandingkan 2 tes stres dengan sifat distribusi klik waktu dan melihat bagaimana itu menjadi lebih baik dan di mana.  Visualisasi adalah kekuatan! <br><br><h2>  Tidak ada yang jelas: persentil, median, kuantil, konsep, distribusi ... </h2><br>  Semuanya sederhana!  Sekarang saya akan menggambar dan menunjukkan di lingkungan yang indah untuk analisis data: Jupyter notebook / Python. <br><br>  Katakanlah 10 hit dibuat ke situs web dengan waktu dalam milidetik: <br><br><img src="https://habrastorage.org/webt/l-/e8/io/l-e8io0jdj8vupfnnzus5sjm54i.png"><br><br>  Sekarang sortir waktu yang diperlukan untuk menyelesaikan hit dalam urutan menaik: <br><br><img src="https://habrastorage.org/webt/tp/m8/ay/tpm8ayfzhwxc3et6n74glp3ngnm.png"><br><br>  Kami satu langkah lagi dari memahami median, 25 dan 75 persen.  Semuanya sederhana - kita membagi bagan menjadi dua dan di tengah akan ada "median" (nomor 1 pada tabel).  Kuartal pertama grafik akan sesuai dengan persentil ke-25 (nomor 2 pada grafik) dan kuartal ketiga akan sesuai dengan persentil ke-75 (nomor 3 pada grafik).  Dengan demikian, persentil lain diperoleh (atau, sebagaimana mereka juga disebut, kuantil) - 90, 95, 99, dll .: <br><br><img src="https://habrastorage.org/webt/zf/2l/wu/zf2lwu3o2z9xl7_zb2srwk2ayqc.png"><br><br>  Dan itu akan terlihat seperti distribusi (histogram) selama waktu pelaksanaan hit di atas.  Seperti yang Anda lihat, semuanya sangat jelas dan sederhana: <br><br><img src="https://habrastorage.org/webt/ro/s8/yi/ros8yifhkgaa8phiovwj7xhffee.png"><br><br>  Dan ini adalah bagaimana Anda dapat dengan cepat membangun distribusi (histogram) berdasarkan log permintaan pengujian beban.  Ubah ke format log Anda: <br><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash TOTAL=`cat /var/log/nginx.access.log | wc -l` echo "Total:" $TOTAL cat /var/log/nginx.access.log | awk -F'-&gt;' '{ $2=$2*1000; zone = int($2/100)*100; hits[zone]++; } \ END {for (z in hits) {printf("%8s ms: %8s,%6.2f% ",z,hits[z],hits[z]/total*100);{s="";a=0;while(a++&lt;int(hits[z]/total*100)) s=s"*";print s} } }' \ total="$TOTAL" - | sort -n</span></span></code> </pre> <br>  Dan Anda mendapatkan sesuatu seperti ini: <br><br><img src="https://habrastorage.org/webt/yi/cw/kt/yicwktq5m-gspcpb81-q9o5mele.png"><br><br>  Saya harap sekarang semuanya menjadi jelas dan siap.  Jika tidak, tanyakan di komentar. <br><br><h2>  Waktu pengujian stres </h2><br>  Orang-orang sering bertanya - berapa lama seharusnya tes beban suatu proyek web berlangsung?  Ada heuristik sederhana - dalam sistem operasi sering tugas terjadwal dilakukan sekali sehari: cadangan, rotasi log, dll., Oleh karena itu, waktu untuk melakukan pengujian beban seharusnya tidak kurang, dengan benar, berhari-hari.  Jika proyek web didasarkan pada Bitrix, maka platform juga memiliki banyak tugas yang dijadwalkan dan disarankan untuk memuat sistem web setidaknya selama sehari. <br><br><h2>  Load balancing </h2><br>  Jika Anda sudah memiliki situs web yang dioperasikan, maka Anda dapat, ya, mengambil log kunjungan dari sana dan memuat sistem web baru dengan menggunakannya.  Namun seringkali mereka memecahkan masalah hanya memuat sistem web yang dikembangkan.  Untuk perencanaan penyeimbangan muatan, model pembagian rantai kunjungan kunjungan yang prospektif menjadi saham seringkali cocok.  Sebagai contoh: <br><br><ul><li>  Beranda - Berita - Berita detail = 50% </li><li>  Beranda - Tinjauan Umum Katalog - Katalog Lengkap = 30% </li><li>  Katalog Lengkap - Tinjauan Katalog - Katalog Lengkap = 15% </li><li>  Hasil Pencarian - Katalog Lengkap = 5% </li></ul><br>  Dalam perangkat lunak untuk membuat beban (kita sering menggunakan Jmeter), begitu banyak aliran beban dibuat untuk setiap rantai sehingga, dengan mempertimbangkan interval antara hit dalam rantai, jumlah total hit dari setiap rantai per unit waktu dikorelasikan sebagai: 50%, 30%, 15%, 5% . <br><br>  Penghitungan interval dan aliran muatan mudah dilakukan di Excel atau di atas lembaran dengan pensil. <br><br><h2>  Struktur rantai beban </h2><br>  Penting untuk mempertimbangkan fitur-fitur dari siklus hidup pengguna sistem web.  Seringkali pengguna masuk dan kemudian pergi ke situs web.  Untuk melakukan ini, Anda perlu menempatkan tindakan yang mengarah ke otorisasi di awal rantai muat: <br><br><img src="https://habrastorage.org/webt/lx/9a/5m/lx9a5m6lnnnjt0t4x0lk6avsn5e.png"><br><br>  Jelas bagi kuda bahwa tidak mungkin untuk menarik hanya satu halaman rinci dari katalog selama pengujian stres, oleh karena itu berguna untuk membaca dan memutar daftar mereka dari file CSV: <br><br><img src="https://habrastorage.org/webt/7o/uz/py/7ouzpyccej3ec5s2cfgederegqe.png"><br><br>  Di antara hit, tentu saja, Anda perlu membuat jeda acak - jadi kami lebih dekat dengan beban yang dibuat oleh pengguna nyata.  Jangan lupa tentang menyimpan dan mengembalikan nilai cookie ke server: <br><br><img src="https://habrastorage.org/webt/j-/x-/wb/j-x-wbxmqntmtxflqp31azfk2ka.png"><br><br>  Variabel global rantai beban, termasuk jumlah utasnya, mudah dikonfigurasi.  Variabel global tertentu kemudian dapat digunakan di berbagai tempat dalam rantai beban: <br><br><img src="https://habrastorage.org/webt/1z/gd/zb/1zgdzbx3p1i53-kzx69v5uypvbc.png"><br><br><img src="https://habrastorage.org/webt/ei/qu/x8/eiqux8vtg5i-pkdagldbiiy-0rs.png"><br><br><img src="https://habrastorage.org/webt/cu/mu/rx/cumurxiaukl1feoyc0ltyeyj2pe.png"><br><br><h2>  Bagaimana cara membuat stress testing berakhir dengan aman? </h2><br>  Dalam prakteknya, hampir selalu, pengujian beban pada menit atau jam pertama crash sistem web, semuanya mulai merokok, kemudian terbakar, situs tidak terbuka, MySQL jatuh ke swap dan tidak membiarkan dirinya terhubung, LA pada server mendekati 100, pengembang mulai menjalankan dengan kata-kata "ini seharusnya tidak terjadi", dan sysadmin dengan seringai biasanya menjawab "ada keadilan dalam hidup!"  dan mulai minum bir di ruang server. <br><br>  Tetapi untuk memahami mengapa semuanya telah jatuh dan apa yang harus diperbaiki, untuk menunjukkan kepada klien hasil dari pengujian beban â€œberhasilâ€ dalam sehari, Anda harus terlebih dahulu mengaktifkan pencatatan metrik utama dari kehidupan sistem operasi - ini mudah dilakukan dalam produk munun / kaktus gratis. <br><br>  Saya akan mencantumkan apa yang paling sering terjadi pada saat runtuhnya sistem web dan bagaimana hal ini dapat diperbaiki. <br><br>  Pertama-tama, server web apache atau php-fpm "tersumbat" dengan permintaan: <br><br><img src="https://habrastorage.org/webt/tm/tv/pd/tmtvpdrhkkgk7vckhnxsglfb19m.png"><br><br>  Paling sering hal ini terjadi karena runtuhnya MySQL - jumlah aliran permintaan menggantung meningkat: <br><br><img src="https://habrastorage.org/webt/ow/dm/f2/owdmf24wsw1zbm9ksfbgczezzv0.png"><br><br>  Apa alasannya?  Seringkali dari atas mereka lupa membatasi jumlah apache atau aliran permintaan ke MySQL, yang menyebabkan aplikasi keluar dari RAM menjadi swap lambat dengan kejang: <br><br><img src="https://habrastorage.org/webt/qq/dc/un/qqdcunmpuk0dbmuq0a1jfhqstas.png"><br><br>  Di sini Anda dapat melihat aktivitas mendadak saat bekerja dengan swap, Anda perlu memahami siapa yang termasuk dalam swap dan di mana: <br><br><img src="https://habrastorage.org/webt/jk/r4/6q/jkr46qtuyn9ttbbcxwav0iaxvhs.png"><br><br>  Namun, terkadang masalahnya ada di sisi subsistem hard disk.  Dalam kasus ini, LA naik tajam dan persentase pemanfaatan disk mendekati 100 (grafik kanan bawah): <br><br><img src="https://habrastorage.org/webt/rn/sk/od/rnskodj5gr0xot-bozw4haogwas.png"><br><br><img src="https://habrastorage.org/webt/sp/za/yq/spzayqb1ud73lnrn9wezocfvjv4.png"><br><br>  Jelas, saya mengungkapkan hanya sebagian dari hal paling menarik yang dapat dimulai dengan proyek web selama pengujian stres.  Tetapi yang utama adalah mengatur arah yang benar dan membangun proses yang benar.  Tanyakan di komentar apa yang muncul selama pemuatan, saya akan mencoba membantu. <br><br><h2>  Interpretasi hasil stress test </h2><br>  Biasanya, setelah 5-10 restart dan penyesuaian, pengujian beban memulai penerbangannya dan berhasil menyelesaikannya.  Akibatnya, Anda harus memiliki satu set kira-kira log ini untuk analisis lebih lanjut: <br><br><ul><li>  log permintaan ke nginx dengan waktu permintaan klien (dalam hal ini akan memuat perangkat lunak), waktu proksi dari nginx ke apache / php-fpm </li><li>  log kesalahan nginx </li><li>  log permintaan apache / php-fpm dengan waktu pemrosesan permintaan dan status respons HTTP </li><li>  log kesalahan apache / php-fpm </li><li>  MySQL Slow Log </li><li>  Log kesalahan MySQL </li></ul><br>  Selain itu, harus ada grafik analitik selama beberapa hari terakhir tentang penggunaan CPU, disk, MySQL, RAM, pekerja apache, dll.  (lihat contoh grafik munin di atas). <br><br>  Memiliki artefak ini, Anda dapat, menggunakan skrip awk sederhana di awal posting, membangun distribusi (histogram) di atas log ini dan menghitung jumlah dan jenis kesalahan HTTP.  Bahkan, Anda dapat menghasilkan laporan tentang keberhasilan stress testing tentang konten ini yang sangat luas dan berguna untuk bisnis dan pengambilan keputusan: <br><blockquote>  Siang hari membuat 1 juta hit.  25% hit dibuat dalam waktu kurang dari 50 ms, 50% hit dibuat dalam waktu kurang dari 0,5 detik (median), 75% hit dibuat dalam waktu kurang dari 1 detik, 95% hit dibuat dalam waktu kurang dari 5 detik, jumlah kesalahan HTTP - 0,01%.  Data uji: katalog, pengguna, berita, artikel kebanjiran dalam volume mendekati yang diharapkan.  <s>Satu pengembang menembak dirinya sendiri.</s> <br><br>  Rantai beban: <br><br>  Beranda - Berita - Berita detail = 50% <br>  Beranda - Tinjauan Umum Katalog - Katalog Lengkap = 30% <br>  Katalog Lengkap - Tinjauan Katalog - Katalog Lengkap = 15% <br>  Hasil Pencarian - Katalog Lengkap = 5% <br><br>  Grafik Penggunaan Sumber Daya Server: <br>  ... <br></blockquote>  Ini adalah laporan yang bagus dan dapat dimengerti tentang pengujian beban sistem web.  Untuk pecinta nyeri akut, Anda masih dapat merekomendasikan selama pengujian beban untuk memasukkan setiap menit impor-ekspor data ke situs web dari sistem kelas SAP, 1C, dll.  dan koneksi sinkron melalui soket TCP / IP dengan layanan pertukaran eksternal, katakanlah, cryptocurrency :-) <br><br>  Tapi, jujur â€‹â€‹saja, jika ekspor-impor dilakukan dengan hati-hati dan jujur, maka pengujian beban dan dalam kondisi seperti itu akan menunjukkan angka yang dapat diterima untuk bisnis. <br><br><h2>  Dari mana datangnya stress testing? </h2><br>  Ngomong-ngomong, ya, kami tidak menyoroti momen ini.  Untuk alasan sepele, kurangnya keseimbangan antara pekerja nginx - apache - mysql biasanya muncul.  Yaitu  pekerja tidak terbatas dari atas, sebagai akibatnya, 500 pekerja (masing-masing kadang-kadang masing-masing 100 MB) dapat segera naik di apache dan 500 utas dengan permintaan akan segera datang ke MySQL - yang akan menyebabkan lonjakan kesalahan HTTP 50x dan kemungkinan keruntuhan. <br><br>  Di sini, disarankan untuk membatasi jumlah pekerja apache / php-fpm hingga jumlah yang sesuai dengan RAM dan, juga, membatasi jumlah utas di MySQL untuk melindungi terhadap melimpahnya RAM yang tersedia.  Idenya sederhana - biarkan klien menunggu di depan nginx, itu dapat memperlambat sedikit pada soket TCP / IP asynchronous dan non-blocking, yang "putus" segera di apache / MySQL. <br><br>  Dari alasan yang lebih menjengkelkan, mungkin ada segfault PHP.  Dalam hal ini, Anda perlu mengaktifkan pengumpulan coredump dan menggunakan gdb untuk melihat mengapa hal ini terjadi.  Dalam kebanyakan kasus, masalah dapat diatasi dengan memperbarui / mengkonfigurasi PHP. <br><br><h2>  Yang tertinggal di balik layar </h2><br>  Ada desas-desus yang terus-menerus bahwa frontend modern untuk web telah begitu aktif menjalani kehidupannya sehingga pengujian beban klasik backend yang disajikan dalam posting ini tidak lagi mencakup semua risiko yang mungkin terjadi pada pembekuan konstruksi halaman web dalam nyali Angular / React / Vue.js - karena itu <s>jangan gunakan ujung depan yang berat dan buram, tidak teruji,</s> Anda dapat, jika perlu, menyesuaikan rantai beban dengan situasi ini. <br><br>  Bagaimanapun, jika hasil stress testing backend menunjukkan angka yang baik, dan situs web terus melambat di peramban, sudah jelas siapa yang "memukul wajah merah kurang ajar" :-) <br><br>  Serius, di posting selanjutnya kami berharap dapat membahas topik penting ini. <br><br><h2>  Ringkasan dan Kesimpulan </h2><br>  Total - tidak ada yang rumit dalam mengatur dan melakukan pengujian beban sistem web yang berguna untuk pengembangan dan bisnis. <br><br>  Pengujian beban, terorganisir dengan baik, harus selalu dilakukan - jika tidak, ada risiko mengalami masalah besar selama operasi pertempuran, yang tidak dapat dihilangkan dalam beberapa hari. <br><br>  Untuk melakukan stress testing, penting untuk menarik tidak hanya pengembang, tetapi juga para ahli sistem operasi dan administrator sistem yang berpengalaman dengan perangkat keras, dan kemudian masalah "jatuh ke swap" atau "meluap jangkauan lokal alamat IP" tidak akan menyebabkan pendarahan dari mata dan pingsan. <br><br>  Selamat mencoba teman-teman dan ajukan pertanyaan di komentar! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id456904/">https://habr.com/ru/post/id456904/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id456892/index.html">Cara mencari kerentanan aplikasi web: membandingkan delapan pemindai populer</a></li>
<li><a href="../id456894/index.html">Docker dan otentikasi melalui Nginx</a></li>
<li><a href="../id456896/index.html">Identifikasi alamat IP nyata pengguna jaringan Tor melalui cache terdistorsi</a></li>
<li><a href="../id456898/index.html">Perkalian integer cepat menggunakan tabel</a></li>
<li><a href="../id456902/index.html">Pemberitahuan push aman: dari teori ke praktik</a></li>
<li><a href="../id456908/index.html">Bagaimana Telegram menggabungkan Anda ke Rostelecom</a></li>
<li><a href="../id456912/index.html">Cara membuat situs di 2019</a></li>
<li><a href="../id456916/index.html">Kompilasi silang di buruh pelabuhan. Kenapa tidak</a></li>
<li><a href="../id456920/index.html">Sony Xperia 1 di Rusia - bonus harga dan pre-order</a></li>
<li><a href="../id456922/index.html">Bagaimana prosesor dirancang dan diproduksi: dasar-dasar arsitektur komputer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>