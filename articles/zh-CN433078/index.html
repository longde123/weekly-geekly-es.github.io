<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🎓 💛 🕟 我们使用StockSharp图形框架编写交易机器人。 第二部分 👷 👨🏿‍🏫 🤵🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我们将继续谈论使用StockSharp平台创建交易机器人。 第一篇文章涉及项目的创建和交易系统主要元素的绘制。 在周期的最后阶段，我们将直接实施交易策略。 

 创建投资组合面板 
 类似于工具栏，创建一个日志面板。 为此，将另一个UserControl添加到XAML文件夹。 为其命名为Portfo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我们使用StockSharp图形框架编写交易机器人。 第二部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/iticapital/blog/433078/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/bv/ll/xa/bvllxaiaoeshjg0_71xwfocozqa.png"></a> <br><br> 我们将继续谈论使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">StockSharp</a>平台创建交易机器人。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一篇文章</a>涉及项目的创建和交易系统主要元素的绘制。 在周期的最后阶段，我们将直接实施交易策略。 <a name="habracut"></a><br><br><h2> 创建投资组合面板 </h2><br> 类似于工具栏，创建一个日志面板。 为此，将另一个UserControl添加到XAML文件夹。 为其命名为PortfolioGridControl。 向其中添加一个PortfolioGrid元素。 <br><br><pre><code class="cs hljs">&lt;UserControl x:Class=<span class="hljs-string"><span class="hljs-string">"ShellNew.XAML.PortfolioGridControl"</span></span> xmlns=<span class="hljs-string"><span class="hljs-string">"http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span></span> xmlns:x=<span class="hljs-string"><span class="hljs-string">"http://schemas.microsoft.com/winfx/2006/xaml"</span></span> xmlns:mc=<span class="hljs-string"><span class="hljs-string">"http://schemas.openxmlformats.org/markup-compatibility/2006"</span></span> xmlns:d=<span class="hljs-string"><span class="hljs-string">"http://schemas.microsoft.com/expression/blend/2008"</span></span> xmlns:xaml=<span class="hljs-string"><span class="hljs-string">"http://schemas.stocksharp.com/xaml"</span></span> mc:Ignorable=<span class="hljs-string"><span class="hljs-string">"d"</span></span> d:DesignHeight=<span class="hljs-string"><span class="hljs-string">"450"</span></span> d:DesignWidth=<span class="hljs-string"><span class="hljs-string">"800"</span></span>&gt; &lt;xaml:PortfolioGrid x:Name=<span class="hljs-string"><span class="hljs-string">"PortfolioGrid"</span></span> /&gt; &lt;/UserControl&gt;</code> </pre> <br> 在PortfolioGridControl构造函数中，我们需要订阅新投资组合的外观事件和连接器上新头寸的外观事件。 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PortfolioGridControl</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { InitializeComponent(); MainWindow.Instance.Connector.NewPortfolio += PortfolioGrid.Portfolios.Add; MainWindow.Instance.Connector.NewPosition += PortfolioGrid.Positions.Add; }</code> </pre> <br> 因此，在创建新投资组合时，它将出现在投资组合面板中，而当新头寸出现在投资组合面板中时，它将被更新。 <br><br> 在MainWindow的中央部分，添加创建的PortfolioGridControl面板： <br><br><pre> <code class="cs hljs">&lt;dxlc:LayoutGroup HorizontalAlignment=<span class="hljs-string"><span class="hljs-string">"Stretch"</span></span> View=<span class="hljs-string"><span class="hljs-string">"Tabs"</span></span>&gt; &lt;!--  --&gt; &lt;dxlc:LayoutGroup Header=<span class="hljs-string"><span class="hljs-string">"Securities"</span></span>&gt; &lt;myxaml:SecurityGridControl x:Name=<span class="hljs-string"><span class="hljs-string">"SecurityPanel"</span></span> /&gt; &lt;/dxlc:LayoutGroup&gt; &lt;dxlc:LayoutGroup Header=<span class="hljs-string"><span class="hljs-string">"Portfolios"</span></span>&gt; &lt;myxaml:PortfolioGridControl x:Name=<span class="hljs-string"><span class="hljs-string">"PortfolioGridControl"</span></span> /&gt; &lt;/dxlc:LayoutGroup&gt; &lt;/dxlc:LayoutGroup&gt;</code> </pre> <br> 运行检查： <br><br><img src="https://habrastorage.org/webt/bz/vs/tl/bzvstlk5xgb54mycansuoqjozhu.png"><br><br> 我们有一个带有投资组合的标签。 <br><br><h2> 创建订单面板 </h2><br>  S＃.API中的订单栏可以下订单，撤消订单和重新注册。 类似于工具栏，创建一个订单面板，将另一个UserControl添加到XAML文件夹。 为它命名为OrderGridControl。 向其中添加OrderGrid元素： <br><br><pre> <code class="cs hljs">&lt;UserControl x:Class=<span class="hljs-string"><span class="hljs-string">"ShellNew.XAML.OrderGridControl"</span></span> xmlns=<span class="hljs-string"><span class="hljs-string">"http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span></span> xmlns:x=<span class="hljs-string"><span class="hljs-string">"http://schemas.microsoft.com/winfx/2006/xaml"</span></span> xmlns:mc=<span class="hljs-string"><span class="hljs-string">"http://schemas.openxmlformats.org/markup-compatibility/2006"</span></span> xmlns:d=<span class="hljs-string"><span class="hljs-string">"http://schemas.microsoft.com/expression/blend/2008"</span></span> xmlns:xaml=<span class="hljs-string"><span class="hljs-string">"http://schemas.stocksharp.com/xaml"</span></span> mc:Ignorable=<span class="hljs-string"><span class="hljs-string">"d"</span></span> d:DesignHeight=<span class="hljs-string"><span class="hljs-string">"450"</span></span> d:DesignWidth=<span class="hljs-string"><span class="hljs-string">"800"</span></span>&gt; &lt;xaml:OrderGrid x:Name=<span class="hljs-string"><span class="hljs-string">"OrderGrid"</span></span> /&gt; &lt;/UserControl&gt;</code> </pre> <br>  OrderGrid具有一个OrderRegistering注册事件，OrderReRegisters重新注册事件和OrderCanceling取消事件。 <br><br> 让我们创建他们的处理程序： <br><br><pre> <code class="cs hljs">&lt;UserControl x:Class=<span class="hljs-string"><span class="hljs-string">"ShellNew.XAML.OrderGridControl"</span></span> xmlns=<span class="hljs-string"><span class="hljs-string">"http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span></span> xmlns:x=<span class="hljs-string"><span class="hljs-string">"http://schemas.microsoft.com/winfx/2006/xaml"</span></span> xmlns:mc=<span class="hljs-string"><span class="hljs-string">"http://schemas.openxmlformats.org/markup-compatibility/2006"</span></span> xmlns:d=<span class="hljs-string"><span class="hljs-string">"http://schemas.microsoft.com/expression/blend/2008"</span></span> xmlns:xaml=<span class="hljs-string"><span class="hljs-string">"http://schemas.stocksharp.com/xaml"</span></span> mc:Ignorable=<span class="hljs-string"><span class="hljs-string">"d"</span></span> d:DesignHeight=<span class="hljs-string"><span class="hljs-string">"450"</span></span> d:DesignWidth=<span class="hljs-string"><span class="hljs-string">"800"</span></span>&gt; &lt;xaml:OrderGrid x:Name=<span class="hljs-string"><span class="hljs-string">"OrderGrid"</span></span> OrderRegistering=<span class="hljs-string"><span class="hljs-string">"OrderGrid_OnOrderRegistering"</span></span> OrderReRegistering=<span class="hljs-string"><span class="hljs-string">"OrderGrid_OnOrderReRegistering"</span></span> OrderCanceling=<span class="hljs-string"><span class="hljs-string">"OrderGrid_OnOrderCanceling"</span></span> /&gt; &lt;/UserControl&gt;</code> </pre> <br> 在请求注册事件处理程序中，我们创建一个OrderWindow窗口，您需要在其中指定工具，投资组合和市场数据的数据源。 在我们的例子中，全部都是连接器。 <br><br> 然后我们使用ShowModal方法调用OrderWindow。 如果在此窗口中按下了“确定”按钮，则通过连接器，我们使用RegisterOrder方法进行注册： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OrderGrid_OnOrderRegistering</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newOrder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OrderWindow { Title = <span class="hljs-string"><span class="hljs-string">"Order registering"</span></span>, Order = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Order(), SecurityProvider = MainWindow.Instance.Connector, MarketDataProvider = MainWindow.Instance.Connector, Portfolios = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PortfolioDataSource(MainWindow.Instance.Connector), }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newOrder.ShowModal(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) MainWindow.Instance.Connector.RegisterOrder(newOrder.Order); }</code> </pre> <br> 在事件重新注册事件处理程序中，我们以相同的方式进行所有操作。 仅在这种情况下，Order对象才会出现在事件中-这是需要重新注册的订单。 因此，在OrderWindow中，我们指定<code>Order = order.ReRegisterClone(newVolume: order.Balance)</code>来填充OrderWindow窗口的字段。 <br><br> 然后我们使用ShowModal方法调用OrderWindow。 如果在此窗口中单击“确定”按钮，那么我们将使用ReRegisterClone方法通过连接器重新注册应用程序。 我们将必须取消的旧应用程序和必须设置的新应用程序移交给它。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OrderGrid_OnOrderReRegistering</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Order order)</span></span></span><span class="hljs-function"> </span></span>{ var window = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OrderWindow { Title = <span class="hljs-string"><span class="hljs-string">"Order re-registering"</span></span>, SecurityProvider = MainWindow.Instance.Connector, MarketDataProvider = MainWindow.Instance.Connector, Portfolios = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PortfolioDataSource(MainWindow.Instance.Connector), Order = order.ReRegisterClone(newVolume: order.Balance) }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (window.ShowModal(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) MainWindow.Instance.Connector.ReRegisterOrder(order, window.Order); }</code> </pre> <br> 在请求取消事件处理程序中，只需调用CancelOrder方法并将订单传递给它即可，该订单必须取消： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OrderGrid_OnOrderCanceling</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Order order</span></span></span><span class="hljs-function">)</span></span> { MainWindow.Instance.Connector.CancelOrder(order); }</code> </pre> <br> 为了使订单显示在OrderGrid中，您需要预订新订单出现的事件和OrderGridControl构造函数中的注册错误事件，然后将这些事件传输到OrderGrid： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OrderGridControl</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { InitializeComponent(); MainWindow.Instance.Connector.NewOrder += OrderGrid.Orders.Add; MainWindow.Instance.Connector.OrderRegisterFailed += OrderGrid.AddRegistrationFail; }</code> </pre> <br> 在MainWindow的中央部分，添加创建的OrderGridControl面板： <br><br><pre> <code class="cs hljs">&lt;dxlc:LayoutGroup HorizontalAlignment=<span class="hljs-string"><span class="hljs-string">"Stretch"</span></span> View=<span class="hljs-string"><span class="hljs-string">"Tabs"</span></span>&gt; &lt;!--  --&gt; &lt;dxlc:LayoutGroup Header=<span class="hljs-string"><span class="hljs-string">"Securities"</span></span>&gt; &lt;myxaml:SecurityGridControl x:Name=<span class="hljs-string"><span class="hljs-string">"SecurityPanel"</span></span> /&gt; &lt;/dxlc:LayoutGroup&gt; &lt;dxlc:LayoutGroup Header=<span class="hljs-string"><span class="hljs-string">"Portfolios"</span></span>&gt; &lt;myxaml:PortfolioGridControl x:Name=<span class="hljs-string"><span class="hljs-string">"PortfolioGridControl"</span></span> /&gt; &lt;/dxlc:LayoutGroup&gt; &lt;dxlc:LayoutGroup Header=<span class="hljs-string"><span class="hljs-string">"Orders"</span></span>&gt; &lt;myxaml:OrderGridControl x:Name=<span class="hljs-string"><span class="hljs-string">"OrderGridControl"</span></span> /&gt; &lt;/dxlc:LayoutGroup&gt; &lt;/dxlc:LayoutGroup&gt;</code> </pre> <br> 运行检查： <br><br><img src="https://habrastorage.org/webt/hp/hu/m7/hphum7vg9x0p-ym0vwdg5_bhdv4.png"><br><br><h2> 创建自己的交易面板 </h2><br> 类似于工具栏，创建我们自己的交易的面板。 在XAML文件夹中，添加另一个UserControl。 为它命名为MyTradeGridControl。 向其中添加MyTradeGrid元素： <br><br><pre> <code class="cs hljs">&lt;UserControl x:Class=<span class="hljs-string"><span class="hljs-string">"ShellNew.XAML.MyTradeGridControl"</span></span> xmlns=<span class="hljs-string"><span class="hljs-string">"http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span></span> xmlns:x=<span class="hljs-string"><span class="hljs-string">"http://schemas.microsoft.com/winfx/2006/xaml"</span></span> xmlns:mc=<span class="hljs-string"><span class="hljs-string">"http://schemas.openxmlformats.org/markup-compatibility/2006"</span></span> xmlns:d=<span class="hljs-string"><span class="hljs-string">"http://schemas.microsoft.com/expression/blend/2008"</span></span> xmlns:xaml=<span class="hljs-string"><span class="hljs-string">"http://schemas.stocksharp.com/xaml"</span></span> mc:Ignorable=<span class="hljs-string"><span class="hljs-string">"d"</span></span> d:DesignHeight=<span class="hljs-string"><span class="hljs-string">"450"</span></span> d:DesignWidth=<span class="hljs-string"><span class="hljs-string">"800"</span></span>&gt; &lt;xaml:MyTradeGrid x:Name=<span class="hljs-string"><span class="hljs-string">"MyTradeGrid"</span></span> /&gt; &lt;/UserControl&gt;</code> </pre> <br> 在MyTradeGridControl构造函数中，我们需要订阅一个新的自己交易的外观事件，并将其转移到MyTradeGrid： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyTradeGridControl</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { InitializeComponent(); MainWindow.Instance.Connector.NewMyTrade += MyTradeGrid.Trades.Add; }</code> </pre> <br> 在MainWindow的中央部分，添加创建的OrderGridControl面板： <br><br><pre> <code class="css hljs">&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">dxlc</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:LayoutGroup</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">HorizontalAlignment</span></span>="<span class="hljs-selector-tag"><span class="hljs-selector-tag">Stretch</span></span>" <span class="hljs-selector-tag"><span class="hljs-selector-tag">View</span></span>="<span class="hljs-selector-tag"><span class="hljs-selector-tag">Tabs</span></span>"&gt; &lt;!<span class="hljs-selector-tag"><span class="hljs-selector-tag">--</span></span>  <span class="hljs-selector-tag"><span class="hljs-selector-tag">--</span></span>&gt; &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">dxlc</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:LayoutGroup</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Header</span></span>="<span class="hljs-selector-tag"><span class="hljs-selector-tag">Securities</span></span>"&gt; &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">myxaml</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:SecurityGridControl</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:Name</span></span>="<span class="hljs-selector-tag"><span class="hljs-selector-tag">SecurityPanel</span></span>" /&gt; &lt;/<span class="hljs-selector-tag"><span class="hljs-selector-tag">dxlc</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:LayoutGroup</span></span>&gt; &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">dxlc</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:LayoutGroup</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Header</span></span>="<span class="hljs-selector-tag"><span class="hljs-selector-tag">Portfolios</span></span>"&gt; &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">myxaml</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:PortfolioGridControl</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:Name</span></span>="<span class="hljs-selector-tag"><span class="hljs-selector-tag">PortfolioGridControl</span></span>" /&gt; &lt;/<span class="hljs-selector-tag"><span class="hljs-selector-tag">dxlc</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:LayoutGroup</span></span>&gt; &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">dxlc</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:LayoutGroup</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Header</span></span>="<span class="hljs-selector-tag"><span class="hljs-selector-tag">Orders</span></span>"&gt; &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">myxaml</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:OrderGridControl</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:Name</span></span>="<span class="hljs-selector-tag"><span class="hljs-selector-tag">OrderGridControl</span></span>" /&gt; &lt;/<span class="hljs-selector-tag"><span class="hljs-selector-tag">dxlc</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:LayoutGroup</span></span>&gt; &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">dxlc</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:LayoutGroup</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Header</span></span>="<span class="hljs-selector-tag"><span class="hljs-selector-tag">MyTrades</span></span>"&gt; &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">myxaml</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:MyTradeGridControl</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:Name</span></span>="<span class="hljs-selector-tag"><span class="hljs-selector-tag">MyTradeGridControl</span></span>" /&gt; &lt;/<span class="hljs-selector-tag"><span class="hljs-selector-tag">dxlc</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:LayoutGroup</span></span>&gt; &lt;/<span class="hljs-selector-tag"><span class="hljs-selector-tag">dxlc</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:LayoutGroup</span></span>&gt;</code> </pre> <br> 运行检查： <br><br><img src="https://habrastorage.org/webt/-4/dr/x1/-4drx1smuyevvg-e5esktgw4ey4.png"><br><br><h2> 用策略创建面板 </h2><br> 我们将以与所有以前的面板相同的方式创建一个策略面板。 在XAML文件夹中，添加另一个UserControl。 为它命名为StrategyControl。 使用LayoutControl，我们将屏幕分为两部分。 在左侧，将有一个带有烛台图表的选项卡和一个带有策略统计信息的选项卡： <br><br><pre> <code class="cs hljs">&lt;dxlc:LayoutGroup Orientation=<span class="hljs-string"><span class="hljs-string">"Vertical"</span></span>&gt; &lt;dxlc:LayoutGroup View=<span class="hljs-string"><span class="hljs-string">"Tabs"</span></span> Name=<span class="hljs-string"><span class="hljs-string">"StatistisAndChartLayoutGroup"</span></span>&gt; &lt;dxlc:LayoutGroup Header=<span class="hljs-string"><span class="hljs-string">"Chart"</span></span>&gt; &lt;xaml:Chart x:Name=<span class="hljs-string"><span class="hljs-string">"Chart"</span></span> /&gt; &lt;/dxlc:LayoutGroup&gt; &lt;dxlc:LayoutGroup Header=<span class="hljs-string"><span class="hljs-string">"Statistic"</span></span>&gt; &lt;dxlc:LayoutItem VerticalAlignment=<span class="hljs-string"><span class="hljs-string">"Stretch"</span></span> dxlc:LayoutControl.AllowHorizontalSizing=<span class="hljs-string"><span class="hljs-string">"True"</span></span> &gt; &lt;xaml:StatisticParameterGrid x:Name=<span class="hljs-string"><span class="hljs-string">"StatisticParameterGrid"</span></span> MaxHeight=<span class="hljs-string"><span class="hljs-string">"2000"</span></span>/&gt; &lt;/dxlc:LayoutItem&gt; &lt;dxlc:LayoutItem VerticalAlignment=<span class="hljs-string"><span class="hljs-string">"Stretch"</span></span> &gt; &lt;xaml:EquityCurveChart x:Name=<span class="hljs-string"><span class="hljs-string">"EquityCurveChart"</span></span> /&gt; &lt;/dxlc:LayoutItem&gt; &lt;/dxlc:LayoutGroup&gt; &lt;/dxlc:LayoutGroup&gt; &lt;/dxlc:LayoutGroup&gt;</code> </pre> <br> 这里，StatisticParameterGrid用于显示策略统计信息，EquityCurveChart用于显示损益表。  StatisticParameterGrid需要设置一些MaxHeight值，否则应用程序将无法启动。 <br><br> 右侧将在PropertyGridEx中配置策略的属性。 用于启动和停止策略的按钮也将位于： <br><br><pre> <code class="cs hljs">&lt;dxlc:LayoutGroup View=<span class="hljs-string"><span class="hljs-string">"Group"</span></span> dxlc:LayoutControl.AllowHorizontalSizing=<span class="hljs-string"><span class="hljs-string">"True"</span></span> dxlc:DockLayoutControl.Dock=<span class="hljs-string"><span class="hljs-string">"Right"</span></span> Orientation=<span class="hljs-string"><span class="hljs-string">"Vertical"</span></span>&gt; &lt;dxlc:LayoutItem VerticalAlignment=<span class="hljs-string"><span class="hljs-string">"Stretch"</span></span>&gt; &lt;xaml:PropertyGridEx x:Name=<span class="hljs-string"><span class="hljs-string">"PropertyGridEx"</span></span> /&gt; &lt;/dxlc:LayoutItem&gt; &lt;dxlc:LayoutItem VerticalAlignment=<span class="hljs-string"><span class="hljs-string">"Stretch"</span></span> Height=<span class="hljs-string"><span class="hljs-string">"20"</span></span>&gt; &lt;dx:SimpleButton x:Name=<span class="hljs-string"><span class="hljs-string">"StartStrategyButton"</span></span> Content=<span class="hljs-string"><span class="hljs-string">"Start strategy"</span></span> ToolTip=<span class="hljs-string"><span class="hljs-string">"Start strategy"</span></span> Click=<span class="hljs-string"><span class="hljs-string">"StartStrategyButton_Click"</span></span> /&gt; &lt;/dxlc:LayoutItem&gt; &lt;dxlc:LayoutItem VerticalAlignment=<span class="hljs-string"><span class="hljs-string">"Stretch"</span></span> Height=<span class="hljs-string"><span class="hljs-string">"20"</span></span>&gt; &lt;dx:SimpleButton x:Name=<span class="hljs-string"><span class="hljs-string">"StopStrategyButton"</span></span> Content=<span class="hljs-string"><span class="hljs-string">"Stop strategy"</span></span> ToolTip=<span class="hljs-string"><span class="hljs-string">"Stop strategy"</span></span> Click=<span class="hljs-string"><span class="hljs-string">"StopStrategyButton_Click"</span></span> /&gt; &lt;/dxlc:LayoutItem&gt; &lt;/dxlc:LayoutGroup&gt;</code> </pre> <br> 完整代码： <br><br><pre> <code class="cs hljs">&lt;UserControl x:Class=<span class="hljs-string"><span class="hljs-string">"ShellNew.XAML.StrategyControl"</span></span> xmlns=<span class="hljs-string"><span class="hljs-string">"http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span></span> xmlns:x=<span class="hljs-string"><span class="hljs-string">"http://schemas.microsoft.com/winfx/2006/xaml"</span></span> xmlns:mc=<span class="hljs-string"><span class="hljs-string">"http://schemas.openxmlformats.org/markup-compatibility/2006"</span></span> xmlns:d=<span class="hljs-string"><span class="hljs-string">"http://schemas.microsoft.com/expression/blend/2008"</span></span> xmlns:dxlc=<span class="hljs-string"><span class="hljs-string">"http://schemas.devexpress.com/winfx/2008/xaml/layoutcontrol"</span></span> xmlns:xaml=<span class="hljs-string"><span class="hljs-string">"http://schemas.stocksharp.com/xaml"</span></span> xmlns:dx=<span class="hljs-string"><span class="hljs-string">"http://schemas.devexpress.com/winfx/2008/xaml/core"</span></span> mc:Ignorable=<span class="hljs-string"><span class="hljs-string">"d"</span></span>&gt; &lt;dxlc:LayoutControl&gt; &lt;dxlc:LayoutGroup Orientation=<span class="hljs-string"><span class="hljs-string">"Vertical"</span></span>&gt; &lt;dxlc:LayoutGroup View=<span class="hljs-string"><span class="hljs-string">"Tabs"</span></span> Name=<span class="hljs-string"><span class="hljs-string">"StatistisAndChartLayoutGroup"</span></span>&gt; &lt;dxlc:LayoutGroup Header=<span class="hljs-string"><span class="hljs-string">"Chart"</span></span>&gt; &lt;xaml:Chart x:Name=<span class="hljs-string"><span class="hljs-string">"Chart"</span></span> /&gt; &lt;/dxlc:LayoutGroup&gt; &lt;dxlc:LayoutGroup Header=<span class="hljs-string"><span class="hljs-string">"Statistic"</span></span>&gt; &lt;dxlc:LayoutItem VerticalAlignment=<span class="hljs-string"><span class="hljs-string">"Stretch"</span></span> dxlc:LayoutControl.AllowHorizontalSizing=<span class="hljs-string"><span class="hljs-string">"True"</span></span> &gt; &lt;xaml:StatisticParameterGrid x:Name=<span class="hljs-string"><span class="hljs-string">"StatisticParameterGrid"</span></span> MaxHeight=<span class="hljs-string"><span class="hljs-string">"2000"</span></span>/&gt; &lt;/dxlc:LayoutItem&gt; &lt;dxlc:LayoutItem VerticalAlignment=<span class="hljs-string"><span class="hljs-string">"Stretch"</span></span> &gt; &lt;xaml:EquityCurveChart x:Name=<span class="hljs-string"><span class="hljs-string">"EquityCurveChart"</span></span> /&gt; &lt;/dxlc:LayoutItem&gt; &lt;/dxlc:LayoutGroup&gt; &lt;/dxlc:LayoutGroup&gt; &lt;/dxlc:LayoutGroup&gt; &lt;dxlc:LayoutGroup View=<span class="hljs-string"><span class="hljs-string">"Group"</span></span> dxlc:LayoutControl.AllowHorizontalSizing=<span class="hljs-string"><span class="hljs-string">"True"</span></span> dxlc:DockLayoutControl.Dock=<span class="hljs-string"><span class="hljs-string">"Right"</span></span> Orientation=<span class="hljs-string"><span class="hljs-string">"Vertical"</span></span>&gt; &lt;dxlc:LayoutItem VerticalAlignment=<span class="hljs-string"><span class="hljs-string">"Stretch"</span></span>&gt; &lt;xaml:PropertyGridEx x:Name=<span class="hljs-string"><span class="hljs-string">"PropertyGridEx"</span></span> /&gt; &lt;/dxlc:LayoutItem&gt; &lt;dxlc:LayoutItem VerticalAlignment=<span class="hljs-string"><span class="hljs-string">"Stretch"</span></span> Height=<span class="hljs-string"><span class="hljs-string">"20"</span></span>&gt; &lt;dx:SimpleButton x:Name=<span class="hljs-string"><span class="hljs-string">"StartStrategyButton"</span></span> Content=<span class="hljs-string"><span class="hljs-string">"Start strategy"</span></span> ToolTip=<span class="hljs-string"><span class="hljs-string">"Start strategy"</span></span> Click=<span class="hljs-string"><span class="hljs-string">"StartStrategyButton_Click"</span></span> /&gt; &lt;/dxlc:LayoutItem&gt; &lt;dxlc:LayoutItem VerticalAlignment=<span class="hljs-string"><span class="hljs-string">"Stretch"</span></span> Height=<span class="hljs-string"><span class="hljs-string">"20"</span></span>&gt; &lt;dx:SimpleButton x:Name=<span class="hljs-string"><span class="hljs-string">"StopStrategyButton"</span></span> Content=<span class="hljs-string"><span class="hljs-string">"Stop strategy"</span></span> ToolTip=<span class="hljs-string"><span class="hljs-string">"Stop strategy"</span></span> Click=<span class="hljs-string"><span class="hljs-string">"StopStrategyButton_Click"</span></span> /&gt; &lt;/dxlc:LayoutItem&gt; &lt;/dxlc:LayoutGroup&gt; &lt;/dxlc:LayoutControl&gt; &lt;/UserControl&gt;</code> </pre> <br> 在StrategyControl构造函数中，将连接器设置为PropertyGridEx的数据源，几乎在每个控件中我们都执行了类似的操作： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StrategyControl</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { InitializeComponent(); PropertyGridEx.SecurityProvider = MainWindow.Instance.Connector; PropertyGridEx.Portfolios = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PortfolioDataSource(MainWindow.Instance.Connector); }</code> </pre> <br> 我们需要以某种方式将策略转移到我们的控制中。 为此，请在StrategyControl中创建BindStraregy方法，该方法将采用该策略，并将其链接保存到局部变量中，并在PropertyGridEx和StatisticParameterGrid中设置该策略。 <br><br> 使用SetChart方法，我们将Chart蜡烛的图表转移到该策略；之后，您可以使用GetChart方法获得Chart策略。 我们还为策略设置了连接器。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Strategy _strategy; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BindStraregy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Strategy strategy</span></span></span><span class="hljs-function">)</span></span> { _strategy = strategy; PropertyGridEx.SelectedObject = strategy; StatisticParameterGrid.Parameters. AddRange(_strategy.StatisticManager.Parameters); _strategy.SetChart(Chart); _strategy.Connector = MainWindow.Instance.Connector; }</code> </pre> <br> 在制定损益表时，应注意该策略将启动和停止，也许有几次，每次启动该策略时都必须清除这首诗。 为此，我们将创建ResetEquityCurveChart方法，在此方法中，我们将首先清除EquityCurveChart。 然后，我们需要为EquityCurveChart创建图形元素，它们可以指定线的名称，颜色和类型。 <br><br> 之后，我们订阅该策略的PnL更改事件，并在此事件的处理程序中在EquityCurveChart损益图上绘制一个新值： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetEquityCurveChart</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { EquityCurveChart.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pnl = EquityCurveChart. CreateCurve(<span class="hljs-string"><span class="hljs-string">"PNL"</span></span>, Colors.Green, ChartIndicatorDrawStyles.Area); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> unrealizedPnL = EquityCurveChart. CreateCurve(<span class="hljs-string"><span class="hljs-string">"unrealizedPnL"</span></span>, Colors.Black, ChartIndicatorDrawStyles.Line); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> commissionCurve = EquityCurveChart .CreateCurve(<span class="hljs-string"><span class="hljs-string">"commissionCurve"</span></span>, Colors.Red, ChartIndicatorDrawStyles.Line); _strategy.PnLChanged += () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChartDrawData(); data.Group(_strategy.CurrentTime) .Add(pnl, _strategy.PnL) .Add(unrealizedPnL, _strategy.PnLManager.UnrealizedPnL ?? <span class="hljs-number"><span class="hljs-number">0</span></span>) .Add(commissionCurve, _strategy.Commission ?? <span class="hljs-number"><span class="hljs-number">0</span></span>); EquityCurveChart.Draw(data); }; }</code> </pre> <br> 在用于单击“开始”按钮的事件处理程序中，我们将调用此方法。 我们还将重置策略的状态并运行它： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartStrategyButton_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { ResetEquityCurveChart(); _strategy.Reset(); _strategy.Start(); }</code> </pre> <br> 在用于单击“停止”按钮的事件处理程序中，我们将停止该策略。 <br> 私有void StopStrategyButton_Click（对象发送者，RoutedEventArgs e）： <br><br><pre> <code class="cs hljs">{ _strategy.Stop(); }</code> </pre> <br> 在MainWindow的中央部分，添加创建的StrategyControl面板： <br><br><pre> <code class="cs hljs">&lt;dxlc:LayoutGroup HorizontalAlignment=<span class="hljs-string"><span class="hljs-string">"Stretch"</span></span> View=<span class="hljs-string"><span class="hljs-string">"Tabs"</span></span>&gt; &lt;!--  --&gt; &lt;dxlc:LayoutGroup Header=<span class="hljs-string"><span class="hljs-string">"Securities"</span></span>&gt; &lt;myxaml:SecurityGridControl x:Name=<span class="hljs-string"><span class="hljs-string">"SecurityPanel"</span></span> /&gt; &lt;/dxlc:LayoutGroup&gt; &lt;dxlc:LayoutGroup Header=<span class="hljs-string"><span class="hljs-string">"Portfolios"</span></span>&gt; &lt;myxaml:PortfolioGridControl x:Name=<span class="hljs-string"><span class="hljs-string">"PortfolioGridControl"</span></span> /&gt; &lt;/dxlc:LayoutGroup&gt; &lt;dxlc:LayoutGroup Header=<span class="hljs-string"><span class="hljs-string">"Orders"</span></span>&gt; &lt;myxaml:OrderGridControl x:Name=<span class="hljs-string"><span class="hljs-string">"OrderGridControl"</span></span> /&gt; &lt;/dxlc:LayoutGroup&gt; &lt;dxlc:LayoutGroup Header=<span class="hljs-string"><span class="hljs-string">"MyTrades"</span></span>&gt; &lt;myxaml:MyTradeGridControl x:Name=<span class="hljs-string"><span class="hljs-string">"MyTradeGridControl"</span></span> /&gt; &lt;/dxlc:LayoutGroup&gt; &lt;dxlc:LayoutGroup Header=<span class="hljs-string"><span class="hljs-string">"MarketDepth"</span></span>&gt; &lt;myxaml:MarketDepthControl x:Name=<span class="hljs-string"><span class="hljs-string">"MarketDepthControl"</span></span> /&gt; &lt;/dxlc:LayoutGroup&gt; &lt;dxlc:LayoutGroup Header=<span class="hljs-string"><span class="hljs-string">"SimpleStrategyControl"</span></span>&gt; &lt;myxaml:StrategyControl x:Name=<span class="hljs-string"><span class="hljs-string">"SimpleStrategyControl"</span></span> /&gt; &lt;/dxlc:LayoutGroup&gt; &lt;/dxlc:LayoutGroup&gt;</code> </pre> <br><h2> 策略制定 </h2><br> 例如，考虑创建一个简单的烛台策略。 如果蜡烛在增长（绿色），她将买入；如果蜡烛在减少（红色），她将卖出。 <br><br> 让我们在项目中创建另一个文件夹-我们将在其中存储所有策略。 在此文件夹中，创建一个新类，将其命名为SimpleStrategy。 所有S＃策略都必须继承自策略策略的基类。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SimpleStrategy</span></span> : <span class="hljs-title"><span class="hljs-title">Strategy</span></span> {}</code> </pre> <br> 由于我们的策略使用蜡烛，因此我们将创建公共属性CandleSeries，并在策略的构造函数中将其设置为默认值。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SimpleStrategy</span></span> : <span class="hljs-title"><span class="hljs-title">Strategy</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CandleSeries Series { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SimpleStrategy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Series = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CandleSeries(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(TimeFrameCandle), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Security(), TimeSpan.FromSeconds(<span class="hljs-number"><span class="hljs-number">15</span></span>)) { BuildCandlesMode = MarketDataBuildModes.Build }; } }</code> </pre> <br> 在这里，我们指示CandleSeries中的蜡烛将为TimeFrameCandle，间隔为15秒（TimeSpan.FromSeconds（15））。 对于CandleSeries，您可以指定BuildCandlesMode蜡烛创建模式。 我们指示将建立蜡烛（MarketDataBuildModes.Build）。 默认情况下，它们将基于刻度创建，但是您可以指定其他数据类型。 <br><br> 由于我们将CandleSeries设为公共财产，因此可以通过上一段中所述的PropertyGridEx进一步自定义CandleSeries。 所有策略都有可以重写的方法，我们需要重写OnStarted方法。 在启动策略之前将其调用，并允许您将其预先设置为启动状态。 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnStarted</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _connector = (Connector)Connector; Series.Security = Security; _connector .WhenCandlesFinished(Series) .Do(ProcessCandle) .Apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); _connector.SubscribeCandles(Series); <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnStarted(); }</code> </pre> <br> 在这里，对于CandleSeries，我们定义了PropertyGridEx中指定的工具。 然后创建处理成品蜡烛的规则。 在规则中，指定将处理每个完成的蜡烛的方法-在我们的例子中，这是ProcessCandle方法。 稍后将描述。 设置完所有内容后，我们通过SubscribeCandles方法在连接器中的CandleSeries上预订蜡烛的外观。 在我们的例子中，ProcessCandle方法包含该策略的主要逻辑： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessCandle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Candle candle</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsRealTime(candle)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (candle.OpenPrice &lt; candle.ClosePrice &amp;&amp; Position &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { RegisterOrder(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.BuyAtMarket(Volume + Math.Abs(Position))); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (candle.OpenPrice &gt; candle.ClosePrice &amp;&amp; Position &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { RegisterOrder(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SellAtMarket(Volume + Math.Abs(Position))); } }</code> </pre> <br> 首先，我们需要确定蜡烛是实时构建的还是历史悠久的。 如果蜡烛是历史的，那么我们将其忽略。 并非所有策略都需要这样做，例如，基于眼镜的策略并不需要此，因为眼镜始终是实时运行的。 没有通用的方法可以确定蜡烛是“实时”还是历史蜡烛，并且在每种策略中，必须根据要求独立解决此问题。 在这种情况下，我们将简单地将蜡烛关闭的时间与连接器中的时间进行比较，如果不超过一定的延迟，则蜡烛将具有实时状态。 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsRealTime</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Candle candle</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (Connector.CurrentTime - candle.CloseTime).TotalSeconds &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; }</code> </pre> <br> 接下来，我们看看这是什么蜡烛，以及该策略的当前位置是什么。 如果蜡烛在增长，那么头寸等于0，我们将使用PropertyGridEx中我们设置的交易量的市场订单开仓。 如果蜡烛在增长并且位置小于0，则我们将位置“反转”： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (candle.OpenPrice &lt; candle.ClosePrice &amp;&amp; Position &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { RegisterOrder(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.BuyAtMarket(Volume + Math.Abs(Position))); }</code> </pre> <br><br> 对于蜡烛的减弱，我们采取相反的做法： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (candle.OpenPrice &gt; candle.ClosePrice &amp;&amp; Position &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { RegisterOrder(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SellAtMarket(Volume + Math.Abs(Position))); }</code> </pre> <br> 目前，我们的策略已准备就绪。 它必须传递给我们在上一段落中使用BindStraregy方法创建的SimpleStrategyControl。 我们在初始化MainWindow组件后立即在MainWindow构造函数中执行此操作。 <br><br><pre> <code class="cs hljs">SimpleStrategyControl.BindStraregy(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleStrategy());</code> </pre> <br><br> 运行检查： <br><br><img src="https://habrastorage.org/webt/b1/-p/t6/b1-pt6ohswyhv5ylanblhvjhsf4.png"><br><br><img src="https://habrastorage.org/webt/ig/qx/kd/igqxkdcsehmsbeeayj-wnhgmhuk.png"><br><br> 该策略有效，达成了交易，但是到目前为止，图表上还没有蜡烛和交易。 <br><br><h2> 从策略中添加蜡烛和交易至图表 </h2><br> 在使用SetChart方法的有关策略面板的部分中，我们将Chart蜡烛的图表背叛了该策略。 在策略的OnStarted方法中，我们检查是否为该策略设置了图表，如果已设置，则我们初始化图表，并订阅新的自有事务的外观和烛形变化的事件。 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnStarted</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _connector = (Connector)Connector; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetChart() <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Chart chart) { InitChart(chart); NewMyTrade += DrawMyTrade; _connector.CandleSeriesProcessing += CandleSeriesProcessing; } Series.Security = Security; _connector .WhenCandlesFinished(Series) .Do(ProcessCandle) .Apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); _connector.SubscribeCandles(Series); <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnStarted(); }</code> </pre> <br>  InitChart图表初始化方法： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ChartCandleElement _chartCandleElement; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ChartTradeElement _tradesElem; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Chart _chart; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitChart</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Chart chart</span></span></span><span class="hljs-function">)</span></span> { _chart = chart; _chart.GuiSync(() =&gt; { _chart.ClearAreas(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> candlesArea = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChartArea(); _chart.AddArea(candlesArea); _chartCandleElement = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChartCandleElement(); _chart.AddElement(candlesArea, _chartCandleElement); _tradesElem = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChartTradeElement { FullTitle = <span class="hljs-string"><span class="hljs-string">"Trade"</span></span> }; _chart.AddElement(candlesArea, _tradesElem); }); }</code> </pre> <br> 在这里，我们将指向Chart的链接保存在本地变量中。 我们清除了时间表。 我们还创建蜡烛和交易的图表元素并将其转移到图表图表元素。 构造_chart.GuiSync（（）=&gt; {...}）; 为了初始化主线程中的计划，需要此命令。 <br><br>  CandleSeries在图表上绘制蜡烛的流程图： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CandleSeriesProcessing</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CandleSeries candleSeries, Candle candle</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChartDrawData(); data.Group(candle.OpenTime) .Add(_chartCandleElement, candle); _chart.Draw(data); }</code> </pre> <br> 在这里，我们从连接器的CandleSeriesProcessing事件中获得一条蜡烛，创建一个ChartDrawData以便在图表上显示它。 我们指示时间数据。Group（candle.OpenTime），指示应将蜡烛添加到图表的蜡烛元素。添加（_chartCandleElement，Candle）;。 并且我们表明图形需要绘制新数据。 <br><br> 我们对交易执行类似的操作： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DrawMyTrade</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MyTrade myTrade</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChartDrawData(); data.Group(myTrade.Trade.Time) .Add(_tradesElem, myTrade); _chart.Draw(data); }</code> </pre> <br> 运行检查： <br><br><img src="https://habrastorage.org/webt/bv/ll/xa/bvllxaiaoeshjg0_71xwfocozqa.png"><br><br><h2> 简要结论 </h2><br> 要创建一个复杂且专业的外观应用程序，您不需要花费大量时间。 数小时以来，我们创建了一个功能强大的应用程序，能够配置，显示直接交易和算法交易。 <br> 不要害怕尝试创建自己的交易程序。 我们希望本文能帮助您熟悉此事。 <br><br>  <b>作者</b> ：伊万·扎鲁茨基（Ivan Zalutsky） </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN433078/">https://habr.com/ru/post/zh-CN433078/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN433066/index.html">高负荷杯＃2。 后端开发人员重新投入使用的冠军</a></li>
<li><a href="../zh-CN433070/index.html">如何从香菇中区分洗发水，从香槟中区分烤串... Elasticsearch-在商店数据库中搜索产品</a></li>
<li><a href="../zh-CN433072/index.html">如何破解Sega Dreamcast控制台复制保护</a></li>
<li><a href="../zh-CN433074/index.html">在Android项目中切换到Kotlin：提示和技巧</a></li>
<li><a href="../zh-CN433076/index.html">我们如何制作Android Gallery库以查看媒体内容</a></li>
<li><a href="../zh-CN433082/index.html">抽走他人的帐户已成为韩国的刑事犯罪</a></li>
<li><a href="../zh-CN433084/index.html">公开课“以经典泰坦尼克号数据集为例的特征工程”</a></li>
<li><a href="../zh-CN433086/index.html">Tinkoff以及一切，一切，一切：银行的物联网，分析和监控</a></li>
<li><a href="../zh-CN433088/index.html">埃隆·马斯克（Elon Musk）：您如何看待宝马和保时捷开发的充电技术，可在3分钟内增加100公里的行驶距离</a></li>
<li><a href="../zh-CN433090/index.html">Oracle位图索引技术</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>