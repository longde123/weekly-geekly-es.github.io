<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👵 🏒 🍍 Persaingan dari Yandex.Taxi: analisis trek backend kejuaraan pemrograman 👆🏼 👨🏾‍🌾 ☕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Presentasi hadiah kepada para peserta trek backend 
 Kami sedang menyelesaikan serangkaian analisis kejuaraan pemrograman kedua. Dalam beberapa minggu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Persaingan dari Yandex.Taxi: analisis trek backend kejuaraan pemrograman</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/483624/"><img src="https://habrastorage.org/webt/za/i-/9x/zai-9xkajiamr99zrbldb0fstty.jpeg"><br><h5>  <sup><sub>Presentasi hadiah kepada para peserta trek backend</sub></sup> </h5><br>  Kami sedang menyelesaikan serangkaian analisis kejuaraan pemrograman kedua.  Dalam beberapa minggu terakhir, kami telah menerbitkan analisis tiga lagu: ML, tampilan depan dan pengembangan seluler.  Masih mengurai trek di backend.  Ternyata menjadi yang paling populer: 2682 orang mengambil bagian dalam kualifikasi, 320 dari mereka mencapai final.  Tugas untuk pengembang backend diciptakan oleh tim Yandex.Taxi. <br><a name="habracut"></a><br><h2>  Kode promosi Mars </h2>  <sup><i>Penulis: Maxim Pedchenko</i></sup> <br><div class="scrollable-table"><table><tbody><tr><td>  Batas waktu </td><td>  1 s </td></tr><tr><td>  Batas memori </td><td>  64 MB </td></tr><tr><td>  Masuk </td><td>  input standar atau input.txt </td></tr><tr><td>  Kesimpulan </td><td>  output standar atau output.txt </td></tr></tbody></table></div>  Enam bulan telah berlalu sejak peluncuran Yandex.Taxi di Mars.  Menjelang Tahun Baru Mars, Yandex.Taxi memutuskan untuk memberikan kode promosi kepada orang-orang Mars.  Tetapi ternyata Mars tidak dapat menggunakan kode promo Earth, karena server di Mars tidak berfungsi sesuai dengan aturan Earth.  Oleh karena itu, Yandex.Taxi datang dengan kode promosi Mars khusus. <br><br>  Kode promosi Mars dihasilkan sebagai berikut: <br><br><ol><li>  Kunci enkripsi dibuat. </li><li>  Kunci enkripsi dibagi menjadi substring dengan panjang acak. </li><li>  Dari semua substring, substring dengan panjang L dipilih. </li><li>  Substring yang dipilih dicampur dan digabung. </li><li>  Hasil penggabungan adalah kode promosi. </li></ol><br>  Tantangan: <br>  Penting untuk memeriksa apakah kode promosi yang dimasukkan valid.  Jika kode promosi itu valid, Anda perlu mencetak "YA".  Jika tidak valid, "TIDAK". <br><br><div class="spoiler">  <b class="spoiler_title">Format, Contoh, dan Catatan I / O</b> <div class="spoiler_text"><h4>  Format input </h4><br>  &lt;panjang kode promosi&gt; <br>  &lt;kode promosi&gt; <br><br>  &lt;panjang kunci&gt; <br><br>  &lt;kunci&gt; <br><br>  &lt;panjang substring L&gt; <br><br><h4>  Format output </h4><br>  Validitas kode promosi: YA atau TIDAK. <br><br><h4>  Contoh 1 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Masuk</b> </td><td>  <b>Kesimpulan</b> </td></tr><tr><td><code>6 <br> ABCDEA <br> 6 <br> EAABCD <br> 2</code> </td> <td> <code>YES</code> </td> </tr></tbody></table></div><h4>  Contoh 2 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Masuk</b> </td><td>  <b>Kesimpulan</b> </td></tr><tr><td> <code>12 <br> MARS1234MARS <br> 24 <br> ASDGRV12MARSS1234VRCMARS <br> 4</code> </td> <td> <code>YES</code> </td> </tr></tbody></table></div><h4>  Contoh 3 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Masuk</b> </td><td>  <b>Kesimpulan</b> </td></tr><tr><td> <code>12 <br> ABC123123ABC <br> 9 <br> ABC123123 <br> 3</code> </td> <td> <code>NO</code> </td> </tr></tbody></table></div><h4>  Catatan </h4><br>  Panjang L&gt; 1. <br>  Alfabet kode promosi [AZ, 0-9]. <br>  Panjang kode promosi ada dalam kisaran [6, 30]. <br>  Panjang kunci dalam kisaran [6, 30]. <br>  Panjang Substring L &lt;panjang kunci. <br>  Panjang kode promosi adalah kelipatan dari L. </div></div><br><h4>  Solusi </h4><br>  Kita perlu mempertimbangkan semua kemungkinan partisi kunci enkripsi ke dalam substring dengan panjang L dan memeriksa apakah kode promo ini dapat terdiri dari kemungkinan partisi. <br><br>  Petunjuk tersembunyi di catatan kondisi: <br><blockquote>  Panjang kode promosi ada dalam kisaran [6, 30]. <br>  Panjang kunci dalam kisaran [6, 30]. </blockquote><br>  Pembatasan kecil menunjukkan bahwa solusi yang efektif tidak diperlukan, yang berarti bahwa Anda tidak perlu menghabiskan waktu mencari pengoptimalan - lebih baik untuk menyelesaikan masalah secara langsung. <br><br>  Situasi ini adalah tipikal dari pengembangan backend produk.  Seringkali ada situasi di mana Anda dapat menghabiskan berminggu-minggu pada algoritma optimal, tetapi jika Anda mempertimbangkan batasannya, menjadi jelas bahwa lebih baik menggunakan solusi yang cepat dan bukan yang paling optimal. <br><br>  Jadi, kita akan mempertimbangkan baris dengan kode promosi sebagai urutan substring S dengan panjang L. Untuk setiap substring S kita menemukan semua substring <sub>Sk</sub> sama dengan itu dari kunci enkripsi.  Untuk setiap S <sub>k,</sub> ingat penggunaannya, beralih ke substring S berikutnya dan ulangi algoritma. <br><br>  Jika untuk substring S tidak mungkin untuk menemukan S <sub>k yang</sub> tidak digunakan, perlu untuk mencoba varian pembelahan lain, jika tidak ada varian lain, maka kode promosi tidak valid. <br><br>  Jika S <sub>k</sub> ditemukan setidaknya untuk satu kasus untuk setiap S, maka kode promosi valid. <br><br><h2>  Optimasi Sistem Transportasi Mars </h2>  <sup><i>Penulis: Dmitry Polishchuk dan Anton Todua</i></sup> <br><div class="scrollable-table"><table><tbody><tr><td>  Batas waktu </td><td>  3 s </td></tr><tr><td>  Batas memori </td><td>  64 MB </td></tr><tr><td>  Masuk </td><td>  input standar </td></tr><tr><td>  Kesimpulan </td><td>  output standar </td></tr></tbody></table></div>  Itu adalah tahun 2058.  Koloni-koloni pemukim pertama sudah mendarat di Mars dan mulai menghuninya, dan Yandex.Taxi mulai menyebarkan sistem stasiun antar-jemput. <br><br>  Untuk operasi normal, stasiun ulang-alik membutuhkan catu daya yang konstan dari jaringan energi.  Untuk menyalakan stasiun, Anda harus membangun generator energi nuklir uranium di dalam stasiun itu sendiri, atau meletakkan kabel ke stasiun pesawat ulang-alik lain (yang sudah bertenaga).  Biaya membangun generator di dalam stasiun antar-jemput yang berbeda dapat bervariasi.  Rute kabel antara stasiun antar-jemput juga bervariasi dalam biaya dan tidak selalu memungkinkan.  Koneksi kabel bersifat dua arah. <br><br>  Tugasnya adalah mengatur daya yang efisien (dengan biaya minimal) ke semua stasiun shuttle. <br><br>  Di pintu masuk, program menerima jumlah total stasiun ulang-alik, biaya pembuatan generator untuk setiap stasiun ulang-alik dan deskripsi dari semua kabel yang mungkin antara stasiun antar-jemput (jumlah stasiun yang terhubung dan biaya pemasangan kabel). <br><br><div class="spoiler">  <b class="spoiler_title">Format, Contoh, dan Catatan I / O</b> <div class="spoiler_text"><h4>  Format input </h4><br>  <b>Baris pertama</b> berisi satu nomor stasiun antar-jemput non-negatif N ≤ 1000. <br><br>  <b>Baris kedua</b> berisi nomor N yang menentukan biaya pembuatan generator di dalam stasiun yang sesuai. <br><br>  <b>Jalur ketiga</b> berisi jumlah kabel non-negatif tunggal K ≤ 100000 antar stasiun antar-jemput. <br><br>  <b>Baris K berikutnya</b> (mulai dari yang keempat) berisi deskripsi satu kabel - tiga bilangan bulat non-negatif: <b>jumlah stasiun pertama</b> , <b>jumlah stasiun kedua</b> dan <b>biaya pelaksanaan</b> . <br><br><h4>  Format output </h4><br>  Satu integer adalah biaya daya minimum untuk semua stasiun shuttle untuk konfigurasi yang diberikan. <br><br><h4>  Contoh 1 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Masuk</b> </td><td>  <b>Kesimpulan</b> </td></tr><tr><td> <code>1 <br> 77 <br> 0</code> </td> <td> <code>77</code> </td> </tr></tbody></table></div><h4>  Contoh 2 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Masuk</b> </td><td>  <b>Kesimpulan</b> </td></tr><tr><td> <code>2 <br> 11 29 <br> 1 <br> 1 2 17</code> </td> <td> <code>28</code> </td> </tr></tbody></table></div><h4>  Catatan </h4><br>  Stasiun diberi nomor dari satu. <br>  Angka-angka di dalam garis dipisahkan oleh satu ruang. <br>  Kebenaran data input tidak perlu diperiksa. </div></div><br><h4>  Solusi </h4><br>  Pertama, ada baiknya beralih dari deskripsi yang indah ke grafik tertimbang yang tidak diarahkan, di mana akan ada puncak di tempat stasiun antar-jemput, kabel akan menjadi pinggiran, dan biaya membangun kabel akan berubah menjadi bobot dari tepi yang sesuai.  Tetapi pertanyaannya tetap - bagaimana memperhitungkan biaya membangun generator uranium di dalam stasiun (puncak) sendiri?  Jawaban atas pertanyaan ini adalah inti dari masalahnya. <br><br>  Misalkan ada simpul lain - sumber energi, dan ujung ditarik dari simpul ini ke masing-masing simpul grafik dengan bobot yang sama dengan biaya membangun generator uranium di stasiun yang sesuai (simpul).  Asumsi ini membawa kita ke grafik terhubung yang perlu diubah menjadi pohon sehingga jumlah bobot tepi di dalamnya ternyata menjadi sekecil mungkin.  Ini tidak lebih dari masalah menemukan pohon spanning minimum dalam grafik.  Anda dapat membangun pohon rentang minimum menggunakan salah satu algoritma yang dikenal - misalnya, Prima atau Kraskal. <br><br><div class="spoiler">  <b class="spoiler_title">Kode sampel dengan komentar</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;tuple&gt; #include &lt;vector&gt; using Price = std::size_t; using Vertex = std::size_t; using Transition = std::tuple&lt;Price, Vertex, Vertex&gt;; using Graph = std::vector&lt;Transition&gt;; //        ( ). class Equals { public: //    . explicit Equals(std::size_t size) { equals_.resize(size); //     . for (std::size_t i = 0; i &lt; size; i++) { equals_[i] = i; } } //   v1  v2   true,    //      . bool Emplace(std::size_t v1, std::size_t v2) { while (v1 != v2) { if (v2 &lt; v1) { std::swap(v1, v2); } auto&amp; next_v2 = equals_[v2]; if (next_v2 == v2) { next_v2 = v1; return true; } v2 = next_v2; } return false; } private: std::vector&lt;size_t&gt; equals_; }; int main() { //   . std::size_t vertex_count = 0; std::cin &gt;&gt; vertex_count; if (vertex_count == 0) { std::cout &lt;&lt; 0 &lt;&lt; std::endl; return 0; } //    —   —   . vertex_count++; //  . Graph graph; graph.reserve(vertex_count); //       . for (Vertex i = 1; i &lt; vertex_count; i++) { Price price = 0; std::cin &gt;&gt; price; graph.emplace_back(price, 0, i); } //    . std::size_t edge_count = 0; std::cin &gt;&gt; edge_count; for (std::size_t i = 0; i &lt; edge_count; i++) { Price price = 0; Vertex from = 0, to = 0; std::cin &gt;&gt; from &gt;&gt; to &gt;&gt; price; graph.emplace_back(price, from, to); } //      . std::sort(graph.begin(), graph.end()); //      . // https://ru.wikipedia.org/wiki/_ Price result = 0; Equals equals{vertex_count}; for (const auto&amp; [price, from, to] : graph) { if (equals.Emplace(from, to)) { result += price; } } //  . std::cout &lt;&lt; result &lt;&lt; std::endl; return 0; }</span></span></span></span></code> </pre> </div></div><br><h2>  Tidak ada parkir </h2>  <sup><i>Penulis: Ilya Mescherin dan Artyom Serebriysky</i></sup> <br><div class="scrollable-table"><table><tbody><tr><td></td><td>  <b>Semua bahasa</b> </td><td>  <b>Python 3.7.3 dan Python 2.7</b> </td></tr><tr><td>  Batas waktu </td><td>  1 s </td><td>  10 s </td></tr><tr><td>  Batas memori </td><td colspan="2">  256 MB </td></tr><tr><td>  Masuk </td><td colspan="2">  input standar atau input.txt </td></tr><tr><td>  Kesimpulan </td><td colspan="2">  output standar atau output.txt </td></tr></tbody></table></div>  Di satu kota, mobil dilarang berhenti, kecuali menaiki penumpang.  Dan penumpang tidak setuju untuk menunggu lebih dari 3 menit.  Di kota ini, seorang pejalan kaki memesan taksi ke titik X dan menunjukkan selang waktu 180 detik.  Pengemudi harus tiba tepat pada interval ini.  Jika Anda tiba lebih awal, Anda tidak akan dapat mengharapkan penumpang.  Jika Anda datang terlambat, penumpang yang marah akan membatalkan pesanan. <br><br>  Karena pembatasan tersebut, hanya driver Z yang tersisa di kota ini, yang masing-masing di awal tugas berada di bagian atas grafik lalu lintas.  Sistem kontrol harus menunjuk driver terbaik dari mereka yang berhasil tiba pada interval yang ditentukan.  Pengemudi terbaik adalah orang yang datang untuk memesan sedekat mungkin dengan awal interval.  Jika ada beberapa driver seperti itu, maka salah satunya. <br><br>  Penting bagi setiap pengemudi untuk menentukan apakah ia memiliki waktu untuk tiba pada interval yang ditunjukkan, dan jika demikian, pada titik waktu paling awal pada interval yang ditunjukkan, ia dapat tiba. <br><br>  <b>Deskripsi formal</b> <br><br>  Diberikan: <br><br><ol><li>  Grafik berorientasi G dengan simpul N dan tepi K, simpul diberi nomor dari 0 hingga N - 1, 0 ≤ N ≤ 10 <sup>4</sup> , 0 ≤ K ≤ 10 <sup>4</sup> .  Setiap tepi sesuai dengan waktu tempuh di dalamnya - bilangan bulat W, 10 ≤ W ≤ 10 <sup>4</sup> . </li><li>  Memesan posisi pada kolom <sub>target</sub> ID. </li><li>  Posisi Z driver dalam kolom IDsource <sub>2</sub> , 1 ≤ Z ≤ 10 <sup>4</sup> . </li><li>  Waktu t <sub>0</sub> , 0 ≤ t <sub>0</sub> ≤ 600 adalah bilangan bulat. </li></ol><br>  Sangat penting bagi setiap pengemudi untuk menemukan sedemikian rupa sehingga: <br><br><ol><li>  ada rute dari driver IDsource <sub>z</sub> ke ID <sub>target</sub> sehingga pengemudi tiba pada t <sub>min</sub> , </li><li>  t <sub>min</sub> ∈ [t <sub>0</sub> ;  t <sub>0</sub> + 180], </li><li>  dan ini adalah t <sub>min</sub> awal yang mungkin: t <sub>min</sub> ≤ t <sub>i</sub> untuk setiap t <sub>i</sub> poin memuaskan 1 dan 2 </li><li>  atau pastikan t <sub>min</sub> seperti itu tidak ada. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Format, Contoh, dan Catatan I / O</b> <div class="spoiler_text"><h4>  Format input </h4><br>  Grafik diatur dalam bentuk tiga kali lipat triples-top-end-end-time-triples. <br><br>  Input data, setiap item pada barisnya sendiri: <br><br>  1. K adalah jumlah tepi. <br>  2. K tiga kali lipat ID ID Weight - titik awal dari tulang rusuk, titik akhir dari tulang rusuk, seberapa banyak mobil menggerakkan tulang rusuk. <br>  3. <sub>Target</sub> ID t <sub>0</sub> - di atas urutan [spasi] awal rentang ketika Anda harus tiba. <br>  4. Z - jumlah driver. <br>  5. (Z kali) ID <sub>z adalah bagian</sub> atas driver berikutnya. <br><br><h4>  Format output </h4><br>  Untuk setiap driver, dengan urutan yang sama seperti yang mereka masukkan, cetak pada baris terpisah t <sub>min yang</sub> dihitung atau –1 jika t <sub>min</sub> tersebut tidak ada. <br><br><h4>  Contoh 1 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Masuk</b> </td><td>  <b>Kesimpulan</b> </td></tr><tr><td> <code>2 <br> 0 1 10 <br> 2 3 10 <br> 3 0 <br> 1 <br> 0</code> </td> <td> <code>-1</code> </td> </tr></tbody></table></div><h4>  Contoh 2 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Masuk</b> </td><td>  <b>Kesimpulan</b> </td></tr><tr><td> <code>2 <br> 0 1 10 <br> 2 3 10 <br> 1 0 <br> 1 <br> 0</code> </td> <td> <code>10</code> </td> </tr></tbody></table></div><h4>  Contoh 3 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Masuk</b> </td><td>  <b>Kesimpulan</b> </td></tr><tr><td> <code>1 <br> 0 1 10 <br> 1 100 <br> 1 <br> 0</code> </td> <td> <code>-1</code> </td> </tr></tbody></table></div><h4>  Catatan </h4><br>  1. Beberapa tepi dapat berubah dari titik A ke titik B, termasuk yang memiliki bobot yang sama. <br>  2. Iga dari A ke A diperbolehkan. <br>  3. Keberadaan tepi (A-&gt; B) dan (B-&gt; A) pada saat yang sama (siklus panjang 2) diperbolehkan. </div></div><br><h4>  Solusi </h4><br>  <b>Pengemudi tunggal</b> <br><br>  Pertama, kami akan menganalisis kasus sederhana dengan satu driver.  Ukuran tulang rusuk adalah waktu [bepergian di atasnya], batasan finish dinyatakan dalam unit yang sama, sehingga kita dapat merumuskan kembali masalah: “Pengemudi bergerak dari titik A ke titik B sesuai dengan grafik.  Temukan jalur minimum sedemikian sehingga panjangnya terletak di segmen [T, U]. " <br><br>  Cara termudah untuk melakukan ini adalah menjalankan dijkstra yang dimodifikasi dari A ke B: <br><br><ol><li>  Modifikasi 1. Misalkan kita mendapat bagian atas dari minQ dan sudah ditandai hitam (yaitu, jarak minimum untuk itu telah ditemukan).  Maka kita tidak mengabaikannya, tetapi memprosesnya dengan cara standar - letakkan semua simpul yang berdekatan dengan jarak baru kembali ke minQ. </li><li>  Kami berhenti hanya ketika jarak ke minQ saat ini secara ketat lebih besar dari U. </li><li>  Misalkan kita menemukan puncak B selama lintasan traversal, maka jika jarak saat ini ≥ T, ingatlah itu sebagai jawaban R. Pada titik ini, dijkstra juga dapat terganggu. </li></ol><br>  Jadi, jika kita memiliki R, ini adalah jalur minimum dengan panjang dalam interval yang diperlukan. <br><br>  <b>Banyak pengemudi</b> <br><br>  Solusi untuk dahi adalah menjalankan algoritma untuk setiap driver.  Tetapi solusi seperti itu tidak berlalu dengan membatasi waktu.  Kita harus belajar memberikan jawaban untuk setiap driver untuk O (1). <br><br>  Untuk melakukan ini, kami memodifikasi algoritma untuk satu driver: <br><br><ol><li>  Alih-alih dijkstra dari pengemudi ke titik pesanan, kami memulai dijkstra dari titik pesanan sesuai dengan grafik dengan Tepi terbalik (!). </li><li>  Kami mengambil keuntungan dari kenyataan bahwa jumlah simpul juga dibatasi hingga sepuluh ribu.  Mari kita mendapatkan array jawaban R - untuk setiap titik ini adalah waktu minimum dalam rentang [T, U] ketika dapat dicapai dari A. </li><li>  Dalam proses melintasi grafik dari dijkstroy yang dimodifikasi, ketika kita memenuhi titik j dan jika jarak saat ini ke dalam interval yang diinginkan [T, U], kita masukkan R: R <sub>j</sub> = min (R <sub>j</sub> , dist). </li></ol><br>  Kemudian, untuk setiap driver di vertex J, seseorang dapat meminta R <sub>j untuk</sub> mengetahui apakah ada jalur yang memenuhi kondisi dan berapa panjangnya. <br><br>  <b>Optimasi minQ</b> <br><br>  Panjang jalur selalu bilangan bulat dan terbatas pada 781 dari atas - untuk pesanan yang dilakukan pada t <sub>0</sub> = 600, detik terakhir yang sah dari kedatangan pengemudi adalah 780. Dalam hal ini, untuk mengimplementasikan dijkstra, Anda perlu menggunakan implementasi minQ berikut. <br><br>  Kami memiliki array Fringe dengan ukuran [781].  Di setiap elemen Fringe <sub>i</sub> ada unordered_set yang menyimpan id dari semua simpul yang ada lintasan panjang i. <br><br>  1. Tambahkan simpul dengan jarak D: <br><br><pre> <code class="cpp hljs">fringe[D].insert(vertex);</code> </pre> <br>  2. Menurut kondisi, berat minimum tepi adalah&gt; 0. Oleh karena itu, alih-alih mengambil elemen dari minQ satu per satu, Anda dapat melewati seluruh irisan: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; fringe.size(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(fringe[i].empty()) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; vertex : fringe[i]) { <span class="hljs-comment"><span class="hljs-comment">// Do some stuff ProcessVertex(vertex, i); } }</span></span></code> </pre> <br><h2>  Kalkulator biaya perjalanan </h2>  <sup><i>Penulis: Nikolay Filchenko</i></sup> <br><div class="scrollable-table"><table><tbody><tr><td></td><td>  <b>Semua bahasa</b> </td><td>  <b>Python 3.7.3 dan Python 2.7</b> </td></tr><tr><td>  Batas waktu </td><td>  3 s </td><td>  65 c </td></tr><tr><td>  Batas memori </td><td>  64 MB </td><td>  256 MB </td></tr><tr><td>  Masuk </td><td colspan="2">  input standar atau input.txt </td></tr><tr><td>  Kesimpulan </td><td colspan="2">  output standar atau output.txt </td></tr></tbody></table></div>  Perlu untuk menghitung biaya perjalanan sesuai dengan formula yang diberikan.  Setiap perjalanan ditandai dengan parameter integer K.  Formula diberikan dalam notasi Polandia terbalik. <br><br>  Operasi yang diizinkan: <br><br><ul><li>  <b>+ -</b> - penjumlahan dan pengurangan; </li><li>  <b>* /</b> - divisi perkalian dan integer; </li><li>  <b>&lt;=</b> - perbandingan; </li><li>  <b>?</b>  - operator bersyarat.  Jika argumen pertama benar - mengembalikan argumen kedua, sebaliknya - argumen ketiga. </li></ul><br>  Variabel [az] dan bilangan bulat dari -10 <sup>9</sup> hingga 10 <sup>9</sup> juga digunakan dalam rumus. <br><br>  Kita dapat mengasumsikan bahwa hasil semua operasi dalam rumus tidak melebihi 10 <sup>9</sup> dalam nilai absolut.  Hasil operasi perbandingan hanya digunakan sebagai argumen kepada operator kondisional. <br><br><div class="spoiler">  <b class="spoiler_title">Format dan Contoh I / O</b> <div class="spoiler_text"><h4>  Format input </h4><br>  Pada baris pertama, satu angka 1 ≤ K ≤ 26 - jumlah variabel. <br><br>  Baris kedua berisi rumus untuk menghitung harga (tidak lebih dari 3-10 <sup>4</sup> elemen).  Semua elemen dipisahkan oleh spasi. <br><br>  Pada baris ketiga, 1 ≤ N ≤ 10 <sup>4</sup> adalah jumlah tes. <br><br>  Baris N berikutnya berisi bilangan bulat K masing-masing (–10 <sup>9</sup> ≤ v ≤ 10 <sup>9</sup> ) - nilai-nilai variabel dalam urutan abjad. <br><br><h4>  Format output </h4><br>  N baris yang mengandung satu bilangan bulat - hasil penggantian setiap set nilai.  Dijamin bahwa hasil dari ekspresi terbatas dan ditentukan <br><br><h4>  Contoh 1 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Masuk</b> </td><td>  <b>Kesimpulan</b> </td></tr><tr><td> <code>1 <br> a 2 2 + * <br> 2 <br> 2 <br> 3</code> </td> <td> <code>8 <br> 12</code> </td> </tr></tbody></table></div><h4>  Contoh 2 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Masuk</b> </td><td>  <b>Kesimpulan</b> </td></tr><tr><td> <code>2 <br> ab &lt; 5 14 ? <br> 2 <br> 10 5 <br> 5 10</code> </td> <td> <code>14 <br> 5</code> </td> </tr></tbody></table></div></div></div><br><h4>  Solusi </h4><br>  Ini adalah tugas untuk implementasi dan perhatian yang cermat.  Ada dua poin utama dalam solusi: <br><br><ol><li>  Ekspresi asli itu sendiri harus diubah menjadi array angka dan operasi agar tidak mem-parsing string ke dalam setiap set variabel. </li><li>  Harus diingat bahwa pembagian bilangan bulat dengan nol mengarah ke SIGFPE, jadi dalam operasi pembagian itu perlu dicek secara eksplisit bahwa penyebutnya bukan nol.  Berdasarkan jaminan kehalusan dan kepastian hasil dari seluruh ekspresi, kita dapat memahami: hasil divisi tersebut tidak terlibat dalam hasil akhir dan berada di cabang yang tidak digunakan dari operator bersyarat, sehingga Anda dapat menerimanya dengan (misalnya, nol). </li></ol><br><hr><br>  Habraposty pada topik: <br><br><ul><li>  <a href="https://habr.com/ru/company/yandex/blog/457262/">Analisis trek backend dari kejuaraan pertama</a> </li><li>  Membahas jejak kejuaraan kedua: <a href="https://habr.com/ru/company/yandex/blog/477452">ML</a> , <a href="https://habr.com/ru/company/yandex/blog/478550/">front-end</a> , <a href="https://habr.com/ru/company/yandex/blog/482210/">pengembangan ponsel</a> </li><li>  <a href="https://habr.com/ru/company/yandex/blog/464179/">Satu standup di Yandex.Taxi</a> , atau Apa yang Anda butuhkan untuk mengajar pengembang backend </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id483624/">https://habr.com/ru/post/id483624/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id483608/index.html">Visualisasi batas-batas solusi classifier berbasis gambar</a></li>
<li><a href="../id483610/index.html">Apakah otomat merupakan suatu peristiwa?</a></li>
<li><a href="../id483612/index.html">Pengemudi Tesla didenda karena menyikat giginya saat mengemudi dengan autopilot</a></li>
<li><a href="../id483614/index.html">Metode memerangi pencurian di klub robotika</a></li>
<li><a href="../id483616/index.html">Proyek Lacmus: Bagaimana Visi Komputer Membantu Menyelamatkan Orang yang Hilang</a></li>
<li><a href="../id483626/index.html">Cara menggambarkan pekerjaan 100 gitlab dalam 100 baris di Jsonnet</a></li>
<li><a href="../id483628/index.html">Pembuatan kode dari OpenAPI v3 (alias Swagger 3) ke TypeScript dan tidak hanya</a></li>
<li><a href="../id483630/index.html">The Ember Times - Edisi 130</a></li>
<li><a href="../id483634/index.html">Min dan Max lebar / properti tinggi di CSS</a></li>
<li><a href="../id483646/index.html">Retas Kotak - Panduan Bitlab. Lemahnya kebingungan JS, GIT dan membalikkan aplikasi Windows</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>