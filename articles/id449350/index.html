<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚱 👨‍👦‍👦 ⛱️ Keybase dan TOFU sejati 🧠 😟 💬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada messenger dengan enkripsi ujung ke ujung (E2E), pengguna bertanggung jawab atas kunci mereka. Ketika dia kehilangan mereka, dia terpaksa mengatur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Keybase dan TOFU sejati</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449350/">  Pada messenger dengan enkripsi ujung ke ujung (E2E), pengguna bertanggung jawab atas kunci mereka.  Ketika dia kehilangan mereka, dia terpaksa mengatur ulang akunnya. <br><br>  Menyetel ulang akun berbahaya.  Anda menghapus kunci publik dan dalam semua percakapan menjadi orang asing kriptografis.  Anda perlu mengembalikan identitas Anda, dan dalam hampir semua kasus ini berarti pertemuan pribadi dan perbandingan "nomor keamanan" dengan masing-masing kontak.  Seberapa sering Anda benar-benar menjalani tes seperti itu, yang merupakan satu-satunya perlindungan dari MiTM? <br><br>  Bahkan jika Anda serius dengan nomor keamanan, Anda hanya melihat banyak mitra obrolan setahun sekali di sebuah konferensi, jadi Anda mandek. <br><a name="habracut"></a><br>
<h1>  Tetapi ini jarang terjadi, bukan? </h1><br>  Seberapa sering reset terjadi?  Jawab: di sebagian besar aplikasi obrolan E2E sepanjang waktu. <br><br>  Dalam messenger ini, Anda menjatuhkan kriptografi dan mulai mempercayai server: (1) setiap kali Anda beralih ke telepon baru;  (2) setiap kali lawan bicara beralih ke telepon baru;  (3) ketika mengatur ulang ke pengaturan pabrik telepon;  (4) ketika lawan bicara melakukan reset ke pengaturan pabrik;  (5) setiap kali Anda menghapus dan menginstal ulang aplikasi, atau (6) ketika seseorang yang Anda ajak bicara hapus instalan dan instal ulang aplikasi itu.  Jika Anda memiliki puluhan kontak, reset akan dilakukan setiap beberapa hari. <br><br>  Reset terjadi secara teratur sehingga aplikasi ini berpura-pura bahwa ini bukan masalah: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dbe/046/a7f/dbe046a7fde23783eff076ae8a59084a.png"></div><br>  <i>Sepertinya kami memiliki peningkatan keamanan!</i>  <i>(Tapi tidak juga)</i> <br><br><h1>  Apakah ini benar-benar TOFU? </h1><br>  Dalam kriptografi, istilah TOFU ("kepercayaan pada penggunaan pertama") menggambarkan permainan kesempatan ketika dua pihak berbicara untuk pertama kalinya.  Alih-alih bertemu secara langsung, mediator bertanggung jawab untuk masing-masing pihak ... dan kemudian, setelah para pihak mempresentasikan diri mereka, masing-masing pihak dengan hati-hati memonitor kunci untuk memastikan tidak ada yang berubah.  Jika kunci telah berubah, masing-masing pihak memberikan alarm. <br><br>  Jika kunci dari host jarak jauh berubah dalam SSH dalam situasi seperti itu, itu tidak akan "hanya bekerja", tetapi menjadi benar-benar berperang: <br><br><blockquote><code>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ <br> @ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @ <br> @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ <br> <br> IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY! <br> Someone could be eavesdropping on you right now (man-in-the-middle attack)! <br> It is also possible that a host key has just been changed. <br> The fingerprint for the RSA key sent by the remote host is <br> 00:11:22:33:44:55:66:77:88:99:aa:bb:cc:dd:ee:ff <br> Please contact your system administrator. <br> Add correct host key in /Users/rmueller/.ssh/known_hosts to get rid of this message. <br> Offending RSA key in /Users/rmueller/.ssh/known_hosts:12 <br> RSA host key for 8.8.8.8 has changed and you have requested strict checking. <br> Host key verification failed.</code> </blockquote> <br>  Inilah perilaku yang benar.  Dan ingat: <b>ini bukan TOFU jika memungkinkan Anda untuk bekerja lebih jauh dengan peringatan kecil.</b>  <b>Anda akan melihat tengkorak raksasa dengan tulang bersilang</b> . <br><br>  Tentu saja, pengirim pesan instan ini akan mengklaim bahwa semuanya baik-baik saja, karena pengguna diperingatkan.  Jika dia mau, dia <i>bisa</i> memeriksa nomor keamanannya.  Itu sebabnya kami tidak setuju: <br><br><ol><li>  Verifikasi tidak dilakukan karena terlalu sering terjadi. <br></li><li>  Periksa payah. <br></li><li>  Bahkan survei sepintas tentang teman-teman kita yang peduli tentang keamanan menunjukkan bahwa tidak ada yang khawatir dengan tes ini. <br></li><li>  Jadi itu hanya mempercayai server dan mempercayai SMS (well, well!) <b>Lagi, lagi dan lagi</b> . <br></li><li>  Akhirnya, aplikasi ini seharusnya tidak berfungsi seperti ini.  Apalagi saat berganti perangkat.  Kasus normal yang biasa dapat ditangani dengan lancar dan aman, dan semakin jarang situasinya, semakin buruk tampilannya.  Sebentar lagi, tunjukkan solusi Keybase. </li></ol><br><h1>  Berhenti menyebutnya TOFU </h1><br>  Ada serangan yang sangat efektif.  Misalkan Hawa ingin masuk ke percakapan Alice dan Bob yang ada dan berdiri di antara mereka.  Alice dan Bob telah berhubungan selama bertahun-tahun, telah lama berlalu di TOFU. <br><br>  Eve hanya membuat Alice berpikir bahwa Bob membeli telepon baru: <br><br><blockquote>  <b>Bob (Eve):</b> Hei, hei! <br><br>  <b>Alice:</b> Yo, Bob!  Sepertinya Anda memiliki nomor keamanan baru. <br><br>  <b>Bob (Eve):</b> Ya, saya membeli iPhone XS, telepon yang bagus, sangat senang dengannya.  Mari bertukar nomor keamanan di RWC 2020. Hei, apakah Anda memiliki alamat Caroline Anda saat ini?  Saya ingin mengejutkannya saat saya di San Francisco. <br><br>  <b>Alice: Saya</b> tidak bisa membandingkan, Android 4 hidup!  Ya, Cozy Street 555. </blockquote><br>  Oleh karena itu, sebagian besar kurir terenkripsi tidak mungkin mendapatkan kepatuhan TOFU.  Ini lebih seperti TADA - kepercayaan setelah menambahkan perangkat.  Ini adalah masalah nyata, bukan fiktif, karena ini menciptakan peluang untuk implementasi jahat dalam percakapan yang sudah ada sebelumnya.  Dalam TOFU nyata, pada saat seseorang tertarik pada percakapan Anda, mereka tidak akan dapat menyusup ke dalamnya.  Dengan TADA, ini dimungkinkan. <br><br>  Dalam obrolan kelompok, situasinya bahkan lebih buruk.  Semakin banyak orang dalam obrolan, semakin sering akun akan diinstal ulang.  Di perusahaan yang hanya terdiri dari 20 orang, ini akan terjadi kira-kira setiap dua minggu, menurut perkiraan kami.  Dan setiap orang di perusahaan harus bertemu orang ini.  Secara pribadi  Kalau tidak, seluruh obrolan dikompromikan oleh satu mol atau hacker. <br><br><h1>  Solusi </h1><br>  Apakah ada solusi yang baik yang tidak menyiratkan kepercayaan pada server kunci pribadi?  Kami pikir ada: dukungan nyata untuk beberapa perangkat.  Ini berarti bahwa Anda mengelola rantai perangkat yang mewakili identitas Anda.  Saat Anda menerima perangkat baru (telepon, laptop, komputer desktop, iPad, dll.), Ia menghasilkan pasangan kunci sendiri, dan perangkat Anda sebelumnya menandatanganinya.  Jika Anda kehilangan perangkat, maka "hapus" dari salah satu yang tersisa.  Secara teknis, penghapusan seperti itu adalah penarikan kembali, dan dalam hal ini ada juga semacam pembalikan kunci yang terjadi secara otomatis. <br><br>  Akibatnya, <b>Anda tidak perlu mempercayai server atau bertemu langsung ketika teman bicara atau kolega menerima perangkat baru</b> .  Demikian pula, Anda tidak perlu mempercayai server atau bertemu langsung ketika menghapus perangkat, jika itu bukan yang terakhir.  Satu-satunya waktu Anda perlu melihat peringatan adalah ketika seseorang benar-benar kehilangan akses ke semua pengaturannya.  Dan dalam hal ini, Anda akan melihat peringatan serius, sebagaimana mestinya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b52/c11/c30/b52c11c30705695088a044658f3fb608.png"></div><br>  <i><font color="gray">Khususnya jelek maksimal</font></i> <br><br>  Akibatnya, lebih sedikit akun yang direset dan diinstal ulang.  Secara historis, di Keybase, jumlah total add-on dan ulasan perangkat adalah <b>sepuluh kali</b> jumlah debit akun (Anda tidak perlu mengambil kata kami untuk itu, ini tersedia untuk umum di pohon Merkle kami).  Tidak seperti messenger lain, kami dapat menunjukkan peringatan yang benar-benar menakutkan ketika Anda berbicara dengan seseorang yang baru saja menginstal ulang kunci. <br><br>  Manajemen perangkat adalah operasi rekayasa yang kompleks yang telah kami sempurnakan beberapa kali.  Perangkat yang ada menandatangani kunci publik perangkat baru dan mengenkripsi semua data rahasia penting untuk kunci publik perangkat baru.  Operasi ini harus dilakukan dengan cepat (dalam satu detik), karena kita berbicara tentang jangkauan perhatian pengguna.  Akibatnya, Keybase menggunakan hierarki kunci, sehingga saat mentransfer 32 byte data rahasia dari perangkat lama, perangkat baru dapat melihat semua data kriptografi yang berumur panjang (lihat FAQ di bawah untuk lebih jelasnya).  Ini mungkin tampak sedikit mengejutkan, tetapi <i>itulah titik kriptografi</i> .  Itu tidak memecahkan masalah manajemen rahasia Anda, itu hanya membuat sistem lebih terukur. <br><br><h1>  Gambaran lengkap keamanan </h1><br>  Sekarang kita dapat merumuskan empat sifat keamanan dasar untuk aplikasi Keybase: <br><br><ol><li>  kunci rahasia yang tahan lama tidak pernah meninggalkan perangkat yang membuatnya <br></li><li>  dukungan multi-perangkat penuh meminimalkan penurunan akun <br></li><li>  pencabutan kunci tidak dapat ditunda atau dibatalkan dengan jahat <br></li><li>  kerahasiaan langsung menggunakan pesan waktu singkat </li></ol><br>  Dua yang pertama tampaknya bisa dimengerti.  Yang ketiga menjadi penting dalam desain di mana penarikan perangkat diharapkan dan dianggap normal.  Sistem harus memeriksa apakah server jahat tidak dapat menunda ulasan perangkat, yang kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tulis sebelumnya</a> . <br><br>  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tentang pesan singkat untuk</a> informasi lebih lanjut tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fitur</a> keamanan keempat. <br><br><h1>  Banyak kriptografi baru, apakah semuanya dilaksanakan dengan benar? </h1><br>  Keybase tidak pernah mengimplementasikan fungsi keamanan dasar sebelumnya dan bahkan tidak pernah menggambarkannya dalam artikel ilmiah.  Kami harus membuat sendiri beberapa <i>protokol</i> kriptografi.  Untungnya, ada banyak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>algoritma</i> kriptografi yang tidak</a> resmi, standar, dan banyak digunakan untuk situasi apa pun.  Semua kode klien kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terbuka</a> .  Secara teoritis, siapa pun dapat menemukan kesalahan desain atau implementasi.  Tapi kami ingin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menunjukkan struktur internal</a> dan menyewa firma audit keamanan terbaik untuk analisis penuh. <br><br>  Hari ini kami menyajikan laporan NCC Group dan sangat didorong oleh hasilnya.  Keybase menghabiskan lebih dari $ 100.000 untuk mengaudit, dan NCC Group mempekerjakan pakar keamanan dan kriptografi tingkat atas.  Mereka menemukan dua kesalahan penting dalam implementasi kami, dan kami segera memperbaikinya.  Bug ini hanya dapat muncul jika server kami bertindak jahat.  Kami dapat memastikan bahwa mereka tidak akan bertindak seperti itu, tetapi Anda tidak memiliki alasan untuk mempercayai kami.  <i>Itu masalahnya!</i> <br><br>  Kami percaya tim NCC telah melakukan pekerjaan dengan sangat baik.  Hormati waktu yang mereka habiskan untuk sepenuhnya memahami arsitektur dan implementasi kami.  Mereka menemukan kesalahan halus yang menarik perhatian pengembang kami, meskipun kami baru-baru ini menonton bagian basis kode ini berulang kali.  Kami menyarankan Anda melihat laporan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , atau buka FAQ kami. <br><br><h1>  Faq </h1><br><h3>  Beraninya kamu menyerang produk XYZ? </h3><br>  Kami telah menghapus referensi ke produk tertentu dari artikel. <br><br><h3>  Apa lagi </h3><br>  Kami bangga bahwa Keybase tidak memerlukan nomor telepon dan secara kriptografi dapat memeriksa Twitter, HackerNews, Reddit, dan pengidentifikasi Github jika Anda mengenal seseorang. <br><br>  Dan ... segera ... akan ada dukungan untuk Mastodon. <br><br><h3>  Bagaimana dengan serangan pengalihan ponsel? </h3><br>  Banyak aplikasi yang rentan terhadap serangan pengalihan.  Eve berjalan ke kios di pusat perbelanjaan dan meyakinkan Bob, operator seluler, untuk meneruskan nomor telepon Bob ke perangkatnya.  Atau dia meyakinkan perwakilan melalui telepon.  Sekarang, Hawa dapat mengotentikasi pada server messenger, mengklaim bahwa dia adalah Bob.  Hasilnya terlihat seperti contoh kami Alice, Bob dan Hawa lebih tinggi, tetapi Hawa tidak perlu menembus server apa pun.  Beberapa aplikasi menawarkan "pemblokiran registrasi" untuk melindungi dari serangan ini, tetapi secara default mereka mengganggu. <br><br><h3>  Saya mendengar Keybase mengirim beberapa kunci pribadi ke server? </h3><br>  Pada hari-hari awal (2014 dan awal 2015), Keybase bekerja sebagai aplikasi web PGP, dan pengguna dapat memilih fungsi untuk menyimpan kunci PGP pribadi mereka di server kami, dienkripsi dengan frasa sandi (yang tidak diketahui Keybase). <br><br>  Pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bulan September 2015,</a> kami memperkenalkan model Keybase baru.  Kunci PGP tidak pernah digunakan (dan tidak pernah digunakan) dalam obrolan Keybase atau sistem file. <br><br><h3>  Bagaimana obrolan lama langsung muncul di ponsel baru? </h3><br>  Di beberapa aplikasi lain, perangkat baru tidak melihat pesan lama, karena menyinkronkan pesan lama melalui server bertentangan dengan kerahasiaan langsung.  Aplikasi Keybase memungkinkan Anda untuk menunjuk pesan tertentu - atau seluruh percakapan - sebagai “sesaat”.  Mereka dihancurkan setelah waktu tertentu dan dienkripsi dua kali: sekali menggunakan kunci enkripsi obrolan yang berumur panjang, dan yang lainnya menggunakan kunci sesaat yang sering berubah.  Dengan demikian, pesan singkat memberikan kerahasiaan langsung dan tidak dapat disinkronkan antara telepon. <br><br>  Pesan non-tetap tetap sampai pengguna secara eksplisit menghapusnya dan menyinkronkan E2E dengan perangkat gaya Slack baru, hanya dengan enkripsi!  Karenanya, saat Anda menambahkan seseorang ke tim atau menambahkan perangkat baru untuk Anda sendiri, pesan tidak terblokir. <br><br>  Lebih lanjut tentang sinkronisasi di paragraf berikutnya. <br><br><h3>  Ceritakan tentang PUK! </h3><br>  Dua tahun lalu, kami memperkenalkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kunci untuk pengguna (PUK)</a> .  Setengah publik dari PUK diiklankan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sigchain</a> publik pengguna.  Setengah rahasia dienkripsi untuk kunci publik setiap perangkat.  Ketika Alice sedang mempersiapkan perangkat baru, perangkat lamanya tahu setengah rahasia dari PUK-nya dan kunci publik dari perangkat baru.  Ini mengenkripsi setengah rahasia PUK untuk kunci publik dari perangkat baru, dan perangkat baru mengunduh ciphertext ini melalui server.  Perangkat baru mendekripsi PUK dan dapat langsung mengakses semua pesan obrolan yang berumur panjang. <br><br>  Setiap kali Alice mengingat suatu perangkat, ia mengganti PUK-nya, sehingga semua perangkatnya, kecuali yang terakhir dipanggil, menerima PUK baru. <br><br>  Skema sinkronisasi ini secara fundamental berbeda dari sistem PGP Keybase awal.  Di sini, semua kunci yang terlibat memiliki 32 byte entropi sejati, mereka tidak putus dengan kekerasan jika terjadi peretasan server.  Benar, jika <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Curve25519</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PRNG</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari Go</a> rusak, maka semuanya rusak.  Tetapi sinkronisasi PUK tidak membuat asumsi kriptografi signifikan lainnya. <br><br><h3>  Bagaimana dengan obrolan grup besar? </h3><br>  <b>tL;</b> Grup <b>dr</b> memiliki rantai tanda tangan diaudit sendiri untuk mengubah peran, menambah dan menghapus anggota. <br><br>  Peneliti keamanan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menulis</a> tentang serangan pengguna hantu pada obrolan grup.  Jika klien pengguna tidak dapat secara kriptografis memverifikasi keanggotaan grup, maka server jahat dapat menanamkan spyware dan mol di obrolan grup.  Keybase memiliki sistem yang sangat andal dalam bentuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi khusus kelompok</a> , yang akan kami tulis di masa depan. <br><br><h3>  Bisakah Anda bicara tentang NCC-KB2018-001? </h3><br>  Kami percaya bahwa bug ini adalah temuan paling signifikan dari audit NCC.  Keybase secara aktif menggunakan struktur data yang tidak dapat diubah untuk melindungi dari ambiguitas server dari penambahan saja.  Dalam kasus bug, server yang jujur ​​mungkin mulai menghindar: "Sudah saya katakan sebelumnya, tetapi bug terjadi, maksud saya B".  Tetapi klien kami memiliki kebijakan umum untuk tidak memberikan fleksibilitas seperti itu kepada server: mereka memiliki <a href="">pengecualian hard-kode</a> jika ada bug. <br><br>  Baru-baru ini, kami juga memperkenalkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sigchain V2</a> : sistem ini memecahkan masalah skalabilitas yang kami tidak memprediksi dengan benar di versi pertama.  Sekarang klien lebih ekonomis dengan data kriptografi yang mereka tarik dari server, hanya menerima satu tanda tangan dari ujung rantai tanda tangan, daripada tanda tangan dari setiap tautan perantara.  Dengan demikian, pelanggan telah kehilangan kesempatan untuk pergi dalam siklus mencari hash tanda tangan tertentu, tetapi kami sebelumnya menggunakan hash ini untuk mencari tautan rantai buruk dalam daftar pengecualian kode-keras ini.  Kami sedang mempersiapkan untuk rilis Sigchain V2, melupakan detail ini terkubur di bawah beberapa lapisan abstraksi, sehingga sistem hanya mempercayai bidang dari respons server. <br><br>  Setelah NCC menemukan kesalahan ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perbaikannya</a> cukup sederhana: mencari pengecualian hard-coded dengan hash chainlink daripada hash signature chainlink.  Klien selalu dapat secara langsung menghitung hash ini. <br><br>  Kami juga dapat mengaitkan kesalahan ini dengan kompleksitas tambahan yang diperlukan untuk mendukung Sigchain V1 dan Sigchain V2 secara bersamaan.  Klien modern menulis tautan Sigchain V2, tetapi semua klien harus mendukung tautan lawas v1 untuk waktu yang tidak terbatas.  Ingat bahwa pelanggan menandatangani tautan dengan kunci pribadi mereka untuk setiap perangkat.  Kami tidak dapat mengoordinasikan semua pelanggan menimpa data historis dalam waktu yang wajar, karena klien ini dapat offline. <br><br><h3>  Bisakah Anda bicara tentang NCC-KB2018-004? </h3><br>  Seperti pada 001 (lihat di atas), kami dikecewakan oleh kombinasi tertentu dari dukungan simultan untuk solusi usang dan optimisasi, yang tampaknya penting karena kami memperoleh lebih banyak pengalaman bekerja dengan sistem. <br><br>  Di Sigchain V2, kami mengurangi ukuran rantai dalam byte untuk mengurangi bandwidth yang dibutuhkan untuk mencari pengguna.  Penghematan ini sangat penting pada ponsel.  Dengan demikian, kami menyandikan tautan rantai dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MessagePack</a> , bukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JSON</a> , yang memberikan penghematan yang baik.  Pada gilirannya, pelanggan menandatangani dan memverifikasi tanda tangan pada rantai ini.  Para peneliti di NCC telah menemukan cara rumit untuk membuat "tanda tangan" yang terlihat seperti JSON dan MessagePack pada saat yang sama, yang mengarah ke konflik.  Kami tanpa sadar memperkenalkan ambiguitas penguraian kode ini selama optimisasi ketika kami mengganti parser JSON dari parser Go standar ke parser yang lebih efisien.  Parser cepat ini dengan diam-diam melewatkan sekelompok sampah sebelum menemukan JSON yang sebenarnya, yang termasuk fitur serangan polyglot ini.  Kesalahan diperbaiki dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">verifikasi input tambahan</a> . <br><br>  Di Sigchain V2, kami juga menerima saran <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Adam Langley</a> bahwa penandatangan mendahului paket mereka dengan tanda tangan oleh awalan garis konteks dan byte <code>\0</code> sehingga verifier tidak menjadi bingung dengan niat penandatangan.  Di sisi verifikasi ide awalan konteks ini, ada kesalahan yang dapat menyebabkan serangan polyglot lainnya.  Kami dengan cepat memperbaiki kekurangan ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dengan daftar putih</a> . <br><br>  Setelah memperbaiki kedua bug, server menolak beban berbahaya serangan polyglot, sehingga eksploitasi kerentanan ini hanya mungkin dilakukan dengan bantuan server yang dikompromikan. <br><br><h3>  Di mana dokumentasinya? </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://keybase.io/docs</a> <br><br>  Dalam beberapa bulan mendatang, kami akan mencurahkan lebih banyak waktu untuk mengerjakan dokumentasi. <br><br><h3>  Anda dapat mengetahui lebih lanjut tentang pernyataan ini oleh NCC: "Namun, seorang penyerang dapat menolak untuk memperbarui sigchain atau memutar kembali sigchain pengguna ke keadaan sebelumnya dengan memotong tautan selanjutnya dalam rantai" </h3><br>  Keybase menggunakan banyak-banyak struktur data publik yang tidak dapat diubah, append yang memaksa infrastruktur server untuk menangkap satu representasi sebenarnya dari pengidentifikasi pengguna.  Kami dapat menjamin penarikan perangkat dan penghapusan anggota grup sedemikian rupa sehingga server yang dikompromikan tidak dapat memutar kembali.  Jika server memutuskan untuk menampilkan tampilan yang tidak konsisten, penyimpangan ini menjadi bagian dari catatan publik yang tidak dapat diubah.  Pelanggan keybase atau auditor pihak ketiga dapat mendeteksi ketidakcocokan setiap saat setelah serangan.  Kami percaya bahwa jaminan ini jauh melampaui jaminan produk yang bersaing dan hampir optimal, dengan mempertimbangkan keterbatasan praktis ponsel dan pelanggan dengan daya komputasi yang terbatas. <br><br>  Sederhananya, Keybase tidak dapat menemukan tanda tangan orang lain.  Seperti server mana pun, ia dapat menyimpan data.  Tetapi pohon Merkle transparan kami dirancang untuk menyimpannya dalam waktu yang sangat singkat, dan selalu dapat ditemukan. <br><br><h3>  Bagaimana Keybase menangani pengaturan ulang akun? </h3><br>  Ketika pengguna Keybase benar-benar kehilangan semua perangkat mereka (yang bertentangan dengan menambahkan yang baru atau kehilangan beberapa), mereka perlu mengatur ulang.  Setelah mengatur ulang akun, pengguna pada dasarnya baru, tetapi ia memiliki nama pengguna yang sama.  Dia tidak dapat menandatangani "instruksi reset" karena dia telah kehilangan semua kuncinya.  Jadi sebagai gantinya, server Keybase melakukan pernyataan tidak bisa dihapus ke pohon Merkle, yang berarti mengatur ulang.  Klien memaksakan kemustahilan untuk mengembalikan instruksi ini.  Dalam artikel mendatang, mekanisme spesifik akan dijelaskan secara rinci. <br><br>  Pengguna ini harus menambahkan kembali verifikasi identitas (Twitter, Github, apa pun) dengan kunci baru. <br><br><h3>  Bisakah server cukup menukar daun pohon Merkle seseorang untuk mengiklankan serangkaian kunci yang sama sekali berbeda? </h3><br>  Penulis NCC sedang mempertimbangkan server Keybase yang bermusuhan yang benar-benar mengubah daun pohon Merkle, menggantikan set kunci Bob yang sebenarnya dengan set palsu yang benar-benar baru.  Server penyerang memiliki dua opsi.  Pertama, dia dapat memotong keadaan dunia dengan menempatkan Bob di satu garpu, dan yang ingin dia mainkan di yang lain.  Kedua, ia dapat "menipu" dengan menerbitkan versi pohon Merkle dengan set kunci Bob yang benar dan versi lain dengan set palsu.  Pengguna yang secara teratur berinteraksi dengan Bob akan mendeteksi serangan ini, karena mereka akan memverifikasi bahwa versi riwayat Bob yang sebelumnya diunduh adalah awalan yang valid dari versi baru yang mereka unduh dari server.  Validator pihak ketiga yang memindai semua pembaruan Keybase juga akan melihat serangan ini.  Jika Anda menulis validator Keybase pihak ketiga yang kami sukai, kami dapat menawarkan hadiah yang signifikan.  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>max</code></a> pada Keybase.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jika tidak, kami berharap dapat segera merencanakan pembuatan validator otonom. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bisakah Anda percaya apa yang saya baca sampai akhir? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Baca atau gulir ke bawah saja? </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id449350/">https://habr.com/ru/post/id449350/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id449340/index.html">Blok oracle berdasarkan oracle acak berdasarkan tanda tangan digital</a></li>
<li><a href="../id449342/index.html">Peramalan acak berdasarkan tanda tangan digital blockchain</a></li>
<li><a href="../id449344/index.html">Kodim - pizza</a></li>
<li><a href="../id449346/index.html">MODX Digest # 4 (8 - 22 April 2019)</a></li>
<li><a href="../id449348/index.html">Buildroot - bagian 2. Membuat konfigurasi papan Anda; penerapan skrip eksternal tree, rootfs-overlay, post-build</a></li>
<li><a href="../id449352/index.html">Bagaimana kami membangun pemantauan di Prometheus, Clickhouse dan ELK</a></li>
<li><a href="../id449356/index.html">Proses bisnis. Ekstraksi model BPMN dari dokumen. Bagian 1</a></li>
<li><a href="../id449358/index.html">Perbatasan Baru dalam Fisika</a></li>
<li><a href="../id449360/index.html">Microsoft telah mengadaptasi realitas virtual untuk orang-orang tunanetra</a></li>
<li><a href="../id449362/index.html">Healthcare UPS: Delta Health Health Experience</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>