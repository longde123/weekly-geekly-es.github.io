<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍✈️ 🌥️ 🍨 Erweiterte vier Regeln für das Software-Design 👨🏽 👩🏽‍🤝‍👩🏻 🏴‍☠️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Ich präsentiere Ihnen den Artikel "Vier bessere Regeln für das Software-Design" von David Bryant Copeland. David Bryant Copeland ist Softw...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erweiterte vier Regeln für das Software-Design</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461823/"><p>  Hallo Habr!  Ich präsentiere Ihnen den Artikel "Vier bessere Regeln für das Software-Design" von David Bryant Copeland.  David Bryant Copeland ist Software-Architekt und CTO für Stitch Fix.  Er unterhält <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Blog</a> und ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Autor mehrerer Bücher</a> . </p><br><p>  Martin Fowler hat kürzlich mit einem Link zu seinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog-Beitrag</a> über vier einfache Designregeln von Kent Beck getwittert, die meiner Meinung nach weiter verbessert werden können (und die den Programmierer manchmal in die falsche Richtung schicken können): </p><br><p>  Kents Regeln aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">extremen Programmierung erklärt</a> : </p><br><ul><li>  Kent sagt: "Führen Sie alle Tests durch." </li><li>  Duplizieren Sie die Logik nicht.  Vermeiden Sie versteckte Duplikate wie parallele Klassenhierarchien. </li><li>  Alle für den Programmierer wichtigen Absichten sollten deutlich sichtbar sein. </li><li>  Der Code sollte die kleinstmögliche Anzahl von Klassen und Methoden haben. </li></ul><br><p>  Nach meiner Erfahrung entsprechen diese Regeln nicht ganz den Anforderungen des Software-Designs. <a name="habracut"></a>  Meine vier Regeln für ein gut gestaltetes System könnten sein: </p><br><ul><li>  es ist gut durch Tests abgedeckt und besteht sie erfolgreich. </li><li>  Es gibt keine Abstraktionen, die das Programm nicht direkt benötigt. </li><li>  Sie hat ein eindeutiges Verhalten. </li><li>  es erfordert die geringste Anzahl von Konzepten. </li></ul><br><p>  Für mich ergeben sich diese Regeln aus dem, was wir mit unserer Software machen. </p><br><h1 id="tak-chto-zhe-my-delaem-s-nashim-po">  Was machen wir <em>also</em> mit unserer Software? </h1><br><p>  Wir können nicht über Software-Design sprechen, ohne vorher darüber zu sprechen, was wir damit machen wollen. </p><br><p>  Die Software wurde geschrieben, um das Problem zu lösen.  Das Programm läuft und hat ein Verhalten.  Dieses Verhalten wird untersucht, um einen korrekten Betrieb sicherzustellen oder Fehler zu erkennen.  Software ändert sich auch häufig, um ihr neues oder geändertes Verhalten zu verleihen. </p><br><p>  Daher sollte sich jeder Ansatz für das Software-Design darauf konzentrieren, sein Verhalten vorherzusagen, zu untersuchen und zu verstehen, um die Änderung dieses Verhaltens so einfach wie möglich zu gestalten. </p><br><p>  Wir überprüfen das korrekte Verhalten durch Tests. Daher stimme ich Kent zu, dass das Erste und Wichtigste darin besteht, dass gut gestaltete Software die Tests bestehen muss.  Ich werde sogar noch weiter gehen und darauf bestehen, dass die Software Tests enthält (d. H. Durch Tests gut abgedeckt ist). </p><br><p>  Nachdem das Verhalten überprüft wurde, beziehen sich die folgenden drei Punkte in beiden Listen auf das Verständnis unserer Software (und damit ihres Verhaltens).  Seine Liste beginnt mit der Codeduplizierung, die wirklich vorhanden ist.  Nach meiner persönlichen Erfahrung ist es jedoch teuer, sich zu sehr auf die Reduzierung der Codeduplizierung zu konzentrieren.  Um es zu beseitigen, müssen Abstraktionen erstellt werden, die es verbergen, und es sind diese Abstraktionen, die es schwierig machen, die Software zu verstehen und zu ändern. </p><br><h1 id="ustranenie-dublirovaniya-koda-trebuet-abstrakciy-a-abstrakcii-privodyat-k-slozhnosti">  Das Eliminieren von Codeduplizierungen erfordert Abstraktionen, und Abstraktionen führen zu Komplexität </h1><br><p>  Nicht wiederholen oder DRY wird verwendet, um kontroverse Designentscheidungen zu rechtfertigen.  Haben Sie jemals einen ähnlichen Code gesehen? </p><br><pre><code class="ruby hljs">ZERO = BigDecimal.new(<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br><p>  Außerdem haben Sie wahrscheinlich so etwas gesehen: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Map payload, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> async, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> errorStrategy)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Wenn Sie Methoden oder Funktionen mit Flags, Booleschen Werten usw. sehen, bedeutet dies normalerweise, dass beim Refactoring jemand das DRY-Prinzip verwendet hat, der Code jedoch an beiden Stellen nicht <em>exakt</em> gleich war, sodass der resultierende Code vorhanden sein sollte flexibel genug sein, um beide Verhaltensweisen zu berücksichtigen. </p><br><p>  Solche verallgemeinerten Abstraktionen sind schwer zu testen und zu verstehen, da sie viel mehr Fälle behandeln sollten als der ursprüngliche (möglicherweise duplizierte) Code.  Mit anderen Worten, Abstraktionen unterstützen viel mehr Verhaltensweisen, als für das normale Funktionieren des Systems erforderlich sind.  Das Eliminieren von Codeduplizierungen kann daher zu einem neuen Verhalten führen, das das System nicht benötigt. </p><br><p>  Daher ist es <em>wirklich wichtig</em> , einige Arten von Verhalten <em>zu</em> kombinieren, aber es kann schwierig sein zu verstehen, welche Art von Verhalten wirklich dupliziert wird.  Oft sehen Codeteile ähnlich aus, aber dies geschieht nur zufällig. </p><br><p>  Überlegen Sie, wie viel einfacher es ist, Codeduplikationen zu beseitigen, als sie erneut zurückzugeben (z. B. nachdem Sie eine schlecht durchdachte Abstraktion erstellt haben).  Daher müssen wir darüber nachdenken, doppelten Code zu hinterlassen, es sei denn, wir sind absolut sicher, dass wir einen besseren Weg haben, ihn loszuwerden. </p><br><p>  Das Erstellen von Abstraktionen sollte uns zum Nachdenken anregen.  Wenn Sie beim Entfernen von doppeltem Code eine sehr flexible verallgemeinerte Abstraktion erstellen, sind Sie möglicherweise in die falsche Richtung gegangen. </p><br><p>  Dies führt uns zum nächsten Punkt - Absicht versus Verhalten. </p><br><h1 id="namerenie-programmista-bessmyslenno---povedenie-znachit-vse">  Die Absicht des Programmierers ist bedeutungslos - Verhalten bedeutet alles </h1><br><p>  Wir loben oft Programmiersprachen, Konstrukte oder Codefragmente dafür, dass sie "die Absichten des Programmierers enthüllen".  Aber was bringt es, Absichten zu kennen, wenn Sie kein Verhalten vorhersagen können?  Und wenn Sie Verhalten kennen, wie viel bedeutet Absicht?  Es stellt sich heraus, dass Sie wissen <em>müssen</em> , wie sich die Software verhalten soll, aber dies ist nicht dasselbe wie die "Absichten des Programmierers". </p><br><p>  Schauen wir uns dieses Beispiel an, das die Absichten des Programmierers sehr gut widerspiegelt, sich aber nicht wie beabsichtigt verhält: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LastModified</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> Last modified on { props.date.toLocaleDateString() } </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); }</code> </pre> <br><p>  Offensichtlich plante der Programmierer, dass diese React-Komponente ein Datum mit der Meldung "Zuletzt geändert am" anzeigt.  Funktioniert das wie vorgesehen?  Nicht wirklich.  Was ist, wenn this.prop.date keine Rolle spielt?  Alles bricht einfach zusammen.  Wir wissen nicht, ob es so konzipiert wurde oder ob jemand es einfach vergessen hat, und es spielt keine Rolle.  Was zählt, ist das Verhalten. </p><br><p>  Und genau das sollten wir wissen, wenn wir diesen Teil des Codes ändern wollen.  Stellen Sie sich vor, wir müssen die Zeile in "Letzte Änderung" ändern.  Obwohl wir dies tun können, ist nicht klar, was passieren soll, wenn das Datum fehlt.  Es wäre besser, wenn wir die Komponente stattdessen so schreiben, dass ihr Verhalten verständlicher wird. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LastModified</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!props.date) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-string"><span class="hljs-string">"LastModified requires a date to be passed"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> Last modified on { props.date.toLocaleDateString() } </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); }</code> </pre> <br><p>  Oder sogar so: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LastModified</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (props.date) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> Last modified on { props.date.toLocaleDateString() } </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Never modified</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } }</code> </pre> <br><p>  In beiden Fällen ist das Verhalten verständlicher und die Absichten des Programmierers spielen keine Rolle.  Angenommen, wir wählen die zweite Alternative (die den fehlenden Datumswert behandelt).  Wenn wir aufgefordert werden, die Nachricht zu ändern, können wir das Verhalten sehen und prüfen, ob die Nachricht "Nie geändert" korrekt ist oder ob sie auch geändert werden muss. </p><br><p>  Je eindeutiger das <em>Verhalten ist</em> , desto größer sind die Chancen, dass wir es erfolgreich ändern können.  Und dies bedeutet, dass wir möglicherweise mehr Code schreiben oder genauer machen oder manchmal sogar doppelten Code schreiben müssen. </p><br><p>  Dies bedeutet auch, dass wir mehr Klassen, Funktionen, Methoden usw. benötigen. Natürlich <em>möchten wir</em> ihre Anzahl minimal halten, aber wir sollten diese Zahl nicht als unsere Metrik verwenden.  Das Erstellen einer großen Anzahl von Klassen oder Methoden verursacht <em>konzeptionellen Aufwand</em> , und in der Software werden mehr Konzepte angezeigt als Einheiten der Modularität.  Daher müssen wir die Anzahl der Konzepte reduzieren, was wiederum zu einer Verringerung der Anzahl der Klassen führen kann. </p><br><h1 id="konceptualnye-rashody-sposobstvuyut-zaputannosti-i-uslozhneniyu">  Konzeptionelle Kosten tragen zu Verwirrung und Komplexität bei </h1><br><p>  Um zu verstehen, was der Code tatsächlich tut, müssen Sie nicht nur den Themenbereich kennen, sondern auch alle in diesem Code verwendeten Konzepte (wenn Sie beispielsweise nach der Standardabweichung suchen, müssen Sie die Zuordnung, Addition, Multiplikation, Schleifen und Arraylängen kennen).  Dies erklärt, warum mit zunehmender Anzahl von Konzepten in einem Entwurf die Komplexität für das Verständnis zunimmt. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Früher habe</a> ich über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">konzeptionelle Ausgaben geschrieben</a> , und ein guter Nebeneffekt bei der Reduzierung der Anzahl von Konzepten in einem System ist, dass mehr Menschen dieses System verstehen können.  Dies wiederum erhöht die Anzahl der Personen, die Änderungen an diesem System vornehmen können.  Auf jeden Fall ist ein Software-Design, das von vielen Menschen sicher geändert werden kann, besser als eines, das nur von einer kleinen Handvoll geändert werden kann.  (Daher glaube ich, dass Hardcore-Funktionsprogrammierung niemals populär werden wird, da es ein tiefes Verständnis vieler sehr abstrakter Konzepte erfordert.) </p><br><p>  Durch die Reduzierung der konzeptionellen Kosten wird natürlich die Anzahl der Abstraktionen reduziert <em>und</em> das Verhalten verständlicher.  Ich sage nicht „niemals ein neues Konzept einführen“, ich sage, dass es einen eigenen Preis hat, und wenn dieser Preis den Nutzen überwiegt, sollte die Einführung eines neuen Konzepts sorgfältig abgewogen werden. </p><br><p>  Wenn wir Code oder Design-Software schreiben, sollten wir aufhören, über die <em>Eleganz</em> , <em>Schönheit</em> oder andere subjektive Maße unseres Codes nachzudenken.  Stattdessen sollten wir uns immer daran erinnern, was wir mit der Software machen werden. </p><br><h1 id="vy-ne-veshaete-kod-na-stenu---vy-menyaete-ego">  Sie hängen den Code nicht an die Wand - Sie ändern ihn </h1><br><p>  Ein Code ist kein Kunstwerk, das Sie drucken und in einem Museum aufhängen können.  Der Code wird ausgeführt.  Es wird untersucht und getestet.  Und vor allem <em>ändert es sich</em> .  Und oft.  Jedes Design, mit dem schwer zu arbeiten ist, sollte in Frage gestellt und überprüft werden.  Jedes Design, das die Anzahl der Personen reduziert, die damit arbeiten können, sollte <em>ebenfalls</em> in Frage gestellt werden. </p><br><p>  Der Code sollte funktionieren, also sollte er getestet werden.  Der Code weist Fehler auf und erfordert das Hinzufügen neuer Funktionen. Daher müssen wir sein Verhalten verstehen.  Der Code lebt länger als die Fähigkeit eines bestimmten Programmierers, ihn zu unterstützen. Daher sollten wir uns um Code bemühen, der für eine breite Palette von Menschen verständlich ist. </p><br><p>  Vereinfachen Sie beim Schreiben Ihres Codes oder beim Entwerfen Ihres Systems die Erklärung des Systemverhaltens?  Wird es einfacher zu verstehen, wie sie sich verhalten wird?  Konzentrieren Sie sich darauf, das Problem direkt vor Ihnen oder auf ein abstrakteres zu lösen? </p><br><p>  Versuchen Sie immer, das Verhalten für Demonstration, Vorhersage und Verständnis einfach zu halten und die Anzahl der Konzepte auf ein absolutes Minimum zu beschränken. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461823/">https://habr.com/ru/post/de461823/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461813/index.html">Nachrichten aus der Welt von OpenStreetMap Nr. 470 (17.07.2019 - 22.07.2019)</a></li>
<li><a href="../de461815/index.html">Eine Revolution im Design von Computer-Netzteilen vor einem halben Jahrhundert</a></li>
<li><a href="../de461817/index.html">CMake und C ++ - Brüder für immer</a></li>
<li><a href="../de461819/index.html">Warum einfaches Website-Design wissenschaftlich besser ist</a></li>
<li><a href="../de461821/index.html">Neue Immuntherapie entfernte alle Tumoren bei einer Frau mit metastasiertem Brustkrebs</a></li>
<li><a href="../de461827/index.html">Entwicklung hybrider PHP / Go-Anwendungen mit RoadRunner</a></li>
<li><a href="../de461829/index.html">TCP vs UDP oder die Zukunft der Netzwerkprotokolle</a></li>
<li><a href="../de461831/index.html">StealthWatch: Bereitstellung und Anpassung. Teil 2</a></li>
<li><a href="../de461833/index.html">Verlieren Sie sich nicht in drei Kiefern: einer egozentrischen Darstellung der Umwelt</a></li>
<li><a href="../de461835/index.html">Wie Gantt-Diagramme das Projektmanagement vereinfachen und stärken</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>