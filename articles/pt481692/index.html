<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóìÔ∏è üë¥üèª üç´ Usando o rastreamento do processador Intel para rastrear o c√≥digo do modo de gerenciamento do sistema üí¶ ‚ôàÔ∏è üçö</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artigo √© dedicado a testar a possibilidade de usar a tecnologia Intel Processor Trace (Intel PT) para gravar faixas no modo SMM (System Managemen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Usando o rastreamento do processador Intel para rastrear o c√≥digo do modo de gerenciamento do sistema</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/481692/"><p><img src="https://habrastorage.org/webt/ek/w6/yn/ekw6ynxfsk4gnib6pbdy0glmkxy.png"></p><br><p>  Este artigo √© dedicado a testar a possibilidade de usar a tecnologia Intel Processor Trace (Intel PT) para gravar faixas no modo SMM (System Management Mode).  Este trabalho foi realizado como parte do Summer Of Hack 2019. Publicado por <a href="https://twitter.com/sysenter_eip">@sysenter_eip</a> . </p><br><p>  A maioria das ferramentas usadas s√£o escritas por outras pessoas (em particular <a href="https://twitter.com/d_olex">@d_olex</a> , <a href="https://twitter.com/aionescu">@aionescu</a> ).  O resultado √© apenas uma combina√ß√£o das ferramentas dispon√≠veis para obter o caminho de execu√ß√£o do c√≥digo no modo SMM para <strong>uma</strong> placa-m√£e <strong>espec√≠fica</strong> .  No entanto, o material pode ser interessante para quem deseja repetir isso para sua plataforma ou simplesmente est√° interessado no trabalho do SMM. </p><a name="habracut"></a><br><h2 id="system-management-mode">  Modo de gerenciamento do sistema </h2><br><p> O SMM √© um modo especial e privilegiado do processador de arquitetura x86, que est√° dispon√≠vel enquanto o sistema operacional est√° em execu√ß√£o, mas √© completamente invis√≠vel para ele.  Ele foi projetado para intera√ß√£o de baixo n√≠vel com ferro, gerenciamento de energia, emula√ß√£o de dispositivos herdados, transi√ß√£o para o modo de suspens√£o (S3), acesso ao TPM e muito mais.  Funciona completamente isolado do sistema operacional.  Durante a execu√ß√£o do SMM, o sistema operacional para completamente.  O c√≥digo do programa que √© executado nesse modo √© armazenado na mem√≥ria SPI-Flash da placa-m√£e e faz parte do firmware do UEFI BIOS. </p><br><p>  A mudan√ßa para o modo SMM √© realizada usando interrup√ß√µes SMI especiais (System Management Interrupt).  Uma das op√ß√µes para essa interrup√ß√£o est√° dispon√≠vel para uso no anel zero (ou seja, no kernel do SO) - Interrup√ß√£o SMI no n√≠vel do aplicativo (Software SMI).  Al√©m disso, vamos nos concentrar nessas interrup√ß√µes. </p><br><p>  Devido ao seu alto privil√©gio, o SMM √© de particular interesse para pesquisas de seguran√ßa.  O comprometimento do SMM leva a graves viola√ß√µes da integridade e confidencialidade de todo o sistema e, na maioria dos casos, permite injetar c√≥digo malicioso que n√£o pode ser exclu√≠do e n√£o pode ser detectado pelo sistema operacional no firmware do UEFI BIOS. </p><br><h2 id="intel-processor-trace">  Rastreio do processador Intel </h2><br><p>  Uma das armadilhas do processo de depura√ß√£o para v√°rios aplicativos altamente carregados √© a sobrecarga - os custos das ferramentas de depura√ß√£o.  Eles podem ser reduzidos com uma solu√ß√£o habilitada para hardware. </p><br><p>  A quinta gera√ß√£o de processadores da Intel (Broadwell) apresentou ao mundo tecnologias como o Intel Processor Trace.  Como isso √© √∫til?  O Intel PT permite que voc√™ obtenha o fluxo completo de execu√ß√£o (fluxo de controle) do aplicativo depurado com sobrecarga m√≠nima (&lt;5%).  Ao mesmo tempo, suporta multithreading e pode ajudar a corrigir erros como "condi√ß√£o de corrida" devido a carimbos de data e hora ao gravar o rastreamento do aplicativo.  Sem d√∫vida, a tecnologia Intel PT oferece grandes oportunidades para escrever ferramentas de pesquisa de vulnerabilidades em aplicativos. </p><br><p>  Hoje, essa tecnologia √© usada em v√°rias ferramentas para rastrear, depurar e avaliar a cobertura de c√≥digo - tanto em aplicativos no n√≠vel do usu√°rio quanto no kernel.  Exemplos de ferramentas podem ser encontrados no site da <a href="https://software.intel.com/en-us/node/721535">Intel</a> .  Uma op√ß√£o de fuzzer AFL que aproveita o Intel PT est√° dispon√≠vel no reposit√≥rio do <a href="https://github.com/hunter-ht-2018/ptfuzzer">PTfuzzer</a> .  De projetos recentes, preste aten√ß√£o ao <a href="https://github.com/ohjeongwook/iptanalyzer">iptanalyzer</a> . </p><br><p>  No entanto, n√£o vimos nenhum trabalho sobre o uso do Intel PT no modo SMM.  Como nada nos impede de usar o Intel PT nesse contexto, decidimos descobrir se √© poss√≠vel rastrear o c√≥digo do Modo de Gerenciamento do Sistema com ele. </p><br><h2 id="podgotovka-k-rabote">  Prepara√ß√£o para o trabalho </h2><br><p>  Resulta do <a href="https://www.intel.ru/content/www/ru/ru/architecture-and-technology/64-ia-32-architectures-software-developer-vol-3c-part-3-manual.html">Manual do desenvolvedor</a> da <a href="https://www.intel.ru/content/www/ru/ru/architecture-and-technology/64-ia-32-architectures-software-developer-vol-3c-part-3-manual.html">Intel</a> que √© imposs√≠vel ativar o rastreamento do Intel PT no SMM de fora usando meios regulares.  Se estava ativo no momento em que o SMI foi acionado, o processador o desativar√° antes de transferir o controle para o ponto de entrada do manipulador SMI.  O √∫nico m√©todo de ativa√ß√£o √© a inclus√£o volunt√°ria do manipulador SMI pelo pr√≥prio c√≥digo. </p><br><p>  Mesmo que o processador n√£o forne√ßa inicialmente essa oportunidade, podemos intercept√°-lo e ativar o Intel PT manualmente.  No entanto, voc√™ precisa determinar de alguma forma que o sistema est√° pronto para registrar o rastreamento (o endere√ßo do buffer de sa√≠da est√° definido) e tamb√©m desativar o rastreamento no final da execu√ß√£o do processador (execu√ß√£o da instru√ß√£o RSM).  Caso contr√°rio, o processador desligar√° o sistema inteiro. </p><br><p>  Primeiro de tudo, voc√™ precisa acessar o SMRAM (a √°rea da RAM na qual o c√≥digo executado no modo SMM est√° localizado).  Como essa regi√£o de RAM est√° protegida, n√£o podemos acess√°-la a partir do sistema operacional (mesmo isso n√£o pode ser feito com o DMA).  Existem v√°rios cen√°rios: </p><br><ol><li>  explore uma vulnerabilidade conhecida no SMM e obtenha o primitivo R / W a partir dele.  Isso pode ser um erro de software (uma vulnerabilidade no pr√≥prio processador SMI; como regra, no SMM h√° c√≥digo suficiente que foi adicionado pelo OEM, portanto as vulnerabilidades n√£o s√£o incomuns), bem como uma configura√ß√£o de plataforma vulner√°vel (desbloquear / mover SMRAM); </li><li>  para corrigir a imagem UEFI de maneira que tenhamos uma interface para leitura e grava√ß√£o em endere√ßos arbitr√°rios - um backdoor.  Para implementar esta op√ß√£o, voc√™ precisa encontrar uma placa-m√£e na qual o Intel Boot Guard esteja desativado ou houver vulnerabilidades que possam contorn√°-la. </li></ol><br><h2 id="vnedrenie-svoego-koda-v-proshivku">  Incorpore seu c√≥digo no firmware </h2><br><p>  Apesar do fato de que as vulnerabilidades SMM no c√≥digo de v√°rios fabricantes s√£o encontradas de <a href="https://embedi.org/blog/uefi-bios-holes-so-much-magic-dont-come-inside/">tempos</a> em <a href="https://embedi.org/blog/uefi-bios-holes-so-much-magic-dont-come-inside/">tempos</a> , ser√° melhor se n√£o confiarmos nelas.  √â mais interessante rastrear o c√≥digo em um novo firmware e, consequentemente, tentar encontrar vulnerabilidades neles.  J√° t√≠nhamos a placa-m√£e GIGABYTE GA-Q270M-D3H com o Intel Boot Guard desativado; portanto, bastava adicionar um backdoor ao SMM. </p><br><p><img src="https://habrastorage.org/webt/cj/gs/ub/cjgsubzj6xwovbitbn7dob_tsz4.jpeg"><br>  Figura 1. Bancada de testes </p><br><p>  J√° existe uma <a href="https://github.com/Cr4sh/SmmBackdoor">estrutura para "infectar" o SMM e trabalhar com um backdoor</a> .  √â composto por tr√™s componentes: o driver UEFI em C, o "infector" e o script do cliente em Python.  Para sua opera√ß√£o, voc√™ precisa extrair um driver DXE arbitr√°rio (voc√™ pode fazer isso usando <a href="https://github.com/LongSoft/UEFITool">UEFITool</a> ) e process√°-lo com um infector.  O m√≥dulo original foi substitu√≠do por "aprimorado" e o firmware foi carregado na mem√≥ria SPI (para conveni√™ncia de piscar, a unidade flash SPI foi removida da placa). </p><br><p><img src="https://habrastorage.org/webt/bv/2a/ih/bv2aihyunbskeqjvp6ppqvqhzmi.jpeg"><br>  Figura 2. Chip de mem√≥ria SPI-Flash </p><br><p>  O sistema foi iniciado com sucesso e agora temos acesso total ao SMRAM a partir do Python (um exemplo de uso √© fornecido com o backdoor).  Como o script do cliente para o backdoor √© baseado no <a href="https://github.com/chipsec/chipsec">CHIPSEC</a> , √© necess√°rio conceder acesso ao modo kernel (usamos o driver RWEverything; ser√° conveniente que algu√©m use seu pr√≥prio driver CHIPSEC com a verifica√ß√£o de assinatura desativada no sistema). </p><br><p>  Voc√™ pode verificar a porta dos fundos solicitando um dump SMRAM. </p><br><p><code>$ python SmmBackdoor.py -d</code> </p> <br><p>  Ap√≥s executar este comando, o arquivo SMRAM_dump_cb000000_cb7fffff.bin ser√° criado contendo o estado atual da SMRAM.  Os valores cb000000 e cb7fffff s√£o, respectivamente, os endere√ßos f√≠sicos do in√≠cio e do fim da SMRAM. </p><br><h2 id="rabota-s-dampom-smram">  Trabalhar com SMRAM de despejo </h2><br><p>  O despejo SMRAM pode ser carregado em um desmontador ou passado para an√°lise no script <a href="https://github.com/Cr4sh/smram_parse">smram_parse.py</a> , que extrair√° muitas informa√ß√µes √∫teis para n√≥s.  O mais importante para n√≥s ser√£o os endere√ßos dos pontos de entrada SMI.  Esses s√£o os endere√ßos das fun√ß√µes para as quais o controle ser√° transferido quando o SMI for acionado.  Cada CPU possui seu pr√≥prio ponto de entrada. </p><br><p><img src="https://habrastorage.org/webt/8a/20/jq/8a20jq29bgn7rhqeim16vqhfxam.png"><br>  Figura 3. A sa√≠da do script smram_parse </p><br><p>  Vamos dar uma olhada no c√≥digo deles.  Como o SMM inicia sua execu√ß√£o no modo real de 16 bits (os primeiros 4 GB de RAM s√£o refletidos no espa√ßo virtual), a primeira coisa que o c√≥digo faz √© alternar para o modo de 64 bits.  Ao mesmo tempo, toda a SMRAM est√° dispon√≠vel com direitos de grava√ß√£o e execu√ß√£o, uma vez que apenas um segmento foi criado (existem fornecedores que fazem isso de maneira diferente?). </p><br><p>  N√£o queremos escrever c√≥digo de 16 bits ou preparar tudo o que √© necess√°rio para alternar para o modo de 64 bits por conta pr√≥pria; portanto, colocaremos nosso interceptador antes de chamar a fun√ß√£o SMI manager (essa fun√ß√£o determina em qual m√≥dulo SMM a execu√ß√£o deve ser transferida dependendo de qual servi√ßo foi chamado ou qual evento aconteceu). </p><br><p><img src="https://habrastorage.org/webt/_u/b0/4k/_ub04kwpncdmptrknltqyl0i3jg.png"><br>  Figura 4. Coloca√ß√£o para enganchar </p><br><p>  A maneira mais f√°cil de assumir o controle √© substituir o endere√ßo do expedidor pelo nosso.  Todos os pontos de entrada t√™m o mesmo c√≥digo, portanto, o patch precisa ser repetido para cada um. </p><br><p>  <strong>Nota:</strong> Em rela√ß√£o √† localiza√ß√£o do c√≥digo interceptador.  Como a estrutura da SMRAM n√£o √© totalmente conhecida por n√≥s, escolhemos um peda√ßo aleat√≥rio de mem√≥ria zero pr√≥ximo a um dos pontos de entrada, onde colocamos o c√≥digo interceptador.  A melhor op√ß√£o seria adicionar o m√≥dulo SMM ao firmware, que a UEFI colocaria legalmente na SMRAM, para n√£o se preocupar que algo importante seja substitu√≠do pelo nosso c√≥digo. </p><br><h2 id="realizaciya-perehvatchika-dispetchera-smi">  Implementando um SMI Manager Interceptor </h2><br><p>  Vamos designar o que exatamente vamos fazer dentro do nosso interceptador.  Primeiro, precisamos determinar se o Intel PT foi ativado antes de passar para o SMM.  √â sabido pela documenta√ß√£o da Intel que cada processador possui sua pr√≥pria base SMBASE (MSR 0x9E) e seu pr√≥prio espa√ßo para armazenar o estado do processador (√°rea SMM Save State) no momento da transi√ß√£o para o SMM. </p><br><p><img src="https://habrastorage.org/webt/bz/ti/i2/bztii2soe7myxor_zprtytfr09q.png"><br>  Figura 5. Layout do SMBASE </p><br><h3 id="opredelyaem-sostoyanie-intel-pt">  Determinamos o status da Intel PT </h3><br><p>  No SMM Save State, o valor do registro MSR IA32_RTIT_CTL, respons√°vel pelo gerenciamento do rastreamento Intel PT, deve ser salvo.  Infelizmente, o Intel Manual n√£o indica onde o processador salva o estado do bit IA32_RTIT_CTL.TraceEn no momento da transi√ß√£o para o SMM (se o rastreamento est√° ativado, zero bit).  No entanto, podemos determinar isso sozinhos despejando o SMM Save State duas vezes: com e sem o rastreamento ativado. </p><br><p>  Usamos a ferramenta <a href="https://ionescu007.github.io/winipt/">WinIPT</a> para ativar o rastreamento no processo do interpretador Python (pid <strong>1337</strong> ), alocando 2 ^ <strong>12</strong> (4096) bytes ao buffer de rastreamento e, em seguida, executando o script SmmBackdoor.py dentro do interpretador (argumento <strong>0</strong> √© um sinalizador, para n√≥s eles n√£o s√£o importante, porque no SMM voc√™ ainda precisa for√ßar suas configura√ß√µes de rastreamento). </p><br><p> <code>$ ipttool.exe --start 1337 12 0</code> </p> <br><p>  Comparando os instant√¢neos SMRAM, determinamos a localiza√ß√£o do registro IA32_RTIT_CTL na estrutura SMM Save State.  Ele √© armazenado no deslocamento SMBASE + 0xFE3C.  O estado do bit IA32_RTIT_CTL.TraceEn √© a principal condi√ß√£o para a reativa√ß√£o do Intel PT no SMM.  O campo nesse deslocamento √© marcado como Reservado no Intel Developer Manual. </p><br><p><img src="https://habrastorage.org/webt/tf/uy/hx/tfuyhxbfmhemoyy8gh003uo37s8.png"><br>  Figura 6. Marcando que os campos est√£o reservados </p><br><h3 id="pishem-shellcode">  Escrevendo c√≥digo de shell </h3><br><p>  N√£o quer√≠amos configurar o Intel PT dentro do SMM por conta pr√≥pria, pois isso complicaria nosso c√≥digo de shell (por exemplo, estando no SMM, seria dif√≠cil alocar uma grande parte da RAM para que n√£o fosse usada pelo pr√≥prio sistema operacional).  Portanto, decidimos usar o rastreador j√° configurado e simplesmente "ignor√°-lo" no SMM, especialmente porque ele j√° tem a fun√ß√£o de salvar o rastreamento em um arquivo. </p><br><p>  Como usamos o WinIPT para essa finalidade, que na √©poca n√£o suportava o rastreamento do c√≥digo do kernel (CPL == 0), era √≥bvio que mesmo quando o rastreamento era inclu√≠do no SMM, nada aparecia no log, pois o c√≥digo SMM era executado na CPL = 0 .  Precisamos modificar alguns filtros para que o rastreador possa funcionar durante todo o tempo gasto no SMM.  Listamos tudo o que precisa ser verificado e instalado: </p><br><ol><li>  O rastreamento com CPL = 0 deve estar ativado. </li><li>  O rastreamento para CPL&gt; 0 deve estar ativado (opcional). </li><li>  Os intervalos de IP v√°lidos para grava√ß√£o de eventos devem ser desativados. </li><li>  IA32_RTIT_STATUS.PacketByteCnt deve ser redefinido. </li><li>  A filtragem CR3 deve estar desativada. </li></ol><br><p>  Algumas palavras devem ser ditas sobre PacketByteCnt.  Esse contador determina em que ponto voc√™ precisa inserir pacotes de sincroniza√ß√£o (uma sequ√™ncia de v√°rios comandos PSB) no rastreamento.  Precisamos redefinir esse contador, caso contr√°rio, durante o processamento do rastreamento, o momento de entrar no SMM ser√° perdido e o rastreamento come√ßar√° de um local aleat√≥rio quando o PSB for gerado naturalmente. </p><br><p>  Abaixo est√° o c√≥digo de shell que usamos: </p><br><pre> <code class="plaintext hljs"> sub rsp, 0x18 ; this will align stack at 16 byte boundary (in case SMM ; code uses align dependent instructions) mov qword ptr ss:[rsp+0x10], rcx ; need to save rcx for SMI_Dispatcher mov ecx, 0x9E ; MSR_IA32_SMBASE rdmsr test byte ptr ds:[rax+0xFE3C], 0x1 ; Save State area contains saved ; IA32_RTIT_CTL.TraceEn je short @NoTrace call @Trace_Enable mov rcx, qword ptr ss:[rsp+0x10] ; SMI_Dispatcher is __fastcall ; (first argument in rcx) mov eax, 0xCB7DDAA4 ; original SMI_Dispatcher !!!!!!!!!!!!!!!!!!!!! call rax call @Trace_Disable add rsp, 0x18 ret @NoTrace: mov rcx, qword ptr ss:[rsp+0x10] ; SMI_Dispatcher is __fastcall mov eax, 0xCB7DDAA4 ; original SMI_Dispatcher !!!!!!!!!!!!!!!!!!!!! call rax add rsp, 0x18 ret @Trace_Disable: mov ecx, 0x570 ; IA32_RTIT_CTL rdmsr mov rax, qword ptr ss:[rsp+0x10] ; restore IA32_RTIT_STATUS wrmsr mov ecx, 0x571 ; IA32_RTIT_STATUS rdmsr mov rax, qword ptr ss:[rsp+0x8] ; restore IA32_RTIT_CTL wrmsr ret @Trace_Enable: mov ecx, 0x571 ; IA32_RTIT_STATUS rdmsr mov qword ptr ss:[rsp+0x8], rax ; save IA32_RTIT_STATUS and edx, 0xFFFF0000 ; IA32_RTIT_STATUS.PacketByteCnt = 0 wrmsr mov ecx, 0x570 ; IA32_RTIT_CTL rdmsr mov qword ptr ss:[rsp+0x10], rax ; save IA32_RTIT_CTL and eax, 0xFFFFFFBF ; IA32_RTIT_CTL.CR3Filter = 0 or eax, 0x5 ; IA32_RTIT_CTL.OS = 1; IA32_RTIT_CTL.User = 1; and edx, 0xFFFF0000 ; IA32_RTIT_CTL.ADDRx_CFG = 0 wrmsr ret</code> </pre> <br><p>  Esse c√≥digo deve ser colocado na SMRAM e a transi√ß√£o para o gerente SMI deve ser corrigida para ir ao nosso c√≥digo.  Tudo isso √© feito usando o SmmBackdoor. </p><br><h2 id="rabota-s-trassoy">  Trabalhar com a faixa </h2><br><p>  O interceptor do gerente SMI nos permitiu escrever o primeiro rastreio de c√≥digo do SMM.  O comando a seguir pode solicitar ao <strong>WinIPT</strong> que salve o <strong>rastreamento</strong> em um arquivo: </p><br><p> <code>$ ipttool.exe --trace 1337 trace_file_name</code> </p> <br><p>  Desativando o rastreio em um processo: </p><br><p> <code>$ ipttool.exe --stop 1337</code> </p> <br><p>  Voc√™ pode tentar desmontar o <strong>rastreamento</strong> usando o utilit√°rio <a href="https://github.com/intel/libipt">dumppt</a> da <a href="https://github.com/intel/libipt">libipt</a> . </p><br><p> <code>$ ptdump.exe --no-pad ./examples/trace_smm_handler_33 &gt; ./examples/trace_smm_handler_33_pt_dump.txt</code> </p> <br><p>  Exemplo de sa√≠da: </p><br><p><img src="https://habrastorage.org/webt/rr/iq/0e/rriq0ex1jsozdb6yuvicvg0i_ao.png"><br>  Figura 7. O primeiro caminho da instru√ß√£o SMM </p><br><p>  Podemos ver alguns endere√ßos, no entanto, √© extremamente dif√≠cil usar essas informa√ß√µes, pois elas s√£o de n√≠vel muito baixo. </p><br><p>  Para obter uma apar√™ncia mais leg√≠vel, existe um utilit√°rio <strong>ptxed</strong> (da libipt) que converte o rastreamento em um log de instru√ß√µes executadas do assembler.  Obviamente, teremos de fornecer ao utilit√°rio um despejo de mem√≥ria SMRAM, pois o log IPT n√£o cont√©m informa√ß√µes sobre os valores das c√©lulas da mem√≥ria ou sobre quais instru√ß√µes foram executadas;  Ele cont√©m apenas informa√ß√µes sobre quais altera√ß√µes ocorreram no fluxo de controle. </p><br><p> <code>$ ptxed.exe --pt tracesmm_12 --raw SMRAM_dump_cb000000_cb7fffff.bin:0xcb000000 &gt; tracesmm_12_ptasm</code> </p> <br><p><img src="https://habrastorage.org/webt/zb/5q/mh/zb5qmhqp5rlqaa2xi6qydeu0i_o.png"><br>  Figura 8. Lista do Assembler correspondente ao log do IPT </p><br><p>  J√° parece muito melhor, mas se o c√≥digo contiver um loop, a sa√≠da ser√° entupida com as mesmas instru√ß√µes. </p><br><h2 id="opredelyaem-pokrytie-koda-pri-pomoschi-trassy">  Definir cobertura de c√≥digo usando o rastreio </h2><br><p>  Para obter a visualiza√ß√£o da cobertura, escolhemos o plug-in <a href="https://github.com/gaasedelen/lighthouse">Lighthouse</a> para o IDA Pro, que usa o formato drcov. </p><br><p>  Nenhuma ferramenta pronta foi encontrada; portanto, modificamos o <strong>ptxed</strong> para que tamb√©m gerasse um arquivo de cobertura no processo.  O <strong>ptxed com</strong> patch est√° dispon√≠vel no <a href="https://github.com/sysenter-eip/smm_intel_pt/commit/8b7e23b3353fc04f886b9a226c1a34f768200822">reposit√≥rio</a> .  D√™ uma olhada no hist√≥rico de consolida√ß√£o para determinar exatamente o que foi adicionado. </p><br><p>  Ap√≥s a conclus√£o do ptxed, o arquivo SMRAM_dump_cb000000_cb7fffff.bin.log aparece, o qual conter√° informa√ß√µes de cobertura no formato drcov. </p><br><p>  <strong>Nota:</strong> H√° um pequeno problema com a sincroniza√ß√£o do desmontador no primeiro PSB.  Por uma raz√£o n√£o totalmente clara, se o PSB for gerado antes do PGE (o contador ser√° redefinido para zero antes do rastreamento ser ativado novamente), o <strong>ptxed</strong> n√£o poder√° ser sincronizado nele.  Para contornar esse problema, fizemos um pequeno patch.  N√£o est√° claro se isso √© um problema para o pr√≥prio <strong>ptxed</strong> ou se estamos fazendo algo errado, redefinindo IA32_RTIT_STATUS.PacketByteCnt. </p><br><p><img src="https://habrastorage.org/webt/pj/es/cq/pjescq_texdfmus7ljkpzxnrcaq.png"><br>  Figura 9. Um patch que permite usar o PSB localizado bem em frente ao PGE </p><br><p>  Os arquivos de cobertura gerados podem ser baixados no IDA Pro e obter um belo destaque, al√©m de estat√≠sticas sobre a porcentagem de cobertura para cada fun√ß√£o. </p><br><p><img src="https://habrastorage.org/webt/xl/7x/al/xl7xalcnynzuvjrrnrniamo-mzw.png"><br>  Figura 10. Plug-in IDA Pro Lighthouse com informa√ß√µes de cobertura de c√≥digo </p><br><p>  <strong>Nota:</strong> O plug-in Lighthouse funciona um pouco estranhamente em bancos de dados analisados ‚Äã‚Äãincompletamente (o c√≥digo execut√°vel n√£o est√° identificado, as fun√ß√µes n√£o foram criadas).  Rastreamos esse "problema" para a fun√ß√£o get_instructions_slice no arquivo \ lighthouse \ metadata.py, onde ele retorna 0 instru√ß√µes, mesmo para o endere√ßo em que a fun√ß√£o foi criada manualmente.  O plugin parece usar o cache e ignorar o novo c√≥digo espec√≠fico.  Isso pode ser contornado chamando Reanalyze no programa e reabrindo o BID.  Somente depois disso o plugin poder√° ver o novo c√≥digo e come√ßar a consider√°-lo.  Como esse problema √© muito inconveniente no caso de um despejo de SMRAM (que na primeira inicializa√ß√£o consiste quase inteiramente de c√≥digo indefinido), fizemos uma pequena altera√ß√£o no c√≥digo do Lighthouse para poder definir manualmente o novo c√≥digo mais rapidamente. </p><br><p><img src="https://habrastorage.org/webt/rq/4m/d8/rq4md80-4y5bjhzyqvpgmjeyjpe.png"><br>  Figura 11. Mensagem de log adicionada para ajudar a identificar o novo c√≥digo </p><br><h2 id="podderzhka-linux">  Suporte Linux </h2><br><p>  Como todos os nossos testes foram realizados no Windows 10 x64 (√© necess√°rio o ipt.sys, que apareceu no Windows October Creators Update 2018), digamos algumas palavras sobre a possibilidade de implementar isso no Linux. </p><br><ul><li>  H√° um m√≥dulo <strong>perf do</strong> kernel Linux que pode executar as mesmas a√ß√µes do WinIPT (ipt.sys), incluindo a capacidade de rastrear c√≥digo no modo kernel. </li><li>  Como a interface SMM backdoor √© baseada na estrutura CHIPSEC de plataforma cruzada, nosso patch funcionar√° em um sistema Linux sem nenhuma modifica√ß√£o. </li></ul><br><h2 id="vyvod">  Conclus√£o </h2><br><p>  Lidamos com √™xito com a tarefa de obter um rastreamento de c√≥digo executado no SMM usando a tecnologia Intel Processor Trace.  Um resultado semelhante poderia ser alcan√ßado com a ajuda de equipamentos e softwares caros que n√£o s√£o vendidos para todos.  Foi o suficiente para termos em m√£os uma placa-m√£e e um programador SPI.  A velocidade de remo√ß√£o da pista √© realmente impressionante e n√£o h√° queixas sobre a precis√£o do resultado. </p><br><p>  Esperamos que este artigo ajude outras pessoas a aproveitar a tecnologia Intel PT para investigar e procurar vulnerabilidades no c√≥digo SMM.  Adaptar nosso trabalho a outras placas-m√£e n√£o deve causar dificuldades (n√£o se esque√ßa do Intel Boot Guard).  O principal √© entender completamente como funciona.  A parte mais dif√≠cil √© determinar como interceptar o despachante SMI e escrever um c√≥digo de shell para o interceptador.  Em nossa vers√£o, endere√ßos "com fio" foram usados, portanto, voc√™ deve transferir cuidadosamente o c√≥digo do shell para outro sistema. </p><br><p>  Todas as ferramentas e scripts usados ‚Äã‚Äãest√£o dispon√≠veis no <a href="https://github.com/sysenter-eip/smm_intel_pt">reposit√≥rio no GitHub</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt481692/">https://habr.com/ru/post/pt481692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt481676/index.html">Semana de seguran√ßa 52: seguran√ßa para alto-falantes inteligentes e c√¢meras IP</a></li>
<li><a href="../pt481678/index.html">Revis√£o pr√©-feriado: N6IIT01 Player e fones de ouvido com armadura YB04 - Hi-Fi do sul da China</a></li>
<li><a href="../pt481680/index.html">Escrevendo TodoMVC no dap. Parte 2</a></li>
<li><a href="../pt481684/index.html">Um laptop da Powerbank?</a></li>
<li><a href="../pt481688/index.html">Por que aprender Java e como faz√™-lo com efici√™ncia. Relat√≥rio Yandex</a></li>
<li><a href="../pt481694/index.html">Meu caminho para particionar no PostgreSQL</a></li>
<li><a href="../pt481696/index.html">regra de regra: verifica√ß√µes din√¢micas para Go</a></li>
<li><a href="../pt481698/index.html">Transmiss√£o WebRTC dentro e ao redor da realidade virtual</a></li>
<li><a href="../pt481700/index.html">Sobre uma tia</a></li>
<li><a href="../pt481702/index.html">Da torradeira ao drone. Como surgiu a Internet das coisas e por que ela disparou apenas 30 anos depois</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>