<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôáüèΩ üéüÔ∏è ü•Ç Apresentando as interfaces virtuais do Linux: t√∫neis üï∫üèª üõÉ üîÇ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O Linux suporta muitos tipos de t√∫neis. Isso confunde os iniciantes que acham dif√≠cil entender as diferen√ßas de tecnologia e entender qual t√∫nel √© mel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apresentando as interfaces virtuais do Linux: t√∫neis</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/457386/"> O Linux suporta muitos tipos de t√∫neis.  Isso confunde os iniciantes que acham dif√≠cil entender as diferen√ßas de tecnologia e entender qual t√∫nel √© melhor usar em uma situa√ß√£o espec√≠fica.  O material, cuja tradu√ß√£o publicamos hoje, fornecer√° uma breve vis√£o geral das interfaces de encapsulamento comumente usadas do kernel Linux.  N√£o vamos nos aprofundar neste t√≥pico, considerando apenas os recursos gerais de t√∫neis e op√ß√µes para seu uso no Linux. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/-0/wg/hq/-0wghqvj6hymntfthlttl1xu6tm.jpeg"></a> <br><br>  O autor deste material acredita que o que ser√° discutido aqui pode ser do interesse de todos que t√™m algo a ver com o gerenciamento de redes de computadores.  A lista de interfaces de encapsulamento, bem como as informa√ß√µes de refer√™ncia em uma configura√ß√£o espec√≠fica, podem ser obtidas usando o comando iproute2 <code>ip link help</code> . <br><br>  As seguintes interfaces comumente usadas ser√£o abordadas aqui: IPIP, SIT, ip6tnl, VTI e VTI6, GRE e GRETAP, GRE6 e GRE6TAP, FOU, GUE, GENEVE, ERSPAN e IP6ERSPAN. <br><br>  Depois de ler este artigo, voc√™ aprender√° sobre os recursos dessas interfaces e descobrir√° as diferen√ßas entre elas.  Voc√™ aprender√° como cri√°-los e aprender√° sobre situa√ß√µes nas quais eles s√£o mais bem utilizados. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">IPIP</font> </h2><br>  O t√∫nel IPIP, como o pr√≥prio nome indica, √© um t√∫nel operando no modo IP sobre IP ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RFC 2003</a> ).  O cabe√ßalho do pacote de encapsulamento IPIP √© como mostrado abaixo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/369/49b/92c/36949b92c3d045185f09095a7a23dbfd.png"></div><br>  <i><font color="#999999">Cabe√ßalho de pacote de encapsulamento IPIP</font></i> <br><br>  Esses t√∫neis s√£o comumente usados ‚Äã‚Äãpara conectar duas sub-redes IPv4 internas em uma rede IPv4 p√∫blica (Internet).  O uso do IPIP cria uma carga adicional m√≠nima no sistema, mas apenas a transmiss√£o de dados unidirecional (unicast) pode ser realizada nesse t√∫nel.  Ou seja, tendo constru√≠do esse t√∫nel, n√£o ser√° poss√≠vel us√°-lo para transmiss√£o de dados multicast. <br><br>  Os t√∫neis IPIP suportam os modos IP sobre IP e MPLS sobre IP. <br><br>  Observe que quando o m√≥dulo ipip √© carregado ou quando o dispositivo IPIP √© criado pela primeira vez, o kernel do Linux cria um dispositivo <code>tunl0</code> padr√£o em cada espa√ßo de nome com os atributos <code>local=any</code> e <code>remote=any</code> .  Ao receber pacotes IPIP, o kernel, em certos casos, os redirecionar√° para <code>tunl0</code> como o dispositivo padr√£o.  Isso acontece quando o kernel n√£o consegue encontrar outro dispositivo cujos atributos <code>local/remote</code> correspondam mais aos endere√ßos de origem e destino dos pacotes. <br><br>  Veja como criar um t√∫nel IPIP: <br><br>  No servidor A: <br><br><pre> <code class="plaintext hljs"># ip link add name ipip0 type ipip local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR # ip link set ipip0 up # ip addr add INTERNAL_IPV4_ADDR/24 dev ipip0 Add a remote internal subnet route if the endpoints don't belong to the same subnet # ip route add REMOTE_INTERNAL_SUBNET/24 dev ipip0</code> </pre> <br>  No servidor B: <br><br><pre> <code class="plaintext hljs"># ip link add name ipip0 type ipip local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR # ip link set ipip0 up # ip addr add INTERNAL_IPV4_ADDR/24 dev ipip0 # ip route add REMOTE_INTERNAL_SUBNET/24 dev ipip0</code> </pre> <br>  Observe que, ao usar esta configura√ß√£o, ela deve ser alinhada com dados reais.  Em particular, <code>LOCAL_IPv4_ADDR</code> , <code>REMOTE_IPv4_ADDR</code> , <code>INTERNAL_IPV4_ADDR</code> e <code>REMOTE_INTERNAL_SUBNET</code> precisam ser substitu√≠dos pelos endere√ßos usados ‚Äã‚Äãem seu ambiente.  O mesmo vale para outros exemplos de configura√ß√µes, que consideraremos posteriormente. <br><br><h2>  <font color="#3AC1EF">Sente-se</font> </h2><br>  O SIT (Transi√ß√£o Simples da Internet) √© uma tecnologia de encapsulamento, cujo objetivo principal √© conectar redes IPv6 isoladas via Internet usando o protocolo IPv4. <br><br>  Inicialmente, a tecnologia SIT s√≥ podia funcionar no modo de encapsulamento "IPv6 sobre IPv4".  No entanto, ao longo dos anos de desenvolvimento, ganhou o apoio de v√°rios outros modos.  Em particular, √© <code>ipip</code> (o mesmo aconteceu com o t√∫nel IPIP), <code>ip6ip</code> , <code>mplsip</code> e <code>any</code> . <br><br>  <code>any</code> modo √© usado para trabalhar com tr√°fego IP e IPv6, o que pode ser √∫til em algumas situa√ß√µes.  Os t√∫neis SIT tamb√©m suportam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ISATAP</a> .  Aqui est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um exemplo do</a> uso dessa tecnologia. <br><br>  O cabe√ßalho do pacote SIT √© como mostrado abaixo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/193/172/49e/19317249ec76200873dabf9aac6bc755.png"></div><br>  <i><font color="#999999">Cabe√ßalho do pacote de t√∫nel SIT</font></i> <br><br>  Quando o m√≥dulo <code>sit</code> carregado, o kernel do Linux cria o <code>sit0</code> padr√£o do <code>sit0</code> . <br><br>  Veja como criar um t√∫nel SIT (estas etapas devem ser executadas nos servidores A e B): <br><br><pre> <code class="plaintext hljs"># ip link add name sit1 type sit local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR mode any # ip link set sit1 up # ip addr add INTERNAL_IPV4_ADDR/24 dev sit1</code> </pre> <br><h2>  <font color="#3AC1EF">Ip6tnl</font> </h2><br>  A interface ip6tnl funciona no modo IPv4 / IPv6 sobre IPv6.  √â semelhante √† vers√£o IPv6 do t√∫nel SIT.  √â assim que o cabe√ßalho do pacote ip6tnl se parece. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e7/b3b/1b6/9e7b3b1b6862d0f3100c9c64db2171b7.png"></div><br>  <i><font color="#999999">Cabe√ßalho do pacote de t√∫nel Ip6tnl</font></i> <br><br>  Os t√∫neis Ip6tnl suportam <code>ip6ip6</code> , <code>ipip6</code> e <code>any</code> modo.  O modo <code>ipip6</code> representado pelo esquema IPv4 sobre IPv6, o modo <code>ip6ip6</code> √© IPv6 sobre IPv6.  <code>any</code> modo suporta os dois esquemas. <br><br>  Quando o m√≥dulo <code>ip6tnl</code> , o kernel do Linux cria um dispositivo padr√£o chamado <code>ip6tnl0</code> . <br><br>  Veja como criar um t√∫nel ip6tnl: <br><br><pre> <code class="plaintext hljs"># ip link add name ipip6 type ip6tnl local LOCAL_IPv6_ADDR remote REMOTE_IPv6_ADDR mode any</code> </pre> <br><h2>  <font color="#3AC1EF">VTI e VTI6</font> </h2><br>  A interface Linux VTI (Virtual Tunnel Interface) √© semelhante √† interface Cisco VTI e √† implementa√ß√£o do Juniper de um t√∫nel seguro (st.xx). <br><br>  Esse driver de encapsulamento implementa o encapsulamento IP, que pode ser usado com o xfrm para criar t√∫neis seguros e, em seguida, usar t√∫neis de roteamento no n√≠vel do kernel sobre esses t√∫neis. <br><br>  Em geral, os t√∫neis VTI funcionam como IPIP ou SIT.  A exce√ß√£o √© que eles usam o encapsulamento / decapsulamento fwmark e IPsec. <br><br>  VTI6 √© o equivalente IPv6 do VTI. <br><br>  Veja como criar um t√∫nel VTI: <br><br><pre> <code class="plaintext hljs"># ip link add name vti1 type vti key VTI_KEY local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR # ip link set vti1 up # ip addr add LOCAL_VIRTUAL_ADDR/24 dev vti1 # ip xfrm state add src LOCAL_IPv4_ADDR dst REMOTE_IPv4_ADDR spi SPI PROTO ALGR mode tunnel # ip xfrm state add src REMOTE_IPv4_ADDR dst LOCAL_IPv4_ADDR spi SPI PROTO ALGR mode tunnel # ip xfrm policy add dir in tmpl src REMOTE_IPv4_ADDR dst LOCAL_IPv4_ADDR PROTO mode tunnel mark VTI_KEY # ip xfrm policy add dir out tmpl src LOCAL_IPv4_ADDR dst REMOTE_IPv4_ADDR PROTO mode tunnel mark VTI_KEY</code> </pre> <br>  Al√©m disso, o IPsec pode ser configurado usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">libreswan</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">strongSwan</a> . <br><br><h2>  <font color="#3AC1EF">GRE e GRETAP</font> </h2><br>  A tecnologia GRE (Encapsulamento de roteamento gen√©rico) √© descrita na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RFC 2784</a> .  No encapsulamento GRE, um cabe√ßalho GRE adicional √© adicionado entre os cabe√ßalhos dos pacotes IP internos e externos. <br><br>  Teoricamente, o GRE pode encapsular pacotes de qualquer protocolo da Camada 3 com um tipo Ethernet v√°lido.  Isso distingue a tecnologia GRE da tecnologia IPIP, que suporta apenas o encapsulamento de pacotes IP.  Aqui est√° a apar√™ncia do cabe√ßalho do pacote ao usar a tecnologia GRE. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22d/b74/b09/22db74b090586084bfe845c7df963139.png"></div><br>  <i><font color="#999999">Cabe√ßalho do pacote de t√∫nel GRE</font></i> <br><br>  Observe que os t√∫neis GRE permitem suporte a multicast e IPv6. <br><br>  Ao carregar o m√≥dulo <code>gre</code> , o kernel do Linux cria o <code>gre0</code> padr√£o <code>gre0</code> . <br><br>  Veja como criar um t√∫nel GRE: <br><br><pre> <code class="plaintext hljs"># ip link add name gre1 type gre local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR [seq] key KEY</code> </pre> <br>  Enquanto os t√∫neis GRE operam na camada OSI 3, os t√∫neis GRETAP operam na camada OSI 2.  Isso significa que um dos cabe√ßalhos internos dos respectivos pacotes √© Ethernet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1da/ec8/099/1daec8099c6cede117df740da4791144.png"></div><br>  <i><font color="#999999">Cabe√ßalho do pacote de t√∫nel GRETAP</font></i> <br><br>  Veja como criar um t√∫nel GRETAP: <br><br><pre> <code class="plaintext hljs"># ip link add name gretap1 type gretap local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR</code> </pre> <br><h2>  <font color="#3AC1EF">GRE6 e GRE6TAP</font> </h2><br>  GRE6 √© o equivalente IPv6 do GRE.  Os t√∫neis GRE6 permitem encapsular qualquer protocolo da camada 3 no IPv6.  √â assim que o cabe√ßalho do pacote GRE6 se parece. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d8c/69e/45a/d8c69e45aab1f77ea5948cf2a6e81c35.png"></div><br>  <i><font color="#999999">Cabe√ßalho do pacote de t√∫neis GRE6</font></i> <br><br>  Nos t√∫neis GRE6TAP, como nos t√∫neis GRETAP, existem cabe√ßalhos Ethernet entre os cabe√ßalhos de pacotes internos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/72c/290/7c7/72c2907c7c649e6390d1e51156bcac57.png"></div><br>  <i><font color="#999999">Cabe√ßalho do pacote de t√∫nel GRE6TAP</font></i> <br><br>  Veja como criar um t√∫nel GRE: <br><br><pre> <code class="plaintext hljs"># ip link add name gre1 type gre6 local LOCAL_IPv6_ADDR remote REMOTE_IPv6_ADDR # ip link add name gretap1 type gretap6 local LOCAL_IPv6_ADDR remote REMOTE_IPv6_ADDR</code> </pre> <br><h2>  <font color="#3AC1EF">Fou</font> </h2><br>  O encapsulamento pode ser realizado em diferentes n√≠veis da pilha de rede.  Os t√∫neis IPIP, SIT e GRE existem na camada IP.  E os t√∫neis FOU (eles s√£o organizados de acordo com o esquema ‚Äúfoo over UDP‚Äù) operam no n√≠vel UDP. <br><br>  Existem algumas vantagens em usar o encapsulamento UDP sobre o encapsulamento IP.  O fato √© que o protocolo UDP funciona com a infraestrutura de hardware existente. <br><br>  Por exemplo, este √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RSS</a> em placas de rede, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ECMP</a> em comutadores, s√£o tecnologias para calcular somas de verifica√ß√£o sem a participa√ß√£o de um processador central.  A aplica√ß√£o do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">patch</a> FOU apropriado aos desenvolvedores mostra um aumento significativo no desempenho para SIT e IPIP. <br><br>  Atualmente, os t√∫neis FOU suportam encapsulamento de protocolo com base em IPIP, SIT e GRE.  Aqui est√° a apar√™ncia do cabe√ßalho de um pacote FOU. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90d/a66/cb9/90da66cb92c6e3083f29ed97b952e0b6.png"></div><br>  <i><font color="#999999">Cabe√ßalho do pacote de t√∫neis FOU</font></i> <br><br>  Veja como criar um t√∫nel FOU: <br><br><pre> <code class="plaintext hljs"># ip fou add port 5555 ipproto 4 # ip link add name tun1 type ipip remote 192.168.1.1 local 192.168.1.2 ttl 225 encap fou encap-sport auto encap-dport 5555</code> </pre> <br>  O primeiro comando configura a porta FOU de recebimento do IPIP vinculada a 5555. Para usar o GRE, voc√™ precisa usar o <code>ipproto 47</code> .  O segundo comando configura a nova interface IPIP virtual ( <code>tun1</code> ), projetada para o encapsulamento FOU, cuja porta de destino √© 5555. <br><br>  Observe que os t√∫neis FOU n√£o s√£o suportados no Red Hat Enterprise Linux. <br><br><h2>  <font color="#3AC1EF">Gue</font> </h2><br>  Outro tipo de encapsulamento UDP √© introduzido pela tecnologia GUE ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Generic UDP Encapsulation</a> ).  A diferen√ßa entre FOU e GUE √© que o GUE tem seu pr√≥prio cabe√ßalho, que cont√©m informa√ß√µes de protocolo e outros dados. <br><br>  Atualmente, os t√∫neis GUE suportam o encapsulamento interno de IPIP, SIT e GRE.  Aqui est√° a apar√™ncia de um cabe√ßalho de pacote GUE. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/412/d7f/d38/412d7fd38350aa55b24cb0b93865d93c.png"></div><br>  <i><font color="#999999">Cabe√ßalho do pacote de t√∫nel GUE</font></i> <br><br>  Veja como criar um t√∫nel GUE: <br><br><pre> <code class="plaintext hljs"># ip fou add port 5555 gue # ip link add name tun1 type ipip remote 192.168.1.1 local 192.168.1.2 ttl 225 encap gue encap-sport auto encap-dport 5555</code> </pre> <br>  Gra√ßas a esses comandos, uma porta GUE de recebimento para IPIP vinculada ao n√∫mero 5555 e um t√∫nel IPIP configurado para encapsulamento de GUE ser√£o criados. <br><br>  Os t√∫neis GUE n√£o s√£o suportados no Red Hat Enterprise Linux. <br><br><h2>  <font color="#3AC1EF">GENEVE</font> </h2><br>  Os t√∫neis GENEVE (encapsulamento de virtualiza√ß√£o de rede gen√©rica) suportam todos os recursos de XLAN, NVGRE e STT.  A tecnologia GENEVE foi projetada para contornar as limita√ß√µes identificadas dessas tr√™s tecnologias.  Muitos acreditam que essa tecnologia √© capaz, a longo prazo, de substituir completamente esses tr√™s formatos mais antigos.  Aqui est√° a apar√™ncia do cabe√ßalho do pacote de encapsulamento GENEVE. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/767/f30/98e/767f3098ee539caf3f03778143fa6106.png"></div><br>  <i><font color="#999999">Cabe√ßalho do pacote de t√∫neis GENEVE</font></i> <br><br>  Este cabe√ßalho √© semelhante ao cabe√ßalho de um pacote <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">VXLAN</a> .  A principal diferen√ßa entre os dois √© que o cabe√ßalho GENEVE √© mais flex√≠vel.  Isso facilita muito a implementa√ß√£o de novos recursos, expandindo os cabe√ßalhos usando os campos Tipo-Comprimento-Valor (TLV). <br><br>  Detalhes sobre GENEVE podem ser encontrados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  GENEVE √© usado na solu√ß√£o SDN de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">rede virtual aberta</a> (OVN) como uma ferramenta de encapsulamento padr√£o.  Veja como criar um t√∫nel GENEVE: <br><br><pre> <code class="plaintext hljs"># ip link add name geneve0 type geneve id VNI remote REMOTE_IPv4_ADDR</code> </pre> <br><h2>  <font color="#3AC1EF">ERSPAN e IP6ERSPAN</font> </h2><br>  A tecnologia do analisador de porta comutada remota encapsulada (ERSPAN) usa o encapsulamento GRE para estender os recursos b√°sicos do espelhamento de porta da camada 2 para a camada 3.  Isso permite encaminhar tr√°fego espelhado por uma rede IP roteada.  √â assim que o cabe√ßalho do pacote ERSPAN se parece. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dee/15d/871/dee15d871a6ee9d433f154b9a6a6e048.png"></div><br>  <i><font color="#999999">Cabe√ßalho do pacote de t√∫nel ERSPAN</font></i> <br><br>  Os t√∫neis do ERSPAN permitem que os hosts Linux atuem como uma fonte de tr√°fego ERSPAN e enviem o tr√°fego espelhado do ERSPAN para um host remoto ou para um destino do ERSPAN que recebe e processa pacotes ERSPAN gerados por switches Cisco ou outros dispositivos que suportam o ERSPAN.  Um sistema semelhante pode ser usado para analisar e diagnosticar a rede, para detectar tr√°fego malicioso. <br><br>  Atualmente, o Linux suporta a maioria dos recursos das duas vers√µes do ERSPAN - v1 (tipo II) e v2 (tipo III). <br><br>  Veja como criar t√∫neis ERSPAN: <br><br><pre> <code class="plaintext hljs"># ip link add dev erspan1 type erspan local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR seq key KEY erspan_ver 1 erspan IDX</code> </pre> <br>  Voc√™ tamb√©m pode fazer isso: <br><br><pre> <code class="plaintext hljs"># ip link add dev erspan1 type erspan local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR seq key KEY erspan_ver 2 erspan_dir DIRECTION erspan_hwid HWID</code> </pre> <br>  Adicione um filtro tc para monitorar o tr√°fego: <br><br><pre> <code class="plaintext hljs"># tc qdisc add dev MONITOR_DEV handle ffff: ingress # tc filter add dev MONITOR_DEV parent ffff: matchall skip_hw action mirred egress mirror dev erspan1</code> </pre> <br><h2>  <font color="#3AC1EF">Sum√°rio</font> </h2><br>  N√≥s cobrimos algumas tecnologias de encapsulamento no Linux aqui.  Aqui est√° uma tabela de resumo para eles. <br><br><div class="scrollable-table"><table><tbody><tr><td>  Tipo de conex√£o / t√∫nel <br></td><td>  Cabe√ßalho externo <br></td><td>  Cabe√ßalho Encapsulado <br></td><td>  Cabe√ßalho interno <br></td></tr><tr><td>  ipip <br></td><td>  IPv4 <br></td><td>  Nenhuma <br></td><td>  IPv4 <br></td></tr><tr><td>  sente-se <br></td><td>  IPv4 <br></td><td>  Nenhuma <br></td><td>  IPv4 / IPv6 <br></td></tr><tr><td>  ip6tnl <br></td><td>  IPv4 <br></td><td>  Nenhuma <br></td><td>  IPv4 / IPv6 <br></td></tr><tr><td>  vti <br></td><td>  IPv4 <br></td><td>  IPsec <br></td><td>  IPv4 <br></td></tr><tr><td>  vti6 <br></td><td>  IPv6 <br></td><td>  IPsec <br></td><td>  IPv6 <br></td></tr><tr><td>  gre <br></td><td>  IPv4 <br></td><td>  GRE <br></td><td>  IPv4 / IPv6 <br></td></tr><tr><td>  agarrar <br></td><td>  IPv4 <br></td><td>  GRE <br></td><td>  √âter + IPv4 / IPv6 <br></td></tr><tr><td>  gre6 <br></td><td>  IPv6 <br></td><td>  GRE <br></td><td>  IPv4 / IPv6 <br></td></tr><tr><td>  gre6tap <br></td><td>  IPv6 <br></td><td>  GRE <br></td><td>  √âter + IPv4 / IPv6 <br></td></tr><tr><td>  fou <br></td><td>  IPv4 / IPv6 <br></td><td>  UDP <br></td><td>  IPv4 / IPv6 / GRE <br></td></tr><tr><td>  gue <br></td><td>  IPv4 / IPv6 <br></td><td>  UDP + GUE <br></td><td>  IPv4 / IPv6 / GRE <br></td></tr><tr><td>  Genebra <br></td><td>  IPv4 / IPv6 <br></td><td>  UDP + Geneve <br></td><td>  √âter + IPv4 / IPv6 <br></td></tr><tr><td>  erspan <br></td><td>  IPv4 <br></td><td>  GRE + ERSPAN <br></td><td>  IPv4 / IPv6 <br></td></tr><tr><td>  ip6erspan <br></td><td>  IPv6 <br></td><td>  GRE + ERSPAN <br></td><td>  IPv4 / IPv6 <br></td></tr></tbody></table></div><br>  Observe que todos os t√∫neis, cujos exemplos de cria√ß√£o s√£o mostrados aqui, existem apenas at√© o servidor ser reiniciado.  Se voc√™ deseja criar um t√∫nel que se recupera ap√≥s a reinicializa√ß√£o, considere usar um daemon para configurar a rede, como o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">NetworkManager</a> , ou use o mecanismo apropriado da distribui√ß√£o Linux que voc√™ est√° usando. <br><br>  <b>Caros leitores!</b>  Quais t√∫neis Linux voc√™ usa? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt457386/">https://habr.com/ru/post/pt457386/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt457366/index.html">Um fan√°tico, um peda√ßo de ferro ou um espectador - que tipo de jogador voc√™ √©?</a></li>
<li><a href="../pt457374/index.html">Reduza o tempo de compila√ß√£o de seus projetos Android</a></li>
<li><a href="../pt457378/index.html">Como a id Software criou o Wolfenstein 3D com base na tecnologia do Commander Keen</a></li>
<li><a href="../pt457380/index.html">OpenGL ultramoderno. Parte 2</a></li>
<li><a href="../pt457382/index.html">7 h√°bitos de programadores de alto desempenho</a></li>
<li><a href="../pt457390/index.html">Madagascar - ilha dos contrastes</a></li>
<li><a href="../pt457392/index.html">Economias no desenvolvimento de plataformas cruzadas m√≥veis: estudo de caso da Skyeng</a></li>
<li><a href="../pt457396/index.html">Desbloquear automaticamente o cont√™iner LUKS raiz ap√≥s uma inicializa√ß√£o a quente</a></li>
<li><a href="../pt457398/index.html">Mas estou fazendo besteira? Por que os desenvolvedores v√£o para o gemba</a></li>
<li><a href="../pt457400/index.html">O n√∫mero de v√≠timas de desastres nucleares como Chernobyl √© exagerado em termos de drama</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>