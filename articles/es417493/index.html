<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì£ üßôüèº üé∞ C√≥mo comprimir el gestor de arranque para STM8 a un tama√±o de 18 bytes en la memoria FLASH üöê üòΩ üç≤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En el proceso de b√∫squeda del gestor de arranque para el microcontrolador STM8S103F3, se descubri√≥ que los gestores de arranque disponibles est√°n escr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo comprimir el gestor de arranque para STM8 a un tama√±o de 18 bytes en la memoria FLASH</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417493/">  En el proceso de b√∫squeda del gestor de arranque para el microcontrolador STM8S103F3, se descubri√≥ que los gestores de arranque disponibles est√°n escritos principalmente en "C", "roban" una cantidad significativa de memoria FLASH y transfieren la tabla de vectores de interrupci√≥n. <br><br>  El gestor de arranque era necesario para alg√∫n dispositivo al que es imposible conectar el programador. <br><br>  Se decidi√≥ intentar escribir un gestor de arranque usted mismo con los siguientes requisitos: <br><br>  - el cargador deber√≠a llamarse STM8uLoader; <br>  - El c√≥digo debe estar escrito en ensamblador (el beneficio del ensamblador a√∫n no est√° legalmente prohibido); <br>  - el gestor de arranque debe ocupar la menor cantidad posible en la memoria FLASH, la cantidad ocupada en la computadora se considerar√° ilimitada; <br>  - el cargador no debe mover la tabla de vectores de interrupci√≥n; <br>  - el gestor de arranque debe tener una funcionalidad m√≠nima, toda la funcionalidad principal debe ser asumida por la computadora; <br>  - el gestor de arranque debe transferir el control al programa de aplicaci√≥n dentro de un tiempo razonable despu√©s de un reinicio / encendido si no hay conexi√≥n a la computadora. <br><br>  La primera condici√≥n se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cumpli√≥</a> instant√°neamente, pero los requisitos posteriores tuvieron que ser trabajados. <br><a name="habracut"></a><br><h4>  Primera etapa  C√≥digo de 65 bytes en la memoria FLASH </h4><br>  Para guardar la tabla de vectores en su lugar, se decidi√≥ colocar el c√≥digo al final de la memoria FLASH y cambiarlo inmediatamente desde el vector de volcado $ 8000. <br><br>  En el arranque, el control se transfiere al c√≥digo del cargador de arranque a $ 9FC2.  El gestor de arranque configura el UART 9600 8N1, espera dos bytes en el UART y, sin esperar, transfiere el control al programa de aplicaci√≥n en la direcci√≥n almacenada en el par $ 9FFE: $ 9FFF. <br><br>  Si el cargador recibe los bytes alto y bajo del tama√±o del volcado esperado del programa host, lo hace, lo deposita en la memoria RAM y le transfiere el control. <br>  Adem√°s, toda la atenci√≥n recae en el programa en la computadora y el volcado que env√≠a.  Deber√≠a enviar exactamente los volcados necesarios para completar la tarea actual (leer / borrar / escribir / copiar celdas de memoria STM8).  Los volcados deber√≠an poder reemplazarse entre s√≠ en la memoria RAM y transferir el control al programa de aplicaci√≥n. <br><br>  La direcci√≥n de transici√≥n a la aplicaci√≥n es $ 9FFE: $ 9FFF. <br><br><div class="spoiler">  <b class="spoiler_title">El archivo boot_FLASH.asm:</b> <div class="spoiler_text"><pre><code class="hljs mel">stm8/ TITLE <span class="hljs-string"><span class="hljs-string">"boot_FLASH.asm"</span></span> .NOLIST #include <span class="hljs-string"><span class="hljs-string">"STM8S103F3P.inc"</span></span> .LIST MOTOROLA WORDS segment byte at <span class="hljs-number"><span class="hljs-number">8000</span></span> <span class="hljs-string"><span class="hljs-string">'boot_start'</span></span> boot_start: jp boot_FLASH_start dc.b $00 ; boot_FLASH ; ******************************************************** ;  <span class="hljs-number"><span class="hljs-number">0x8004</span></span>..<span class="hljs-number"><span class="hljs-number">.0</span></span>x9FC1      WORDS ; segment byte at <span class="hljs-number"><span class="hljs-number">8004</span></span> <span class="hljs-string"><span class="hljs-string">'main_FLASH'</span></span> main_FLASH_start: ldw X, #$03FF ldw SP, X mov UART1_BRR1, #<span class="hljs-number"><span class="hljs-number">13</span></span> mov UART1_CR2, #%00001100 main_FLASH_cycle: callr main_delay ;   bset PB_DDR,#<span class="hljs-number"><span class="hljs-number">5</span></span> bset PB_CR1,#<span class="hljs-number"><span class="hljs-number">5</span></span> ;   byte1_tx: mov UART1_DR, #$80 byte1_wait_tx btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">7</span></span>, byte1_wait_tx callr main_delay boot_RAM_exit1: ;   bres PB_DDR,#<span class="hljs-number"><span class="hljs-number">5</span></span> ; bres PB_CR1,#<span class="hljs-number"><span class="hljs-number">5</span></span> ; ;   byte2_tx: mov UART1_DR, #$08 byte2_wait_tx btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">7</span></span>, byte2_wait_tx jra main_FLASH_cycle main_delay: decw X jrne main_delay ret segment byte at <span class="hljs-number"><span class="hljs-number">9</span></span>FC2 <span class="hljs-string"><span class="hljs-string">'boot_FLASH'</span></span> boot_FLASH_start: mov UART1_BRR1, #<span class="hljs-number"><span class="hljs-number">13</span></span>; Fmaster=<span class="hljs-number"><span class="hljs-number">16</span></span>/<span class="hljs-number"><span class="hljs-number">8</span></span>=<span class="hljs-number"><span class="hljs-number">2</span></span>/<span class="hljs-number"><span class="hljs-number">9600</span></span>/<span class="hljs-number"><span class="hljs-number">16</span></span> mov UART1_CR2, #%00001100;  / ;   UART1   RST_SR boot_FLASH_RST_SR_tx: mov UART1_DR, RST_SR ;    ,      ;      ;    X    ( <span class="hljs-number"><span class="hljs-number">200</span></span> ) ldw X,#<span class="hljs-number"><span class="hljs-number">0</span></span> boot_FLASH_wait_byte1: decw X jreq boot_FLASH_exit;       btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">5</span></span>, boot_FLASH_wait_byte1 ;   ,   , ;  X     ld A, UART1_DR ld XH, A ;      boot_FLASH_wait_byte2: btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">5</span></span>, boot_FLASH_wait_byte2 ;    ld A, UART1_DR ld XL, A ;  X -    ;   X       ldw Y, #$0400 ;  Y   <span class="hljs-number"><span class="hljs-number">0x0400</span></span> (RAM_END + <span class="hljs-number"><span class="hljs-number">1</span></span>) ;    boot_FLASH_rx_block_wait: btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">5</span></span>, boot_FLASH_rx_block_wait boot_EEPROM_rx_block_entry: decw Y ;      Y     ld A, UART1_DR ld (Y), A decw X ;      X      jrne boot_FLASH_rx_block_wait ;      jp (Y) ;    ()  boot_FLASH_exit: dc.b $CC boot_FLASH_exit_addr: dc.w main_FLASH_start end ;</code> </pre> <br></div></div><br><h4>  Segunda etapa.  Tama√±o de c√≥digo 21 bytes en FLASH y 52 bytes en memoria EEPROM </h4><br>  Seleccionar 65 bytes de la memoria FLASH (en STM8S103F3 es solo 8192 bytes) no es humano.  Despu√©s de todo, la memoria EEPROM innecesaria con sus 640 bytes est√° cerca.  Dividamos el c√≥digo del gestor de arranque en dos partes boot_FLASH y boot_EEPROM. <br><br>  Al cargar, el control se transfiere al c√≥digo boot_FLASH a $ 9FEF.  boot_FLASH copia la imagen del c√≥digo boot_EEPROM de EEPROM en la memoria RAM y le transfiere el control. <br><br>  Ahora boot_EEPROM configura UART 9600 8N1, espera los bytes UART y, sin esperar, transfiere el control al programa de aplicaci√≥n (dejaremos la direcci√≥n en el mismo lugar $ 9FFE: $ 9FFF). <br><br>  Si boot_EEPROM recibe un byte con el tama√±o del volcado esperado para la memoria RAM, recibe un volcado, coloca el volcado en otra √°rea de la memoria RAM y le transfiere el control. <br><br>  Adem√°s, todo es como en la primera etapa. <br><br><div class="spoiler">  <b class="spoiler_title">Archivo boot_FLASH_EEPROM.asm:</b> <div class="spoiler_text"><pre> <code class="hljs mel">stm8/ TITLE <span class="hljs-string"><span class="hljs-string">"boot_FLASH_EEPROM.asm"</span></span> .NOLIST #include <span class="hljs-string"><span class="hljs-string">"STM8S103F3P.inc"</span></span> .LIST MOTOROLA WORDS segment byte at <span class="hljs-number"><span class="hljs-number">4000</span></span> <span class="hljs-string"><span class="hljs-string">'eeprom'</span></span> ;  boot_EEPROM dc.b $35, $0D, $52, $32, $35, $0C, $52, $35 dc.b $35, $01, $52, $31, $5A, $27, $16, $72 dc.b $0B, $52, $30, $F8, $C6, $52, $31, $72 dc.b $0B, $52, $30, $FB, $3B, $52, $31, $4A dc.b $26, $F5, $96, $5C, $FC, $CE, $9F, $FE dc.b $2B, $FA, $90, $AE, $42, $7F, $AE, $02 dc.b $7F, $CC, $9F, $F4 segment byte at <span class="hljs-number"><span class="hljs-number">8000</span></span> <span class="hljs-string"><span class="hljs-string">'boot_start'</span></span> boot_start: jp boot_FLASH_start dc.b $01 ; boot_FLASH_EEPROM ; ******************************************************** ;  <span class="hljs-number"><span class="hljs-number">0x8004</span></span>..<span class="hljs-number"><span class="hljs-number">.0</span></span>x9FEE      segment byte at <span class="hljs-number"><span class="hljs-number">8004</span></span> <span class="hljs-string"><span class="hljs-string">'main_FLASH'</span></span> ;   main_FLASH_start: ldw X, #$03FF ldw SP, X mov UART1_BRR1, #<span class="hljs-number"><span class="hljs-number">13</span></span> mov UART1_CR2, #%00001100 main_FLASH_cycle: callr main_delay ;   bset PB_DDR,#<span class="hljs-number"><span class="hljs-number">5</span></span> bset PB_CR1,#<span class="hljs-number"><span class="hljs-number">5</span></span> ;   byte1_tx: mov UART1_DR, #$80 byte1_wait_tx btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">7</span></span>, byte1_wait_tx callr main_delay boot_RAM_exit1: ;   bres PB_DDR,#<span class="hljs-number"><span class="hljs-number">5</span></span> ; bres PB_CR1,#<span class="hljs-number"><span class="hljs-number">5</span></span> ; ;   byte2_tx: mov UART1_DR, #$08 byte2_wait_tx btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">7</span></span>, byte2_wait_tx jra main_FLASH_cycle main_delay: decw X jrne main_delay ret ;   EEPROM -&gt; RAM segment byte at <span class="hljs-number"><span class="hljs-number">9</span></span>FEF <span class="hljs-string"><span class="hljs-string">'boot_FLASH'</span></span> boot_FLASH_start: ldw X, SP ; Y &lt;- { EEPROM_START + RAM_END} ; Y &lt;- { $4000 + $03FF = $43FF } ldw Y, #$43FF boot_FLASH_copy: ld A, (Y) ld (X), A decw Y decw X jrpl boot_FLASH_copy incw X jp (X) boot_FLASH_exit_address: dc.w main_FLASH_start end ;</code> </pre><br></div></div><br>  Ejecute el archivo <a href="">runSTM8uLoader.bat</a> , presione el bot√≥n de reinicio en la placa, el gestor de arranque env√≠a el byte 0x01.  Se env√≠a un volcado con el c√≥digo del archivo main_RAM.hex a RAM STM8 a trav√©s de UART.  La placa comienza a parpadear el LED y env√≠a los bytes 0x20 y 0x02.  Presione el bot√≥n de reinicio nuevamente.  Se inicia el programa de aplicaci√≥n desde la memoria FLASH, el LED comienza a parpadear m√°s r√°pido y env√≠a los bytes 0x80 y 0x08. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/582/519/9bc/5825199bc0f6dfaf10b3e297e1339c06.png"></div><br><h4>  La tercera etapa.  Tama√±o del c√≥digo 18 bytes en memoria FLASH y 52 bytes en bytes de OPCI√ìN </h4><br>  Por supuesto, nos apuramos con la memoria EEPROM.  ¬øD√≥nde guardar los senos y otras mesas ahora?  Y con la memoria FLASH, no todo est√° claro.  ¬øQui√©n decidi√≥ almacenar la direcci√≥n de control de transferencia del programa de aplicaci√≥n en la memoria FLASH?  Y el mismo byte de la versi√≥n del gestor de arranque generalmente se almacena en dos lugares a la vez.  ¬øD√≥nde exprimir 52 bytes destinados a EEPROM? <br><br>  Aqu√≠ la litograf√≠a nos ayuda.  La memoria EEPROM consta de 10 bloques de 64 bytes cada uno.  Agregar otro bloque a estos bloques, pero con un tama√±o diferente, no es econ√≥micamente factible.  STMicroelectronics hizo exactamente eso, agreg√≥ otro bloque de 64 bytes, llam√≥ a esta √°rea Bytes de OPCI√ìN y almacena all√≠ importantes configuraciones de microcontroladores no vol√°tiles (para STM8S103F3 es de hasta 11 bytes).  Y, por supuesto, STM olvid√≥ mencionar que todav√≠a quedan 53 c√©lulas funcionales en esta √°rea.  Aparentemente hay muchos modelos STM8, debe dejar espacio para futuras configuraciones importantes. <br><br>  Nuestro gestor de arranque solo reclama el modelo STM8 sin gestores de arranque integrados.  Por lo tanto, tomamos las celdas de respaldo del bloque OPTION Bytes hasta ahora que nadie ve.  Es cierto que hay un peque√±o inconveniente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pero resuelto</a> .  Un programador convencional no le permitir√° escribir informaci√≥n en estas celdas. <br><br>  Al cargar, el control se transfiere al c√≥digo copy_boot_FLASH inicial a $ 9FF2.  boot_FLASH transfiere la imagen del cargador de arranque boot_OPTION desde el √°rea de Bytes de OPCI√ìN a la RAM. <br><br>  boot_OPTION configura el UART 9600 8N1, env√≠a el byte UART con su versi√≥n, espera los bytes UART del programa host y, sin esperar 0.2 segundos, transfiere el control al programa de aplicaci√≥n en la direcci√≥n ubicada en el par $ 4831: $ 4832. <br><br>  Si boot_OPTION, despu√©s de enviar un byte con su versi√≥n, toma un byte del tama√±o del volcado esperado, luego toma el volcado en s√≠, lo coloca en la memoria RAM y le transfiere el control. <br>  Adem√°s, toda la atenci√≥n recae en el programa en la computadora y el volcado que env√≠a.  Deber√≠a enviar exactamente los volcados necesarios para completar la tarea actual (leer / borrar / escribir / copiar celdas de memoria STM8).  Los volcados deber√≠an poder reemplazarse entre s√≠ en la memoria RAM y transferir el control al programa de aplicaci√≥n. <br><br>  La direcci√≥n de transici√≥n a la solicitud es $ 4831: $ 4832. <br><br><div class="spoiler">  <b class="spoiler_title">Cargador y c√≥digo de aplicaci√≥n para ejecutar en la memoria FLASH:</b> <div class="spoiler_text"><pre> <code class="hljs mel">stm8/ TITLE <span class="hljs-string"><span class="hljs-string">"boot_FLASH_OPTION.asm"</span></span> .NOLIST #include <span class="hljs-string"><span class="hljs-string">"STM8S103F3P.inc"</span></span> .LIST MOTOROLA WORDS segment byte at <span class="hljs-number"><span class="hljs-number">4800</span></span> <span class="hljs-string"><span class="hljs-string">'boot_OPTION'</span></span> ;    boot_OPTION dc.b $00, $00, $FF, $00, $FF, $00, $FF, $00 dc.b $FF, $00, $FF, $35, $0D, $52, $32, $35 dc.b $0C, $52, $35, $35, $25, $52, $31, $5A dc.b $27, $16, $72, $0B, $52, $30, $F8, $C6 dc.b $52, $31, $72, $0B, $52, $30, $FB, $3B dc.b $52, $31, $4A, $26, $F5, $96, $5C, $FC dc.b $AE, $80, $04, $2B, $FA, $90, $AE, $42 dc.b $7F, $AE, $02, $7F, $CC, $9F, $F6, $00 segment byte at <span class="hljs-number"><span class="hljs-number">8000</span></span> <span class="hljs-string"><span class="hljs-string">'boot_start'</span></span> boot_start: ldw X, SP jp boot_FLASH_start ; ******************************************************** ;  <span class="hljs-number"><span class="hljs-number">0x8004</span></span>..<span class="hljs-number"><span class="hljs-number">.0</span></span>x9FF1      segment byte at <span class="hljs-number"><span class="hljs-number">8004</span></span> <span class="hljs-string"><span class="hljs-string">'main_FLASH'</span></span> ;   main_FLASH_start: ldw X, #$03FF ldw SP, X mov UART1_BRR1, #<span class="hljs-number"><span class="hljs-number">13</span></span> mov UART1_CR2, #%00001100 main_FLASH_cycle: callr main_delay ;   bset PB_DDR,#<span class="hljs-number"><span class="hljs-number">5</span></span> bset PB_CR1,#<span class="hljs-number"><span class="hljs-number">5</span></span> ;   byte1_tx: mov UART1_DR, #$80 byte1_wait_tx btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">7</span></span>, byte1_wait_tx callr main_delay boot_RAM_exit1: ;   bres PB_DDR,#<span class="hljs-number"><span class="hljs-number">5</span></span> ; bres PB_CR1,#<span class="hljs-number"><span class="hljs-number">5</span></span> ; ;   byte2_tx: mov UART1_DR, #$08 byte2_wait_tx btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">7</span></span>, byte2_wait_tx jra main_FLASH_cycle main_delay: decw X jrne main_delay ret ;   OPTION -&gt; RAM segment byte at <span class="hljs-number"><span class="hljs-number">9</span></span>FF2 <span class="hljs-string"><span class="hljs-string">'boot_FLASH'</span></span> boot_FLASH_start: ; Y &lt;- { OPTION_START + RAM_END} ; Y &lt;- { $4800 + $03FF = $43FF } ldw Y, #$43FF boot_FLASH_copy: ld A, (Y) ld (X), A decw Y decw X jrpl boot_FLASH_copy incw X jp (X) boot_FLASH_exit_address: dc.w main_FLASH_start end ;</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">C√≥digo de aplicaci√≥n para ejecuci√≥n en memoria RAM:</b> <div class="spoiler_text"><pre> <code class="hljs 1c">stm8/ TITLE ‚Äúboot_RAM.asm‚Äù MOTOROLA <span class="hljs-meta"><span class="hljs-meta">#include "STM8S103F3P.inc" BYTES segment byte at 0000 'boot_RAM_data' boot_RAM_start: ;  pull-up   (</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">  </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">   ) </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta"> ,   ,  14  ; ld A, #%01001100 ; [A6 4C] ; cpl A ; [43] ; ld PA_CR1, A ; [C7 50 03] ; ld PB_CR1, A ; [C7 50 08] ; ld PC_CR1, A ; [C7 50 0D] ; ld PD_CR1, A ; [C7 50 12]   PD6(UART1_RX), PD2, PD1 ;  UART1  /   9600,   </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">  (8 ,   , 1  ) ; mov UART1_BRR2, #0 ; [35 00 52 33] </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta"> Fmaster=16/8=2  9600 mov UART1_BRR1, #13 ; [35 0D 52 32] </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta"> Fmaster=16/8=2  9600 mov UART1_CR2, #%00001100 ; [35 0C 52 35] UART1_CR2.TEN &lt;- 1 UART1_CR2.REN &lt;- 1  / ;   </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta"> UART1 boot_RAM_byte1_tx: mov UART1_DR, #$02 boot_RAM_byte1_wait_tx btjf UART1_SR, #7, boot_RAM_byte1_wait_tx ldw X,#0 ; [AE 00 00] boot_FLASH     X boot_RAM_wait1: decw X ; [5A] jreq boot_RAM_exit1 ; jra boot_RAM_wait1 boot_RAM_exit1: ;   bres PB_DDR,#5 ; bres PB_CR1,#5 ; ;   </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta"> UART1 boot_RAM_byte2_tx: mov UART1_DR, #$20 ; [35 11 52 31] boot_RAM_byte2_wait_tx btjf UART1_SR, #7, boot_RAM_byte2_wait_tx ldw X,#0 ; [AE 00 00] boot_FLASH     X boot_RAM_wait2: decw X ; [5A] jreq boot_RAM_exit2 ; jra boot_RAM_wait2 boot_RAM_exit2: ;   bset PB_DDR,#5 ; bset PB_CR1,#5 ; jra boot_RAM_byte1_tx end</span></span></code> </pre> </div></div><br>  Ejecute el archivo <a href="">runSTM8uLoader.bat</a> , presione el bot√≥n de reinicio en el tablero, el gestor de arranque env√≠a el byte 0x25.  Se env√≠a un volcado con el c√≥digo del archivo main_RAM.hex a RAM STM8 a trav√©s de UART.  La placa comienza a parpadear el LED y env√≠a los bytes 0x20 y 0x02.  Presione el bot√≥n de reinicio nuevamente.  Se inicia el programa de aplicaci√≥n desde la memoria FLASH, el LED comienza a parpadear m√°s r√°pido y env√≠a los bytes 0x80 y 0x08. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab1/ceb/14d/ab1ceb14d6c5aa19ad29084223298e07.png"></div><br>  En la √∫ltima etapa, para escribir la imagen del cargador de arranque en el √°rea Bytes de OPCI√ìN, debe usar el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">m√©todo</a> .  La esencia del m√©todo es que primero necesita que el programador escriba el archivo de firmware boot_OPTION_rev25.hex en la memoria STM8 FLAH, reinicie el microcontrolador, el √°rea de Bytes de OPCI√ìN se llenar√° con la informaci√≥n necesaria y el LED se encender√°.  Por otra parte, el programador escribe en el archivo de firmware FLASH desde este art√≠culo <a href="">boot_FLASH_OPTION.hex</a> . <br><br>  Se agreg√≥ el c√≥digo de cargador de arranque "limpio" versi√≥n 0x14 sin c√≥digo de aplicaci√≥n.  Despleg√≥ la imagen boot_OPTION en el c√≥digo fuente.  Comentarios corregidos  A diferencia de la versi√≥n de $ 25, la direcci√≥n de transferencia de control de la aplicaci√≥n se encuentra en las celdas FLASH de $ 9FFE: $ 9FFFF.  El tama√±o en FLASH es de 20 bytes, respectivamente. <br><div class="spoiler">  <b class="spoiler_title">boot_uC_rev14.asm:</b> <div class="spoiler_text"><pre> <code class="hljs mel">stm8/ TITLE <span class="hljs-string"><span class="hljs-string">"boot_uC_rev14.asm"</span></span> ; boot_uC = boot_OPTION + boot_FLASH MOTOROLA .NOLIST #include <span class="hljs-string"><span class="hljs-string">"STM8S103F3P.inc"</span></span> .LIST WORDS ; ******************************************************** segment byte at <span class="hljs-number"><span class="hljs-number">4800</span></span> <span class="hljs-string"><span class="hljs-string">'boot_O_IMG'</span></span> ;<span class="hljs-number"><span class="hljs-number">0000</span></span>FF00FF00FF00FF00FF350D523235 ;<span class="hljs-number"><span class="hljs-number">0</span></span>C5235351452315A2716720B5230F8C6 ;<span class="hljs-number"><span class="hljs-number">5231720</span></span>B5230FB3B52314A26F5965CFC ;CE9FFE2BFA90AE427FAE027FCC9FF400 ;    ; $4800    RAM dc.b $00, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF ; OPTION (RAM) ; $480B ($0000)    boot_O boot_O_start: ;  UART <span class="hljs-number"><span class="hljs-number">96008</span></span>N1 Fmaster=<span class="hljs-number"><span class="hljs-number">16</span></span>/<span class="hljs-number"><span class="hljs-number">8</span></span>=<span class="hljs-number"><span class="hljs-number">2</span></span>/<span class="hljs-number"><span class="hljs-number">9600</span></span>/<span class="hljs-number"><span class="hljs-number">16</span></span> ; mov UART1_BRR2, #<span class="hljs-number"><span class="hljs-number">0</span></span> ; [<span class="hljs-number"><span class="hljs-number">35</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">33</span></span>]     mov UART1_BRR1, #<span class="hljs-number"><span class="hljs-number">13</span></span> ; [<span class="hljs-number"><span class="hljs-number">35</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>D <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span>] ; UART1_CR2.TEN &lt;- <span class="hljs-number"><span class="hljs-number">1</span></span> UART1_CR2.REN &lt;- <span class="hljs-number"><span class="hljs-number">1</span></span>  / mov UART1_CR2, #%00001100 ; [<span class="hljs-number"><span class="hljs-number">35</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>C <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">35</span></span>] ; $4813 ($0008) boot_E_byte1_tx: ;   $14  mov UART1_DR, #$14 ; [<span class="hljs-number"><span class="hljs-number">35</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span> <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span>] ;    ,     ;      ;  X   ( <span class="hljs-number"><span class="hljs-number">200</span></span> ) ; clrw X ; [<span class="hljs-number"><span class="hljs-number">5</span></span>F]  X   boot_F ; $4817 ($000C) boot_O_rx_wait_byte: decw X ; [<span class="hljs-number"><span class="hljs-number">5</span></span>A] jreq boot_O_exit ; [<span class="hljs-number"><span class="hljs-number">27</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>]       btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">5</span></span>, boot_O_rx_wait_byte ; [<span class="hljs-number"><span class="hljs-number">72</span></span> OB <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span> F8] ;   ,   ,  A    ; $481F ($0014) ld A, UART1_DR ; [C6 <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span>] ; $4822 ($0017)    boot_O_rx_wait_block: btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">5</span></span>, boot_O_rx_wait_block ; [<span class="hljs-number"><span class="hljs-number">72</span></span> OB <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span> FB] push UART1_DR ; [<span class="hljs-number"><span class="hljs-number">3</span></span>B <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span>] dec A ; [<span class="hljs-number"><span class="hljs-number">4</span></span>A] ;      A      jrne boot_O_rx_wait_block ; [<span class="hljs-number"><span class="hljs-number">26</span></span> F5] ; $482D ($0022)      ldw X, SP ; [<span class="hljs-number"><span class="hljs-number">96</span></span>] incw X ; [<span class="hljs-number"><span class="hljs-number">5</span></span>C] boot_O_exit_to_FLASH: jp (X) ; [FC] ; $4830 ($0025)     boot_O_exit: ldw X, boot_F_exit_address ; [CE <span class="hljs-number"><span class="hljs-number">9</span></span>F FE] jrmi boot_O_exit_to_FLASH ; [<span class="hljs-number"><span class="hljs-number">2</span></span>B FA] ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> X &lt; $8000     $0000 ;     EEPROM boot_O_exit_to_EEPROM: ; Y &lt;- { EEPROM_END} ldw Y, #$427F ; [<span class="hljs-number"><span class="hljs-number">90</span></span> AE <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>F] ; X &lt;- { EEPROM_END - EEPROM_START } ;   EEPROM  RAM ldw X, #$027F ; [AE <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>F] jp boot_F_copy ; [CC <span class="hljs-number"><span class="hljs-number">9</span></span>F F4] ; $483F ($0034) dc.b $00 ;   boot_O_end: ; ******************************************************** segment byte at <span class="hljs-number"><span class="hljs-number">8000</span></span> <span class="hljs-string"><span class="hljs-string">'RESET_vector'</span></span> ;<span class="hljs-number"><span class="hljs-number">96</span></span>CC9FF0 ldw X, SP ; [<span class="hljs-number"><span class="hljs-number">96</span></span>] X &lt;- RAM_END jp boot_F_start ; [CC <span class="hljs-number"><span class="hljs-number">9</span></span>F F0] ; ******************************************************** ;  <span class="hljs-number"><span class="hljs-number">0x8004</span></span>..<span class="hljs-number"><span class="hljs-number">.0</span></span>x9FEF      segment byte at <span class="hljs-number"><span class="hljs-number">8004</span></span> <span class="hljs-string"><span class="hljs-string">'main_FLASH'</span></span> ;<span class="hljs-number"><span class="hljs-number">20</span></span>FE jra * ; [<span class="hljs-number"><span class="hljs-number">20</span></span> FE] ; ******************************************************** ;   boot_FLASH segment byte at <span class="hljs-number"><span class="hljs-number">9</span></span>FF0 <span class="hljs-string"><span class="hljs-string">'boot_F'</span></span> ;<span class="hljs-number"><span class="hljs-number">90</span></span>AE4C0A90F6F7905A5A2AF85CFC8004 boot_F_start: ; Y &lt;- { boot_O_START + RAM_END} { $480B + $03FF = $4C0A } ldw Y, #$4C0A ; [<span class="hljs-number"><span class="hljs-number">90</span></span> AE <span class="hljs-number"><span class="hljs-number">4</span></span>C <span class="hljs-number"><span class="hljs-number">0</span></span>A] ;     ; boot_FLASH, boot_OPTION      boot_F_copy: ld A, (Y) ; [<span class="hljs-number"><span class="hljs-number">90</span></span> F6] ld (X), A ; [F7] decw Y ; [<span class="hljs-number"><span class="hljs-number">90</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>A] decw X ; [<span class="hljs-number"><span class="hljs-number">5</span></span>A] jrpl boot_F_copy ; [<span class="hljs-number"><span class="hljs-number">2</span></span>A F8]  X(Y) &gt;= RAM_START(boot_O_START) incw X ; [<span class="hljs-number"><span class="hljs-number">5</span></span>C] jp (X) ; [FC] boot_F_exit_address: dc.w $8004 ; [<span class="hljs-number"><span class="hljs-number">80</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span>] ; dc.w $0000 ; [<span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span>] end ;</code> </pre></div></div><br>  Se agreg√≥ un c√≥digo de cargador de arranque "limpio" versi√≥n 0x25 sin c√≥digo de aplicaci√≥n.  Despleg√≥ la imagen boot_OPTION en el c√≥digo fuente.  Comentarios corregidos  A diferencia de la versi√≥n de $ 14, la direcci√≥n de transferencia de control de la aplicaci√≥n se encuentra en las celdas $ 4831: $ 4832 del √°rea OPTION Bytes.  El tama√±o ocupado en la memoria FLASH, respectivamente, disminuy√≥ a 18 bytes.  El tama√±o ocupado en el √°rea de Bytes de OPCI√ìN no ha cambiado (52 bytes + 1 reserva). <br><div class="spoiler">  <b class="spoiler_title">boot_uC_rev14.asm:</b> <div class="spoiler_text"><pre> <code class="hljs mel">stm8/ TITLE <span class="hljs-string"><span class="hljs-string">"boot_uC_rev25.asm"</span></span> ; boot_uC = boot_OPTION + boot_FLASH MOTOROLA .NOLIST #include <span class="hljs-string"><span class="hljs-string">"STM8S103F3P.inc"</span></span> .LIST BYTES ; ******************************************************** ;        EEPROM  ; boot_O_exit_address    $0000 (   &lt;$8000) ;       ;          segment byte at <span class="hljs-number"><span class="hljs-number">0000</span></span> <span class="hljs-string"><span class="hljs-string">'boot_O_IMG'</span></span> main_ram: ;<span class="hljs-number"><span class="hljs-number">20</span></span>FE jra * ; [<span class="hljs-number"><span class="hljs-number">20</span></span> FE] WORDS ; ******************************************************** segment byte at <span class="hljs-number"><span class="hljs-number">4800</span></span> <span class="hljs-string"><span class="hljs-string">'boot_O_IMG'</span></span> ;<span class="hljs-number"><span class="hljs-number">0000</span></span>FF00FF00FF00FF00FF350D523235 ;<span class="hljs-number"><span class="hljs-number">0</span></span>C5235351452315A2716720B5230F8C6 ;<span class="hljs-number"><span class="hljs-number">5231720</span></span>B5230FB3B52314A26F5965CFC ;AE80042BFA90AE427FAE027FCC9FF600 ;    ; $4800    RAM dc.b $00, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF ; OPTION (RAM) ; $480B ($0000)    boot_OPTION boot_O_start: ;  UART <span class="hljs-number"><span class="hljs-number">96008</span></span>N1 Fmaster=<span class="hljs-number"><span class="hljs-number">16</span></span>/<span class="hljs-number"><span class="hljs-number">8</span></span>=<span class="hljs-number"><span class="hljs-number">2</span></span>/<span class="hljs-number"><span class="hljs-number">9600</span></span>/<span class="hljs-number"><span class="hljs-number">16</span></span> ; mov UART1_BRR2, #<span class="hljs-number"><span class="hljs-number">0</span></span> ; [<span class="hljs-number"><span class="hljs-number">35</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">33</span></span>]     mov UART1_BRR1, #<span class="hljs-number"><span class="hljs-number">13</span></span> ; [<span class="hljs-number"><span class="hljs-number">35</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>D <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span>] ; UART1_CR2.TEN &lt;- <span class="hljs-number"><span class="hljs-number">1</span></span> UART1_CR2.REN &lt;- <span class="hljs-number"><span class="hljs-number">1</span></span>  / mov UART1_CR2, #%00001100 ; [<span class="hljs-number"><span class="hljs-number">35</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>C <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">35</span></span>] ; $4813 ($0008) boot_E_byte1_tx: ;   $14  mov UART1_DR, #$14 ; [<span class="hljs-number"><span class="hljs-number">35</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span> <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span>] ;    ,     ;      ;  X   ( <span class="hljs-number"><span class="hljs-number">200</span></span> ) ; clrw X ; [<span class="hljs-number"><span class="hljs-number">5</span></span>F]  X   boot_F ; $4817 ($000C) boot_O_rx_wait_byte: decw X ; [<span class="hljs-number"><span class="hljs-number">5</span></span>A] jreq boot_O_exit ; [<span class="hljs-number"><span class="hljs-number">27</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>]       btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">5</span></span>, boot_O_rx_wait_byte ; [<span class="hljs-number"><span class="hljs-number">72</span></span> OB <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span> F8] ;   ,   ,  A    ; $481F ($0014) ld A, UART1_DR ; [C6 <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span>] ; $4822 ($0017)    boot_O_rx_wait_block: btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">5</span></span>, boot_O_rx_wait_block ; [<span class="hljs-number"><span class="hljs-number">72</span></span> OB <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span> FB] push UART1_DR ; [<span class="hljs-number"><span class="hljs-number">3</span></span>B <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span>] dec A ; [<span class="hljs-number"><span class="hljs-number">4</span></span>A] ;      A      jrne boot_O_rx_wait_block ; [<span class="hljs-number"><span class="hljs-number">26</span></span> F5] ; $482D ($0022)      ldw X, SP ; [<span class="hljs-number"><span class="hljs-number">96</span></span>] incw X ; [<span class="hljs-number"><span class="hljs-number">5</span></span>C] boot_O_exit_to_FLASH: jp (X) ; [FC] ; $4830 ($0025)     boot_O_exit: dc.b $AE ; ldw X, #boot_O_exit_address ; [AE <span class="hljs-number"><span class="hljs-number">80</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span>] ; $4831 ($0026) ;      boot_O_exit_address: dc.w main_flash ; [<span class="hljs-number"><span class="hljs-number">80</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span>] ; dc.w main_ram ; [<span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span>] jrmi boot_O_exit_to_FLASH ; [<span class="hljs-number"><span class="hljs-number">2</span></span>B FA] ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> X &lt; $8000     $0000 ;     EEPROM boot_O_exit_to_EEPROM: ; Y &lt;- { EEPROM_END} ldw Y, #$427F ; [<span class="hljs-number"><span class="hljs-number">90</span></span> AE <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>F] ; X &lt;- { EEPROM_END - EEPROM_START } ;   EEPROM  RAM ldw X, #$027F ; [AE <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>F] jp boot_F_copy ; [CC <span class="hljs-number"><span class="hljs-number">9</span></span>F F4] ; $483F ($0034) dc.b $00 ;   boot_O_end: ; ******************************************************** segment byte at <span class="hljs-number"><span class="hljs-number">8000</span></span><span class="hljs-number"><span class="hljs-number">-8003</span></span> <span class="hljs-string"><span class="hljs-string">'RESET_vector'</span></span> ;<span class="hljs-number"><span class="hljs-number">96</span></span>CC9FF2 ldw X, SP ; [<span class="hljs-number"><span class="hljs-number">96</span></span>] X &lt;- RAM_END jp boot_F_start ; [CC <span class="hljs-number"><span class="hljs-number">9</span></span>F F2] ; ******************************************************** ;  <span class="hljs-number"><span class="hljs-number">0x8004</span></span>..<span class="hljs-number"><span class="hljs-number">.0</span></span>x9FF1      segment byte at <span class="hljs-number"><span class="hljs-number">8004</span></span> <span class="hljs-string"><span class="hljs-string">'main_FLASH'</span></span> main_flash: ;<span class="hljs-number"><span class="hljs-number">20</span></span>FE jra * ; [<span class="hljs-number"><span class="hljs-number">20</span></span> FE] ; ******************************************************** ;   boot_FLASH segment byte at <span class="hljs-number"><span class="hljs-number">9</span></span>FF2<span class="hljs-number"><span class="hljs-number">-9</span></span>FFF <span class="hljs-string"><span class="hljs-string">'boot_F'</span></span> ;<span class="hljs-number"><span class="hljs-number">90</span></span>AE4C0A90F6F7905A5A2AF85CFC boot_F_start: ; Y &lt;- { boot_O_START + RAM_END} { $480B + $03FF = $4C0A } ldw Y, #$4C0A ; [<span class="hljs-number"><span class="hljs-number">90</span></span> AE <span class="hljs-number"><span class="hljs-number">4</span></span>C <span class="hljs-number"><span class="hljs-number">0</span></span>A] ;     ; boot_FLASH, boot_OPTION      boot_F_copy: ld A, (Y) ; [<span class="hljs-number"><span class="hljs-number">90</span></span> F6] ld (X), A ; [F7] decw Y ; [<span class="hljs-number"><span class="hljs-number">90</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>A] decw X ; [<span class="hljs-number"><span class="hljs-number">5</span></span>A] jrpl boot_F_copy ; [<span class="hljs-number"><span class="hljs-number">2</span></span>A F8]  X(Y) &gt;= RAM_START(boot_O_START) incw X ; [<span class="hljs-number"><span class="hljs-number">5</span></span>C] jp (X) ; [FC] end ;</code> </pre></div></div><br>  La direcci√≥n de transferencia de control de la aplicaci√≥n en la memoria FLASH se puede seleccionar del rango de $ 8004 ... $ 9FF1.  Para una imagen de c√≥digo de aplicaci√≥n de la memoria EEPROM, la transferencia de control solo es posible en la direcci√≥n $ 0000 en la memoria RAM. <br>  El programa host puede pasar cualquier direcci√≥n de transferencia de control como el segundo argumento de l√≠nea de comando. <br>  El c√≥digo fuente del programa host se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .  Tambi√©n hay contactos para una comunicaci√≥n m√°s detallada. <br>  Pido a los lectores cr√≠ticas espec√≠ficas y sugerencias para una mayor reducci√≥n del c√≥digo. <br><br>  Tambi√©n propongo leer el art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"C√≥mo comprimir el gestor de arranque para STM8 al tama√±o de 8 bytes en la memoria FLASH"</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es417493/">https://habr.com/ru/post/es417493/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es417481/index.html">Acerca de los generadores en JavaScript ES6, y por qu√© es opcional estudiarlos</a></li>
<li><a href="../es417483/index.html">Comparaci√≥n de marcos JS: React, Vue e Hyperapp</a></li>
<li><a href="../es417485/index.html">[marcador] Cheat sheet del administrador del sistema para herramientas de red Linux</a></li>
<li><a href="../es417487/index.html">El lugar donde comenz√≥ la Internet rusa</a></li>
<li><a href="../es417489/index.html">Informe del Club de Roma 2018, Cap√≠tulo 3.4: ‚ÄúEnerg√≠a descentralizada‚Äù</a></li>
<li><a href="../es417495/index.html">Los equipos rusos y ucranianos prevalecieron sobre los europeos en la final europea de la competencia InnovateFPGA de Intel</a></li>
<li><a href="../es417497/index.html">4 a√±os de Data Science en Schibsted Media Group</a></li>
<li><a href="../es417501/index.html">Lifehacks fabricando tableros de dos capas (LUT)</a></li>
<li><a href="../es417503/index.html">Lo que un desarrollador web debe recordar hacer SEO-Feng Shui</a></li>
<li><a href="../es417505/index.html">Intel lanza parches para nuevas vulnerabilidades de firmware de ME</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>