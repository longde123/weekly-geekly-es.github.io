<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📣 🧙🏼 🎰 Cómo comprimir el gestor de arranque para STM8 a un tamaño de 18 bytes en la memoria FLASH 🚐 😽 🍲</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En el proceso de búsqueda del gestor de arranque para el microcontrolador STM8S103F3, se descubrió que los gestores de arranque disponibles están escr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cómo comprimir el gestor de arranque para STM8 a un tamaño de 18 bytes en la memoria FLASH</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417493/">  En el proceso de búsqueda del gestor de arranque para el microcontrolador STM8S103F3, se descubrió que los gestores de arranque disponibles están escritos principalmente en "C", "roban" una cantidad significativa de memoria FLASH y transfieren la tabla de vectores de interrupción. <br><br>  El gestor de arranque era necesario para algún dispositivo al que es imposible conectar el programador. <br><br>  Se decidió intentar escribir un gestor de arranque usted mismo con los siguientes requisitos: <br><br>  - el cargador debería llamarse STM8uLoader; <br>  - El código debe estar escrito en ensamblador (el beneficio del ensamblador aún no está legalmente prohibido); <br>  - el gestor de arranque debe ocupar la menor cantidad posible en la memoria FLASH, la cantidad ocupada en la computadora se considerará ilimitada; <br>  - el cargador no debe mover la tabla de vectores de interrupción; <br>  - el gestor de arranque debe tener una funcionalidad mínima, toda la funcionalidad principal debe ser asumida por la computadora; <br>  - el gestor de arranque debe transferir el control al programa de aplicación dentro de un tiempo razonable después de un reinicio / encendido si no hay conexión a la computadora. <br><br>  La primera condición se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cumplió</a> instantáneamente, pero los requisitos posteriores tuvieron que ser trabajados. <br><a name="habracut"></a><br><h4>  Primera etapa  Código de 65 bytes en la memoria FLASH </h4><br>  Para guardar la tabla de vectores en su lugar, se decidió colocar el código al final de la memoria FLASH y cambiarlo inmediatamente desde el vector de volcado $ 8000. <br><br>  En el arranque, el control se transfiere al código del cargador de arranque a $ 9FC2.  El gestor de arranque configura el UART 9600 8N1, espera dos bytes en el UART y, sin esperar, transfiere el control al programa de aplicación en la dirección almacenada en el par $ 9FFE: $ 9FFF. <br><br>  Si el cargador recibe los bytes alto y bajo del tamaño del volcado esperado del programa host, lo hace, lo deposita en la memoria RAM y le transfiere el control. <br>  Además, toda la atención recae en el programa en la computadora y el volcado que envía.  Debería enviar exactamente los volcados necesarios para completar la tarea actual (leer / borrar / escribir / copiar celdas de memoria STM8).  Los volcados deberían poder reemplazarse entre sí en la memoria RAM y transferir el control al programa de aplicación. <br><br>  La dirección de transición a la aplicación es $ 9FFE: $ 9FFF. <br><br><div class="spoiler">  <b class="spoiler_title">El archivo boot_FLASH.asm:</b> <div class="spoiler_text"><pre><code class="hljs mel">stm8/ TITLE <span class="hljs-string"><span class="hljs-string">"boot_FLASH.asm"</span></span> .NOLIST #include <span class="hljs-string"><span class="hljs-string">"STM8S103F3P.inc"</span></span> .LIST MOTOROLA WORDS segment byte at <span class="hljs-number"><span class="hljs-number">8000</span></span> <span class="hljs-string"><span class="hljs-string">'boot_start'</span></span> boot_start: jp boot_FLASH_start dc.b $00 ; boot_FLASH ; ******************************************************** ;  <span class="hljs-number"><span class="hljs-number">0x8004</span></span>..<span class="hljs-number"><span class="hljs-number">.0</span></span>x9FC1      WORDS ; segment byte at <span class="hljs-number"><span class="hljs-number">8004</span></span> <span class="hljs-string"><span class="hljs-string">'main_FLASH'</span></span> main_FLASH_start: ldw X, #$03FF ldw SP, X mov UART1_BRR1, #<span class="hljs-number"><span class="hljs-number">13</span></span> mov UART1_CR2, #%00001100 main_FLASH_cycle: callr main_delay ;   bset PB_DDR,#<span class="hljs-number"><span class="hljs-number">5</span></span> bset PB_CR1,#<span class="hljs-number"><span class="hljs-number">5</span></span> ;   byte1_tx: mov UART1_DR, #$80 byte1_wait_tx btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">7</span></span>, byte1_wait_tx callr main_delay boot_RAM_exit1: ;   bres PB_DDR,#<span class="hljs-number"><span class="hljs-number">5</span></span> ; bres PB_CR1,#<span class="hljs-number"><span class="hljs-number">5</span></span> ; ;   byte2_tx: mov UART1_DR, #$08 byte2_wait_tx btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">7</span></span>, byte2_wait_tx jra main_FLASH_cycle main_delay: decw X jrne main_delay ret segment byte at <span class="hljs-number"><span class="hljs-number">9</span></span>FC2 <span class="hljs-string"><span class="hljs-string">'boot_FLASH'</span></span> boot_FLASH_start: mov UART1_BRR1, #<span class="hljs-number"><span class="hljs-number">13</span></span>; Fmaster=<span class="hljs-number"><span class="hljs-number">16</span></span>/<span class="hljs-number"><span class="hljs-number">8</span></span>=<span class="hljs-number"><span class="hljs-number">2</span></span>/<span class="hljs-number"><span class="hljs-number">9600</span></span>/<span class="hljs-number"><span class="hljs-number">16</span></span> mov UART1_CR2, #%00001100;  / ;   UART1   RST_SR boot_FLASH_RST_SR_tx: mov UART1_DR, RST_SR ;    ,      ;      ;    X    ( <span class="hljs-number"><span class="hljs-number">200</span></span> ) ldw X,#<span class="hljs-number"><span class="hljs-number">0</span></span> boot_FLASH_wait_byte1: decw X jreq boot_FLASH_exit;       btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">5</span></span>, boot_FLASH_wait_byte1 ;   ,   , ;  X     ld A, UART1_DR ld XH, A ;      boot_FLASH_wait_byte2: btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">5</span></span>, boot_FLASH_wait_byte2 ;    ld A, UART1_DR ld XL, A ;  X -    ;   X       ldw Y, #$0400 ;  Y   <span class="hljs-number"><span class="hljs-number">0x0400</span></span> (RAM_END + <span class="hljs-number"><span class="hljs-number">1</span></span>) ;    boot_FLASH_rx_block_wait: btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">5</span></span>, boot_FLASH_rx_block_wait boot_EEPROM_rx_block_entry: decw Y ;      Y     ld A, UART1_DR ld (Y), A decw X ;      X      jrne boot_FLASH_rx_block_wait ;      jp (Y) ;    ()  boot_FLASH_exit: dc.b $CC boot_FLASH_exit_addr: dc.w main_FLASH_start end ;</code> </pre> <br></div></div><br><h4>  Segunda etapa.  Tamaño de código 21 bytes en FLASH y 52 bytes en memoria EEPROM </h4><br>  Seleccionar 65 bytes de la memoria FLASH (en STM8S103F3 es solo 8192 bytes) no es humano.  Después de todo, la memoria EEPROM innecesaria con sus 640 bytes está cerca.  Dividamos el código del gestor de arranque en dos partes boot_FLASH y boot_EEPROM. <br><br>  Al cargar, el control se transfiere al código boot_FLASH a $ 9FEF.  boot_FLASH copia la imagen del código boot_EEPROM de EEPROM en la memoria RAM y le transfiere el control. <br><br>  Ahora boot_EEPROM configura UART 9600 8N1, espera los bytes UART y, sin esperar, transfiere el control al programa de aplicación (dejaremos la dirección en el mismo lugar $ 9FFE: $ 9FFF). <br><br>  Si boot_EEPROM recibe un byte con el tamaño del volcado esperado para la memoria RAM, recibe un volcado, coloca el volcado en otra área de la memoria RAM y le transfiere el control. <br><br>  Además, todo es como en la primera etapa. <br><br><div class="spoiler">  <b class="spoiler_title">Archivo boot_FLASH_EEPROM.asm:</b> <div class="spoiler_text"><pre> <code class="hljs mel">stm8/ TITLE <span class="hljs-string"><span class="hljs-string">"boot_FLASH_EEPROM.asm"</span></span> .NOLIST #include <span class="hljs-string"><span class="hljs-string">"STM8S103F3P.inc"</span></span> .LIST MOTOROLA WORDS segment byte at <span class="hljs-number"><span class="hljs-number">4000</span></span> <span class="hljs-string"><span class="hljs-string">'eeprom'</span></span> ;  boot_EEPROM dc.b $35, $0D, $52, $32, $35, $0C, $52, $35 dc.b $35, $01, $52, $31, $5A, $27, $16, $72 dc.b $0B, $52, $30, $F8, $C6, $52, $31, $72 dc.b $0B, $52, $30, $FB, $3B, $52, $31, $4A dc.b $26, $F5, $96, $5C, $FC, $CE, $9F, $FE dc.b $2B, $FA, $90, $AE, $42, $7F, $AE, $02 dc.b $7F, $CC, $9F, $F4 segment byte at <span class="hljs-number"><span class="hljs-number">8000</span></span> <span class="hljs-string"><span class="hljs-string">'boot_start'</span></span> boot_start: jp boot_FLASH_start dc.b $01 ; boot_FLASH_EEPROM ; ******************************************************** ;  <span class="hljs-number"><span class="hljs-number">0x8004</span></span>..<span class="hljs-number"><span class="hljs-number">.0</span></span>x9FEE      segment byte at <span class="hljs-number"><span class="hljs-number">8004</span></span> <span class="hljs-string"><span class="hljs-string">'main_FLASH'</span></span> ;   main_FLASH_start: ldw X, #$03FF ldw SP, X mov UART1_BRR1, #<span class="hljs-number"><span class="hljs-number">13</span></span> mov UART1_CR2, #%00001100 main_FLASH_cycle: callr main_delay ;   bset PB_DDR,#<span class="hljs-number"><span class="hljs-number">5</span></span> bset PB_CR1,#<span class="hljs-number"><span class="hljs-number">5</span></span> ;   byte1_tx: mov UART1_DR, #$80 byte1_wait_tx btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">7</span></span>, byte1_wait_tx callr main_delay boot_RAM_exit1: ;   bres PB_DDR,#<span class="hljs-number"><span class="hljs-number">5</span></span> ; bres PB_CR1,#<span class="hljs-number"><span class="hljs-number">5</span></span> ; ;   byte2_tx: mov UART1_DR, #$08 byte2_wait_tx btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">7</span></span>, byte2_wait_tx jra main_FLASH_cycle main_delay: decw X jrne main_delay ret ;   EEPROM -&gt; RAM segment byte at <span class="hljs-number"><span class="hljs-number">9</span></span>FEF <span class="hljs-string"><span class="hljs-string">'boot_FLASH'</span></span> boot_FLASH_start: ldw X, SP ; Y &lt;- { EEPROM_START + RAM_END} ; Y &lt;- { $4000 + $03FF = $43FF } ldw Y, #$43FF boot_FLASH_copy: ld A, (Y) ld (X), A decw Y decw X jrpl boot_FLASH_copy incw X jp (X) boot_FLASH_exit_address: dc.w main_FLASH_start end ;</code> </pre><br></div></div><br>  Ejecute el archivo <a href="">runSTM8uLoader.bat</a> , presione el botón de reinicio en la placa, el gestor de arranque envía el byte 0x01.  Se envía un volcado con el código del archivo main_RAM.hex a RAM STM8 a través de UART.  La placa comienza a parpadear el LED y envía los bytes 0x20 y 0x02.  Presione el botón de reinicio nuevamente.  Se inicia el programa de aplicación desde la memoria FLASH, el LED comienza a parpadear más rápido y envía los bytes 0x80 y 0x08. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/582/519/9bc/5825199bc0f6dfaf10b3e297e1339c06.png"></div><br><h4>  La tercera etapa.  Tamaño del código 18 bytes en memoria FLASH y 52 bytes en bytes de OPCIÓN </h4><br>  Por supuesto, nos apuramos con la memoria EEPROM.  ¿Dónde guardar los senos y otras mesas ahora?  Y con la memoria FLASH, no todo está claro.  ¿Quién decidió almacenar la dirección de control de transferencia del programa de aplicación en la memoria FLASH?  Y el mismo byte de la versión del gestor de arranque generalmente se almacena en dos lugares a la vez.  ¿Dónde exprimir 52 bytes destinados a EEPROM? <br><br>  Aquí la litografía nos ayuda.  La memoria EEPROM consta de 10 bloques de 64 bytes cada uno.  Agregar otro bloque a estos bloques, pero con un tamaño diferente, no es económicamente factible.  STMicroelectronics hizo exactamente eso, agregó otro bloque de 64 bytes, llamó a esta área Bytes de OPCIÓN y almacena allí importantes configuraciones de microcontroladores no volátiles (para STM8S103F3 es de hasta 11 bytes).  Y, por supuesto, STM olvidó mencionar que todavía quedan 53 células funcionales en esta área.  Aparentemente hay muchos modelos STM8, debe dejar espacio para futuras configuraciones importantes. <br><br>  Nuestro gestor de arranque solo reclama el modelo STM8 sin gestores de arranque integrados.  Por lo tanto, tomamos las celdas de respaldo del bloque OPTION Bytes hasta ahora que nadie ve.  Es cierto que hay un pequeño inconveniente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pero resuelto</a> .  Un programador convencional no le permitirá escribir información en estas celdas. <br><br>  Al cargar, el control se transfiere al código copy_boot_FLASH inicial a $ 9FF2.  boot_FLASH transfiere la imagen del cargador de arranque boot_OPTION desde el área de Bytes de OPCIÓN a la RAM. <br><br>  boot_OPTION configura el UART 9600 8N1, envía el byte UART con su versión, espera los bytes UART del programa host y, sin esperar 0.2 segundos, transfiere el control al programa de aplicación en la dirección ubicada en el par $ 4831: $ 4832. <br><br>  Si boot_OPTION, después de enviar un byte con su versión, toma un byte del tamaño del volcado esperado, luego toma el volcado en sí, lo coloca en la memoria RAM y le transfiere el control. <br>  Además, toda la atención recae en el programa en la computadora y el volcado que envía.  Debería enviar exactamente los volcados necesarios para completar la tarea actual (leer / borrar / escribir / copiar celdas de memoria STM8).  Los volcados deberían poder reemplazarse entre sí en la memoria RAM y transferir el control al programa de aplicación. <br><br>  La dirección de transición a la solicitud es $ 4831: $ 4832. <br><br><div class="spoiler">  <b class="spoiler_title">Cargador y código de aplicación para ejecutar en la memoria FLASH:</b> <div class="spoiler_text"><pre> <code class="hljs mel">stm8/ TITLE <span class="hljs-string"><span class="hljs-string">"boot_FLASH_OPTION.asm"</span></span> .NOLIST #include <span class="hljs-string"><span class="hljs-string">"STM8S103F3P.inc"</span></span> .LIST MOTOROLA WORDS segment byte at <span class="hljs-number"><span class="hljs-number">4800</span></span> <span class="hljs-string"><span class="hljs-string">'boot_OPTION'</span></span> ;    boot_OPTION dc.b $00, $00, $FF, $00, $FF, $00, $FF, $00 dc.b $FF, $00, $FF, $35, $0D, $52, $32, $35 dc.b $0C, $52, $35, $35, $25, $52, $31, $5A dc.b $27, $16, $72, $0B, $52, $30, $F8, $C6 dc.b $52, $31, $72, $0B, $52, $30, $FB, $3B dc.b $52, $31, $4A, $26, $F5, $96, $5C, $FC dc.b $AE, $80, $04, $2B, $FA, $90, $AE, $42 dc.b $7F, $AE, $02, $7F, $CC, $9F, $F6, $00 segment byte at <span class="hljs-number"><span class="hljs-number">8000</span></span> <span class="hljs-string"><span class="hljs-string">'boot_start'</span></span> boot_start: ldw X, SP jp boot_FLASH_start ; ******************************************************** ;  <span class="hljs-number"><span class="hljs-number">0x8004</span></span>..<span class="hljs-number"><span class="hljs-number">.0</span></span>x9FF1      segment byte at <span class="hljs-number"><span class="hljs-number">8004</span></span> <span class="hljs-string"><span class="hljs-string">'main_FLASH'</span></span> ;   main_FLASH_start: ldw X, #$03FF ldw SP, X mov UART1_BRR1, #<span class="hljs-number"><span class="hljs-number">13</span></span> mov UART1_CR2, #%00001100 main_FLASH_cycle: callr main_delay ;   bset PB_DDR,#<span class="hljs-number"><span class="hljs-number">5</span></span> bset PB_CR1,#<span class="hljs-number"><span class="hljs-number">5</span></span> ;   byte1_tx: mov UART1_DR, #$80 byte1_wait_tx btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">7</span></span>, byte1_wait_tx callr main_delay boot_RAM_exit1: ;   bres PB_DDR,#<span class="hljs-number"><span class="hljs-number">5</span></span> ; bres PB_CR1,#<span class="hljs-number"><span class="hljs-number">5</span></span> ; ;   byte2_tx: mov UART1_DR, #$08 byte2_wait_tx btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">7</span></span>, byte2_wait_tx jra main_FLASH_cycle main_delay: decw X jrne main_delay ret ;   OPTION -&gt; RAM segment byte at <span class="hljs-number"><span class="hljs-number">9</span></span>FF2 <span class="hljs-string"><span class="hljs-string">'boot_FLASH'</span></span> boot_FLASH_start: ; Y &lt;- { OPTION_START + RAM_END} ; Y &lt;- { $4800 + $03FF = $43FF } ldw Y, #$43FF boot_FLASH_copy: ld A, (Y) ld (X), A decw Y decw X jrpl boot_FLASH_copy incw X jp (X) boot_FLASH_exit_address: dc.w main_FLASH_start end ;</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Código de aplicación para ejecución en memoria RAM:</b> <div class="spoiler_text"><pre> <code class="hljs 1c">stm8/ TITLE “boot_RAM.asm” MOTOROLA <span class="hljs-meta"><span class="hljs-meta">#include "STM8S103F3P.inc" BYTES segment byte at 0000 'boot_RAM_data' boot_RAM_start: ;  pull-up   (</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">  </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">   ) </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta"> ,   ,  14  ; ld A, #%01001100 ; [A6 4C] ; cpl A ; [43] ; ld PA_CR1, A ; [C7 50 03] ; ld PB_CR1, A ; [C7 50 08] ; ld PC_CR1, A ; [C7 50 0D] ; ld PD_CR1, A ; [C7 50 12]   PD6(UART1_RX), PD2, PD1 ;  UART1  /   9600,   </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">  (8 ,   , 1  ) ; mov UART1_BRR2, #0 ; [35 00 52 33] </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta"> Fmaster=16/8=2  9600 mov UART1_BRR1, #13 ; [35 0D 52 32] </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta"> Fmaster=16/8=2  9600 mov UART1_CR2, #%00001100 ; [35 0C 52 35] UART1_CR2.TEN &lt;- 1 UART1_CR2.REN &lt;- 1  / ;   </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta"> UART1 boot_RAM_byte1_tx: mov UART1_DR, #$02 boot_RAM_byte1_wait_tx btjf UART1_SR, #7, boot_RAM_byte1_wait_tx ldw X,#0 ; [AE 00 00] boot_FLASH     X boot_RAM_wait1: decw X ; [5A] jreq boot_RAM_exit1 ; jra boot_RAM_wait1 boot_RAM_exit1: ;   bres PB_DDR,#5 ; bres PB_CR1,#5 ; ;   </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta"> UART1 boot_RAM_byte2_tx: mov UART1_DR, #$20 ; [35 11 52 31] boot_RAM_byte2_wait_tx btjf UART1_SR, #7, boot_RAM_byte2_wait_tx ldw X,#0 ; [AE 00 00] boot_FLASH     X boot_RAM_wait2: decw X ; [5A] jreq boot_RAM_exit2 ; jra boot_RAM_wait2 boot_RAM_exit2: ;   bset PB_DDR,#5 ; bset PB_CR1,#5 ; jra boot_RAM_byte1_tx end</span></span></code> </pre> </div></div><br>  Ejecute el archivo <a href="">runSTM8uLoader.bat</a> , presione el botón de reinicio en el tablero, el gestor de arranque envía el byte 0x25.  Se envía un volcado con el código del archivo main_RAM.hex a RAM STM8 a través de UART.  La placa comienza a parpadear el LED y envía los bytes 0x20 y 0x02.  Presione el botón de reinicio nuevamente.  Se inicia el programa de aplicación desde la memoria FLASH, el LED comienza a parpadear más rápido y envía los bytes 0x80 y 0x08. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab1/ceb/14d/ab1ceb14d6c5aa19ad29084223298e07.png"></div><br>  En la última etapa, para escribir la imagen del cargador de arranque en el área Bytes de OPCIÓN, debe usar el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">método</a> .  La esencia del método es que primero necesita que el programador escriba el archivo de firmware boot_OPTION_rev25.hex en la memoria STM8 FLAH, reinicie el microcontrolador, el área de Bytes de OPCIÓN se llenará con la información necesaria y el LED se encenderá.  Por otra parte, el programador escribe en el archivo de firmware FLASH desde este artículo <a href="">boot_FLASH_OPTION.hex</a> . <br><br>  Se agregó el código de cargador de arranque "limpio" versión 0x14 sin código de aplicación.  Desplegó la imagen boot_OPTION en el código fuente.  Comentarios corregidos  A diferencia de la versión de $ 25, la dirección de transferencia de control de la aplicación se encuentra en las celdas FLASH de $ 9FFE: $ 9FFFF.  El tamaño en FLASH es de 20 bytes, respectivamente. <br><div class="spoiler">  <b class="spoiler_title">boot_uC_rev14.asm:</b> <div class="spoiler_text"><pre> <code class="hljs mel">stm8/ TITLE <span class="hljs-string"><span class="hljs-string">"boot_uC_rev14.asm"</span></span> ; boot_uC = boot_OPTION + boot_FLASH MOTOROLA .NOLIST #include <span class="hljs-string"><span class="hljs-string">"STM8S103F3P.inc"</span></span> .LIST WORDS ; ******************************************************** segment byte at <span class="hljs-number"><span class="hljs-number">4800</span></span> <span class="hljs-string"><span class="hljs-string">'boot_O_IMG'</span></span> ;<span class="hljs-number"><span class="hljs-number">0000</span></span>FF00FF00FF00FF00FF350D523235 ;<span class="hljs-number"><span class="hljs-number">0</span></span>C5235351452315A2716720B5230F8C6 ;<span class="hljs-number"><span class="hljs-number">5231720</span></span>B5230FB3B52314A26F5965CFC ;CE9FFE2BFA90AE427FAE027FCC9FF400 ;    ; $4800    RAM dc.b $00, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF ; OPTION (RAM) ; $480B ($0000)    boot_O boot_O_start: ;  UART <span class="hljs-number"><span class="hljs-number">96008</span></span>N1 Fmaster=<span class="hljs-number"><span class="hljs-number">16</span></span>/<span class="hljs-number"><span class="hljs-number">8</span></span>=<span class="hljs-number"><span class="hljs-number">2</span></span>/<span class="hljs-number"><span class="hljs-number">9600</span></span>/<span class="hljs-number"><span class="hljs-number">16</span></span> ; mov UART1_BRR2, #<span class="hljs-number"><span class="hljs-number">0</span></span> ; [<span class="hljs-number"><span class="hljs-number">35</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">33</span></span>]     mov UART1_BRR1, #<span class="hljs-number"><span class="hljs-number">13</span></span> ; [<span class="hljs-number"><span class="hljs-number">35</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>D <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span>] ; UART1_CR2.TEN &lt;- <span class="hljs-number"><span class="hljs-number">1</span></span> UART1_CR2.REN &lt;- <span class="hljs-number"><span class="hljs-number">1</span></span>  / mov UART1_CR2, #%00001100 ; [<span class="hljs-number"><span class="hljs-number">35</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>C <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">35</span></span>] ; $4813 ($0008) boot_E_byte1_tx: ;   $14  mov UART1_DR, #$14 ; [<span class="hljs-number"><span class="hljs-number">35</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span> <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span>] ;    ,     ;      ;  X   ( <span class="hljs-number"><span class="hljs-number">200</span></span> ) ; clrw X ; [<span class="hljs-number"><span class="hljs-number">5</span></span>F]  X   boot_F ; $4817 ($000C) boot_O_rx_wait_byte: decw X ; [<span class="hljs-number"><span class="hljs-number">5</span></span>A] jreq boot_O_exit ; [<span class="hljs-number"><span class="hljs-number">27</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>]       btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">5</span></span>, boot_O_rx_wait_byte ; [<span class="hljs-number"><span class="hljs-number">72</span></span> OB <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span> F8] ;   ,   ,  A    ; $481F ($0014) ld A, UART1_DR ; [C6 <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span>] ; $4822 ($0017)    boot_O_rx_wait_block: btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">5</span></span>, boot_O_rx_wait_block ; [<span class="hljs-number"><span class="hljs-number">72</span></span> OB <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span> FB] push UART1_DR ; [<span class="hljs-number"><span class="hljs-number">3</span></span>B <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span>] dec A ; [<span class="hljs-number"><span class="hljs-number">4</span></span>A] ;      A      jrne boot_O_rx_wait_block ; [<span class="hljs-number"><span class="hljs-number">26</span></span> F5] ; $482D ($0022)      ldw X, SP ; [<span class="hljs-number"><span class="hljs-number">96</span></span>] incw X ; [<span class="hljs-number"><span class="hljs-number">5</span></span>C] boot_O_exit_to_FLASH: jp (X) ; [FC] ; $4830 ($0025)     boot_O_exit: ldw X, boot_F_exit_address ; [CE <span class="hljs-number"><span class="hljs-number">9</span></span>F FE] jrmi boot_O_exit_to_FLASH ; [<span class="hljs-number"><span class="hljs-number">2</span></span>B FA] ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> X &lt; $8000     $0000 ;     EEPROM boot_O_exit_to_EEPROM: ; Y &lt;- { EEPROM_END} ldw Y, #$427F ; [<span class="hljs-number"><span class="hljs-number">90</span></span> AE <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>F] ; X &lt;- { EEPROM_END - EEPROM_START } ;   EEPROM  RAM ldw X, #$027F ; [AE <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>F] jp boot_F_copy ; [CC <span class="hljs-number"><span class="hljs-number">9</span></span>F F4] ; $483F ($0034) dc.b $00 ;   boot_O_end: ; ******************************************************** segment byte at <span class="hljs-number"><span class="hljs-number">8000</span></span> <span class="hljs-string"><span class="hljs-string">'RESET_vector'</span></span> ;<span class="hljs-number"><span class="hljs-number">96</span></span>CC9FF0 ldw X, SP ; [<span class="hljs-number"><span class="hljs-number">96</span></span>] X &lt;- RAM_END jp boot_F_start ; [CC <span class="hljs-number"><span class="hljs-number">9</span></span>F F0] ; ******************************************************** ;  <span class="hljs-number"><span class="hljs-number">0x8004</span></span>..<span class="hljs-number"><span class="hljs-number">.0</span></span>x9FEF      segment byte at <span class="hljs-number"><span class="hljs-number">8004</span></span> <span class="hljs-string"><span class="hljs-string">'main_FLASH'</span></span> ;<span class="hljs-number"><span class="hljs-number">20</span></span>FE jra * ; [<span class="hljs-number"><span class="hljs-number">20</span></span> FE] ; ******************************************************** ;   boot_FLASH segment byte at <span class="hljs-number"><span class="hljs-number">9</span></span>FF0 <span class="hljs-string"><span class="hljs-string">'boot_F'</span></span> ;<span class="hljs-number"><span class="hljs-number">90</span></span>AE4C0A90F6F7905A5A2AF85CFC8004 boot_F_start: ; Y &lt;- { boot_O_START + RAM_END} { $480B + $03FF = $4C0A } ldw Y, #$4C0A ; [<span class="hljs-number"><span class="hljs-number">90</span></span> AE <span class="hljs-number"><span class="hljs-number">4</span></span>C <span class="hljs-number"><span class="hljs-number">0</span></span>A] ;     ; boot_FLASH, boot_OPTION      boot_F_copy: ld A, (Y) ; [<span class="hljs-number"><span class="hljs-number">90</span></span> F6] ld (X), A ; [F7] decw Y ; [<span class="hljs-number"><span class="hljs-number">90</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>A] decw X ; [<span class="hljs-number"><span class="hljs-number">5</span></span>A] jrpl boot_F_copy ; [<span class="hljs-number"><span class="hljs-number">2</span></span>A F8]  X(Y) &gt;= RAM_START(boot_O_START) incw X ; [<span class="hljs-number"><span class="hljs-number">5</span></span>C] jp (X) ; [FC] boot_F_exit_address: dc.w $8004 ; [<span class="hljs-number"><span class="hljs-number">80</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span>] ; dc.w $0000 ; [<span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span>] end ;</code> </pre></div></div><br>  Se agregó un código de cargador de arranque "limpio" versión 0x25 sin código de aplicación.  Desplegó la imagen boot_OPTION en el código fuente.  Comentarios corregidos  A diferencia de la versión de $ 14, la dirección de transferencia de control de la aplicación se encuentra en las celdas $ 4831: $ 4832 del área OPTION Bytes.  El tamaño ocupado en la memoria FLASH, respectivamente, disminuyó a 18 bytes.  El tamaño ocupado en el área de Bytes de OPCIÓN no ha cambiado (52 bytes + 1 reserva). <br><div class="spoiler">  <b class="spoiler_title">boot_uC_rev14.asm:</b> <div class="spoiler_text"><pre> <code class="hljs mel">stm8/ TITLE <span class="hljs-string"><span class="hljs-string">"boot_uC_rev25.asm"</span></span> ; boot_uC = boot_OPTION + boot_FLASH MOTOROLA .NOLIST #include <span class="hljs-string"><span class="hljs-string">"STM8S103F3P.inc"</span></span> .LIST BYTES ; ******************************************************** ;        EEPROM  ; boot_O_exit_address    $0000 (   &lt;$8000) ;       ;          segment byte at <span class="hljs-number"><span class="hljs-number">0000</span></span> <span class="hljs-string"><span class="hljs-string">'boot_O_IMG'</span></span> main_ram: ;<span class="hljs-number"><span class="hljs-number">20</span></span>FE jra * ; [<span class="hljs-number"><span class="hljs-number">20</span></span> FE] WORDS ; ******************************************************** segment byte at <span class="hljs-number"><span class="hljs-number">4800</span></span> <span class="hljs-string"><span class="hljs-string">'boot_O_IMG'</span></span> ;<span class="hljs-number"><span class="hljs-number">0000</span></span>FF00FF00FF00FF00FF350D523235 ;<span class="hljs-number"><span class="hljs-number">0</span></span>C5235351452315A2716720B5230F8C6 ;<span class="hljs-number"><span class="hljs-number">5231720</span></span>B5230FB3B52314A26F5965CFC ;AE80042BFA90AE427FAE027FCC9FF600 ;    ; $4800    RAM dc.b $00, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF ; OPTION (RAM) ; $480B ($0000)    boot_OPTION boot_O_start: ;  UART <span class="hljs-number"><span class="hljs-number">96008</span></span>N1 Fmaster=<span class="hljs-number"><span class="hljs-number">16</span></span>/<span class="hljs-number"><span class="hljs-number">8</span></span>=<span class="hljs-number"><span class="hljs-number">2</span></span>/<span class="hljs-number"><span class="hljs-number">9600</span></span>/<span class="hljs-number"><span class="hljs-number">16</span></span> ; mov UART1_BRR2, #<span class="hljs-number"><span class="hljs-number">0</span></span> ; [<span class="hljs-number"><span class="hljs-number">35</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">33</span></span>]     mov UART1_BRR1, #<span class="hljs-number"><span class="hljs-number">13</span></span> ; [<span class="hljs-number"><span class="hljs-number">35</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>D <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span>] ; UART1_CR2.TEN &lt;- <span class="hljs-number"><span class="hljs-number">1</span></span> UART1_CR2.REN &lt;- <span class="hljs-number"><span class="hljs-number">1</span></span>  / mov UART1_CR2, #%00001100 ; [<span class="hljs-number"><span class="hljs-number">35</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>C <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">35</span></span>] ; $4813 ($0008) boot_E_byte1_tx: ;   $14  mov UART1_DR, #$14 ; [<span class="hljs-number"><span class="hljs-number">35</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span> <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span>] ;    ,     ;      ;  X   ( <span class="hljs-number"><span class="hljs-number">200</span></span> ) ; clrw X ; [<span class="hljs-number"><span class="hljs-number">5</span></span>F]  X   boot_F ; $4817 ($000C) boot_O_rx_wait_byte: decw X ; [<span class="hljs-number"><span class="hljs-number">5</span></span>A] jreq boot_O_exit ; [<span class="hljs-number"><span class="hljs-number">27</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>]       btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">5</span></span>, boot_O_rx_wait_byte ; [<span class="hljs-number"><span class="hljs-number">72</span></span> OB <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span> F8] ;   ,   ,  A    ; $481F ($0014) ld A, UART1_DR ; [C6 <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span>] ; $4822 ($0017)    boot_O_rx_wait_block: btjf UART1_SR, #<span class="hljs-number"><span class="hljs-number">5</span></span>, boot_O_rx_wait_block ; [<span class="hljs-number"><span class="hljs-number">72</span></span> OB <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span> FB] push UART1_DR ; [<span class="hljs-number"><span class="hljs-number">3</span></span>B <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span>] dec A ; [<span class="hljs-number"><span class="hljs-number">4</span></span>A] ;      A      jrne boot_O_rx_wait_block ; [<span class="hljs-number"><span class="hljs-number">26</span></span> F5] ; $482D ($0022)      ldw X, SP ; [<span class="hljs-number"><span class="hljs-number">96</span></span>] incw X ; [<span class="hljs-number"><span class="hljs-number">5</span></span>C] boot_O_exit_to_FLASH: jp (X) ; [FC] ; $4830 ($0025)     boot_O_exit: dc.b $AE ; ldw X, #boot_O_exit_address ; [AE <span class="hljs-number"><span class="hljs-number">80</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span>] ; $4831 ($0026) ;      boot_O_exit_address: dc.w main_flash ; [<span class="hljs-number"><span class="hljs-number">80</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span>] ; dc.w main_ram ; [<span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span>] jrmi boot_O_exit_to_FLASH ; [<span class="hljs-number"><span class="hljs-number">2</span></span>B FA] ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> X &lt; $8000     $0000 ;     EEPROM boot_O_exit_to_EEPROM: ; Y &lt;- { EEPROM_END} ldw Y, #$427F ; [<span class="hljs-number"><span class="hljs-number">90</span></span> AE <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>F] ; X &lt;- { EEPROM_END - EEPROM_START } ;   EEPROM  RAM ldw X, #$027F ; [AE <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>F] jp boot_F_copy ; [CC <span class="hljs-number"><span class="hljs-number">9</span></span>F F4] ; $483F ($0034) dc.b $00 ;   boot_O_end: ; ******************************************************** segment byte at <span class="hljs-number"><span class="hljs-number">8000</span></span><span class="hljs-number"><span class="hljs-number">-8003</span></span> <span class="hljs-string"><span class="hljs-string">'RESET_vector'</span></span> ;<span class="hljs-number"><span class="hljs-number">96</span></span>CC9FF2 ldw X, SP ; [<span class="hljs-number"><span class="hljs-number">96</span></span>] X &lt;- RAM_END jp boot_F_start ; [CC <span class="hljs-number"><span class="hljs-number">9</span></span>F F2] ; ******************************************************** ;  <span class="hljs-number"><span class="hljs-number">0x8004</span></span>..<span class="hljs-number"><span class="hljs-number">.0</span></span>x9FF1      segment byte at <span class="hljs-number"><span class="hljs-number">8004</span></span> <span class="hljs-string"><span class="hljs-string">'main_FLASH'</span></span> main_flash: ;<span class="hljs-number"><span class="hljs-number">20</span></span>FE jra * ; [<span class="hljs-number"><span class="hljs-number">20</span></span> FE] ; ******************************************************** ;   boot_FLASH segment byte at <span class="hljs-number"><span class="hljs-number">9</span></span>FF2<span class="hljs-number"><span class="hljs-number">-9</span></span>FFF <span class="hljs-string"><span class="hljs-string">'boot_F'</span></span> ;<span class="hljs-number"><span class="hljs-number">90</span></span>AE4C0A90F6F7905A5A2AF85CFC boot_F_start: ; Y &lt;- { boot_O_START + RAM_END} { $480B + $03FF = $4C0A } ldw Y, #$4C0A ; [<span class="hljs-number"><span class="hljs-number">90</span></span> AE <span class="hljs-number"><span class="hljs-number">4</span></span>C <span class="hljs-number"><span class="hljs-number">0</span></span>A] ;     ; boot_FLASH, boot_OPTION      boot_F_copy: ld A, (Y) ; [<span class="hljs-number"><span class="hljs-number">90</span></span> F6] ld (X), A ; [F7] decw Y ; [<span class="hljs-number"><span class="hljs-number">90</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>A] decw X ; [<span class="hljs-number"><span class="hljs-number">5</span></span>A] jrpl boot_F_copy ; [<span class="hljs-number"><span class="hljs-number">2</span></span>A F8]  X(Y) &gt;= RAM_START(boot_O_START) incw X ; [<span class="hljs-number"><span class="hljs-number">5</span></span>C] jp (X) ; [FC] end ;</code> </pre></div></div><br>  La dirección de transferencia de control de la aplicación en la memoria FLASH se puede seleccionar del rango de $ 8004 ... $ 9FF1.  Para una imagen de código de aplicación de la memoria EEPROM, la transferencia de control solo es posible en la dirección $ 0000 en la memoria RAM. <br>  El programa host puede pasar cualquier dirección de transferencia de control como el segundo argumento de línea de comando. <br>  El código fuente del programa host se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> .  También hay contactos para una comunicación más detallada. <br>  Pido a los lectores críticas específicas y sugerencias para una mayor reducción del código. <br><br>  También propongo leer el artículo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Cómo comprimir el gestor de arranque para STM8 al tamaño de 8 bytes en la memoria FLASH"</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es417493/">https://habr.com/ru/post/es417493/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es417481/index.html">Acerca de los generadores en JavaScript ES6, y por qué es opcional estudiarlos</a></li>
<li><a href="../es417483/index.html">Comparación de marcos JS: React, Vue e Hyperapp</a></li>
<li><a href="../es417485/index.html">[marcador] Cheat sheet del administrador del sistema para herramientas de red Linux</a></li>
<li><a href="../es417487/index.html">El lugar donde comenzó la Internet rusa</a></li>
<li><a href="../es417489/index.html">Informe del Club de Roma 2018, Capítulo 3.4: “Energía descentralizada”</a></li>
<li><a href="../es417495/index.html">Los equipos rusos y ucranianos prevalecieron sobre los europeos en la final europea de la competencia InnovateFPGA de Intel</a></li>
<li><a href="../es417497/index.html">4 años de Data Science en Schibsted Media Group</a></li>
<li><a href="../es417501/index.html">Lifehacks fabricando tableros de dos capas (LUT)</a></li>
<li><a href="../es417503/index.html">Lo que un desarrollador web debe recordar hacer SEO-Feng Shui</a></li>
<li><a href="../es417505/index.html">Intel lanza parches para nuevas vulnerabilidades de firmware de ME</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>