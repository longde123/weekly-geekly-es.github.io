<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✳️ 🧗🏽 🗽 Geschichte von 3dfx Voodoo1 👋 👨🏻‍🔧 👷🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist der zweite Artikel in der Reihe „3D-Karten des Bebens der späten 90er Jahre“. Im ersten Teil haben wir die Rendition Vérité 1000 von Ende 199...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Geschichte von 3dfx Voodoo1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446860/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c2/507/9b7/0c25079b7f8c22bd64dc32612d89136a.jpg" alt="Bild"></div><br>  Dies ist der zweite Artikel in der Reihe „3D-Karten des Bebens der späten 90er Jahre“.  Im ersten Teil haben wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rendition Vérité 1000 von</a> Ende 1996 und einen speziellen Game-Port dafür namens vQuake untersucht.  Rendition hat es geschafft, alle auf dem Quake-Markt zu besiegen.  Für kurze Zeit blieb es das einzige Board, das den id Software-Blockbuster mit Hardwarebeschleunigung starten konnte. <br><br>  Dies änderte sich jedoch im Januar 1997, als id Software eine neue Version von Quake namens GLQuake veröffentlichte.  Da der Port mit miniGL (einer Teilmenge des OpenGL 1.1-Standards) erstellt wurde, konnte jeder Hersteller von Hardwarebeschleunigern miniGL-Treiber schreiben und am 3D-Kartenrennen teilnehmen.  Von diesem Moment an stand die Möglichkeit des Wettbewerbs allen offen.  Ziel war es, möglichst viele Frames pro Sekunde zu generieren.  Die Belohnung war der Ruhm und das Geld der Kunden.  Wenn man kurz die Geschichte studiert hat, kann man verstehen, dass die beiden damaligen Autoritäten zweifellos die Könige der beiden Bergproduzenten betrachteten. <br><br><blockquote>  Bisher besteht kein Zweifel: Die Welt von Quake wird von Voodoo regiert.  Und da Quake die Welt der Spiele regiert, ist der Kauf von 3Dfx Voodoo für Gamer fast unvermeidlich. <br><br>  <i>- Tom's Hardware, 30. November 1997</i> </blockquote><br><blockquote>  3DFX Voodoo 1 <br>  - Der Standard, an dem alle anderen Karten gemessen werden. <br><br>  <i>- John Carmack .plan Datei.</i>  <i>12. Februar 1998</i> <sup>[2]</sup> </blockquote><br>  Wenn ich mir nur die Spezifikationen <sup>[3] ansehe</sup> , in denen eine Füllrate von 50 Megapixeln / s angegeben ist, wollte ich diese Karte sofort studieren und verstehen, was 3dfx getan hat, um ein so leistungsstarkes Produkt zu entwickeln. <br><a name="habracut"></a><br><h2>  3dfx Interaktiv </h2><br>  Ross Smith, Scott Sellers und Gary Tarolli trafen sich, als sie bei SGI zusammenarbeiteten <sup>[4]</sup> .  Nachdem sie ein wenig bei Pellucid gearbeitet hatten, wo sie versuchten, IrisVision-Boards für PCs zu verkaufen (1994 kosteten solche Boards 4000 USD pro Stück), gründeten Kollegen mit Unterstützung von Gordy Campbell TechFarm eine eigene Firma.  3dfx Interactive mit Hauptsitz in San Jose, Kalifornien, wurde 1994 gegründet. <br><br>  Ursprünglich beabsichtigte das Unternehmen, leistungsstarke Hardwaresysteme für Arcade-Automaten zu entwickeln, änderte jedoch seinen Kurs durch die Entwicklung von PC-Karten.  Dafür gab es drei Gründe. <br><br><ol><li>  Ziemlich niedriger RAM-Preis. </li><li>  Beginnend mit FastPage RAM und dann EDO RAM hat sich die Latenz im RAM um 30% verringert.  Jetzt kann der Speicher mit einer Frequenz von bis zu 50 MHz arbeiten. </li><li>  Spiele in 3D (oder in Pseudo-3D) sind immer beliebter geworden.  Der Erfolg von Spielen wie DOOM, Descent und Wing Commander III hat gezeigt, dass ein Markt für 3D-Beschleuniger im Entstehen begriffen ist. </li></ol><br>  Die Gründer des Unternehmens erkannten, dass sie etwas Mächtiges schaffen mussten, das für Spiele konzipiert war und einen Verkaufspreis im Bereich von 300 bis 400 Dollar hatte.  1996 gab das Unternehmen die Schaffung der SST1-Architektur (benannt nach den Gründern - Sellers-Smith-Tarolli-1) bekannt, die bald von mehreren OEMs wie Diamond, Canopus, Innovision und ColorMAX lizenziert wurde.  Für ihre Kreation kam der Marketingname "Voodoo1", der seine magische Leistung betont. <br><br>  Wie beim V1000 konnten die Hersteller beim Erstellen von Karten nur den ausgewählten RAM-Typ (EDO oder DRAM), die Farbe der Karten und die physische Anordnung der Chips ändern.  Fast alles andere war standardisiert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f9/717/a52/6f9717a52ba3bcee9f418af37d8c6dcc.webp"></div><br>  <i>Diamond Monster 3D, Bild aus vgamuseum.info.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35b/75c/aea/35b75caea36c0ad8cc44f5bb0f5f53e0.png"></div><br>  <i>Canopus Pure3D, Bild aus vgamuseum.info.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/75d/10d/0fb/75d10d0fb753c92c19542e0340ee733e.png"></div><br>  <i>BIOSTAR Venus 3D, Bild aus vgamuseum.info.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2cc/de8/a3d/2ccde8a3d1371c4a1c51411c1b7a2d8e.png"></div><br>  <i>ORCHID Righteous 3D, Bild aus vgamuseum.info.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bee/6c7/11f/bee6c711ffb6aed87499b3710176e0a9.svg"></div><br>  Beim Blick auf das SST1-Board fiel auf, wie unterschiedlich es sich von seinen Konkurrenten - Rendition Verite 1000 und NVidia NV1 - unterschied. <br><br>  Erstens hat 3dfx einen mutigen Schritt getan und die Unterstützung des 2D-Renderings aufgegeben.  Voodoo1 hatte zwei VGA-Anschlüsse, einen als Ausgang und einen als Eingang.  Die Karte wurde als Ergänzung entwickelt, sie nahm als Eingabe die Ausgabe einer zweidimensionalen VGA-Karte, die bereits im Computer installiert war.  Wenn der Benutzer mit dem Betriebssystem (DOS oder Windows) arbeitete, leitete Voodoo1 das Signal einfach von seinem VGA-Eingang zum VGA-Ausgang um.  Beim Umschalten in den 3D-Modus übernahm Voodoo1 die Kontrolle über den VGA-Ausgang und ignorierte das Signal von seinem VGA-Eingang.  Einige Boards hatten einen mechanischen Schalter, der beim Umschalten zwischen 2D- und 3D-Modus klickte.  Diese Entscheidung bedeutete, dass die Karte nur für das Rendern im Vollbildmodus verwendet werden kann. Es gab keinen „Fenstermodus“. <br><br>  Der zweite bemerkenswerte Aspekt von SST1 war, dass es nicht aus einer CPU, sondern aus zwei nicht programmierbaren ASICs (Application-Specific Integrated Circuit, Special Purpose Integrated Circuits) hergestellt wurde.  Wenn Sie die Reifenspuren entlang gehen, können Sie sehen, dass jeder der mit „TMU“ und „FBI“ gekennzeichneten Chips über einen eigenen RAM verfügt.  Auf der Speicherkarte wurden 4 Mebibyte RAM gleichmäßig aufgeteilt: 2 Mebibyte TMU für die Texturspeicherung und 2 Mebibyte FBI für die Speicherung des Farbpuffers und des Z-Puffers, während die Werte jeweils als 16-Bit-RGBA bzw. 16-Bit-Ganzzahl / Halb-Float gespeichert wurden.  Eine Speicherkarte mit 4 Mebibyte unterstützt eine Auflösung von bis zu 640 x 480 (2 Farbpuffer (640 x 480 x 2) für doppelte Pufferung + 1 Tiefenpuffer (640 x 480 x 2) = 1 843 200).  Spätere Modelle mit 4 Mebibyte FBI-RAM können Auflösungen von bis zu 800 x 600 (2 x 800 x 600 x 2 + 800 x 600 x 2 = 2.880.000) verwenden. <br><br><h2>  SST1-Rendering-Pipeline </h2><br>  Der Förderer ist in den Spezifikationen nicht detailliert beschrieben.  Nach meiner Interpretation bestand das Leben eines Dreiecks aus fünf Stufen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f57/428/32d/f5742832d4cdf861bf1d8446f8ea10f1.svg"></div><br><ol><li>  Im Hauptprozessor des Computers (normalerweise Pentium) wird ein Dreieck erstellt und transformiert.  Solche Operationen umfassen die Multiplikation mit der Matrix des Modell- / Projektionsraums, das Abschneiden, die Scheitelpunktperspektiventeilung, das Abschneiden homogener Koordinaten und das Transformieren des Sichtfelds.  Am Ende dieses Vorgangs bleiben nur sichtbare Dreiecke des Bildschirmbereichs übrig (aufgrund von Übersteuerungen kann sich herausstellen, dass ein Dreieck zwei sind). </li><li>  Mit dem Befehl triangleCMD werden die Dreiecke über den PCI-Bus an das Frame Buffer Interface (FBI) übertragen.  Sie werden in Rasterzeichenfolgenabfragen konvertiert, die von der Texture Mapping Unit erstellt wurden.  Für jedes Element der Rasterzeile (als Fragment bezeichnet) führt die TMU bis zu vier Suchabfragen pro Pixel durch, wenn der Entwickler eine bilineare Filterung benötigt.  Eine fragmentierte Perspektiventeilung wird auch in TMU durchgeführt. </li><li>  Die TMU sendet Fragmente als strukturierten 16-Bit-RGBA-Farbwert + 16-Bit-Z-Wert an das FBI. </li><li>  Das FBI führt Fragmenttests im Z-Puffer durch und vergleicht sie mit dem zugewiesenen RAM, in dem die RGBA-Werte und die Z-Werte des Bildpuffers gespeichert sind. </li><li>  Schließlich wird das Fragment anhand seines Farbattributs und einer Suche in der Nebeltabelle mit 64 Elementen beleuchtet.  Wenn ein Mischen erforderlich ist, kombiniert das FBI das resultierende Fragment mit dem, was sich bereits im Farbpuffer befindet. </li></ol><br>  <b>Interessante Tatsache:</b> Wenn Sie ein 3D-Enthusiast sind, kennen Sie wahrscheinlich den schnellen Quadratwurzelcode, der dank des ursprünglichen Quake 3-Codes berühmt wurde: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Q_rsqrt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> number)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x2, y; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> threehalfs = <span class="hljs-number"><span class="hljs-number">1.5f</span></span>; x2 = number * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; y = number; i = * (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>*) &amp;y; <span class="hljs-comment"><span class="hljs-comment">// evil floating point bit level hacking i = 0x5f3759df - ( i &gt;&gt; 1 ); // what the fuck? y = * ( float * ) &amp;i; y = y * ( threehalfs - ( x2 * y * y ) ); // 1st iteration return y; }</span></span></code> </pre> <br>  Auf der Suche nach <sup>[5]</sup> kontaktierte <sup>die</sup> Quelle Q_rsqrt Rys for Software Gary Tarolli, der sagte, dass er diesen Code verwendet habe, während er noch in SGI arbeitete.  Man kann also davon ausgehen, dass es auch in der SST1-Pipeline verwendet wurde. <br><br><h2>  Etwas passt nicht zusammen </h2><br>  Nachdem wir uns mit dem Förderer vertraut gemacht haben und wissen, dass jede Komponente (TMU, FBI, EDO RAM) mit einer Frequenz von 50 MHz arbeitet, können wir verstehen, dass die Berechnungen fehlerhaft sind und die Karte keine Geschwindigkeit von 50 Megapixeln / s erreichen kann.  Hier mussten zwei Probleme gelöst werden. <br><br>  Zunächst musste die TMU vier Texel lesen, um eine bilineare Texturfilterung durchzuführen.  Dies bedeutet, dass vier Zyklen für den Zugriff auf RAM erforderlich sind, was zu einem Mangel an Daten für TMU und einer Füllrate von 50/4 = 12,5 Megapixeln / s führen würde. <br><br>  Auf FBI-Ebene gibt es einen weiteren Engpass.  Wenn die Z-Puffer-Überprüfung aktiviert ist, sollte vor dem Schreiben oder Verwerfen der eingehende Z-Wert des Fragments mit dem verglichen werden, was sich bereits im Z-Puffer befindet.  Wenn der Test erfolgreich war, muss der Wert aufgezeichnet werden.  Dies sind zwei Operationen mit RAM, die zu einer Verringerung der Füllrate um die Hälfte führten: 50/2 = 25 Megapixel / s. <br><br><h2>  Vier-Wege-Interleaving-TMU </h2><br>  Die Lösung des Vier-Proben-Problems im TMU-Stadium wird in der SST1-Spezifikation erwähnt. <br><br><blockquote>  Die vollständige Verschachtelung ist im Texturspeicher-Datenpfad implementiert, wodurch eine einzelne Bank unabhängig von der Adresse, die für den Zugriff auf Daten in anderen Banken verwendet wird, auf Daten zugreifen kann. <br><br>  <i>- Spezifikation SST1</i> </blockquote><br>  Es wird nicht angezeigt, ob der Bus Adressmultiplex oder gemeinsame Daten- und Adressbusse verwendet.  Es ist einfacher herauszufinden, ob Sie sie ohne Multiplexing und ohne Trennung zeichnen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9f4/9b4/1ea/9f49b41ea0bbb672768b3b066a17e556.svg"></div><br>  Unabhängig von den Details konnte die TMU-Architektur 4 x 16-Bit-Texel pro Zyklus empfangen.  Wenn die Eingabedaten mit der richtigen Frequenz ankommen, kann die TMU eine fragmentweise Division durch w durchführen und dann den z-Wert des Fragments (16 Bit) und die Farbe des Fragments (16 Bit) erzeugen, die an das FBI übertragen wurden. <br><br><h2>  Zwei-Wege-Interleaving-FBI </h2><br>  Die Lösung des Problems von zwei RAM-Zugriffsoperationen in der FBI-Phase ist in der Spezifikation ebenfalls nicht beschrieben.  In dem Dokument wird jedoch eine Füllrate von 100 Megapixeln / s erwähnt, die mit glClear erreicht wird, da zwei Pixel pro Zyklus aufgezeichnet werden können. Dies macht uns verständlich, dass hier Zwei-Wege-Interlacing verwendet wurde. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/361/8bd/a7b/3618bda7b13296f51bc145a84dc86beb.svg"></div><br>  Das FBI hat zwei Pixel gleichzeitig gelesen und geschrieben (2 x 1 Pixel, bestehend aus 16-Bit-Farbe und 16-Bit-z = 64 Bit).  Zu diesem Zweck generiert die 21-Bit-Adresse zwei 20-Bit-Adressen, bei denen das niedrigstwertige Bit zum Lesen / Schreiben von zwei Pixeln der Reihe nach verworfen wird.  Da sich der zum Schreiben / Lesen in horizontalen Linien erforderliche Rasterlinienalgorithmus von links nach rechts bewegt, hat das gleichzeitige Lesen von zwei Ordnungspixeln sehr gut funktioniert. <br><br><h2>  64-Bit-Bus TMU-&gt; FBI </h2><br>  Das letzte Puzzleteil ist der 64-Bit-FBI-TMU-Bus.  In der Spezifikation ist fast nichts darüber geschrieben, aber sein Verhalten kann anhand der Daten verstanden werden, die das FBI verbraucht.  Da das FBI zwei Pixel gleichzeitig verarbeitet, ist davon auszugehen, dass die TMU Texel nicht so schnell wie möglich sendet, sondern zwei als zwei 16-Bit-Farben + 16-Bit-Z-Wert kombiniert. <br><br><h2>  Programmieren von Voodoo1 </h2><br>  Auf der untersten Ebene wurde die Voodoo1-Programmierung unter Verwendung von speicherabgebildeten Registern durchgeführt.  Die API besteht aus einer überraschend kleinen Anzahl von Befehlen, von denen es nur fünf gibt: TRIANGLECMD (mit einem festen Punkt), FTRIANGLECMD (mit einem Gleitkomma), NOPCMD (no-op), FASTFILLCMD (Pufferlöschung) und SWAPBUFFERCMD in Bezug auf das Laden von Datenregistern zum Mischen von Einstellungen, Z-Test, Nebelfarben-Downloads und mehr.  Das Laden der Textur in VRAM wurde über 8 MBibyte Nur-Schreib-PCI-RAM mit Speicherzuordnung durchgeführt. <br><br><h2>  (Real) Voodoo1-Programmierung </h2><br>  Die Entwickler programmierten Voodoo1 über die Glide-API <sup>[6]</sup> .  Die API-Entwurfslogik wurde von IRIS GL / OpenGL inspiriert. Sie verwendete eine Zustandsmaschine und Präfixe für alles (nur "gr" wurde anstelle von "gl" verwendet, und Programmierer mussten VRAM steuern, wie dies jetzt in Vulkan geschieht.) <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;glide.h&gt; void main( void ) { GrHwConfiguration hwconfig; grGlideInit(void); grSstSelect( 0 ); grSstQueryHardware(&amp;hwconfig); grSstSelect(0); grSstWinOpen(null, GR_RESOLUTION_640x480, GR_REFRESH_60HZ, GR_COLORFORMAT_RGBA, GR_ORIGIN_LOWER_LEFT, 2, 0); grBufferClear(0, 0, 0); GrVertex A, B, C; ... // Init A, B, and C. guColorCombineFunction( GR_COLORCOMBINE_ITRGB ); grDrawTriangle(&amp;A, &amp;B, &amp;C); grBufferSwap( 1 ); grGlideShutdown(); }</span></span></span></span></code> </pre> <br><h2>  "Standard" MiniGL </h2><br>  Obwohl MiniGL eine Teilmenge des OpenGL 1.1-Standards war, wurde nie eine Spezifikation dafür veröffentlicht.  MiniGL war "genau die Funktionen, die Quake verwendet".  Durch Ausführen von objdump für die Binärdatei quake.exe ist es einfach, eine "offizielle" Liste zu erstellen. <br><br><pre>  $ objdump -p glquake.exe |  grep "gl"<font></font>
<font></font>
 glAlphaFunc glDepthMask glLoadIdentity glShadeModel
 glBegin glDepthRange glLoadMatrixf glTexCoord2f
 glBlendFunc glDisable glMatrixMode glTexEnvf
 glClear glDrawBuffer glOrtho glTexImage2D
 glClearColor glEnable glPolygonMode glTexParameterf
 glColor3f glEnd glPopMatrix glTexSubImage2D
 glColor3ubv glFinish glPushMatrix glTranslatef
 glColor4f glFrustum glReadBuffer glVertex2f
 glColor4fv glGetFloatv glReadPixels glVertex3f
 glCullFace glGetString glRotatef glVertex3fv
 glDepthFunc glHint glScalef glViewport </pre><br><br>  Wenn Sie kürzlich mit dem Erlernen von OpenGL begonnen haben, sollten Sie von Funktionsnamen wie glColor3f, glTexCoord2f, glVertex3f, glTranslatef, glBegin und glEnd fasziniert sein.  Sie wurden für einen Modus namens "Sofortmodus" verwendet, in dem die Scheitelpunktkoordinate, Texturkoordinate, Matrixmanipulation und Farbe durch jeweils einen Funktionsaufruf angezeigt wurden. <br><br>  So wurde „damals“ ein vom Gouraud-Dreieck strukturiertes und schattiertes gezeichnet. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Render { glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glEnable(GL_TEXTURE_2D); glShadeModel(GL_SMOOTH); glBindTexture(GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Assume a texture was loaded in textureId=1 glMatrixMode(GL_PROJECTION); glLoadIdentity(); glOrtho(-1.0, 1.0, -1.0, 1.0, -1.0, 1.0); glMatrixMode(GL_MODELVIEW); glLoadIdentity(); glBegin(GL_TRIANGLES); glColor3f(1.0f, 1.0f, 1.0f); glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f,-0.25f,0.0f); glColor3f(0.0f, 0.0f, 0.0f); glTexCoord2f(1.0f, 0.0f); glVertex3f(-0.5f,-0.25f,0.0f); glColor3f(0.5f, 0.5f, 0.5f); glTexCoord2f(0.0f, 1.0f); glVertex3f(-0.75f,0.25f,0.0f); glEnd();</span></span></code> </pre> <br><h2>  GLQuake </h2><br>  Die theoretische maximale Füllrate von 50 Megapixeln / s sollte fast 50 Bilder pro Sekunde bei einer Auflösung von 640 x 480 liefern.  Da Quake jedoch zwei Texturebenen pro Oberfläche kombinierte (eine für Farbe, die andere für die Lichtkarte), musste SST1 jeden Frame zweimal mit zusätzlicher Überblendung im zweiten Durchgang zeichnen.  Infolgedessen lief Quake auf dem P166Mhz mit 26 fps. <br><br>  Durch Reduzieren der Auflösung auf 512 x 384 auf demselben Computer konnten glatte 41 fps <sup>[7]</sup> erzielt werden, die zu diesem Zeitpunkt von keinem Konkurrenten bereitgestellt werden konnten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/177/1bc/61c/1771bc61c289021a187aee52b5746828.png" alt="Bild"></div><br>  <i>Software-Rendering</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/816/6a4/30f/8166a430fbb7dfeeec12e973896ba8a5.png" alt="Bild"><br><h2>  GLQUAKE VOODOO1 </h2><br><br>  <b>Interessante Tatsache:</b> SST1 war nicht jedermanns Sache.  Einige Leute mochten die Pixel und fanden die bilineare Filterung "verschwommen".  Andere ärgerten sich über den Verlust der Gammakorrektur. <br><br><blockquote>  Glquake sieht beschissen aus.  Ich denke, jemand kann damit streiten, aber lassen Sie uns zugeben - es sieht schrecklich aus, besonders auf NVidia-Karten.  Auf 3dfx-Boards ist nicht alles so schlecht ... aber die Farben sind immer noch verschwommen.  Auf TNT2 ist das Bild ekelhaft;  Sie ist zu dunkel und düster. <br><br>  <i>- @Frib, Inoffizieller Glquake &amp; QW Guide</i> <sup>[8]</sup> </blockquote><br><h2>  3fdx Voodoo <sup>2</sup> </h2><hr><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62b/473/e96/62b473e965baa1937d47a6d37ae4e087.svg"></div><br>  Wenn ich sagen würde, dass 3dfx von 1996 bis 1998 auf dem Markt ist, wäre dies eine Untertreibung.  Nach SST1 hat die Voodoo <sup>2-</sup> Technologie die Messlatte dank 100-MHz-EDO-RAM, ASIC mit einer Frequenz von 90 MHz und nicht nur einer, sondern zwei TMUs, die das Rendern eines mehrstrukturierten Quake-Frames (Farbe + Beleuchtung) in einem Durchgang ermöglichen, noch höher gelegt <sup>[9]</sup> .  Diese Technologie war ein echtes Monster, und selbst die Grafikkarten selbst sahen luxuriös aus. <br><br>  Die Füllgeschwindigkeit in Voodoo <sup>2</sup> verdoppelte sich fast und erreichte 90 Megapixel / s.  Die Quake-Benchmarks stiegen auf dem Pentium II 266 MMX auf beeindruckende 80 fps (im Vergleich zu 56 fps mit Voodoo1) und stießen tatsächlich an die Grenzen der Spielelogik und der Monitorfunktionen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e6/d73/0bc/7e6d730bce2492ef8c380d026fc61625.jpg" alt="Bild"></div><br>  <i>Super Voodoo 2 12MB, Bild aus vgamuseum.info.</i> <br><br>  Leider machte die 3dfx-Geschichte nach der Veröffentlichung von Voodoo3 im Jahr 1999 eine scharfe Wendung.  Sie begann sich zu bemühen, ihre eigenen Universalkarten zu entwickeln, und hörte angesichts des zunehmenden Wettbewerbs auf, OEM-Technologie zu verkaufen. <br><br>  Dieser Übergang wurde nicht wie erwartet abgeschlossen, und die Leistung von Voodoo3 war im Vergleich zu NVidias GeForce 256, die Hardware-Tessellation und Beleuchtung bereitstellen kann, enttäuschend (Pentium hat diesen Teil in der Pipeline ausgeführt). <br><br>  Als Reaktion auf NVidia hat 3dfx die Entwicklung von Voodoo4 abgebrochen, um mit dem Bau von Voodoo5 mit VSA-100-Technologie (Voodoo Scalable Architecture) zu beginnen.  Das Ergebnis war unerwartet: Nach der Veröffentlichung von „Napalm“ (dem Codenamen der Karte) stieß sie auf leistungsstärkere NVidia GeForce 2- und ATI Radeon-Karten.  Am 28. März 2000 meldete 3dfx Insolvenz an und wurde von NVidia gekauft. <br><br>  Für diejenigen, die Ende der 90er Jahre lebten und das Vergnügen hatten, Voodoo1 oder Voodoo2 zu spielen, bleibt 3dfx ein Meilenstein für herausragende Leistungen.  Sie wurde eine Ode an den verdienten Erfolg, der durch Mut, herausragendes Talent und harte Arbeit erzielt wurde.  Danke Jungs! <br><br><h2>  Referenzen </h2><br>  [1] Quelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Geschichte der Rendition Vérité 1000</a> <br><br>  [2] Quelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">John Carmack .plan.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">12. Februar 1998</a> <br><br>  [3] Quelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SST-1, HIGH PERFORMANCE GRAPHICS ENGINE FÜR 3D-SPIELBESCHLEUNIGUNG</a> <br><br>  [4] Quelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3dfx Oral History Panel</a> <br><br>  [5] Quelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ursprung von Quake3s Fast InvSqrt ()</a> <br><br>  [6] Quelle: <a href="">Glide-Programmierhandbuch</a> <br><br>  [7] Quelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vergleich der Frameraten in GLQuake mit Voodoo &amp; Voodoo 2 3D-Karten</a> <br><br>  [8] Quelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Frib, Inoffizieller Glquake &amp; QW Guide</a> <br><br>  [9] Quelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VOODOO2 GRAPHICS HIGH PERFORMANCE GRAPHICS ENGINE FÜR DIE BESCHLEUNIGUNG VON 3D-SPIELEN</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446860/">https://habr.com/ru/post/de446860/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446848/index.html">Was kostet ein Google Stadia-Abonnement?</a></li>
<li><a href="../de446850/index.html">Videos vom CocoaHeads-Treffen am 15. März im Büro von Tutu.ru</a></li>
<li><a href="../de446852/index.html">TEMPEST und EMSEC: Ist es möglich, elektromagnetische Wellen bei Cyberangriffen einzusetzen?</a></li>
<li><a href="../de446854/index.html">Azure Tech Lab, 11. April in Moskau</a></li>
<li><a href="../de446858/index.html">So stellen Sie SAP HANA bereit: Analysieren verschiedener Methoden</a></li>
<li><a href="../de446862/index.html">Was Designer auf der DUMP-2019 erwarten: Überblick über den Designbereich</a></li>
<li><a href="../de446864/index.html">Energie, Wärme und Wasser</a></li>
<li><a href="../de446866/index.html">Betriebssysteme: Drei einfache Teile. Teil 2: Abstraktion: Prozess (Übersetzung)</a></li>
<li><a href="../de446870/index.html">Partikelsysteme: eine Weihnachtsgeschichte</a></li>
<li><a href="../de446872/index.html">Erkundung von OpenCV auf StereoPi: Tiefenkarte aus Video</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>