<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôáüèª üßïüèæ üñ±Ô∏è Indexando bilh√µes de vetores de texto üí∏ üõ£Ô∏è üåΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ao extrair informa√ß√µes, muitas vezes surge a tarefa de encontrar esses fragmentos de texto. No contexto de uma pesquisa, uma consulta pode ser gerada ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Indexando bilh√µes de vetores de texto</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/479692/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/id/dd/fg/idddfg6zku7xq-zv9f0m8xemyiy.jpeg"></div><br>  Ao extrair informa√ß√µes, muitas vezes surge a tarefa de encontrar <i>esses</i> fragmentos de texto.  No contexto de uma pesquisa, uma consulta pode ser gerada pelo usu√°rio (por exemplo, o texto que o usu√°rio digita no mecanismo de pesquisa) ou pelo pr√≥prio sistema.  Frequentemente, precisamos corresponder uma consulta recebida com consultas j√° indexadas.  Neste artigo, veremos como voc√™ pode criar um sistema que resolva esse problema em rela√ß√£o a bilh√µes de solicita√ß√µes sem gastar uma fortuna na infraestrutura do servidor. <br><a name="habracut"></a><br>  Primeiro, definimos formalmente o problema: <br><br><blockquote>  Dado um conjunto fixo de consultas <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2">Q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-1"> Q </script>  pedido recebido <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-3"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4">q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-2"> q </script>  e inteiro <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-5"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6">k</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-3"> k </script>  .  Precisa encontrar esse subconjunto de consultas <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-7"><span class="noError" id="MJXp-Span-8" style="display: inline-block;">R&nbsp;=&nbsp;\&nbsp;left&nbsp;\&nbsp;{q0,&nbsp;q1,&nbsp;...,&nbsp;qk&nbsp;\&nbsp;right&nbsp;\}&nbsp;\&nbsp;subconjunto&nbsp;Q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-4"> R = \ left \ {q0, q1, ..., qk \ right \} \ subconjunto Q </script>  para cada solicita√ß√£o <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-9"><span class="MJXp-msubsup" id="MJXp-Span-10"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-11" style="margin-right: 0.05em;">q</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-12" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-13">i</span></span></span><span class="MJXp-mtext" id="MJXp-Span-14">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-15">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-16">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-17">R</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-5"> q_ {i} \ em R </script>  era mais como <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-18"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-19">q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-6"> q </script>  do que qualquer outro pedido em <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-20"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-21">Q</span><span class="MJXp-mo" id="MJXp-Span-22" style="margin-left: 0.267em; margin-right: 0.267em;">‚àñ</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23">R</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-7"> Q ‚àñ R </script>  . </blockquote><br>  Por exemplo, com este conjunto de consultas <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-24"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-25">Q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-8"> Q </script>  : <br><br><pre><code class="plaintext hljs">{tesla cybertruck, beginner bicycle gear, eggplant dishes, tesla new car, how expensive is cybertruck, vegetarian food, shimano 105 vs ultegra, building a carbon bike, zucchini recipes}</code> </pre> <br>  e <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-26"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-27">k</span><span class="MJXp-mo" id="MJXp-Span-28" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-29">3</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9"> k = 3 </script>  Voc√™ pode esperar este resultado: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Solicita√ß√£o de entrada <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-30"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-31">q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-10"> q </script><br></th><th>  Consultas semelhantes <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-32"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-33">R</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-11"> R </script><br></th></tr><tr><td>  pickup tesla <br></td><td>  {tesla cybertruck, carro novo tesla, qu√£o caro √© o cybertruck} <br></td></tr><tr><td>  melhor moto 2019 <br></td><td>  {shimano 105 vs ultegra, as bicicletas de carbono s√£o melhores, as artes de bicicleta} <br></td></tr><tr><td>  cozinhar com legumes <br></td><td>  {pratos de berinjela, receitas de abobrinha, comida vegetariana} <br></td></tr></tbody></table></div><br>  Observe que ainda n√£o definimos um crit√©rio de <i>similaridade</i> .  Nesse contexto, isso pode significar quase tudo, mas geralmente se resume a alguma forma de similaridade com base em palavras-chave ou vetores.  Usando similaridade com base em palavras-chave, podemos encontrar duas consultas semelhantes se elas contiverem palavras comuns suficientes.  Por exemplo, as consultas "abrir um restaurante em munique" e "melhor restaurante de munique" s√£o semelhantes porque cont√™m as palavras "restaurante" e "munique".  E as perguntas "melhor restaurante de munique" e "onde comer em munique" j√° s√£o menos semelhantes, porque t√™m apenas uma palavra comum.  No entanto, quem procura um restaurante em Munique ficaria melhor se o segundo par de pedidos fosse semelhante.  E nisso ajudaremos a compara√ß√£o com base em vetores. <br><br><h1>  Representa√ß√£o vetorial de palavras </h1><br>  A representa√ß√£o vetorial de palavras √© uma t√©cnica de aprendizado de m√°quina usada no processamento de linguagem natural para converter texto ou palavras em vetores.  Movendo a tarefa para o espa√ßo vetorial, podemos usar opera√ß√µes matem√°ticas com vetores - somando e calculando dist√¢ncias.  Para estabelecer links entre palavras semelhantes, voc√™ pode usar m√©todos tradicionais de agrupamento de vetores.  <i>O significado</i> dessas opera√ß√µes no espa√ßo de palavras original pode n√£o ser √≥bvio, mas a vantagem √© que agora temos acesso a uma ampla gama de ferramentas matem√°ticas.  Se voc√™ estiver interessado em detalhes sobre vetores de palavras e sua aplica√ß√£o, leia sobre <a href="https://arxiv.org/pdf/1301.3781.pdf">word2vec</a> e <a href="https://nlp.stanford.edu/pubs/glove.pdf">GloVe</a> . <br><br>  Temos uma maneira de gerar vetores a partir de palavras, agora vamos reuni-los em vetores de texto (vetores de documentos ou express√µes).  A maneira mais f√°cil de fazer isso √© adicionando (ou calculando a m√©dia) os vetores de todas as palavras no texto. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/692/bc5/b0c/692bc5b0ccbbe7a89392528365645708.png"><br>  <i><sup>Figura 1: Vetores de consulta.</sup></i> <br><br>  Agora voc√™ pode determinar a semelhan√ßa de duas partes do texto (ou consultas) representando-as no espa√ßo vetorial e calculando a dist√¢ncia entre os vetores.  Normalmente, uma dist√¢ncia angular √© usada para isso. <br><br>  Como resultado, a representa√ß√£o vetorial de palavras permite a correspond√™ncia textual de um tipo diferente, que complementa a correspond√™ncia baseada em palavras-chave.  Voc√™ pode explorar a semelhan√ßa sem√¢ntica dos pedidos (por exemplo, "melhor restaurante de munique" e "onde comer em munique"), como n√£o pod√≠amos fazer antes. <br><br><h1>  Pesquisa por Vizinho Mais Pr√≥ximo Aproximado </h1><br>  Agora podemos refinar nosso problema de correspond√™ncia de consulta original: <br><br><blockquote>  Dado um conjunto fixo de vetores de consulta <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-34"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-35">Q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-12"> Q </script>  vetor de entrada <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-36"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-37">q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-13"> q </script>  e inteiro <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-38"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-39">k</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-14"> k </script>  .  Voc√™ precisa encontrar esse subconjunto de vetores <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-40"><span class="noError" id="MJXp-Span-41" style="display: inline-block;">R&nbsp;=&nbsp;\&nbsp;left&nbsp;\&nbsp;{q0,&nbsp;q1,&nbsp;...,&nbsp;qk&nbsp;\&nbsp;right&nbsp;\}&nbsp;\&nbsp;subconjunto&nbsp;Q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-15"> R = \ left \ {q0, q1, ..., qk \ right \} \ subconjunto Q </script>  de modo que a dist√¢ncia angular de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-42"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-43">q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-16"> q </script>  para cada vetor <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-44"><span class="MJXp-msubsup" id="MJXp-Span-45"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-46" style="margin-right: 0.05em;">q</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-47" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-48">i</span></span></span><span class="MJXp-mtext" id="MJXp-Span-49">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-50">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-51">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-52">R</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-17-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-17"> q_ {i} \ em R </script>  foi menor que a dist√¢ncia para qualquer outro vetor <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-53"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-54">Q</span><span class="MJXp-mo" id="MJXp-Span-55" style="margin-left: 0.267em; margin-right: 0.267em;">‚àñ</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-56">R</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-18-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-18"> Q ‚àñ R </script>  . </blockquote><br>  Isso √© chamado de tarefa de encontrar o vizinho mais pr√≥ximo.  Existem <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25B4%25D0%25B0%25D1%2587%25D0%25B0_%25D0%25BF%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA%25D0%25B0_%25D0%25B1%25D0%25BB%25D0%25B8%25D0%25B6%25D0%25B0%25D0%25B9%25D1%2588%25D0%25B5%25D0%25B3%25D0%25BE_%25D1%2581%25D0%25BE%25D1%2581%25D0%25B5%25D0%25B4%25D0%25B0">v√°rios algoritmos</a> para sua solu√ß√£o r√°pida em espa√ßos de baixa dimens√£o.  Por√©m, ao trabalhar com representa√ß√µes vetoriais de palavras, geralmente operamos com vetores de alta dimens√£o (100-1000 dimens√µes).  E aqui os m√©todos mencionados n√£o funcionam mais. <br><br>  N√£o existe uma maneira adequada de determinar rapidamente os vizinhos mais pr√≥ximos em espa√ßos de alta dimens√£o.  Portanto, simplificamos o problema permitindo o uso de resultados aproximados: em vez de sempre retornar <i>os</i> vetores mais pr√≥ximos, ficaremos satisfeitos com apenas alguns dos vizinhos mais pr√≥ximos ou <i>at√© certo ponto</i> pr√≥ximos.  Isso √© chamado de tarefa de busca aproximada dos vizinhos mais pr√≥ximos e √© uma √°rea de pesquisa ativa. <br><br><h3>  Mundo pequeno hier√°rquico </h3><br>  O gr√°fico de mundo pequeno naveg√°vel hier√°rquico ( <a href="https://arxiv.org/abs/1603.09320">HNSW</a> ) √© um dos algoritmos mais r√°pidos para a pesquisa aproximada dos vizinhos mais pr√≥ximos.  O √≠ndice de pesquisa no HNSW √© uma estrutura de v√°rios n√≠veis, na qual cada n√≠vel √© um gr√°fico de proximidade.  Cada n√≥ do gr√°fico corresponde a um dos vetores de consulta. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/42e/55e/4b7/42e55e4b72cd088b45e5aff56159f7fb.png"><br>  <sup><i>Figura 2: Gr√°fico de proximidade multin√≠vel.</i></sup> <br>  Encontrar vizinhos mais pr√≥ximos no HNSW usa o m√©todo de aumento de zoom.  Ele inicia no n√≥ de entrada do n√≠vel mais alto e executa recursivamente o percurso de gr√°fico ganancioso em cada n√≠vel at√© atingir um m√≠nimo local na parte inferior. <br><br>  Detalhes sobre o algoritmo e a t√©cnica de pesquisa est√£o bem descritos no trabalho cient√≠fico.  √â importante lembrar que cada ciclo de pesquisa dos vizinhos mais pr√≥ximos consiste em percorrer os n√≥s dos gr√°ficos e calcular as dist√¢ncias entre os vetores.  Examinaremos essas etapas abaixo para usar esse m√©todo para criar um √≠ndice em larga escala. <br><br><h1>  A dificuldade de indexar bilh√µes de consultas </h1><br>  Suponha que precisamos indexar 4 bilh√µes de vetores de consulta 200-dimensionais, com cada dimens√£o representada por um n√∫mero de ponto flutuante de quatro bytes (4 bilh√µes s√£o suficientes para tornar a tarefa interessante, mas voc√™ ainda pode armazenar os IDs dos n√≥s em n√∫meros regulares de quatro bytes) .  Um c√°lculo aproximado indica que o tamanho dos vetores ser√° de aproximadamente 3 TB.  Como a maioria das bibliotecas existentes usa uma capacidade de RAM para uma pesquisa aproximada dos vizinhos mais pr√≥ximos, precisaremos de um servidor muito grande para inserir pelo menos vetores na RAM.  Observe que isso n√£o leva em considera√ß√£o o √≠ndice de pesquisa adicional, necess√°rio para a maioria dos m√©todos. <br><br>  Em toda a hist√≥ria do desenvolvimento de nosso mecanismo de pesquisa, usamos v√°rias abordagens diferentes para resolver esse problema.  Vamos considerar alguns deles. <br><br><h3>  Subconjunto de dados </h3><br>  A primeira e mais simples abordagem, que n√£o nos permitiu resolver completamente o problema, foi limitar o n√∫mero de vetores no √≠ndice.  Tomando um d√©cimo dos dados, criamos um √≠ndice que precisa - surpresa - 10% da mem√≥ria.  No entanto, a qualidade da pesquisa se deteriorou, porque agora operamos com menos consultas. <br><br><h3>  Quantiza√ß√£o </h3><br>  Aqui, usamos todos os dados, mas os reduzimos usando a <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B2%25D0%25B0%25D0%25BD%25D1%2582%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">quantiza√ß√£o</a> (usamos diferentes t√©cnicas de quantiza√ß√£o, por exemplo, quantiza√ß√£o do produto, mas n√£o conseguimos atingir a qualidade desejada de trabalho com essa quantidade de dados).  Ao arredondar alguns erros, conseguimos substituir todos os n√∫meros de quatro bytes nos vetores originais por vers√µes quantizadas de um byte.  A quantidade de RAM para vetores diminuiu 75%.  No entanto, ainda precis√°vamos de 750 GB de mem√≥ria (sem contar o tamanho do pr√≥prio √≠ndice), e este ainda √© um servidor muito grande. <br><br><h1>  Resolvendo problemas de mem√≥ria com o Granne </h1><br>  As abordagens descritas tiveram suas vantagens, mas exigiram muitos recursos e deram baixa qualidade √† pesquisa.  Embora <a href="http://ann-benchmarks.com/">existam bibliotecas</a> que respondem em menos de 1 ms, poder√≠amos sacrificar a velocidade em troca de requisitos de hardware mais baixos. <br><br>  <a href="https://github.com/granne/granne">Granne</a> (vizinhos mais pr√≥ximos aproximados baseados em gr√°ficos) √© uma biblioteca HNSW desenvolvida e usada pela Cliqz para pesquisar essas consultas.  Possui c√≥digo-fonte aberto, mas a biblioteca ainda est√° em desenvolvimento ativo.  Uma vers√£o melhorada ser√° publicada no <a href="https://crates.io/">crates.io</a> em 2020.  Est√° escrito em Rust com inser√ß√µes Python, projetado para lidar com bilh√µes de vetores usando competitividade.  Do ponto de vista dos vetores de consulta, √© interessante que o Granne tenha um modo especial que exija muito menos mem√≥ria em compara√ß√£o com outras bibliotecas. <br><br><h3>  Representa√ß√£o compacta de vetores de consulta </h3><br>  Reduzir o tamanho dos vetores de consulta nos dar√° muitos benef√≠cios.  Para fazer isso, vamos voltar e considerar a cria√ß√£o de vetores.  Como as consultas s√£o compostas de palavras e os vetores de consulta s√£o somas de vetores de palavras, podemos recusar explicitamente o armazenamento de vetores de consulta e calcul√°-los conforme necess√°rio. <br><br>  Voc√™ pode armazenar consultas na forma de conjuntos de palavras e usar a tabela de pesquisa para encontrar os vetores correspondentes.  No entanto, evitamos o redirecionamento armazenando cada consulta como uma lista de IDs inteiros correspondentes aos vetores de palavras na consulta.  Por exemplo, salve a consulta "melhor restaurante de munique" como <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-57"><span class="MJXp-mo" id="MJXp-Span-58" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mrow" id="MJXp-Span-59"><span class="MJXp-msubsup" id="MJXp-Span-60"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-61" style="margin-right: 0.05em;">i</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-62" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-63">b</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-64">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-65">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-66">t</span></span></span></span><span class="MJXp-mo" id="MJXp-Span-67" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mrow" id="MJXp-Span-68"><span class="MJXp-msubsup" id="MJXp-Span-69"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-70" style="margin-right: 0.05em;">i</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-71" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-72">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-73">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-74">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-75">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-76">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-77">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-78">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-79">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-80">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-81">t</span></span></span></span><span class="MJXp-mo" id="MJXp-Span-82" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mrow" id="MJXp-Span-83"><span class="MJXp-msubsup" id="MJXp-Span-84"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-85" style="margin-right: 0.05em;">i</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-86" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-87">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-88">f</span></span></span></span><span class="MJXp-mo" id="MJXp-Span-89" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mrow" id="MJXp-Span-90"><span class="MJXp-msubsup" id="MJXp-Span-91"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-92" style="margin-right: 0.05em;">i</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-93" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-94">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-95">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-96">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-97">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-98">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-99">h</span></span></span></span><span class="MJXp-mo" id="MJXp-Span-100" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-19"> [{i_ {best}}, {i_ {restaurant}}, {i_ {of}}, {i_ {munich}}] </script>  onde <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-101"><span class="MJXp-mrow" id="MJXp-Span-102"><span class="MJXp-msubsup" id="MJXp-Span-103"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-104" style="margin-right: 0.05em;">i</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-105" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-106">b</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-107">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-108">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-109">t</span></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-20-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-20"> {i_ {best}} </script>  - esse √© o ID do vetor da palavra "melhor" etc. Suponha que tenhamos menos de 16 milh√µes de vetores de palavras (mais do que esse valor custar√° 1 byte por palavra), ent√£o voc√™ pode usar 3 bytes para representar todos os IDs de palavras.  Ou seja, em vez de armazenar 800 bytes (ou 200 bytes no caso de vetores quantizados), armazenaremos apenas 12 bytes para esta solicita√ß√£o (isso n√£o √© totalmente verdade. Como as solicita√ß√µes consistem em um n√∫mero diferente de palavras, tamb√©m precisamos armazenar o deslocamento da lista no √≠ndice de palavras. isso exigir√° 5 bytes por solicita√ß√£o). <br><br>  Quanto aos vetores de palavras, todos precisamos deles.  No entanto, o n√∫mero de palavras √© muito menor que o n√∫mero de consultas que podem ser criadas combinando essas palavras.  E isso significa que o tamanho das palavras n√£o √© t√£o importante.  Se voc√™ armazenar vetores de palavras como vers√µes de ponto flutuante de quatro bytes em uma matriz simples <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-110"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-111">v</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-21-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-21"> v </script>  , precisamos de menos de 1 GB para cada milh√£o de palavras.  Este volume pode caber facilmente na RAM.  Agora, o vetor de consulta fica assim: <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-112"><span class="noError" id="MJXp-Span-113" style="display: inline-block;">{v&nbsp;_&nbsp;{{i_&nbsp;{best}}}}&nbsp;+&nbsp;{v&nbsp;_&nbsp;{{i_&nbsp;{restaurant}}}&nbsp;+&nbsp;{v&nbsp;_&nbsp;{{i_&nbsp;{of}}}&nbsp;+&nbsp;{v&nbsp;_&nbsp;{{i_&nbsp;{munich}}}}</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-22-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-22"> {v _ {{i_ {best}}}} + {v _ {{i_ {restaurant}}} + {v _ {{i_ {of}}} + {v _ {{i_ {munich}}}} </script>  . <br><br>  O tamanho final do envio da consulta depende do n√∫mero total de palavras na consulta.  Para 4 bilh√µes de consultas, s√£o cerca de 80 GB (incluindo vetores de palavras).  Em outras palavras, comparado aos vetores de palavras originais, o tamanho diminuiu 97% e comparado aos vetores quantizados - 90%. <br><br>  E mais uma coisa.  Para uma pesquisa, precisamos visitar aproximadamente 200 a 300 n√≥s do gr√°fico.  Cada n√≥ tem 20 a 30 vizinhos.  Portanto, precisamos calcular a dist√¢ncia do vetor de consulta de entrada aos 4000-9000 vetores no √≠ndice.  E mais, precisamos gerar vetores.  Quanto tempo leva para criar vetores de consulta rapidamente? <br><br>  Acontece que, com um processador relativamente novo, esse problema pode ser resolvido em alguns milissegundos.  Uma solicita√ß√£o que costumava ser executada em 1 ms agora √© executada em cerca de 5 ms.  Mas reduzimos a quantidade de mem√≥ria para vetores em 90%.  Aceitamos com prazer esse compromisso. <br><br><h3>  Exibir na mem√≥ria de vetores e √≠ndice </h3><br>  Acima, resolvemos o problema de reduzir a quantidade de mem√≥ria para vetores.  Mas depois que resolvemos esse problema, a pr√≥pria estrutura do √≠ndice se tornou um fator limitante.  Agora voc√™ precisa reduzir seu tamanho. <br><br>  No Granne, a estrutura do gr√°fico √© armazenada compactamente na forma de uma lista de adjac√™ncias com um n√∫mero vari√°vel de vizinhos para cada n√≥.  Ou seja, a mem√≥ria dificilmente √© desperdi√ßada em metadados.  O tamanho da estrutura do √≠ndice depende muito dos par√¢metros de design e das propriedades do gr√°fico.  No entanto, para ter uma id√©ia do tamanho do √≠ndice, basta dizer que podemos criar um √≠ndice para 4 bilh√µes de vetores com um tamanho total de cerca de 240 GB.  Isso pode ser aceit√°vel para uso na mem√≥ria em um servidor grande, mas pode ser feito melhor. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e73/daa/0de/e73daa0dea90e3e84afe9aaec7bd6a8e.jpg"><br>  <sup><i>Figura 3: Dois layouts diferentes na RAM e SSD.</i></sup> <br><br>  Uma propriedade importante do Granne √© a capacidade de <a href="https://ru.wikipedia.org/wiki/Mmap">exibir os</a> vetores de √≠ndice e consulta <a href="https://ru.wikipedia.org/wiki/Mmap">na mem√≥ria</a> .  Isso nos permite carregar pregui√ßosamente o √≠ndice e compartilhar mem√≥ria com v√°rios processos.  Os arquivos de √≠ndice e consulta s√£o divididos em arquivos de exibi√ß√£o separados na mem√≥ria e podem ser usados ‚Äã‚Äãem diferentes layouts na RAM e no SSD.  Se os requisitos para o atraso forem um pouco menores, ent√£o, colocando o √≠ndice no SSD, solicita√ß√µes para RAM, mantemos uma velocidade aceit√°vel sem consumo excessivo de mem√≥ria.  No final do artigo, veremos como esse compromisso se parece. <br><br><h3>  Melhorando a localidade dos dados </h3><br>  Em nossa configura√ß√£o atual, quando o √≠ndice est√° em um SSD, cada solicita√ß√£o requer de 200 a 300 leituras do disco.  Voc√™ pode tentar aumentar a localidade dos dados organizando os elementos cujos vetores est√£o t√£o pr√≥ximos que seus n√≥s HNSW est√£o localizados no √≠ndice tamb√©m n√£o muito longe um do outro.  A localidade dos dados melhora o desempenho, porque √© mais prov√°vel que uma opera√ß√£o de leitura √∫nica (geralmente extra√≠da de 4 KB) contenha outros n√≥s necess√°rios para percorrer o gr√°fico.  E isso, por sua vez, reduz o n√∫mero de recupera√ß√µes de dados por uma pesquisa. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1f8/1d2/2f4/1f81d22f418256c704bb12b7514e68a1.jpg"><br>  <sup><i>Figura 4: A localidade dos dados reduz a recupera√ß√£o de informa√ß√µes.</i></sup> <br><br>  Deve-se notar que os elementos de reordena√ß√£o n√£o afetam os resultados da pesquisa; √© uma maneira de acelerar isso.  Ou seja, o pedido pode ser qualquer, mas nem todas as op√ß√µes aceleram a pesquisa.  √â muito dif√≠cil encontrar a ordem ideal.  No entanto, a heur√≠stica que usamos com sucesso √© classificar as consultas pela palavra mais <i>importante</i> em cada consulta. <br><br><h1>  Conclus√£o </h1><br>  Usamos o Granne para criar e manter √≠ndices de bilh√µes de d√≥lares com vetores de consulta, a fim de procurar consultas semelhantes com consumo de mem√≥ria relativamente baixo.  A tabela abaixo mostra os requisitos para diferentes m√©todos.  Seja c√©tico em rela√ß√£o aos valores absolutos dos atrasos durante a pesquisa, porque eles dependem fortemente do que √© considerado uma resposta aceit√°vel.  No entanto, essas informa√ß√µes descrevem o desempenho relativo dos m√©todos. <br><br><div class="scrollable-table"><table><tbody><tr><th></th><th>  Valor inicial <br></th><th>  Quantiza√ß√£o <br></th><th>  Granne (apenas RAM) <br></th><th>  Granne (RAM + SSD) <br></th></tr><tr><td>  <b>A mem√≥ria</b> <br></td><td>  3000 + 240 GB <br></td><td>  750 + 240 GB <br></td><td>  80 + 240 GB <br></td><td>  80-150 GB * <br></td></tr><tr><td>  <b>SSD</b> <br></td><td>  - </td><td>  - </td><td>  - </td><td>  240 GB <br></td></tr><tr><td>  <b>Atraso</b> <br></td><td>  1 ms <br></td><td>  1 ms <br></td><td>  5 ms <br></td><td>  10-50 ms <br></td></tr></tbody></table></div><br>  <i>* A aloca√ß√£o de um √≠ndice de mem√≥ria maior que a quantidade necess√°ria levou ao cache de alguns n√≥s (frequentemente visitados), o que reduziu o atraso na pesquisa.</i>  <i>Nenhum cache interno foi usado para isso, apenas ferramentas internas do SO (kernel do Linux).</i> <br><br>  Deve-se notar que algumas das otimiza√ß√µes mencionadas no artigo n√£o s√£o aplic√°veis ‚Äã‚Äãpara resolver o problema geral de encontrar vizinhos mais pr√≥ximos com vetores indecompon√≠veis.  No entanto, eles s√£o aplic√°veis ‚Äã‚Äãem qualquer situa√ß√£o em que os elementos possam ser gerados a partir de menos partes (como √© o caso de palavras e consultas).  Caso contr√°rio, voc√™ ainda poder√° usar o Granne com os vetores de origem, mas ser√° necess√°rio mais mem√≥ria, como em outras bibliotecas. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt479692/">https://habr.com/ru/post/pt479692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt479682/index.html">Relat√≥rio de uso de cont√™iner Sysdig 2019: novos Kubernetes e detalhes de seguran√ßa</a></li>
<li><a href="../pt479684/index.html">Como coletar chaves de baixa frequ√™ncia para SEO: 4 maneiras n√£o triviais</a></li>
<li><a href="../pt479686/index.html">Principais tend√™ncias na terceiriza√ß√£o de TI ap√≥s 2020</a></li>
<li><a href="../pt479688/index.html">Em quais pa√≠ses e cidades os desenvolvedores ganham mais quando consideram impostos e custo de vida?</a></li>
<li><a href="../pt479690/index.html">Zork e Z-Machine: como os desenvolvedores transferiram o jogo dos mainframes para os computadores dom√©sticos de 8 bits</a></li>
<li><a href="../pt479696/index.html">Algumas palavras sobre Alter Table, ou como n√£o faz√™-lo</a></li>
<li><a href="../pt479700/index.html">CIMON-2: (des) Doomsday, ou como o IBM Watson subiu acima das nuvens</a></li>
<li><a href="../pt479702/index.html">Torradeira, Meu c√≠rculo e Freelansim se tornam parte da Habr</a></li>
<li><a href="../pt479704/index.html">Escalonamento de privil√©gios no cliente EA Origin Windows (CVE-2019-19247 e CVE-2019-19248)</a></li>
<li><a href="../pt479708/index.html">Postagem n√£o oficial sobre a rebranding da Habr + Competition</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>