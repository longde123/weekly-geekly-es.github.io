<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙇🏻 🧕🏾 🖱️ Indexando bilhões de vetores de texto 💸 🛣️ 🌽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ao extrair informações, muitas vezes surge a tarefa de encontrar esses fragmentos de texto. No contexto de uma pesquisa, uma consulta pode ser gerada ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Indexando bilhões de vetores de texto</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/479692/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/id/dd/fg/idddfg6zku7xq-zv9f0m8xemyiy.jpeg"></div><br>  Ao extrair informações, muitas vezes surge a tarefa de encontrar <i>esses</i> fragmentos de texto.  No contexto de uma pesquisa, uma consulta pode ser gerada pelo usuário (por exemplo, o texto que o usuário digita no mecanismo de pesquisa) ou pelo próprio sistema.  Frequentemente, precisamos corresponder uma consulta recebida com consultas já indexadas.  Neste artigo, veremos como você pode criar um sistema que resolva esse problema em relação a bilhões de solicitações sem gastar uma fortuna na infraestrutura do servidor. <br><a name="habracut"></a><br>  Primeiro, definimos formalmente o problema: <br><br><blockquote>  Dado um conjunto fixo de consultas <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2">Q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-1"> Q </script>  pedido recebido <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-3"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4">q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-2"> q </script>  e inteiro <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-5"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6">k</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-3"> k </script>  .  Precisa encontrar esse subconjunto de consultas <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-7"><span class="noError" id="MJXp-Span-8" style="display: inline-block;">R&nbsp;=&nbsp;\&nbsp;left&nbsp;\&nbsp;{q0,&nbsp;q1,&nbsp;...,&nbsp;qk&nbsp;\&nbsp;right&nbsp;\}&nbsp;\&nbsp;subconjunto&nbsp;Q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-4"> R = \ left \ {q0, q1, ..., qk \ right \} \ subconjunto Q </script>  para cada solicitação <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-9"><span class="MJXp-msubsup" id="MJXp-Span-10"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-11" style="margin-right: 0.05em;">q</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-12" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-13">i</span></span></span><span class="MJXp-mtext" id="MJXp-Span-14">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-15">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-16">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-17">R</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-5"> q_ {i} \ em R </script>  era mais como <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-18"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-19">q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-6"> q </script>  do que qualquer outro pedido em <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-20"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-21">Q</span><span class="MJXp-mo" id="MJXp-Span-22" style="margin-left: 0.267em; margin-right: 0.267em;">∖</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23">R</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-7"> Q ∖ R </script>  . </blockquote><br>  Por exemplo, com este conjunto de consultas <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-24"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-25">Q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-8"> Q </script>  : <br><br><pre><code class="plaintext hljs">{tesla cybertruck, beginner bicycle gear, eggplant dishes, tesla new car, how expensive is cybertruck, vegetarian food, shimano 105 vs ultegra, building a carbon bike, zucchini recipes}</code> </pre> <br>  e <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-26"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-27">k</span><span class="MJXp-mo" id="MJXp-Span-28" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-29">3</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9"> k = 3 </script>  Você pode esperar este resultado: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Solicitação de entrada <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-30"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-31">q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-10"> q </script><br></th><th>  Consultas semelhantes <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-32"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-33">R</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-11"> R </script><br></th></tr><tr><td>  pickup tesla <br></td><td>  {tesla cybertruck, carro novo tesla, quão caro é o cybertruck} <br></td></tr><tr><td>  melhor moto 2019 <br></td><td>  {shimano 105 vs ultegra, as bicicletas de carbono são melhores, as artes de bicicleta} <br></td></tr><tr><td>  cozinhar com legumes <br></td><td>  {pratos de berinjela, receitas de abobrinha, comida vegetariana} <br></td></tr></tbody></table></div><br>  Observe que ainda não definimos um critério de <i>similaridade</i> .  Nesse contexto, isso pode significar quase tudo, mas geralmente se resume a alguma forma de similaridade com base em palavras-chave ou vetores.  Usando similaridade com base em palavras-chave, podemos encontrar duas consultas semelhantes se elas contiverem palavras comuns suficientes.  Por exemplo, as consultas "abrir um restaurante em munique" e "melhor restaurante de munique" são semelhantes porque contêm as palavras "restaurante" e "munique".  E as perguntas "melhor restaurante de munique" e "onde comer em munique" já são menos semelhantes, porque têm apenas uma palavra comum.  No entanto, quem procura um restaurante em Munique ficaria melhor se o segundo par de pedidos fosse semelhante.  E nisso ajudaremos a comparação com base em vetores. <br><br><h1>  Representação vetorial de palavras </h1><br>  A representação vetorial de palavras é uma técnica de aprendizado de máquina usada no processamento de linguagem natural para converter texto ou palavras em vetores.  Movendo a tarefa para o espaço vetorial, podemos usar operações matemáticas com vetores - somando e calculando distâncias.  Para estabelecer links entre palavras semelhantes, você pode usar métodos tradicionais de agrupamento de vetores.  <i>O significado</i> dessas operações no espaço de palavras original pode não ser óbvio, mas a vantagem é que agora temos acesso a uma ampla gama de ferramentas matemáticas.  Se você estiver interessado em detalhes sobre vetores de palavras e sua aplicação, leia sobre <a href="https://arxiv.org/pdf/1301.3781.pdf">word2vec</a> e <a href="https://nlp.stanford.edu/pubs/glove.pdf">GloVe</a> . <br><br>  Temos uma maneira de gerar vetores a partir de palavras, agora vamos reuni-los em vetores de texto (vetores de documentos ou expressões).  A maneira mais fácil de fazer isso é adicionando (ou calculando a média) os vetores de todas as palavras no texto. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/692/bc5/b0c/692bc5b0ccbbe7a89392528365645708.png"><br>  <i><sup>Figura 1: Vetores de consulta.</sup></i> <br><br>  Agora você pode determinar a semelhança de duas partes do texto (ou consultas) representando-as no espaço vetorial e calculando a distância entre os vetores.  Normalmente, uma distância angular é usada para isso. <br><br>  Como resultado, a representação vetorial de palavras permite a correspondência textual de um tipo diferente, que complementa a correspondência baseada em palavras-chave.  Você pode explorar a semelhança semântica dos pedidos (por exemplo, "melhor restaurante de munique" e "onde comer em munique"), como não podíamos fazer antes. <br><br><h1>  Pesquisa por Vizinho Mais Próximo Aproximado </h1><br>  Agora podemos refinar nosso problema de correspondência de consulta original: <br><br><blockquote>  Dado um conjunto fixo de vetores de consulta <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-34"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-35">Q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-12"> Q </script>  vetor de entrada <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-36"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-37">q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-13"> q </script>  e inteiro <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-38"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-39">k</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-14"> k </script>  .  Você precisa encontrar esse subconjunto de vetores <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-40"><span class="noError" id="MJXp-Span-41" style="display: inline-block;">R&nbsp;=&nbsp;\&nbsp;left&nbsp;\&nbsp;{q0,&nbsp;q1,&nbsp;...,&nbsp;qk&nbsp;\&nbsp;right&nbsp;\}&nbsp;\&nbsp;subconjunto&nbsp;Q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-15"> R = \ left \ {q0, q1, ..., qk \ right \} \ subconjunto Q </script>  de modo que a distância angular de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-42"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-43">q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-16"> q </script>  para cada vetor <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-44"><span class="MJXp-msubsup" id="MJXp-Span-45"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-46" style="margin-right: 0.05em;">q</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-47" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-48">i</span></span></span><span class="MJXp-mtext" id="MJXp-Span-49">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-50">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-51">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-52">R</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-17-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-17"> q_ {i} \ em R </script>  foi menor que a distância para qualquer outro vetor <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-53"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-54">Q</span><span class="MJXp-mo" id="MJXp-Span-55" style="margin-left: 0.267em; margin-right: 0.267em;">∖</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-56">R</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-18-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-18"> Q ∖ R </script>  . </blockquote><br>  Isso é chamado de tarefa de encontrar o vizinho mais próximo.  Existem <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25B4%25D0%25B0%25D1%2587%25D0%25B0_%25D0%25BF%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA%25D0%25B0_%25D0%25B1%25D0%25BB%25D0%25B8%25D0%25B6%25D0%25B0%25D0%25B9%25D1%2588%25D0%25B5%25D0%25B3%25D0%25BE_%25D1%2581%25D0%25BE%25D1%2581%25D0%25B5%25D0%25B4%25D0%25B0">vários algoritmos</a> para sua solução rápida em espaços de baixa dimensão.  Porém, ao trabalhar com representações vetoriais de palavras, geralmente operamos com vetores de alta dimensão (100-1000 dimensões).  E aqui os métodos mencionados não funcionam mais. <br><br>  Não existe uma maneira adequada de determinar rapidamente os vizinhos mais próximos em espaços de alta dimensão.  Portanto, simplificamos o problema permitindo o uso de resultados aproximados: em vez de sempre retornar <i>os</i> vetores mais próximos, ficaremos satisfeitos com apenas alguns dos vizinhos mais próximos ou <i>até certo ponto</i> próximos.  Isso é chamado de tarefa de busca aproximada dos vizinhos mais próximos e é uma área de pesquisa ativa. <br><br><h3>  Mundo pequeno hierárquico </h3><br>  O gráfico de mundo pequeno navegável hierárquico ( <a href="https://arxiv.org/abs/1603.09320">HNSW</a> ) é um dos algoritmos mais rápidos para a pesquisa aproximada dos vizinhos mais próximos.  O índice de pesquisa no HNSW é uma estrutura de vários níveis, na qual cada nível é um gráfico de proximidade.  Cada nó do gráfico corresponde a um dos vetores de consulta. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/42e/55e/4b7/42e55e4b72cd088b45e5aff56159f7fb.png"><br>  <sup><i>Figura 2: Gráfico de proximidade multinível.</i></sup> <br>  Encontrar vizinhos mais próximos no HNSW usa o método de aumento de zoom.  Ele inicia no nó de entrada do nível mais alto e executa recursivamente o percurso de gráfico ganancioso em cada nível até atingir um mínimo local na parte inferior. <br><br>  Detalhes sobre o algoritmo e a técnica de pesquisa estão bem descritos no trabalho científico.  É importante lembrar que cada ciclo de pesquisa dos vizinhos mais próximos consiste em percorrer os nós dos gráficos e calcular as distâncias entre os vetores.  Examinaremos essas etapas abaixo para usar esse método para criar um índice em larga escala. <br><br><h1>  A dificuldade de indexar bilhões de consultas </h1><br>  Suponha que precisamos indexar 4 bilhões de vetores de consulta 200-dimensionais, com cada dimensão representada por um número de ponto flutuante de quatro bytes (4 bilhões são suficientes para tornar a tarefa interessante, mas você ainda pode armazenar os IDs dos nós em números regulares de quatro bytes) .  Um cálculo aproximado indica que o tamanho dos vetores será de aproximadamente 3 TB.  Como a maioria das bibliotecas existentes usa uma capacidade de RAM para uma pesquisa aproximada dos vizinhos mais próximos, precisaremos de um servidor muito grande para inserir pelo menos vetores na RAM.  Observe que isso não leva em consideração o índice de pesquisa adicional, necessário para a maioria dos métodos. <br><br>  Em toda a história do desenvolvimento de nosso mecanismo de pesquisa, usamos várias abordagens diferentes para resolver esse problema.  Vamos considerar alguns deles. <br><br><h3>  Subconjunto de dados </h3><br>  A primeira e mais simples abordagem, que não nos permitiu resolver completamente o problema, foi limitar o número de vetores no índice.  Tomando um décimo dos dados, criamos um índice que precisa - surpresa - 10% da memória.  No entanto, a qualidade da pesquisa se deteriorou, porque agora operamos com menos consultas. <br><br><h3>  Quantização </h3><br>  Aqui, usamos todos os dados, mas os reduzimos usando a <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B2%25D0%25B0%25D0%25BD%25D1%2582%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">quantização</a> (usamos diferentes técnicas de quantização, por exemplo, quantização do produto, mas não conseguimos atingir a qualidade desejada de trabalho com essa quantidade de dados).  Ao arredondar alguns erros, conseguimos substituir todos os números de quatro bytes nos vetores originais por versões quantizadas de um byte.  A quantidade de RAM para vetores diminuiu 75%.  No entanto, ainda precisávamos de 750 GB de memória (sem contar o tamanho do próprio índice), e este ainda é um servidor muito grande. <br><br><h1>  Resolvendo problemas de memória com o Granne </h1><br>  As abordagens descritas tiveram suas vantagens, mas exigiram muitos recursos e deram baixa qualidade à pesquisa.  Embora <a href="http://ann-benchmarks.com/">existam bibliotecas</a> que respondem em menos de 1 ms, poderíamos sacrificar a velocidade em troca de requisitos de hardware mais baixos. <br><br>  <a href="https://github.com/granne/granne">Granne</a> (vizinhos mais próximos aproximados baseados em gráficos) é uma biblioteca HNSW desenvolvida e usada pela Cliqz para pesquisar essas consultas.  Possui código-fonte aberto, mas a biblioteca ainda está em desenvolvimento ativo.  Uma versão melhorada será publicada no <a href="https://crates.io/">crates.io</a> em 2020.  Está escrito em Rust com inserções Python, projetado para lidar com bilhões de vetores usando competitividade.  Do ponto de vista dos vetores de consulta, é interessante que o Granne tenha um modo especial que exija muito menos memória em comparação com outras bibliotecas. <br><br><h3>  Representação compacta de vetores de consulta </h3><br>  Reduzir o tamanho dos vetores de consulta nos dará muitos benefícios.  Para fazer isso, vamos voltar e considerar a criação de vetores.  Como as consultas são compostas de palavras e os vetores de consulta são somas de vetores de palavras, podemos recusar explicitamente o armazenamento de vetores de consulta e calculá-los conforme necessário. <br><br>  Você pode armazenar consultas na forma de conjuntos de palavras e usar a tabela de pesquisa para encontrar os vetores correspondentes.  No entanto, evitamos o redirecionamento armazenando cada consulta como uma lista de IDs inteiros correspondentes aos vetores de palavras na consulta.  Por exemplo, salve a consulta "melhor restaurante de munique" como <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-57"><span class="MJXp-mo" id="MJXp-Span-58" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mrow" id="MJXp-Span-59"><span class="MJXp-msubsup" id="MJXp-Span-60"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-61" style="margin-right: 0.05em;">i</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-62" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-63">b</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-64">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-65">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-66">t</span></span></span></span><span class="MJXp-mo" id="MJXp-Span-67" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mrow" id="MJXp-Span-68"><span class="MJXp-msubsup" id="MJXp-Span-69"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-70" style="margin-right: 0.05em;">i</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-71" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-72">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-73">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-74">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-75">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-76">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-77">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-78">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-79">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-80">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-81">t</span></span></span></span><span class="MJXp-mo" id="MJXp-Span-82" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mrow" id="MJXp-Span-83"><span class="MJXp-msubsup" id="MJXp-Span-84"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-85" style="margin-right: 0.05em;">i</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-86" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-87">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-88">f</span></span></span></span><span class="MJXp-mo" id="MJXp-Span-89" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mrow" id="MJXp-Span-90"><span class="MJXp-msubsup" id="MJXp-Span-91"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-92" style="margin-right: 0.05em;">i</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-93" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-94">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-95">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-96">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-97">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-98">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-99">h</span></span></span></span><span class="MJXp-mo" id="MJXp-Span-100" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-19"> [{i_ {best}}, {i_ {restaurant}}, {i_ {of}}, {i_ {munich}}] </script>  onde <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-101"><span class="MJXp-mrow" id="MJXp-Span-102"><span class="MJXp-msubsup" id="MJXp-Span-103"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-104" style="margin-right: 0.05em;">i</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-105" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-106">b</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-107">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-108">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-109">t</span></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-20-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-20"> {i_ {best}} </script>  - esse é o ID do vetor da palavra "melhor" etc. Suponha que tenhamos menos de 16 milhões de vetores de palavras (mais do que esse valor custará 1 byte por palavra), então você pode usar 3 bytes para representar todos os IDs de palavras.  Ou seja, em vez de armazenar 800 bytes (ou 200 bytes no caso de vetores quantizados), armazenaremos apenas 12 bytes para esta solicitação (isso não é totalmente verdade. Como as solicitações consistem em um número diferente de palavras, também precisamos armazenar o deslocamento da lista no índice de palavras. isso exigirá 5 bytes por solicitação). <br><br>  Quanto aos vetores de palavras, todos precisamos deles.  No entanto, o número de palavras é muito menor que o número de consultas que podem ser criadas combinando essas palavras.  E isso significa que o tamanho das palavras não é tão importante.  Se você armazenar vetores de palavras como versões de ponto flutuante de quatro bytes em uma matriz simples <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-110"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-111">v</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-21-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-21"> v </script>  , precisamos de menos de 1 GB para cada milhão de palavras.  Este volume pode caber facilmente na RAM.  Agora, o vetor de consulta fica assim: <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-112"><span class="noError" id="MJXp-Span-113" style="display: inline-block;">{v&nbsp;_&nbsp;{{i_&nbsp;{best}}}}&nbsp;+&nbsp;{v&nbsp;_&nbsp;{{i_&nbsp;{restaurant}}}&nbsp;+&nbsp;{v&nbsp;_&nbsp;{{i_&nbsp;{of}}}&nbsp;+&nbsp;{v&nbsp;_&nbsp;{{i_&nbsp;{munich}}}}</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-22-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-22"> {v _ {{i_ {best}}}} + {v _ {{i_ {restaurant}}} + {v _ {{i_ {of}}} + {v _ {{i_ {munich}}}} </script>  . <br><br>  O tamanho final do envio da consulta depende do número total de palavras na consulta.  Para 4 bilhões de consultas, são cerca de 80 GB (incluindo vetores de palavras).  Em outras palavras, comparado aos vetores de palavras originais, o tamanho diminuiu 97% e comparado aos vetores quantizados - 90%. <br><br>  E mais uma coisa.  Para uma pesquisa, precisamos visitar aproximadamente 200 a 300 nós do gráfico.  Cada nó tem 20 a 30 vizinhos.  Portanto, precisamos calcular a distância do vetor de consulta de entrada aos 4000-9000 vetores no índice.  E mais, precisamos gerar vetores.  Quanto tempo leva para criar vetores de consulta rapidamente? <br><br>  Acontece que, com um processador relativamente novo, esse problema pode ser resolvido em alguns milissegundos.  Uma solicitação que costumava ser executada em 1 ms agora é executada em cerca de 5 ms.  Mas reduzimos a quantidade de memória para vetores em 90%.  Aceitamos com prazer esse compromisso. <br><br><h3>  Exibir na memória de vetores e índice </h3><br>  Acima, resolvemos o problema de reduzir a quantidade de memória para vetores.  Mas depois que resolvemos esse problema, a própria estrutura do índice se tornou um fator limitante.  Agora você precisa reduzir seu tamanho. <br><br>  No Granne, a estrutura do gráfico é armazenada compactamente na forma de uma lista de adjacências com um número variável de vizinhos para cada nó.  Ou seja, a memória dificilmente é desperdiçada em metadados.  O tamanho da estrutura do índice depende muito dos parâmetros de design e das propriedades do gráfico.  No entanto, para ter uma idéia do tamanho do índice, basta dizer que podemos criar um índice para 4 bilhões de vetores com um tamanho total de cerca de 240 GB.  Isso pode ser aceitável para uso na memória em um servidor grande, mas pode ser feito melhor. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e73/daa/0de/e73daa0dea90e3e84afe9aaec7bd6a8e.jpg"><br>  <sup><i>Figura 3: Dois layouts diferentes na RAM e SSD.</i></sup> <br><br>  Uma propriedade importante do Granne é a capacidade de <a href="https://ru.wikipedia.org/wiki/Mmap">exibir os</a> vetores de índice e consulta <a href="https://ru.wikipedia.org/wiki/Mmap">na memória</a> .  Isso nos permite carregar preguiçosamente o índice e compartilhar memória com vários processos.  Os arquivos de índice e consulta são divididos em arquivos de exibição separados na memória e podem ser usados ​​em diferentes layouts na RAM e no SSD.  Se os requisitos para o atraso forem um pouco menores, então, colocando o índice no SSD, solicitações para RAM, mantemos uma velocidade aceitável sem consumo excessivo de memória.  No final do artigo, veremos como esse compromisso se parece. <br><br><h3>  Melhorando a localidade dos dados </h3><br>  Em nossa configuração atual, quando o índice está em um SSD, cada solicitação requer de 200 a 300 leituras do disco.  Você pode tentar aumentar a localidade dos dados organizando os elementos cujos vetores estão tão próximos que seus nós HNSW estão localizados no índice também não muito longe um do outro.  A localidade dos dados melhora o desempenho, porque é mais provável que uma operação de leitura única (geralmente extraída de 4 KB) contenha outros nós necessários para percorrer o gráfico.  E isso, por sua vez, reduz o número de recuperações de dados por uma pesquisa. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1f8/1d2/2f4/1f81d22f418256c704bb12b7514e68a1.jpg"><br>  <sup><i>Figura 4: A localidade dos dados reduz a recuperação de informações.</i></sup> <br><br>  Deve-se notar que os elementos de reordenação não afetam os resultados da pesquisa; é uma maneira de acelerar isso.  Ou seja, o pedido pode ser qualquer, mas nem todas as opções aceleram a pesquisa.  É muito difícil encontrar a ordem ideal.  No entanto, a heurística que usamos com sucesso é classificar as consultas pela palavra mais <i>importante</i> em cada consulta. <br><br><h1>  Conclusão </h1><br>  Usamos o Granne para criar e manter índices de bilhões de dólares com vetores de consulta, a fim de procurar consultas semelhantes com consumo de memória relativamente baixo.  A tabela abaixo mostra os requisitos para diferentes métodos.  Seja cético em relação aos valores absolutos dos atrasos durante a pesquisa, porque eles dependem fortemente do que é considerado uma resposta aceitável.  No entanto, essas informações descrevem o desempenho relativo dos métodos. <br><br><div class="scrollable-table"><table><tbody><tr><th></th><th>  Valor inicial <br></th><th>  Quantização <br></th><th>  Granne (apenas RAM) <br></th><th>  Granne (RAM + SSD) <br></th></tr><tr><td>  <b>A memória</b> <br></td><td>  3000 + 240 GB <br></td><td>  750 + 240 GB <br></td><td>  80 + 240 GB <br></td><td>  80-150 GB * <br></td></tr><tr><td>  <b>SSD</b> <br></td><td>  - </td><td>  - </td><td>  - </td><td>  240 GB <br></td></tr><tr><td>  <b>Atraso</b> <br></td><td>  1 ms <br></td><td>  1 ms <br></td><td>  5 ms <br></td><td>  10-50 ms <br></td></tr></tbody></table></div><br>  <i>* A alocação de um índice de memória maior que a quantidade necessária levou ao cache de alguns nós (frequentemente visitados), o que reduziu o atraso na pesquisa.</i>  <i>Nenhum cache interno foi usado para isso, apenas ferramentas internas do SO (kernel do Linux).</i> <br><br>  Deve-se notar que algumas das otimizações mencionadas no artigo não são aplicáveis ​​para resolver o problema geral de encontrar vizinhos mais próximos com vetores indecomponíveis.  No entanto, eles são aplicáveis ​​em qualquer situação em que os elementos possam ser gerados a partir de menos partes (como é o caso de palavras e consultas).  Caso contrário, você ainda poderá usar o Granne com os vetores de origem, mas será necessário mais memória, como em outras bibliotecas. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt479692/">https://habr.com/ru/post/pt479692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt479682/index.html">Relatório de uso de contêiner Sysdig 2019: novos Kubernetes e detalhes de segurança</a></li>
<li><a href="../pt479684/index.html">Como coletar chaves de baixa frequência para SEO: 4 maneiras não triviais</a></li>
<li><a href="../pt479686/index.html">Principais tendências na terceirização de TI após 2020</a></li>
<li><a href="../pt479688/index.html">Em quais países e cidades os desenvolvedores ganham mais quando consideram impostos e custo de vida?</a></li>
<li><a href="../pt479690/index.html">Zork e Z-Machine: como os desenvolvedores transferiram o jogo dos mainframes para os computadores domésticos de 8 bits</a></li>
<li><a href="../pt479696/index.html">Algumas palavras sobre Alter Table, ou como não fazê-lo</a></li>
<li><a href="../pt479700/index.html">CIMON-2: (des) Doomsday, ou como o IBM Watson subiu acima das nuvens</a></li>
<li><a href="../pt479702/index.html">Torradeira, Meu círculo e Freelansim se tornam parte da Habr</a></li>
<li><a href="../pt479704/index.html">Escalonamento de privilégios no cliente EA Origin Windows (CVE-2019-19247 e CVE-2019-19248)</a></li>
<li><a href="../pt479708/index.html">Postagem não oficial sobre a rebranding da Habr + Competition</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>