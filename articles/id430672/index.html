<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐌 🚟 🥥 Versi teks dari laporan "Aktor vs CSP vs Tugas ..." dengan C ++ CoreHard Musim Gugur 2018 👨 🍙 🤛🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada awal November, Minsk menjadi tuan rumah konferensi C ++ berikutnya C ++ CoreHard Autumn 2018 konferensi. Ini menyampaikan laporan kapten "Aktor v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Versi teks dari laporan "Aktor vs CSP vs Tugas ..." dengan C ++ CoreHard Musim Gugur 2018</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430672/">  Pada awal November, Minsk menjadi tuan rumah konferensi C ++ berikutnya C ++ CoreHard Autumn 2018 konferensi. Ini menyampaikan laporan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kapten "Aktor vs CSP vs Tugas ..."</a> , yang berbicara tentang bagaimana aplikasi tingkat yang lebih tinggi daripada "dapat melihat dalam C ++" bare multithreading ”, model pemrograman yang kompetitif.  Di bawah versi cut dari laporan ini, diubah menjadi sebuah artikel.  Disisir, dipangkas di beberapa tempat, ditambah di beberapa tempat. <br><br>  Saya ingin menggunakan kesempatan ini untuk mengucapkan terima kasih kepada komunitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CoreHard yang</a> telah menyelenggarakan konferensi besar berikutnya di Minsk dan atas kesempatan untuk berbicara.  Dan juga untuk publikasi cepat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan video dari laporan di YouTube</a> . <br><br>  Jadi, mari kita beralih ke topik pembicaraan utama.  Yaitu, pendekatan apa yang dapat kita gunakan untuk menyederhanakan pemrograman multi-threaded di C ++, bagaimana beberapa pendekatan ini akan terlihat dalam kode, fitur apa yang melekat pada pendekatan tertentu, apa yang umum di antara mereka, dll. <br><br>  Catatan: kesalahan dan kesalahan ketik ditemukan dalam presentasi asli laporan, sehingga artikel akan menggunakan slide dari versi yang diperbarui dan diedit, yang dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Google Slides</a> atau di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SlideShare</a> . <br><br><h1>  Multithreading telanjang adalah kejahatan! </h1><br>  Anda harus mulai dengan banality berulang, yang, bagaimanapun, masih relevan: <br><blockquote>  Pemrograman C ++ multithreaded melalui thread telanjang, mutex dan variabel kondisi adalah <b>keringat</b> , <b>rasa sakit</b> dan <b>darah</b> . </blockquote><a name="habracut"></a><br>  Sebuah contoh yang baik baru-baru ini dijelaskan di sini dalam artikel ini di sini di Habré: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Arsitektur server-meta dari penembak online seluler Tacticool</a> ".  Di dalamnya, orang-orang berbicara tentang bagaimana mereka berhasil mengumpulkan, tampaknya, berbagai macam penggaruk terkait dengan pengembangan kode multi-threaded di C dan C ++.  Ada "memory pass" sebagai hasil dari balapan, dan kinerja rendah karena paralelisasi yang gagal. <br><br>  Akibatnya, semuanya berakhir secara alami: <br><blockquote>  Setelah beberapa minggu menghabiskan waktu menemukan dan memperbaiki bug yang paling kritis, kami memutuskan bahwa <u>lebih mudah untuk menulis ulang semuanya dari awal</u> daripada mencoba untuk memperbaiki semua kekurangan dari solusi saat ini. </blockquote><br>  Orang-orang memakan C / C ++ ketika bekerja pada versi pertama dari server mereka dan menulis ulang server dalam bahasa lain. <br><br>  Peragaan yang sangat baik tentang bagaimana, di dunia nyata, di luar komunitas C ++ kami yang nyaman, pengembang menolak untuk menggunakan C ++ bahkan di mana penggunaan C ++ masih sesuai dan dibenarkan. <br><br><h2>  Tapi mengapa? </h2><br>  Tetapi mengapa, jika berulang kali dikatakan bahwa "bare multithreading" di C ++ itu jahat, orang terus menggunakannya dengan ketekunan yang layak untuk aplikasi yang lebih baik?  Apa yang harus disalahkan: <br><br><ul><li>  ketidaktahuan? </li><li>  kemalasan? </li><li>  Sindrom NIH? </li></ul><br>  Bagaimanapun, ada jauh dari satu pendekatan yang diuji oleh waktu dan banyak proyek.  Khususnya: <br><br><ul><li>  aktor </li><li>  mengkomunikasikan proses sekuensial (CSP) </li><li>  tugas (async, janji, masa depan, ...) </li><li>  aliran data </li><li>  pemrograman reaktif </li><li>  ... </li></ul><br>  Diharapkan alasan utama masih ketidaktahuan.  Sepertinya ini tidak diajarkan di universitas.  Jadi profesional muda, yang memasuki profesi, menggunakan sedikit yang sudah mereka ketahui.  Dan jika kemudian penyimpanan pengetahuan kemudian tidak diisi ulang, maka orang-orang terus menggunakan benang telanjang, mutex, dan condition_variables. <br><br>  Hari ini kita akan berbicara tentang tiga pendekatan pertama dari daftar ini.  Dan kita akan berbicara tidak secara abstrak, tetapi pada contoh satu tugas sederhana.  Mari kita coba tunjukkan bagaimana kode yang memecahkan masalah ini akan terlihat seperti menggunakan Aktor, proses dan saluran CSP, serta menggunakan Tugas. <br><br><h1>  Tantangan untuk eksperimen </h1><br>  Diperlukan untuk mengimplementasikan server HTTP yang: <br><br><ul><li>  menerima permintaan (ID gambar, ID pengguna); </li><li>  memberikan gambar dengan "tanda air" yang unik untuk pengguna ini. </li></ul><br>  Misalnya, server semacam itu mungkin diperlukan oleh beberapa layanan berbayar yang mendistribusikan konten dengan berlangganan.  Jika gambar dari layanan ini kemudian "muncul" di suatu tempat, maka dengan "tanda air" di atasnya akan mungkin untuk memahami siapa yang perlu "memblokir oksigen". <br><br>  Tugas ini abstrak, dirumuskan secara khusus untuk laporan ini di bawah pengaruh proyek demo kami Udang (kami sudah membicarakannya: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">No. 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">No. 2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">No. 3</a> ). <br><br>  Server HTTP kami ini akan berfungsi sebagai berikut: <br><table border="1"><tbody><tr><td><img src="https://habrastorage.org/webt/bq/qo/zk/bqqozkulonydk1ccnzog-kzv610.jpeg"></td></tr></tbody></table><br>  Setelah menerima permintaan dari klien, kami beralih ke dua layanan eksternal: <br><br><ul><li>  yang pertama mengembalikan informasi pengguna kepada kami.  Termasuk dari sana kita mendapatkan gambar dengan "tanda air"; </li><li>  yang kedua mengembalikan kita gambar aslinya </li></ul><br>  Kedua layanan ini bekerja secara independen dan kami dapat mengakses keduanya secara bersamaan. <br><br>  Karena pemrosesan permintaan dapat dilakukan secara independen satu sama lain, dan bahkan beberapa tindakan saat memproses permintaan tunggal dapat dilakukan secara paralel, penggunaan daya saing menunjukkan sendiri.  Hal paling sederhana yang terlintas dalam pikiran adalah membuat utas terpisah untuk setiap permintaan yang masuk: <br><table border="1"><tbody><tr><td><img src="https://habrastorage.org/webt/g0/f9/ps/g0f9ps3vmq-osh-hy0i71ut_kfw.jpeg"></td></tr></tbody></table><br>  Tetapi model one-request = one-workflow terlalu mahal dan tidak bisa diukur dengan baik.  Kami tidak membutuhkan ini. <br><br>  Bahkan jika kita mendekati jumlah alur kerja dengan sia-sia, kita masih membutuhkan sejumlah kecil dari mereka: <br><table border="1"><tbody><tr><td><img src="https://habrastorage.org/webt/ve/yl/vv/veylvvoaisqxod1-0nsp4vhh80e.jpeg"></td></tr></tbody></table><br>  Di sini kita membutuhkan aliran terpisah untuk menerima permintaan HTTP masuk, aliran terpisah untuk permintaan HTTP keluar kita sendiri, aliran terpisah untuk mengoordinasikan pemrosesan permintaan HTTP yang diterima.  Serta kumpulan alur kerja untuk melakukan operasi pada gambar (karena manipulasi pada gambar paralel dengan baik, memproses gambar dengan beberapa aliran sekaligus akan mengurangi waktu pemrosesan). <br><br>  Oleh karena itu, tujuan kami adalah menangani sejumlah besar permintaan masuk bersamaan pada sejumlah kecil utas kerja.  Mari kita lihat bagaimana kita mencapai ini melalui berbagai pendekatan. <br><br><h2>  Beberapa penafian penting </h2><br>  Sebelum beralih ke cerita utama dan contoh kode parsing, beberapa catatan perlu dibuat. <br><br>  Pertama, semua contoh berikut ini tidak terikat pada kerangka atau pustaka tertentu.  Kecocokan apa pun dalam nama panggilan API adalah acak dan tidak disengaja. <br><br>  Kedua, tidak ada penanganan kesalahan dalam contoh di bawah ini.  Ini dilakukan dengan sengaja, sehingga slide menjadi padat dan terlihat.  Dan juga agar materi sesuai dengan waktu yang ditentukan untuk laporan. <br><br>  Ketiga, contoh-contoh menggunakan entitas entity_excontext tertentu, yang berisi informasi tentang apa lagi yang ada di dalam program.  Mengisi entitas ini tergantung pada pendekatannya.  Dalam hal aktor, eksekusi_konteks akan memiliki tautan ke aktor lain.  Dalam kasus CSP, dalam eksekusi_context akan ada saluran CSP untuk komunikasi dengan proses CSP lainnya.  Dll <br><br><h1>  Pendekatan # 1: Aktor </h1><br><h2>  Singkatnya Model Aktor </h2><br>  Ketika menggunakan Model Aktor, solusinya akan dibangun dari objek-aktor yang terpisah, masing-masing memiliki negara pribadi dan negara ini tidak dapat diakses oleh siapa pun kecuali aktor itu sendiri. <br><br>  Aktor berinteraksi satu sama lain melalui pesan asinkron.  Setiap aktor memiliki kotak suratnya sendiri (antrian pesan), di mana pesan yang dikirim ke aktor disimpan dan dari mana mereka diambil untuk diproses lebih lanjut. <br><br>  Aktor bekerja pada prinsip yang sangat sederhana: <br><br><ul><li>  seorang aktor adalah entitas dengan perilaku; </li><li>  aktor merespons pesan yang masuk; </li><li>  Setelah menerima pesan, aktor dapat: <br><ul><li>  mengirim sejumlah (final) pesan ke aktor lain; </li><li>  membuat sejumlah (final) sejumlah aktor baru; </li><li>  Tetapkan perilaku baru untuk memproses pesan berikutnya. </li></ul></li></ul><br>  Di dalam aplikasi, aktor dapat diimplementasikan dengan berbagai cara: <br><br><ul><li>  setiap aktor dapat direpresentasikan sebagai aliran OS yang terpisah (ini terjadi, misalnya, di pustaka C :: Just :: Thread Pro Actor Edition); </li><li>  setiap aktor dapat direpresentasikan sebagai coroutine yang penuh; </li><li>  setiap aktor dapat direpresentasikan sebagai objek di mana seseorang memanggil metode panggilan balik. </li></ul><br>  Dalam keputusan kami, kami akan menggunakan aktor dalam bentuk objek dengan callback, dan meninggalkan coroutine untuk pendekatan CSP. <br><br><h2>  Skema keputusan berdasarkan Model Aktor </h2><br>  Berdasarkan aktor, skema umum untuk menyelesaikan masalah kita akan terlihat seperti ini: <br><table border="1"><tbody><tr><td><img src="https://habrastorage.org/webt/di/f7/pn/dif7pngijjde8aizja_skqy58oo.jpeg"></td></tr></tbody></table><br>  Kami akan memiliki aktor yang dibuat pada awal server HTTP dan ada sepanjang waktu saat server HTTP berfungsi.  Ini adalah aktor seperti: HttpSrv, UserChecker, ImageDownloader, ImageMixer. <br><br>  Setelah menerima permintaan HTTP masuk yang baru, kami membuat instance baru dari aktor RequestHandler, yang akan dimusnahkan setelah mengeluarkan respons terhadap permintaan HTTP yang masuk. <br><br><h2>  Kode Aktor RequestHandler </h2><br>  Implementasi aktor request_handler, yang mengoordinasikan pemrosesan permintaan HTTP yang masuk, dapat terlihat seperti ini: <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request_handler</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> some_basic_type { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> execution_context context_; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> request request_; optional&lt;user_info&gt; user_info_; optional&lt;image_loaded&gt; image_; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_user_info</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user_info info)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_image_loaded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image_loaded image)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_mixed_image</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mixed_image image)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_mix_images_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; ... <span class="hljs-comment"><span class="hljs-comment">//     . }; void request_handler::on_start() { send(context_.user_checker(), check_user{request_.user_id(), self()}); send(context_.image_downloader(), download_image{request_.image_id(), self()}); } void request_handler::on_user_info(user_info info) { user_info_ = std::move(info); if(image_) send_mix_images_request(); } void request_handler::on_image_loaded(image_loaded image) { image_ = std::move(image); if(user_info_) send_mix_images_request(); } void request_handler::send_mix_images_request() { send(context_.image_mixer(), mix_images{user_info-&gt;watermark_image(), *image_, self()}); } void request_handler::on_mixed_image(mixed_image image) { send(context_.http_srv(), reply{..., std::move(image), ...}); }</span></span></code> </pre> <br>  Mari kita uraikan kode ini. <br><br>  Kami memiliki kelas dalam atribut yang kami simpan atau akan menyimpan apa yang kami butuhkan untuk memproses permintaan.  Juga di kelas ini ada satu set panggilan balik yang akan dipanggil pada satu waktu atau yang lain. <br><br>  Pertama, ketika aktor baru saja dibuat, panggilan balik on_start () dipanggil.  Di dalamnya, kami mengirim dua pesan ke aktor lain.  Pertama, ini adalah pesan check_user untuk memverifikasi ID klien.  Kedua, ini adalah pesan download_image untuk mengunduh gambar asli. <br><br>  Di setiap pesan yang dikirim, kami meneruskan tautan ke diri kami sendiri (metode panggilan ke diri () mengembalikan tautan ke aktor yang dipanggil sendiri () dipanggil).  Ini diperlukan agar aktor kami dapat mengirim pesan sebagai tanggapan.  Jika kami tidak mengirim tautan ke aktor kami, misalnya, dalam pesan check_user, maka aktor UserChecker tidak akan tahu kepada siapa harus mengirim informasi pengguna. <br><br>  Ketika pesan user_info dengan informasi pengguna dikirimkan kepada kami sebagai respons, panggilan balik on_user_info () dipanggil.  Dan ketika pesan image_loaded dikirim kepada kami, panggilan balik on_image_loaded () dipanggil pada aktor kami.  Dan sekarang di dalam dua panggilan balik ini kita melihat fitur yang melekat dalam Model Aktor: kita tidak tahu persis bagaimana urutan kita akan menerima pesan tanggapan.  Karena itu, kita harus menulis kode kita sehingga tidak tergantung pada urutan pesan masuk.  Oleh karena itu, di setiap prosesor, pertama-tama kita menyimpan informasi yang diterima dalam atribut yang sesuai, dan kemudian memeriksa apakah kita sudah mengumpulkan semua informasi yang kita butuhkan?  Jika demikian, maka kita bisa melanjutkan.  Jika tidak, maka kami akan menunggu lebih jauh. <br><br>  Itulah mengapa kita memiliki if_ on_user_info () dan on_image_loaded () yang dijalankan ketika send_mix_images_request () dipanggil. <br><br><blockquote>  Pada prinsipnya, dalam implementasi Model Aktor dapat terdapat mekanisme seperti selektif terima dari Erlang atau simpanan dari Akka, yang melaluinya Anda dapat memanipulasi urutan pemrosesan pesan yang masuk, tetapi kami tidak akan membicarakan hal ini hari ini, agar tidak menyelidiki rincian detail dari berbagai implementasi Model tersebut. Aktor. </blockquote><br>  Jadi, jika semua informasi yang kita butuhkan dari UserChecker dan ImageDownloader diterima, maka metode send_mix_images_request () dipanggil, di mana pesan mix_images dikirim ke aktor ImageMixer.  Callback on_mixed_image () dipanggil ketika kami menerima pesan respons dengan gambar yang dihasilkan.  Di sini kita mengirim gambar ini ke aktor HttpSrv dan menunggu sampai HttpSrv membentuk respons HTTP dan menghancurkan RequestHandler yang telah menjadi tidak perlu (meskipun, pada prinsipnya, tidak ada yang mencegah aktor RequestHandler merusak diri di panggilan on_mixed_image ()). <br><br>  Itu saja. <br><br>  Implementasi aktor RequestHandler ternyata cukup produktif.  Tapi ini karena fakta bahwa kita perlu menggambarkan kelas dengan atribut dan panggilan balik, dan kemudian juga menerapkan panggilan balik.  Tetapi logika pekerjaan RequestHandler sangat sepele, dan memahaminya, terlepas dari jumlah kode di kelas request_handler, mudah. <br><br><h2>  Fitur yang melekat pada aktor </h2><br>  Sekarang kita dapat mengatakan beberapa kata tentang fitur Model Aktor. <br><br><h3>  Reaktor </h3><br>  Sebagai aturan, aktor hanya merespons pesan yang masuk.  Ada pesan - aktor memprosesnya.  Tidak ada pesan - aktor tidak melakukan apa pun. <br><br>  Ini terutama berlaku untuk implementasi Model Aktor di mana aktor direpresentasikan sebagai objek dengan panggilan balik.  Kerangka kerja menarik callback aktor dan jika aktor tidak mengembalikan kontrol dari callback, kerangka kerja tidak dapat melayani aktor lain dalam konteks yang sama. <br><br><h3>  Aktor kelebihan beban </h3><br>  Pada aktor, kita dapat dengan mudah membuat aktor-produser menghasilkan pesan untuk konsumen-aktor pada kecepatan yang jauh lebih cepat daripada aktor-konsumen yang dapat memproses. <br><br>  Ini akan mengarah pada fakta bahwa antrian pesan yang masuk untuk aktor-konsumen akan terus bertambah.  Pertumbuhan antrian, mis.  peningkatan konsumsi memori dalam aplikasi akan mengurangi kecepatan aplikasi.  Ini akan mengarah pada pertumbuhan antrian yang lebih cepat dan, sebagai akibatnya, aplikasi mungkin menurun sehingga tidak dapat dioperasikan sepenuhnya. <br><br>  Semua ini adalah konsekuensi langsung dari interaksi aktor yang tidak sinkron.  Karena operasi pengiriman umumnya non-pemblokiran.  Dan untuk membuatnya tidak mudah, karena  seorang aktor dapat mengirim ke dirinya sendiri.  Dan jika antrian untuk aktor penuh, maka pada send-to-yourself aktor akan diblokir dan ini akan menghentikan pekerjaannya. <br><br>  Jadi ketika bekerja dengan aktor, perhatian serius harus diberikan pada masalah kelebihan beban. <br><br><h3>  Banyak aktor tidak selalu solusinya. </h3><br>  Sebagai aturan, aktor adalah entitas yang ringan dan ada godaan untuk membuatnya dalam aplikasi mereka dalam jumlah besar.  Anda dapat membuat sepuluh ribu aktor, dan seratus ribu, dan satu juta.  Dan bahkan seratus juta aktor, jika besi memungkinkan Anda. <br><br>  Tetapi masalahnya adalah bahwa perilaku sejumlah besar aktor sulit dilacak.  Yaitu  Anda mungkin memiliki beberapa aktor yang jelas bekerja dengan benar.  Beberapa aktor yang jelas-jelas bekerja salah atau tidak bekerja sama sekali, dan Anda tahu pasti.  Tetapi mungkin ada sejumlah besar aktor tentang siapa Anda tidak tahu apa-apa: apakah mereka bekerja sama sekali, apakah mereka bekerja dengan benar atau salah.  Dan semua karena ketika Anda memiliki seratus juta entitas otonom dengan logika perilaku Anda sendiri dalam program Anda, maka memantau ini sangat sulit untuk semua orang. <br><br>  Oleh karena itu, mungkin ternyata saat membuat sejumlah besar aktor dalam aplikasi, kami tidak memecahkan masalah yang kami terapkan, tetapi mendapatkan masalah lain.  Dan, oleh karena itu, mungkin bermanfaat bagi kita untuk meninggalkan aktor sederhana yang menyelesaikan satu tugas, demi aktor yang lebih kompleks dan berat yang melakukan beberapa tugas.  Tetapi kemudian akan ada lebih sedikit aktor "berat" dalam aplikasi dan akan lebih mudah bagi kita untuk mengikuti mereka. <br><br><h2>  Di mana mencarinya, apa yang harus diambil? </h2><br>  Jika seseorang ingin mencoba bekerja dengan aktor dalam C ++, maka tidak ada gunanya membangun sepeda Anda sendiri, ada beberapa solusi yang sudah jadi, khususnya: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SObjectizer</a> (dukung produsen dalam negeri!) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">C ++ Actor Framework (CAF)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">QP / C ++</a> </li></ul><br>  Tiga opsi ini hidup, berkembang, lintas platform, didokumentasikan.  Anda juga dapat mencobanya secara gratis.  Ditambah beberapa opsi lagi dengan tingkat kesegaran yang berbeda-beda dapat ditemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam daftar di Wikipedia</a> . <br><br>  SObjectizer dan CAF dirancang untuk digunakan dalam tugas-tugas tingkat tinggi di mana pengecualian dan memori dinamis dapat diterapkan.  Dan kerangka kerja QP / C ++ mungkin menarik bagi mereka yang terlibat dalam pengembangan yang disematkan, seperti  di bawah ceruk inilah dia "dipenjara." <br><br><h1>  Pendekatan # 2: CSP (mengkomunikasikan proses berurutan) </h1><br><h2>  CSP di jari dan tanpa matan </h2><br>  Model CSP sangat mirip dengan Model Aktor.  Kami juga membangun solusi kami dari sekumpulan entitas otonom, yang masing-masing memiliki negara pribadi dan berinteraksi dengan entitas lain hanya melalui pesan asinkron. <br><br>  Hanya entitas ini dalam model CSP yang disebut "proses." <br><br>  Proses dalam CSP ringan, tanpa paralelisasi pekerjaan mereka di dalamnya.  Jika kita perlu memparalelkan sesuatu, maka kita cukup memulai beberapa proses CSP, di dalamnya tidak ada paralelisasi lagi. <br><br>  Proses CSP berinteraksi satu sama lain melalui pesan asinkron, tetapi pesan dikirim bukan ke kotak surat, seperti dalam Model Aktor, tetapi ke saluran.  Saluran dapat dianggap sebagai antrian pesan, biasanya berukuran tetap. <br><br>  Tidak seperti Model Aktor, di mana kotak surat secara otomatis dibuat untuk setiap aktor, saluran di CSP harus dibuat secara eksplisit.  Dan jika kita membutuhkan dua proses untuk berinteraksi satu sama lain, maka kita harus membuat saluran sendiri, dan kemudian memberi tahu proses pertama "Anda akan menulis di sini", dan proses kedua harus mengatakan: "Anda akan membaca di sini dari sini." <br><br>  Pada saat yang sama, saluran memiliki setidaknya dua operasi yang harus dipanggil secara eksplisit.  Yang pertama adalah operasi tulis (kirim) untuk menulis pesan ke saluran. <br><br>  Kedua, ini adalah operasi baca (terima) untuk membaca pesan dari saluran.  Dan kebutuhan untuk secara eksplisit memanggil read / accept membedakan CSP dari Actors Model, karena  dalam kasus aktor, operasi baca / terima umumnya dapat disembunyikan dari aktor.  Yaitu  Kerangka kerja aktor dapat mengambil pesan dari antrian aktor dan memanggil penangan (panggilan balik) untuk pesan yang diambil. <br><br>  Sedangkan proses CSP itu sendiri harus memilih saat untuk panggilan baca / terima, maka proses CSP harus menentukan pesan apa yang diterima dan memproses pesan yang diekstraksi. <br><br>  Di dalam aplikasi "besar" kami, proses CSP dapat diimplementasikan dengan berbagai cara: <br><br><ul><li>  Proses CSP-shny dapat diimplementasikan sebagai OS utas terpisah.  Ternyata solusi yang mahal, tetapi dengan multitasking preemptive; </li><li>  Proses CSP dapat diimplementasikan oleh coroutine (stackful coroutine, fiber, green thread, ...).  Ini jauh lebih murah, tetapi multitasking hanya kooperatif. </li></ul><br>  Lebih lanjut, kami mengasumsikan bahwa proses CSP disajikan dalam bentuk stackout coroutine (meskipun kode yang ditunjukkan di bawah ini mungkin dapat diimplementasikan pada utas OS). <br><br><h2>  Diagram Solusi Berbasis CSP </h2><br>  Skema solusi berdasarkan model CSP akan sangat mirip dengan skema serupa untuk Model Aktor (dan ini bukan kecelakaan): <br><table border="1"><tbody><tr><td><img src="https://habrastorage.org/webt/96/oy/uu/96oyuu6mwhj4ot6fqpsiiv-f1h8.jpeg"></td></tr></tbody></table><br>  Akan ada entitas yang mulai pada awal server HTTP dan berfungsi sepanjang waktu - ini adalah proses CSP HttpSrv, UserChecker, ImageDownloader dan ImageMixer.  Untuk setiap permintaan masuk baru, proses CSP RequestHandler baru akan dibuat.  Proses ini mengirim dan menerima pesan yang sama seperti ketika menggunakan Model Aktor. <br><br><h2>  Kode Proses CSP RequestHandler </h2><br>  Ini mungkin terlihat seperti kode fungsi yang mengimplementasikan proses CSP RequestHandler: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> execution_context ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request req)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user_info_ch = make_chain&lt;user_info&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> image_loaded_ch = make_chain&lt;image_loaded&gt;(); ctx.user_checker_ch().write(check_user{req.user_id(), user_info_ch}); ctx.image_downloader_ch().write(download_image{req.image_id(), image_loaded_ch}); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user = user_info_ch.read(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> original_image = image_loaded_ch.read(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> image_mix_ch = make_chain&lt;mixed_image&gt;(); ctx.image_mixer_ch().write( mix_image{user.watermark_image(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(original_image), image_mix_ch}); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result_image = image_mix_ch.read(); ctx.http_srv_ch().write(reply{..., <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(result_image), ...}); }</code> </pre> <br>  Di sini semuanya sangat sepele dan secara teratur mengulangi pola yang sama: <br><br><ul><li>  Pertama, kami membuat saluran untuk menerima pesan tanggapan.  Ini perlu karena  proses CSP tidak memiliki kotak surat default sendiri, seperti aktor.  Karena itu, jika proses CSP-shny ingin menerima sesuatu, maka itu harus dibuat bingung oleh pembuatan saluran tempat "sesuatu" ini akan ditulis; </li><li>  kemudian kami mengirim pesan kami ke proses master CSP.  Dan dalam pesan ini kami menunjukkan saluran untuk pesan respons; </li><li>  kemudian kami melakukan operasi baca dari saluran di mana kami akan dikirimi pesan tanggapan. </li></ul><br>  Ini sangat jelas terlihat dalam contoh komunikasi dengan proses CSP ImageSPixer: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> image_mix_ch = make_chain&lt;mixed_image&gt;(); <span class="hljs-comment"><span class="hljs-comment">//  . ctx.image_mixer_ch().write( //  . mix_image{..., image_mix_ch}); //     . auto result_image = image_mix_ch.read(); //  .</span></span></code> </pre> <br>  Namun secara terpisah ada baiknya fokus pada fragmen ini: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user = user_info_ch.read(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> original_image = image_loaded_ch.read();</code> </pre> <br>  Di sini kita melihat perbedaan serius lain dari Model Aktor.  Dalam hal CSP, kami dapat menerima pesan respons sesuai urutan yang kami inginkan. <br><br>  Ingin menunggu user_info dulu?  Tidak masalah, tidurlah pada baca sampai user_info muncul.  Jika image_loaded sudah dikirim kepada kami saat ini, maka ia hanya akan menunggu di salurannya sampai kita membacanya. <br><br>  Itu, pada kenyataannya, adalah semua yang dapat menyertai kode yang ditunjukkan di atas.  Kode berbasis CSP lebih kompak daripada rekannya yang berbasis aktor.  Yang tidak mengherankan sejak itu  di sini kita tidak perlu menggambarkan kelas yang terpisah dengan metode panggilan balik.  Dan bagian dari proses CSP-pemalu kami RequestHandler hadir secara implisit dalam bentuk argumen ctx dan req. <br><br><h2>  Fitur CSP </h2><br><h3>  Reaktivitas dan proaktif proses CSP </h3><br>  Tidak seperti aktor, proses CSP dapat menjadi reaktif, proaktif, atau keduanya.  Katakanlah proses CSP memeriksa pesan yang masuk, jika ada, itu memprosesnya.  Dan kemudian, melihat bahwa tidak ada pesan masuk, dia berjanji untuk melipatgandakan matriks. <br><br>  Setelah beberapa waktu, proses CSP dari matriks sudah bosan mengalikan, dan dia sekali lagi memeriksa pesan yang masuk.  Tidak ada yang baru?  Baiklah, mari kita gandakan matriks lebih jauh. <br><br>  Dan kemampuan proses CSP ini untuk melakukan beberapa pekerjaan bahkan tanpa adanya pesan masuk membuat model CSP sangat berbeda dari Model Aktor. <br><br><h3>  Mekanisme perlindungan overload asli </h3><br>  Karena, sebagai aturan, saluran adalah antrian pesan dengan ukuran terbatas dan upaya untuk menulis pesan ke saluran yang diisi menghentikan pengirim, maka di CSP kami memiliki mekanisme perlindungan bawaan terhadap kelebihan beban. <br><br>  Memang, jika kita memiliki proses produsen gesit dan proses konsumen lambat, maka proses produser akan dengan cepat mengisi saluran dan itu akan ditangguhkan untuk operasi pengiriman berikutnya.  Dan proses produser akan tidur sampai proses konsumen membebaskan ruang di saluran untuk pesan baru.  Segera setelah tempat itu muncul, proses produksi bangun dan melemparkan pesan baru ke saluran. <br><br>  Jadi, ketika menggunakan CSP, kita bisa lebih sedikit khawatir tentang masalah kelebihan daripada dalam kasus Model Aktor.  Benar, ada jebakan di sini, yang akan kita bicarakan nanti. <br><br><h3>  Bagaimana proses CSP diimplementasikan </h3><br>  Kita harus memutuskan bagaimana proses CSP kita akan diimplementasikan. <br><br>  Hal ini dapat dilakukan agar setiap proses CSP-shny akan diwakili oleh utas OS yang terpisah.  Ternyata solusi yang mahal dan tidak scalable.  Tetapi di sisi lain, kita mendapatkan multitasking preemptive: jika proses CSP kami mulai mengalikan matriks atau membuat semacam panggilan pemblokiran, maka OS pada akhirnya akan mendorongnya keluar dari inti komputasi dan memberikan proses CSP lain kesempatan untuk bekerja. <br><br>  Dimungkinkan untuk membuat setiap proses CSP diwakili oleh coroutine (stackful coroutine).  Ini adalah solusi yang jauh lebih murah dan terukur.  Tapi di sini kita hanya akan memiliki multitasking kooperatif.  Oleh karena itu, jika tiba-tiba proses CSP mengambil perkalian matriks, untaian kerja dengan proses CSP ini dan proses CSP lain yang dilampirkan akan diblokir. <br><br>  Mungkin ada trik lain.  Misalkan kita menggunakan perpustakaan pihak ketiga, di dalamnya kita tidak bisa memengaruhi.  Dan di dalam perpustakaan, variabel TLS digunakan (mis. Thread-local-storage).  Kami melakukan satu panggilan ke fungsi perpustakaan dan perpustakaan menetapkan nilai beberapa variabel TLS.  Kemudian coroutine kami "bergerak" ke utas yang lain, dan ini dimungkinkan, karena  pada prinsipnya, coroutine dapat berpindah dari satu utas kerja ke utas lainnya.  Kami membuat panggilan berikut ke fungsi perpustakaan dan perpustakaan mencoba membaca nilai variabel TLS.  Tetapi mungkin sudah ada makna yang berbeda!  Dan mencari bug seperti itu akan sangat sulit. <br><br>  Karena itu, Anda perlu mempertimbangkan pilihan metode untuk mengimplementasikan proses CSP-shnyh dengan hati-hati.  Masing-masing opsi memiliki kekuatan dan kelemahannya sendiri. <br><br><h3>  Banyak proses tidak selalu merupakan solusi. </h3><br>  Seperti para aktor, kemampuan untuk menciptakan banyak proses CSP dalam program Anda tidak selalu merupakan solusi untuk masalah yang diterapkan, tetapi menciptakan masalah tambahan untuk diri Anda sendiri. <br><br>  Selain itu, visibilitas yang buruk dari apa yang terjadi di dalam program hanya merupakan satu bagian dari masalah.  Saya ingin fokus pada perangkap lain. <br><br>  Faktanya adalah bahwa pada saluran CSP-shnyh Anda dapat dengan mudah mendapatkan analog dari kebuntuan.  Proses A mencoba menulis pesan ke saluran lengkap C1 dan proses A dijeda.  Dari saluran C1, proses B, yang mencoba menulis ke saluran C2, yang penuh, harus dibaca, dan karena itu, proses B ditangguhkan.  Dan dari saluran C2, proses A adalah untuk membaca. Itu saja, kita menemui jalan buntu. <br><br>  Jika kita hanya memiliki dua proses CSP, maka kita dapat menemukan kebuntuan selama debugging atau bahkan dengan prosedur peninjauan kode.  Tetapi jika kita memiliki jutaan proses dalam program, mereka secara aktif berkomunikasi satu sama lain, maka kemungkinan kebuntuan tersebut meningkat secara signifikan. <br><br><h2>  Di mana mencarinya, apa yang harus diambil? </h2><br>  Jika seseorang ingin bekerja dengan CSP di C ++, maka pilihan di sini, sayangnya, tidak sebesar untuk aktor.  Ya, atau saya tidak tahu ke mana harus mencari dan bagaimana mencarinya.  Dalam hal ini, saya harap komentar akan membagikan tautan lain. <br><br>  Tetapi, jika kita ingin menggunakan CSP, pertama-tama kita harus melihat ke arah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Boost.Fiber</a> .  Ada serat (mis. Coroutine), dan saluran, dan bahkan primitif tingkat rendah seperti mutex, condition_variable, barrier.  Semua ini bisa diambil dan digunakan. <br><br>  Jika Anda puas dengan proses CSP dalam bentuk utas, maka Anda dapat melihat pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SObjectizer</a> .  Ada juga analog saluran CSP dan aplikasi multi-utas kompleks pada SObjectizer dapat ditulis tanpa aktor sama sekali. <br><br><h1>  Aktor vs CSP </h1><br>  Aktor dan CSP sangat mirip satu sama lain.  Berulang kali saya menemukan pernyataan bahwa kedua model ini setara satu sama lain.  Yaitu  apa yang dapat dilakukan pada aktor dapat hampir 1-in-1 diulangi pada proses CSP dan sebaliknya.  Mereka mengatakan bahwa itu bahkan terbukti secara matematis.  Tapi di sini saya tidak mengerti apa-apa, jadi saya tidak bisa mengatakan apa-apa.  Tetapi dari pikiran saya sendiri di suatu tempat pada tingkat akal sehat sehari-hari, semua ini terlihat cukup masuk akal.  Dalam beberapa kasus, memang, aktor dapat digantikan oleh proses CSP, dan proses CSP oleh aktor. <br><br>  Namun, ada beberapa perbedaan antara aktor dan CSP yang dapat membantu menentukan di mana masing-masing model ini bermanfaat atau tidak menguntungkan. <br><br><h2>  Saluran vs kotak surat </h2><br>  Seorang aktor memiliki "saluran" tunggal untuk menerima pesan masuk - ini adalah kotak suratnya, yang secara otomatis dibuat untuk setiap aktor.  Dan aktor mengambil pesan dari sana secara berurutan, persis dalam urutan pesan di kotak surat. <br><br>  Dan ini adalah pertanyaan yang cukup serius.  Katakanlah ada tiga pesan di kotak surat aktor: M1, M2 dan M3.  Aktor saat ini hanya tertarik pada M3.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi sebelum sampai ke M3, aktor pertama-tama akan mengekstrak M1, kemudian M2. </font><font style="vertical-align: inherit;">Dan apa yang akan dia lakukan dengan mereka?</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekali lagi, sebagai bagian dari percakapan ini, kami tidak akan menyentuh mekanisme penerimaan selektif dari Erlang dan menyembunyikan dari Akka. </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sedangkan proses CSP-shny memiliki kemampuan untuk memilih saluran dari mana saat ini ia ingin membaca pesan. </font><font style="vertical-align: inherit;">Jadi, proses CSP dapat memiliki tiga saluran: C1, C2, dan C3. </font><font style="vertical-align: inherit;">Saat ini, proses CSP hanya tertarik pada pesan dari C3. </font><font style="vertical-align: inherit;">Saluran inilah yang dibaca proses. </font><font style="vertical-align: inherit;">Dan dia akan kembali ke isi saluran C1 dan C2 ketika dia tertarik dengan ini.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reaktivitas dan Proaktif </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai aturan, aktor reaktif dan hanya berfungsi ketika mereka memiliki pesan masuk. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sedangkan proses CSP dapat melakukan beberapa pekerjaan bahkan tanpa adanya pesan yang masuk. </font><font style="vertical-align: inherit;">Dalam beberapa skenario, perbedaan ini dapat memainkan peran penting.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mesin negara </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faktanya, aktor adalah mesin negara hingga (KA). </font><font style="vertical-align: inherit;">Oleh karena itu, jika ada banyak mesin negara terbatas di area subjek Anda, dan bahkan jika mereka mesin mesin negara terbatas hirarkis, maka bisa lebih mudah bagi Anda untuk mengimplementasikannya berdasarkan model aktor daripada dengan menambahkan implementasi pesawat ruang angkasa ke proses CSP.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Di C ++, belum ada dukungan CSP asli. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengalaman bahasa Go menunjukkan betapa mudah dan nyamannya menggunakan model CSP ketika dukungannya diimplementasikan pada tingkat bahasa pemrograman dan pustaka standarnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di Go, mudah untuk membuat "proses CSP" (alias goroutine), mudah untuk membuat dan bekerja dengan saluran, ada sintaks bawaan untuk bekerja dengan beberapa saluran sekaligus (Pilih, yang berfungsi tidak hanya untuk membaca tetapi juga untuk menulis), perpustakaan standar tahu tentang goroutin dan dapat mengubahnya ketika goroutin membuat panggilan pemblokiran dari stdlib. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di C ++, sejauh ini tidak ada dukungan untuk coroutine stackful (di tingkat bahasa). </font><font style="vertical-align: inherit;">Oleh karena itu, bekerja dengan CSP di C ++ mungkin terlihat, di beberapa tempat, jika bukan penopang, maka ... Itu tentu saja membutuhkan lebih banyak perhatian pada dirinya sendiri daripada dalam kasus Go yang sama.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pendekatan No. 3: Tugas (async, masa depan, wait_all, ...) </font></font></h1><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tentang pendekatan berbasis tugas dengan kata-kata yang paling umum </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arti dari pendekatan berbasis tugas adalah bahwa jika kita memiliki operasi yang kompleks, maka kita membagi operasi ini menjadi langkah-langkah tugas yang terpisah, di mana setiap tugas (itu adalah tugas) melakukan satu sub-operasi tunggal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami memulai tugas ini dengan operasi khusus async. </font><font style="vertical-align: inherit;">Operasi async mengembalikan objek masa depan di mana, setelah tugas selesai, nilai yang dikembalikan oleh tugas akan ditempatkan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah kami meluncurkan tugas N dan menerima objek N-masa depan, kita perlu merajut semua ini dalam sebuah rantai. </font><font style="vertical-align: inherit;">Tampaknya ketika tugas No. 1 dan No. 2 selesai, nilai yang dikembalikan oleh mereka harus jatuh ke dalam tugas No. 3. </font><font style="vertical-align: inherit;">Dan ketika tugas No. 3 selesai, nilai yang dikembalikan harus ditransfer ke tugas No. 4, No. 5, dan No. 6. </font><font style="vertical-align: inherit;">Dll, dll.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk "dasi", cara khusus digunakan. </font><font style="vertical-align: inherit;">Seperti, misalnya, metode .then () dari objek masa depan, serta fungsi wait_all (), wait_any (). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penjelasan seperti itu "di jari" mungkin tidak begitu jelas, jadi mari kita beralih ke kode. </font><font style="vertical-align: inherit;">Mungkin dalam percakapan tentang kode tertentu situasinya akan menjadi lebih jelas (tetapi bukan fakta).</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kode Request_handler untuk pendekatan berbasis tugas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kode untuk memproses permintaan HTTP masuk berdasarkan tugas dapat terlihat seperti ini: </font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> execution_context &amp; ctx, request req)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user_info_ft = async(ctx.http_client_ctx(), [req] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retrieve_user_info(req.user_id()); }); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> original_image_ft = async(ctx.http_client_ctx(), [req] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> download_image(req.image_id()); }); when_all(user_info_ft, original_image_ft).then( [&amp;ctx, req](tuple&lt;future&lt;user_info&gt;, future&lt;image_loaded&gt;&gt; data) { async(ctx.image_mixer_ctx(), [&amp;ctx, req, d=<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(data)] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mix_image(get&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(d).get().watermark_image(), get&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(d).get()); }) .then([req](future&lt;mixed_image&gt; mixed) { async(ctx.http_srv_ctx(), [req, im=<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(mixed)] { make_reply(...); }); }); }); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita coba mencari tahu apa yang terjadi di sini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama, kami membuat tugas yang harus diluncurkan dalam konteks klien HTTP kami sendiri dan yang meminta informasi tentang pengguna. Objek masa depan yang dikembalikan disimpan dalam variabel user_info_ft. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selanjutnya, kami membuat tugas serupa, yang juga harus dijalankan dalam konteks klien HTTP kami sendiri dan yang memuat gambar asli. Objek masa depan yang dikembalikan disimpan dalam variabel original_image_ft.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selanjutnya, kita harus menunggu dua tugas pertama selesai. </font><font style="vertical-align: inherit;">Apa yang kami tulis secara langsung: when_all (user_info_ft, original_image_ft). </font><font style="vertical-align: inherit;">Ketika kedua objek di masa depan mendapatkan nilainya, maka kita akan menjalankan tugas lain. </font><font style="vertical-align: inherit;">Tugas ini akan mengambil bitmap dengan tanda air dan gambar asli dan menjalankan tugas lain dalam konteks ImageMixer. </font><font style="vertical-align: inherit;">Tugas ini akan mencampur gambar dan ketika selesai, tugas lain akan diluncurkan pada konteks server HTTP, yang akan menghasilkan respons HTTP. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mungkin penjelasan seperti itu tentang apa yang terjadi dalam kode tidak banyak diklarifikasi. </font><font style="vertical-align: inherit;">Karena itu, mari beri nomor tugas kita:</font></font><br><table><tbody><tr><td><img src="https://habrastorage.org/webt/5k/c0/mr/5kc0mrvqnxdf6lp4-p0wgn1nj7w.jpeg"></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dan mari kita lihat dependensi di antara mereka (dari mana urutan tugas mengalir): </font></font><br><table><tbody><tr><td><img src="https://habrastorage.org/webt/zu/j4/g4/zuj4g4wwg0wxmhazj5k5rdb8pgu.jpeg"></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dan jika sekarang kita overlay gambar ini pada kode sumber kita, maka saya harap itu menjadi lebih jelas: </font></font><br><table><tbody><tr><td><img src="https://habrastorage.org/webt/sw/at/uz/swatuzio1z33-ei16gquj-ss5mg.jpeg"></td></tr></tbody></table><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fitur dari pendekatan berbasis tugas </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visibilitas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fitur pertama yang seharusnya sudah jelas adalah visibilitas kode pada Tugas. </font><font style="vertical-align: inherit;">Tidak semua baik-baik saja dengannya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sini Anda dapat menyebutkan hal seperti neraka panggilan balik. </font><font style="vertical-align: inherit;">Pemrogram Node.js sangat akrab dengannya. </font><font style="vertical-align: inherit;">Tapi nama julukan C ++ yang bekerja erat dengan Task juga masuk ke neraka panggilan balik ini.</font></font><br><br><h3>  Menangani kesalahan </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fitur menarik lainnya adalah penanganan kesalahan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di satu sisi, dalam hal menggunakan async dan masa depan dengan penyampaian informasi kesalahan kepada pihak yang berkepentingan, hal itu bahkan bisa lebih mudah daripada dalam kasus aktor atau CSP. </font><font style="vertical-align: inherit;">Lagi pula, jika dalam proses CSP A mengirimkan permintaan untuk memproses B dan menunggu pesan respons, maka ketika B menemukan kesalahan saat menjalankan permintaan, kita perlu memutuskan bagaimana mengirimkan kesalahan ke proses A:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau kami akan membuat jenis pesan yang terpisah dan saluran untuk menerimanya; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau kami mengembalikan hasilnya dengan satu pesan, yang akan menjadi std :: varian untuk hasil yang normal dan salah. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan dalam hal masa depan, semuanya lebih sederhana: kita mengekstraksi dari masa depan baik hasil normal, atau pengecualian dilemparkan kepada kita. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi, di sisi lain, kita dapat dengan mudah mengalami serangkaian kesalahan. </font><font style="vertical-align: inherit;">Misalnya, pengecualian terjadi pada tugas No. 1, pengecualian ini jatuh ke objek masa depan, yang diteruskan ke tugas No. 2. </font><font style="vertical-align: inherit;">Dalam tugas No. 2, kami mencoba mengambil nilai dari masa depan, tetapi menerima pengecualian. </font><font style="vertical-align: inherit;">Dan, kemungkinan besar, kami akan membuang pengecualian yang sama. </font><font style="vertical-align: inherit;">Dengan demikian, itu akan jatuh ke masa depan berikutnya, yang akan pergi ke tugas No. 3. </font><font style="vertical-align: inherit;">Juga akan ada pengecualian, yang, sangat mungkin, juga akan dirilis.</font></font> Dll <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jika pengecualian kita dicatat, maka dalam log kita bisa melihat pengulangan berulang dari pengecualian yang sama, yang beralih dari satu tugas dalam rantai ke tugas lain. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Batalkan Tugas dan Pengatur Waktu / Waktu Habis </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan fitur lain yang sangat menarik dari kampanye berbasis Tugas adalah pembatalan tugas jika terjadi kesalahan. </font><font style="vertical-align: inherit;">Bahkan, katakanlah kita membuat 150 tugas, menyelesaikan 10 tugas pertama, dan menyadari bahwa tidak ada gunanya melanjutkan pekerjaan. </font><font style="vertical-align: inherit;">Bagaimana kita membatalkan 140 yang tersisa? </font><font style="vertical-align: inherit;">Ini adalah pertanyaan yang sangat, sangat bagus :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertanyaan serupa lainnya adalah bagaimana cara membuat teman-teman tugas dengan timer dan timeout. </font><font style="vertical-align: inherit;">Misalkan kita mengakses beberapa sistem eksternal dan ingin membatasi waktu tunggu hingga 50 milidetik. </font><font style="vertical-align: inherit;">Bagaimana kita mengatur timer, bagaimana bereaksi terhadap berakhirnya batas waktu, bagaimana mengganggu rantai tugas jika batas waktu telah berakhir? </font><font style="vertical-align: inherit;">Sekali lagi, bertanya lebih mudah daripada menjawab :)</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Curang </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nah, dan berbicara tentang fitur pendekatan berbasis tugas. </font><font style="vertical-align: inherit;">Dalam contoh yang ditunjukkan, sedikit kecurangan diterapkan:</font></font><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user_info_ft = async(ctx.http_client_ctx(), [req] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retrieve_user_info(req.user_id()); }); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> original_image_ft = async(ctx.http_client_ctx(), [req] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> download_image(req.image_id()); });</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sini saya mengirim dua tugas ke konteks server HTTP kami sendiri, yang masing-masing melakukan operasi pemblokiran di dalamnya. </font><font style="vertical-align: inherit;">Bahkan, untuk dapat memproses dua permintaan ke layanan pihak ketiga secara paralel, di sini Anda harus membuat rantai tugas asinkron Anda sendiri. </font><font style="vertical-align: inherit;">Tetapi saya tidak melakukan ini untuk membuat solusi lebih atau kurang terlihat dan sesuai pada slide presentasi.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aktor / CSP vs Tugas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami memeriksa tiga pendekatan dan melihat bahwa jika para aktor dan proses CSP mirip satu sama lain, maka pendekatan berbasis tugas tidak seperti salah satu dari mereka. Dan mungkin terlihat bahwa Aktor / CSP harus dikontraskan dengan Tugas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tapi secara pribadi, saya suka sudut pandang yang berbeda. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika kita berbicara tentang Model Aktor dan CSP, maka kita berbicara tentang dekomposisi tugas kita. Dalam tugas kami, kami memilih entitas independen yang terpisah dan menggambarkan antarmuka entitas ini: pesan mana yang mereka kirim, yang mana yang mereka terima, melalui saluran mana pesan itu pergi.</font></font><br><br>  Yaitu<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bekerja dengan aktor dan CSP kita berbicara tentang antarmuka. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi misalkan kita membagi tugas menjadi aktor dan proses CSP yang terpisah. Bagaimana tepatnya mereka melakukan pekerjaan mereka? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika kami mengambil pendekatan berbasis tugas, kami mulai berbicara tentang implementasi. Tentang bagaimana pekerjaan tertentu dilakukan, sub-operasi apa yang dilakukan, dalam urutan apa, bagaimana sub-operasi ini terhubung menurut data, dll.</font></font><br><br>  Yaitu<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bekerja dengan Tugas, kita berbicara tentang implementasi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oleh karena itu, Aktor / CSP dan Tugas tidak begitu saling bertentangan, tetapi saling melengkapi. </font><font style="vertical-align: inherit;">Aktor / CSP dapat digunakan untuk menguraikan tugas dan mendefinisikan antarmuka antar komponen. </font><font style="vertical-align: inherit;">Dan Tugas kemudian dapat digunakan untuk mengimplementasikan komponen tertentu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misalnya, saat menggunakan Aktor, kami memiliki entitas seperti ImageMixer, yang perlu dimanipulasi dengan gambar di kumpulan utas. </font><font style="vertical-align: inherit;">Secara umum, tidak ada yang mencegah kita menggunakan aktor ImageMixer untuk menggunakan pendekatan berbasis tugas.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Di mana mencarinya, apa yang harus diambil? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda ingin bekerja dengan Tugas di C ++, Anda bisa melihat ke perpustakaan standar C ++ 20 mendatang. Mereka telah menambahkan metode .then () ke masa depan, serta fungsi bebas wait_all () dan wait_any. Lihat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">preferensi cp untuk referensi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sudah ada juga jauh dari </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perpustakaan async ++</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> baru </font><font style="vertical-align: inherit;">. Di mana, pada prinsipnya, ada semua yang Anda butuhkan, hanya sedikit dengan saus yang berbeda. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan ada perpustakaan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Microsoft PPL yang</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bahkan lebih tua </font><font style="vertical-align: inherit;">. Yang juga memberikan semua yang Anda butuhkan, tetapi dengan saus Anda sendiri.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pisahkan tambahan tentang perpustakaan Intel TBB. </font><font style="vertical-align: inherit;">Tidak disebutkan dalam cerita tentang pendekatan berbasis tugas karena, menurut pendapat saya, grafik tugas dari TBB sudah menjadi pendekatan aliran data. </font><font style="vertical-align: inherit;">Dan, jika laporan ini berlanjut, pembicaraan tentang Intel TBB pasti akan datang, tetapi dalam konteks kisah tentang aliran data.</font></font></blockquote><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lebih menarik </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baru-baru ini di sini, di Habré, ada sebuah artikel oleh Anton Polukhin: "Kami sedang </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mempersiapkan C ++ 20. Coroutines TS menggunakan contoh nyata</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ." </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini berbicara tentang menggabungkan pendekatan berbasis tugas dengan coroutine stackless dari C ++ 20. </font><font style="vertical-align: inherit;">Dan ternyata kode berdasarkan pembacaan Tugas mendekati pembacaan kode pada proses CSP. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, jika seseorang tertarik pada pendekatan berbasis tugas, maka masuk akal untuk membaca artikel ini.</font></font><br><br><h1>  Kesimpulan </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nah, ini saatnya untuk beralih ke hasil, karena jumlahnya tidak begitu banyak. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hal utama yang ingin saya katakan adalah bahwa di dunia modern Anda mungkin perlu melakukan multithreading hanya jika Anda sedang mengembangkan semacam kerangka kerja atau menyelesaikan beberapa tugas tingkat rendah dan spesifik. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan jika Anda menulis kode aplikasi, maka Anda hampir tidak memerlukan utas kosong, primitif sinkronisasi tingkat rendah atau semacam algoritma bebas kunci bersama dengan wadah bebas kunci. </font><font style="vertical-align: inherit;">Untuk waktu yang lama ada pendekatan yang teruji oleh waktu dan telah membuktikan diri dengan baik:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aktor </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mengkomunikasikan proses sekuensial (CSP) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tugas (async, janji, masa depan, ...) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aliran data </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pemrograman reaktif </font></font></li><li>  ... </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan yang paling penting, ada alat yang siap pakai untuk mereka di C ++. </font><font style="vertical-align: inherit;">Anda tidak perlu siklus apa pun, Anda dapat mengambil, mencoba dan, jika Anda suka, operasikan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sangat sederhana: ambil, coba dan operasikan.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430672/">https://habr.com/ru/post/id430672/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430662/index.html">Memantau server Windows pada MS SQL murni, dan bagaimana saya diam-diam mengimplementasikannya</a></li>
<li><a href="../id430664/index.html">Peran pemimpin tim dalam merekrut</a></li>
<li><a href="../id430666/index.html">Cara mengevaluasi kinerja tim</a></li>
<li><a href="../id430668/index.html">Sendiri di lapangan bukan seorang pejuang. Jalan menuju kerja tim yang efektif</a></li>
<li><a href="../id430670/index.html">Manajemen pengaturan</a></li>
<li><a href="../id430674/index.html">Logika membangun jadwal kerja universal</a></li>
<li><a href="../id430676/index.html">Barang antik: shshshsh, sssssss, VOIP, BBS dan teman-teman modem lainnya</a></li>
<li><a href="../id430678/index.html">Uji sepuluh dimmer dengan lampu LED</a></li>
<li><a href="../id430680/index.html">Menulis prosesor dan lingkungan yang sederhana untuknya</a></li>
<li><a href="../id430682/index.html">Tiga tahun proyek mikrosatelit bulan: tahap-tahap pertumbuhan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>