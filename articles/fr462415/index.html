<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôâÔ∏è üì≤ üéΩ D√©ployer des applications Symfony + React sur AWS via CI üë®‚Äçüîß üîê üßù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, dans cet article, je vais vous montrer comment d√©ployer l'application Symfony 4 sur AWS. Il existe un exemple d'un tel processus dans la docu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>D√©ployer des applications Symfony + React sur AWS via CI</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462415/"> Bonjour, dans cet article, je vais vous montrer comment d√©ployer l'application Symfony 4 sur AWS.  Il existe un exemple d'un tel processus dans la documentation officielle, mais ma version n'est pas aussi triviale que le t√©l√©chargement d'une archive zip avec une application.  Dans la cour de 2019, en mode docker, l'architecture de microservice et les pratiques CI / CD commencent enfin √† √™tre incluses dans les outils non seulement des ing√©nieurs DevOps, mais aussi des d√©veloppeurs <s>mortels</s> ordinaires.  Pour rendre l'article plus int√©ressant, j'ai ajout√© une fa√ßade √† React.JS, pour couvrir les besoins de plus de personnes, si votre application n'utilise pas Encore - cela n'a pas d'importance, je vous indiquerai comment changer le fichier Docker pour vous, la prise en charge de React.JS ne l'affecte que .  Qui sera int√©ress√© par ce tutoriel?  Tout d'abord, il s'adresse aux d√©veloppeurs PHP qui souhaitent changer leur pratique de d√©ploiement - s'√©loigner des canons habituels et utiliser docker pour emballer leur application et disposer l'image.  Mais vous pouvez aller un peu plus loin, et la suite de la narration visera √† d√©ployer automatiquement l'application depuis Git via la plateforme CI / CD (CircleCI sera utilis√©, mais si vous √™tes int√©ress√© par la configuration de Gitlab, √©crivez dans les commentaires, je la joindrai).  En fait, il n'est absolument pas important pour React / PHP que vous ayez une application ou, par exemple, .NET Core, cette partie sera int√©ressante pour les d√©veloppeurs pour acqu√©rir des comp√©tences d'automatisation du d√©ploiement en g√©n√©ral.  Le code source est disponible dans le r√©f√©rentiel github, lien √† la fin de l'article.  Eh bien, allons-y! <br><a name="habracut"></a><br>  Je suppose que vous avez votre propre application Symfony, mais √† des fins de d√©monstration, j'ai esquiss√© ¬´bonjour, monde!¬ª Contenant les packages suivants: <br><br>  <code>`symfony/webpack-encore-bundle symfony/form symfony/orm-pack symfony/profiler-pack symfony/security-bundle symfony/twig-bundle symfony/validator symfony/phpunit-bridge`</code> est un ensemble minimal de gentleman.  Pour le moment, la structure des dossiers devrait √™tre la suivante: <br><br><img width="350" src="https://habrastorage.org/webt/6m/ck/xi/6mckxiczmqlde3nsjhdpzcbforq.png" alt="image"><br><br>  Vous devez maintenant configurer votre infrastructure cloud.  Je ne me concentrerai pas sur l'enregistrement et l'activation de la p√©riode d'essai d'AWS, √† ce stade, nous devons cr√©er 2 instances de base de donn√©es - j'utiliserai 2 types d'environnement: STG (staging) pour tester la mise en ≈ìuvre de nouvelles ¬´fonctionnalit√©s¬ª et PROD (production) comme directement ¬´combat¬ª serveur  De nombreux articles ont √©t√© √©crits sur les avantages de la base de donn√©es de services g√©r√©s, de plus, nous recherchons principalement la commodit√© pour le d√©veloppeur dans ce guide, nous utilisons donc RDS, plut√¥t que d'√©lever notre propre serveur de base de donn√©es distinct.  En tant que SGBD pour cet exemple, j'ai utilis√© PostgreSQL, vous √™tes libre de choisir celui qui vous convient, acc√©dez au service RDS et cr√©ez 2 instances de la capacit√© et du volume dont vous avez besoin.  √âtant donn√© que le fichier <code>.env</code> est disponible pour nous hors de la bo√Æte dans Symfony, nous allons l'utiliser, par exemple, pour PROD, et pour STG nous allons cr√©er une copie de <code>.env.stg</code> et changer <code>APP_ENV=dev</code> en <code>APP_ENV=stg</code> <code>.env.stg</code> dans <code>.env.stg</code> et <code>APP_ENV=dev</code> sur <code>APP_ENV=prod</code> dans <code>.env</code> , et entrez √©galement les param√®tres de connexion √† la <code>.env</code> pour chacune des instances cr√©√©es. <br><br>  G√©nial, un d√©but a √©t√© fait!  Comme vous le savez, les d√©pendances symfony sont install√©es via composer, pour l'installer, utilisez le fichier composer.sh, que nous mettons √† la racine du projet: <br><br><div class="spoiler">  <b class="spoiler_title">composer.sh</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#!/bin/sh EXPECTED_SIGNATURE="$(wget -q -O - https://composer.github.io/installer.sig)" php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');" ACTUAL_SIGNATURE="$(php -r "echo hash_file('sha384', 'composer-setup.php');")" if [ "$EXPECTED_SIGNATURE" != "$ACTUAL_SIGNATURE" ] then &gt;&amp;2 echo 'ERROR: Invalid installer signature' rm composer-setup.php exit 1 fi php composer-setup.php --quiet RESULT=$? rm composer-setup.php exit $RESULT</code> </pre> <br></div></div><br>  Ceci <a href="">est un</a> guide d' <a href="">installation du logiciel de composer</a> . <br><br>  Maintenant, pour chaque environnement, cr√©ez votre propre Dockerfile √† la racine du projet: <br><br><div class="spoiler">  <b class="spoiler_title">Dockerfile.stg (mise en sc√®ne)</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">FROM php:7.2.19-apache EXPOSE 80 RUN mv "$PHP_INI_DIR/php.ini-production" "$PHP_INI_DIR/php.ini" &amp;&amp; a2enmod rewrite RUN sed -ri -e 's!memory_limit = 128M!memory_limit = 256M!g' "$PHP_INI_DIR/php.ini" RUN apt-get update &amp;&amp; apt-get install -y \ wget \ curl \ libfreetype6-dev \ libjpeg62-turbo-dev \ libpng-dev \ libzip-dev \ zip \ libpq-dev \ &amp;&amp; docker-php-ext-configure gd --with-freetype-dir=/usr/include/ --with-jpeg-dir=/usr/include/ \ &amp;&amp; docker-php-ext-configure zip --with-libzip \ &amp;&amp; docker-php-ext-configure pgsql -with-pgsql=/usr/local/pgsql \ &amp;&amp; docker-php-ext-install -j$(nproc) gd \ &amp;&amp; docker-php-ext-install zip \ &amp;&amp; docker-php-ext-install pdo pdo_pgsql pgsql WORKDIR /var/www ENV APACHE_DOCUMENT_ROOT /var/www/public RUN sed -ri -e 's!/var/www/html!${APACHE_DOCUMENT_ROOT}!g' /etc/apache2/sites-available/*.conf RUN sed -ri -e 's!/var/www/!${APACHE_DOCUMENT_ROOT}!g' /etc/apache2/apache2.conf /etc/apache2/conf-available/*.conf RUN echo "ServerName localhost" &gt;&gt; /etc/apache2/apache2.conf COPY ./composer.sh ./ RUN chmod +x ./composer.sh &amp;&amp; ./composer.sh &amp;&amp; mv composer.phar /usr/local/bin/composer RUN curl -sL https://deb.nodesource.com/setup_10.x | bash - \ &amp;&amp; apt-get install -y nodejs RUN curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | apt-key add - \ &amp;&amp; echo "deb https://dl.yarnpkg.com/debian/ stable main" | tee /etc/apt/sources.list.d/yarn.list \ &amp;&amp; apt-get update -qq \ &amp;&amp; apt-get install -y yarn COPY ./ ./ COPY ./.env.stg ./.env RUN composer install &amp;&amp; yarn &amp;&amp; yarn run build</code> </pre> <br></div></div><br>  et <br><br><div class="spoiler">  <b class="spoiler_title">Dockerfile (production)</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">FROM php:7.2.19-apache EXPOSE 80 RUN mv "$PHP_INI_DIR/php.ini-production" "$PHP_INI_DIR/php.ini" &amp;&amp; a2enmod rewrite RUN sed -ri -e 's!memory_limit = 128M!memory_limit = 256M!g' "$PHP_INI_DIR/php.ini" RUN apt-get update &amp;&amp; apt-get install -y \ wget \ curl \ libfreetype6-dev \ libjpeg62-turbo-dev \ libpng-dev \ libzip-dev \ zip \ libpq-dev \ &amp;&amp; docker-php-ext-configure gd --with-freetype-dir=/usr/include/ --with-jpeg-dir=/usr/include/ \ &amp;&amp; docker-php-ext-configure zip --with-libzip \ &amp;&amp; docker-php-ext-configure pgsql -with-pgsql=/usr/local/pgsql \ &amp;&amp; docker-php-ext-install -j$(nproc) gd \ &amp;&amp; docker-php-ext-install zip \ &amp;&amp; docker-php-ext-install pdo pdo_pgsql pgsql WORKDIR /var/www ENV APACHE_DOCUMENT_ROOT /var/www/public RUN sed -ri -e 's!/var/www/html!${APACHE_DOCUMENT_ROOT}!g' /etc/apache2/sites-available/*.conf RUN sed -ri -e 's!/var/www/!${APACHE_DOCUMENT_ROOT}!g' /etc/apache2/apache2.conf /etc/apache2/conf-available/*.conf RUN echo "ServerName localhost" &gt;&gt; /etc/apache2/apache2.conf COPY ./composer.sh ./ RUN chmod +x ./composer.sh &amp;&amp; ./composer.sh &amp;&amp; mv composer.phar /usr/local/bin/composer RUN curl -sL https://deb.nodesource.com/setup_10.x | bash - \ &amp;&amp; apt-get install -y nodejs RUN curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | apt-key add - \ &amp;&amp; echo "deb https://dl.yarnpkg.com/debian/ stable main" | tee /etc/apt/sources.list.d/yarn.list \ &amp;&amp; apt-get update -qq \ &amp;&amp; apt-get install -y yarn COPY ./ ./ RUN composer install &amp;&amp; yarn &amp;&amp; yarn run build</code> </pre> <br></div></div><br>  Les fichiers peuvent √™tre utilis√©s ¬´tels quels¬ª, aucune macro n'est utilis√©e pour les modifications.  Parcourons le contenu du Dockerfile pour dissiper la touche ¬´magique¬ª.  En tant que ¬´fondation¬ª, nous utilisons l'image officielle PHP 7.2.19 avec le serveur Web Apache int√©gr√© (vous √™tes libre d'utiliser n'importe lequel de votre choix, de configurer un bundle avec Nginx, et ainsi de suite, dans cet exemple, j'utilise ce qui pr√©c√®de comme le plus, √† mon avis, pratique).  La ligne d'exposition n'est pas importante pour nous pour le moment, elle ne fait rien en soi, mais √† l'avenir, elle sera utilis√©e par ElasticBeanstalk, qui en a besoin pour se d√©ployer correctement.  Les constructions suivantes utilisent des param√®tres de production optimis√©s pour PHP recommand√©s par le fabricant, activent mod_rewrite pour Apache et augmentent la m√©moire maximale pour un script PHP de 128 √† 256 Mo, ce qui est n√©cessaire pour que composer fonctionne correctement.  Ensuite, nous installons les applications n√©cessaires, les d√©pendances et extensions PHP, et les configurons imm√©diatement.  Nous attribuons le dossier / var / www au r√©pertoire de travail de notre application - le code source de notre application y sera copi√©.  Comme apache, par d√©faut, utilise / var / www comme point d'entr√©e pour son h√¥te, et que le fichier d'index symfony se trouve dans / var / www / public, nous changeons la racine du document apache avec la construction suivante.  Ensuite, nous installons s√©quentiellement compositeur, nodejs et fil (si vous n'utilisez pas encore / react.js dans votre application, vous n'avez pas besoin des deux derniers points).  Enfin, nous copions notre code source et commen√ßons l'installation des d√©pendances via composer pour symfony et yarn pour react.js.  La signification d'un Dockerfile distinct pour STG r√©side dans l'avant-derni√®re instruction pour docker - copier .env.stg vers .env, de sorte que le fichier .env dans l'image STG contiendra les param√®tres pertinents pour cet environnement.  Vous pouvez localement (bien s√ªr avec docker install√©) collecter l'image, l'ex√©cuter et vous assurer que l'application fonctionne et n'a besoin de rien d'autre pour ce travail: <br><br><pre> <code class="plaintext hljs">docker build -t tmp:stg -f Dockerfile.stg . docker run -p 80:80 tmp:stg</code> </pre> <br>  pour STG et <br><br><pre> <code class="plaintext hljs">docker build -t tmp:prod . docker run -p 80:80 tmp:prod</code> </pre> <br>  pour PROD. <br>  Nous pouvons utiliser EC2, configurer ELB / ASG, etc., ou utiliser ElasticBeanstalk, qui est juste un cadeau pour nous en termes de commodit√©.  Acc√©dez √† la section ElasticBeanstalk et cr√©ez une nouvelle application avec son nom et sa description.  Ensuite, cr√©ez 2 environnements mentionn√©s pr√©c√©demment: STG et PROD, cr√©ez les deux environnements en tant qu'environnement de serveur Web, sp√©cifiez ¬´Docker¬ª comme plate-forme et laissez l'exemple d'application comme code d'application.  Le d√©ploiement vers ElasticBeanstalk se fait en t√©l√©chargeant des fichiers de projet ou des instructions, g√©n√©ralement dans une archive zip.  Dans notre cas, le flux sera le suivant: nous collectons l'image docker de notre application, la chargeons dans le r√©f√©rentiel et chargeons l'instruction √† la place de l'archive source ou de l'image docker, qui indique √† ElasticBeanstalk de prendre l'image du serveur distant et de la d√©ployer.  Et tout cela est automatique. <br><br>  Commen√ßons par cr√©er un r√©f√©rentiel pour stocker les images docker.  Il y a 2 options: <br><br>  1 - votre projet est priv√©, son code est ferm√© et le r√©f√©rentiel, respectivement, doit √©galement √™tre ferm√©.  Dans ce cas, vous devez conserver votre propre registre d'images quelque part ou utiliser un cloud priv√©.  AWS a ECR √† ces fins, vous pouvez y cr√©er un r√©f√©rentiel, mais personne ne vous y oblige. <br><br>  2 - vous avez un projet open source et vous pouvez utiliser dockerhub. <br><br>  Dans notre exemple, le code est ouvert, mais je vais montrer comment utiliser des r√©f√©rentiels ferm√©s, apr√®s avoir compris ce processus, la connexion d'une image √† partir de dockerhub ne sera pas difficile.  La premi√®re chose dont nous avons besoin est de cr√©er le r√©f√©rentiel lui-m√™me, apr√®s quoi vous obtiendrez son URI unique.  La narration suppl√©mentaire ira pour les tiers (pas les r√©f√©rentiels AWS ECR et leur int√©gration), pour ECR j'√©crirai apr√®s cela. <br><br>  Apr√®s avoir cr√©√© le r√©f√©rentiel, nous devons nous connecter √† ce service et il y a une petite astuce ... Allez dans les param√®tres de votre docker install√© localement et v√©rifiez que vous avez la possibilit√© d'enregistrer les mots de passe dans le stockage externe supprim√© (pour les utilisateurs de macOS: ¬´Stockez en toute s√©curit√© les connexions de docker dans macOS Keychain ‚Äù), sinon le fichier de configuration dont nous avons besoin sera vide.  Et donc, nous autorisons dans le service s√©lectionn√© √† stocker les registres de vos images: <br><br><pre> <code class="plaintext hljs">docker login -u LOGIN -p PASSWORD REGISTRY</code> </pre> <br>  apr√®s l'authentification r√©ussie, la construction suivante appara√Ætra dans le fichier de configuration ~ / .docker / config.json: <br><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"REGISTRY"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"auth"</span></span> : <span class="hljs-string"><span class="hljs-string">"BASE64_ENCODED_TOKEN"</span></span> }</code> </pre><br>  S'il n'appara√Æt pas, v√©rifiez √† nouveau la configuration du docker d√©crite ci-dessus. <br><br>  Maintenant, tout est pr√™t pour pr√©parer le fichier d'instructions pour ElasticBeanstalk - Dockerrun.aws.json, son code sera comme ceci: <br><br><div class="spoiler">  <b class="spoiler_title">Dockerrun.aws.json</b> <div class="spoiler_text"><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"AWSEBDockerrunVersion"</span></span>: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Authentication"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Bucket"</span></span>: <span class="hljs-string"><span class="hljs-string">"BUCKET_ID"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Key"</span></span>: <span class="hljs-string"><span class="hljs-string">"KEY_PATH"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"Image"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"IMAGE_URL"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Update"</span></span>: <span class="hljs-string"><span class="hljs-string">"true"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"Ports"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"ContainerPort"</span></span>: <span class="hljs-string"><span class="hljs-string">"80"</span></span> } ] }</code> </pre><br></div></div><br>  En g√©n√©ral, l'instruction ressemble √† ceci: apr√®s s'√™tre connect√© en utilisant la cl√© localis√©e par KEY_PATH dans le stockage S3 BUCKET_ID, charger l'image par IMAGE_URL en √©crasant celle enregistr√©e, la d√©marrer en redirigeant le port 80 vers le m√™me port du conteneur.  Maintenant sur les constantes utilis√©es: <br><br>  BUCKET_ID est le ¬´sac √† dos¬ª cr√©√© automatiquement pour vous dans le service S3, sous la forme √©lastiquebeanstalk-REGION-HASH, c'est l√† que le syst√®me localise les fichiers de service pour votre ElasticBeanstalk, y compris les fichiers d'application que vous t√©l√©chargez √† l'aide du bouton ¬´T√©l√©charger et d√©ployer¬ª. <br><br>  KEY_PATH - chemin d'acc√®s au fichier d'autorisation vers le r√©f√©rentiel d'images, j'utilise le format APP_NAME / cr.json, c'est-√†-dire dans le dossier √† l'int√©rieur de BUCKET_ID sous le nom de mon application (je cr√©e, sinon encore) je mets le fichier cr.json contenant le code re√ßu apr√®s autorisation dans le registre Images localement: <br><br><div class="spoiler">  <b class="spoiler_title">BUCKET_ID / APP_NAME / cr.json</b> <div class="spoiler_text"><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"REGISTRY"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"auth"</span></span> : <span class="hljs-string"><span class="hljs-string">"BASE64_ENCODED_TOKEN"</span></span> } }</code> </pre> </div></div><br>  IMAGE_URL est l'URI unique de votre registre d'image + tag de l'image elle-m√™me, tout doit √™tre clair ici. <br><br>  Voil√†, nous pouvons maintenant t√©l√©charger ce fichier en tant que version de notre application dans ElasticBeanstalk, et il va extraire l'image sp√©cifi√©e et la d√©ployer. <br><br>  Il reste √† automatiser ce processus.  Et pour √™tre absolument int√©ressant, je vais impl√©menter la s√©quence d'√©tapes pour le flux suivant: pour tous les commits PAS dans la branche master, l'image sera collect√©e et d√©ploy√©e dans l'environnement STG, et si nous poussons dans le master, ou mieux, fermez-le et remplissez-le avec une demande de fusion , le code sera d√©ploy√© sur PROD.  Ainsi, nous obtenons dans PROD un assistant √† jour, dans lequel tout devrait bien se passer, et des branches pour d√©velopper et tester de nouveaux codes dans STG.  Pour cette impl√©mentation, nous avons besoin d'instructions pour t√©l√©charger les images les plus r√©centes, copier Dockerrun.aws.json dans Dockerrun.aws.stg.json et renommer Dockerrun.aws.json en Dockerrun.aws.prod.json (juste pour plus de commodit√©). <br><br>  La seule chose qui distingue Dockerrun.aws.stg.json de Dockerrun.aws.prod.json est IMAGE_URL: <br><br><div class="spoiler">  <b class="spoiler_title">Dockerrun.aws.stg.json</b> <div class="spoiler_text"><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"AWSEBDockerrunVersion"</span></span>: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Authentication"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Bucket"</span></span>: <span class="hljs-string"><span class="hljs-string">"BUCKET_ID"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Key"</span></span>: <span class="hljs-string"><span class="hljs-string">"KEY_PATH"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"Image"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"IMAGE_URL:dev"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Update"</span></span>: <span class="hljs-string"><span class="hljs-string">"true"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"Ports"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"ContainerPort"</span></span>: <span class="hljs-string"><span class="hljs-string">"80"</span></span> } ] }</code> </pre><br></div></div><br>  Comme je l'ai dit au d√©but de l'article, j'utiliserai CircleCI comme CI / CD, ce qui, selon mes sentiments personnels, est plus rapide que GitlabCI si j'utilise la version SaaS gratuite.  Free Travis ferait l'affaire, mais comme il ne fonctionne pas avec les r√©f√©rentiels git priv√©s, je n'ai pas sp√©cifiquement fait de d√©monstration dessus afin qu'il n'y ait pas de d√©ception quand une telle opportunit√© √©tait n√©cessaire.  Je laisserai les param√®tres du projet dans CircleCI aux lecteurs pour qu'ils les √©tudient eux-m√™mes, je donnerai les instructions n√©cessaires pour le d√©ploiement moi-m√™me - √† la racine de notre projet, nous cr√©erons le dossier .circleci, dans ce config.yml avec le contenu suivant: <br><br><div class="spoiler">  <b class="spoiler_title">.circleci / config.yml</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">version: 2 jobs: build: machine: true steps: - checkout - run: echo "$CI_REGISTRY_PASSWORD" | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY - run: docker build -t $CI_REGISTRY/$CI_REGISTRY_ID:dev -f Dockerfile.stg . - run: docker push $CI_REGISTRY/$CI_REGISTRY_ID:dev build-master: machine: true steps: - checkout - run: echo "$CI_REGISTRY_PASSWORD" | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY - run: docker build -t $CI_REGISTRY/$CI_REGISTRY_ID:latest . - run: docker push $CI_REGISTRY/$CI_REGISTRY_ID:latest deploy-stg: docker: - image: circleci/python:latest steps: - checkout - run: sudo pip install awsebcli --upgrade - run: | mkdir ~/.aws touch ~/.aws/config chmod 600 ~/.aws/config echo "[profile eb-cli]" &gt; ~/.aws/config echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config - run: eb init --region EB_REGION --platform Docker EB_APP - run: cp Dockerrun.aws.stg.json Dockerrun.aws.json - run: eb use EB_ENV_STG --region EB_REGION - run: eb deploy -v --staged --profile eb-cli deploy-prod: docker: - image: circleci/python:latest steps: - checkout - run: sudo pip install awsebcli --upgrade - run: | mkdir ~/.aws touch ~/.aws/config chmod 600 ~/.aws/config echo "[profile eb-cli]" &gt; ~/.aws/config echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config - run: eb init --region EB_REGION --platform Docker EB_APP - run: cp Dockerrun.aws.prod.json Dockerrun.aws.json - run: eb use EB_ENV_STG --region EB_REGION - run: eb deploy -v --staged --profile eb-cli workflows: version: 2 build: jobs: - build: filters: branches: ignore: - master - deploy-stg: requires: - build filters: branches: ignore: - master build-deploy: jobs: - build-master: filters: branches: only: - master - deploy-prod: requires: - build-master filters: branches: only: - master</code> </pre></div></div><br>  J'ai peint le flux lui-m√™me un peu plus t√¥t, le voici traduit en yaml-instructions pour CircleCI, passons par l'impl√©mentation d'√©tapes sp√©cifiques.  Il est important de noter la pr√©sence de variables d'environnement d√©finies pour CI qui seront utilis√©es par lui lors des travaux: <br><br>  CI_REGISTRY, CI_REGISTRY_USER, CI_REGISTRY_PASSWORD sont n√©cessaires pour acc√©der au stockage d'images docker - la m√™me chose que nous avons mise dans cr.json, uniquement sans base64 <br><br>  CI_REGISTRY / CI_REGISTRY_ID composent une URL d'image unique, sans balise <br><br>  AWS_ACCESS_KEY_ID et AWS_SECRET_ACCESS_KEY - les noms parlent d'eux-m√™mes, ce sont des cr√©dits AWS pour l'utilisateur au nom duquel CircleCI d√©ploiera.  Acc√©dez √† AWS IAM et cr√©ez un utilisateur, ajoutez-le au groupe d'administrateurs et fournissez uniquement un acc√®s par programme.  N'oubliez pas que AWS_SECRET_ACCESS_KEY n'est disponible pour la visualisation / copie qu'une seule fois, apr√®s avoir cliqu√© sur le lien Afficher, vous ne le verrez plus. <br><br>  Retour aux √©tapes de configuration de CircleCI.  Quelle est la magie?  Checkout charge le code source de la branche git dans le r√©pertoire de travail actuel, ce processus est r√©p√©t√© dans chaque travail.  Dans le processus de construction, nous nous connectons s√©quentiellement au r√©f√©rentiel, collectons le code bas√© sur Dockerfile.stg sous la balise XXX: dev et l'envoyons au r√©f√©rentiel.  build-master fait de m√™me, uniquement pour le build, il utilise le Dockerfile ¬´normal¬ª sous la balise XXX: latest. <br><br>  deploy-stg installe l'AWS EB CLI et cr√©e un profil d'autorisation dans le fichier ~ / .aws / config, qui est n√©cessaire pour que la CLI fonctionne correctement, puis initialise les variables pour la CLI - vous devrez sp√©cifier la r√©gion que vous choisissez, la plate-forme - toujours Docker et le nom de votre application.  Ensuite, nous copions le contenu de Dockerrun.aws.stg.json dans le nouveau fichier Dockerrun.aws.json et, en utilisant l'environnement et la r√©gion sp√©cifiques, donnons une commande pour d√©ployer notre application en utilisant le profil d'autorisation cr√©√©.  Par d√©faut, √† la suite de cette commande, tout le code de la branche surveill√©e se retrouvera dans une archive zip, qui sera t√©l√©charg√©e sur ElasticBeanstalk et d√©compress√©e l√†, mais cette op√©ration est relativement co√ªteuse, donc nous avons cr√©√© un nouveau fichier Dockerrun.aws.json, qui est suffisant pour d√©ployer le cr√©√© par nous image distante, et nous avons seulement besoin de la t√©l√©charger, en fait.  Pour ce faire, cr√©ez un fichier .ebignore √† la racine du projet: <br><br><div class="spoiler">  <b class="spoiler_title">.ebignore</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">* !Dockerrun.aws.json</code> </pre></div></div><br>  Ce fichier utilise la syntaxe .gitignore et il s'agit de .gitignore, mais pas pour la CLI Git, mais pour la CLI AWS EB.  Dans ce fichier, je dis √† la CLI de sauter tous les fichiers sauf Dockerrun.aws.json.  Voil√†, maintenant, lorsque vous ex√©cutez le travail deploy-stg dans ElasticBeanstalk, seul le fichier que nous avons cr√©√© sera envoy√©.  deploy-prod fait la m√™me chose, copie uniquement le contenu du fichier Dockerrun.aws.prod.json dans Dockerrun.aws.json, et le dernier est une indication de la s√©quence de travail au format CircleCI (deploy-stg apr√®s construction et deploy-prod apr√®s construction -master), et sur quelles branches les donn√©es recherchent (ignorer: - master et uniquement: - master). <br><br>  Une question un peu diff√©rente est avec AWS ECR, comme je l'ai promis, nous y reviendrons.  Vous n'avez pas besoin de vous connecter √† distance √† l'ECR et de cr√©er un fichier cr.json, car ElasticBeanstalk ¬´conna√Æt un fr√®re en personne¬ª.  En cons√©quence, Dockerrun.aws.json sera diff√©rent - il n'y aura tout simplement pas de bloc d'authentification: <br><br><div class="spoiler">  <b class="spoiler_title">Dockerrun.aws.json (AWS ECR)</b> <div class="spoiler_text"><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"AWSEBDockerrunVersion"</span></span>: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Image"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"IMAGE_URL"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Update"</span></span>: <span class="hljs-string"><span class="hljs-string">"true"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"Ports"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"ContainerPort"</span></span>: <span class="hljs-string"><span class="hljs-string">"80"</span></span> } ] }</code> </pre><br></div></div><br>  Mais comment se fera alors l'authentification?  Le fait est que le service qui acc√®de √† l'ECR a un certain ensemble de droits, qui √† leur tour sont bas√©s sur certaines politiques de s√©curit√©.  Dans notre cas, lorsque le d√©ploiement est lanc√© via l'AWS CLI √† partir d'un serveur tiers (√† partir de CI), le r√¥le ¬´aws-elasticbeanstalk-ec2-role¬ª est utilis√©, recherchez-le dans AWS IAM dans la section des r√¥les et attachez-lui la strat√©gie suppl√©mentaire ¬´AmazonEC2ContainerRegistryReadOnly¬ª.  D√©sormais, le t√©l√©chargement √† partir d'un r√©f√©rentiel priv√© vers son ¬´voisin¬ª r√©ussira sans erreur. <br><br>  Mais cela se charge exactement √† partir du m√™me VPC, via la CLI, la commande de connexion Docker n'est pas non plus "sans astuces": vous devez obtenir (obtenir simplement) des cr√©dits pour la connexion Docker via l'AWS CLI, pour cela, il existe une commande <br><br> <code>aws ecr get-login --region REGION --no-include-email</code> <br> <br>  Cette commande vous renverra une ligne du formulaire de connexion docker ..., mettez simplement, dans la console que vous devez ex√©cuter <br><br> <code>eval $(aws ecr get-login --region EB_REGION --no-include-email)</code> <br> <br>  La commande recevra d'abord une cha√Æne pour l'authentification, puis d√©marrera le processus correspondant.  Au vu de ces r√®gles pour AWS ECR, le fichier d'instructions pour CircleCI ressemblera √† ceci: <br><br><div class="spoiler">  <b class="spoiler_title">.circleci / config.yml (pour AWS ECR)</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">version: 2 jobs: build: docker: - image: circleci/python:latest steps: - checkout - run: sudo pip install awscli --upgrade - run: | mkdir ~/.aws touch ~/.aws/config chmod 600 ~/.aws/config echo "[profile eb-cli]" &gt; ~/.aws/config echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config - setup_remote_docker - run: eval $(aws ecr get-login --region EB_REGION --no-include-email) - run: docker build -t $CI_REGISTRY/$CI_REGISTRY_ID:dev -f Dockerfile.stg . - run: docker push $CI_REGISTRY/$CI_REGISTRY_ID:dev build-master: docker: - image: circleci/python:latest steps: - checkout - run: sudo pip install awscli --upgrade - run: | mkdir ~/.aws touch ~/.aws/config chmod 600 ~/.aws/config echo "[profile eb-cli]" &gt; ~/.aws/config echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config - setup_remote_docker - run: eval $(aws ecr get-login --region EB_REGION --no-include-email) - run: docker build -t $CI_REGISTRY/$CI_REGISTRY_ID:latest . - run: docker push $CI_REGISTRY/$CI_REGISTRY_ID:latest deploy-stg: docker: - image: circleci/python:latest steps: - checkout - run: sudo pip install awsebcli --upgrade - run: | mkdir ~/.aws touch ~/.aws/config chmod 600 ~/.aws/config echo "[profile eb-cli]" &gt; ~/.aws/config echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config - run: eb init --region EB_REGION --platform Docker EB_APP - run: cp Dockerrun.aws.stg.json Dockerrun.aws.json - run: eb use EB_ENV_STG --region EB_REGION - run: eb deploy -v --staged --profile eb-cli deploy-prod: docker: - image: circleci/python:latest steps: - checkout - run: sudo pip install awsebcli --upgrade - run: | mkdir ~/.aws touch ~/.aws/config chmod 600 ~/.aws/config echo "[profile eb-cli]" &gt; ~/.aws/config echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config - run: eb init --region EB_REGION --platform Docker EB_APP - run: cp Dockerrun.aws.prod.json Dockerrun.aws.json - run: eb use EB_ENV_STG --region EB_REGION - run: eb deploy -v --staged --profile eb-cli workflows: version: 2 build: jobs: - build: filters: branches: ignore: - master - deploy-stg: requires: - build filters: branches: ignore: - master build-deploy: jobs: - build-master: filters: branches: only: - master - deploy-prod: requires: - build-master filters: branches: only: - master</code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour prendre en charge docker-in-docker, nous avons ajout√© setup_remote_docker aux √©tapes de l'assemblage, vous devez d√©j√† conna√Ætre le reste du contenu de cet article. </font><font style="vertical-align: inherit;">C'est tout, maintenant la structure de notre projet est la suivante: </font></font><br><br><img width="350" src="https://habrastorage.org/webt/7e/cw/sj/7ecwsjkjjmr8myxiuutwkujwnkg.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essayez de changer le code, poussez-le dans la branche de t√¢che, puis faites une demande de fusion (pull) au ma√Ætre et acceptez-le. </font><font style="vertical-align: inherit;">Plus de ¬´mouvements¬ª pour publier des mises √† jour. </font><font style="vertical-align: inherit;">Il est possible (et quelqu'un a besoin) d'aller plus loin, d'√©crire vos propres bureaux de travail pour les migrations en continu, de prendre une √©tape obligatoire interm√©diaire pour passer les autotests, etc. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code source GitHub: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tutorial-aws-symfony-ci</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr462415/">https://habr.com/ru/post/fr462415/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr462401/index.html">D√©veloppeur Deadly Sins</a></li>
<li><a href="../fr462403/index.html">S√©lection de la taille du moniteur: th√©orie de la taille angulaire, justification et comparaison</a></li>
<li><a href="../fr462407/index.html">Food Design Digest juillet 2019</a></li>
<li><a href="../fr462409/index.html">Biblioth√®que de g√©n√©rateur de code assembleur pour microcontr√¥leurs AVR. Partie 1</a></li>
<li><a href="../fr462411/index.html">R√©solvez le Sudoku avec l'algorithme X</a></li>
<li><a href="../fr462417/index.html">P√©tition d'Apple</a></li>
<li><a href="../fr462421/index.html">Apollo Guidance Computer - logiciel d'architecture et de syst√®me. 2e partie</a></li>
<li><a href="../fr462423/index.html">Gestion de projet</a></li>
<li><a href="../fr462429/index.html">VueJs + VueRouter + modal. Un autre v√©lo</a></li>
<li><a href="../fr462431/index.html">Le condens√© de mat√©riaux int√©ressants pour le d√©veloppeur mobile # 309 (29 juillet - 4 ao√ªt)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>