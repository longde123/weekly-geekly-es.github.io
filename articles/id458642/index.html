<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔒 🧓🏼 🧓🏼 Teori bukannya heuristik: menjadi lebih baik sebagai pengembang frontend 🥪 👬 👨🏿‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Menjadi pengembang front-end yang lebih baik menggunakan fundamental daripada heuristik 

 Pengalaman kami menunjukkan bahwa pendidik non-teknis dan o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Teori bukannya heuristik: menjadi lebih baik sebagai pengembang frontend</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/nix/blog/458642/"><img src="https://habrastorage.org/getpro/habr/post_images/424/ed0/eec/424ed0eec08450f6be205e19896298a7.png"><br><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menjadi pengembang front-end yang lebih baik menggunakan fundamental daripada heuristik</a></i> <br><br>  Pengalaman kami menunjukkan bahwa pendidik non-teknis dan orang yang belajar sendiri sering kali tidak bergantung pada prinsip-prinsip teoritis, tetapi pada metode heuristik. <br><br>  Heuristik - pola dan aturan terbukti yang telah dipelajari pengembang dari praktik.  Mereka dapat bekerja secara tidak sempurna atau dengan cara terbatas, tetapi sampai batas tertentu, dan tidak memerlukan pemikiran serius.  Berikut adalah beberapa contoh heuristik: <br><br><ul><li> “Gunakan <code>$(document).ready(function(){})</code> untuk menginisialisasi kode di situs jQuery” </li><li>  “ <code>var self = this</code> konstruk ini diperlukan untuk memanggil metode dalam fungsi panggilan balik” </li><li>  “Fungsi panah tidak memiliki <code>return</code> ” <br></li></ul><br>  Pada saat yang sama, prinsip teoretis dapat digunakan untuk menemukan solusi untuk masalah lain.  Dia selalu setia dan sering menentukan perangkat dari satu atau elemen lainnya.  Prinsip-prinsip teoretis meliputi, misalnya: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sintaks resmi untuk fungsi panah</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumentasi Lodash API</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aturan penggunaan dan fungsi-fungsi vertikal-align</a> <br></li></ul><br>  Harap dicatat: kami hanya mengutip contoh heuristik untuk menekankan sifat artifisial heuristik dibandingkan dengan kekakuan fondasi teoritis.  Tidak ada contoh heuristik yang universal untuk semua kasus, tetapi mereka bekerja dalam situasi yang cukup sehingga pengembang yang menggunakannya menerima kode kerja tanpa pemahaman penuh tentang operasinya. <br><a name="habracut"></a><br><h2>  Argumen untuk Pendekatan Teoritis </h2><br>  Kami sering menemukan fakta bahwa pengembang tanpa pendidikan teknis tidak cenderung menyelesaikan masalah menggunakan prinsip-prinsip teoritis.  Sebagai aturan, ini dijelaskan oleh fakta bahwa pada awal karir mereka, mereka tidak memiliki kesempatan untuk mempelajarinya, dan karena metode heuristik bekerja dengan memuaskan, mereka terus menggunakannya. <br><br>  Namun, terlepas dari kerumitan yang tampak, belajar teori bisa sangat berguna.  Mengapa  Kemudian, teori itu akan membuat Anda merasa yakin bahwa solusi Anda berfungsi, serta secara mandiri menampilkan jawaban untuk pertanyaan baru, tanpa harus mencari solusi orang lain.  Dalam jangka pendek, algoritma heuristik mungkin tampak seperti solusi sederhana dan cepat, tetapi mereka sering mengarah pada solusi yang tidak sempurna - jika memang ada. <br><br>  Selain itu, dengan mengandalkan metode heuristik, Anda tidak akan pernah belajar bagaimana menyelesaikan masalah secara nyata.  Anda mungkin sering berhasil menemukan solusi yang berfungsi, tetapi cepat atau lambat Anda akan terhenti, dari mana Anda tidak akan menemukan jalan keluar.  Pemrogram C&amp;P mengandalkan heuristik dalam pekerjaan mereka. <br><br><h2>  Kriteria Tingkat Keterampilan Pengembang </h2><br>  Saat mewawancarai pengembang frontend, kami menetapkan tugas pemrograman untuk mereka dan mengatakan bahwa mereka bebas menggunakan sumber apa pun, baik itu Google atau Stack Overflow.  Dengan cara ini, mudah untuk menentukan apakah pengembang adalah penganut heuristik atau teori. <br><br>  Yang pertama, tanpa kecuali, menyalin kode dari contoh yang kurang lebih cocok dengan Stack Overflow.  Hanya ketika kode tidak berfungsi seperti yang direncanakan barulah mereka mulai menyempurnakannya sendiri.  Seringkali mereka gagal. <br><br>  Yang terakhir cenderung mencari jawaban dalam dokumentasi API.  Di sana mereka menemukan informasi tentang berapa banyak parameter fungsi tertentu, atau sintaks spesifik dari bentuk diperluas dari properti CSS yang diinginkan. <br><br>  Sudah dalam lima menit pertama wawancara Anda dapat menentukan dengan tepat apa jenis program yang dimiliki kandidat. <br><br><h2>  Contoh </h2><br>  Ambil Bill sebagai contoh.  Dia menyelesaikan beberapa kursus pelatihan, menyelesaikan sejumlah tugas dalam JavaScript dan menulis situs web di waktu luangnya, tetapi dia tidak benar-benar belajar JavaScript. <br><br>  Begitu Bill menemukan sebuah objek seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> usersById = { <span class="hljs-string"><span class="hljs-string">"5"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"5"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Adam"</span></span>, <span class="hljs-string"><span class="hljs-string">"registered"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-string"><span class="hljs-string">"27"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"27"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Bobby"</span></span>, <span class="hljs-string"><span class="hljs-string">"registered"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-string"><span class="hljs-string">"32"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"32"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Clarence"</span></span>, <span class="hljs-string"><span class="hljs-string">"registered"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }, <span class="hljs-string"><span class="hljs-string">"39"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"39"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Danielle"</span></span>, <span class="hljs-string"><span class="hljs-string">"registered"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-string"><span class="hljs-string">"42"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"42"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Ekaterina"</span></span>, <span class="hljs-string"><span class="hljs-string">"registered"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } }</code> </pre><br>  Objek semacam itu dapat menampilkan daftar pengguna dan apakah mereka telah mendaftar untuk acara tertentu. <br><br>  Misalkan Bill perlu mengambil daftar pengguna terdaftar.  Dengan kata lain, saringlah.  Dia menemukan kode di mana metode <code>.filter()</code> digunakan untuk menyaring daftar.  Jadi dia mencoba sesuatu seperti: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> attendees = usersById.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function"> =&gt;</span></span> user.registered);</code> </pre> <br>  Dan inilah yang didapatnya: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">TypeError</span></span>: usersById.filter is not a <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code> </pre> <br>  "Sesuatu yang tidak masuk akal," pikir Bill, karena dia melihat kode di mana <code>.filter()</code> bekerja sebagai filter. <br><br>  Masalahnya adalah bahwa Bill mengandalkan metode heuristik.  Dia tidak mengerti bahwa <code>filter</code> adalah metode yang didefinisikan pada array, sedangkan <code>usersById</code> adalah objek reguler yang tidak memiliki metode <code>filter</code> . <br><br>  Tagihan bingung Google " <i>filter javascript</i> ".  Dia menemukan banyak referensi untuk array dan menyadari bahwa dia perlu mengubah <code>usersById</code> menjadi sebuah array.  Kemudian, dengan meminta " <i>javascript untuk mengubah objek menjadi array</i> ", ia menemukan contoh menggunakan <code>Object.keys()</code> di Stack Overflow.  Setelah itu, ia mencoba: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> attendees = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(usersById).filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function"> =&gt;</span></span> user.registered);</code> </pre> <br>  Kali ini kesalahan tidak ditampilkan, tetapi, yang mengejutkan Bill, bidang <code>attendees</code> tetap kosong. <br><br>  Faktanya adalah <code>Object.keys()</code> mengembalikan kunci objek, tetapi tidak nilainya.  Bahkan, nama variabel <code>user</code> mudah menyesatkan, karena itu bukan objek <code>user</code> , tetapi pengidentifikasi, yaitu string.  Karena atribut <code>registered</code> tidak didefinisikan untuk string, <code>filter</code> memperlakukan setiap entri sebagai false dan array kosong. <br><br>  Bill melihat lebih dekat jawaban Stack Overflow dan membuat perubahan berikut: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> attendees = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(usersById).filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function"> =&gt;</span></span> usersById[id].registered);</code> </pre> <br>  Kali ini hasilnya lebih baik: <code>["5", "27", "39"]</code> .  Tetapi Bill ingin mendapatkan objek pengunjung, bukan ID mereka. <br><br>  Untuk memahami cara memfilter pengunjung, Bill yang kesal mencari " <i>filter objek javascript</i> ", memeriksa hasil pencarian untuk Stack Overflow dan menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jawaban ini</a> dengan kode berikut: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.filter = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj, predicate</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(obj) .filter( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key</span></span></span><span class="hljs-function"> =&gt;</span></span> predicate(obj[key]) ) .reduce( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res, key</span></span></span><span class="hljs-function">) =&gt;</span></span> (res[key] = obj[key], res), {} );</code> </pre> <br>  Bill menyalin baris-baris ini dan mencoba: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> attendees = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.filter(usersById, user =&gt; user.registered);</code> </pre> <br>  Semuanya berfungsi - meskipun tidak jelas mengapa.  Bill tidak mengerti mengapa <code>reduce</code> dibutuhkan dan bagaimana <code>reduce</code> itu digunakan.  Selain itu, Bill tidak mengerti bahwa dia baru saja mendefinisikan metode non-standar baru untuk <code>Object</code> global. <br><br>  Tapi Bill tidak peduli - itu berhasil!  Konsekuensinya belum menarik baginya. <br><br><h2>  Apa yang salah dari Bill? </h2><br>  Bill mencoba metode heuristik untuk menyelesaikan masalah dan mengalami masalah berikut: <br><br><ol><li>  Menggunakan <code>.filter()</code> pada variabel, Bill mendapat <code>TypeError</code> .  Dia tidak mengerti bahwa <code>filter</code> tidak didefinisikan pada objek biasa. <br></li><li>  Dia menggunakan <code>Object.keys()</code> untuk "mengubah objek menjadi array", tetapi ini saja tidak membawa hasil apa pun.  Dia perlu membuat array nilai objek. </li><li>  Bahkan setelah menerima nilai-nilai dan menggunakannya sebagai syarat untuk penyaringan, ia hanya menerima pengidentifikasi dan bukan objek pengguna yang terkait dengan pengidentifikasi ini.  Ini karena array yang difilter berisi ID, bukan objek pengguna. </li><li>  Seiring waktu, Bill meninggalkan pendekatan ini dan menemukan solusi yang berfungsi di Internet.  Namun demikian, dia masih tidak mengerti cara kerjanya - dan tidak akan membuang waktu untuk memilahnya, karena dia memiliki hal lain yang harus dilakukan. <br></li></ol><br>  Ini adalah contoh buatan, tetapi kami telah menemukan banyak pengembang yang memecahkan masalah dengan cara yang sama.  Untuk menyelesaikannya secara efektif, Anda perlu menjauh dari metode heuristik dan mempelajari teorinya. <br><br><h2>  Mari kita beralih ke dasar-dasar </h2><br>  Jika Bill adalah pendukung pendekatan teoretis, prosesnya akan terlihat seperti ini: <br><br><ol><li>  Untuk mengidentifikasi data input yang diberikan dan untuk menentukan output yang diinginkan - dalam arti propertinya: <i>“Saya memiliki objek yang kuncinya adalah string yang mewakili ID, dan nilai adalah objek yang mewakili pengguna.</i>  <i>Saya ingin mendapatkan array yang nilainya akan menjadi objek pengguna - tetapi hanya objek pengguna terdaftar ”</i> </li><li>  Untuk memahami cara mencari di dalam objek: <i>"Saya tahu bahwa saya bisa mendapatkan larik kunci di objek dengan memanggil <code>Object.keys()</code> .</i>  <i>Saya ingin mendapatkan array karena array mendukung pencacahan</i> . <i>"</i> </li><li>  Untuk menyadari bahwa metode ini membantu untuk mendapatkan kunci, dan Anda perlu mengubah kunci menjadi nilai, dan ingat tentang <code>map</code> - metode yang jelas untuk membuat array baru dengan mengubah nilai-nilai array lain: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(usersById).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function"> =&gt;</span></span> usersById[id])</code> </pre> </li><li>  Untuk melihat bahwa Anda sekarang memiliki array objek pengguna yang bisa difilter dan yang berisi nilai nyata yang ingin Anda filter: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(usersById).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function"> =&gt;</span></span> usersById[id]).filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function"> =&gt;</span></span> user.registered)</code> </pre> </li></ol><br>  Pergi Bill dengan cara ini, dia bisa bekerja untuk kita. <br><br><h2>  Mengapa orang tidak lebih sering menggunakan teori? </h2><br>  Terkadang mereka tidak mengenalnya.  Paling sering, mereka terlalu sibuk dan tidak dapat menemukan waktu untuk belajar cara memecahkan masalah ini - mereka hanya perlu segalanya untuk bekerja.  Mereka berisiko mengubah pendekatan ini menjadi kebiasaan yang akan menjadi hambatan bagi pengembangan keterampilan mereka. <br><br>  Untuk menghindari kesalahan seperti itu, selalu mulai dengan teori.  Pada setiap tahap proses, pikirkan tentang jenis data apa yang Anda hadapi.  Alih-alih mengandalkan pola yang sudah dikenal sepanjang waktu, pertimbangkan tipe data primitif: array, objek, string, dll.  Saat menggunakan fungsi atau metode, lihat dokumentasi untuk mengetahui dengan tepat tipe data apa yang mendukungnya, argumen apa yang mereka ambil, dan apa hasilnya. <br><br>  Dengan pendekatan ini, Anda dapat menemukan solusi yang berfungsi pada percobaan pertama.  Anda dapat memastikan kebenarannya, karena Anda secara khusus memilih tindakan Anda berdasarkan input yang diberikan dan output yang diinginkan.  Masuk jauh ke dasar-dasar setiap operasi (tipe data dan nilai pengembalian), daripada formulasi bisnis fuzzy (seperti "pengguna terdaftar"). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458642/">https://habr.com/ru/post/id458642/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458632/index.html">Benar-benar mengetik vue</a></li>
<li><a href="../id458634/index.html">"Jangan jahat" atau apa yang disembunyikan Facebook dari kami</a></li>
<li><a href="../id458636/index.html">Kaset video dari mitap DevLeads dari kantor Tutu.ru</a></li>
<li><a href="../id458638/index.html">Intel oneAPI Project: banyak arsitektur, satu API</a></li>
<li><a href="../id458640/index.html">Menemukan Dash Panjang</a></li>
<li><a href="../id458646/index.html">Atom Swap Singkatnya</a></li>
<li><a href="../id458648/index.html">CI / CD dengan AWS dan Bambu</a></li>
<li><a href="../id458650/index.html">Tantangan Dunia Maya. Tingkat baru. Persaingan online dari Rostelecom Solar</a></li>
<li><a href="../id458652/index.html">RamblerFront & Meetup # 7</a></li>
<li><a href="../id458654/index.html">Virus Lurk meretas bank ketika ditulis oleh pekerja sewaan biasa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>