<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöµ üîï üôåüèΩ Prueba de contratos inteligentes de Ethereum en marcha: adi√≥s, JavaScript üßü ‚òùÔ∏è üëéüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quiero agradecer a mis colegas: Sergey Nemesh, Mikhail Popsuyev, Evgeny Babich e Igor Titarenko por sus consultas, comentarios y pruebas. Tambi√©n quie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Prueba de contratos inteligentes de Ethereum en marcha: adi√≥s, JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445254/"><p><img src="https://cdn-images-1.medium.com/max/1600/1*WNQyyGK2TrOy2m784kJang.jpeg" alt="imagen"><br>  <em>Quiero agradecer a mis colegas: Sergey Nemesh, Mikhail Popsuyev, Evgeny Babich e Igor Titarenko por sus consultas, comentarios y pruebas.</em>  <em>Tambi√©n quiero agradecer al equipo de PolySwarm por desarrollar la versi√≥n original de Perigord.</em> <em><br></em> <br>  <em>Esta es una traducci√≥n de mi primer art√≠culo publicado en ingl√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">medio</a></em> </p><br><p>  Las pruebas siempre han sido una parte integral del desarrollo de software, aunque no la m√°s agradable.  Cuando se trata de contratos inteligentes, se requieren pruebas rigurosas con atenci√≥n excepcional al detalle, como  Los errores ser√°n imposibles de corregir despu√©s de la implementaci√≥n en la red blockchain.  En los √∫ltimos a√±os, la comunidad Ethereum ha creado muchas herramientas para desarrollar contratos inteligentes.  Algunos de ellos no se hicieron populares, por ejemplo, Vyper, un dialecto de Python para escribir contratos inteligentes.  Otros, como Solidity, se han convertido en un est√°ndar reconocido.  La documentaci√≥n m√°s extensa sobre la prueba de contratos inteligentes hasta la fecha proporciona un mont√≥n de Truffle &amp; Ganache.  Ambas herramientas tienen buena documentaci√≥n, muchos casos ya se han decidido sobre Stack Overflow y recursos similares.  Sin embargo, este enfoque tiene un inconveniente importante: para escribir pruebas, debe usar Node.js. </p><a name="habracut"></a><br><h4 id="lovushki-javascript">  Trampas de JavaScript </h4><br><p>  Incluso si no eres un fan√°tico de los lenguajes de programaci√≥n con tipos est√°ticos y te encanta JavaScript, considera hacer un error tipogr√°fico y comenzar a comparar el resultado de una funci√≥n que devuelve una cadena con un valor booleano usando el m√©todo de desuso igual en lugar de estrictoEqual. </p><br><pre><code class="plaintext hljs">let proposalExists = await voting.checkProposal(); assert.equal(proposalExists, true, 'Proposal should exist');</code> </pre> <br><p>  Si checkProposal devuelve la cadena "yes" o "no", siempre los convertir√° en true.  La escritura din√°mica oculta muchas de estas trampas, e incluso los programadores experimentados pueden cometer tales errores cuando trabajan en un proyecto grande o en un equipo con otros desarrolladores que pueden realizar cambios en el c√≥digo y no informarlo. </p><br><p>  La escritura est√°tica de Go ayuda a prevenir tales errores.  Adem√°s, el uso del lenguaje Go en lugar de Node.js para las pruebas es el sue√±o de cualquier desarrollador de Go que comience a trabajar con contratos inteligentes. </p><br><p>  Mi equipo estaba desarrollando un sistema de inversi√≥n basado en contratos inteligentes con una arquitectura muy compleja.  El sistema de contrato inteligente conten√≠a m√°s de 2,000 l√≠neas de c√≥digo.  Como la mayor parte del equipo eran desarrolladores de Go, las pruebas en Go eran preferibles a Node.js. </p><br><h4 id="pervaya-sreda-dlya-testirovaniya-smart-kontraktov-na-go">  El primer entorno para probar contratos inteligentes en Go </h4><br><p>  En 2017, PolySwarm desarroll√≥ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Perigord</a> , una herramienta similar a Truffle, usando Go en lugar de JavaScript.  Desafortunadamente, este proyecto ya no es compatible, solo tiene un tutorial con ejemplos muy simples.  Adem√°s, no admite la integraci√≥n con Ganache (una cadena de bloques privada para desarrollar Ethereum con una GUI muy conveniente).  Mejoramos Perigord eliminando errores e introduciendo dos nuevas funciones: generar billeteras a partir del c√≥digo mnem√≥nico y usarlas para probar y conectarse a la cadena de bloques de Ganache.  Puedes leer el c√≥digo fuente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . </p><br><p>  El tutorial original de Perigord contiene solo el ejemplo m√°s simple de invocar un contrato para cambiar un solo valor.  Sin embargo, en el mundo real, tambi√©n deber√° llamar a un contrato desde diferentes billeteras, enviar y recibir Ether, etc.  Ahora puedes hacer todo esto usando el Perigord avanzado y el viejo Ganache.  A continuaci√≥n encontrar√° una gu√≠a detallada sobre el desarrollo y prueba de contratos inteligentes con Perigord &amp; Ganache. </p><br><h4 id="ispolzovanie-uluchshennogo-perigord-polnoe-rukovodstvo">  Uso de Perigord avanzado: una gu√≠a completa </h4><br><p>  Para usar Perigord necesita instalar Go 1.7+, solc, abigen y Ganache.  Consulte la documentaci√≥n de su sistema operativo. </p><br><p>  Instale Perigord de la siguiente manera: </p><br><pre> <code class="plaintext hljs">$ go get gitlab.com/go-truffle/enhanced-perigord $ go build</code> </pre> <br><p>  Despu√©s de eso, puedes usar el comando perigord: </p><br><pre> <code class="plaintext hljs">$ perigord A golang development environment for Ethereum Usage: perigord [command] Available Commands: add Add a new contract or test to the project build (alias for compile) compile Compile contract source files deploy (alias for migrate) generate (alias for compile) help Help about any command init Initialize new Ethereum project with example contracts and tests migrate Run migrations to deploy contracts test Run go and solidity tests Flags: -h, --help help for perigord Use "perigord [command] --help" for more information about a command.</code> </pre> <br><p>  Ahora crearemos un contrato simple de mercado inteligente para demostrar las opciones de prueba disponibles. </p><br><p>  Para comenzar un proyecto, ingrese lo siguiente en la terminal: </p><br><pre> <code class="plaintext hljs">$ perigord init market</code> </pre> <br><p>  El proyecto aparecer√° en la carpeta src / en GOPATH.  Mueva el proyecto a otra carpeta y actualice las rutas de importaci√≥n si desea cambiar su ubicaci√≥n.  Veamos qu√© hay en el mercado / carpeta. </p><br><pre> <code class="plaintext hljs">$ tree . ‚îú‚îÄ‚îÄ contracts ‚îÇ ‚îî‚îÄ‚îÄ Foo.sol ‚îú‚îÄ‚îÄ generate.go ‚îú‚îÄ‚îÄ main.go ‚îú‚îÄ‚îÄ migrations ‚îÇ ‚îî‚îÄ‚îÄ 1_Migrations.go ‚îú‚îÄ‚îÄ perigord.yaml ‚îú‚îÄ‚îÄ stub ‚îÇ ‚îú‚îÄ‚îÄ README.md ‚îÇ ‚îî‚îÄ‚îÄ main.go ‚îú‚îÄ‚îÄ stub_test.go ‚îî‚îÄ‚îÄ tests ‚îî‚îÄ‚îÄ Foo.go</code> </pre> <br><p>  Muy similar al proyecto creado en Truffle, ¬øno?  Pero todo est√° en marcha!  Veamos qu√© hay en el archivo de configuraci√≥n perigord.yaml. </p><br><pre> <code class="plaintext hljs">networks: dev: url: /tmp/geth_private_testnet/geth.ipc keystore: /tmp/geth_private_testnet/keystore passphrase: blah mnemonic: candy maple cake sugar pudding cream honey rich smooth crumble sweet treat num_accounts: 10</code> </pre> <br><p>  Para las pruebas, puede usar tanto la red geth privada como los archivos de billetera y conectarse a Ganache.  Estas opciones son mutuamente excluyentes.  Tomamos la mnemotecnia predeterminada, generamos 10 cuentas y nos conectamos a Ganache.  Reemplace el c√≥digo en perigord.yaml con: </p><br><pre> <code class="plaintext hljs">networks: dev: url: HTTP://127.0.0.1:7545 mnemonic: candy maple cake sugar pudding cream honey rich smooth crumble sweet treat num_accounts: 10</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HTTP http://127.0.0.1:7545</a> : la direcci√≥n est√°ndar del servidor Ganache RPC.  Tenga en cuenta que puede crear cualquier n√∫mero de cuentas para pruebas, pero solo las cuentas generadas en Ganache (GUI) contendr√°n fondos. </p><br><p>  Crearemos un contrato llamado Market.sol.  Puede mantener un registro de pares de direcciones, una de las cuales env√≠a fondos a la cuenta del contrato, y la otra tiene derecho a recibir fondos cuando el propietario del contrato autoriza dicha transacci√≥n.  Por ejemplo, dos participantes no conf√≠an el uno en el otro, sino que conf√≠an en el propietario del contrato, que decide si se cumple una determinada condici√≥n.  El ejemplo implementa varias funciones b√°sicas para fines de demostraci√≥n. </p><br><p>  Agregar un contacto al proyecto: </p><br><pre> <code class="plaintext hljs">$ perigord add contract Market</code> </pre> <br><p>  El postfix .sol se agregar√° autom√°ticamente.  Tambi√©n puede agregar otros contratos o eliminar el contrato de muestra Foo.sol.  Mientras trabaja en GOPATH, puede usar contratos de importaci√≥n para crear estructuras complejas.  Tendremos tres archivos de Solidity: el contrato principal de Market, los contratos auxiliares Ownable and Migrations y la biblioteca SafeMath.  Puedes encontrar el c√≥digo fuente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . </p><br><p>  Ahora el proyecto tiene la siguiente estructura: </p><br><pre> <code class="plaintext hljs">. ‚îú‚îÄ‚îÄ contracts ‚îÇ ‚îú‚îÄ‚îÄ Market.sol ‚îÇ ‚îú‚îÄ‚îÄ Ownable.sol ‚îÇ ‚îî‚îÄ‚îÄ SafeMath.sol ‚îú‚îÄ‚îÄ generate.go ‚îú‚îÄ‚îÄ main.go ‚îú‚îÄ‚îÄ migrations ‚îÇ ‚îî‚îÄ‚îÄ 1_Migrations.go ‚îú‚îÄ‚îÄ perigord.yaml ‚îú‚îÄ‚îÄ stub ‚îÇ ‚îú‚îÄ‚îÄ README.md ‚îÇ ‚îî‚îÄ‚îÄ main.go ‚îú‚îÄ‚îÄ stub_test.go ‚îî‚îÄ‚îÄ tests ‚îî‚îÄ‚îÄ Foo.go</code> </pre> <br><p>  Genere bytecode EVM, enlaces ABI y Go: </p><br><pre> <code class="plaintext hljs">$ perigord build</code> </pre> <br><p>  Agregue las migraciones de todos los contratos que implementar√°.  Porque  solo implementamos Market.sol, solo necesitamos una nueva migraci√≥n: </p><br><pre> <code class="plaintext hljs">$ perigord add migration Market</code> </pre> <br><p>  Nuestro contrato no contiene un constructor que acepte par√°metros.  Si necesita pasar par√°metros al constructor, agr√©guelos a la funci√≥n Deploy {NewContract} en el archivo de migraci√≥n: </p><br><pre> <code class="plaintext hljs">address, transaction, contract, err := bindings.Deploy{NewContract}(auth, network.Client(), ‚ÄúFOO‚Äù, ‚ÄúBAR‚Äù)</code> </pre> <br><p>  Elimine el archivo de muestra Foo.go y agregue un archivo de prueba para nuestro contrato: </p><br><pre> <code class="plaintext hljs">$ perigord add test Market</code> </pre> <br><p>  Para usar billeteras deterministas, necesitamos leer los mnem√≥nicos del archivo de configuraci√≥n: </p><br><pre> <code class="plaintext hljs">func getMnemonic() string { viper.SetConfigFile("perigord.yaml") if err := viper.ReadInConfig(); err != nil { log.Fatal() } mnemonic := viper.GetStringMapString("networks.dev")["mnemonic"] return mnemonic }</code> </pre> <br><p>  La siguiente funci√≥n auxiliar se utiliza para obtener la direcci√≥n de red: </p><br><pre> <code class="plaintext hljs">func getNetworkAddress() string { viper.SetConfigFile("perigord.yaml") if err := viper.ReadInConfig(); err != nil { log.Fatal() } networkAddr := viper.GetStringMapString("networks.dev")["url"] return networkAddr }</code> </pre> <br><p>  Otra funci√≥n auxiliar que necesitaremos es sendETH, la usaremos para transferir Ether desde una de las billeteras generadas (indicadas por el √≠ndice) a cualquier direcci√≥n de Ethereum: </p><br><pre> <code class="plaintext hljs">func sendETH(s *MarketSuite, c *ethclient.Client, sender int, receiver common.Address, value *big.Int) { senderAcc := s.network.Accounts()[sender].Address nonce, err := c.PendingNonceAt(context.Background(), senderAcc) if err != nil { log.Fatal(err) } gasLimit := uint64(6721975) // in units gasPrice := big.NewInt(3700000000) wallet, err := hdwallet.NewFromMnemonic(getMnemonic()) toAddress := receiver var data []byte tx := types.NewTransaction(nonce, toAddress, value, gasLimit, gasPrice, data) chainID, err := c.NetworkID(context.Background()) if err != nil { log.Fatal(err) } privateKey, err := wallet.PrivateKey(s.network.Accounts()[sender]) signedTx, err := types.SignTx(tx, types.NewEIP155Signer(chainID), privateKey) if err != nil { log.Fatal(err) } ts := types.Transactions{signedTx} rawTx := hex.EncodeToString(ts.GetRlp(0)) var trx *types.Transaction rawTxBytes, err := hex.DecodeString(rawTx) err = rlp.DecodeBytes(rawTxBytes, &amp;trx) err = c.SendTransaction(context.Background(), trx) if err != nil { log.Fatal(err) } }</code> </pre> <br><p>  Las siguientes dos funciones se utilizan para modificar una llamada de contrato: </p><br><pre> <code class="plaintext hljs">func ensureAuth(auth bind.TransactOpts) *bind.TransactOpts { return &amp;bind.TransactOpts{ auth.From, auth.Nonce, auth.Signer, auth.Value, auth.GasPrice, auth.GasLimit, auth.Context} } func changeAuth(s MarketSuite, account int) bind.TransactOpts { return *s.network.NewTransactor(s.network.Accounts()[account]) }</code> </pre> <br><h4 id="procedura-testirovaniya">  Procedimiento de prueba </h4><br><p>  Para una llamada, creamos un contractSessionActual para un contrato espec√≠fico.  Porque  el contrato tiene un propietario, podemos obtener su direcci√≥n y verificar si coincide con la cuenta predeterminada de Ganache cero.  Haremos esto de la siguiente manera (omitiremos el manejo de errores para ahorrar espacio): </p><br><pre> <code class="plaintext hljs">contractSession := contract.Session("Market") c.Assert(contractSession, NotNil) contractSessionActual, ok := contractSession.(*bindings.MarketSession) c.Assert(ok, Equals, true) c.Assert(contractSessionActual, NotNil) owner, _ := contractSessionActual.Owner() account0 := s.network.Accounts()[0] c.Assert(owner.Hex(), Equals, account0.Address.Hex()) //Owner account is account 0</code> </pre> <br><p>  La siguiente caracter√≠stica √∫til es cambiar la billetera que causa el contrato: </p><br><pre> <code class="plaintext hljs">ownerInd := 0 sender := 5 receiver := 6 senderAcc := s.network.Accounts()[sender].Address receiverAcc := s.network.Accounts()[receiver].Address //Call contract on behalf of its owner auth := changeAuth(*s, ownerInd) _, err = contractSessionActual.Contract.SetSenderReceiverPair(ensureAuth(auth), senderAcc, receiverAcc)</code> </pre> <br><p>  Porque  Una de las principales funciones utilizadas en las pruebas es cambiar el contrato de llamada, hagamos un pago en nombre del remitente: </p><br><pre> <code class="plaintext hljs">auth = changeAuth(*s, sender) //Change auth fo senderAcc to make a deposit on behalf of the sender client, _ := ethclient.Dial(getNetworkAddress()) //Let's check the current balance balance, _ := client.BalanceAt(context.Background(), contract.AddressOf("Market"), nil) c.Assert(balance.Int64(), Equals, big.NewInt(0).Int64()) //Balance should be 0 //Let's transfer 3 ETH to the contract on behalf of the sender value := big.NewInt(3000000000000000000) // in wei (3 eth) contractReceiver := contract.AddressOf("Market") sendETH(s, client, sender, contractReceiver, value) balance2, _ := client.BalanceAt(context.Background(), contract.AddressOf("Market"), nil) c.Assert(balance2.Int64(), Equals, value.Int64()) //Balance should be 3 ETH</code> </pre> <br><p>  El c√≥digo de prueba completo est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . </p><br><p>  Ahora abra stub_test.go y aseg√∫rese de que todas las importaciones apunten a su proyecto actual.  En nuestro caso, es: </p><br><pre> <code class="plaintext hljs">import ( _ "market/migrations" _ "market/tests" "testing" . "gopkg.in/check.v1" )</code> </pre> <br><p>  Ejecute las pruebas: </p><br><pre> <code class="plaintext hljs">$ perigord test</code> </pre> <br><p>  Si todo se hace correctamente, despu√©s del final de la prueba habr√° un resultado similar: </p><br><pre> <code class="plaintext hljs">Running migration 2 Running migration 3 OK: 1 passed PASS ok market 0.657s</code> </pre> <br><p>  Si tiene alg√∫n problema, descargue los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">archivos de</a> origen y repita los pasos descritos en esta gu√≠a. </p><br><h4 id="v-zaklyuchenie">  En conclusi√≥n </h4><br><p>  Perigord es una herramienta de prueba confiable escrita en su idioma favorito.  √âl crea la misma estructura de proyecto que Truffle, y tiene los mismos equipos, por lo que no tendr√° que volver a aprender.  La escritura est√°tica y una firma de funci√≥n inequ√≠voca le permiten desarrollar y realizar depuraci√≥n r√°pidamente, as√≠ como proteger significativamente contra errores tipogr√°ficos en los argumentos.  En Perigord, puede migrar f√°cilmente un proyecto existente a Truffle (todo lo que necesita hacer es copiar y pegar los archivos del contrato en la carpeta correspondiente y agregar pruebas), y tambi√©n comenzar un proyecto completamente nuevo con pruebas escritas en Go. </p><br><p>  Espero que el trabajo iniciado por el equipo de PolySwarm y continuado por Inn4Science sea √∫til para la comunidad Go y libere horas de pruebas y depuraci√≥n utilizando herramientas menos convenientes. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/445254/">https://habr.com/ru/post/445254/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../445242/index.html">Experiencia con Coroutines y Retrofit2</a></li>
<li><a href="../445244/index.html">"Los juegos de dinero fuera de la cadena de bloques deben morir"</a></li>
<li><a href="../445246/index.html">Los juegos que no son de Blockchain que involucran dinero deben morir</a></li>
<li><a href="../445248/index.html">¬øQuieres ser un poco m√°s feliz? Intenta ser el mejor en tu campo</a></li>
<li><a href="../445252/index.html">Los derechos digitales llegaron a Rusia</a></li>
<li><a href="../445256/index.html">Los ciberdelincuentes controlaron ASUS Live Update durante cinco meses</a></li>
<li><a href="../445258/index.html">C√≥mo eliminar de forma segura sus datos de su tel√©fono inteligente Android antes de venderlos</a></li>
<li><a href="../445260/index.html">¬øLos robots alguna vez se reconocer√°n realmente a s√≠ mismos? Los cient√≠ficos se est√°n moviendo en esta direcci√≥n.</a></li>
<li><a href="../445262/index.html">GeekUniversity abre reclutamiento en el departamento de an√°lisis de Big Data</a></li>
<li><a href="../445264/index.html">Precarga, captaci√≥n previa y otras etiquetas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>