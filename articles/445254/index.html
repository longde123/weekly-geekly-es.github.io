<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚵 🔕 🙌🏽 Prueba de contratos inteligentes de Ethereum en marcha: adiós, JavaScript 🧟 ☝️ 👎🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quiero agradecer a mis colegas: Sergey Nemesh, Mikhail Popsuyev, Evgeny Babich e Igor Titarenko por sus consultas, comentarios y pruebas. También quie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Prueba de contratos inteligentes de Ethereum en marcha: adiós, JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445254/"><p><img src="https://cdn-images-1.medium.com/max/1600/1*WNQyyGK2TrOy2m784kJang.jpeg" alt="imagen"><br>  <em>Quiero agradecer a mis colegas: Sergey Nemesh, Mikhail Popsuyev, Evgeny Babich e Igor Titarenko por sus consultas, comentarios y pruebas.</em>  <em>También quiero agradecer al equipo de PolySwarm por desarrollar la versión original de Perigord.</em> <em><br></em> <br>  <em>Esta es una traducción de mi primer artículo publicado en inglés <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">medio</a></em> </p><br><p>  Las pruebas siempre han sido una parte integral del desarrollo de software, aunque no la más agradable.  Cuando se trata de contratos inteligentes, se requieren pruebas rigurosas con atención excepcional al detalle, como  Los errores serán imposibles de corregir después de la implementación en la red blockchain.  En los últimos años, la comunidad Ethereum ha creado muchas herramientas para desarrollar contratos inteligentes.  Algunos de ellos no se hicieron populares, por ejemplo, Vyper, un dialecto de Python para escribir contratos inteligentes.  Otros, como Solidity, se han convertido en un estándar reconocido.  La documentación más extensa sobre la prueba de contratos inteligentes hasta la fecha proporciona un montón de Truffle &amp; Ganache.  Ambas herramientas tienen buena documentación, muchos casos ya se han decidido sobre Stack Overflow y recursos similares.  Sin embargo, este enfoque tiene un inconveniente importante: para escribir pruebas, debe usar Node.js. </p><a name="habracut"></a><br><h4 id="lovushki-javascript">  Trampas de JavaScript </h4><br><p>  Incluso si no eres un fanático de los lenguajes de programación con tipos estáticos y te encanta JavaScript, considera hacer un error tipográfico y comenzar a comparar el resultado de una función que devuelve una cadena con un valor booleano usando el método de desuso igual en lugar de estrictoEqual. </p><br><pre><code class="plaintext hljs">let proposalExists = await voting.checkProposal(); assert.equal(proposalExists, true, 'Proposal should exist');</code> </pre> <br><p>  Si checkProposal devuelve la cadena "yes" o "no", siempre los convertirá en true.  La escritura dinámica oculta muchas de estas trampas, e incluso los programadores experimentados pueden cometer tales errores cuando trabajan en un proyecto grande o en un equipo con otros desarrolladores que pueden realizar cambios en el código y no informarlo. </p><br><p>  La escritura estática de Go ayuda a prevenir tales errores.  Además, el uso del lenguaje Go en lugar de Node.js para las pruebas es el sueño de cualquier desarrollador de Go que comience a trabajar con contratos inteligentes. </p><br><p>  Mi equipo estaba desarrollando un sistema de inversión basado en contratos inteligentes con una arquitectura muy compleja.  El sistema de contrato inteligente contenía más de 2,000 líneas de código.  Como la mayor parte del equipo eran desarrolladores de Go, las pruebas en Go eran preferibles a Node.js. </p><br><h4 id="pervaya-sreda-dlya-testirovaniya-smart-kontraktov-na-go">  El primer entorno para probar contratos inteligentes en Go </h4><br><p>  En 2017, PolySwarm desarrolló <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Perigord</a> , una herramienta similar a Truffle, usando Go en lugar de JavaScript.  Desafortunadamente, este proyecto ya no es compatible, solo tiene un tutorial con ejemplos muy simples.  Además, no admite la integración con Ganache (una cadena de bloques privada para desarrollar Ethereum con una GUI muy conveniente).  Mejoramos Perigord eliminando errores e introduciendo dos nuevas funciones: generar billeteras a partir del código mnemónico y usarlas para probar y conectarse a la cadena de bloques de Ganache.  Puedes leer el código fuente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . </p><br><p>  El tutorial original de Perigord contiene solo el ejemplo más simple de invocar un contrato para cambiar un solo valor.  Sin embargo, en el mundo real, también deberá llamar a un contrato desde diferentes billeteras, enviar y recibir Ether, etc.  Ahora puedes hacer todo esto usando el Perigord avanzado y el viejo Ganache.  A continuación encontrará una guía detallada sobre el desarrollo y prueba de contratos inteligentes con Perigord &amp; Ganache. </p><br><h4 id="ispolzovanie-uluchshennogo-perigord-polnoe-rukovodstvo">  Uso de Perigord avanzado: una guía completa </h4><br><p>  Para usar Perigord necesita instalar Go 1.7+, solc, abigen y Ganache.  Consulte la documentación de su sistema operativo. </p><br><p>  Instale Perigord de la siguiente manera: </p><br><pre> <code class="plaintext hljs">$ go get gitlab.com/go-truffle/enhanced-perigord $ go build</code> </pre> <br><p>  Después de eso, puedes usar el comando perigord: </p><br><pre> <code class="plaintext hljs">$ perigord A golang development environment for Ethereum Usage: perigord [command] Available Commands: add Add a new contract or test to the project build (alias for compile) compile Compile contract source files deploy (alias for migrate) generate (alias for compile) help Help about any command init Initialize new Ethereum project with example contracts and tests migrate Run migrations to deploy contracts test Run go and solidity tests Flags: -h, --help help for perigord Use "perigord [command] --help" for more information about a command.</code> </pre> <br><p>  Ahora crearemos un contrato simple de mercado inteligente para demostrar las opciones de prueba disponibles. </p><br><p>  Para comenzar un proyecto, ingrese lo siguiente en la terminal: </p><br><pre> <code class="plaintext hljs">$ perigord init market</code> </pre> <br><p>  El proyecto aparecerá en la carpeta src / en GOPATH.  Mueva el proyecto a otra carpeta y actualice las rutas de importación si desea cambiar su ubicación.  Veamos qué hay en el mercado / carpeta. </p><br><pre> <code class="plaintext hljs">$ tree . ├── contracts │ └── Foo.sol ├── generate.go ├── main.go ├── migrations │ └── 1_Migrations.go ├── perigord.yaml ├── stub │ ├── README.md │ └── main.go ├── stub_test.go └── tests └── Foo.go</code> </pre> <br><p>  Muy similar al proyecto creado en Truffle, ¿no?  Pero todo está en marcha!  Veamos qué hay en el archivo de configuración perigord.yaml. </p><br><pre> <code class="plaintext hljs">networks: dev: url: /tmp/geth_private_testnet/geth.ipc keystore: /tmp/geth_private_testnet/keystore passphrase: blah mnemonic: candy maple cake sugar pudding cream honey rich smooth crumble sweet treat num_accounts: 10</code> </pre> <br><p>  Para las pruebas, puede usar tanto la red geth privada como los archivos de billetera y conectarse a Ganache.  Estas opciones son mutuamente excluyentes.  Tomamos la mnemotecnia predeterminada, generamos 10 cuentas y nos conectamos a Ganache.  Reemplace el código en perigord.yaml con: </p><br><pre> <code class="plaintext hljs">networks: dev: url: HTTP://127.0.0.1:7545 mnemonic: candy maple cake sugar pudding cream honey rich smooth crumble sweet treat num_accounts: 10</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HTTP http://127.0.0.1:7545</a> : la dirección estándar del servidor Ganache RPC.  Tenga en cuenta que puede crear cualquier número de cuentas para pruebas, pero solo las cuentas generadas en Ganache (GUI) contendrán fondos. </p><br><p>  Crearemos un contrato llamado Market.sol.  Puede mantener un registro de pares de direcciones, una de las cuales envía fondos a la cuenta del contrato, y la otra tiene derecho a recibir fondos cuando el propietario del contrato autoriza dicha transacción.  Por ejemplo, dos participantes no confían el uno en el otro, sino que confían en el propietario del contrato, que decide si se cumple una determinada condición.  El ejemplo implementa varias funciones básicas para fines de demostración. </p><br><p>  Agregar un contacto al proyecto: </p><br><pre> <code class="plaintext hljs">$ perigord add contract Market</code> </pre> <br><p>  El postfix .sol se agregará automáticamente.  También puede agregar otros contratos o eliminar el contrato de muestra Foo.sol.  Mientras trabaja en GOPATH, puede usar contratos de importación para crear estructuras complejas.  Tendremos tres archivos de Solidity: el contrato principal de Market, los contratos auxiliares Ownable and Migrations y la biblioteca SafeMath.  Puedes encontrar el código fuente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . </p><br><p>  Ahora el proyecto tiene la siguiente estructura: </p><br><pre> <code class="plaintext hljs">. ├── contracts │ ├── Market.sol │ ├── Ownable.sol │ └── SafeMath.sol ├── generate.go ├── main.go ├── migrations │ └── 1_Migrations.go ├── perigord.yaml ├── stub │ ├── README.md │ └── main.go ├── stub_test.go └── tests └── Foo.go</code> </pre> <br><p>  Genere bytecode EVM, enlaces ABI y Go: </p><br><pre> <code class="plaintext hljs">$ perigord build</code> </pre> <br><p>  Agregue las migraciones de todos los contratos que implementará.  Porque  solo implementamos Market.sol, solo necesitamos una nueva migración: </p><br><pre> <code class="plaintext hljs">$ perigord add migration Market</code> </pre> <br><p>  Nuestro contrato no contiene un constructor que acepte parámetros.  Si necesita pasar parámetros al constructor, agréguelos a la función Deploy {NewContract} en el archivo de migración: </p><br><pre> <code class="plaintext hljs">address, transaction, contract, err := bindings.Deploy{NewContract}(auth, network.Client(), “FOO”, “BAR”)</code> </pre> <br><p>  Elimine el archivo de muestra Foo.go y agregue un archivo de prueba para nuestro contrato: </p><br><pre> <code class="plaintext hljs">$ perigord add test Market</code> </pre> <br><p>  Para usar billeteras deterministas, necesitamos leer los mnemónicos del archivo de configuración: </p><br><pre> <code class="plaintext hljs">func getMnemonic() string { viper.SetConfigFile("perigord.yaml") if err := viper.ReadInConfig(); err != nil { log.Fatal() } mnemonic := viper.GetStringMapString("networks.dev")["mnemonic"] return mnemonic }</code> </pre> <br><p>  La siguiente función auxiliar se utiliza para obtener la dirección de red: </p><br><pre> <code class="plaintext hljs">func getNetworkAddress() string { viper.SetConfigFile("perigord.yaml") if err := viper.ReadInConfig(); err != nil { log.Fatal() } networkAddr := viper.GetStringMapString("networks.dev")["url"] return networkAddr }</code> </pre> <br><p>  Otra función auxiliar que necesitaremos es sendETH, la usaremos para transferir Ether desde una de las billeteras generadas (indicadas por el índice) a cualquier dirección de Ethereum: </p><br><pre> <code class="plaintext hljs">func sendETH(s *MarketSuite, c *ethclient.Client, sender int, receiver common.Address, value *big.Int) { senderAcc := s.network.Accounts()[sender].Address nonce, err := c.PendingNonceAt(context.Background(), senderAcc) if err != nil { log.Fatal(err) } gasLimit := uint64(6721975) // in units gasPrice := big.NewInt(3700000000) wallet, err := hdwallet.NewFromMnemonic(getMnemonic()) toAddress := receiver var data []byte tx := types.NewTransaction(nonce, toAddress, value, gasLimit, gasPrice, data) chainID, err := c.NetworkID(context.Background()) if err != nil { log.Fatal(err) } privateKey, err := wallet.PrivateKey(s.network.Accounts()[sender]) signedTx, err := types.SignTx(tx, types.NewEIP155Signer(chainID), privateKey) if err != nil { log.Fatal(err) } ts := types.Transactions{signedTx} rawTx := hex.EncodeToString(ts.GetRlp(0)) var trx *types.Transaction rawTxBytes, err := hex.DecodeString(rawTx) err = rlp.DecodeBytes(rawTxBytes, &amp;trx) err = c.SendTransaction(context.Background(), trx) if err != nil { log.Fatal(err) } }</code> </pre> <br><p>  Las siguientes dos funciones se utilizan para modificar una llamada de contrato: </p><br><pre> <code class="plaintext hljs">func ensureAuth(auth bind.TransactOpts) *bind.TransactOpts { return &amp;bind.TransactOpts{ auth.From, auth.Nonce, auth.Signer, auth.Value, auth.GasPrice, auth.GasLimit, auth.Context} } func changeAuth(s MarketSuite, account int) bind.TransactOpts { return *s.network.NewTransactor(s.network.Accounts()[account]) }</code> </pre> <br><h4 id="procedura-testirovaniya">  Procedimiento de prueba </h4><br><p>  Para una llamada, creamos un contractSessionActual para un contrato específico.  Porque  el contrato tiene un propietario, podemos obtener su dirección y verificar si coincide con la cuenta predeterminada de Ganache cero.  Haremos esto de la siguiente manera (omitiremos el manejo de errores para ahorrar espacio): </p><br><pre> <code class="plaintext hljs">contractSession := contract.Session("Market") c.Assert(contractSession, NotNil) contractSessionActual, ok := contractSession.(*bindings.MarketSession) c.Assert(ok, Equals, true) c.Assert(contractSessionActual, NotNil) owner, _ := contractSessionActual.Owner() account0 := s.network.Accounts()[0] c.Assert(owner.Hex(), Equals, account0.Address.Hex()) //Owner account is account 0</code> </pre> <br><p>  La siguiente característica útil es cambiar la billetera que causa el contrato: </p><br><pre> <code class="plaintext hljs">ownerInd := 0 sender := 5 receiver := 6 senderAcc := s.network.Accounts()[sender].Address receiverAcc := s.network.Accounts()[receiver].Address //Call contract on behalf of its owner auth := changeAuth(*s, ownerInd) _, err = contractSessionActual.Contract.SetSenderReceiverPair(ensureAuth(auth), senderAcc, receiverAcc)</code> </pre> <br><p>  Porque  Una de las principales funciones utilizadas en las pruebas es cambiar el contrato de llamada, hagamos un pago en nombre del remitente: </p><br><pre> <code class="plaintext hljs">auth = changeAuth(*s, sender) //Change auth fo senderAcc to make a deposit on behalf of the sender client, _ := ethclient.Dial(getNetworkAddress()) //Let's check the current balance balance, _ := client.BalanceAt(context.Background(), contract.AddressOf("Market"), nil) c.Assert(balance.Int64(), Equals, big.NewInt(0).Int64()) //Balance should be 0 //Let's transfer 3 ETH to the contract on behalf of the sender value := big.NewInt(3000000000000000000) // in wei (3 eth) contractReceiver := contract.AddressOf("Market") sendETH(s, client, sender, contractReceiver, value) balance2, _ := client.BalanceAt(context.Background(), contract.AddressOf("Market"), nil) c.Assert(balance2.Int64(), Equals, value.Int64()) //Balance should be 3 ETH</code> </pre> <br><p>  El código de prueba completo está <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . </p><br><p>  Ahora abra stub_test.go y asegúrese de que todas las importaciones apunten a su proyecto actual.  En nuestro caso, es: </p><br><pre> <code class="plaintext hljs">import ( _ "market/migrations" _ "market/tests" "testing" . "gopkg.in/check.v1" )</code> </pre> <br><p>  Ejecute las pruebas: </p><br><pre> <code class="plaintext hljs">$ perigord test</code> </pre> <br><p>  Si todo se hace correctamente, después del final de la prueba habrá un resultado similar: </p><br><pre> <code class="plaintext hljs">Running migration 2 Running migration 3 OK: 1 passed PASS ok market 0.657s</code> </pre> <br><p>  Si tiene algún problema, descargue los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">archivos de</a> origen y repita los pasos descritos en esta guía. </p><br><h4 id="v-zaklyuchenie">  En conclusión </h4><br><p>  Perigord es una herramienta de prueba confiable escrita en su idioma favorito.  Él crea la misma estructura de proyecto que Truffle, y tiene los mismos equipos, por lo que no tendrá que volver a aprender.  La escritura estática y una firma de función inequívoca le permiten desarrollar y realizar depuración rápidamente, así como proteger significativamente contra errores tipográficos en los argumentos.  En Perigord, puede migrar fácilmente un proyecto existente a Truffle (todo lo que necesita hacer es copiar y pegar los archivos del contrato en la carpeta correspondiente y agregar pruebas), y también comenzar un proyecto completamente nuevo con pruebas escritas en Go. </p><br><p>  Espero que el trabajo iniciado por el equipo de PolySwarm y continuado por Inn4Science sea útil para la comunidad Go y libere horas de pruebas y depuración utilizando herramientas menos convenientes. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/445254/">https://habr.com/ru/post/445254/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../445242/index.html">Experiencia con Coroutines y Retrofit2</a></li>
<li><a href="../445244/index.html">"Los juegos de dinero fuera de la cadena de bloques deben morir"</a></li>
<li><a href="../445246/index.html">Los juegos que no son de Blockchain que involucran dinero deben morir</a></li>
<li><a href="../445248/index.html">¿Quieres ser un poco más feliz? Intenta ser el mejor en tu campo</a></li>
<li><a href="../445252/index.html">Los derechos digitales llegaron a Rusia</a></li>
<li><a href="../445256/index.html">Los ciberdelincuentes controlaron ASUS Live Update durante cinco meses</a></li>
<li><a href="../445258/index.html">Cómo eliminar de forma segura sus datos de su teléfono inteligente Android antes de venderlos</a></li>
<li><a href="../445260/index.html">¿Los robots alguna vez se reconocerán realmente a sí mismos? Los científicos se están moviendo en esta dirección.</a></li>
<li><a href="../445262/index.html">GeekUniversity abre reclutamiento en el departamento de análisis de Big Data</a></li>
<li><a href="../445264/index.html">Precarga, captación previa y otras etiquetas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>