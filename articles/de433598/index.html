<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üó∫Ô∏è üöø ‚ùóÔ∏è Wie LLVM die Funktion optimiert üí´ üîñ üôãüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der optimierende AOT-Compiler ist normalerweise folgenderma√üen aufgebaut: 



1. Frontend-Konvertierung von Quellcode in Zwischendarstellung 
2. Masch...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie LLVM die Funktion optimiert</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433598/">  Der optimierende AOT-Compiler ist normalerweise folgenderma√üen aufgebaut: <br><br><ol><li>  Frontend-Konvertierung von Quellcode in Zwischendarstellung </li><li>  Maschinenunabh√§ngige Optimierungspipeline (IR): Eine Folge von Durchl√§ufen, die IR neu schreiben, um ineffiziente Abschnitte und Strukturen zu eliminieren, die nicht direkt in Maschinencode konvertiert werden k√∂nnen.  Manchmal wird dieser Teil als mittleres Ende bezeichnet. </li><li>  Maschinenabh√§ngiges Backend zum Generieren von Baugruppencode oder Maschinencode. </li></ol><br><img src="https://habrastorage.org/webt/dx/1k/k8/dx1kk8oxixxudiub62ffatlrpzq.jpeg"><br><br>  Bei einigen Compilern bleibt das IR-Format w√§hrend des gesamten Optimierungsprozesses unver√§ndert, bei anderen √§ndert sich das Format oder die Semantik.  In LLVM sind Format und Semantik festgelegt. Daher k√∂nnen Durchl√§ufe in beliebiger Reihenfolge ausgef√ºhrt werden, ohne dass das Risiko einer fehlerhaften Kompilierung oder eines Absturzes des Compilers besteht. <br><a name="habracut"></a><br>  Die Reihenfolge der Optimierungsdurchl√§ufe wurde von den Compiler-Entwicklern entwickelt, mit dem Ziel, die Arbeit in einer akzeptablen Zeit abzuschlie√üen.  Es √§ndert sich von Zeit zu Zeit, und nat√ºrlich gibt es verschiedene Durchg√§nge, die auf verschiedenen Optimierungsstufen ausgef√ºhrt werden k√∂nnen.  Eines der langfristigen Themen in der Computerforschung ist die Verwendung von maschinellem Lernen oder anderen Methoden, um die beste Optimierungspipeline f√ºr den allgemeinen Gebrauch und f√ºr bestimmte Anwendungen zu finden, f√ºr die die Standardpipeline nicht sehr geeignet ist. <br><br>  Die Prinzipien beim Entwerfen der Passagen sind Minimalismus und Orthogonalit√§t: Jeder Pass sollte eine Sache gut machen und ihre Funktionalit√§t sollte sich nicht √ºberschneiden.  In der Praxis sind manchmal Kompromisse m√∂glich.  In der Praxis k√∂nnen zwei Durchg√§nge, die Arbeit f√ºr einander erzeugen, zu einem gr√∂√üeren Durchgang kombiniert werden.  Einige Funktionen auf IR-Ebene, wie z. B. das Falten konstanter Operatoren, sind so n√ºtzlich, dass es keinen Sinn macht, sie in einen separaten Durchgang zu setzen. LLVM minimiert standardm√§√üig konstante Operationen, wenn eine Anweisung erstellt wird. <br><br>  In diesem Beitrag werden wir sehen, wie einige LLVM-Optimierungsdurchl√§ufe funktionieren.  Ich meine, Sie lesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen Teil</a> dar√ºber, wie Clang eine Funktion kompiliert, oder Sie verstehen mehr oder weniger, wie LLVM IR funktioniert.  Das Verst√§ndnis des SSA-Formulars (Static Single Assignment) ist besonders hilfreich: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia</a> gibt Ihnen eine Einf√ºhrung, und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses Buch enth√§lt</a> mehr Informationen, als Sie gerne wissen w√ºrden.  Lesen Sie auch die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LLVM-Sprachreferenz</a> und eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Liste der Optimierungsdurchl√§ufe</a> . <br><br>  Mal sehen, wie Clang / LLVM 6.0.1 diesen C ++ - Code optimiert: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_sorted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n - <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a[i] &gt; a[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Gleichzeitig erinnern wir uns, dass die Optimierungspipeline sehr belebt ist und wir viele lustige Momente verpassen werden, wie zum Beispiel: <br><br>  Inlining ist eine einfache, aber sehr wichtige Optimierung, die in diesem Beispiel nicht auftritt, weil  Wir betrachten nur eine Funktion.  Fast alle Optimierungen sind spezifisch f√ºr C ++, jedoch nicht f√ºr C. Automatische Vektorisierung, die ein vorzeitiges Verlassen der Schleife verhindert <br><br>  Im folgenden Text √ºberspringe ich alle Durchg√§nge, die keine √Ñnderungen am Code vornehmen.  Wir werden auch nicht in das Backend schauen, das auch viel Arbeit leistet.  Aber auch die restlichen Passagen sind viel!  (Entschuldigen Sie die Bilder, aber dies scheint der beste Weg zu sein, um Formatierungsschwierigkeiten zu vermeiden.) <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist die</a> von Clang erstellte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IR-Datei</a> (ich habe das von Clang eingef√ºgte Attribut "optnone" manuell gel√∂scht) und die Befehlszeile, mit der die Auswirkungen jedes Optimierungsdurchlaufs angezeigt werden: <br><br><pre> <code class="bash hljs">opt -O2 -<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>-before-all -<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>-after-all is_sorted2.ll</code> </pre> <br>  Der erste Durchgang ist die <a href="">CFG-Vereinfachung</a> (Kontrollflussdiagramm).  Da Clang keine Optimierung durchf√ºhrt, enth√§lt die von ihm erzeugte IR einfache Optimierungsoptionen: <br><br><img src="https://habrastorage.org/webt/kn/xb/ow/knxbowtdwkjlcjaogvmo7rlzdtu.png"><br><br>  Hier bewegt sich die Basiseinheit 26 einfach zu Block 27. Solche Bl√∂cke k√∂nnen gel√∂scht werden, indem Verweise durch den Zielblock auf sie umgeleitet werden.  LLVM nummeriert Bl√∂cke automatisch neu.  Die vollst√§ndige Liste der von SimplifyCFG erstellten Conversions befindet sich oben im Gang. <br><br> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> <ul><li> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> </li> <li> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> </li> <li> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> </li> <li> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> </li> <li> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> </li> <li> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> </li> </ul> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> <br>  Die meisten M√∂glichkeiten zur CFG-Optimierung ergeben sich aus der Arbeit anderer LLVM-P√§sse.  Zum Beispiel kann das L√∂schen der Eliminierung von totem Code und das Verschieben von Schleifeninvarianten leicht zu leeren Basisbl√∂cken f√ºhren. <br><br>  Die n√§chste Passage, <a href="">SROA</a> (skalarer Ersatz von Aggregaten), ist eine der am h√§ufigsten verwendeten.  Sein Name f√ºhrt zu Verwirrung, da SROA nur eine seiner Funktionen ist.  Der Durchlauf √ºberpr√ºft jeden Zuordnungsbefehl (Speicherzuordnung auf dem Funktionsstapel) und versucht, ihn in SSA-Register umzuwandeln.  Ein Allokationsbefehl (dh <i>eine Variable auf dem Stapel von</i> ca. Transl ..) wird in viele Register umgewandelt, wenn er mehrmals statisch zugewiesen wird, und wenn Allokation eine Klasse oder Struktur ist, wird er in Komponenten unterteilt (dies wird als "Skalar" bezeichnet). Ersatz ‚Äúim Namen der Passage).  Eine einfache Version von SROA w√ºrde sich Stapelvariablen ergeben, f√ºr die die Operation zum Nehmen einer Adresse verwendet wird, aber die LLVM-Version interagiert mit einem Alias-Analysealgorithmus und handelt auf intelligente Weise (obwohl dies im folgenden Beispiel nicht erforderlich ist). <br><br><img src="https://habrastorage.org/webt/d9/qp/tt/d9qpttybpemz-gxsqew6orkzlj8.png"><br><br>  Nach SROA verschwinden die Allokationsanweisungen (und die entsprechenden Lade- und Speicheranweisungen), und der Code wird sauberer und eignet sich besser f√ºr nachfolgende Optimierungen (nat√ºrlich kann SROA im allgemeinen Fall nicht alle Allokationen l√∂schen, dies geschieht nur, wenn die Zeigeranalyse dies kann Aliase vollst√§ndig loswerden).  Dabei f√ºgt SROA Phi-Anweisungen in den Code ein.  Die Phi-Anweisungen bilden den Kern der SSA-Darstellung, und das Fehlen von Phi im von Clang generierten Code zeigt, dass Clang eine triviale Version von SSA generiert, bei der die Basisbl√∂cke √ºber den Speicher und nicht √ºber SSA-Register verbunden sind. <br><br>  Was folgt, ist " <a href="">Early Common Subexpression Elimination</a> ", CSE (Early Removal of Common Subexpressions).  CSE versucht, F√§lle √ºberm√§√üiger Unterausdr√ºcke zu beseitigen, die sowohl in von Menschen geschriebenem Code als auch in teilweise optimiertem Code auftreten k√∂nnen.  "Early CSE" ist eine schnelle und einfache Version von CSE, die triviale redundante Berechnungen identifiziert. <br><br><img src="https://habrastorage.org/webt/zv/bk/ud/zvbkudo1n9njnkertwvr_agrkrq.png"><br><br>  Hier machen% 10 und% 17 dasselbe, dh der Code kann neu geschrieben werden, sodass ein Wert verwendet und der zweite gel√∂scht wird.  Dies gibt einen Einblick in die Vorteile von SSA: Wenn jedes Register nur einmal zugewiesen wird, gibt es nicht mehrere Versionen eines einzelnen Registers.  Somit k√∂nnen redundante Berechnungen unter Verwendung syntaktischer √Ñquivalenz erkannt werden, ohne eine eingehende Analyse des Programms zu verwenden (dies ist nicht der Fall f√ºr Speicherorte, die au√üerhalb der SSA-Welt existieren). <br><br>  Als n√§chstes werden mehrere Durchg√§nge gestartet, die in unserem Fall keine Auswirkung haben, und dann wird der " <a href="">Global Variable Optimizer</a> " gestartet, der wie folgt beschrieben wird: <br><br> <code>     ,      .   ,        ,  ,     ,  ..</code> <br> <br>  Diese Passage nimmt folgende √Ñnderungen vor: <br><br><img src="https://habrastorage.org/webt/pz/nd/nm/pzndnmja1jgtbkw9acxrenagtku.png"><br><br>  Er f√ºgte ein Funktionsattribut hinzu: Metadaten, die von einem Teil des Compilers verwendet werden, um Informationen dar√ºber zu speichern, was f√ºr einen anderen Teil des Compilers n√ºtzlich sein k√∂nnte.  √úber den Zweck dieses Attributs k√∂nnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> lesen. <br><br>  Im Gegensatz zu anderen Optimierungen, die wir in Betracht gezogen haben, ist der Optimierer globaler Variablen interprocedural und bezieht sich ausschlie√ülich auf das LLVM-Modul.  Ein Modul entspricht (mehr oder weniger) einer Kompilierungseinheit in C und C ++.  Im Gegensatz zur interproceduralen Optimierung sieht intraprocedural jeweils nur eine Funktion. <br><br>  Die n√§chste Passage kombiniert Anweisungen und hei√üt ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anweisungskombinierer</a> ‚Äú, InstCombine.  Dies ist eine gro√üe und vielf√§ltige Sammlung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gucklochoptimierungen</a> , die (normalerweise) einige Anweisungen, kombiniert mit gemeinsamen Daten, in einer effizienteren Form umschreiben.  InstCombine √§ndert den Kontrollfluss einer Funktion nicht.  Im obigen Beispiel hat er nicht viel ge√§ndert: <br><br><img src="https://habrastorage.org/webt/ma/z2/ky/maz2ky8g_cis8kasz94_rlhzck4.png"><br><br>  Anstatt 1 von% 1 zu subtrahieren, addieren wir hier -1, um% 4 zu berechnen.  Dies ist keine Optimierung, sondern eine Kanonisierung.  Wenn es viele M√∂glichkeiten gibt, die Berechnung durchzuf√ºhren, versucht LLVM, sie in die kanonische (oft zuf√§llig ausgew√§hlte) Form zu bringen, die nachfolgende Durchl√§ufe und Backends erwarten.  Die zweite √Ñnderung, die InstCombine vorgenommen hat, ist die kanonische Form von zwei vorzeichenbehafteten Erweiterungsoperationen (der Sext-Anweisung), die% 7 und% 11 berechnen, die in eine Null-Erweiterung (zext) konvertiert wurden.  Diese Konvertierung ist sicher, wenn der Compiler nachweisen kann, dass der Sext-Operand nicht negativ ist.  In diesem Fall liegt dies daran, dass sich die Schleifenvariable von 0 auf n √§ndert (wenn n negativ ist, wird die Schleife √ºberhaupt nicht ausgef√ºhrt).  Die letzte √Ñnderung war das Hinzuf√ºgen des Flags "nuw" (kein vorzeichenloser Wrap) zu der Anweisung, die% 10 berechnet.  Wir k√∂nnen sehen, dass es sicher ist, dass (1) die Schleifenvariable immer zunimmt und (2) wenn die Variable bei Null beginnt und zunimmt, sie undefiniert wird, wenn das Vorzeichen an der Kreuzung INT_MAX ge√§ndert wird, bevor sie einen vorzeichenlosen √úberlauf erreicht. folgenden UINT_MAX.  Dieses Flag kann f√ºr nachfolgende Optimierungen verwendet werden. <br><br>  Als n√§chstes startet SimplifyCFG ein zweites Mal und entfernt zwei leere Basisbl√∂cke: <br><br><img src="https://habrastorage.org/webt/oa/jj/om/oajjom0adr5es0yccpze9nnkyzs.png"><br><br>  Anschlie√üend kommentiert der Pass "Funktionsattribute ableiten" die Funktion: <br><br><img src="https://habrastorage.org/webt/vj/s4/dm/vjs4dmr1paqb3s0yabk6ev-ycfq.png"><br><br>  "Norecurse" bedeutet, dass die Funktion nicht in rekursiven Aufrufen enthalten ist. "Readonly" bedeutet, dass die Funktion den globalen Status nicht √§ndert.  Das Parameterattribut "nocapture" bedeutet, dass der Parameter nach dem Beenden der Funktion nirgendwo gespeichert wird, und "readonly" bedeutet, dass der Speicher von der Funktion nicht ge√§ndert wird.  Sie sehen eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Liste von Funktionsattributen</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Parameterattributen</a> . <br><br>  Dann verschiebt der Durchlauf " <a href="">Schleifen drehen</a> " den Code, um die Bedingungen f√ºr nachfolgende Optimierungen zu verbessern: <br><br><img src="https://habrastorage.org/webt/fd/qm/eg/fdqmegxzophmowskfsd-wpwjkmi.png"><br><br>  Obwohl der Unterschied einsch√ºchternd aussieht, sind die √Ñnderungen tats√§chlich gering.  Wir k√∂nnen besser lesbar sehen, was passiert ist, wenn wir LLVM bitten, vor und nach den Rotationszyklen einen Kontroll√ºbertragungsgraphen zu zeichnen.  Hier ist ihre Ansicht vor (links) und nach (rechts): <br><br><img src="https://habrastorage.org/webt/ab/wb/8p/abwb8pofuvyvzu13vn278retos8.png"><br><br>  Der urspr√ºngliche Code folgt weiterhin der von Clang generierten Schleifenstruktur: <br><br><pre> <code class="cpp hljs">initializer <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> COND COND: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> BODY <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> EXIT BODY: body modifier <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> COND EXIT:</code> </pre> <br>  Nach dem Lauf sieht die Schleife folgenderma√üen aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">initializer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(condition)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">goto</span></span></span><span class="hljs-function"> BODY </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">else</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">goto</span></span></span><span class="hljs-function"> EXIT BODY: body modifier </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(condition)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">goto</span></span></span><span class="hljs-function"> BODY </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">else</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">goto</span></span></span><span class="hljs-function"> EXIT EXIT:</span></span></code> </pre> <br>  (Von Johannes Durfert vorgeschlagene Korrekturen sind unten aufgef√ºhrt - danke!) <br><br>  Der Zweck des Schleifendrehungsdurchlaufs besteht darin, einen Zweig zu entfernen, was weitere Optimierungen erm√∂glicht.  Ich habe im Internet keine bessere Beschreibung dieser Konvertierung gefunden. <br><br>  Der CFG-Vereinfachungsdurchlauf minimiert zwei Basisbl√∂cke, die nur entartete Phi-Anweisungen (mit einem Eingang) enthalten: <br><br><img src="https://habrastorage.org/webt/vi/rp/tv/virptvmlal7fxobwfsagegvh9sa.png"><br><br>  Der Befehlskombinierer-Durchgang verwandelt "% 4 = 0 s &lt;(% 1 - 1)" in "% 4 =% 1 s&gt; 1" (wobei s &lt;und s&gt; Operationen zum Vergleichen von vorzeichenbehafteten Operanden sind) Eine n√ºtzliche Transformation, die die L√§nge von Abh√§ngigkeitsketten verringert und auch tote (unerreichbare) Anweisungen erstellen kann (siehe den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Patch</a> , der dies tut).  Dieser Durchgang entfernt auch die trivialen Phi-Anweisungen, die durch den Schleifenrotationsdurchlauf hinzugef√ºgt wurden. <br><br><img src="https://habrastorage.org/webt/5j/ds/vd/5jdsvdbgbxm2ycakdby1q9t9stm.png"><br><br>  Das Folgende ist die Passage ‚Äû <a href="">Kanonisieren nat√ºrlicher Schleifen</a> ‚Äú, die in ihrem eigenen Quellcode wie folgt beschrieben wird: <br><br> <code>          ,          . <br> <br>     (Loop pre-header) ,   ,      .      ,,  LICM. <br> <br>       ,   ,     (      )        (      ).   , ,  "store-sinking",   LICM. <br> <br>   ,               (backedge). <br> <br>  Indirectbr   .            ,      .    ,    ,     . <br> <br> ,   simplifycfg  ,   ,      ,         . <br> <br>  , ,  CFG,       . <br></code> <br><br>  Hier sehen wir, dass der Ausgabeblock eingef√ºgt wurde: <br><br><img src="https://habrastorage.org/webt/k_/qb/v0/k_qbv0es1zxpy7-uprkg-qc0l5y.png"><br><br>  Dann folgt die " <a href="">Vereinfachung der Schleifenvariablen</a> ": <br><br> <code>       ( ,    ),    ,      . <br> <br>     ,     : <br> <br>       ,        . ,  'for (i = 7; i*i &lt; 1000; ++i)'   'for (i = 0; i != 25; ++i)'. <br> <br>          indvar        ,       .           ,     "". <br></code> <br>  Der Effekt dieses Durchlaufs besteht darin, die 32-Bit-Schleifenvariable in 64-Bit zu √§ndern: <br><br><img src="https://habrastorage.org/webt/e9/o2/ta/e9o2tabc6zwddljjzvfqxevmnlm.png"><br><br>  Ich wei√ü nicht, warum zext - zuvor von sext in die kanonische Form gegossen, wieder zu sext zur√ºckgekehrt. <br><br>  Jetzt f√ºhrt der Durchgang " <a href="">Globale Wertnummerierung</a> " eine sehr intelligente Optimierung durch.  Einer der Gr√ºnde f√ºr das Schreiben dieses Beitrags ist der Wunsch, ihn zu zeigen.  Kannst du sie hier sehen? <br><br><img src="https://habrastorage.org/webt/xz/w9/qz/xzw9qzzlspziaetqokxpkgeajz4.png"><br><br>  Hast du gesehen  Ja, zwei Ladeanweisungen in der Schleife links, die einem [i] und einem [i + 1] entsprechen.  Hier stellte die GVN fest, dass ein [i] zum Laden nicht ben√∂tigt wurde, da ein [i + 1] von einer Iteration der Schleife wie ein [i] zur n√§chsten √ºbertragen werden konnte.  Dieser einfache Trick reduziert die Anzahl der von der Funktion durchgef√ºhrten Speicherlesevorg√§nge um die H√§lfte.  Sowohl LLVM als auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GCC</a> haben erst k√ºrzlich gelernt, diese Transformation durchzuf√ºhren. <br><br>  Sie k√∂nnten sich fragen, ob dieser Trick funktioniert, wenn wir ein [i] mit einem [i + 2] vergleichen.  Es stellt sich heraus, dass nein, aber GCC kann f√ºr solche F√§lle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bis zu vier Register</a> zuweisen. <br><br>  Dann beginnt der Durchgang " <a href="">Bit-Tracking Dead Code Elimination</a> ": <br><br> <code>    "Bit-Tracking Dead Code Elimination".   (,   ""  ""  ..) ""   .        ,    "" .</code> <br> <br>  Hier stellt sich jedoch heraus, dass solche Tricks nicht ben√∂tigt werden, da der einzige tote Code der Befehl GEP (get element pointer) ist und er trivial tot ist (der GVN-Durchgang hat den Ladebefehl gel√∂scht, der die von diesem Befehl berechnete Adresse verwendet hat): <br><br><img src="https://habrastorage.org/webt/wc/ya/kp/wcyakpozeya4ntmpbtgj8e49h0u.png"><br><br>  Jetzt hat der Algorithmus zum Kombinieren von Anweisungen add in eine andere Basiseinheit eingef√ºgt.  Die Logik, mit der diese Transformation in InstCombine platziert wurde, ist mir nicht klar, vielleicht gab es keinen offensichtlichen Ort, an dem sie platziert werden konnte: <br><br><img src="https://habrastorage.org/webt/wl/5a/lf/wl5alf_cvrnvgdjtmrmeiqddvno.png"><br><br>  Jetzt passiert etwas Seltsameres: Der " <a href="">Jump Threading</a> " -Pass hat gel√∂scht, was der "Canonicalize Natural Loops" -Pass zuvor getan hat: <br><br><img src="https://habrastorage.org/webt/8l/qo/wj/8lqowjsprlzfgnu9w_kilkckbvc.png"><br><br>  Dann werfen wir wieder auf die kanonische Form: <br><br><img src="https://habrastorage.org/webt/-c/ax/ev/-caxev-fsfgtsrr10dhwmwizuzg.png"><br><br>  Und die CFG-Vereinfachung transformiert es anders: <br><br><img src="https://habrastorage.org/webt/6m/p6/c8/6mp6c8wo3tdsj4ylu5_iuycuktc.png"><br><br>  Und zur√ºck: <br><br><img src="https://habrastorage.org/webt/yn/jm/k3/ynjmk3lrtjxek1x2tmlsbdw2sfc.png"><br><br>  Und da nochmal: <br><br><img src="https://habrastorage.org/webt/to/l2/jb/tol2jb-p3tatdxzdqpas_vsnkt0.png"><br><br>  Und zur√ºck: <br><br><img src="https://habrastorage.org/webt/xx/dd/o5/xxddo5fos6vgooq4g_mu4pvrss4.png"><br><br>  Und da: <br><br><img src="https://habrastorage.org/webt/nf/gp/qv/nfgpqvw4-oikia4hmkxok04vmwo.png"><br><br>  Und schlie√ülich sind wir mit dem Mittelland fertig!  Der Code auf der rechten Seite ist der Code, den wir (in unserem Fall) an das x86-64-Backend √ºbergeben. <br><br>  Sie m√∂gen neugierig sein, ob Schwankungen im Verhalten am Ende der Pipeline das Ergebnis eines Compiler-Fehlers sind, aber lassen Sie uns ber√ºcksichtigen, dass diese Funktion sehr, sehr einfach ist und viele Durchg√§nge in ihrer Verarbeitung involviert sind, aber ich habe sie nicht einmal erw√§hnt, weil sie hat keine √Ñnderungen am Code vorgenommen.  In der zweiten H√§lfte der Optimierungspipeline beobachten wir haupts√§chlich entartete F√§lle f√ºr diese Funktion. <br><br>  Danksagung: Einige Studenten in meinem ausf√ºhrlichen Compiler-Kurs in diesem Herbst haben Feedback zu einem Entwurf dieses Beitrags hinterlassen (und ich habe dieses Material auch f√ºr Hausaufgaben verwendet).  Ich ging durch die Funktionen, die hier in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser</a> guten Reihe von Vorlesungen zur Schleifenoptimierung besprochen wurden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433598/">https://habr.com/ru/post/de433598/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433582/index.html">Was ist, wenn die Gewinnbeteiligung 30/70 nicht mehr der Standard f√ºr Spieleentwickler ist?</a></li>
<li><a href="../de433586/index.html">Wie wir den Hackathon nicht gewonnen haben</a></li>
<li><a href="../de433588/index.html">Erstaunliche Leistung paralleler C ++ 17-Algorithmen. Mythos oder Wirklichkeit?</a></li>
<li><a href="../de433592/index.html">Information: Yandex.Phone</a></li>
<li><a href="../de433596/index.html">Magellans Fehler: Puffer√ºberlauf oder Expedition um die Welt mit SQLite FTS</a></li>
<li><a href="../de433600/index.html">Pixel 3 lernt, wie man die Tiefe von Fotos bestimmt</a></li>
<li><a href="../de433602/index.html">Mathematische Einfachheit kann der Geschwindigkeit der Evolution zugrunde liegen.</a></li>
<li><a href="../de433604/index.html">Komfortable Arbeit mit Android Studio</a></li>
<li><a href="../de433606/index.html">SIEM-Tiefen: Out-of-Box-Korrelationen. Teil 3.2. Ereignisnormalisierungsmethode</a></li>
<li><a href="../de433608/index.html">Das Auto der Zukunft. Bildschirme statt Autoglas?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>