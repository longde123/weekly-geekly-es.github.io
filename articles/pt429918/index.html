<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèáüèΩ ü§≤üèø ‚úâÔ∏è Mundo virtual Intel. Parte 2: SMP üå± üé± üö∂üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em um artigo anterior (link), falei sobre o conceito b√°sico de um hipervisor baseado na tecnologia de virtualiza√ß√£o de hardware Intel. Agora, proponho...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mundo virtual Intel. Parte 2: SMP</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429918/">  Em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> anterior (link), falei sobre o conceito b√°sico de um hipervisor baseado na tecnologia de virtualiza√ß√£o de hardware Intel.  Agora, proponho expandir os recursos do hypervisor adicionando suporte √† arquitetura de multiprocessador (SMP) e tamb√©m considero um exemplo de como o hypervisor pode fazer altera√ß√µes no sistema operacional convidado. <br><br>  Todas as a√ß√µes adicionais ser√£o realizadas no PC com a seguinte configura√ß√£o: <br><br>  CPU: Intel Core i7 5820K <br>  Placa-m√£e: Asus X99-PRO <br>  Mem√≥ria RAM: 16GB <br>  SO convidado: Windows 7 x32 com PAE desativado <br><a name="habracut"></a><br>  Come√ßarei descrevendo a localiza√ß√£o dos componentes do hypervisor no disco r√≠gido (todos os valores s√£o especificados em setores). <br><br><img src="https://habrastorage.org/webt/in/_l/4b/in_l4birv9nzswyy15vouhjywla.jpeg" alt="imagem"><br>  <i>O processo de carregamento de um hypervisor difere da vers√£o anterior apenas na presen√ßa de um novo m√≥dulo <i>hypervisor.ap</i> , cujo objetivo √© a inicializa√ß√£o b√°sica do processador AP.</i> <br><br>  O processo de carregamento de m√≥dulos na mem√≥ria: <br><br><img src="https://habrastorage.org/webt/3a/in/ul/3ainulrasx1dmbgbpodesnsg-qy.jpeg"><br><br>  <b>Suporte SMP</b> <br><br>  Eu implementei um hipervisor no princ√≠pio do multiprocessamento sim√©trico, o que significa que a mesma c√≥pia do VMX ser√° lan√ßada em todos os processadores l√≥gicos presentes.  Al√©m disso, as tabelas IDT e GDT, bem como as tabelas para mem√≥ria de pagina√ß√£o, ser√£o comuns a todos os processadores l√≥gicos.  Fiz isso porque o hypervisor inicializar√° imediatamente a mem√≥ria para o espa√ßo de endere√ßo do SO convidado e n√£o h√° necessidade de reatribuir dinamicamente os endere√ßos f√≠sicos de p√°ginas individuais.  Al√©m disso, com essa abordagem, voc√™ n√£o precisa monitorar a correspond√™ncia dos caches TLB do processador no lado do hypervisor. <br>  O processo de inicializa√ß√£o do BSP e do AP ser√° diferente.  Todas as principais estruturas envolvidas no hypervisor ser√£o criadas durante a inicializa√ß√£o do BSP.  Al√©m disso, o estado da atividade para processadores AP do modo n√£o raiz vmx ser√° definido como estado HLT.  Assim, o ambiente do SO convidado ser√° emulado de acordo com o que seria sem o uso da virtualiza√ß√£o. <br><br>  Inicializando o BSP: <br><br><ol><li>  Inicializa√ß√£o Spinlock </li><li>  Inicializando e carregando tabelas GDT e IDT </li><li>  Inicializando tabelas de pagina√ß√£o </li><li>  Inicializando estruturas do VMCS e criando uma tabela EPT comum </li><li>  Ativa√ß√£o de processadores AP.  Para fazer isso, uma sequ√™ncia de interrup√ß√£o INIT - SIPI √© enviada para cada AP.  O vetor para a interrup√ß√£o do SIPI √© 0x20, que corresponde √† transfer√™ncia do controle AP em 0x20000 (m√≥dulo hypervisor.ap) </li><li>  Iniciando o sistema operacional convidado em 0x7C00 (m√≥dulo win7.mbr) </li></ol><br>  Inicializa√ß√£o AP: <br><br><ol><li>  Depois de ativar o AP, o processador est√° no modo real.  O m√≥dulo hypervisor.ap inicializa as tabelas de mem√≥ria e pagina√ß√£o para alternar para o modo longo </li><li>  Fa√ßa o download do IDT, GDT e do cat√°logo de tabelas de pagina√ß√£o criadas durante a fase de inicializa√ß√£o do BSP </li><li>  Inicializa√ß√£o de estruturas VMCS e carregamento de tabelas EPT criadas no est√°gio de inicializa√ß√£o do BSP </li><li>  Alternando para o modo n√£o raiz vmx com o estado HLT ativo </li></ol><br>  Podemos dizer que a implementa√ß√£o do suporte SMP no hypervisor √© bastante simples, mas h√° alguns pontos que eu gostaria de chamar a aten√ß√£o. <br><br>  1. Suporte legado USB <br><br>  Os novos modelos de placas-m√£e podem n√£o ter conectores PS / 2; portanto, o Suporte USB herdado √© usado para garantir compatibilidade com vers√µes anteriores.  Isso significa que voc√™ pode trabalhar com um teclado ou mouse USB usando os mesmos m√©todos (portas de entrada / sa√≠da) que o padr√£o PS / 2.  A implementa√ß√£o do USB Legacy Support depende n√£o apenas do modelo da placa-m√£e, mas tamb√©m pode acenar em diferentes vers√µes do firmware.  Na minha placa-m√£e Asus X99-PRO, o USB Legacy Support √© implementado atrav√©s de interrup√ß√µes SMI, no processador em que ocorre a emula√ß√£o PS / 2.  Escrevo sobre isso com detalhes, porque, no meu caso (vers√£o de firmware 3801), o Suporte Legado USB n√£o √© compat√≠vel com o modo longo e, quando retorna do SMM, o processador entra no estado de desligamento. <br><br>  A solu√ß√£o mais f√°cil nessa situa√ß√£o √© desativar o USB Legacy Support antes de mudar para o modo longo.  No entanto, no Windows, o m√©todo de pesquisa de teclado PS / 2 √© usado no est√°gio de sele√ß√£o das op√ß√µes de inicializa√ß√£o, portanto, o Suporte Legado USB deve ser ativado novamente antes do carregamento do SO convidado. <br><br>  2. Chave de Tarefa de Hardware <br><br>  Nos sistemas operacionais modernos, a altern√¢ncia entre tarefas √© implementada, via de regra, por m√©todos de software.  No entanto, no Windows7, os seletores apontando para TSS s√£o atribu√≠dos √† interrup√ß√£o 2 - NMI e 8 - Double Fault, o que significa que essas interrup√ß√µes levar√£o √† altern√¢ncia de contexto de hardware.  O Intel VMX n√£o oferece suporte ao Switch de tarefas de hardware e uma tentativa de execut√°-lo leva √† sa√≠da da VM.  Para esses casos, escrevi meu manipulador de altern√¢ncia de tarefas (fun√ß√£o GuestTaskSwitch).  Uma interrup√ß√£o de falha dupla ocorre apenas no caso de um conflito grave do sistema causado pelo manuseio inadequado de outras interrup√ß√µes.  No processo de depura√ß√£o, eu n√£o o encontrei.  Mas a NMI aparece nos processadores AP no momento da reinicializa√ß√£o do Windows.  Isso ainda levanta minhas d√∫vidas, porque n√£o est√° claro se essas NMIs s√£o o resultado de um processo de reinicializa√ß√£o regular ou se √© essa opera√ß√£o incorreta do hypervisor em alguns dos est√°gios anteriores.  Se voc√™ tiver alguma informa√ß√£o sobre esse assunto, fale nos coment√°rios ou escreva-me em uma mensagem pessoal. <br><br>  <b>Altera√ß√µes no SO convidado</b> <br><br>  Sinceramente, n√£o pude decidir por um longo tempo exatamente quais mudan√ßas o hypervisor deve fazer no trabalho do SO convidado.  O fato √© que, por um lado, eu queria mostrar algo interessante, como a introdu√ß√£o de nossos manipuladores em protocolos de rede b√°sicos, mas, por outro lado, tudo se resumia a uma grande quantidade de c√≥digo, e havia pouco a ver com o assunto de um hypervisor.  Al√©m disso, n√£o queria vincular o hypervisor a nenhum conjunto espec√≠fico de ferro. <br><br>  Como resultado, foi encontrado o seguinte compromisso: nesta vers√£o do hypervisor, o controle sobre as chamadas do sistema a partir do modo de usu√°rio √© implementado, ou seja, ser√° poss√≠vel controlar a opera√ß√£o de aplicativos em execu√ß√£o no SO convidado.  Esse tipo de controle √© bastante simples de implementar e, al√©m disso, permite obter um resultado visual do trabalho. <br><br>  O controle sobre a opera√ß√£o dos aplicativos ser√° realizado no n√≠vel das chamadas do sistema.  E o objetivo principal ser√° alterar o resultado da fun√ß√£o <i>NtQuerySystemInformation</i> para que, quando voc√™ ligar com o argumento <i>SystemProcessInformation</i> ( <i>0x05</i> ), possa interceptar as informa√ß√µes do processo. <br><br>  No Windows 7, o programa aplicativo para chamar a fun√ß√£o de sistema usa o comando assembler sysenter, ap√≥s o qual o controle √© transferido para o processador <i>KiFastCallEntry</i> para o kernel no n√≠vel r0.  Para retornar ao n√≠vel do aplicativo r3, use o comando sysexit. <br>  Para obter acesso aos resultados da <i>execu√ß√£o da</i> fun√ß√£o <i>NtQuerySystemInformation,</i> √© necess√°rio salvar o n√∫mero da fun√ß√£o chamada toda vez que o comando sysenter √© executado.  Em seguida, ao executar <i>sysexit,</i> compare o valor armazenado com o n√∫mero da fun√ß√£o que est√° sendo interceptada e, se houver uma correspond√™ncia, fa√ßa altera√ß√µes nos dados retornados pela fun√ß√£o. <br>  O Intel VMX n√£o fornece meios diretos de monitorar a execu√ß√£o de <i>sysenter / sysexit</i> ; no entanto, se voc√™ escrever o valor 0 em <i>Guest MSR IA32_SYSENTER_CS</i> , os <i>comandos sysenter / sysexit gerar√£o</i> uma exce√ß√£o GP que pode ser usada para chamar o manipulador de sa√≠da VM.  Para que a exce√ß√£o GP chame VM Exit, voc√™ precisa definir 13 bits no campo <i>Exception Bitmap</i> no VMCS. <br><br>  A estrutura abaixo √© usada para emular o par sysenter / sysexit. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class">{</span></span> QWORD ServiceNumber; QWORD Guest_Sys_CS; QWORD Guest_Sys_EIP; QWORD Guest_Sys_ESP; } SysEnter_T;</code> </pre> <br>  O campo <i>ServiceNumber</i> cont√©m o n√∫mero da fun√ß√£o que est√° sendo chamada e √© atualizado a cada chamada para o sysenter. <br><br>  Os campos <i>Guest_Sys_CS, Guest_Sys_EIP, Guest_Sys_ESP</i> s√£o atualizados quando o SO convidado tenta gravar no registro MSR correspondente.  Para isso, <i>s√£o definidas</i> m√°scaras de grava√ß√£o no <i>endere√ßo MSR-Bitmap</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 174H 372 IA32_SYSENTER_CS SYSENTER_CS write mask ptrMSR_BMP[0x100 + (0x174 &gt;&gt; 6)] |= (1UL &lt;&lt; (0x174 &amp; 0x3F)); // 175H 373 IA32_SYSENTER_ESP SYSENTER_ESP write mask ptrMSR_BMP[0x100 + (0x175 &gt;&gt; 6)] |= (1UL &lt;&lt; (0x175 &amp; 0x3F)); // 176H 374 IA32_SYSENTER_EIP SYSENTER_EIP write mask ptrMSR_BMP[0x100 + (0x176 &gt;&gt; 6)] |= (1UL &lt;&lt; (0x176 &amp; 0x3F));</span></span></code> </pre><br>  O SO convidado n√£o deve ver as altera√ß√µes feitas pelo hypervisor na opera√ß√£o das chamadas de fun√ß√£o do sistema.  Ao definir a m√°scara de leitura para <i>MSR IA32_SYSENTER_CS,</i> voc√™ pode retornar o sistema operacional convidado ao seu valor de registro original ao ler. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 174H 372 IA32_SYSENTER_CS SYSENTER_CS read mask ptrMSR_BMP[0x174 &gt;&gt; 6] |= (1UL &lt;&lt; (0x174 &amp; 0x3F));</span></span></code> </pre><br>  A seguir, √© apresentado um esquema de emula√ß√£o de comando <i>sysenter / sysexit</i> . <br><br><img src="https://habrastorage.org/webt/bl/wx/vo/blwxvocgthxx_0skhnjmm4sbf4i.jpeg"><br><br>  No <i>est√°gio de</i> emula√ß√£o <i>sysexit</i> , o n√∫mero armazenado da fun√ß√£o chamada √© comparado com o n√∫mero NtQuerySystemInformation (0x105).  No caso de uma correspond√™ncia, verifica-se que NtQuerySystemInformation √© chamado com o argumento System Process Information e, nesse caso, a fun√ß√£o <i>ChangeProcessNames (DWORD SPI_GVA, DWORD SPI_size)</i> faz altera√ß√µes nas estruturas que cont√™m informa√ß√µes sobre os processos. <br>  <i>SPI_GVA</i> √© o endere√ßo virtual convidado da estrutura <i>SYSTEM_PROCESS_INFORMATION</i> <br>  <i>SPI_size</i> √© o tamanho total de estruturas em bytes. <br>  A estrutura <i>SYSTEM_PROCESS_INFORMATION se</i> parece com esta: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SYSTEM_PROCESS_INFORMATION</span></span></span><span class="hljs-class"> {</span></span> ULONG NextEntryOffset; ULONG NumberOfThreads; BYTE Reserved1[<span class="hljs-number"><span class="hljs-number">48</span></span>]; UNICODE_STRING ImageName; KPRIORITY BasePriority; HANDLE UniqueProcessId; PVOID Reserved2; ULONG HandleCount; ULONG SessionId; PVOID Reserved3; SIZE_T PeakVirtualSize; SIZE_T VirtualSize; ULONG Reserved4; SIZE_T PeakWorkingSetSize; SIZE_T WorkingSetSize; PVOID Reserved5; SIZE_T QuotaPagedPoolUsage; PVOID Reserved6; SIZE_T QuotaNonPagedPoolUsage; SIZE_T PagefileUsage; SIZE_T PeakPagefileUsage; SIZE_T PrivatePageCount; LARGE_INTEGER Reserved7[<span class="hljs-number"><span class="hljs-number">6</span></span>]; } SYSTEM_PROCESS_INFORMATION;</code> </pre><br>  N√£o h√° nada complicado na an√°lise; o principal √© n√£o esquecer de converter o endere√ßo virtual do convidado em f√≠sico, para isso √© usada a fun√ß√£o <i>GuestLinAddrToPhysAddr ()</i> . <br><br>  Para maior clareza, substitu√≠ os dois primeiros caracteres nos nomes de todos os processos por um sinal ' <b>:)</b> '. O resultado dessa substitui√ß√£o √© vis√≠vel na captura de tela. <br><br><img src="https://habrastorage.org/webt/rs/nq/rt/rsnqrtxvkrcoc0r_4xgjnuabk8o.png"><br><br>  <b>Sum√°rio</b> <br><br>  Em geral, as tarefas definidas no in√≠cio do artigo foram conclu√≠das.  O hipervisor garante a opera√ß√£o est√°vel do sistema operacional convidado e tamb√©m controla a chamada das fun√ß√µes do sistema no n√≠vel do aplicativo.  Observo que a principal desvantagem do uso da emula√ß√£o de comando <i>sysenter / sysexit</i> √© um aumento significativo nas chamadas de sa√≠da da VM, o que afeta o desempenho e isso √© especialmente percept√≠vel quando o sistema operacional convidado est√° no modo de processador √∫nico.  Essa desvantagem pode ser eliminada se voc√™ controlar as chamadas apenas no contexto dos processos selecionados. <br><br>  E isso √© tudo por enquanto.  As fontes do artigo podem ser obtidas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> <br><br>  Obrigado pela aten√ß√£o. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt429918/">https://habr.com/ru/post/pt429918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt429908/index.html">Como usar corotinas na comida e dormir tranquilamente √† noite</a></li>
<li><a href="../pt429910/index.html">AppsConf Rises</a></li>
<li><a href="../pt429912/index.html">Desenvolvimento da biblioteca: da API ao lan√ßamento p√∫blico</a></li>
<li><a href="../pt429914/index.html">OpenSceneGraph: Gr√°fico de cena e ponteiros inteligentes</a></li>
<li><a href="../pt429916/index.html">Como construir e construir</a></li>
<li><a href="../pt429920/index.html">Tragicomedy em NaN age: como criamos um jogo em JS e o lan√ßamos no Steam</a></li>
<li><a href="../pt429922/index.html">Como transformar um projeto simples em uma constru√ß√£o de longo prazo ou cortar todos os itens desnecess√°rios</a></li>
<li><a href="../pt429928/index.html">Tudo o que voc√™ precisa saber sobre estresse e emo√ß√µes fortes</a></li>
<li><a href="../pt429930/index.html">Splunk Solu√ß√£o de problemas f√°cil de aplicativos</a></li>
<li><a href="../pt429934/index.html">O que tem ai?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>