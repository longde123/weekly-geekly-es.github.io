<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚈 🔶 👼🏿 Pemrograman adalah perwujudan gagasan. 👩‍👩‍👦 🤛🏾 🎅🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tesis utama artikel ini: Pengembangan perangkat lunak harus dilihat sebagai perwujudan ide melalui transformasi model mental menjadi kode program. 
 A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pemrograman adalah perwujudan gagasan.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425321/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/ca/ha/pc/cahapcznbgjnjjfsimgdlkqovig.jpeg"></a> <br><br>  Tesis utama artikel ini: Pengembangan perangkat lunak harus dilihat sebagai perwujudan ide melalui transformasi model mental menjadi kode program. <br>  Artikel ini menjelaskan paradigma mewujudkan ide-ide dalam rekayasa perangkat lunak (bahasa Inggris: RPSE: Reifikasi sebagai Paradigma Rekayasa Perangkat Lunak). <br><a name="habracut"></a><br>  Versi bahasa Inggris artikel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RPSE: Reifikasi sebagai Paradigma Rekayasa Perangkat Lunak</a> .  Singkatan RPSE digunakan kemudian dalam teks untuk menunjukkan paradigma yang dijelaskan. <br><br><h2>  Definisi Kunci </h2><br>  Sebelum membahas poin-poin utama dari artikel ini, Anda harus menyetujui arti dari istilah-istilah dasar yang digunakan di dalamnya. <br><br><h3>  Rekayasa perangkat lunak </h3><br>  Yang kami maksud dengan <b>rekayasa perangkat lunak</b> adalah definisi klasik dari disiplin Rekayasa Perangkat Lunak dari kamus IEEE [1]: Rekayasa perangkat lunak adalah “Penerapan pendekatan yang sistematis, disiplin, terkuantifikasi untuk pengembangan, pengoperasian, dan pemeliharaan perangkat lunak”. <br><br><h3>  Paradigma </h3><br>  Istilah <b>paradigma yang</b> digunakan dalam artikel ini didasarkan pada definisi klasik dari paradigma Thomas Kuhn [2]: Paradigma adalah lingkaran masalah, seperangkat konsep, aturan dan hukum yang diterima secara umum, metode untuk memecahkan masalah dalam bidang ilmu tertentu. <br><br><div class="spoiler">  <b class="spoiler_title">Lebih lanjut tentang paradigma</b> <div class="spoiler_text">  Untuk lebih menentukan konsep paradigma yang digunakan di bawah ini, ada baiknya mengutip dua kutipan terkenal dari buku Kuhn: <br><blockquote>  Dengan paradigma, maksud saya adalah pencapaian ilmiah yang diakui bahwa untuk beberapa waktu memberikan komunitas ilmiah model untuk mengajukan masalah dan solusi mereka ... <br><br>  Memperkenalkan istilah ini, saya maksudkan bahwa beberapa contoh yang diterima secara umum dari praktik nyata penelitian ilmiah - contoh yang mencakup hukum, teori, penerapan praktisnya dan peralatan yang diperlukan - semuanya bersama-sama memberi kita model-model dari mana tradisi spesifik penelitian ilmiah muncul. </blockquote><br>  Dualisme dari konsep ini terletak pada kenyataan bahwa, di satu sisi, paradigma dicirikan melalui komunitas spesialis yang mengenalinya.  Spesialis dari bidang tertentu yang menentukan, membuat, dan mengembangkan bagian-bagiannya.  Di sisi lain, pengakuan terhadap paradigma tertentu berarti bagi seorang spesialis yang bergabung dengan komunitas semacam itu. </div></div><br>  Thomas Kuhn mempertimbangkan paradigma ilmiah dalam bukunya.  Namun, segera setelah rilis edisi pertama buku tersebut, kegunaan menggunakan konsep ini dalam teknologi dan berbagai bidang kehidupan sosial menjadi jelas.  Dalam hal ini, banyak publikasi tentang paradigma dan perubahannya dalam industri otomotif, perencanaan kota, perawatan penyakit tertentu, dll. Mulai muncul dalam literatur khusus dan populer. <br><br>  Rekayasa perangkat lunak dan terutama komponen penting - pemrograman, tidak terkecuali.  Saat ini ada banyak paradigma pemrograman yang bersaing.  Artikel terpisah di Wikipedia [3], serta ulasan menarik seperti [4], dikhususkan untuk pencacahan mereka. <br><br><div class="spoiler">  <b class="spoiler_title">Tentang keterbatasan paradigma pemrograman</b> <div class="spoiler_text">  Para penulis paradigma yang dijelaskan dalam [3] dan [4] berkonsentrasi pada sub-area yang sempit dari rekayasa perangkat lunak, yaitu, menulis program dalam bahasa pemrograman tertentu.  Saya pikir banyak profesional setuju bahwa proyek perangkat lunak nyata tidak dapat diselesaikan dalam kerangka hanya satu dari paradigma ini (misalnya, pemrograman fungsional). <br><br>  Paradigma yang dijelaskan dalam artikel ini, sebaliknya, berlaku untuk berbagai bidang subjek dan fase pengembangan perangkat lunak. </div></div><br><div class="spoiler">  <b class="spoiler_title">Pada keterbatasan paradigma manajemen proyek perangkat lunak</b> <div class="spoiler_text">  Beberapa penulis, misalnya, dalam tinjauan [5], menyebutkan berbagai pendekatan atau model untuk mengatur dan melakukan proyek perangkat lunak sebagai paradigma.  Misalnya, model air terjun, model V, atau model Agile dibandingkan.  Tidak mungkin bahwa pendekatan ini, berbeda dengan paradigma pemrograman yang disebutkan di atas, dapat disebut paradigma dalam semangat definisi Kuhn karena kesederhanaan teoretis relatifnya dan kurangnya landasan teori yang luas. <br><br>  Paradigma yang diusulkan dalam artikel ini juga belum memiliki landasan teoretis yang dikembangkan sendiri, tetapi hari ini jalur pengembangannya sudah terlihat. </div></div><br><h3>  Terwujudnya ide </h3><br>  Istilah <b>materialisasi ide</b> (bahasa Inggris: <i>reifikasi</i> ) yang digunakan dalam artikel ini adalah perpanjangan dari definisi klasik reifikasi dalam ilmu komputer: "Reifikasi adalah proses dimana ide abstrak tentang program komputer diubah menjadi model data eksplisit atau objek lain yang dibuat dalam bahasa pemrograman" [6]. <br><br><div class="spoiler">  <b class="spoiler_title">Lebih banyak tentang dunia ide, dunia benda dan materialisasi</b> <div class="spoiler_text">  Inti dari perluasan definisi klasik dari konsep materialisasi yang digunakan dalam artikel ini dapat didefinisikan sebagai berikut. <br><br>  Sudah sejak awal traktat filosofis yang turun kepada kita, sudah biasa untuk membandingkan Ideal (dunia ide) dengan Material (dunia benda). <br><br>  Kita dapat merasakan yang terbaik yang terbaik (atau berpikir bahwa kita merasakannya).  Indikator perasaan Ideal seperti itu bisa berupa perubahan suasana hati atau pemikiran setelah mendengarkan musik, fragmen buku yang sudah dibaca, dll.  Tentu saja, maksud saya adalah efek tidak langsung, misalnya musik, pada kesadaran kita, dan bukan subordinasi fisiologis primitif tubuh terhadap deru konser rock atau ritme disko. <br><br>  Upaya merumuskan rasa Ideal kita sebagai suatu peraturan tidak mengarah pada kesuksesan. <br>  Penyair besar Rusia, Fedor Ivanovich Tyutchev, berkomentar sangat: <br><blockquote>  Bagaimana hati mengekspresikan dirinya? <br>  Bagaimana cara memahami Anda? <br>  Apakah dia akan mengerti bagaimana Anda hidup? <br>  Pikiran yang diucapkan itu bohong ... [7] </blockquote>  Bahkan ide-ide praktis seperti perbaikan kecil di sekitar rumah atau menyiapkan variasi baru hidangan yang akrab pada awalnya sulit untuk dirumuskan.  Dan hanya setelah musyawarah atau upaya untuk menjelaskan kepada orang lain, gagasan mengambil "garis besar" semakin jelas. <br><br>  Kita sekarang beralih dari pertimbangan konsep Ideal ke pertimbangan Material.  Kita dapat merasakan dan mendaftarkan benda-benda material di sekitar kita, untuk membedakan sifat-sifatnya secara kualitatif.  Properti banyak objek dapat diukur secara objektif.  Kami juga dapat secara objektif mengidentifikasi hierarki dan struktur lain dari objek material. </div></div><br>  Untuk mengevaluasi atau mengukur (untuk mendapatkan karakteristik kuantitatif) tidak perlu memiliki item.  Sudah cukup memiliki modelnya.  Selain itu, dalam banyak situasi yang praktis menarik, model dapat digunakan tanpa objek.  Model dapat didiskusikan dengan orang lain.  Model dapat dinegosiasikan.  Model dapat distandarisasi (diformalkan). <br><br>  Dalam beberapa bidang aktivitas manusia, standardisasi model telah berjalan sejauh bagian-bagian (misalnya, baut berulir) dibuat berdasarkan model standar (misalnya, gambar) oleh orang yang berbeda atau senapan mesin tidak dapat dibedakan dari sudut pandang teknologi. <br><br>  Menyadari ketidakakuratan relatif dari definisi yang diusulkan, nanti dalam artikel ini saya akan membagi dunia fenomena dunia batin dan dunia luar kita menjadi dua bagian: <br><br>  <b>U = M + I</b> <br><br>  di mana himpunan <b>M</b> terdiri dari fenomena mereka yang dapat didaftarkan atau diukur secara objektif (dunia material) dan <b>I</b> - segalanya. <br><br>  Apakah formula ini berlaku untuk semua fenomena dunia di sekitar kita adalah pertanyaan filosofis terbuka.  Kemudian dalam artikel ini, kami mempersempit cakupan formula ini ke dunia fenomena dari dunia rekayasa perangkat lunak. <br><br>  Atau, merumuskannya sebagai tesis: Seluruh rangkaian fenomena yang terkait dengan rekayasa perangkat lunak dapat dibagi menjadi subset dari yang ideal dan subset dari materi.  Selain itu, fenomena material dicatat atau diukur berdasarkan model mereka. <br>  Proses membuat atau memodifikasi sistem perangkat lunak berakhir dalam banyak kasus dengan penciptaan satu atau kode lain, yang, menggunakan komputer, ditampilkan dalam proses fisik (fenomena dunia nyata). <br><br>  Proses ini dimulai dengan munculnya ide-ide tertentu tentang sistem masa depan di benak pelanggan atau pengembang.  Kami akan menyebut ide dan ide ini sebagai <b>model mental</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Tentang Model Menengah</b> <div class="spoiler_text">  Dalam sistem sederhana atau dengan penambahan / perubahan sederhana pada sistem besar, pengembang segera menulis kode atau mengkonfigurasi sistem berdasarkan model mentalnya.  Namun, dalam kebanyakan kasus, model antara kompleksitas dan tingkat formalisasi yang berbeda dibuat - dari daftar persyaratan sederhana hingga model formal yang luas (misalnya, model UML atau BPMN) </div></div><br><h2>  Terwujudnya ide di bidang yang berdekatan dengan Rekayasa Perangkat Lunak </h2><br>  Jelas bahwa definisi di atas tidak secara radikal baru dan digunakan secara luas (secara sadar atau tidak sadar) di bidang pekerjaan intelektual yang berdekatan dengan pemrograman.  Misalnya, pertimbangkan dua bidang seperti itu - teknik mesin dan matematika. <br><br>  Kedua bidang ini telah menggunakan materialisasi gagasan untuk waktu yang lama dan efektif.  Mereka harus banyak belajar tentang pemrograman dalam hal ini. <br><br>  Dalam teknik mesin, kita melihat siklus lengkap dari materialisasi ide - dari munculnya ide di kepala perancang melalui pemikirannya melalui, merinci, memetakan ke dalam model, dan akhirnya - manufaktur dari bahan tertentu. <br><br>  Situasinya berbeda dalam matematika. <br><br><div class="spoiler">  <b class="spoiler_title">Pada materialisasi ide dalam matematika</b> <div class="spoiler_text">  Fakta menarik dan pertimbangan mengenai materialisasi gagasan dalam matematika dapat ditemukan dalam paragraf 7.3 dalam buku [8]. </div></div><br>  "Produk akhir" matematika adalah model formal dengan sifat yang telah terbukti benar. <br><br>  Dari sudut pandang ini, pemrograman ada di tengah.  Ini dapat digambarkan secara grafis sebagai berikut: <br><br><img src="https://habrastorage.org/webt/8n/ja/84/8nja84baboink2t_bp02narqbja.png"><br><br>  Dengan demikian, matematika menggunakan sejumlah besar model yang lebih abstrak dan hampir tidak berlaku untuk bidang model yang sangat spesifik seperti gambar teknik. <br><br>  Teknik mesin, sebaliknya, menggunakan model abstrak yang relatif sedikit, tetapi banyak yang spesifik.  Misalnya, benda-benda yang objek fisiknya dapat dibuat dengan jelas. <br><br>  Dari sudut pandang ini, pemrograman ada di tengah. <br><br><div class="spoiler">  <b class="spoiler_title">Mengapa pemrograman di tengah?</b> <div class="spoiler_text">  Produk pemrograman terakhir adalah kode perangkat lunak.  Dan meskipun itu, ketika dieksekusi pada perangkat keras, dipetakan ke objek fisik tertentu (sinyal listrik dan bidang berbagai sifat fisik), objek ini sulit untuk dibandingkan dengan mur, roda gigi, dan badan mobil.  Di sisi lain, kode program dekat dengan rumus matematika, dan kadang-kadang itu adalah refleksi langsung mereka.  Namun, dalam sistem perangkat lunak nyata, Anda perlu mempertimbangkan banyak aspek khusus dari lingkungan dan interaksi dengan pengguna atau sistem lain.  Ini membuat kode program lebih spesifik daripada rumus matematika. </div></div><br><div class="spoiler">  <b class="spoiler_title">Apa yang bisa dipelajari oleh rekayasa perangkat lunak dari wilayah sekitar dalam hal penggunaan model</b> <div class="spoiler_text">  Pertimbangkan dulu matematika. <br><br><h3>  Multimodel dunia </h3><br>  Selama beberapa ribu tahun perkembangannya, matematika telah belajar untuk menggambarkan fenomena yang sama dari dunia nyata atau imajiner dalam istilah yang sangat berbeda.  Orang-orang Yunani kuno belajar untuk mengganti deskripsi verbal murni tugas-tugas dengan angka-angka geometris dan dengan bantuan mereka memecahkan masalah yang praktis penting.  Kemudian, muncul pemahaman tentang pertukaran segmen di pesawat dan angka.  Kemudian konsep variabel aljabar dan reduksi masalah geometri menjadi sistem persamaan aljabar dikristalisasi. <br><br>  Saat ini, siswa sekolah menengah sudah tahu bahwa masalah yang sama dapat diselesaikan dengan cara yang berbeda (misalnya, secara geometris atau aljabar) dan bahwa model matematika yang sama, misalnya, persamaan aljabar, menggambarkan banyak perbedaan fisik, kimia, dll.  fenomena. <br><br><h3>  Morfisme model dan konsistensi konsep dan notasi </h3><br>  Matematika telah belajar dengan baik tidak hanya untuk menggambarkan objek dan proses nyata atau imajiner yang sama menggunakan model yang sifat matematisnya sangat berbeda.  Suatu pencapaian penting matematika adalah kemampuan untuk menentukan tingkat kesamaan model dari berbagai cabang matematika, serta kemampuan untuk mengubah mereka menjadi satu sama lain.  Banyak solusi terobosan untuk masalah matematika paling penting dalam beberapa tahun terakhir pada dasarnya adalah rantai bukti terpisah, yang masing-masing menggunakan alat khusus dari bagian khusus matematika.  Pada persimpangan bukti yang sangat khusus ini, matematika dengan terampil mengubah model dari satu bagian matematika menjadi model bagian lain.  Dalam pemrograman, sesuatu yang serupa terjadi sekarang ketika mengkompilasi kode sumber program dan ketika menghasilkan kode dari DSL (Domain Specific Language) atau metadata.  Tetapi budaya bekerja dengan model di bidang rekayasa perangkat lunak jauh di belakang yang matematika. <br><br><h3>  Model dalam teknik mesin </h3><br>  Dan apa yang bisa dipelajari rekayasa perangkat lunak dari materialisasi dalam rekayasa? <br>  Di banyak industri, dan bahkan dalam keprihatinan besar, ada rantai model formal dan semi formal yang terkoordinasi.  Rantai ini diakhiri dengan model, yang menjadi dasar pembuatan dan pemasangan benda fisik - perangkat dan mesin.  Sebagai aturan, untuk sebagian besar jenis model perantara, ada metode formal untuk memeriksa kebenarannya (standar teknis).  Model adalah bahasa komunikasi utama para spesialis dari berbagai profil dalam proses perancangan dan pembuatan produk-produk teknik. <br><br>  Terhadap latar belakang ini, situasi di IT terlihat jauh lebih buruk.  Hanya dalam keprihatinan TI yang sangat besar dalam beberapa tahun terakhir telah dilakukan upaya untuk membangun serangkaian model dan proses yang sebanding.  Perusahaan kecil dan perusahaan rintisan TI, sebagai suatu peraturan, tidak hanya tidak mengembangkan model dan proses formal, tetapi bahkan tidak mencurigai keberadaan mereka.  Situasi ini saat ini ditentukan oleh faktor-faktor berikut: <br><br><ul><li>  Kurangnya efisiensi model dan proses yang ada </li><li>  Kurangnya ketenaran model-model ini di luar kekhawatiran besar </li><li>  Pendidikan yang tidak memadai untuk pengembang dan terutama manajer </li><li>  Tumpukan pendidikan universitas dari kebutuhan nyata rekayasa perangkat lunak. </li></ul></div></div><br><h2>  Definisi dan kontur paradigma materialisasi gagasan (RPSE) </h2><br>  Kami telah mengidentifikasi semua konsep yang diperlukan untuk memberikan definisi dasar dari paradigma yang diusulkan.  Ini dia: <br><blockquote>  Pengembangan perangkat lunak adalah perwujudan ide melalui transformasi model mental menjadi kode yang dijalankan pada komputer. <br><br>  Dalam kerangka paradigma yang diusulkan: <br><br><ol><li>  Semua proses pengembangan perangkat lunak utama adalah varian spesifik (implementasi) dari proses membangun rantai model mental dan material.  Model paling spesifik terakhir dalam rantai ini adalah, sebagai aturan, kode program. </li><li>  Inti dari pengembangan perangkat lunak adalah menciptakan rantai seperti itu. </li><li>  Semua masalah utama optimasi pengembangan, mengurangi biaya dan meningkatkan kualitasnya dapat dikurangi untuk mengoptimalkan pembangunan rantai model yang sesuai. </li></ol></blockquote><br><div class="spoiler">  <b class="spoiler_title">Mengapa Materialisasi dan Bukan Modeling?</b> <div class="spoiler_text">  Perhatikan bahwa meskipun definisi RPSE mengacu pada pembangunan rantai model, namun demikian diusulkan untuk menyebut materialisasi paradigma daripada pemodelan.  Dengan demikian, upaya dilakukan untuk menekankan kekhasan rantai model yang menjadi semakin tidak abstrak / ideal dan semakin konkret / material. </div></div><br>  Definisi di atas memiliki karakteristik dan variasi sendiri di berbagai bidang rekayasa perangkat lunak.  Hanya dalam sejumlah kecil kasus yang terjadi bahwa di kepala seorang programmer, sebuah gagasan yang jelas tentang bagaimana menyelesaikan tugas sebelum dia benar-benar matang, yang kemudian diterjemahkan ke dalam kode bahasa pemrograman dalam waktu singkat.  Dalam sebagian besar proyek dunia nyata, proses menemukan solusi dan implementasinya hidup berdampingan, berkembang secara paralel dan berinteraksi satu sama lain.  Yaitu  model mental, kode, dan seringkali model perantara (dalam bentuk tes, gambar, model formal seperti UML) tumbuh dan berubah secara paralel, saling memengaruhi. <br><br><div class="spoiler">  <b class="spoiler_title">Opsi Definisi</b> <div class="spoiler_text">  Sangat sering beberapa orang mengerjakan suatu masalah pada saat yang bersamaan.  Masing-masing dari mereka memiliki model mentalnya sendiri dan, mungkin, model-model menengahnya dan fragmen kode. <br><br>  Seringkali kode dalam beberapa bahasa pemrograman hampir tidak ada, karena menciptakan solusi baru datang ke pengelolaan topeng konfigurator atau generator, seperti ketika bekerja dengan alat pengembangan dalam sistem seperti SAP atau WebSphere. <br><br>  Pilihan untuk mengubah kode yang ditulis secara manual atau dibuat secara otomatis menjadi kode yang dapat dieksekusi juga menjadi sangat beragam belakangan ini. <br><br>  Dan akhirnya, konsep prosesor tempat kode dijalankan juga telah berkembang secara signifikan dalam beberapa tahun terakhir.  Jika sebelumnya itu adalah prosesor yang ada di papan, yang pada gilirannya dimasukkan ke dalam cangkang desktop, laptop dan rak server, sekarang set ini telah diperluas oleh berbagai chip dari berbagai ukuran yang dibangun ke dalam ponsel, konsol game, kamera pengintai, " peralatan rumah pintar, dll.  Belum lagi komputer kuantum. <br><br>  Namun demikian, RPSE, berdasarkan sifat umumnya, berlaku untuk semua area yang tercantum di atas. </div></div><br>  Apa lagi yang bisa dikatakan tentang paradigma tertentu saat ini, mungkinkah untuk secara lebih akurat menguraikan konturnya? <br><br>  Langkah selanjutnya untuk memperbaiki paradigma setelah mencoba memberikan definisi utamanya adalah upaya untuk membuat daftar kategori utama dari fenomena yang dipengaruhi.  Mengingat definisi Kuhn, kita perlu mencoba mendaftar jenis-jenis model yang diperkenalkan dan digunakan RPSE. <br><br>  Model RPSE dapat dibagi menjadi tiga kategori utama: <br><br><ul><li>  Model mental </li><li>  Kode dalam bahasa pemrograman atau yang setara sebagai model kode yang dapat dieksekusi. </li><li>  Model menengah. </li></ul><br>  Yang paling tidak dieksplorasi dalam triad ini adalah model mental.  Apa sebenarnya yang dimaksud oleh mereka? <br><br>  <b>Model mental</b> adalah istilah untuk ide-ide yang ada di kepala pelanggan, programmer dan peserta lain dalam proses dan atas dasar yang akhirnya kode executable muncul.  Kehadiran model seperti itu tidak dapat dibantah dan dapat didaftarkan pada tingkat mental, misalnya, oleh programmer sendiri.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada tingkat perkembangan teknologi saat ini, model-model ini tidak dapat diukur dengan andal oleh instrumen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salah satu cara yang berhasil untuk memperbaiki dan mengukur model-model tersebut adalah dengan menggunakan media ide. </font><font style="vertical-align: inherit;">Jelas, proses wawancara atau yang serupa secara dramatis mempengaruhi model mental itu sendiri. </font><font style="vertical-align: inherit;">Kita masing-masing pasti pernah mengalami situasi lebih dari sekali ketika upaya untuk merumuskan masalah untuk berkonsultasi dengan seorang kolega saja mengarah pada "wawasan", dan seringkali ke solusi untuk masalah tersebut. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wawancara memungkinkan, berdasarkan pertanyaan yang diformulasikan dengan benar, untuk secara relatif membangun model-model dengan kompleksitas yang berbeda-beda. </font><font style="vertical-align: inherit;">Yang paling umum adalah: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Model struktural:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Daftar dengan nilai biner, enumerasi, numerik, string, dan lainnya. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Grafik dan struktur data jaringan </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Model deskripsi perilaku: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tujuh model formal untuk menentukan perilaku </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Model formal untuk menentukan perilaku (misalnya, mesin negara terbatas) </font></font></li></ul><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada teori model mental</font></font></b> <div class="spoiler_text"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pola-pola ini merupakan cerminan dari pola mental. </font><font style="vertical-align: inherit;">Tingkat kedekatan model mental dengan model nyata harus ditangani oleh psikologi atau pedagogi teoretis. </font><font style="vertical-align: inherit;">Sayangnya, penulis tidak mengetahui pekerjaan serius di bidang ini. </font><font style="vertical-align: inherit;">(Ini tidak berarti bahwa pekerjaan seperti itu tidak ada).</font></font></div></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mengapa rekayasa perangkat lunak membutuhkan paradigma ujung ke ujung? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kehadiran paradigma "lintas sektoral" membuka kemungkinan-kemungkinan berikut bagi para peserta untuk menggunakan paradigma proses menciptakan, memodifikasi, dan menggunakan perangkat lunak: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kemampuan untuk semua peserta dalam proses menggunakan terminologi yang sama. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kemampuan untuk membangun proses ujung ke ujung untuk menciptakan perangkat lunak baru. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kemampuan untuk mengevaluasi parameter prosesnya, hasil antara dan mengelolanya. </font></font></li></ul>  . <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tujuan utama pengembangan paradigma </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Masalah teoretis </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang telah berulang kali dicatat, termasuk dalam buku Kuhn [2], dalam kebanyakan kasus, para ilmuwan terlibat dalam memecahkan masalah potensial yang sedang dipecahkan, dan mereka cenderung untuk mengambil masalah yang tidak begitu jelas cara pendekatannya. </font><font style="vertical-align: inherit;">Tapi ini persis tugas kita.</font></font> Inilah yang utama: <br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Definisi konstruktif dari konsep model mental. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menemukan kriteria konstruktif untuk menilai tingkat abstrak / idealitas vs. </font><font style="vertical-align: inherit;">spesifisitas / materialitas model.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menemukan kriteria untuk memilih kandidat untuk peran model menengah dan tambahan. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seleksi dan pengembangan kriteria dan metode untuk membandingkan model dari berbagai jenis, termasuk pelacakan langsung dan mundur </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pengembangan metode untuk transformasi model otomatis dan otomatis. </font></font></li></ol><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tugas praktis </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seiring dengan tugas-tugas teoritis untuk pengembangan dan implementasi paradigma yang dijelaskan dalam praktik rekayasa perangkat lunak, perlu untuk menyelesaikan setidaknya masalah praktis berikut: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pembuatan alat untuk: a) Ekstraksi dan pemasangan model mental. </font><font style="vertical-align: inherit;">b) Transformasi mental model secara otomatis dan otomatis menjadi model menengah. </font><font style="vertical-align: inherit;">c) Jejak dan perkiraan perubahan dalam isi model yang dapat ditransformasikan</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pembuatan literatur teknis dan pendidikan yang diperlukan dan materi pendidikan medial lainnya. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Organisasi forum dan konferensi tentang hal ini </font></font></li></ol><br><h2>  Kesimpulan </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel ini mencoba untuk mendefinisikan paradigma rekayasa perangkat lunak sebagai perwujudan gagasan. </font><font style="vertical-align: inherit;">Kata untuk mendefinisikan (dan tidak terbuka) digunakan di sini bukan secara kebetulan. </font><font style="vertical-align: inherit;">Bahkan, peserta dalam proyek-proyek TI telah lama terlibat dalam penciptaan, transformasi dan penggunaan model, mungkin tanpa disadari. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam pengertian definisi Kuhn yang ketat, pendekatan yang dideskripsikan belum dapat mengklaim hak untuk disebut paradigma, tetapi hanya kandidat untuk paradigma, karena ia tidak memiliki komunitas luas orang yang mendukungnya dan sistem yang dikembangkan dengan baik dari model yang saling berhubungan. </font><font style="vertical-align: inherit;">Namun, saya ingin percaya bahwa kekurangan akan segera diatasi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah artikel pertama dari serangkaian artikel yang direncanakan. </font><font style="vertical-align: inherit;">Dalam artikel berikut ini saya akan berbicara tentang model mental dan menengah.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sastra </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Daftar Istilah Standar IEEE untuk Terminologi Rekayasa Perangkat Lunak, IEEE std 610.12-1990, 1990. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Kuhn, Thomas S. Struktur Revolusi Ilmiah. Edisi ke-3. Chicago, IL: University of Chicago Press, 1996. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Paradigma pemrograman: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en.wikipedia.org/wiki/Programming_paradigm</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (negara bagian - 08/27/2018) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Peter A. Henning, Holger Vogelsang Taschenbuch Programmiersprachen. Carl Hanser Verlag GmbH &amp; Co. KG; Auflage: 2., neu bearbeitete (5. September 2007). ISBN-13: 978-3446407442. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Paradigma Dan Model Rekayasa Perangkat Lunak Esai Teknologi Informasi </font></font><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.uniassignment.com/essay-samples/information-technology/software-engineering-paradigms-and-models-information-technology-essay.php</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (state - </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">08.28.2018</font></a><font style="vertical-align: inherit;"> )</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. Reifikasi (ilmu komputer) </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en.wikipedia.org/wiki/Reification_</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (computer_science) (negara bagian - 08/27/2018) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. Fedor Ivanovich Tyutchev. </font><font style="vertical-align: inherit;">Silentium! </font><font style="vertical-align: inherit;">(Silence (lat.), 1829. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8. Borovik, Alexandre. Matematika di bawah mikroskop: catatan tentang aspek kognitif dari praktik matematika. American Mathematical Society. ISBN-13: 978-0821847619. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ilustrasi: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">geralt</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425321/">https://habr.com/ru/post/id425321/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425305/index.html">Bagaimana The Chemical Brothers Tampilkan Mengatur: Detail Teknis dan Pengalihan</a></li>
<li><a href="../id425311/index.html">Buku "Pemrograman untuk anak-anak. Dari dasar-dasar untuk membuat robot</a></li>
<li><a href="../id425313/index.html">10 ekstensi Kode VS terbaik 2018 untuk pengembang front-end</a></li>
<li><a href="../id425315/index.html">Mengatur penyimpanan kode di GitLab dan mengintegrasikan tinjauan kode ke GitFlow</a></li>
<li><a href="../id425317/index.html">Cara melakukannya: kita menulis "Minesweeper" dalam 4 menit</a></li>
<li><a href="../id425323/index.html">"Lubang kelinci." Desainer UX dalam tim produk</a></li>
<li><a href="../id425325/index.html">Penerjemah Bytecode DIY</a></li>
<li><a href="../id425327/index.html">Pemrograman fungsional: mengukur tujuh kali, potong sekali</a></li>
<li><a href="../id425329/index.html">Beberapa saran untuk generasi milenium dari "oldies." Cara sukses di dunia digital kita</a></li>
<li><a href="../id425331/index.html">Alice akan membantu pengembang menemukan objek dalam permintaan pengguna. NER dalam Dialog</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>