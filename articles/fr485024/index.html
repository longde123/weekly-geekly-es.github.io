<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙍🏽 👨🏾‍🔧 😧 Qu'est-ce qui se cache sous le capot des optimisations du compilateur GraalVM? 🏗️ 👊🏽 🐟</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous continuons à traiter du travail de GraalVM, et cette fois nous avons une traduction de l'article d'Aleksandar Prokopec «Sous le capot des optimis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Qu'est-ce qui se cache sous le capot des optimisations du compilateur GraalVM?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/485024/"><p>  Nous continuons à traiter du travail de GraalVM, et cette fois nous avons une traduction de l'article d'Aleksandar Prokopec «Sous le capot des optimisations GraalVM JIT», initialement publié sur le <a href="https://medium.com/graalvm/under-the-hood-of-graalvm-jit-optimizations-d6e931394797">blog de Medium</a> .  L'article contient des liens intéressants, nous essaierons ensuite de traduire ces articles également. </p><br><p><img src="https://habrastorage.org/webt/k-/0k/fz/k-0kfzbwnfrk_hswloa6dyyftjc.jpeg"></p><br><hr><br><p>  <a href="https://medium.com/graalvm/stream-api-performance-with-graalvm-be6cfe7fbb52">La dernière fois à Medium,</a> nous avons examiné les problèmes de performances de l'API Java Streams sur GraalVM par rapport à Java HotSpot VM.  <a href="https://www.graalvm.org/">GraalVM</a> se caractérise par des performances élevées, et dans ces expériences, nous avons atteint une accélération de 1,7 à 5 fois.  Bien sûr, les valeurs spécifiques du gain de performances dépendront toujours du code que vous exécutez et des données de chargement, donc avant de tirer des conclusions, vous devez essayer d'exécuter votre code sur GraalVM vous-même. </p><br><p>  Dans cet article, nous approfondirons l'intérieur de GraalVM et verrons comment se déroule la compilation JIT. </p><br><a name="habracut"></a><br><h2>  <font color="#D93740">Optimisations JIT dans GraalVM</font> </h2><br><p>  Jetons un coup d'œil à un certain nombre d'optimisations de haut niveau que le compilateur GraalVM utilise.  Dans cet article, nous n'aborderons que les optimisations les plus intéressantes ainsi que des exemples spécifiques de leur travail.  Si vous voulez approfondir, une bonne vue d'ensemble des optimisations du compilateur GraalVM est dans le travail intitulé <a href="https://www.researchgate.net/publication/320359502_Making_collection_operations_optimal_with_aggressive_JIT_compilation">«Optimiser les opérations de collecte avec une compilation JIT agressive»</a> . </p><br><h2>  <font color="#D93740">Inlining</font> </h2><br><p>  Si vous ne touchez pas l'assemblage à l'avance, la plupart des compilateurs JIT des machines virtuelles modernes effectuent une analyse en interne.  Cela signifie qu'à chaque instant, il y a une analyse d'une méthode.  Pour cette raison, l'analyse intraprocédurale est beaucoup plus rapide que l'analyse interprocédurale de l'ensemble du programme, qui n'a généralement pas le temps de terminer dans le temps alloué pour le travail du compilateur JIT.  Dans un compilateur qui utilise des optimisations intra-procédurales (par exemple, l'optimisation d'une méthode à la fois), l'une des optimisations fondamentales les plus importantes est l'inline.  L'inclusion est importante car elle augmente efficacement la méthode, ce qui signifie que le compilateur peut voir plus d'opportunités pour optimiser simultanément plusieurs morceaux de code utilisés dans des méthodes apparemment sans rapport. </p><br><p> Prenons, par exemple, la méthode <code>volleyballStars</code> d'un article précédent: </p><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volleyballStars</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Arrays.stream(people) .map(p -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(p.hair, p.age + <span class="hljs-number"><span class="hljs-number">1</span></span>, p.height)) .filter(p -&gt; p.height &gt; <span class="hljs-number"><span class="hljs-number">198</span></span>) .filter(p -&gt; p.age &gt;= <span class="hljs-number"><span class="hljs-number">18</span></span> &amp;&amp; p.age &lt;= <span class="hljs-number"><span class="hljs-number">21</span></span>) .mapToInt(p -&gt; p.age) .average().getAsDouble(); }</code> </pre> <br><p>  Dans ce diagramme, nous voyons des parties de la représentation intermédiaire (IR) de cette méthode dans GraalVM, au moment qui suit immédiatement l'analyse du bytecode Java correspondant. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1cb/b4f/fd1/1cbb4ffd15a4c171de823accd8830071.png"></p><br><p>  Vous pouvez considérer cet IR comme une sorte d' <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">arbre de syntaxe abstraite</a> sur les stéroïdes - grâce à lui, certaines optimisations sont plus faciles à effectuer.  Peu importe le fonctionnement de cet IR, mais si vous souhaitez comprendre ce sujet plus en profondeur, vous pouvez consulter un document intitulé <a href="http://citeseerx.ist.psu.edu/viewdoc/download%3Fdoi%3D10.1.1.726.5496%26amp%3Brep%3Drep1%26amp%3Btype%3Dpdf">«Graal IR: une représentation intermédiaire déclarative extensible»</a> . </p><br><p>  La principale conclusion ici est que le flux de contrôle de la méthode indiquée par les nœuds jaunes du graphique et les lignes rouges exécute séquentiellement les méthodes de l'interface <code>Stream</code> : <code>Stream.filter</code> , <code>Stream.mapToInt</code> , <code>IntStream.average</code> .  Faute d'une connaissance précise de ce qui se trouve dans le code de ces méthodes, le compilateur n'est pas en mesure de simplifier la méthode - et ici l'inlining vient à la rescousse! </p><br><p>  Une transformation appelée inlining est une chose très compréhensible: elle cherche juste des endroits pour appeler des méthodes et les remplace par le corps de la méthode inline correspondante, les incorpore à l'intérieur.  Jetons un coup d'œil à l'IR de la méthode <code>volleyballStars</code> après avoir intégré une partie des méthodes.  Seule la partie qui suit l'appel <code>IntStream.average</code> est <code>IntStream.average</code> : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d5a/717/c71/d5a717c711a64a653ae7784f5557a2e5.png"></p><br><p>  Le diagramme montre que l'appel à <code>getAsDouble</code> (noeud numéro 71) a disparu de l'IR.  Notez que la méthode <code>getAsDouble</code> de l'objet <code>getAsDouble</code> renvoyé par <code>IntStream.average</code> (le dernier appel de la méthode <code>volleyballStars</code> ) est définie dans le JDK comme suit: </p><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAsDouble</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isPresent) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NoSuchElementException(<span class="hljs-string"><span class="hljs-string">"No value present"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; }</code> </pre> <br><p>  Ici, nous pouvons trouver le chargement du champ <code>isPresent</code> (numéro de nœud 190, <code>LoadField</code> ) et lire le champ de <code>value</code> .  Toutefois, il ne reste aucune trace de l'exception <code>NoSuchElementException</code> et il n'y a plus de code qui la <code>NoSuchElementException</code> . </p><br><p>  C'est parce que le compilateur GraalVM suppose: la méthode <code>volleyballStars</code> ne lèvera jamais d'exception.  Cette connaissance n'est généralement pas disponible lors de la compilation de <code>getAsDouble</code> - elle peut être appelée depuis de nombreux endroits différents dans le programme, et dans certains autres cas, l'exception fonctionnera toujours.  Cependant, dans une méthode particulière de <code>volleyballStars</code> , il est peu probable qu'une exception se produise car l'ensemble des stars potentielles du volleyball n'est jamais vide.  Pour cette raison, GraalVM supprime la branche et insère <code>FixedGuard</code> - un nœud qui <code>FixedGuard</code> le code en cas de violation de notre hypothèse.  Il s'agit d'un exemple assez minimaliste, et dans la vie réelle, il existe des cas beaucoup plus compliqués de la façon dont l'inclusion aide d'autres optimisations. </p><br><p>  Nous savons que l'arborescence des appels de programme est généralement très profonde, voire infinie.  Par conséquent, l'incrustation à un moment donné doit être arrêtée - elle a des restrictions très spécifiques sur le temps de fonctionnement et la taille de la mémoire.  Sachant cela, il devient clair: déterminer quoi et quand s'aligner est très difficile. </p><br><h2>  <font color="#D93740">Doublure polymorphe</font> </h2><br><p>  L'inclusion ne fonctionne que si le compilateur peut déterminer la méthode spécifique à laquelle l'opération d'appel de méthode est destinée.  Mais en Java, il existe généralement de nombreux appels indirects pour les méthodes dont les implémentations sont inconnues en statique, qui sont recherchées lors de l'exécution à l'aide de la répartition virtuelle. </p><br><p>  Par exemple, prenez la méthode <code>IntStream.average</code> .  Son implémentation typique ressemble à ceci: </p><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> OptionalDouble </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">average</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>[] avg = collect( () -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>], (ll, i) -&gt; { ll[<span class="hljs-number"><span class="hljs-number">0</span></span>]++; ll[<span class="hljs-number"><span class="hljs-number">1</span></span>] += i; }, (ll, rr) -&gt; { ll[<span class="hljs-number"><span class="hljs-number">0</span></span>] += rr[<span class="hljs-number"><span class="hljs-number">0</span></span>]; ll[<span class="hljs-number"><span class="hljs-number">1</span></span>] += rr[<span class="hljs-number"><span class="hljs-number">1</span></span>]; }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> avg[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? OptionalDouble.of((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) avg[<span class="hljs-number"><span class="hljs-number">1</span></span>] / avg[<span class="hljs-number"><span class="hljs-number">0</span></span>]) : OptionalDouble.empty(); }</code> </pre> <br><p>  Ne laissez pas l'apparente simplicité du code vous tromper!  Cette méthode est définie en termes d'appels à <code>collect</code> , et la magie opère ici.  L'arborescence des appels de cette méthode (par exemple, la hiérarchie des appels) se développe rapidement à mesure que nous approfondissons la <code>collect</code> .  Jetez un œil à ce diagramme: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/584/306/ce3/584306ce380584ae1266e1026040389f.png"></p><br><p>  À partir d'un certain point du processus de traversée de l'arborescence des appels, l'inliner repose contre l'appel <code>opWrapSink</code> du framework de <code>opWrapSink</code> Java, qui est une méthode abstraite: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/be4/43b/b46/be443bb464f938c962b8649ef26de75d.png"></p><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function">&lt;P_IN&gt; Sink&lt;P_IN&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrapSink</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sink&lt;P_OUT&gt; sink)</span></span></span></span>;</code> </pre> <br><p>  Habituellement, un inliner n'ira pas plus loin, car il s'agit d'un appel indirect.  La détermination d'une méthode spécifique ne se produira que pendant l'exécution du programme, et maintenant l'incrustateur ne sait tout simplement pas sur quoi il continuera de travailler. </p><br><p>  Dans le cas de GraalVM, quelque chose d'autre se produit: il enregistre un profil du type de la méthode cible pour chaque point d'appel indirect.  Ce profil est essentiellement juste un tableau qui indique à quelle fréquence chacune des implémentations de <code>wrapSink</code> été <code>wrapSink</code> .  Dans notre cas, le profil connaît trois implémentations différentes dans les classes anonymes: <code>ReferencePipeline$2</code> , <code>ReferencePipeline$3</code> , <code>ReferencePipeline$4</code> .  Ces implémentations sont appelées avec une probabilité de 50%, 25% et 25%, respectivement. </p><br><br><pre> <code class="plaintext hljs">0.500000: Ljava/util/stream/ReferencePipeline$2; 0.250000: Ljava/util/stream/ReferencePipeline$4; 0.250000: Ljava/util/stream/ReferencePipeline$3; notRecorded: 0.000000</code> </pre><br><p>  Ces informations fournissent une assistance inestimable au compilateur, vous permettant de générer <em>typeswitch</em> - une courte <code>switch</code> qui vérifie le type de la méthode lors de l'exécution, puis appelle une méthode spécifique pour chacun des cas ci-dessus.  L'image ci-dessous montre une partie de la vue intermédiaire montrant un commutateur de type (trois <code>if</code> nœuds) avec une vérification pour voir si le type de destinataire est quelqu'un de <code>ReferencePipeline$2</code> , <code>ReferencePipeline$3</code> ou <code>ReferencePipeline$4</code> .  Chaque appel direct dans le branchement réussi de chacune des vérifications <code>InstanceOf</code> peut maintenant être en ligne ou y connecter des optimisations supplémentaires.  Si aucun des types ne réussit le test, le code est désoptimisé dans le nœud <code>Deopt</code> (comme alternative, vous pouvez exécuter la répartition virtuelle). </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/26e/688/ca8/26e688ca89ea6c397b72f9acaba08ff3.png"></p><br><p>  Si vous voulez mieux comprendre l'incrustation polymorphe, je recommande le travail classique sur ce sujet, <a href="https://dl.acm.org/citation.cfm%3Fid%3D679839">«Inlining of Virtual Methods»</a> . </p><br><h2>  <font color="#D93740">Analyse d'échappement partielle</font> </h2><br><p>  Revenons à notre exemple de volleyball.  Notez <code>Person</code> objets <code>Person</code> alloués à l'intérieur du lambda passé à la fonction <code>map</code> n'échappe à la portée de la méthode <code>volleyballStars</code> .  En d'autres termes, au moment où la méthode <code>volleyballStars</code> se termine, il n'y a pas une telle zone de mémoire qui pointerait vers des objets de type <code>Person</code> .  En particulier, l'enregistrement de la valeur <code>getHeight</code> est en outre utilisé uniquement pour le filtrage de la hauteur. </p><br><p>  À un moment donné lors de la compilation de la méthode <code>volleyballStars</code> , nous arrivons à l'IR montré dans le diagramme ci-dessous.  Le bloc commençant par le nœud <code>Begin</code> -1621 commence par l'allocation de l'objet <code>Person</code> (dans le nœud <code>Alloc</code> ), qui est initialisé à la fois avec la valeur du champ <code>age</code> avec un incrément de 1 et la valeur précédente du champ <code>height</code> .  Le champ de <code>height</code> est précédemment lu dans le nœud <code>LoadField</code> -1539.  Le résultat de l'allocation est encapsulé dans AllocatedObject -2137 et envoyé à l'appel de méthode <code>accept</code> -1625.  Le compilateur ne peut rien faire de plus en ce moment - de son point de vue, l'objet s'est échappé de la méthode <code>volleyballStars</code> .  ( <em>Note du traducteur: «fuir un objet» est appelé «échapper» en anglais, d'où le nom de l'optimisation est «analyse d'échappement»</em> ). </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a02/cca/495/a02cca495ad607770a0111040e0a724a.png"></p><br><p>  Après cela, le compilateur décide d'insérer l'appel d' <code>accept</code> - cela semble raisonnable.  En conséquence, nous arrivons à l'IR suivant: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/334/5b9/029/3345b90295b77a64ded506f3042a146a.png"></p><br><p>  Et ici, le compilateur JIT commence une analyse d'échappement partielle: il remarque que <code>AllocatedObject</code> utilisé que pour lire le champ <code>height</code> (rappel, la <code>height</code> utilisée que dans la condition de filtrage, vérifiez que la hauteur est supérieure à 198).  Par conséquent, le compilateur peut réaffecter la lecture du champ <code>height</code> -2167 afin de travailler directement avec le nœud qui est précédemment écrit dans l'objet <code>Person</code> (nœud <code>Alloc</code> -2136), et c'est notre <code>LoadField</code> -1539.  De plus, le nœud <code>Alloc</code> ci-après ne va pas à l'entrée d'un autre nœud, vous pouvez donc simplement le supprimer - c'est du code mort! </p><br><p>  Cette optimisation est, en fait, la principale raison pour laquelle l'exemple <code>volleyballStars</code> connu une accélération quintuple après le passage à GraalVM.  Même si tous les objets <code>Person</code> ne sont pas nécessaires et sont supprimés immédiatement après leur création, ils doivent toujours être alloués sur le tas, leur mémoire doit encore être initialisée.  L'analyse d'échappement partielle vous permet d'éliminer les allocations ou de les reporter en les déplaçant vers les branches de code où les objets s'enfuient vraiment et qui se produisent beaucoup moins souvent. </p><br><p>  Vous pouvez obtenir une compréhension plus approfondie de l'analyse d'échappement partielle dans un article intitulé <a href="http://www.ssw.uni-linz.ac.at/Research/Papers/Stadler14/Stadler2014-CGO-PEA.pdf">Analyse d'échappement partielle et remplacement scalaire pour Java</a> . </p><br><h2>  <font color="#D93740">Résumé</font> </h2><br><p>  Dans cet article, nous avons examiné trois optimisations GraalVM: l'incrustation, l'incrustation polymorphe et l'analyse d'échappement partielle.  Il existe de nombreuses autres optimisations différentes: promotion et fractionnement des cycles, duplication des chemins, numérotation des valeurs globales, convolution des constantes, suppression du code mort, exécution spéculative, etc. </p><br><p>  Si vous souhaitez en savoir plus sur le fonctionnement de GraalVM, n'hésitez pas à ouvrir la <a href="http://www.graalvm.org/community/publications/">page de publication</a> .  Si vous voulez vous assurer que GraalVM peut accélérer votre code, vous pouvez <a href="https://www.graalvm.org/downloads/">télécharger les binaires</a> et l'essayer vous-même. </p><br><hr><br><h2>  <font color="#D93740">Du traducteur: matériel supplémentaire</font> </h2><br>  Lors de conférences, JPoint et Joker parlent souvent de GraalVM.  Par exemple, au dernier JPoint 2019, Thomas Wuerthinger (directeur de recherche chez Oracle Labs, responsable de GraalVM) et Oleg Shelaev, l'un des deux évangélistes technologiques officiels, nous ont rendu visite. <br><br>  Vous pouvez regarder ces vidéos et d'autres sur notre chaîne YouTube: <br><br><ul><li>  Thomas Wuerthinger: <a href="https://www.youtube.com/watch%3Fv%3DR_SeDk16PLY">«Maximiser les performances avec GraalVM»</a> </li><li>  Oleg Shelaev: <a href="https://www.youtube.com/watch%3Fv%3DC5fATKdVxZ0">«Supercompilation, évaluation partielle, projections Futamura et comment GraalVM sauvera le monde»</a> </li><li>  Roberto Cortez: <a href="https://www.youtube.com/watch%3Fv%3DoY8sfg7A1kg">«GraalVM et MicroProfile: une solution de microservices polyglottes»</a> </li><li>  Ionut Balosin: <a href="https://www.youtube.com/watch%3Fv%3DRYLEIRHWsVo">«Une course de deux compilateurs: GraalVM JIT contre HotSpot JIT C2.</a>  <a href="https://www.youtube.com/watch%3Fv%3DRYLEIRHWsVo">Lequel offre de meilleures performances d'exécution? "</a> </li></ul><br><blockquote>  Nous vous rappelons que le prochain JPoint se tiendra du 15 au 16 mai 2020 à Moscou, et les billets peuvent déjà être achetés <a href="https://jpoint.ru/registration/%3Futm_source%3Dhabr%26utm_medium%3D485024%26utm_campaign%3Djpoint20">sur le site officiel</a> . </blockquote><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr485024/">https://habr.com/ru/post/fr485024/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr485012/index.html">Comment utiliser Control Inversion en JavaScript et Reactjs pour simplifier la gestion du code</a></li>
<li><a href="../fr485014/index.html">Dois-je me plaindre des entretiens?</a></li>
<li><a href="../fr485016/index.html">Bases de données gérées chez Selectel: Bienvenue dans la version bêta</a></li>
<li><a href="../fr485018/index.html">Écriture de shaders avec du code dans Unity LWRP</a></li>
<li><a href="../fr485022/index.html">Playme Sigma: DVR fonctionnel et abordable</a></li>
<li><a href="../fr485026/index.html">Les opportunités de la Géorgie pour les professionnels de l'informatique</a></li>
<li><a href="../fr485028/index.html">CRM 2020</a></li>
<li><a href="../fr485030/index.html">Les 8 principaux frais IEO et leur capitalisation maintenant</a></li>
<li><a href="../fr485032/index.html">Comment accélérer une application React avec le co-hébergement d'état</a></li>
<li><a href="../fr485034/index.html">Automatisation de la construction d'un projet Qt sous Windows dans Travis CI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>