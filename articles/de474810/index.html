<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úçüèº üëÉüèΩ üßëüèº Funktionsweise der Kryptographie mit elliptischen Kurven in TLS 1.3 üêè üçΩÔ∏è üñãÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einige Leserbenachrichtigungen: 

 Um den Beschreibungsprozess (etwas) zu vereinfachen und das Volumen des Artikels, den wir schreiben werden, zu verr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funktionsweise der Kryptographie mit elliptischen Kurven in TLS 1.3</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/qrator/blog/474810/"><img src="https://hsto.org/webt/qy/r5/a6/qyr5a6ywaf8vbc2kxtaazdmvgz8.png" alt="Bild"><br><br>  Einige Leserbenachrichtigungen: <br><br>  Um den Beschreibungsprozess (etwas) zu vereinfachen und das Volumen des Artikels, den wir schreiben werden, zu verringern, ist es wichtig, sofort eine wichtige Bemerkung zu machen und die Hauptbeschr√§nkung anzugeben - alles, was wir Ihnen heute zum Praktischen sagen werden Seite der Problematik ist nur in Bezug auf TLS 1.3 realisierbar.  Das bedeutet, dass Ihr ECDSA-Zertifikat zwar weiterhin in TLS 1.2 funktioniert, wenn Sie dies w√ºnschen, jedoch Abw√§rtskompatibilit√§t bietet. Die Beschreibung des tats√§chlichen Handshake-Prozesses, der Verschl√ºsselungsverfahren und der Client-Server-Benchmarks bezieht sich jedoch nur auf TLS 1.3.  Dies bezieht sich nat√ºrlich nicht auf die mathematische Beschreibung von Algorithmen hinter modernen Verschl√ºsselungssystemen. <br><br>  Dieser Artikel wurde weder von einem Mathematiker noch von einem Ingenieur verfasst - obwohl diese dabei halfen, einen Weg um die gruselige Mathematik zu finden, und diesen Artikel rezensierten.  Vielen Dank an die Mitarbeiter von Qrator Labs. <br><br><h3>  ( <b>E</b> lliptic <b>C</b> urve) <b>D</b> iffie- <b>H</b> ellman ( <b>E</b> phemeral) </h3> <b>Das Diffie-Hellman-Erbe im 21. Jahrhundert</b> <br><br>  Nat√ºrlich hat dies weder mit Diffie noch mit Hellman begonnen.  Um jedoch eine korrekte Zeitachse bereitzustellen, m√ºssen wir auf die wichtigsten Daten und Ereignisse hinweisen. <br><br>  Bei der Entwicklung der modernen Kryptographie gab es mehrere bedeutende Pers√∂nlichkeiten.  Vor allem Alan Turing und Claud Shannon haben beide unglaublich viel Arbeit auf dem Gebiet der Rechnungs- und Informationstheorie sowie der allgemeinen Kryptoanalyse geleistet, und sowohl Diffie als auch Hellman wurden offiziell die Idee des √∂ffentlichen Schl√ºssels zugeschrieben (oder sogenannte asymmetrische) Kryptographie (obwohl bekannt ist, dass es in Gro√übritannien ernsthafte Fortschritte in der Kryptographie gab, die sehr lange im Verborgenen blieben), die diese beiden Herren zu Pionieren machten. <br><br>  In was genau? <br><a name="habracut"></a><br>  Nun, das mag merkw√ºrdig klingen.  Vor dem 6. November 1976 gab es jedoch keine √∂ffentlichen Kenntnisse √ºber Verschl√ºsselungssysteme mit √∂ffentlichem Schl√ºssel.  Whitfield Diffie und Martin Hellman (und tats√§chlich Ralph Merkle) - Mathematiker, Computeringenieure und Enthusiasten sowie Kryptologen waren die ersten. <br><br>  F√ºr diejenigen, die sich nicht bewusst sind - aufgrund der Rolle, die die Kryptoanalyse w√§hrend des Zweiten Weltkriegs einnahm, und ihrer enormen Auswirkung auf die Geheimhaltung von Informationen -, haben die beiden L√§nder, die sie f√ºr am weitesten fortgeschritten hielten, die Verschl√ºsselung in ihre Munitionslisten aufgenommen und genutzt ein starkes Exportverbot (das gleichzeitig die Implementierung der Verschl√ºsselung f√ºr den privaten und gewerblichen Gebrauch im Inland schw√§cht).  Aus diesem Grund wurden die britischen Forscher, die im Government Communications Headquarters an der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20141030210530/">Technik des Austauschs asymmetrischer Schl√ºssel arbeiteten</a> und ein analoges Schema entwickelten, f√ºr diese Erfindung erst 1997 anerkannt, als Beschr√§nkungen f√ºr Kryptografiealgorithmen und deren Beschreibung unwirksam wurden. <br><br>  Zur√ºck zu unseren beiden Erfindern - was haben Diffie und Hellman konkret revolutioniert? <br><br>  Werfen wir einen Blick auf ihre Originalarbeit und veranschaulichen den gro√üen Sprung, den sie eingef√ºhrt haben (sogar theoretisch mit ihrer Forschungsarbeit): <br><img src="https://habrastorage.org/webt/tt/rb/ig/ttrbigv4-qiw2ugkittwgox65se.png" alt="Bild"><br>  Und der folgende: <br><img src="https://habrastorage.org/webt/3c/n5/6g/3cn56g2moitap1tsu-dpsnspfc4.png" alt="Bild"><br>  Diese beiden Bilder veranschaulichen perfekt die enorme Ver√§nderung, die Whitfield Diffie und Martin Hellman nach der Kryptographie und Kryptoanalyse in Jahrhunderten der Evolution eingef√ºhrt haben - die Etablierung eines gemeinsamen geheimen Schl√ºssels als Ergebnis einer kryptographischen Berechnung. <br><br>  Schauen wir uns ein weiteres gutes Bild mit Farben an: <br><br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/46/Diffie-Hellman_Key_Exchange.svg/375px-Diffie-Hellman_Key_Exchange.svg.png" alt="Bild"><br><br>  Es erkl√§rt, was los ist.  Vor der Erfindung der Diffie- und Hellman-Schl√ºsselvereinbarung gab es nur einen symmetrischen Schl√ºssel - er wurde sowohl zum Ver- als auch zum Entschl√ºsseln der Nachricht verwendet.  Wenn Sie jemandem einen solchen ‚ÄûSchl√ºssel‚Äú geben m√∂chten, muss dieser √ºber einen ‚Äûsicheren‚Äú Kanal √ºbertragen werden.  Sie k√∂nnen sich sofort alle Einschr√§nkungen eines solchen Schemas der vorherigen Generation vorstellen - Sie ben√∂tigen einen bereits eingerichteten sicheren Kanal, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">k√∂nnen den Schl√ºssel nicht wiederverwenden</a> , und im Idealfall sollte die L√§nge des Schl√ºssels der L√§nge der Nachricht entsprechen. <br><br>  Claude Shannon hat in seiner in der Kriegszeit klassifizierten Arbeit " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Communication Theory of Secrecy Systems</a> " bewiesen, dass alle theoretisch unzerbrechlichen Chiffren die gleichen Anforderungen erf√ºllen m√ºssen wie die einmalige Unterlage - bekannt als Vernam-Chiffre - vom Autor dieser symmetrischen polyalphabetischen Stream-Chiffre. <br><br>  Wir werden uns noch einmal das Originalpapier ansehen: <br><img src="https://habrastorage.org/webt/p1/p0/yf/p1p0yfmprijaobfof3kb2lu4bpk.png" alt="Bild"><br><br>  Bevor wir weitermachen, fragen wir uns, wie zwei, wenn auch brillante, Menschen auf einem angewandten Gebiet mit einer solchen Geschichte, insbesondere zur Zeit des Krieges, zu einer so signifikanten Verbesserung gekommen sind. <br>  Nun, wegen der: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationstheorie</a> , formuliert von Claude Shannon; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Berechnungstheorie</a> , die insbesondere von Alonzo Church, John von Neumann und Alan Turing beeinflusst wird; </li><li>  Und, was noch wichtiger ist, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Berechenbarkeitstheorie</a> basiert haupts√§chlich auf Turings Arbeiten, die wir alle zur gleichen Zeit des 20. Jahrhunderts entwickelt und gereift haben.  Diffie und Hellman nannten beide Claude Shannon als den wichtigsten Einflussfaktor ihrer Arbeit. </li></ul><br>  Lenstras " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Universal Security</a> " veranschaulicht die Energiemenge, die ben√∂tigt wird, um das symmetrische Kryptosystem mit verschiedenen Schl√ºssell√§ngen zu "brechen".  Es stellte sich heraus, dass das Brechen eines 228 Bit langen, elliptischen Kurvenschl√ºssels dieselbe Energiemenge erfordert, die zum Kochen des gesamten Wassers auf der Erde erforderlich ist.  Sie gilt jedoch nur unter Ber√ºcksichtigung bekannter Algorithmen und Hardware, da streng genommen niemand wei√ü, ob es wesentlich effizientere Algorithmen oder Hardware gibt.  Der 228-Bit-EC-Schl√ºssel ist vergleichbar mit dem 2380-Bit-langen RSA-Schl√ºssel, dazu sp√§ter mehr.  Obwohl bei dieser Sch√§tzung sowohl RSA- als auch EC-Schl√ºssel in einem asymmetrischen Verschl√ºsselungsschema verwendet werden, entsprechen solche Schl√ºssell√§ngen in gewisser Weise einem symmetrischen 128-Bit-Verschl√ºsselungsschl√ºssel. <br><br>  Es ist leicht vorstellbar, dass etwas ‚ÄûSchwer zu berechnendes‚Äú viel Energie und / oder Zeit f√ºr die Berechnung ben√∂tigt.  Wir neigen dazu zu denken, dass Computer "alles berechnen" k√∂nnen, aber es stellt sich heraus, dass es nicht wahr ist.  Erstens gibt es unbestreitbare Beispiele wie das Halteproblem, obwohl wir auf dem Gebiet der Kryptographie diese Falle umgehen k√∂nnen.  Zweitens kann die Zeit, die f√ºr die Ausf√ºhrung eines bestimmten Algorithmus ben√∂tigt wird, beliebig hoch sein.  Das nutzen wir in der Kryptographie.  Ein Problem wird als ‚Äûeinfach‚Äú zu berechnen angesehen, wenn die f√ºr die Ausf√ºhrung des jeweiligen Algorithmus erforderliche Zeit wie bei einem Polynom von der Eingangsgr√∂√üe (in Bits gemessen) abh√§ngt: <math> </math> $ inline $ T (n) = O (n ^ k) $ inline $   f√ºr eine positive Konstante <math> </math> $ inline $ k $ inline $   .  Im Bereich der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">rechnergest√ºtzten Komplexit√§tstheorie</a> bilden solche Probleme die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P-Komplexit√§tsklasse</a> . <br><br>  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P-Komplexit√§tsklasse</a> ist fast zentral, da sie das Problem darstellt, f√ºr das ein deterministischer polynomieller Zeitalgorithmus existiert.  Eine andere Komplexit√§tsklasse ist der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NP</a> (die Probleme, die ‚Äûschwer‚Äú zu berechnen sind), der eine Reihe von Entscheidungsproblemen darstellt, dh Probleme, die eine Antwort mit ‚ÄûJa‚Äú oder ‚ÄûNein‚Äú erfordern und deren Beweis in Polynomzeit √ºberpr√ºfbar ist.  Sehen Sie hier das Wort ‚ÄûBeweis‚Äú?  Hier gelangen wir zu den Fallt√ºrfunktionen, die zur NP-Komplexit√§tsklasse geh√∂ren. <br><br><img src="https://imgs.xkcd.com/comics/travelling_salesman_problem.png" alt="Bild"><br>  Credits: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">xkcd</a> <br><br><h3>  Einwegfunktionen;  Trapdoor-Funktionen </h3><br>  Per Definition ist eine Einwegfunktion eine Funktion, die bei jeder Eingabe einfach zu berechnen ist, die sich jedoch nur schwer umkehren l√§sst, dh die urspr√ºngliche Eingabe nur bei gegebener Ausgabe berechnet.  "Einfach" und "Schwer" beziehen sich auf die obigen Definitionen der Komplexit√§tstheorie.  Interessanterweise ist die Existenz von Einwegfunktionen nicht (mathematisch) bewiesen, da ihre Existenz beweisen w√ºrde, dass die P- und NP-Komplexit√§tsklassen nicht gleich sind, w√§hrend entweder P gleich NP ist oder nicht, heutzutage ein offenes Problem ist.  Denken Sie also daran, dass jede moderne Kryptographie auf unbewiesenen Hypothesen beruht. <br><br>  In ihrer Originalarbeit stellen Diffie und Hellman nun eine weitere Generation der Einwegfunktionen vor, die sie als "Fallt√ºrfunktionen" bezeichnen.  Wie unterscheiden sie sich? <br>  Wie sie in ihrem Leitartikel erkl√§ren: <blockquote>  In einem Kryptosystem mit √∂ffentlichem Schl√ºssel werden die Verschl√ºsselung und Entschl√ºsselung durch getrennte Schl√ºssel E und D geregelt, so dass die Berechnung von D aus E rechnerisch nicht durchf√ºhrbar ist (z. B. erforderlich) <math> </math> $ inline $ 10 ^ {100} $ inline $   Anweisungen).  Der Verschl√ºsselungsschl√ºssel E kann [in einem Verzeichnis] ‚Äã‚Äãohne Beeintr√§chtigung des Entschl√ºsselungsschl√ºssels D offenbart werden. Dies erm√∂glicht jedem Benutzer des Systems, eine Nachricht an einen anderen Benutzer zu senden, der derart verschl√ºsselt ist, dass nur der beabsichtigte Empf√§nger sie entschl√ºsseln kann. .. Das Problem der Authentifizierung ist m√∂glicherweise ein noch gr√∂√üeres Hindernis f√ºr die universelle Einf√ºhrung der Telekommunikation f√ºr Gesch√§ftstransaktionen als das Problem der Schl√ºsselverteilung ... [es] ... ist der Kern eines jeden Systems, das Vertr√§ge und Abrechnungen umfasst. </blockquote>  √úblicherweise werden die Kryptographiezeichen ‚ÄûAlice‚Äú und ‚ÄûBob‚Äú (f√ºr eine sichere Kommunikation) h√§ufig verwendet, um das Konzept des √∂ffentlichen Schl√ºssels zu erl√§utern.  Alice und Bob sind sich √ºber gro√üe ganze Zahlen einig <math> </math> $ inline $ n $ inline $   und <math> </math> $ inline $ g $ inline $   mit <math> </math> $ inline $ 1 &lt;g &lt;n $ inline $   .  Die Auswahl wirkt sich auf die Sicherheit des Systems aus.  ‚ÄûDer Modul <math> </math> $ inline $ n $ inline $   sollte eine Primzahl sein;  was noch wichtiger ist <math> </math> $ inline $ (n-1) / 2 $ inline $   sollte auch eine Primzahl sein &lt;...&gt; und <math> </math> $ inline $ g $ inline $   sollte eine primitive Wurzel Modulo sein <math> </math> $ inline $ n $ inline $   &lt;...&gt; [und] <math> </math> $ inline $ n $ inline $   sollte &lt;...&gt; mindestens 512 Bit lang sein. ‚Äù  Das Diffie - Hellman - Protokoll kann in 5 Schritten in elementarer Form angegeben werden. <br><br><ol><li>  Alice w√§hlt <math> </math> $ inline $ x $ inline $   (eine gro√üe zuf√§llige ganze Zahl) und berechnet <math> </math> $ inline $ X = g ^ x \ bmod n $ inline $ </li><li>  Bob w√§hlt <math> </math> $ inline $ y $ inline $   (eine gro√üe zuf√§llige ganze Zahl) und berechnet <math> </math> $ inline $ Y = g ^ y \ bmod n $ inline $ </li><li>  Alice schickt <math> </math> $ inline $ X $ inline $   zu Bob, w√§hrend Bob sendet <math> </math> $ inline $ Y $ inline $   zu Alice (sie behalten <math> </math> $ inline $ x $ inline $   und <math> </math> $ inline $ y $ inline $   Geheimnis voneinander) </li><li>  Alice rechnet <math> </math> $ inline $ k = Y ^ x \ bmod n $ inline $ </li><li>  Bob rechnet <math> </math> $ inline $ k '= X ^ y \ bmod n $ inline $ </li></ol><br>  Infolgedessen haben Alice und Bob den gleichen Wert <math> </math> $ inline $ k = k '$ inline $   das dient als gemeinsames Geheimnis. <br><br>  Die Trapdoor-Funktion ist eine Einwegfunktion, die es erm√∂glicht, ihre Umkehrung zu finden, wenn eine spezielle Information namens "Trapdoor" vorhanden ist.  Klingt einfach, obwohl es ziemlich schwierig ist, solche Funktionen zu finden - die erste realisierbare Methode bestand in der Implementierung eines asymmetrischen Verschl√ºsselungsalgorithmus f√ºr die Kryptografie mit √∂ffentlichem Schl√ºssel, der RSA genannt wurde und nach seinen Entwicklern Ron Rivest, Adi Shamir und Leonard Adleman benannt wurde. <br><br><h3>  RSA </h3><br>  In RSA beruht die H√§rte der Invertierung der Funktion auf der Tatsache, dass das Factoring (Finden von Primmultiplikatoren einer Zahl) viel mehr Zeit ben√∂tigt als das Multiplizieren, oder sollten wir hier sagen, dass es keine polynomielle Zeitmethode zum Factoring gro√üer Ganzzahlen auf einem klassischen Computer gibt Es wurde jedoch nicht nachgewiesen, dass keines existiert. <br><br>  In RSA gibt es wie in jedem anderen Verschl√ºsselungssystem mit √∂ffentlichem Schl√ºssel zwei Schl√ºssel: √∂ffentlich und privat.  RSA verwendet die Eingangsnachricht (dargestellt als Bitfolge) und wendet eine mathematische Operation (Exponentiation modulo a big integer) auf sie an, um ein Ergebnis zu erhalten, das nicht vom Zufall zu unterscheiden ist.  Die Entschl√ºsselung verwendet dieses Ergebnis und wendet einen √§hnlichen Vorgang an, um die urspr√ºngliche Nachricht wiederherzustellen.  Bei der asymmetrischen Kryptographie erfolgt die Verschl√ºsselung mit dem √∂ffentlichen Schl√ºssel und die Entschl√ºsselung mit dem privaten. <br><br>  Wie?  Weil die Operanden zu einer endlichen zyklischen Gruppe geh√∂ren (eine Menge von Ganzzahlen mit Multiplikation in modularer Arithmetik).  Computer k√∂nnen mit willk√ºrlich gro√üen Zahlen nicht gut umgehen, aber zum Gl√ºck besteht unsere zyklische Gruppe von Ganzzahlen darin, eine Operation mit der Bezeichnung "Umlauf" auszuf√ºhren - eine Zahl, die gr√∂√üer als das zul√§ssige Maximum ist, wird auf eine Zahl in dem g√ºltigen Bereich umlaufen, den wir betreiben .  Dies erm√∂glicht es uns, mit Schl√ºsseln zu arbeiten, die nicht l√§nger als sind.  In der Kryptographie mit elliptischen Kurven werden auch zyklische (multiplikative) Gruppen verwendet, die jedoch etwas anders aufgebaut sind, wie wir sp√§ter sehen werden. <br><br>  Grunds√§tzlich nimmt RSA zwei gro√üe Primzahlen und multipliziert sie, um den sogenannten Modul zu erhalten.  Alle anderen zu behandelnden Zahlen liegen zwischen Null und dem Modul.  Der Modul soll Teil des √∂ffentlichen Schl√ºssels sein, und seine Bitl√§nge bestimmt die Schl√ºssell√§nge.  Der zweite Teil des √∂ffentlichen Schl√ºssels ist eine Zahl zwischen Null und dem Euler-Totienten (moderne RSA-Implementierung verwendet den Carmichael-Totienten anstelle von Euler) des Moduls mit einigen zus√§tzlichen Einschr√§nkungen.  Schlie√ülich soll der private Schl√ºssel durch L√∂sen einer modularen Gleichung berechnet werden.  Um eine Zahl zu verschl√ºsseln, erh√∂hen wir sie einfach auf die Potenz, die dem √∂ffentlichen Schl√ºssel entspricht, und um eine Zahl zu entschl√ºsseln, erh√∂hen wir sie auf die Potenz, die dem privaten Schl√ºssel entspricht.  Aufgrund der Zyklizit√§t der Gruppe erhalten wir die urspr√ºngliche Nummer zur√ºck. <br><br>  Heutzutage gibt es zwei signifikante Probleme mit der RSA, eines ist eine Konsequenz des anderen.  Wenn die L√§nge eines Schl√ºssels (d. H. Die Anzahl seiner Bits) zunimmt, nimmt der Komplexit√§tsfaktor nicht so schnell zu, wie man es erwarten k√∂nnte.  Das liegt daran, dass es einen subexponentiellen (aber immer noch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">superpolynomiellen</a> ) Faktorisierungsalgorithmus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gibt</a> .  Um eine angemessene Sicherheitsstufe beizubehalten, muss die L√§nge des RSA-Schl√ºssels etwas schneller als die L√§nge des ECC-Schl√ºssels wachsen.  Aus diesem Grund sind die meisten heute verbreiteten RSA-Schl√ºssel entweder 2048 oder 3072 Bit lang. <br><br>  Etwas sp√§ter werden wir in Zahlen sehen, wie sich die L√§nge des Schl√ºssels auf die Gesamteffizienz des Kryptosystems auswirkt, indem wir das mit der Berechtigung Let's Encrypt signierte RSA- und ECDSA-Zertifikat vergleichen. <br><br><h3>  ( <b>E</b> lliptic <b>C</b> urve) Digitaler <b>S</b> ignature <b>A-</b> Algorithmus </h3><br>  Die Suche nach einer besseren Fallt√ºrfunktion f√ºhrte die Kryptografen schlie√ülich zu einem sich Mitte der 80er Jahre aktiv entwickelnden Zweig der Mathematik, der elliptischen Kurven gewidmet war. <br><br>  Es w√§re die ultimative Aufgabe, die Kryptographie mit elliptischen Kurven in einem Artikel zu beschreiben, also werden wir es nicht tun.  Schauen wir uns stattdessen eine Trapdoor-Funktion mit elliptischen Kurven an, die auf dem Problem des diskreten Logarithmus basiert. <br><br>  Es gibt viele Grundlagen und tiefere Einf√ºhrungen in die Kryptographie mit elliptischen Kurven, und wir w√ºrden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andrea Corbellinis ‚ÄûECC: eine sanfte Einf√ºhrung‚Äú</a> besonders empfehlen, wenn Sie sich f√ºr Mathematik interessieren. <br><br>  Was uns interessiert, sind eher "einfache" Parameter. <br><br>  Die elliptische Kurve wird durch eine Gleichung wie folgt definiert: <math> </math> $ inline $ y ^ 2 = x ^ 3 + ax + b $ inline $ <br>  Eine solche Kurve wird ben√∂tigt, um eine zyklische Untergruppe √ºber einem endlichen Feld aufzubauen.  Daher werden folgende Parameter verwendet: <br><br><ul><li>  Die <b>Bl√ºtezeit</b> <math> </math> <b>$ inline $ p $ inline $</b>   das gibt die Gr√∂√üe des endlichen Feldes an; </li><li>  Die <b>Koeffizienten</b> <math> </math> <b>$ inline $ a $ inline $</b>   <b>und</b> <math> </math> <b>$ inline $ b $ inline $</b>   der elliptischen Kurvengleichung; </li><li>  Der <b>Ausgangspunkt</b> <math> </math> <b>$ inline $ g $ inline $</b>   das erzeugt die erw√§hnte Untergruppe; </li><li>  Die <b>Bestellung</b> <math> </math> <b>$ inline $ n $ inline $</b>   der Untergruppe; </li><li>  Der <b>Cofaktor</b> <math> </math> <b>$ inline $ h $ inline $</b>   der Untergruppe. </li></ul><br>  Zusammenfassend ist der <b>Dom√§nenparameter</b> f√ºr unsere Algorithmen das <b>Sextuplett</b> <math> </math> $ inline $ (p, a, b, g, n, h) $ inline $   . <br>  Solche elliptischen Kurven wirken √ºber das endliche Feld <math> </math> $ inline $ \ mathbb {F} _p $ inline $   wo <math> </math> $ inline $ p $ inline $   ist eine ziemlich gro√üe Primzahl.  Wir haben also eine Reihe von Ganzzahlen modulo <math> </math> $ inline $ p $ inline $   , wobei Operationen wie Addition, Subtraktion, Multiplikation, additive Inverse, multiplikative Inverse m√∂glich sind.  Addition und Multiplikation funktionieren √§hnlich wie die modulare oder sogenannte "Clock" -Arithmetik, die wir in den RSA "Wrap Around" gesehen haben. <br>  Da die Kurve bei jedem Punkt symmetrisch zur x-Achse ist <math> </math> $ inline $ P $ inline $   k√∂nnen wir nehmen <math> </math> $ inline $ ‚àíP $ inline $   der Punkt gegen√ºber sein.  Wir nehmen <math> </math> $ inline $ ‚àíO $ inline $   gerecht zu sein <math> </math> $ inline $ O $ inline $   . <br>  Die Addition f√ºr Kurvenpunkte wird auf eine Weise definiert, die bestimmten Punkten entspricht <math> </math> $ inline $ P $ inline $   und <math> </math> $ inline $ Q $ inline $   k√∂nnen wir eine Linie zeichnen, die beide Punkte schneidet und eine Kurve in einem dritten Punkt schneidet <math> </math> $ inline $ R $ inline $   so das <math> </math> $ inline $ P + Q = -R $ inline $   und <math> </math> $ inline $ P + Q + R = 0 $ inline $   . <br><br>  Werfen wir einen Blick auf die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erkl√§rung von Marc Hughes</a> : <br><blockquote><img src="https://www.allaboutcircuits.com/uploads/articles/Curve_Cryptography_fig09.jpg" alt="Bild"><br><br>  Oben ist eine Linie mit konstanter Steigung dargestellt, die sich entlang der Oberfl√§che des Torus erstreckt.  Diese Linie verl√§uft durch zwei zuf√§llig ausgew√§hlte ganzzahlige Punkte auf der Kurve. <br><br><img src="https://www.allaboutcircuits.com/uploads/articles/Curve_Cryptography_fig10.gif" alt="Bild"><br><br>  Um zwei Punkte zum Diagramm hinzuzuf√ºgen, zeichnen Sie eine Linie vom ersten ausgew√§hlten Punkt <math> </math> $ inline $ P $ inline $   zum zweiten ausgew√§hlten Punkt <math> </math> $ inline $ Q $ inline $   , und verl√§ngern Sie die Linie, bis sie einen anderen Punkt im Diagramm schneidet <math> </math> $ inline $ -R $ inline $   bei Bedarf √ºber die Grundst√ºcksgrenzen hinweg erweitern. <br><br>  Wenn Sie einen ganzzahligen Punkt abfangen, spiegeln Sie den Punkt vertikal in der Mitte des Diagramms (eine orange gepunktete Linie), um den neuen Punkt zu finden <math> </math> $ inline $ R $ inline $   in der Grafik.  Deshalb <math> </math> $ inline $ P + Q = R $ inline $   . </blockquote>  Die Multiplikation mit einem Skalar ist jetzt trivial: <math> </math> $ inline $ n \ cdot P = P + P + P + \ dots + P $ inline $   (hier sind <math> </math> $ inline $ n $ inline $   summands). <br><br>  Die Fallt√ºrfunktion liegt hier im Problem des diskreten Logarithmus (f√ºr elliptische Kurven), nicht in der Faktorisierung, die wir im Abschnitt RSA untersucht haben.  Das Problem ist: Wenn wir es wissen <math> </math> $ inline $ P $ inline $   und <math> </math> $ inline $ Q $ inline $   , was ist so <math> </math> $ inline $ k $ inline $   , das <math> </math> $ inline $ Q = k \ cdot P $ inline $   ? <br><br>  Sowohl das Faktorisierungsproblem (das dem RSA zugrunde liegt) als auch der diskrete Logarithmus f√ºr elliptische Kurven (der die Basis f√ºr ECDSA und ECDH ist) sollen schwierig sein, d. H. Es sind keine Algorithmen bekannt, um dieses Problem in der Polynomzeit f√ºr einen gegebenen Schl√ºssel zu l√∂sen L√§nge. <br><br>  W√§hrend normalerweise jeder besch√§mt ist, den Schl√ºsselaustausch (ECDH) mit dem Signaturalgorithmus (ECDSA) zu mischen, m√ºssen wir erkl√§ren, wie sie zusammenarbeiten.  Ein modernes TLS-Zertifikat enth√§lt in unserem Fall einen √∂ffentlichen Schl√ºssel f√ºr das vom Ellipsenkurvenalgorithmus generierte Schl√ºsselpaar, das normalerweise von einer √ºbergeordneten Beh√∂rde signiert wird.  Der Client √ºberpr√ºft die Signatur des Servers und erh√§lt das gemeinsame Geheimnis.  Das gemeinsame Geheimnis wird in einem symmetrischen Verschl√ºsselungsalgorithmus wie AES oder ChaCha20 verwendet.  Das Prinzip bleibt jedoch dasselbe: Vereinbaren Sie Dom√§nenparameter (das Sextuplet), und erhalten Sie das Schl√ºsselpaar, wobei der private Schl√ºssel eine zuf√§llig ausgew√§hlte Ganzzahl ist (der Multiplikand von <math> </math> $ inline $ Q = k \ cdot P $ inline $   ) und der √∂ffentliche Schl√ºssel ist ein Punkt auf der Kurve.  Signaturalgorithmen verwenden den Basispunkt <math> </math> $ inline $ g $ inline $   Dies ist ein Generator f√ºr eine Untergruppe gro√üer Primzahlen <math> </math> $ inline $ n $ inline $   , so dass <math> </math> $ inline $ n \ cdot G = 0 $ inline $   , wobei 0 das Identit√§tselement ist.  Die Signatur belegt, dass die sichere Verbindung mit der authentischen Partei hergestellt wird - einem Server, auf dem das TLS-Zertifikat (√∂ffentlicher Schl√ºssel) von einer Zertifizierungsstelle f√ºr den angegebenen Servernamen signiert ist. <br><br><h3>  (EC) DH (E) + ECDSA = Aktuelle Handshake-Form </h3><br>  In modernen TLS (1.3) generieren der Client und der Server ihr √∂ffentlich-privates Schl√ºsselpaar im laufenden Betrieb, w√§hrend die Verbindung hergestellt wird. Dies wird als kurzlebige Version des Schl√ºsselaustauschs bezeichnet.  Die beliebtesten Browser-TLS-Bibliotheken unterst√ºtzen dies.  Meistens verwenden sie die von Daniel J. Bernstein (djb) eingef√ºhrte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">elliptische Kurve Edwards 25519</a> , die 128-Bit-Sicherheit bietet.  Seit 2014 verwendet openssh diese Kurve f√ºr die Schl√ºsselpaarerstellung.  Im Jahr 2019 unterst√ºtzen Browser jedoch keine TLS-Sitzungen mit Servern, die ein Zertifikat mit einem √∂ffentlichen EdDSA-Schl√ºssel haben. <br><br>  Kommen wir jedoch zum Ende des Jahres 2019 mit TLS 1.3 zur√ºck. <br><br>  Die Schl√ºsselaustauschmechanismen in TLS 1.3 sind auf (EC) DH (E) -basiert beschr√§nkt (mit x25519 wird dies in clientseitigen TLS-Bibliotheken der meisten g√§ngigen Browser sowie in serverseitigen TLS-Bibliotheken wie OpenSSL unterst√ºtzt). Die Liste der Chiffresuiten enth√§lt nur drei Eintr√§ge: TLS_AES_128_GCM_SHA256, TLS_AES_256_GCM_SHA384 und TLS_CHACHA20_POLY1305_SHA256.  F√ºr diejenigen unter Ihnen, die wissen, wie die Chiffresuiten in der TLS 1.2-Version benannt wurden, ist es sofort ersichtlich, dass der Schl√ºsselaustauschmechanismus jetzt vom Namen der Chiffresuite ‚Äûgetrennt‚Äú ist und auch die statischen Austauschmodi RSA und Diffie-Hellman entfernt wurden von der Spezifikation ganz.  Sogar die auf PSK basierende Sitzungswiederaufnahme erfolgt √ºber ECDHE in TLS 1.3.  Dies gilt auch f√ºr benutzerdefinierte DH-Parameter, die derzeit nicht zul√§ssig sind, sodass nur die in der endg√ºltigen Protokollspezifikation als sicher vereinbarten Parameter √ºbrig bleiben. <br><br>  Es ist interessant, dass es heutzutage einen erheblichen Unterschied in der Funktionsweise asymmetrischer Verschl√ºsselungsalgorithmen gibt.  Bei ECC (und insbesondere ECDSA-Zertifikaten) verwenden wir kleinere Schl√ºssel, um im Vergleich zu RSA ein ‚Äûkomfortables‚Äú Sicherheitsniveau zu erreichen.  Dies erm√∂glicht die Verwendung eines st√§rkeren asymmetrischen Verschl√ºsselungsalgorithmus und von Schl√ºsselaustauschmechanismen auf kleineren Ger√§ten und manchmal sogar in Dingen, die im Allgemeinen nicht als Ger√§t (Smartcard) betrachtet werden. <br><br>  Zun√§chst muss erw√§hnt werden, was ‚Äûhybrides Kryptosystem‚Äú im Sinne von TLS 1.3 bedeutet. <br>  Ein hybrides Kryptosystem ist dasjenige, das eine asymmetrische Verschl√ºsselung (√∂ffentlicher Schl√ºssel) verwendet, um ein gemeinsames Geheimnis herzustellen, das ferner als Schl√ºssel in einem symmetrischen Strom oder einer Blockverschl√ºsselung verwendet wird. <br><br>  Zweitens Public-Key-Infrastruktur und Zertifikate.  Interessanterweise erw√§hnte Martin Hellman in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">seinem Interview von 2004</a> einen ‚Äûnicht gesungenen Helden‚Äú, Loren Kohnfelder, dessen MIT-Bachelorarbeit eine Baumstruktur der heute als Public-Key-Infrastruktur bekannten Infrastruktur vorstellte.  Kehren wir dennoch zu Zertifikaten zur√ºck. <br><br>  Die Tatsache, dass der Server wirklich √ºber den privaten Schl√ºssel verf√ºgt, wird durch seine Signatur sichergestellt, die mit dem √∂ffentlichen Schl√ºssel des Servers √ºberpr√ºft werden kann.  Das Zertifikat stellt sicher, dass ein √∂ffentlicher Schl√ºssel zu einem bestimmten Server geh√∂rt.  Dies bedeutet, dass Sie eine sichere Kommunikation mit der bestimmten Partei und nicht mit einem Betr√ºger herstellen.  Ihre Bank, kein Cyberkrimineller.  In TLS 1.3 gibt es eine erhebliche Verbesserung gegen√ºber dem vorherigen Verhandlungsformat: Der Server signiert alle Informationen, die er bis zu diesem Zeitpunkt hat: die Begr√º√üung des Clients und des Servers, einschlie√ülich der ausgehandelten Verschl√ºsselung.  Werfen wir einen Blick auf den entsprechenden Abschnitt des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RFC 8446</a> : <br><br><pre><code class="plaintext hljs">Client Server Key ^ ClientHello Exch | + key_share* | + signature_algorithms* | + psk_key_exchange_modes* v + pre_shared_key* --------&gt; ServerHello ^ Key + key_share* | Exch + pre_shared_key* v {EncryptedExtensions} ^ Server {CertificateRequest*} v Params {Certificate*} ^ {CertificateVerify*} | Auth {Finished} v &lt;-------- [Application Data*] ^ {Certificate*} Auth | {CertificateVerify*} v {Finished} --------&gt; [Application Data] &lt;-------&gt; [Application Data]</code> </pre> <br>  In TLS 1.3 sendet der Client die Schl√ºsselfreigabe (zusammen mit den erforderlichen Parametern) und die Signaturalgorithmen sofort in der ersten Nachricht (Client Hello).  Die zum Austausch mit dem Server erforderlichen Schl√ºssel werden im Hintergrund erstellt, ohne dass der Benutzer dies bemerkt.  Sie werden weiter mit dem Server ausgetauscht, um ein gemeinsames Geheimnis aus geheimen Pre-Master-Schl√ºsseln zu erstellen, die eingerichtet wurden, als der Server seine Nachricht (Server Hello) an den Client antwortete. <br>  Auf der Seite ‚ÄûServer Hello‚Äú sehen Sie das Zertifikat *, das an den Client √ºbertragen wird, sowie den Teil Certificate Verify *, der √ºberpr√ºft, ob der Teilnehmer den privaten Schl√ºssel f√ºr den entsprechenden √∂ffentlichen Schl√ºsseleintrag besitzt, und erstellt den Sitzungsschl√ºssel (symmetrisch) if Alles l√§uft wie geplant - was bedeutet, dass die Seite, die die Daten anfordert (Client), die antwortende Seite (Server) erfolgreich verifiziert hat, wodurch ein gemeinsames Geheimnis entsteht. <br><br>  In dieser √úbertragung sind zwei wesentliche Vorg√§nge verborgen - das Erstellen einer Signatur und das √úberpr√ºfen der Signatur.  Diese werden auf beiden Seiten der Kommunikation vorgenommen, da ‚ÄûSignatur‚Äú im Wesentlichen ein Beweis daf√ºr ist, dass die Partei tats√§chlich √ºber den privaten Schl√ºssel verf√ºgt, der dem √∂ffentlichen Schl√ºssel entspricht, dass die Daten vom Unterzeichner stammen und die Nachricht w√§hrend der √úbertragung nicht ge√§ndert wurde. <br><br>  Wie wir weiter sehen werden, ist der Signiervorgang bei RSA am teuersten.  Da wir mit einem 2048 oder 3072 Bit langen Schl√ºssel signieren, wird durch diesen Vorgang der Server erheblich st√§rker belastet als der Client, der eine solche Signatur √ºberpr√ºft. <br><br>  Mit ECDSA haben wir kleinere Schl√ºssel (wir werden uns das ECDSA mit NIST P-256 (oder dem secp256v1) ansehen), aber komplexere Operationen.  Infolgedessen kann es als "verkehrter" RSA angesehen werden - der Client wird durch die Signatur√ºberpr√ºfungsberechnung am meisten geladen, w√§hrend der Server die Signaturerstellung problemlos abwickelt.  Die Messungen best√§tigen dies, siehe Abschnitt ‚ÄûEin bisschen Benchmark‚Äú. <br><br>  Dieser Effekt skaliert das heutige Internet auf einfache Weise - da moderne Clients fast genauso leistungsf√§hig sind wie die Server (unter Ber√ºcksichtigung der CPU-Kernfrequenz), k√∂nnen sie den teuren Vorgang effektiv in Kauf nehmen.  Der Server kann seinerseits die freigegebenen Funktionen verwenden, um mehr Signaturen zu erstellen und mehr Sitzungen einzurichten. <br><br><h3>  Lassen Sie uns die Zertifikatsignatur verschl√ºsseln </h3><br>  Um dem Leser einige praktische und praktische Anweisungen zum Erstellen eines TLS-f√§higen Servers mit dem von der Let's Encrypt-Autorit√§t signierten ECDSA-Schl√ºsselpaar zu geben, haben wir uns entschlossen, einen vollst√§ndigen Prozess zum Erstellen eines erforderlichen Schl√ºsselpaars zu veranschaulichen um eine CSR (Certificate Signing Request) f√ºr Let's Encrypt zu erstellen und als Ergebnis das erforderliche ECDSA-Zertifikat f√ºr unseren Server zu erhalten. <br><br>  Wir m√ºssen einen privaten Schl√ºssel generieren, um fortzufahren.  Wir werden die OpenSSL-Bibliothek verwenden. <br>  Das OpenSSL-Handbuch beschreibt die Generierung von EC-Schl√ºsseln durch einen speziellen Befehl, der speziell f√ºr den elliptischen Kurvenast des Generierungsalgorithmus bestimmt ist. <br><br><pre> <code class="plaintext hljs">openssl ecparam -genkey -name -secp256v1 -out privatekey.pem</code> </pre> <br>  Um zu √ºberpr√ºfen, ob die OpenSSL-Bibliothek alles richtig gemacht hat, k√∂nnen wir den Befehl <code>ec</code> ausf√ºhren. <br><br><pre> <code class="plaintext hljs">openssl ec -in privatekey.pem -noout -text</code> </pre> <br>  Die Ausgabe zeigt uns die angegebene Kurve, mit der der Schl√ºssel erstellt wurde. <br><br>  Der n√§chste Schritt ist f√ºr die Erstellung des CSR sehr wichtig. Damit Sie nicht alle Informationen eingeben m√ºssen, um das Zertifikat zu erhalten, ben√∂tigen Sie die Konfigurationsdatei.  Gl√ºcklicherweise hat Mozilla die gesamte Arbeit f√ºr uns erledigt und den ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SSL Configuration Generator</a> ‚Äú eingef√ºhrt.  Dort k√∂nnen Sie aus beliebigen verf√ºgbaren Serveroptionen ausw√§hlen.  Die reine OpenSSL-Konfiguration, die auf der Seite des Generators nicht vorhanden ist, w√ºrde ungef√§hr so ‚Äã‚Äãaussehen: <br><br><pre> <code class="plaintext hljs">[ req ] prompt = no encrypt_key = no default_md = sha256 distinguished_name = dname req_extensions = reqext [ dname ] CN = example.com emailAddress = admin@example.com [ reqext ] subjectAltName = DNS:example.com, DNS:*.example.com</code> </pre> <br>  <i>Hinweis: Es ist nicht erforderlich, √ºber CNF zu verf√ºgen. Andernfalls werden Sie aufgefordert, diese Details in die Befehlszeile einzugeben.</i> <br><br>  Folgen Sie nun der Erstellung eines CSR.  Hier haben wir einen praktischen OpenSSL-Befehl. <br><br><pre> <code class="plaintext hljs">openssl req -new -config -pathtoconfigfile.cnf -key privatekey.pem -out csr.pem</code> </pre> <br>  Wir k√∂nnen auch die Richtigkeit einer neu erstellten CSR √ºberpr√ºfen. <br><br><pre> <code class="plaintext hljs">openssl req -in csr.pem -noout -text -verify</code> </pre> <br>  Hier sind wir zu einer letzten Phase gekommen - mit einem ACME-Client, certbot, um unsere Zertifikatsignierungsanforderung an Let's Encrypt weiterzuleiten. <br><br>  Certbot hilft Ihnen, das erforderliche Zertifikat zu erhalten, und bietet eine Vielzahl von Optionen.  Wenn Sie mit der Verschl√ºsselung mit √∂ffentlichen Schl√ºsseln und der PKI-Infrastruktur von 2019 noch nicht <code>--dry-run</code> sind, sollten Sie <code>--dry-run</code> bevor Sie versuchen, das Zertifikat f√ºr eine Domain Ihrer <code>--dry-run</code> zu erhalten. <br><br><pre> <code class="plaintext hljs">certbot certonly --dry-run --dns-somednsprovider --domain ‚Äúexample.com‚Äù --domain ‚Äú*.example.com‚Äù --csr csr.pem</code> </pre> <br>  In diesem Fall √ºberpr√ºft der Certbot-Client, ob die Liste der angeforderten Dom√§nen (in der Befehlszeile) mit den in der Zertifikatsignierungsanforderung aufgef√ºhrten Dom√§nen √ºbereinstimmt.  <code>--dns-somednsprovider</code> Befehl <code>--dns-somednsprovider</code> eine <code>--dns-somednsprovider</code> L√ºge, da Sie auf vielf√§ltige Weise nachweisen k√∂nnen, dass Let's Encrypt Sie im Besitz eines bestimmten Teils des Internetverkehrs sind.  Wenn Sie jedoch einen √∂ffentlichen Cloud-Hosting-Anbieter verwenden, z. B. DigitalOcean, Hetzner, Amazon, Azure, usw., gibt es wahrscheinlich eine nat√ºrlichere M√∂glichkeit, die erforderlichen Informationen bereitzustellen, da Ihr Anbieter bereits ein Integrationstool erstellt hat. <br><br>  Wenn Sie sich nachher sicher sind, ob die Parameter, mit denen Sie Ihre CSR √ºber einen Certbot-Client an Let's Encrypt √ºbergeben, korrekt sind, schlie√üen Sie den Parameter <code>--dry-run</code> aus Ihrem Befehl aus und fahren Sie fort. <br><br>  Bei Erfolg w√ºrde der Client mehrere Zertifikate als Ausgabe erzeugen: das signierte Zertifikat selbst, die Stamm- und Zwischenzertifikate und die Kombination dieser Zertifikate als letztgenannte Zertifikatskette im PEM-Dateiformat. <br><br>  OpenSSL verf√ºgt √ºber einen Befehl, mit dem wir die Zertifikate √ºberpr√ºfen k√∂nnen: <br><br><pre> <code class="plaintext hljs">openssl x509 -in chainfilepath.pem -noout -text</code> </pre> <br>  An diesem Punkt wird deutlich, dass Let's Encrypt das Zertifikat mit SHA256 Digest signiert hat.  Dar√ºber hinaus fallen die Signaturen f√ºr ECDSA-Stamm- und Zwischenprodukte unter den Abschnitt ‚ÄûBevorstehende Funktionen‚Äú. Dies bedeutet effektiv, dass Sie derzeit nur RSA-Zwischenprodukte erhalten.  Aber das ist in Ordnung, da Sie immer noch den √∂ffentlichen ECDSA-Schl√ºssel verwenden. <br><br>  Am Ende dieses Abschnitts m√∂chten wir etwas zur L√§nge der Tasten sagen.  In der Informationssicherheit wird h√§ufig die Sicherheitsstufe 2 ^ x angegeben, wobei x die Bitl√§nge ist (RSA ist hier eine Ausnahme, da es etwas langsamer als exponentiell w√§chst).  Um zu sch√§tzen, wie die f√ºr verschiedene Algorithmen verwendeten Schl√ºssel einander entsprechen, verweisen wir auf die OpenSSL- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wiki-Seite</a> . <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Symmetrische Schl√ºssell√§nge</b> <br></td><td>  <b>RSA-Schl√ºssell√§nge</b> <br></td><td>  <b>Elliptic Curve Key Length</b> <br></td></tr><tr><td>  80 <br></td><td>  1024 <br></td><td>  160 <br></td></tr><tr><td>  112 <br></td><td>  2048 <br></td><td>  224 <br></td></tr><tr><td>  128 <br></td><td>  3072 <br></td><td>  256 <br></td></tr><tr><td>  192 <br></td><td>  7680 <br></td><td>  384 <br></td></tr><tr><td>  256 <br></td><td>  15360 <br></td><td>  512 <br></td></tr></tbody></table></div>  Wie Sie sehen, sind die Unterschiede ziemlich ausgepr√§gt.  Obwohl mit Let's Encrypt keine Zertifikate au√üerhalb der elliptischen Kurvenschl√ºssel 256 (secp256v1) und 384 (secp384r1) signiert werden konnten. <br><br><h3>  Bekannte Probleme und Ausnahmen sowie die NSA </h3><br><img src="https://imgs.xkcd.com/comics/random_number.png" alt="Bild"><br>  Credits: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">xkcd</a> <br><br>  Wahrscheinlich war das zentrale Problem bei der Verwendung der Kryptographie mit elliptischen Kurven im Laufe der Jahre die Notwendigkeit eines sehr sorgf√§ltig ausgearbeiteten Zufallszahlengenerators, um Schl√ºssel mit der erforderlichen Sicherheitsstufe zu erstellen. <br><br>  Es gab einen massiven Skandal um den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dual_EC_DRBG-</a> Algorithmus (Dual Elliptic Curve Deterministic Random Bit Generator), dessen Aufl√∂sung viele Jahre in Anspruch nahm.  Es besteht auch Unsicherheit in Bezug auf ECC-Patente, da bekannt ist, dass viele von ihnen der Certicom-Firma geh√∂rten, die von Blackberry erworben wurde.  Es gibt auch Unternehmen, von denen bekannt ist, dass sie die Verwendung von ECC von Blackberry zertifizieren.  Nat√ºrlich gibt es in einigen NIST-Standards ein einfaches Misstrauen, das von der NSA oder einer anderen US-amerikanischen Durchsetzungs- und √úberwachungsbeh√∂rde beeintr√§chtigt werden k√∂nnte oder nicht. <br><br>  Die Implementierungsseite eines Problems ist eine ganz andere Frage.  Im Jahr 2010 wurde auf der PlayStation 3-Konsole ein privater Schl√ºssel von Sony wiederhergestellt, da der ECDSA-Algorithmus nicht ordnungsgem√§√ü implementiert wurde. Die statische Zufallszahl machte die Trapdoor-Funktion l√∂sbar.  OpenSSL litt auch im folgenden Jahr darunter, dass die Sicherheitsanf√§lligkeit, die das Abrufen eines privaten Schl√ºssels mithilfe eines Timing-Angriffs erm√∂glichte, schnell behoben wurde. Weitere Informationen finden Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Originaldokument</a> . <br><br>  2013 pr√§sentierte eine Gruppe von Forschern auf der RSA-Konferenz ihre ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Randomly Failed!</a>  Artikel √ºber Sicherheitsl√ºcken in der SecureRandom-Java-Klasse.  Ein halbes Jahr sp√§ter ging es um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Android</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bitcoin-</a> Geldb√∂rsen, die mit nicht gen√ºgend kryptografisch sicherem PRNG erstellt wurden. <br><br>  Aufgrund schwerwiegender serieller Sicherheitsl√ºcken ver√∂ffentlichte die IETF im August 2013 einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RFC 6979</a> , der eine deterministische Generation von k beschreibt, die bei der Schl√ºsselerstellung verwendet wurde.  Wir k√∂nnten sagen, dass eine solche Ma√ünahme das Problem behoben hat, aber wir werden es nicht tun - Forscher k√∂nnten aufgrund unn√∂tiger Abweichungen von den Protokollspezifikationen jederzeit Probleme in zahlreichen Implementierungen finden. <br><br>  √úber die NSA.  Wenn Sie noch nichts √ºber die Geschichte von Dual_EC_DRBG geh√∂rt haben - nehmen Sie sich etwas Zeit und lesen Sie die entsprechenden Artikel. Sie werden es nicht bereuen, auf Einzelheiten eingegangen zu sein.  Edward Snowden ist ein Teil dieser Geschichte, weil die Enth√ºllungen von 2013 den fr√ºheren Verdacht bewiesen haben.  Dies f√ºhrte dazu, dass viele prominente Kryptografen das Vertrauen in NIST verloren, da diese Organisation viele der Kurven und weiteren Algorithmen entwarf und beschrieb, die ECDSA zugrunde lagen. <br><br>  Daniel Bernsteins 25519-Kurve und DH-Funktion sind die Antwort auf beide Probleme. Wie wir bereits beschrieben haben, ist ein √úbergang zu EdDSA zwar langsam, aber offensichtlich.  Selbst mit den NIST-Kurven wurden noch keine Hinweise auf ihre Verwundbarkeit gefunden, und wie bereits erw√§hnt, waren zuf√§llige Erfahrungen recht aufschlussreich. <br><br>  Abschlie√üend m√∂chten wir das Zitat von John von Neumann zitieren: "Wer versucht, Zufallszahlen mit deterministischen Mitteln zu generieren, lebt nat√ºrlich in einem Zustand der S√ºnde." <br><br><h3>  Ein bisschen Benchmark </h3><br>  Wir haben einen NGINX 1.16.0-Server mit OpenSSL 1.1.1d verwendet, um diese Benchmarks mit verschiedenen Zertifikaten auszuf√ºhren.  Wie bereits erw√§hnt, l√§sst Let's Encrypt derzeit nur die Algorithmen prime256v1 und secp384r1 f√ºr Zertifikatsignierungsanforderungen zu und bietet keine Root- und Intermedi√§r-ECDSA-Zertifikate, die wahrscheinlich bei dieser Funktion zum Zeitpunkt des Erstellens dieses Artikels funktionieren. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Signaturtyp</b> </td><td>  <b>Handshakes pro Sekunde</b> </td></tr><tr><td>  <b>ECDSA (prime256v1 / nistp256)</b> </td><td>  3358.6 </td></tr><tr><td>  <b>RSA 2048</b> </td><td>  972,5 </td></tr></tbody></table></div>  Wie Sie sehen, betr√§gt der Gesamtunterschied bei der ECDSA-Leistung eines einzelnen Kerns der Intel¬Æ Xeon¬Æ Silver 4114-CPU bei 2,20 GHz (Start Q3'17) im Vergleich zum weit verbreiteten RSA 2048 das 3,5-fache. <br><br>  Schauen wir uns nun die OpenSSL-Geschwindigkeitsergebnisse des gleichen Prozessors mit ECDSA und RSA an. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Signaturtyp</b> <br></td><td>  <b>unterschreiben</b> <br></td><td>  <b>verifizieren</b> <br></td><td>  <b>Vorzeichen / Sek</b> <br></td><td>  <b>verifizieren / Sek</b> <br></td></tr><tr><td>  <b>RSA 2048 Bit</b> <br></td><td>  717 Œºs <br></td><td>  20,2 Œºs <br></td><td>  1393.9 <br></td><td>  49458.2 <br></td></tr><tr><td>  <b>256-Bit-ECDSA (nistp256)</b> <br></td><td>  25,7 Œºs <br></td><td>  81,8 Œºs <br></td><td>  38971.6 <br></td><td>  12227.1 <br></td></tr></tbody></table></div>  Hier sehen wir eine Best√§tigung f√ºr die fr√ºher gegebene These der unterschiedlichen Rechenkosten f√ºr die Vorzeichen- und √úberpr√ºfungsoperationen von ECC und RSA.  Infolgedessen bietet die derzeit mit TLS 1.3 ECC ausgestattete Version eine deutliche Leistungssteigerung bei der h√∂heren Bit-Sicherheitsstufe im Vergleich zu RSA.  Dies ist der wichtigste Grund, warum wir bei Qrator Labs unsere Kunden dazu ermutigen, ECDSA einzuf√ºhren.  Mit modernen CPUs erhalten Sie fast den f√ºnffachen Unterschied zugunsten von ECDSA. <br><br>  Wenn Sie daran interessiert sind, wie Ihre CPU kryptografische Berechnungen durchf√ºhrt, k√∂nnen Sie einen einfachen Befehl <code>openssl speed</code> ausf√ºhren.  Mit den Parametern <code>-rsa</code> , <code>-ecdsa</code> und <code>-eddsa</code> Sie Benchmark-Ergebnisse f√ºr die entsprechenden Signaturalgorithmen. <br><br><h3>  (√úberlagerte) Zukunft </h3><br><img src="https://pbs.twimg.com/media/CB4sHACVEAAYMyZ?format=jpg&amp;name=large" alt="Bild"><br>  Credits: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">djb</a> <br><br>  Es ist ironisch, dass Google w√§hrend der Vorbereitung dieses Artikels " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erreichen der Quantenherrschaft</a> " angek√ºndigt hat.  Bedeutet dies, dass wir gerade in Gefahr sind und alles, was bis zu diesem Moment entwickelt wurde, keine Geheimhaltung bietet? <br><br>  Nun, nein. <br><br>  Wie Bruce Schneier in seinem Aufsatz f√ºr IEEE-Sicherheit und Datenschutz " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kryptographie nach den Aliens Lands</a> " schrieb, konnte ein schwerer Schlag mit einem ausreichend leistungsf√§higen Quantencomputer gegen die (asymmetrische) Kryptographie mit √∂ffentlichem Schl√ºssel ver√ºbt werden.  Symmetrische Kryptographie w√§re immer noch stark. <br><br>  Wir m√∂chten Bruce Schneier mit folgenden Worten zitieren: <br><blockquote>  Es gibt noch ein weiteres Zukunftsszenario, f√ºr das kein Quantencomputer erforderlich ist.  W√§hrend es mehrere mathematische Theorien gibt, die die Einbahnstra√üe, die wir in der Kryptographie verwenden, untermauern, ist der Nachweis der G√ºltigkeit dieser Theorien tats√§chlich eines der gro√üen offenen Probleme in der Informatik.  So wie es einem intelligenten Kryptografen m√∂glich ist, einen neuen Trick zu finden, der es einfacher macht, einen bestimmten Algorithmus zu brechen, k√∂nnen wir uns Aliens mit einer ausreichenden mathematischen Theorie vorstellen, um alle Verschl√ºsselungsalgorithmen zu brechen.  F√ºr uns ist das heute l√§cherlich.  Die Kryptographie mit √∂ffentlichen Schl√ºsseln ist eine Zahlentheorie und potenziell anf√§llig f√ºr mathematisch veranlagte Aliens.  Symmetrische Kryptographie ist so viel nichtlineares Durcheinander, so einfach komplexer zu machen und so einfach, die Schl√ºssell√§nge zu erh√∂hen, dass diese Zukunft unvorstellbar ist.  Betrachten Sie eine AES-Variante mit einer Block- und Schl√ºsselgr√∂√üe von 512 Bit und 128 Runden.  Wenn sich die Mathematik nicht grundlegend von unserem derzeitigen Verst√§ndnis unterscheidet, ist dies sicher, bis Computer aus etwas anderem als Materie bestehen und etwas anderes als Raum einnehmen. <br><br>  Aber wenn das Unvorstellbare passiert, bleibt uns die Kryptographie, die ausschlie√ülich auf der Informationstheorie basiert: Einmal-Pads und ihre Varianten. </blockquote><br>  Dies ist der Bereich, in dem, abgesehen von der Suche nach Implementierungsfehlern, die meisten Probleme auftreten k√∂nnen.  Wenn es eine Gruppe gut finanzierter Mathematiker, Kryptoanalytiker / Kryptographen und Computeringenieure gibt, die daran arbeiten, einige au√üergew√∂hnlich komplexe mathematische Probleme (wie das P? = NP) zu beweisen oder zu widerlegen und bis zu diesem Moment erhebliche Ergebnisse zu erzielen, k√∂nnten wir in Schwierigkeiten geraten.  Es ist jedoch unwahrscheinlich, dass solche Fortschritte in den Bereichen Informatik, Informations- und Rechenf√§higkeitstheorien verborgen bleiben, da diese Tatsache die Namen ihrer Sch√∂pfer auf die Seiten der Geschichte und insbesondere der Geschichte der Internet-Lehrb√ºcher schreibt, was f√ºr jeden so unbezahlbar ist .  Ein solches Szenario k√∂nnte also als nahezu unm√∂glich angesehen werden. <br><br>  Es ist nicht klar, ob es in den n√§chsten 5 Jahren Erfolge mit dem Quanten-Computing geben w√ºrde, obwohl es bereits mehrere Kryptographie-Primitive gibt, die als f√ºr die Welt nach der Quanten geeignet angesehen werden: Gitter, auf supersingul√§ren elliptischen Kurven basierende Isogenese, Hashes und Codes.  Im Moment experimentieren Sicherheitsspezialisten nur mit ihnen.  Es besteht jedoch kein Zweifel, dass die Menschheit im Bedarfsfall solche Algorithmen schnell in gro√üem Ma√üstab einsetzen w√ºrde. <br><br>  Derzeit scheint die Kryptografie mit elliptischen Kurven die perfekte L√∂sung f√ºr das kommende Jahrzehnt zu sein und bietet Sicherheit und Leistung. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de474810/">https://habr.com/ru/post/de474810/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de474796/index.html">Was ist das Internet der Dinge und wie k√∂nnen Unternehmen damit mehr verdienen?</a></li>
<li><a href="../de474800/index.html">Leistung in .NET Core</a></li>
<li><a href="../de474804/index.html">Russischer technologischer Fortschritt im Sport: Neuronale Schnittstellen, IP-Kameras, Sport-CRM und BigData aus einem Rennwagen</a></li>
<li><a href="../de474806/index.html">UDP Flood von Google oder wie nicht alle Youtube zu berauben</a></li>
<li><a href="../de474808/index.html">Rust 1.39.0 Release: async / await, Attribute f√ºr Funktionsparameter, neue konstante Funktionen</a></li>
<li><a href="../de474812/index.html">Shader ist keine Magie. Shader in Unity schreiben. Vertex-Shader</a></li>
<li><a href="../de474814/index.html">Altert√ºmer: der Botschafter des Verfalls oder der ungeplanten Veralterung</a></li>
<li><a href="../de474816/index.html">Haustierprojekte - kleines Leben</a></li>
<li><a href="../de474818/index.html">Gibt es Zufallszahlen in CSS?</a></li>
<li><a href="../de474822/index.html">WISE-PaaS - eine Cloud-Plattform f√ºr das industrielle Internet der Dinge</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>