<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👲🏿 🥠 🏩 Maths génériques dangereux en C # 🧟 ⏪ 🐙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Malheureusement, il n'a pas été facile de traduire correctement le nom de la laideur que j'ai commencé en russe. J'ai été surpris de constater que la ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Maths génériques dangereux en C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480416/"><p><img src="https://habrastorage.org/webt/mj/zg/yw/mjzgywquj0lud4_vs9bjh8xdacu.png"></p><br><p> Malheureusement, il n'a pas été facile de traduire correctement le nom de la laideur que j'ai commencé en russe.  J'ai été surpris de constater que la documentation <a href="https://docs.microsoft.com/ru-ru/dotnet/csharp/programming-guide/generics/" rel="nofollow">MSDN</a> officielle appelle des «modèles» «génériques» (similaires aux modèles <code>C++</code> , je suppose).  Dans la 4e édition de <a href="https://www.microsoftpressstore.com/store/clr-via-c-sharp-9780735667457" rel="nofollow"><code>"CLR</code> via <code>C#</code></a> qui m'a frappé <a href="https://www.microsoftpressstore.com/store/clr-via-c-sharp-9780735667457" rel="nofollow">,</a> <a href="https://twitter.com/jeffrichter" rel="nofollow">Jeffrey Richter</a> , traduit par <a href="https://habr.com/en/company/piter/">Peter</a> , les génériques sont appelés «généralisations», ce qui reflète bien mieux l'essence du concept.  Cet article parlera <em>des opérations mathématiques généralisées dangereuses en <code>C#</code></em> .  Étant donné que <code>C#</code> pas destiné à l'informatique haute performance (bien qu'il puisse certainement, mais n'est pas en mesure de rivaliser avec le même <code>C/C++</code> ), <code>BCL</code> ne prête pas beaucoup d'attention aux opérations mathématiques.  Essayons de simplifier le travail avec les types arithmétiques de base en utilisant <code>C#</code> et <code>CLR</code> . </p><a name="habracut"></a><br><h2 id="postanovka-zadachi">  Énoncé du problème </h2><br><p>  <strong>Avertissement</strong> : l'article contiendra de nombreux fragments de code, dont certains que <a href="https://sharplab.io/" rel="nofollow">j'illustrerai</a> avec des liens vers la merveilleuse ressource <a href="https://sharplab.io/" rel="nofollow">SharpLab</a> ( <a href="https://github.com/ashmind/SharpLab" rel="nofollow">Gi <s>r</s> tHub</a> ) d' <a href="https://twitter.com/ashmind" rel="nofollow">Andrey Shchekin</a> . </p><br><p>  La plupart des calculs se résument d'une manière ou d'une autre aux opérations de base.  L'addition, la soustraction (inversion, négation), la multiplication et la division peuvent être complétées par des opérations de comparaison et de vérification de l'égalité.  Bien sûr, toutes ces actions peuvent être facilement et simplement effectuées sur des variables de n'importe quel type arithmétique de base de <code>C#</code> .  Le seul problème est que <code>C#</code> devrait <em>savoir</em> au moment de la compilation que les opérations sont effectuées sur des types spécifiques, et il semble que l'écriture d'une méthode qui ajoute de manière aussi efficace (et transparente) deux entiers et deux nombres à virgule flottante est impossible. </p><br><p>  Précisons nos souhaits pour une méthode généralisée hypothétique qui effectue une opération mathématique simple: </p><br><ol><li>  Une méthode doit avoir des restrictions de type généralisées qui nous empêchent d'essayer d'ajouter (ou de multiplier, de diviser) deux types arbitraires.  Nous avons besoin d'une contrainte de type générique. </li><li>  Pour la pureté de l'expérience, les types acceptés et retournés doivent être les mêmes.  Par exemple, un opérateur binaire doit avoir une signature de la forme <code>(T, T) =&gt; T</code> </li><li>  La méthode doit être au moins partiellement optimisée.  Par exemple, la boxe omniprésente est inacceptable. </li></ol><br><h2 id="a-chto-tam-u-sosedey">  Et les voisins? </h2><br><p>  Regardons <code>F#</code> .  Je ne suis pas fort en <code>F#</code> , mais la plupart des restrictions <code>C#</code> sont dictées par les limitations <code>CLR</code> , ce qui signifie que <code>F#</code> souffre des mêmes problèmes.  Vous pouvez essayer de déclarer une méthode d'addition généralisée explicite et la méthode d'addition habituelle et voir ce que dit le système d'inférence de type <code>F#</code> : </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">let</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_gen</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'a) (y : '</span></span></span></span><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">)</span></span> = x + y <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> xy = x + y add_gen <span class="hljs-number"><span class="hljs-number">5.0</span></span> <span class="hljs-number"><span class="hljs-number">6.0</span></span> |&gt; ignore <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-number"><span class="hljs-number">5.0</span></span> <span class="hljs-number"><span class="hljs-number">6.0</span></span> |&gt; ignore</code> </pre> <br><p>  Dans <a href="https://sharplab.io/" rel="nofollow">ce cas, les</a> deux méthodes se révéleront non généralisées et le code généré sera identique.  Étant donné la rigidité du système de type <code>F#</code> , où il n'y a pas de conversions implicites de la forme <code>int -&gt; double</code> , après le premier appel de ces méthodes avec des paramètres de type <code>double</code> (en termes <code>C#</code> ), appelez des méthodes avec des paramètres d'autres types (même avec une possible perte de précision due à la conversion de type) plus échouera. </p><br><p>  Il convient de noter que si vous remplacez l'opérateur <code>+</code> par l'opérateur d'égalité <code>=</code> , l' <a href="https://sharplab.io/" rel="nofollow">image devient quelque peu différente</a> : les deux méthodes deviennent généralisées (du point de vue de <code>C#</code> ), et une méthode d'assistance spéciale disponible en <code>F#</code> est appelée pour effectuer la comparaison. </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">let</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eq_gen</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'a) (y : '</span></span></span></span><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">)</span></span> = x = y <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> eq xy = x = y eq_gen <span class="hljs-number"><span class="hljs-number">5.0</span></span> <span class="hljs-number"><span class="hljs-number">6.0</span></span> |&gt; ignore eq_gen <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> |&gt; ignore eq <span class="hljs-number"><span class="hljs-number">5.0</span></span> <span class="hljs-number"><span class="hljs-number">6.0</span></span> |&gt; ignore eq <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> |&gt; ignore</code> </pre> <br><h3 id="chto-naschet-java">  Et <code>Java</code> ? </h3><br><p>  Il m'est difficile de parler de <code>Java</code> , mais, pour autant que je sache, les types significatifs <a href="https://en.wikipedia.org/wiki/Comparison_of_C_Sharp_and_Java" rel="nofollow">ne</a> sont <a href="https://en.wikipedia.org/wiki/Comparison_of_C_Sharp_and_Java" rel="nofollow">pas</a> là sous la forme habituelle pour nous, mais il existe encore <em>des</em> types <em>primitifs</em> .  Pour travailler avec les primitives en <code>Java</code> il existe des <a href="https://en.wikipedia.org/wiki/Comparison_of_C_Sharp_and_Java" rel="nofollow">wrappers</a> (par exemple, une référence <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Long.html" rel="nofollow"><code>Long</code></a> pour la primitive par valeur <code>long</code> ), qui ont un <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Number.html" rel="nofollow"><code>Number</code></a> classe de base commun.  Ainsi, vous pouvez généraliser partiellement les opérations à l'aide de <code>Number</code> , mais il s'agit d'un type de référence, qui est peu susceptible d'avoir un effet positif sur les performances. </p><br><p>  <em>Corrigez-moi si je me trompe.</em> </p><br><h3 id="c">  <code>C++</code> ? </h3><br><p>  <code>C++</code> est un langage pour les tricheurs. <br>  <code>C++</code> ouvre la voie à des fonctionnalités que certains considèrent ... contre <a href="https://ru.wikiquote.org/wiki/%25D0%2597%25D0%25B2%25D1%2591%25D0%25B7%25D0%25B4%25D0%25BD%25D1%258B%25D0%25B5_%25D0%25B2%25D0%25BE%25D0%25B9%25D0%25BD%25D1%258B._%25D0%25AD%25D0%25BF%25D0%25B8%25D0%25B7%25D0%25BE%25D0%25B4_III:_%25D0%259C%25D0%25B5%25D1%2581%25D1%2582%25D1%258C_%25D1%2581%25D0%25B8%25D1%2582%25D1%2585%25D0%25BE%25D0%25B2" rel="nofollow">nature</a> . <br>  Les modèles (ou modèles), contrairement aux généralisations (génériques), sont, au sens littéral, des <em>modèles</em> .  Lors de la déclaration d'un modèle, vous pouvez restreindre explicitement les types pour lesquels ce modèle est disponible.  Pour cette raison, en <code>C++</code> , par exemple, le code suivant est valide: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; template&lt;typename T, std::enable_if_t&lt;std::is_arithmetic&lt;T&gt;::value&gt;* = nullptr&gt; T Add (T left, T right) { return left + right; } int main() { std::cout &lt;&lt; Add(5, 6) &lt;&lt; std::endl; std::cout &lt;&lt; Add(5.0, 6.0) &lt;&lt; std::endl; // std::cout &lt;&lt; Add("a", "b") &lt;&lt; std::endl; Does not compile }</span></span></span></span></code> </pre> <br><p>  <code>is_arithmetic</code> , malheureusement, autorise à la fois <code>char</code> et <code>bool</code> comme paramètres.  D'un autre côté, <code>char</code> peut être équivalent à <code>sbyte</code> dans la terminologie <code>C#</code> , bien que les tailles réelles des types entiers dépendent de la plate-forme / du compilateur / de la phase lunaire. </p><br><h3 id="yazyki-s-dinamicheskoy-tipizaciey">  Langages de frappe dynamiques </h3><br><p>  Enfin, considérons quelques langages typés dynamiquement (et <em>interprétés</em> ), affinés par le calcul.  Dans de tels langages, la généralisation du calcul ne pose généralement pas de problèmes: si le type de paramètres est adapté à l'exécution, conditionnellement, l'addition, alors l'opération sera effectuée, sinon elle échouera avec une erreur. </p><br><p>  En <code>Python</code> (3.7.3 x64): </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y type(add(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># &lt;class 'int'&gt; type(add(5.0, 6.0)) # &lt;class 'float'&gt; type(add('a', 'b') # &lt;class 'str'&gt;</span></span></code> </pre> <br><p>  Dans <code>R</code> (3.6.1 x64) </p><br><pre> <code class="cpp hljs">add &lt;- function(x, y) x + y # <span class="hljs-function"><span class="hljs-function">Or </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">typeof</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> vctrs::</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vec_ptype_show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(add(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">6</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> # Prototype: </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> vctrs::</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vec_ptype_show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(add(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5L</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">6L</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> # Prototype: integer vctrs::</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vec_ptype_show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(add(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"5"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"6"</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> # Error in x + y : non-numeric argument to binary </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span></span></code> </pre> <br><h2 id="obratno-v-mir-c-ogranichivaem-obobschennyy-tip-matematicheskoy-funkcii">  Inversement, dans le monde C #: on restreint le type généralisé de fonction mathématique </h2><br><p>  Malheureusement, nous ne pouvons pas faire cela.  En <code>C#</code> les types primitifs sont des types par valeur, c'est-à-dire  structures qui, bien <code>System.Object</code> de <code>System.Object</code> (et <a href="https://docs.microsoft.com/en-us/dotnet/api/system.valuetype%3Fview%3Dnetcore-3.0" rel="nofollow"><code>System.ValueType</code></a> ), n'ont pas grand-chose en commun.  Une limitation naturelle et logique est celle <code>where T : struct</code> .  À partir de <code>C# 7.3</code> nous avons la contrainte <code>where T : unmanaged</code> , ce qui signifie que <code>T</code> est un <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types" rel="nofollow"><code> ,        null</code></a> .  En plus des types arithmétiques primitifs dont nous avons besoin, <code>char</code> , <code>bool</code> , <code>decimal</code> , <em>any</em> <code>Enum</code> et <em>toute</em> structure dont tous les champs ont le même type <code>unmanaged</code> managé satisfont à ces exigences.  C'est-à-dire  <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types" rel="nofollow">ce type</a> passera le test: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Coords&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TX; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TY; }</code> </pre> <br><p>  Ainsi, nous ne pouvons pas écrire une fonction généralisée qui accepte uniquement les types arithmétiques souhaités.  D'où l' <code>Unsafe</code> dans le titre de l'article - nous devrons nous fier aux programmeurs utilisant notre code.  Une tentative d'appeler une méthode hypothétique généralisée <code>T Add&lt;T&gt;(T left, T right) where T : unmanaged</code> conduira à des résultats imprévisibles si le programmeur passe en argument des objets d'un type incompatible. </p><br><h2 id="eksperiment-pervyy-naivnyy-dynamic">  La première expérience, naïve: <code>dynamic</code> </h2><br><p>  <code>dynamic</code> est le premier et évident outil qui peut nous aider à résoudre notre problème.  Bien sûr, l'utilisation de la <code>dynamic</code> pour les calculs est absolument inutile - la <code>dynamic</code> équivalente à l' <code>object</code> , et les méthodes appelées avec une variable <code>dynamic</code> sont transformées en une réflexion monstrueuse par le compilateur.  En prime - emballer / déballer nos types de valeur.  Voici <a href="https://sharplab.io/" rel="nofollow">un exemple</a> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Class</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = Add(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = Add(<span class="hljs-number"><span class="hljs-number">5.0</span></span>, <span class="hljs-number"><span class="hljs-number">6.0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">dynamic</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">dynamic</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">dynamic</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right</span></span></span><span class="hljs-function">)</span></span> =&gt; left + right; }</code> </pre> <br><p>  Regardez simplement l' <code>IL</code> la méthode <code>Method</code> : </p><br><pre> <code class="cs hljs">.<span class="hljs-function"><span class="hljs-function">method </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> hidebysig </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) cil managed</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Method begins at RVA 0x2050 // Code size 53 (0x35) .maxstack 8 IL_0000: ldc.i4.5 IL_0001: box [System.Private.CoreLib]System.Int32 IL_0006: ldc.i4.6 IL_0007: box [System.Private.CoreLib]System.Int32 IL_000c: call object Class::Add(object, object) IL_0011: pop IL_0012: ldc.r8 5 IL_001b: box [System.Private.CoreLib]System.Double IL_0020: ldc.r8 6 IL_0029: box [System.Private.CoreLib]System.Double IL_002e: call object Class::Add(object, object) IL_0033: pop IL_0034: ret } // end of method Class::Method</span></span></code> </pre> <br><p>  Chargé <code>5</code> , <em>compressé</em> , chargé <code>6</code> , compressé, appelé <code>object Add(object, object)</code> . <br>  L'option ne nous convient évidemment pas. </p><br><h2 id="eksperiment-vtoroy-v-lob">  La deuxième expérience, "dans le front" </h2><br><p>  Eh bien, la <code>dynamic</code> n'est pas pour nous, mais le nombre de nos types est fini, et ils sont connus à l'avance.  Armons-nous avec un <s>pied-de</s> - <s>biche de</s> branche et notons-le: si <em>notre</em> type <em>est</em> , calculons quelque chose, sinon - voici l'exception. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T Add&lt;T&gt;(T left, T right) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i32Left &amp;&amp; right <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i32Right) { <span class="hljs-comment"><span class="hljs-comment">// ??? } // ... throw new NotSupportedException(); }</span></span></code> </pre> <br><p>  III, nous rencontrons ici un problème.  Si vous comprenez avec quels types nous travaillons, vous pouvez également leur appliquer l'opération, puis l'intégratif conditionnel résultant doit être converti en un type inconnu <code>T</code> et ce n'est pas très simple.  L' <code>return (T)(i32Left + i32Right)</code> ne se compile pas - il n'y a aucune garantie que <code>T</code> est <code>int</code> (même si nous savons que c'est le cas).  Vous pouvez essayer la double conversion <code>return (T)(object)(i32Left + i32Right)</code> .  Tout d'abord, le montant est emballé, puis il est déballé en <code>T</code>  Cela <strong>ne</strong> fonctionnera <strong>que</strong> si les types <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/boxing-and-unboxing" rel="nofollow">correspondent</a> avant l'emballage et après l'emballage.  Vous ne pouvez pas emballer <code>int</code> , mais décompressez-le en <code>double</code> , même s'il existe une conversion implicite <code>int -&gt; double</code> .  Le problème avec <a href="https://sharplab.io/" rel="nofollow">ce</a> code est la ramification géante et l'abondance de déballage des paquets, même dans des <code>if</code> difficiles.  Cette option n'est également pas bonne. </p><br><h2 id="refleksiya-i-metadannye">  Réflexion et métadonnées </h2><br><p>  Eh bien, jouez et ça suffit.  Tout le monde sait qu'il existe des opérateurs en <code>C#</code> qui peuvent être remplacés.  Là, il y a <code>+</code> , <code>-</code> , <code>==</code> <code>!=</code> Et ainsi de suite.  Tout ce que nous devons faire est de retirer une méthode statique de type <code>T</code> correspondant à l'opérateur, par exemple, des ajouts - c'est tout.  Eh bien, oui, encore une fois quelques packages, mais pas de branchement et pas de problèmes.  Le tout peut être mis en cache par le type <code>T</code> et généralement accélérer le processus dans tous les sens, réduisant une opération mathématique à l'appel d'une méthode de réflexion unique.  Eh bien, quelque chose comme ça: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T Add&lt;T&gt;(T left, T right) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-comment"><span class="hljs-comment">// Simple example without cache. var method = typeof(T) .GetMethod(@"op_Addition", new [] {typeof(T), typeof(T)}) ?.CreateDelegate(typeof(Func&lt;T, T, T&gt;)) as Func&lt;T, T, T&gt;; return method?.Invoke(left, right) ?? throw new InvalidOperationException(); }</span></span></code> </pre> <br><p>  Malheureusement, cela <a href="https://jonskeet.uk/csharp/genericoperators.html" rel="nofollow">ne fonctionne pas</a> .  Le fait est que les types arithmétiques (mais pas <code>decimal</code> ) <em>n'ont pas une</em> telle méthode statique.  Toutes les opérations sont implémentées via des opérations <code>IL</code> , telles que l' <a href="" rel="nofollow"><code>add</code></a> .  Une réflexion normale ne résout pas notre problème. </p><br><h2 id="systemlinqexpressions">  System.Linq.Expressions </h2><br><p>  La solution basée sur les <code>Expressions</code> est décrite sur le blog de <a href="https://twitter.com/jonskeet" rel="nofollow">John Skeet</a> <a href="https://jonskeet.uk/csharp/genericoperators.html" rel="nofollow">ici</a> (par Marc Gravell). <br>  L'idée est assez simple.  Supposons que nous ayons un type <code>T</code> qui prend en charge l'opération <code>+</code> .  Créons une expression comme celle-ci: </p><br><pre> <code class="cs hljs">(x, y) =&gt; x + y;</code> </pre> <br><p>  Après cela, après avoir mis en cache, nous l'utiliserons.  Construire une telle expression est assez facile.  Nous avons besoin de deux paramètres et d'une opération.  Alors écrivons-le. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Dictionary&lt;(Type Type, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Op), Delegate&gt; Cache = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;(Type Type, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Op), Delegate&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T Add&lt;T&gt;(T left, T right) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T); <span class="hljs-comment"><span class="hljs-comment">// If op is cached by type and function name, use cached version if (Cache.TryGetValue((t, nameof(Add)), out var del)) return del is Func&lt;T, T, T&gt; specificFunc ? specificFunc(left, right) : throw new InvalidOperationException(nameof(Add)); var leftPar = Expression.Parameter(t, nameof(left)); var rightPar = Expression.Parameter(t, nameof(right)); var body = Expression.Add(leftPar, rightPar); var func = Expression.Lambda&lt;Func&lt;T, T, T&gt;&gt;(body, leftPar, rightPar).Compile(); Cache[(t, nameof(Add))] = func; return func(left, right); }</span></span></code> </pre> <br><p>  Des informations utiles sur les arbres d'expression et les délégués ont été publiées sur le hub </p><br><p>  Techniquement, les expressions nous permettent de résoudre tous nos problèmes - toute opération de base peut être réduite à appeler une méthode généralisée.  Toute opération plus complexe peut être écrite de la même manière, en utilisant des expressions plus complexes.  C'est <em>presque</em> suffisant. </p><br><h2 id="narushaem-vse-pravila">  Nous brisons toutes les règles </h2><br><p>  Est-il possible de réaliser autre chose en utilisant la puissance de <code>CLR/C#</code> ?  Voyons quelle <s>année le</s> code est généré par des méthodes d'addition <a href="https://sharplab.io/" rel="nofollow">pour différents types</a> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Class</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> =&gt; x + y; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> =&gt; x + y; <span class="hljs-comment"><span class="hljs-comment">// Decimal only to show difference public static decimal Add(decimal x, decimal y) =&gt; x + y; }</span></span></code> </pre> <br><p>  Le code <code>IL</code> correspondant contient le même ensemble d'instructions: </p><br><pre> <code class="cs hljs">ldarg<span class="hljs-number"><span class="hljs-number">.0</span></span> ldarg<span class="hljs-number"><span class="hljs-number">.1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> ret</code> </pre> <br><p>  Il s'agit du code op très <a href="" rel="nofollow"><code>add</code></a> dans lequel l'ajout de types primitifs arithmétiques est compilé.  <code>decimal</code> à cet endroit appelle <code>static decimal decimal.op_Addition(decimal, decimal)</code> .  Mais que se passe-t-il si nous écrivons une méthode qui sera généralisée, mais qui contient exactement ce code <code>IL</code> ?  Eh bien, John Skeet prévient que cela <a href="https://jonskeet.uk/csharp/genericoperators.html" rel="nofollow">n'en vaut pas la peine</a> .  Dans son cas, il considère tous les types (y compris <code>decimal</code> ), ainsi que leurs analogues <code>nullable</code> .  Cela nécessitera des opérations <code>IL</code> tout à fait non triviales et conduira nécessairement à une erreur.  Mais nous pouvons toujours essayer de mettre en œuvre des opérations de base. </p><br><p>  À ma grande surprise, <code>Visual Studio</code> ne contient pas de modèles pour les projets <code>IL</code> et les fichiers <code>IL</code> .  Vous ne pouvez pas simplement prendre et décrire une partie du code dans <code>IL</code> et l'inclure dans votre assembly.  Naturellement, l'open source vient à notre aide.  Le projet <a href="https://github.com/ins0mniaque/ILSupport" rel="nofollow"><code>ILSupport</code></a> contient des modèles pour les projets <code>IL</code> , ainsi qu'un ensemble d'instructions qui peuvent être ajoutées à <code>*.csproj</code> pour inclure le code <code>IL</code> dans le projet.  Bien sûr, tout décrire en <code>IL</code> est assez difficile, donc l'auteur du projet utilise l'attribut <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.methodimplattribute%3Fview%3Dnetcore-3.0" rel="nofollow"><code>MethodImpl</code></a> avec l'indicateur <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.methodimploptions%3Fredirectedfrom%3DMSDN%26view%3Dnetcore-3.0" rel="nofollow"><code>ForwardRef</code></a> .  Cet attribut vous permet de déclarer la méthode comme <code>extern</code> et de ne pas décrire le corps de la méthode.  Cela ressemble à ceci: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">MethodImpl(MethodImplOptions.ForwardRef)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> T Add&lt;T&gt;(T left, T right) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged;</code> </pre> <br><p>  L'étape suivante consiste à écrire l'implémentation de la méthode dans le fichier <code>*.il</code> avec le code <code>IL</code> : </p><br><pre> <code class="cs hljs">.method <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> hidebysig !!T Add&lt;valuetype .ctor (<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> [<span class="hljs-title"><span class="hljs-title">mscorlib</span></span>]<span class="hljs-title"><span class="hljs-title">System</span></span>.<span class="hljs-title"><span class="hljs-title">ValueType</span></span> <span class="hljs-title"><span class="hljs-title">modreq</span></span> ([<span class="hljs-title"><span class="hljs-title">mscorlib</span></span>]<span class="hljs-title"><span class="hljs-title">System</span></span>.<span class="hljs-title"><span class="hljs-title">Runtime</span></span>.<span class="hljs-title"><span class="hljs-title">InteropServices</span></span>.<span class="hljs-title"><span class="hljs-title">UnmanagedType</span></span>)) <span class="hljs-title"><span class="hljs-title">T</span></span>&gt;(!!<span class="hljs-title"><span class="hljs-title">T</span></span> <span class="hljs-title"><span class="hljs-title">left</span></span>, !!<span class="hljs-title"><span class="hljs-title">T</span></span> <span class="hljs-title"><span class="hljs-title">right</span></span>) <span class="hljs-title"><span class="hljs-title">cil</span></span> <span class="hljs-title"><span class="hljs-title">managed</span></span> { .param type [<span class="hljs-number"><span class="hljs-number">1</span></span>] .custom instance <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> System.Runtime.CompilerServices.IsUnmanagedAttribute::.ctor() = (<span class="hljs-number"><span class="hljs-number">01</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ) ldarg<span class="hljs-number"><span class="hljs-number">.0</span></span> ldarg<span class="hljs-number"><span class="hljs-number">.1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> ret }</code> </pre> <br><p>  Nulle part faisant explicitement référence au type <code>!!T</code> , nous suggérons au <code>CLR</code> d'ajouter deux arguments et de renvoyer le résultat.  Il n'y a <strong>pas de</strong> vérification de type et tout est dans la conscience du développeur.  Étonnamment, cela fonctionne, et <em>relativement</em> rapidement. </p><br><h2 id="nemnogo-benchmarka">  Un peu de référence </h2><br><p>  Probablement, un point de repère honnête serait construit sur une expression assez complexe, dont le calcul serait comparé de front à ces dangereuses méthodes <code>IL</code> .  J'ai écrit un algorithme simple qui résume les carrés de nombres précédemment calculés et stockés dans un <code>double</code> tableau et divise le montant final par le nombre de nombres.  Pour effectuer l'opération, j'ai utilisé les opérateurs <code>C#</code> <code>+</code> , <code>*</code> et <code>/</code> , comme le font les personnes saines, les fonctions construites avec les <code>Expressions</code> et les fonctions <code>IL</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Les résultats sont approximativement les suivants:</b> <div class="spoiler_text"><ul><li>  <code>DirectSum</code> est la somme utilisant les opérateurs standard <code>+</code> , <code>*</code> et <code>/</code> ; </li><li>  <code>BranchSum</code> utilise la ramification par type et transforme en <code>object</code> ; </li><li>  <code>UnsafeBranchSum</code> utilise un branchement par type et <code>Unsafe.As&lt;,&gt;()</code> par <code>Unsafe.As&lt;,&gt;()</code> ; </li><li>  <code>ExpressionSum</code> utilise des expressions mises en cache pour chaque opération ( <code>Expression</code> ); </li><li>  <code>UnsafeSum</code> utilise le code <code>IL</code> unsafe présenté dans l'article </li></ul><br><p>  Repère de charge utile - additionnant les carrés d'éléments d'un tableau prérempli au hasard de type <code>double</code> et de taille <code>N</code> , suivi de la division de la somme par <code>N</code> et de son stockage;  optimisations incluses. </p><br><pre> <code class="plaintext hljs">BenchmarkDotNet=v0.12.0, OS=Windows 10.0.18362 Intel Core i7-2700K CPU 3.50GHz (Sandy Bridge), 1 CPU, 8 logical and 4 physical cores .NET Core SDK=3.1.100 [Host] : .NET Core 3.1.0 (CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404), X64 RyuJIT Job-POXTAH : .NET Core 3.1.0 (CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404), X64 RyuJIT Runtime=.NET Core 3.1</code> </pre><br><div class="scrollable-table"><table><thead><tr><th>  La méthode </th><th>  N </th><th>  Moyenne </th><th>  Erreur </th><th>  Stddev </th><th>  Ratio </th><th>  RatioSD </th></tr></thead><tbody><tr><td>  <strong>Directsum</strong> </td><td>  <strong>1000</strong> </td><td>  <strong>2.128 nous</strong> </td><td>  <strong>0,0341 nous</strong> </td><td>  <strong>0,0303 nous</strong> </td><td>  <strong>1,00</strong> </td><td>  <strong>0,00</strong> </td></tr><tr><td>  Branchum </td><td>  1000 </td><td>  57.468 us </td><td>  0.4478 us </td><td>  0,3496 us </td><td>  26,97 </td><td>  0,46 </td></tr><tr><td>  UnsafeBranchSum </td><td>  1000 </td><td>  72.924 us </td><td>  0.4131 us </td><td>  0,3864 us </td><td>  34,28 </td><td>  0,50 </td></tr><tr><td>  ExpressionSum </td><td>  1000 </td><td>  144.555 us </td><td>  2.5182 us </td><td>  2.2323 us </td><td>  67,94 </td><td>  1,29 </td></tr><tr><td>  Unsafesum </td><td>  1000 </td><td>  5.054 us </td><td>  0,0324 us </td><td>  0,0303 nous </td><td>  2,37 </td><td>  0,03 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  <strong>Directsum</strong> </td><td>  <strong>10 000</strong> </td><td>  <strong>21.174 us</strong> </td><td>  <strong>0,3092 us</strong> </td><td>  <strong>0,2741 nous</strong> </td><td>  <strong>1,00</strong> </td><td>  <strong>0,00</strong> </td></tr><tr><td>  Branchum </td><td>  10 000 </td><td>  573.972 us </td><td>  2.9274 us </td><td>  2.5951 us </td><td>  27/11 </td><td>  0,40 </td></tr><tr><td>  UnsafeBranchSum </td><td>  10 000 </td><td>  735.031 us </td><td>  9.1016 us </td><td>  8.0683 us </td><td>  34,72 </td><td>  0,53 </td></tr><tr><td>  ExpressionSum </td><td>  10 000 </td><td>  1,462.593 us </td><td>  9.0932 us </td><td>  8.0609 us </td><td>  69,09 </td><td>  1.02 </td></tr><tr><td>  Unsafesum </td><td>  10 000 </td><td>  50,388 us </td><td>  0.3956 us </td><td>  0.3701 us </td><td>  2,38 </td><td>  0,03 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  <strong>Directsum</strong> </td><td>  <strong>100 000</strong> </td><td>  <strong>210.021 us</strong> </td><td>  <strong>1.9832 us</strong> </td><td>  <strong>1.7581 us</strong> </td><td>  <strong>1,00</strong> </td><td>  <strong>0,00</strong> </td></tr><tr><td>  Branchum </td><td>  100 000 </td><td>  6046340 us </td><td>  86,9740 us </td><td>  77.1002 us </td><td>  28,79 </td><td>  0,42 </td></tr><tr><td>  UnsafeBranchSum </td><td>  100 000 </td><td>  7,406.489 us </td><td>  65,7415 us </td><td>  58.2782 us </td><td>  35,27 </td><td>  0,27 </td></tr><tr><td>  ExpressionSum </td><td>  100 000 </td><td>  14021,642 us </td><td>  189.2625 us </td><td>  167.7763 us </td><td>  66,77 </td><td>  0,88 </td></tr><tr><td>  Unsafesum </td><td>  100 000 </td><td>  505.551 us </td><td>  2.3662 us </td><td>  2.2133 nous </td><td>  2,41 </td><td>  0,03 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  <strong>Directsum</strong> </td><td>  <strong>1 024 000</strong> </td><td>  <strong>2,306.751 us</strong> </td><td>  <strong>22.4173 us</strong> </td><td>  <strong>20.9692 us</strong> </td><td>  <strong>1,00</strong> </td><td>  <strong>0,00</strong> </td></tr><tr><td>  Branchum </td><td>  1 024 000 </td><td>  61,643.224 us </td><td>  610.3048 us </td><td>  570.8795 us </td><td>  26,72 </td><td>  0,28 </td></tr><tr><td>  UnsafeBranchSum </td><td>  1 024 000 </td><td>  75,644.639 us </td><td>  494.4096 us </td><td>  462.4711 us </td><td>  32,80 </td><td>  0,39 </td></tr><tr><td>  ExpressionSum </td><td>  1 024 000 </td><td>  154327,137 us </td><td>  1267.2469 us </td><td>  1185,3835 us </td><td>  66,91 </td><td>  0,55 </td></tr><tr><td>  Unsafesum </td><td>  1 024 000 </td><td>  5,295.990 us </td><td>  14.9537 us </td><td>  12.4871 us </td><td>  2.29 </td><td>  0,02 </td></tr></tbody></table></div></div></div><br><p>  Notre code dangereux est environ <code>2.5</code> fois plus lent (en termes d'une opération).  Cela peut être attribué au fait que dans le cas d'un calcul "frontal", le compilateur compile <code>a + b</code> dans le code d'opération <code>add</code> , et dans le cas d'une méthode non sûre, une fonction statique est appelée, ce qui est naturellement plus lent. </p><br><h2 id="vmesto-zaklyucheniya-kogda-true--true">  Au lieu de conclure: quand <code>true != true</code> </h2><br><p>  Il y a quelques jours, j'ai rencontré un tel <a href="https://twitter.com/jaredpar/status/1205540750764625920" rel="nofollow">tweet de</a> Jared Parsons: </p><br><blockquote>  Il y a des cas où ce qui suit imprimera "faux" <br>  bool b = ... <br>  if (b) Console.WriteLine (b.IsTrue ()); </blockquote><p>  C'était la réponse à <a href="https://twitter.com/vreshetnikov/status/1204929378368417792" rel="nofollow">cette entrée</a> , qui montre le code de vérification <code>bool</code> pour <code>true</code> , qui ressemble à ceci: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsTrue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !<span class="hljs-literal"><span class="hljs-literal">true</span></span> &amp;&amp; !<span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><p>  Les chèques semblent redondants, non?  Jared donne un contre-exemple qui montre <a href="https://gist.github.com/jaredpar/a0835afc71139284c09bfda203d8c011" rel="nofollow">certaines des caractéristiques</a> du comportement <code>bool</code> .  L'idée est que <code>bool</code> est <code>byte</code> ( <code>sizeof(bool) == 1</code> ), tandis que <code>false</code> correspond à <code>0</code> et <code>true</code> <code>1</code> .  Tant que vous ne balancez pas les pointeurs, <code>bool</code> se comporte sans ambiguïté et de manière prévisible.  Cependant, comme Jared l'a montré, vous pouvez créer un <code>bool</code> utilisant <code>2</code> comme valeur initiale, et une partie des vérifications échouera correctement: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>* ptr = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*)&amp;b; *ptr = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><p>  Nous pouvons obtenir un effet similaire en utilisant nos opérations mathématiques dangereuses (cela ne fonctionne pas avec les <code>Expressions</code> ): </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fakeTrue = Subtract&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> val = *(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*)&amp;fakeTrue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(fakeTrue) Assert.AreNotEqual(fakeTrue, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Assert.Fail(<span class="hljs-string"><span class="hljs-string">"Clause not entered."</span></span>);</code> </pre> <br><p>  Oui, oui, nous vérifions à l'intérieur de la <code>true</code> branche si la condition est <code>true</code> , et nous nous attendons à ce qu'elle <em>ne</em> soit <em>pas <code>true</code></em> .  Pourquoi en est-il ainsi?  Si vous soustrayez de <code>0</code> ( <code>=false</code> ) <code>1</code> ( <code>=true</code> ) sans vérifications, alors pour l' <code>byte</code> ce sera égal à <code>255</code> .  Naturellement, <code>255</code> (notre <code>fakeTrue</code> ) n'est pas <code>1</code> (vrai <code>true</code> ), donc assert est exécuté.  La ramification fonctionne différemment. </p><br><p>  <code>if</code> inversion se produit: une branche conditionnelle est insérée;  si la condition est <em>fausse</em> , alors une transition vers le point se produit après la fin du bloc <code>if</code> .  La validation est effectuée par l' <code>brfalse</code> / <code>brfalse_S</code> .  Il compare la dernière valeur de la pile à <em>zéro</em> .  Si la valeur est nulle, alors elle est <code>false</code> , nous enjambons le bloc <code>if</code> .  Dans notre cas, <code>fakeTrue</code> n'est tout simplement pas égal à zéro, donc la vérification réussit et l'exécution se poursuit à l'intérieur du bloc <code>if</code> , où nous comparons <code>fakeBool</code> avec la vraie valeur et obtenons un résultat négatif. </p><br><p>  UPD01: <br>  Après avoir discuté dans les commentaires avec <a href="https://habr.com/en/users/shai_hulud/" class="user_link">shai_hulud</a> et <a href="https://habr.com/en/users/blowin/" class="user_link">blowin</a> , j'ai ajouté une autre méthode aux benchmarks qui implémente une branche comme <code>if(typeof(T) == typeof(int)) return (T)(object)((int)(object)left + (int)(object)right);</code>  .  Malgré le fait que <code>JIT</code> devrait optimiser les contrôles, au moins lorsque <code>T</code> est une <code>struct</code> , de telles méthodes fonctionnent toujours plus lentement.  Il n'est pas évident si les transformations <code>T</code> -&gt; <code>int</code> -&gt; <code>T</code> optimisées, ou si la boxe / unboxing est utilisée.  Les résultats de l'indice de référence <code>MethodImpl</code> sont <code>MethodImpl</code> significativement affectés par les indicateurs <code>MethodImpl</code> . </p><br><p>  UPD02: <br>  <a href="https://habr.com/en/users/xxxvano/" class="user_link">xXxVano</a> dans les commentaires a montré un exemple d'utilisation de la ramification par type et transforme <code>T</code> &lt;--&gt; un type spécifique en utilisant <code>Unsafe.As&lt;TFrom, TTo&gt;()</code> .  Par analogie avec la ramification habituelle et l' <code>object</code> personnalisé à travers, j'ai écrit trois opérations (addition, multiplication et division) avec ramification pour tous les types arithmétiques, après quoi j'ai ajouté une autre référence ( <code>UnsafeBranchSum</code> ).  Malgré le fait que toutes les méthodes (sauf les expressions) génèrent du code asm presque identique (pour autant que ma connaissance limitée de l'assembleur me permette de juger), pour une raison inconnue pour moi, les deux méthodes de branchement sont très lentes par rapport à la sommation directe ( <code>DirectSum</code> ) et en utilisant des génériques et du code <code>IL</code> .  Je n'ai aucune explication à cet effet, le fait que le temps passé augmente proportionnellement à <code>N</code> indique qu'il y a une sorte de surcharge constante pour <em>chaque</em> opération, malgré toute la magie du <code>JIT</code> .  Cette surcharge est absente de la version <code>IL</code> des méthodes.   ,   <code>IL</code> -    ,    /    /  ,          100%  (  ,   ). <br>   ,      , -       . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr480416/">https://habr.com/ru/post/fr480416/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr480402/index.html">Comment p̶е̶р Tв̶ы̶й̶ le deuxième mitap Android de Tinkoff</a></li>
<li><a href="../fr480404/index.html">Mikrotik et Linux. Routine et automatisation</a></li>
<li><a href="../fr480408/index.html">52 jeu de données pour les projets de formation</a></li>
<li><a href="../fr480412/index.html">Alexei Ragozin à propos des nouvelles et anciennes fonctionnalités de Java Flight Recorder dans OpenJDK 11 lors de la réunion jug.msk.ru</a></li>
<li><a href="../fr480414/index.html">Le condensé de matières fraîches du monde du front-end de la dernière semaine n ° 393 (9-15 décembre 2019)</a></li>
<li><a href="../fr480422/index.html">Google Style Guide en C ++. Partie 1</a></li>
<li><a href="../fr480424/index.html">Google Style Guide en C ++. Partie 9</a></li>
<li><a href="../fr480428/index.html">La méthode de raccourci le plus simple. Alphabet et police pour elle.</a></li>
<li><a href="../fr480430/index.html">Fonctionnement du codec vidéo. Partie 2. Quoi, pourquoi, comment</a></li>
<li><a href="../fr480432/index.html">Le problème du premier visualiseur ou la difficile conversion des flux vidéo WebRTC en HLS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>