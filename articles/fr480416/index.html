<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë≤üèø ü•† üè© Maths g√©n√©riques dangereux en C # üßü ‚è™ üêô</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Malheureusement, il n'a pas √©t√© facile de traduire correctement le nom de la laideur que j'ai commenc√© en russe. J'ai √©t√© surpris de constater que la ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Maths g√©n√©riques dangereux en C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480416/"><p><img src="https://habrastorage.org/webt/mj/zg/yw/mjzgywquj0lud4_vs9bjh8xdacu.png"></p><br><p> Malheureusement, il n'a pas √©t√© facile de traduire correctement le nom de la laideur que j'ai commenc√© en russe.  J'ai √©t√© surpris de constater que la documentation <a href="https://docs.microsoft.com/ru-ru/dotnet/csharp/programming-guide/generics/" rel="nofollow">MSDN</a> officielle appelle des ¬´mod√®les¬ª ¬´g√©n√©riques¬ª (similaires aux mod√®les <code>C++</code> , je suppose).  Dans la 4e √©dition de <a href="https://www.microsoftpressstore.com/store/clr-via-c-sharp-9780735667457" rel="nofollow"><code>"CLR</code> via <code>C#</code></a> qui m'a frapp√© <a href="https://www.microsoftpressstore.com/store/clr-via-c-sharp-9780735667457" rel="nofollow">,</a> <a href="https://twitter.com/jeffrichter" rel="nofollow">Jeffrey Richter</a> , traduit par <a href="https://habr.com/en/company/piter/">Peter</a> , les g√©n√©riques sont appel√©s ¬´g√©n√©ralisations¬ª, ce qui refl√®te bien mieux l'essence du concept.  Cet article parlera <em>des op√©rations math√©matiques g√©n√©ralis√©es dangereuses en <code>C#</code></em> .  √âtant donn√© que <code>C#</code> pas destin√© √† l'informatique haute performance (bien qu'il puisse certainement, mais n'est pas en mesure de rivaliser avec le m√™me <code>C/C++</code> ), <code>BCL</code> ne pr√™te pas beaucoup d'attention aux op√©rations math√©matiques.  Essayons de simplifier le travail avec les types arithm√©tiques de base en utilisant <code>C#</code> et <code>CLR</code> . </p><a name="habracut"></a><br><h2 id="postanovka-zadachi">  √ânonc√© du probl√®me </h2><br><p>  <strong>Avertissement</strong> : l'article contiendra de nombreux fragments de code, dont certains que <a href="https://sharplab.io/" rel="nofollow">j'illustrerai</a> avec des liens vers la merveilleuse ressource <a href="https://sharplab.io/" rel="nofollow">SharpLab</a> ( <a href="https://github.com/ashmind/SharpLab" rel="nofollow">Gi <s>r</s> tHub</a> ) d' <a href="https://twitter.com/ashmind" rel="nofollow">Andrey Shchekin</a> . </p><br><p>  La plupart des calculs se r√©sument d'une mani√®re ou d'une autre aux op√©rations de base.  L'addition, la soustraction (inversion, n√©gation), la multiplication et la division peuvent √™tre compl√©t√©es par des op√©rations de comparaison et de v√©rification de l'√©galit√©.  Bien s√ªr, toutes ces actions peuvent √™tre facilement et simplement effectu√©es sur des variables de n'importe quel type arithm√©tique de base de <code>C#</code> .  Le seul probl√®me est que <code>C#</code> devrait <em>savoir</em> au moment de la compilation que les op√©rations sont effectu√©es sur des types sp√©cifiques, et il semble que l'√©criture d'une m√©thode qui ajoute de mani√®re aussi efficace (et transparente) deux entiers et deux nombres √† virgule flottante est impossible. </p><br><p>  Pr√©cisons nos souhaits pour une m√©thode g√©n√©ralis√©e hypoth√©tique qui effectue une op√©ration math√©matique simple: </p><br><ol><li>  Une m√©thode doit avoir des restrictions de type g√©n√©ralis√©es qui nous emp√™chent d'essayer d'ajouter (ou de multiplier, de diviser) deux types arbitraires.  Nous avons besoin d'une contrainte de type g√©n√©rique. </li><li>  Pour la puret√© de l'exp√©rience, les types accept√©s et retourn√©s doivent √™tre les m√™mes.  Par exemple, un op√©rateur binaire doit avoir une signature de la forme <code>(T, T) =&gt; T</code> </li><li>  La m√©thode doit √™tre au moins partiellement optimis√©e.  Par exemple, la boxe omnipr√©sente est inacceptable. </li></ol><br><h2 id="a-chto-tam-u-sosedey">  Et les voisins? </h2><br><p>  Regardons <code>F#</code> .  Je ne suis pas fort en <code>F#</code> , mais la plupart des restrictions <code>C#</code> sont dict√©es par les limitations <code>CLR</code> , ce qui signifie que <code>F#</code> souffre des m√™mes probl√®mes.  Vous pouvez essayer de d√©clarer une m√©thode d'addition g√©n√©ralis√©e explicite et la m√©thode d'addition habituelle et voir ce que dit le syst√®me d'inf√©rence de type <code>F#</code> : </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">let</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_gen</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'a) (y : '</span></span></span></span><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">)</span></span> = x + y <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> xy = x + y add_gen <span class="hljs-number"><span class="hljs-number">5.0</span></span> <span class="hljs-number"><span class="hljs-number">6.0</span></span> |&gt; ignore <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-number"><span class="hljs-number">5.0</span></span> <span class="hljs-number"><span class="hljs-number">6.0</span></span> |&gt; ignore</code> </pre> <br><p>  Dans <a href="https://sharplab.io/" rel="nofollow">ce cas, les</a> deux m√©thodes se r√©v√©leront non g√©n√©ralis√©es et le code g√©n√©r√© sera identique.  √âtant donn√© la rigidit√© du syst√®me de type <code>F#</code> , o√π il n'y a pas de conversions implicites de la forme <code>int -&gt; double</code> , apr√®s le premier appel de ces m√©thodes avec des param√®tres de type <code>double</code> (en termes <code>C#</code> ), appelez des m√©thodes avec des param√®tres d'autres types (m√™me avec une possible perte de pr√©cision due √† la conversion de type) plus √©chouera. </p><br><p>  Il convient de noter que si vous remplacez l'op√©rateur <code>+</code> par l'op√©rateur d'√©galit√© <code>=</code> , l' <a href="https://sharplab.io/" rel="nofollow">image devient quelque peu diff√©rente</a> : les deux m√©thodes deviennent g√©n√©ralis√©es (du point de vue de <code>C#</code> ), et une m√©thode d'assistance sp√©ciale disponible en <code>F#</code> est appel√©e pour effectuer la comparaison. </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">let</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eq_gen</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'a) (y : '</span></span></span></span><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">)</span></span> = x = y <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> eq xy = x = y eq_gen <span class="hljs-number"><span class="hljs-number">5.0</span></span> <span class="hljs-number"><span class="hljs-number">6.0</span></span> |&gt; ignore eq_gen <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> |&gt; ignore eq <span class="hljs-number"><span class="hljs-number">5.0</span></span> <span class="hljs-number"><span class="hljs-number">6.0</span></span> |&gt; ignore eq <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> |&gt; ignore</code> </pre> <br><h3 id="chto-naschet-java">  Et <code>Java</code> ? </h3><br><p>  Il m'est difficile de parler de <code>Java</code> , mais, pour autant que je sache, les types significatifs <a href="https://en.wikipedia.org/wiki/Comparison_of_C_Sharp_and_Java" rel="nofollow">ne</a> sont <a href="https://en.wikipedia.org/wiki/Comparison_of_C_Sharp_and_Java" rel="nofollow">pas</a> l√† sous la forme habituelle pour nous, mais il existe encore <em>des</em> types <em>primitifs</em> .  Pour travailler avec les primitives en <code>Java</code> il existe des <a href="https://en.wikipedia.org/wiki/Comparison_of_C_Sharp_and_Java" rel="nofollow">wrappers</a> (par exemple, une r√©f√©rence <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Long.html" rel="nofollow"><code>Long</code></a> pour la primitive par valeur <code>long</code> ), qui ont un <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Number.html" rel="nofollow"><code>Number</code></a> classe de base commun.  Ainsi, vous pouvez g√©n√©raliser partiellement les op√©rations √† l'aide de <code>Number</code> , mais il s'agit d'un type de r√©f√©rence, qui est peu susceptible d'avoir un effet positif sur les performances. </p><br><p>  <em>Corrigez-moi si je me trompe.</em> </p><br><h3 id="c">  <code>C++</code> ? </h3><br><p>  <code>C++</code> est un langage pour les tricheurs. <br>  <code>C++</code> ouvre la voie √† des fonctionnalit√©s que certains consid√®rent ... contre <a href="https://ru.wikiquote.org/wiki/%25D0%2597%25D0%25B2%25D1%2591%25D0%25B7%25D0%25B4%25D0%25BD%25D1%258B%25D0%25B5_%25D0%25B2%25D0%25BE%25D0%25B9%25D0%25BD%25D1%258B._%25D0%25AD%25D0%25BF%25D0%25B8%25D0%25B7%25D0%25BE%25D0%25B4_III:_%25D0%259C%25D0%25B5%25D1%2581%25D1%2582%25D1%258C_%25D1%2581%25D0%25B8%25D1%2582%25D1%2585%25D0%25BE%25D0%25B2" rel="nofollow">nature</a> . <br>  Les mod√®les (ou mod√®les), contrairement aux g√©n√©ralisations (g√©n√©riques), sont, au sens litt√©ral, des <em>mod√®les</em> .  Lors de la d√©claration d'un mod√®le, vous pouvez restreindre explicitement les types pour lesquels ce mod√®le est disponible.  Pour cette raison, en <code>C++</code> , par exemple, le code suivant est valide: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; template&lt;typename T, std::enable_if_t&lt;std::is_arithmetic&lt;T&gt;::value&gt;* = nullptr&gt; T Add (T left, T right) { return left + right; } int main() { std::cout &lt;&lt; Add(5, 6) &lt;&lt; std::endl; std::cout &lt;&lt; Add(5.0, 6.0) &lt;&lt; std::endl; // std::cout &lt;&lt; Add("a", "b") &lt;&lt; std::endl; Does not compile }</span></span></span></span></code> </pre> <br><p>  <code>is_arithmetic</code> , malheureusement, autorise √† la fois <code>char</code> et <code>bool</code> comme param√®tres.  D'un autre c√¥t√©, <code>char</code> peut √™tre √©quivalent √† <code>sbyte</code> dans la terminologie <code>C#</code> , bien que les tailles r√©elles des types entiers d√©pendent de la plate-forme / du compilateur / de la phase lunaire. </p><br><h3 id="yazyki-s-dinamicheskoy-tipizaciey">  Langages de frappe dynamiques </h3><br><p>  Enfin, consid√©rons quelques langages typ√©s dynamiquement (et <em>interpr√©t√©s</em> ), affin√©s par le calcul.  Dans de tels langages, la g√©n√©ralisation du calcul ne pose g√©n√©ralement pas de probl√®mes: si le type de param√®tres est adapt√© √† l'ex√©cution, conditionnellement, l'addition, alors l'op√©ration sera effectu√©e, sinon elle √©chouera avec une erreur. </p><br><p>  En <code>Python</code> (3.7.3 x64): </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y type(add(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># &lt;class 'int'&gt; type(add(5.0, 6.0)) # &lt;class 'float'&gt; type(add('a', 'b') # &lt;class 'str'&gt;</span></span></code> </pre> <br><p>  Dans <code>R</code> (3.6.1 x64) </p><br><pre> <code class="cpp hljs">add &lt;- function(x, y) x + y # <span class="hljs-function"><span class="hljs-function">Or </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">typeof</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> vctrs::</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vec_ptype_show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(add(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">6</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> # Prototype: </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> vctrs::</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vec_ptype_show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(add(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5L</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">6L</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> # Prototype: integer vctrs::</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vec_ptype_show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(add(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"5"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"6"</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> # Error in x + y : non-numeric argument to binary </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span></span></code> </pre> <br><h2 id="obratno-v-mir-c-ogranichivaem-obobschennyy-tip-matematicheskoy-funkcii">  Inversement, dans le monde C #: on restreint le type g√©n√©ralis√© de fonction math√©matique </h2><br><p>  Malheureusement, nous ne pouvons pas faire cela.  En <code>C#</code> les types primitifs sont des types par valeur, c'est-√†-dire  structures qui, bien <code>System.Object</code> de <code>System.Object</code> (et <a href="https://docs.microsoft.com/en-us/dotnet/api/system.valuetype%3Fview%3Dnetcore-3.0" rel="nofollow"><code>System.ValueType</code></a> ), n'ont pas grand-chose en commun.  Une limitation naturelle et logique est celle <code>where T : struct</code> .  √Ä partir de <code>C# 7.3</code> nous avons la contrainte <code>where T : unmanaged</code> , ce qui signifie que <code>T</code> est un <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types" rel="nofollow"><code> ,        null</code></a> .  En plus des types arithm√©tiques primitifs dont nous avons besoin, <code>char</code> , <code>bool</code> , <code>decimal</code> , <em>any</em> <code>Enum</code> et <em>toute</em> structure dont tous les champs ont le m√™me type <code>unmanaged</code> manag√© satisfont √† ces exigences.  C'est-√†-dire  <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types" rel="nofollow">ce type</a> passera le test: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Coords&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TX; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TY; }</code> </pre> <br><p>  Ainsi, nous ne pouvons pas √©crire une fonction g√©n√©ralis√©e qui accepte uniquement les types arithm√©tiques souhait√©s.  D'o√π l' <code>Unsafe</code> dans le titre de l'article - nous devrons nous fier aux programmeurs utilisant notre code.  Une tentative d'appeler une m√©thode hypoth√©tique g√©n√©ralis√©e <code>T Add&lt;T&gt;(T left, T right) where T : unmanaged</code> conduira √† des r√©sultats impr√©visibles si le programmeur passe en argument des objets d'un type incompatible. </p><br><h2 id="eksperiment-pervyy-naivnyy-dynamic">  La premi√®re exp√©rience, na√Øve: <code>dynamic</code> </h2><br><p>  <code>dynamic</code> est le premier et √©vident outil qui peut nous aider √† r√©soudre notre probl√®me.  Bien s√ªr, l'utilisation de la <code>dynamic</code> pour les calculs est absolument inutile - la <code>dynamic</code> √©quivalente √† l' <code>object</code> , et les m√©thodes appel√©es avec une variable <code>dynamic</code> sont transform√©es en une r√©flexion monstrueuse par le compilateur.  En prime - emballer / d√©baller nos types de valeur.  Voici <a href="https://sharplab.io/" rel="nofollow">un exemple</a> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Class</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = Add(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = Add(<span class="hljs-number"><span class="hljs-number">5.0</span></span>, <span class="hljs-number"><span class="hljs-number">6.0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">dynamic</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">dynamic</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">dynamic</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right</span></span></span><span class="hljs-function">)</span></span> =&gt; left + right; }</code> </pre> <br><p>  Regardez simplement l' <code>IL</code> la m√©thode <code>Method</code> : </p><br><pre> <code class="cs hljs">.<span class="hljs-function"><span class="hljs-function">method </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> hidebysig </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) cil managed</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Method begins at RVA 0x2050 // Code size 53 (0x35) .maxstack 8 IL_0000: ldc.i4.5 IL_0001: box [System.Private.CoreLib]System.Int32 IL_0006: ldc.i4.6 IL_0007: box [System.Private.CoreLib]System.Int32 IL_000c: call object Class::Add(object, object) IL_0011: pop IL_0012: ldc.r8 5 IL_001b: box [System.Private.CoreLib]System.Double IL_0020: ldc.r8 6 IL_0029: box [System.Private.CoreLib]System.Double IL_002e: call object Class::Add(object, object) IL_0033: pop IL_0034: ret } // end of method Class::Method</span></span></code> </pre> <br><p>  Charg√© <code>5</code> , <em>compress√©</em> , charg√© <code>6</code> , compress√©, appel√© <code>object Add(object, object)</code> . <br>  L'option ne nous convient √©videmment pas. </p><br><h2 id="eksperiment-vtoroy-v-lob">  La deuxi√®me exp√©rience, "dans le front" </h2><br><p>  Eh bien, la <code>dynamic</code> n'est pas pour nous, mais le nombre de nos types est fini, et ils sont connus √† l'avance.  Armons-nous avec un <s>pied-de</s> - <s>biche de</s> branche et notons-le: si <em>notre</em> type <em>est</em> , calculons quelque chose, sinon - voici l'exception. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T Add&lt;T&gt;(T left, T right) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i32Left &amp;&amp; right <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i32Right) { <span class="hljs-comment"><span class="hljs-comment">// ??? } // ... throw new NotSupportedException(); }</span></span></code> </pre> <br><p>  III, nous rencontrons ici un probl√®me.  Si vous comprenez avec quels types nous travaillons, vous pouvez √©galement leur appliquer l'op√©ration, puis l'int√©gratif conditionnel r√©sultant doit √™tre converti en un type inconnu <code>T</code> et ce n'est pas tr√®s simple.  L' <code>return (T)(i32Left + i32Right)</code> ne se compile pas - il n'y a aucune garantie que <code>T</code> est <code>int</code> (m√™me si nous savons que c'est le cas).  Vous pouvez essayer la double conversion <code>return (T)(object)(i32Left + i32Right)</code> .  Tout d'abord, le montant est emball√©, puis il est d√©ball√© en <code>T</code>  Cela <strong>ne</strong> fonctionnera <strong>que</strong> si les types <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/boxing-and-unboxing" rel="nofollow">correspondent</a> avant l'emballage et apr√®s l'emballage.  Vous ne pouvez pas emballer <code>int</code> , mais d√©compressez-le en <code>double</code> , m√™me s'il existe une conversion implicite <code>int -&gt; double</code> .  Le probl√®me avec <a href="https://sharplab.io/" rel="nofollow">ce</a> code est la ramification g√©ante et l'abondance de d√©ballage des paquets, m√™me dans des <code>if</code> difficiles.  Cette option n'est √©galement pas bonne. </p><br><h2 id="refleksiya-i-metadannye">  R√©flexion et m√©tadonn√©es </h2><br><p>  Eh bien, jouez et √ßa suffit.  Tout le monde sait qu'il existe des op√©rateurs en <code>C#</code> qui peuvent √™tre remplac√©s.  L√†, il y a <code>+</code> , <code>-</code> , <code>==</code> <code>!=</code> Et ainsi de suite.  Tout ce que nous devons faire est de retirer une m√©thode statique de type <code>T</code> correspondant √† l'op√©rateur, par exemple, des ajouts - c'est tout.  Eh bien, oui, encore une fois quelques packages, mais pas de branchement et pas de probl√®mes.  Le tout peut √™tre mis en cache par le type <code>T</code> et g√©n√©ralement acc√©l√©rer le processus dans tous les sens, r√©duisant une op√©ration math√©matique √† l'appel d'une m√©thode de r√©flexion unique.  Eh bien, quelque chose comme √ßa: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T Add&lt;T&gt;(T left, T right) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-comment"><span class="hljs-comment">// Simple example without cache. var method = typeof(T) .GetMethod(@"op_Addition", new [] {typeof(T), typeof(T)}) ?.CreateDelegate(typeof(Func&lt;T, T, T&gt;)) as Func&lt;T, T, T&gt;; return method?.Invoke(left, right) ?? throw new InvalidOperationException(); }</span></span></code> </pre> <br><p>  Malheureusement, cela <a href="https://jonskeet.uk/csharp/genericoperators.html" rel="nofollow">ne fonctionne pas</a> .  Le fait est que les types arithm√©tiques (mais pas <code>decimal</code> ) <em>n'ont pas une</em> telle m√©thode statique.  Toutes les op√©rations sont impl√©ment√©es via des op√©rations <code>IL</code> , telles que l' <a href="" rel="nofollow"><code>add</code></a> .  Une r√©flexion normale ne r√©sout pas notre probl√®me. </p><br><h2 id="systemlinqexpressions">  System.Linq.Expressions </h2><br><p>  La solution bas√©e sur les <code>Expressions</code> est d√©crite sur le blog de <a href="https://twitter.com/jonskeet" rel="nofollow">John Skeet</a> <a href="https://jonskeet.uk/csharp/genericoperators.html" rel="nofollow">ici</a> (par Marc Gravell). <br>  L'id√©e est assez simple.  Supposons que nous ayons un type <code>T</code> qui prend en charge l'op√©ration <code>+</code> .  Cr√©ons une expression comme celle-ci: </p><br><pre> <code class="cs hljs">(x, y) =&gt; x + y;</code> </pre> <br><p>  Apr√®s cela, apr√®s avoir mis en cache, nous l'utiliserons.  Construire une telle expression est assez facile.  Nous avons besoin de deux param√®tres et d'une op√©ration.  Alors √©crivons-le. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Dictionary&lt;(Type Type, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Op), Delegate&gt; Cache = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;(Type Type, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Op), Delegate&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T Add&lt;T&gt;(T left, T right) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T); <span class="hljs-comment"><span class="hljs-comment">// If op is cached by type and function name, use cached version if (Cache.TryGetValue((t, nameof(Add)), out var del)) return del is Func&lt;T, T, T&gt; specificFunc ? specificFunc(left, right) : throw new InvalidOperationException(nameof(Add)); var leftPar = Expression.Parameter(t, nameof(left)); var rightPar = Expression.Parameter(t, nameof(right)); var body = Expression.Add(leftPar, rightPar); var func = Expression.Lambda&lt;Func&lt;T, T, T&gt;&gt;(body, leftPar, rightPar).Compile(); Cache[(t, nameof(Add))] = func; return func(left, right); }</span></span></code> </pre> <br><p>  Des informations utiles sur les arbres d'expression et les d√©l√©gu√©s ont √©t√© publi√©es sur le hub </p><br><p>  Techniquement, les expressions nous permettent de r√©soudre tous nos probl√®mes - toute op√©ration de base peut √™tre r√©duite √† appeler une m√©thode g√©n√©ralis√©e.  Toute op√©ration plus complexe peut √™tre √©crite de la m√™me mani√®re, en utilisant des expressions plus complexes.  C'est <em>presque</em> suffisant. </p><br><h2 id="narushaem-vse-pravila">  Nous brisons toutes les r√®gles </h2><br><p>  Est-il possible de r√©aliser autre chose en utilisant la puissance de <code>CLR/C#</code> ?  Voyons quelle <s>ann√©e le</s> code est g√©n√©r√© par des m√©thodes d'addition <a href="https://sharplab.io/" rel="nofollow">pour diff√©rents types</a> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Class</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> =&gt; x + y; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> =&gt; x + y; <span class="hljs-comment"><span class="hljs-comment">// Decimal only to show difference public static decimal Add(decimal x, decimal y) =&gt; x + y; }</span></span></code> </pre> <br><p>  Le code <code>IL</code> correspondant contient le m√™me ensemble d'instructions: </p><br><pre> <code class="cs hljs">ldarg<span class="hljs-number"><span class="hljs-number">.0</span></span> ldarg<span class="hljs-number"><span class="hljs-number">.1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> ret</code> </pre> <br><p>  Il s'agit du code op tr√®s <a href="" rel="nofollow"><code>add</code></a> dans lequel l'ajout de types primitifs arithm√©tiques est compil√©.  <code>decimal</code> √† cet endroit appelle <code>static decimal decimal.op_Addition(decimal, decimal)</code> .  Mais que se passe-t-il si nous √©crivons une m√©thode qui sera g√©n√©ralis√©e, mais qui contient exactement ce code <code>IL</code> ?  Eh bien, John Skeet pr√©vient que cela <a href="https://jonskeet.uk/csharp/genericoperators.html" rel="nofollow">n'en vaut pas la peine</a> .  Dans son cas, il consid√®re tous les types (y compris <code>decimal</code> ), ainsi que leurs analogues <code>nullable</code> .  Cela n√©cessitera des op√©rations <code>IL</code> tout √† fait non triviales et conduira n√©cessairement √† une erreur.  Mais nous pouvons toujours essayer de mettre en ≈ìuvre des op√©rations de base. </p><br><p>  √Ä ma grande surprise, <code>Visual Studio</code> ne contient pas de mod√®les pour les projets <code>IL</code> et les fichiers <code>IL</code> .  Vous ne pouvez pas simplement prendre et d√©crire une partie du code dans <code>IL</code> et l'inclure dans votre assembly.  Naturellement, l'open source vient √† notre aide.  Le projet <a href="https://github.com/ins0mniaque/ILSupport" rel="nofollow"><code>ILSupport</code></a> contient des mod√®les pour les projets <code>IL</code> , ainsi qu'un ensemble d'instructions qui peuvent √™tre ajout√©es √† <code>*.csproj</code> pour inclure le code <code>IL</code> dans le projet.  Bien s√ªr, tout d√©crire en <code>IL</code> est assez difficile, donc l'auteur du projet utilise l'attribut <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.methodimplattribute%3Fview%3Dnetcore-3.0" rel="nofollow"><code>MethodImpl</code></a> avec l'indicateur <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.methodimploptions%3Fredirectedfrom%3DMSDN%26view%3Dnetcore-3.0" rel="nofollow"><code>ForwardRef</code></a> .  Cet attribut vous permet de d√©clarer la m√©thode comme <code>extern</code> et de ne pas d√©crire le corps de la m√©thode.  Cela ressemble √† ceci: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">MethodImpl(MethodImplOptions.ForwardRef)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> T Add&lt;T&gt;(T left, T right) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged;</code> </pre> <br><p>  L'√©tape suivante consiste √† √©crire l'impl√©mentation de la m√©thode dans le fichier <code>*.il</code> avec le code <code>IL</code> : </p><br><pre> <code class="cs hljs">.method <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> hidebysig !!T Add&lt;valuetype .ctor (<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> [<span class="hljs-title"><span class="hljs-title">mscorlib</span></span>]<span class="hljs-title"><span class="hljs-title">System</span></span>.<span class="hljs-title"><span class="hljs-title">ValueType</span></span> <span class="hljs-title"><span class="hljs-title">modreq</span></span> ([<span class="hljs-title"><span class="hljs-title">mscorlib</span></span>]<span class="hljs-title"><span class="hljs-title">System</span></span>.<span class="hljs-title"><span class="hljs-title">Runtime</span></span>.<span class="hljs-title"><span class="hljs-title">InteropServices</span></span>.<span class="hljs-title"><span class="hljs-title">UnmanagedType</span></span>)) <span class="hljs-title"><span class="hljs-title">T</span></span>&gt;(!!<span class="hljs-title"><span class="hljs-title">T</span></span> <span class="hljs-title"><span class="hljs-title">left</span></span>, !!<span class="hljs-title"><span class="hljs-title">T</span></span> <span class="hljs-title"><span class="hljs-title">right</span></span>) <span class="hljs-title"><span class="hljs-title">cil</span></span> <span class="hljs-title"><span class="hljs-title">managed</span></span> { .param type [<span class="hljs-number"><span class="hljs-number">1</span></span>] .custom instance <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> System.Runtime.CompilerServices.IsUnmanagedAttribute::.ctor() = (<span class="hljs-number"><span class="hljs-number">01</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ) ldarg<span class="hljs-number"><span class="hljs-number">.0</span></span> ldarg<span class="hljs-number"><span class="hljs-number">.1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> ret }</code> </pre> <br><p>  Nulle part faisant explicitement r√©f√©rence au type <code>!!T</code> , nous sugg√©rons au <code>CLR</code> d'ajouter deux arguments et de renvoyer le r√©sultat.  Il n'y a <strong>pas de</strong> v√©rification de type et tout est dans la conscience du d√©veloppeur.  √âtonnamment, cela fonctionne, et <em>relativement</em> rapidement. </p><br><h2 id="nemnogo-benchmarka">  Un peu de r√©f√©rence </h2><br><p>  Probablement, un point de rep√®re honn√™te serait construit sur une expression assez complexe, dont le calcul serait compar√© de front √† ces dangereuses m√©thodes <code>IL</code> .  J'ai √©crit un algorithme simple qui r√©sume les carr√©s de nombres pr√©c√©demment calcul√©s et stock√©s dans un <code>double</code> tableau et divise le montant final par le nombre de nombres.  Pour effectuer l'op√©ration, j'ai utilis√© les op√©rateurs <code>C#</code> <code>+</code> , <code>*</code> et <code>/</code> , comme le font les personnes saines, les fonctions construites avec les <code>Expressions</code> et les fonctions <code>IL</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Les r√©sultats sont approximativement les suivants:</b> <div class="spoiler_text"><ul><li>  <code>DirectSum</code> est la somme utilisant les op√©rateurs standard <code>+</code> , <code>*</code> et <code>/</code> ; </li><li>  <code>BranchSum</code> utilise la ramification par type et transforme en <code>object</code> ; </li><li>  <code>UnsafeBranchSum</code> utilise un branchement par type et <code>Unsafe.As&lt;,&gt;()</code> par <code>Unsafe.As&lt;,&gt;()</code> ; </li><li>  <code>ExpressionSum</code> utilise des expressions mises en cache pour chaque op√©ration ( <code>Expression</code> ); </li><li>  <code>UnsafeSum</code> utilise le code <code>IL</code> unsafe pr√©sent√© dans l'article </li></ul><br><p>  Rep√®re de charge utile - additionnant les carr√©s d'√©l√©ments d'un tableau pr√©rempli au hasard de type <code>double</code> et de taille <code>N</code> , suivi de la division de la somme par <code>N</code> et de son stockage;  optimisations incluses. </p><br><pre> <code class="plaintext hljs">BenchmarkDotNet=v0.12.0, OS=Windows 10.0.18362 Intel Core i7-2700K CPU 3.50GHz (Sandy Bridge), 1 CPU, 8 logical and 4 physical cores .NET Core SDK=3.1.100 [Host] : .NET Core 3.1.0 (CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404), X64 RyuJIT Job-POXTAH : .NET Core 3.1.0 (CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404), X64 RyuJIT Runtime=.NET Core 3.1</code> </pre><br><div class="scrollable-table"><table><thead><tr><th>  La m√©thode </th><th>  N </th><th>  Moyenne </th><th>  Erreur </th><th>  Stddev </th><th>  Ratio </th><th>  RatioSD </th></tr></thead><tbody><tr><td>  <strong>Directsum</strong> </td><td>  <strong>1000</strong> </td><td>  <strong>2.128 nous</strong> </td><td>  <strong>0,0341 nous</strong> </td><td>  <strong>0,0303 nous</strong> </td><td>  <strong>1,00</strong> </td><td>  <strong>0,00</strong> </td></tr><tr><td>  Branchum </td><td>  1000 </td><td>  57.468 us </td><td>  0.4478 us </td><td>  0,3496 us </td><td>  26,97 </td><td>  0,46 </td></tr><tr><td>  UnsafeBranchSum </td><td>  1000 </td><td>  72.924 us </td><td>  0.4131 us </td><td>  0,3864 us </td><td>  34,28 </td><td>  0,50 </td></tr><tr><td>  ExpressionSum </td><td>  1000 </td><td>  144.555 us </td><td>  2.5182 us </td><td>  2.2323 us </td><td>  67,94 </td><td>  1,29 </td></tr><tr><td>  Unsafesum </td><td>  1000 </td><td>  5.054 us </td><td>  0,0324 us </td><td>  0,0303 nous </td><td>  2,37 </td><td>  0,03 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  <strong>Directsum</strong> </td><td>  <strong>10 000</strong> </td><td>  <strong>21.174 us</strong> </td><td>  <strong>0,3092 us</strong> </td><td>  <strong>0,2741 nous</strong> </td><td>  <strong>1,00</strong> </td><td>  <strong>0,00</strong> </td></tr><tr><td>  Branchum </td><td>  10 000 </td><td>  573.972 us </td><td>  2.9274 us </td><td>  2.5951 us </td><td>  27/11 </td><td>  0,40 </td></tr><tr><td>  UnsafeBranchSum </td><td>  10 000 </td><td>  735.031 us </td><td>  9.1016 us </td><td>  8.0683 us </td><td>  34,72 </td><td>  0,53 </td></tr><tr><td>  ExpressionSum </td><td>  10 000 </td><td>  1,462.593 us </td><td>  9.0932 us </td><td>  8.0609 us </td><td>  69,09 </td><td>  1.02 </td></tr><tr><td>  Unsafesum </td><td>  10 000 </td><td>  50,388 us </td><td>  0.3956 us </td><td>  0.3701 us </td><td>  2,38 </td><td>  0,03 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  <strong>Directsum</strong> </td><td>  <strong>100 000</strong> </td><td>  <strong>210.021 us</strong> </td><td>  <strong>1.9832 us</strong> </td><td>  <strong>1.7581 us</strong> </td><td>  <strong>1,00</strong> </td><td>  <strong>0,00</strong> </td></tr><tr><td>  Branchum </td><td>  100 000 </td><td>  6046340 us </td><td>  86,9740 us </td><td>  77.1002 us </td><td>  28,79 </td><td>  0,42 </td></tr><tr><td>  UnsafeBranchSum </td><td>  100 000 </td><td>  7,406.489 us </td><td>  65,7415 us </td><td>  58.2782 us </td><td>  35,27 </td><td>  0,27 </td></tr><tr><td>  ExpressionSum </td><td>  100 000 </td><td>  14021,642 us </td><td>  189.2625 us </td><td>  167.7763 us </td><td>  66,77 </td><td>  0,88 </td></tr><tr><td>  Unsafesum </td><td>  100 000 </td><td>  505.551 us </td><td>  2.3662 us </td><td>  2.2133 nous </td><td>  2,41 </td><td>  0,03 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  <strong>Directsum</strong> </td><td>  <strong>1 024 000</strong> </td><td>  <strong>2,306.751 us</strong> </td><td>  <strong>22.4173 us</strong> </td><td>  <strong>20.9692 us</strong> </td><td>  <strong>1,00</strong> </td><td>  <strong>0,00</strong> </td></tr><tr><td>  Branchum </td><td>  1 024 000 </td><td>  61,643.224 us </td><td>  610.3048 us </td><td>  570.8795 us </td><td>  26,72 </td><td>  0,28 </td></tr><tr><td>  UnsafeBranchSum </td><td>  1 024 000 </td><td>  75,644.639 us </td><td>  494.4096 us </td><td>  462.4711 us </td><td>  32,80 </td><td>  0,39 </td></tr><tr><td>  ExpressionSum </td><td>  1 024 000 </td><td>  154327,137 us </td><td>  1267.2469 us </td><td>  1185,3835 us </td><td>  66,91 </td><td>  0,55 </td></tr><tr><td>  Unsafesum </td><td>  1 024 000 </td><td>  5,295.990 us </td><td>  14.9537 us </td><td>  12.4871 us </td><td>  2.29 </td><td>  0,02 </td></tr></tbody></table></div></div></div><br><p>  Notre code dangereux est environ <code>2.5</code> fois plus lent (en termes d'une op√©ration).  Cela peut √™tre attribu√© au fait que dans le cas d'un calcul "frontal", le compilateur compile <code>a + b</code> dans le code d'op√©ration <code>add</code> , et dans le cas d'une m√©thode non s√ªre, une fonction statique est appel√©e, ce qui est naturellement plus lent. </p><br><h2 id="vmesto-zaklyucheniya-kogda-true--true">  Au lieu de conclure: quand <code>true != true</code> </h2><br><p>  Il y a quelques jours, j'ai rencontr√© un tel <a href="https://twitter.com/jaredpar/status/1205540750764625920" rel="nofollow">tweet de</a> Jared Parsons: </p><br><blockquote>  Il y a des cas o√π ce qui suit imprimera "faux" <br>  bool b = ... <br>  if (b) Console.WriteLine (b.IsTrue ()); </blockquote><p>  C'√©tait la r√©ponse √† <a href="https://twitter.com/vreshetnikov/status/1204929378368417792" rel="nofollow">cette entr√©e</a> , qui montre le code de v√©rification <code>bool</code> pour <code>true</code> , qui ressemble √† ceci: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsTrue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !<span class="hljs-literal"><span class="hljs-literal">true</span></span> &amp;&amp; !<span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><p>  Les ch√®ques semblent redondants, non?  Jared donne un contre-exemple qui montre <a href="https://gist.github.com/jaredpar/a0835afc71139284c09bfda203d8c011" rel="nofollow">certaines des caract√©ristiques</a> du comportement <code>bool</code> .  L'id√©e est que <code>bool</code> est <code>byte</code> ( <code>sizeof(bool) == 1</code> ), tandis que <code>false</code> correspond √† <code>0</code> et <code>true</code> <code>1</code> .  Tant que vous ne balancez pas les pointeurs, <code>bool</code> se comporte sans ambigu√Øt√© et de mani√®re pr√©visible.  Cependant, comme Jared l'a montr√©, vous pouvez cr√©er un <code>bool</code> utilisant <code>2</code> comme valeur initiale, et une partie des v√©rifications √©chouera correctement: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>* ptr = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*)&amp;b; *ptr = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><p>  Nous pouvons obtenir un effet similaire en utilisant nos op√©rations math√©matiques dangereuses (cela ne fonctionne pas avec les <code>Expressions</code> ): </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fakeTrue = Subtract&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> val = *(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*)&amp;fakeTrue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(fakeTrue) Assert.AreNotEqual(fakeTrue, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Assert.Fail(<span class="hljs-string"><span class="hljs-string">"Clause not entered."</span></span>);</code> </pre> <br><p>  Oui, oui, nous v√©rifions √† l'int√©rieur de la <code>true</code> branche si la condition est <code>true</code> , et nous nous attendons √† ce qu'elle <em>ne</em> soit <em>pas <code>true</code></em> .  Pourquoi en est-il ainsi?  Si vous soustrayez de <code>0</code> ( <code>=false</code> ) <code>1</code> ( <code>=true</code> ) sans v√©rifications, alors pour l' <code>byte</code> ce sera √©gal √† <code>255</code> .  Naturellement, <code>255</code> (notre <code>fakeTrue</code> ) n'est pas <code>1</code> (vrai <code>true</code> ), donc assert est ex√©cut√©.  La ramification fonctionne diff√©remment. </p><br><p>  <code>if</code> inversion se produit: une branche conditionnelle est ins√©r√©e;  si la condition est <em>fausse</em> , alors une transition vers le point se produit apr√®s la fin du bloc <code>if</code> .  La validation est effectu√©e par l' <code>brfalse</code> / <code>brfalse_S</code> .  Il compare la derni√®re valeur de la pile √† <em>z√©ro</em> .  Si la valeur est nulle, alors elle est <code>false</code> , nous enjambons le bloc <code>if</code> .  Dans notre cas, <code>fakeTrue</code> n'est tout simplement pas √©gal √† z√©ro, donc la v√©rification r√©ussit et l'ex√©cution se poursuit √† l'int√©rieur du bloc <code>if</code> , o√π nous comparons <code>fakeBool</code> avec la vraie valeur et obtenons un r√©sultat n√©gatif. </p><br><p>  UPD01: <br>  Apr√®s avoir discut√© dans les commentaires avec <a href="https://habr.com/en/users/shai_hulud/" class="user_link">shai_hulud</a> et <a href="https://habr.com/en/users/blowin/" class="user_link">blowin</a> , j'ai ajout√© une autre m√©thode aux benchmarks qui impl√©mente une branche comme <code>if(typeof(T) == typeof(int)) return (T)(object)((int)(object)left + (int)(object)right);</code>  .  Malgr√© le fait que <code>JIT</code> devrait optimiser les contr√¥les, au moins lorsque <code>T</code> est une <code>struct</code> , de telles m√©thodes fonctionnent toujours plus lentement.  Il n'est pas √©vident si les transformations <code>T</code> -&gt; <code>int</code> -&gt; <code>T</code> optimis√©es, ou si la boxe / unboxing est utilis√©e.  Les r√©sultats de l'indice de r√©f√©rence <code>MethodImpl</code> sont <code>MethodImpl</code> significativement affect√©s par les indicateurs <code>MethodImpl</code> . </p><br><p>  UPD02: <br>  <a href="https://habr.com/en/users/xxxvano/" class="user_link">xXxVano</a> dans les commentaires a montr√© un exemple d'utilisation de la ramification par type et transforme <code>T</code> &lt;--&gt; un type sp√©cifique en utilisant <code>Unsafe.As&lt;TFrom, TTo&gt;()</code> .  Par analogie avec la ramification habituelle et l' <code>object</code> personnalis√© √† travers, j'ai √©crit trois op√©rations (addition, multiplication et division) avec ramification pour tous les types arithm√©tiques, apr√®s quoi j'ai ajout√© une autre r√©f√©rence ( <code>UnsafeBranchSum</code> ).  Malgr√© le fait que toutes les m√©thodes (sauf les expressions) g√©n√®rent du code asm presque identique (pour autant que ma connaissance limit√©e de l'assembleur me permette de juger), pour une raison inconnue pour moi, les deux m√©thodes de branchement sont tr√®s lentes par rapport √† la sommation directe ( <code>DirectSum</code> ) et en utilisant des g√©n√©riques et du code <code>IL</code> .  Je n'ai aucune explication √† cet effet, le fait que le temps pass√© augmente proportionnellement √† <code>N</code> indique qu'il y a une sorte de surcharge constante pour <em>chaque</em> op√©ration, malgr√© toute la magie du <code>JIT</code> .  Cette surcharge est absente de la version <code>IL</code> des m√©thodes.   ,   <code>IL</code> -    ,    /    /  ,          100%  (  ,   ). <br>   ,      , -       . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr480416/">https://habr.com/ru/post/fr480416/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr480402/index.html">Comment pÃ∂–µÃ∂—Ä T–≤Ã∂—ãÃ∂–πÃ∂ le deuxi√®me mitap Android de Tinkoff</a></li>
<li><a href="../fr480404/index.html">Mikrotik et Linux. Routine et automatisation</a></li>
<li><a href="../fr480408/index.html">52 jeu de donn√©es pour les projets de formation</a></li>
<li><a href="../fr480412/index.html">Alexei Ragozin √† propos des nouvelles et anciennes fonctionnalit√©s de Java Flight Recorder dans OpenJDK 11 lors de la r√©union jug.msk.ru</a></li>
<li><a href="../fr480414/index.html">Le condens√© de mati√®res fra√Æches du monde du front-end de la derni√®re semaine n ¬∞ 393 (9-15 d√©cembre 2019)</a></li>
<li><a href="../fr480422/index.html">Google Style Guide en C ++. Partie 1</a></li>
<li><a href="../fr480424/index.html">Google Style Guide en C ++. Partie 9</a></li>
<li><a href="../fr480428/index.html">La m√©thode de raccourci le plus simple. Alphabet et police pour elle.</a></li>
<li><a href="../fr480430/index.html">Fonctionnement du codec vid√©o. Partie 2. Quoi, pourquoi, comment</a></li>
<li><a href="../fr480432/index.html">Le probl√®me du premier visualiseur ou la difficile conversion des flux vid√©o WebRTC en HLS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>