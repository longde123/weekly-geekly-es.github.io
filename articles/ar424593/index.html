<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏨 👉 🌘 C ++ 11 ومعالجة الأحداث 🦒 🥛 📱</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="أعتقد أن معالجة الحدث كطريقة للتفاعل بين الكائنات في OOP معروف للجميع تقريبًا ممن لمسوا OOP مرة واحدة على الأقل. على الأقل ، هذا النهج مريح للغاية في ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++ 11 ومعالجة الأحداث</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424593/" style=";text-align:right;direction:rtl">  أعتقد أن معالجة الحدث كطريقة للتفاعل بين الكائنات في OOP معروف للجميع تقريبًا ممن لمسوا OOP مرة واحدة على الأقل.  على الأقل ، هذا النهج مريح للغاية في مجموعة واسعة جدًا من المهام ، في رأيي.  في العديد من لغات البرمجة ، يتم تضمين محرك معالجة الحدث ؛  ومع ذلك ، في C ++ لا يوجد مثل هذه الآلية.  دعونا نرى ما يمكنك القيام به حيال ذلك. <br><a name="habracut"></a><br><a name="Intro"></a><h1 style=";text-align:right;direction:rtl">  مقدمة موجزة </h1><br>  <i>الحدث</i> هو شيء يمكن أن يحدث لشيء ما تحت ظروف معينة (على سبيل المثال ، مع زر عند النقر عليه بالماوس).  قد تحتاج الكيانات الأخرى إلى أن تدرك ذلك ؛  ثم <i>اشتركوا في الحدث</i> .  في هذه الحالة ، عند وقوع حدث ، يتم استدعاء <i>معالج</i> كائن تابع لجهة خارجية مشترك في الحدث ؛  وبالتالي ، لديه الفرصة لتنفيذ بعض التعليمات البرمجية ، أي  الرد على حدث.  وبالمثل ، يمكن للكائن <i>إلغاء الاشتراك من حدث</i> إذا لم يعد يريد الرد عليه.  نتيجة لذلك ، لدينا العديد من الأشياء التي يمكن ربطها ببعضها البعض من خلال أحداث أحدها ورد الفعل على أحداث الآخرين. <br><br>  شيء من هذا القبيل ، على الرغم من أن الجميع يعرفون ذلك. <br><br><a name="Trivial"></a><h1 style=";text-align:right;direction:rtl">  أبسط تنفيذ </h1><br>  قد يبدو من السهل تنفيذ مثل هذا السلوك.  وقد يبدو مثل هذا: <br><br><pre style=";text-align:right;direction:rtl"><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventHandler</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TParams... params )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: AbstractEventHandler() {} };</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEvent</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandler = AbstractEventHandler&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent() : m_handlers() { } ~TEvent() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( TEventHandler* oneHandler : m_handlers ) <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> oneHandler; m_handlers.clear(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TParams... params )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( TEventHandler* oneHandler : m_handlers ) oneHandler-&gt;call( params... ); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=( TEventHandler&amp; eventHandler ) { m_handlers.push_back( &amp;eventHandler ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;TEventHandler*&gt; m_handlers; };</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodEventHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventHandler&lt;TParams...&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TMethod = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>( TObject::* )( TParams... ); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MethodEventHandler( TObject&amp; object, TMethod method ) : AbstractEventHandler&lt;TParams...&gt;(), m_object( object ), m_method( method ) { assert( m_method != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TParams... params )</span></span></span><span class="hljs-function"> override final </span></span>{ ( m_object.*m_method )( params... ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: TObject&amp; m_object; TMethod m_method; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventHandler</span></span></span><span class="hljs-class">&lt;TParams...&gt;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">createMethodEventHandler</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">:</span></span>:*method )( TParams... ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MethodEventHandler&lt;TObject, TParams...&gt;( object, method ); } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> METHOD_HANDLER( Object, Method ) createMethodEventHandler( Object, &amp;Method ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MY_METHOD_HANDLER( Method ) METHOD_HANDLER( *this, Method )</span></span></code> </pre><br>  يجب أن يكون تطبيق هذه الحالة بالشكل: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestWindow</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; onButtonClick; . . . }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClickEventHandler</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testWindowButtonClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ ... } . . . }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[] )</span></span></span><span class="hljs-function"> </span></span>{ . . . TestWindow testWindow; ClickEventHandler clickEventHandler; testWindow.onButtonClick += METHOD_HANDLER( clickEventHandler, ClickEventHandler::testWindowButtonClick ); . . . }</code> </pre><br>  وبطبيعة الحال ، لن تكون طريقة المعالج (-الوظيفة-عضو في فئة) هي النوع الوحيد من المعالجات ، ولكن المزيد عن ذلك لاحقًا. <br><br>  يبدو أن كل شيء مريح وصغير ورائع.  ولكن في حين أن هناك عدد من أوجه القصور. <br><br><a name="HandlerCompare"></a><h1 style=";text-align:right;direction:rtl">  مقارنة معالج </h1><br>  لتنفيذ إلغاء الاشتراك من حدث ، من الضروري إضافة إمكانية المقارنة إلى المعالج (بواسطة <i>==</i> و <i>! ==</i> ).  تعتبر تلك المعالجات التي تستدعي نفس الأسلوب (وظيفة عضو لفئة) من نفس الكائن (أي نفس مثيل نفس الفئة) متساوية. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventHandler</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyType = AbstractEventHandler&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isEquals( other ); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == other ); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MyType&amp; other )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; . . . };</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TMethodHolder</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodEventHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventHandler&lt;TParams...&gt; { . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TMethod = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>( TObject::* )( TParams... ); <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AbstractEventHandler&lt;TParams...&gt;&amp; other )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType* _other = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType*&gt;( &amp;other ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( _other != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; &amp;m_object == &amp;_other.m_object &amp;&amp; m_method == _other.m_method ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: TObject&amp; m_object; TMethod m_method; . . . };</code> </pre><br>  ثم سنتمكن من إزالة المعالجات من اشتراك الحدث.  في هذه الحالة ، من الضروري حظر إضافة نفس المعالجات (المتساوية). <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEvent</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandler = AbstractEventHandler&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandlerIt = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;TEventHandler*&gt;::const_iterator; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=( TEventHandler&amp; eventHandler ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( findEventHandler( eventHandler ) == m_handlers.end() ) { m_handlers.push_back( &amp;eventHandler ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-=( TEventHandler&amp; eventHandler ) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = findEventHandler( eventHandler ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( it != m_handlers.end() ) { TEventHandler* removedEventHandler = *it; m_handlers.erase( it ); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> removedEventHandler; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> TEventHandlerIt </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findEventHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandler&amp; eventHandler )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::find_if( m_handlers.cbegin(), m_handlers.cend(), [ &amp;eventHandler ]( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TEventHandler* oneHandler ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( *oneHandler == eventHandler ); } ); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;TEventHandler*&gt; m_handlers; . . . };</code> </pre><br>  هنا ، تقوم وظائف الإضافة / الإزالة للمعالج بإرجاع <i>true في</i> حالة النجاح <i>والخطأ</i> إذا لم يتم تنفيذ الإجراء المقابل (إضافة أو إزالة). <br><br>  نعم ، تتضمن حالة الاستخدام مع المقارنة إنشاء معالجات مؤقتة مضافة في أي مكان ولا يتم حذفها في أي مكان.  لكن المزيد عن ذلك لاحقًا. <br><br>  هل يمكن استخدام هذا؟  لم يتم تنفيذه بالكامل بعد. <br><br><a name="HandlerRemoving"></a><h1 style=";text-align:right;direction:rtl">  إزالة معالج داخل معالج </h1><br>  لذلك ، نواجه على الفور عطلًا أثناء تنفيذ التعليمات البرمجية ، حيث يقوم المعالج بإلغاء اشتراك نفسه من الحدث (أعتقد أنه ليس من <i>حالات الاستخدام</i> النادرة عندما يتم قطع المعالج ذاتيًا تحت أي ظروف): <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestWindow</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; onButtonClick; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TestWindow&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">instance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; . . . }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClickEventHandler</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testWindowButtonClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ TestWindow::instance().onButtonClick -= MY_METHOD_HANDLER( ClickEventHandler::testWindowButtonClick ); } . . . }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[] )</span></span></span><span class="hljs-function"> </span></span>{ . . . ClickEventHandler clickEventHandler; TestWindow::instance().onButtonClick += METHOD_HANDLER( clickEventHandler, ClickEventHandler::testWindowButtonClick ); . . . }</code> </pre><br>  تنشأ المشكلة لسبب بسيط للغاية: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يتم تشغيل الحدث ويبدأ في تكرار معالجات (باستخدام عوامل التكرار) ، ويطلق عليها ؛ </li><li style=";text-align:right;direction:rtl">  المعالج التالي نفسه يؤدي إلى حذف نفسه ؛ </li><li style=";text-align:right;direction:rtl">  يقوم الحدث بحذف المعالج المحدد ، مما يجعل المكرر المناظر غير صالح ؛ </li><li style=";text-align:right;direction:rtl">  بعد الانتهاء من هذا المعالج ، يعود الحدث إلى تعداد الآخرين ، ومع ذلك ، فإن المكرر الحالي (المقابل للمعالج البعيد) غير صالح بالفعل ؛ </li><li style=";text-align:right;direction:rtl">  يحاول الحدث الوصول إلى المكرر غير الصالح ، مما يتسبب في السقوط. </li></ul><br>  لذلك ، من الضروري التحقق من الحالات التي يمكن فيها تغيير قائمة المعالجات ، مما يؤدي إلى إبطال التكرار ؛  ثم تنفيذ حماية القراءة لمثل هذه التكرارات. <br><br>  ميزة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">std :: list</a> 'في هذا التطبيق هي حقيقة أنه عند حذفه يجعل مكرر واحد فقط غير صالح - على العنصر المحذوف (يؤثر ، على سبيل المثال ، ما يلي) ؛  وإضافة عنصر لا يؤدي إلى إبطال أي تكرارات على الإطلاق.  وبالتالي ، نحتاج إلى التحكم في الحالة الوحيدة: حذف عنصر يكون مكرره الحالي في التعداد الحالي للعناصر.  في هذه الحالة ، يمكنك ، على سبيل المثال ، عدم حذف عنصر ، ولكن ببساطة وضع علامة على أن العنصر الحالي سيتم حذفه ، وتركه يتم داخل تعداد العناصر. <br><br>  سيكون من الممكن البدء في تنفيذ هذا على الفور ، لكني أقترح حل هذه المشكلة مع ما يلي. <br><br><a name="ThreadSafety"></a><h1 style=";text-align:right;direction:rtl">  سلامة الخيط </h1><br>  من المحتمل أن تكون الاستدعاءات لثلاث وظائف محتملة - إضافة معالجات وحذفها وفرزها (عند تشغيل حدث) - ممكنة من سلاسل المحادثات المختلفة في أوقات عشوائية.  وهذا يخلق مجالًا كاملاً من الاحتمالات لـ "التقاطع" في الوقت المناسب ، و "التداخل" في تنفيذها على بعضها البعض وسقوط البرنامج نتيجة لذلك.  دعونا نحاول تجنب هذا.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">كائنات المزامنة هي كل شيء لدينا</a> . <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEvent</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandler = AbstractEventHandler&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandlerIt = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;TEventHandler*&gt;::const_iterator; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent() : m_handlers(), m_currentIt(), m_isCurrentItRemoved( <span class="hljs-literal"><span class="hljs-literal">false</span></span> ), m_handlerListMutex() { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TParams... params )</span></span></span><span class="hljs-function"> </span></span>{ m_handlerListMutex.lock_shared(); m_isCurrentItRemoved = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; m_currentIt = m_handlers.begin(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( m_currentIt != m_handlers.end() ) { m_handlerListMutex.unlock_shared(); ( *m_currentIt )-&gt;call( params... ); m_handlerListMutex.lock_shared(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_isCurrentItRemoved ) { m_isCurrentItRemoved = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; TEventHandlerIt removedIt = m_currentIt; ++m_currentIt; deleteHandler( removedIt ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++m_currentIt; } } m_handlerListMutex.unlock_shared(); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=( TEventHandler&amp; eventHandler ) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique_lock&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::shared_mutex&gt; _handlerListMutexLock( m_handlerListMutex ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( findEventHandler( eventHandler ) == m_handlers.end() ) { m_handlers.push_back( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( eventHandler ) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-=( TEventHandler&amp; eventHandler ) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique_lock&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::shared_mutex&gt; _handlerListMutexLock( m_handlerListMutex ); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = findEventHandler( eventHandler ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( it != m_handlers.end() ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( it == m_currentIt ) m_isCurrentItRemoved = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> deleteHandler( it ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">//      'm_handlerListMutex' inline TEventHandlerIt findEventHandler( TEventHandler&amp; eventHandler ) const { return std::find_if( m_handlers.cbegin(), m_handlers.cend(), [ &amp;eventHandler ]( const TEventHandler* oneHandler ) { return ( *oneHandler == eventHandler ); } ); } //      'm_handlerListMutex' inline void deleteHandler( TEventHandlerIt it ) { TEventHandler* removedEventHandler = *it; m_handlers.erase( it ); delete removedEventHandler; } std::list&lt;TEventHandler*&gt; m_handlers; //    'm_handlerListMutex' mutable TEventHandlerIt m_currentIt; mutable bool m_isCurrentItRemoved; mutable std::shared_mutex m_handlerListMutex; };</span></span></code> </pre><br>  لا تنس ترك النافذة مفتوحة تقريبًا في كل مرة تتصل فيها بكل معالج.  يعد ذلك ضروريًا بحيث يمكن داخل المعالج الوصول إلى الحدث وتغييره (على سبيل المثال ، إضافة / إزالة معالجات) دون التسبب في حالة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">توقف تام</a> .  لا يمكنك أن تخاف من صحة البيانات ، لأنه ، كما اكتشفنا ، الشيء الوحيد الذي يؤدي إلى ذلك هو حذف العنصر الحالي ، وقد تمت معالجة هذا الموقف. <br>  <b>UPD1.</b>  شكرا <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" class="user_link">الغشاش</a> ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">اقترح</a> أن <i>std :: Shared_mutex</i> يظهر فقط في <i>C ++ 17</i> (و <i>std :: shared_lock</i> فقط في <i>C ++ 14</i> ).  أولئك الذين يعتبر هذا أمرًا بالغ الأهمية بالنسبة لهم ربما يجب عليهم أن يفعلوا مع <i>std :: mutex</i> . <br>  <b>UPD2.</b>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">علاوة على ذلك ، حول سلامة الخيط</a> (بدون الحفاظ على تسلسل السرد). <br><br><a name="EventVisibility"></a><h1 style=";text-align:right;direction:rtl">  مشكلة رؤية الحدث </h1><br>  عند استخدام حدث كعضو في فصل دراسي ، يبدو من المنطقي جعله <i>عامًا</i> ، بحيث يمكن لكائنات الجهات الخارجية إضافة / إزالة معالجاتها.  ومع ذلك ، سيؤدي هذا إلى <i>عامل التشغيل ()</i> ، أي  سيكون من الممكن أيضًا الوصول إلى مكالمة الحدث من الخارج ، والتي قد تكون في بعض الحالات غير مقبولة.  سنحل هذه المشكلة عن طريق عزل واجهة مجردة من فئة الحدث ( <i>TEvent &lt;...&gt;</i> ) مخصصة فقط للتعامل مع المعالجات. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IEvent</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandler = AbstractEventHandler&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=( TEventHandler&amp; eventHandler ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> addHandler( eventHandler ); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-=( TEventHandler&amp; eventHandler ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> removeHandler( eventHandler ); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: IEvent() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandler&amp; eventHandler )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandler&amp; eventHandler )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEvent</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IEvent&lt;TParams...&gt; { . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent() : IEvent&lt;TParams...&gt;() . . . { } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandler&amp; eventHandler )</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ,     'TEvent::operator+=' } virtual bool removeHandler( TEventHandler&amp; eventHandler ) override { // ,     'TEvent::operator-=' } . . . };</span></span></code> </pre><br>  الآن يمكننا تقسيم إلى نطاقات مختلفة جزء الحدث المسؤول عن العمل مع معالجات ، والجزء المسؤول عن استدعاء ذلك. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestWindow</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TestWindow() : onButtonClick( m_onButtonClick ), m_onButtonClick() { } IEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&amp; onButtonClick; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; m_onButtonClick; . . . };</code> </pre><br>  وبالتالي ، يمكن الآن لكائنات / جهات خارجية إضافة / إزالة معالجاتها عبر <i>TestWindow :: onButtonClick</i> ، ومع ذلك لن تتمكن من تشغيل هذا الحدث بنفسها.  يمكن إجراء مكالمة الآن فقط داخل فئة <i>TestWindow</i> (ونسلها ، إذا كان نطاق الحدث ، كمثال ، <i>محميًا</i> ). <br><br>  بدأ الكود التافه يتحول ببطء إلى شيء بشع ، لكن هذه ليست النهاية. <br><br><a name="EventHandlerParams"></a><h1 style=";text-align:right;direction:rtl">  تطابق معلمات الأحداث ومعالجاتها </h1><br>  في التطبيق الحالي ، يجب أن يكون للحدث وأي من معالجاته قائمة معلمات مطابقة تمامًا.  هذا يؤدي إلى عدد من العيوب. <br><br>  <b>الأول.</b>  افترض أن لدينا قالب فئة يوجد فيه حدث بمعلمة قالب. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSource</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TSource&amp;&gt; onValueChanged; . . . };</code> </pre><br>  نظرًا لأن النوع الذي سيتم استخدامه هنا غير معروف مسبقًا ، فمن المنطقي أن يتم تمريره عن طريق رابط ثابت ، وليس حسب القيمة.  ومع ذلك ، الآن بالنسبة لأي تنفيذ ، حتى مع الأنواع الأساسية ، يجب أن تكون المعالجات المقابلة موجودة. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">MyClass&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; myBoolClass; . . . <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSource</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyHandlerClass</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleValueChanged1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; newValue )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleValueChanged2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newValue )</span></span></span></span>; . . . }; . . . MyHandlerClass myHandlerClass; myBoolClass.onValueChanged += METHOD_HANDLER( myHandlerClass, MyHandlerClass::handleValueChanged1 ); <span class="hljs-comment"><span class="hljs-comment">// OK myBoolClass.onValueChanged += METHOD_HANDLER( myHandlerClass, MyHandlerClass::handleValueChanged2 ); // compile error</span></span></code> </pre><br>  أود أن أكون قادرًا على توصيل معالجات النموذج <i>MyHandlerClass :: handleValueChanged2</i> بحدث مشابه ، ولكن حتى الآن لا يوجد مثل هذا الاحتمال. <br><br>  <b>الثاني.</b>  دعنا نحاول تنفيذ معالج مرح مشابه لطريقة معالج موجودة (-وظيفة-عضو في فئة). <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorEventHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventHandler&lt;TParams...&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: FunctorEventHandler( TFunctor&amp; functor ) : AbstractEventHandler&lt;TParams...&gt;(), m_functor( functor ) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TParams... params )</span></span></span><span class="hljs-function"> override final </span></span>{ m_functor( params... ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: TFunctor&amp; m_functor; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventHandler</span></span></span><span class="hljs-class">&lt;TParams...&gt;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">createFunctorEventHandler</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">functor</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FunctorEventHandler&lt;TFunctor, TParams...&gt;( functor ); } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FUNCTOR_HANDLER( Functor ) createFunctorEventHandler( Functor )</span></span></code> </pre><br>  حاول الآن أن تفسد الأمر على حدث ما. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestWindow</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; onButtonClick; . . . }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClickEventHandler</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ . . . } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[] )</span></span></span><span class="hljs-function"> </span></span>{ . . . TestWindow testWindow; ClickEventHandler clickEventHandler; testWindow.onButtonClick += FUNCTOR_HANDLER( clickEventHandler ); . . . }</code> </pre><br>  ستكون النتيجة خطأ في الترجمة.  بالنسبة للدالة <i>createFunctorEventHandler ،</i> لا يستطيع المحول البرمجي استنتاج أنواع <i>TParams ...</i> من الوسيطة الوحيدة لهذه الوظيفة - الممول نفسه.  لا يحتوي الممر على أي معلومات حول نوع المعالج الذي سيتم إنشاؤه بناءً عليه.  الشيء الوحيد الذي يمكن القيام به في هذه الحالة هو كتابة شيء مثل: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">testWindow.onButtonClick += createFunctorEventHandler&lt;ClickEventHandler, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;( clickEventHandler );</code> </pre><br>  لكنك لا تريد القيام بذلك على الإطلاق. <br><br><a name="HandlerHolder"></a><h1 style=";text-align:right;direction:rtl">  ربط حدث بأنواع مختلفة من المعالجات </h1><br>  لذا ، هناك قائمة الرغبات ، والأمر متروك للتنفيذ.  سننظر في الموقف باستخدام مثال معالج الممر ؛ سيتم الحصول على طريقة معالج (-الوظيفة-عضو في فئة) بطريقة مماثلة. <br><br>  نظرًا لأنه على أساس المعلق فقط ، من المستحيل تحديد قائمة معلمات المعالج المقابل ، فلن نقوم بذلك.  يصبح هذا السؤال ذا صلة ليس في وقت إنشاء المعالج ، ولكن في وقت محاولة إرفاقه بحدث معين.  ونعم ، هاتان نقطتان مختلفتان.  يمكن تنفيذ هذه الفكرة على النحو التالي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorHolder</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorEventHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventHandler&lt;TParams...&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: FunctorEventHandler( FunctorHolder&lt;TFunctor&gt;&amp; functorHolder ) : AbstractEventHandler&lt;TParams...&gt;(), m_functorHolder( functorHolder ) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TParams... params )</span></span></span><span class="hljs-function"> override </span></span>{ m_functorHolder.m_functor( params... ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: FunctorHolder&lt;TFunctor&gt;&amp; m_functorHolder; . . . };</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorHolder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: FunctorHolder( TFunctor&amp; functor ) : m_functor( functor ) { } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCallParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventHandler</span></span></span><span class="hljs-class">&lt;TCallParams...&gt;&amp;() {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FunctorEventHandler&lt;TFunctor, TCallParams...&gt;( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: TFunctor&amp; m_functor; . . . <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">friend</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorEventHandler</span></span></span><span class="hljs-class">;</span></span> };</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorHolder</span></span></span><span class="hljs-class">&lt;TFunctor&gt;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">createFunctorEventHandler</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">functor</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FunctorHolder&lt;TFunctor&gt;( functor ); } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FUNCTOR_HANDLER( Functor ) createFunctorEventHandler( Functor ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LAMBDA_HANDLER( Lambda ) FUNCTOR_HANDLER( Lambda ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STD_FUNCTION_HANDLER( StdFunction ) FUNCTOR_HANDLER( StdFunction ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FUNCTION_HANDLER( Function ) FUNCTOR_HANDLER( &amp;Function )</span></span></code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IEvent</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandler = AbstractEventHandler&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">+=( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> addHandler( <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;TEventHandler&amp;&gt;( some ) ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">-=( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> removeHandler( <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;TEventHandler&amp;&gt;( some ) ); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: IEvent() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandler&amp; eventHandler )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandler&amp; eventHandler )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br>  باختصار ، يكون فصل لحظات إنشاء المعالج وملاحقته بالحدث هنا أكثر وضوحًا من ذي قبل.  هذا يتحايل على المشاكل الموصوفة في الفقرة السابقة.  سيحدث اختبار توافق النوع عند محاولة إرفاق <i>FunctorHolder</i> معينة إلى <i>FunctorEventHandler</i> ، أو بالأحرى ، إنشاء مثيل <i>لفئة FunctorEventHandler &lt;...&gt; بنوع موصِّل</i> محدد للغاية ؛  وفي هذا الفصل سيكون هناك سطر من الكود <i>m_functorHolder.m_functor (المعلمات ...) ؛</i>  ، والتي لا يمكن تجميعها ببساطة لمجموعة من الأنواع غير المتوافقة مع المعلق (أو إذا لم يكن ممرًا على الإطلاق ، أي كائن لا يحتوي على <i>عامل تشغيل ()</i> ). <br><br>  أكرر أن مشكلة حذف الأشياء المؤقتة سيتم مناقشتها أدناه.  بالإضافة إلى ذلك ، تجدر الإشارة إلى أنه تم إنشاء مجموعة من وحدات الماكرو لكل حالة ، أولاً ، من أجل توضيح إمكانات هذا النوع من المعالجات ، وثانيًا ، في حالة تعديل محتمل لأي منها مع ملف. <br><br>  تحقق من النتيجة. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestWindow</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; onButtonClick; . . . }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor3</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor4</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor5</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor6</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor7</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[] )</span></span></span><span class="hljs-function"> </span></span>{ . . . TestWindow testWindow; Functor functor; Functor2 functor2; Functor3 functor3; Functor4 functor4; Functor5 functor5; Functor6 functor6; Functor7 functor7; testWindow.onButtonClick += FUNCTOR_HANDLER( functor ); <span class="hljs-comment"><span class="hljs-comment">// ok testWindow.onButtonClick += FUNCTOR_HANDLER( functor2 ); // ok testWindow.onButtonClick += FUNCTOR_HANDLER( functor3 ); // ok testWindow.onButtonClick += FUNCTOR_HANDLER( functor4 ); // ok testWindow.onButtonClick += FUNCTOR_HANDLER( functor5 ); // compile error testWindow.onButtonClick += FUNCTOR_HANDLER( functor6 ); // ok testWindow.onButtonClick += FUNCTOR_HANDLER( functor7 ); // compile error . . . }</span></span></code> </pre><br>  يحدث خطأ في الترجمة عند محاولة تحويل إحدى المعلمات من <i>const lvalue</i> إلى <i>lvalue</i> .  لا يؤدي التحويل من <i>rvalue</i> إلى <i>lvalue</i> غير <i>المألوف</i> إلى حدوث خطأ ، على الرغم من أنه تجدر الإشارة إلى أنه يخلق تهديدًا محتملاً <i>للتصوير</i> الذاتي في الساق: سيكون المعالج قادرًا على تغيير المتغير المنسوخ إلى المكدس ، والذي سيتم حذفه بفرح عند خروج هذا المعالج. <br><br>  بشكل عام ، يجب أن تظهر رسالة الخطأ على النحو التالي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs vhdl"><span class="hljs-literal"><span class="hljs-literal">Error</span></span> C2664 <span class="hljs-symbol"><span class="hljs-symbol">'void</span></span> Functor5::operator ()(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;,<span class="hljs-built_in"><span class="hljs-built_in">unsigned</span></span> int &amp;)': cannot convert argument <span class="hljs-number"><span class="hljs-number">1</span></span> from <span class="hljs-symbol"><span class="hljs-symbol">'const</span></span> std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>' <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;'</code> </pre><br>  لمزيد من الوضوح ، عند استخدام الأحداث والمعالجات في رمز جهة خارجية ، يمكنك إضافة رسالة الخطأ الخاصة بك.  سيتطلب ذلك كتابة هيكل داعم صغير (أعترف ، لقد تجسست على نهج مماثل في مكان ما): <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IsFunctorParamsCompatible</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCheckedFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCheckedParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-function"><span class="hljs-function">true_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">decltype</span></span></span></span><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;TCheckedFunctor&gt;()( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;TCheckedParams&gt;()... ) )* = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nullptr</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCheckedFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCheckedParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-function"><span class="hljs-function">false_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ... )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>( exists&lt;TFunctor, TParams...&gt;( <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) )::value; }; } <span class="hljs-comment"><span class="hljs-comment">//</span></span></code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorEventHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventHandler&lt;TParams...&gt; { . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TParams... params )</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( IsFunctorParamsCompatible&lt;TFunctor, TParams...&gt;::value, <span class="hljs-string"><span class="hljs-string">"Event and functor arguments are not compatible"</span></span> ); m_functorHolder-&gt;m_functor( params... ); } . . . };</code> </pre><br><a name="AboutSfinae"></a>  يعتمد هذا العمل على آلية <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">SFINAE</a> .  باختصار ، هناك محاولة لتجميع الوظيفة الأولى <i>موجودة</i> ، ومع ذلك ، إذا لم يفلح ذلك بسبب عدم توافق الحجج (أو غياب <i>العامل ()</i> من ما تم تمريره كممرح) ، فإن المترجم لا يلقي خطأ ، ولكنه يحاول ببساطة تجميع الوظيفة الثانية ؛  نحن نفعل كل شيء حتى ينجح تجميعه دائمًا ، وبعد ذلك ، بناءً على حقيقة الوظيفة التي تم تجميعها ، نستنتج (بكتابة النتيجة إلى <i>القيمة</i> ) حول توافق الحجج لأنواع معينة. <br><br>  الآن ستظهر رسالة الخطأ على النحو التالي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">Error C2338 Event <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> functor arguments are <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> compatible Error C2664 <span class="hljs-string"><span class="hljs-string">'void Functor5::operator ()(std::string &amp;,unsigned int &amp;)'</span></span>: cannot convert argument <span class="hljs-number"><span class="hljs-number">1</span></span> from <span class="hljs-string"><span class="hljs-string">'const std::string'</span></span> to <span class="hljs-string"><span class="hljs-string">'std::string &amp;'</span></span></code> </pre><br>  بالإضافة إلى رسالة خطأ إضافية أكثر <i>إفادة</i> ، يحل هذا النهج مشكلة تحويل الوسيطة (s) من <i>rvalue</i> إلى <i>unvst lvalue</i> : الآن يتسبب في خطأ عدم توافق الوسيطة ، أي  <i>تؤدي محاولة</i> إضافة معالج <i>functor6</i> من المثال أعلاه إلى حدوث خطأ في وقت الترجمة. <br>  <b>UPD</b>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">صقل</a> (بدون الحفاظ على تسلسل السرد). <br><br><a name="FunctorCompare"></a><h1 style=";text-align:right;direction:rtl">  مقارنة Functor </h1><br>  نظرًا للتغييرات في فئة المعالج ، سيتغير تطبيق مقارنة حالات هذا الفصل قليلاً.  مرة أخرى ، سأقدم تطبيقًا فقط على معالج المواهب ، لأن طريقة المعالج (-الوظيفة-عضو في الفصل) ستبدو متشابهة. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventHandler</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyType = AbstractEventHandler&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isEquals( other ); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == other ); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MyType&amp; other )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; . . . };</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorEventHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventHandler&lt;TParams...&gt; { . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyType = FunctorEventHandler&lt;TFunctor, TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AbstractEventHandler&lt;TParams...&gt;&amp; other )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType* _other = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType*&gt;( &amp;other ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( _other != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; *m_functorHolder == *_other-&gt;m_functorHolder ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: FunctorHolder&lt;TFunctor&gt;&amp; m_functorHolder; . . . };</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorHolder</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyType = FunctorHolder&lt;TFunctor&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( m_functor == other.m_functor ); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == other ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: TFunctor&amp; m_functor; . . . };</code> </pre><br>  على هذا ، فإن أوجه التشابه في تنفيذ نهاية المقارنة والجزء يبدأ فقط لمعالجات المعلق. <br><br>  كما هو مذكور أعلاه ، حصلنا على عدة أنواع من معالجات المعلق: كائنات المعلق مباشرة ، وتعبيرات لامدا ، وحالات فئة <i>std :: function</i> ، والوظائف الفردية.  من بين هذه الأشياء ، لا يمكن مقارنة كائنات الدوافع ، وتعبيرات لامدا ، وحالات فئة <i>std :: function</i> باستخدام <i>عامل التشغيل ==</i> (يجب أن تتم مقارنتها في العنوان) ، ولكن يمكن للوظائف الفردية ، لأن  مخزنة بالفعل في.  من أجل عدم إعادة كتابة وظيفة المقارنة بشكل منفصل لكل حالة ، نكتبها في شكل عام: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEqu</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEnabled</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EqualityChecker</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEquatable</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EqualityChecker</span></span></span><span class="hljs-class">&lt;TEquatable, typename std::enable_if&lt;is_equatable&lt;TEquatable&gt;::value&gt;::type&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TEquatable&amp; operand1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TEquatable&amp; operand2 )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( operand1 == operand2 ); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TNonEquatable</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EqualityChecker</span></span></span><span class="hljs-class">&lt;TNonEquatable, typename std::enable_if&lt;!is_equatable&lt;TNonEquatable&gt;::value&gt;::type&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TNonEquatable&amp; operand1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TNonEquatable&amp; operand2 )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &amp;operand1 == &amp;operand2 ); } }; } <span class="hljs-comment"><span class="hljs-comment">// template&lt;class TFunctor&gt; class FunctorHolder { . . . using MyType = FunctorHolder&lt;TFunctor&gt;; public: bool operator==( const MyType&amp; other ) const { return EqualityChecker&lt;TFunctor&gt;::isEquals( m_functor, other.m_functor ); } private: TFunctor&amp; m_functor; . . . };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">من المفهوم أن </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is_equatable</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> هو قالب مساعد يحدد ما إذا كان يمكن التحقق من حالتين من نوع معين من أجل المساواة. </font><font style="vertical-align: inherit;">بمساعدتها ، باستخدام </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: enable_if</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، نختار أحد بنيتي </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EqualityChecker</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> المتخصصة جزئيًا </font><font style="vertical-align: inherit;">، والتي ستجري مقارنة: حسب القيمة أو حسب العنوان. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يتم</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> تنفيذ </font><i><font style="vertical-align: inherit;">Is_equatable ،</font></i><font style="vertical-align: inherit;"> ويمكن أن يكون على النحو التالي:</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_equatable</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-function"><span class="hljs-function">true_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">decltype</span></span></span></span><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;U&gt;() == </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;U&gt;() )* = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nullptr</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-function"><span class="hljs-function">false_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ... )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>( exists&lt;T&gt;( <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) )::value; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يعتمد هذا التنفيذ على آلية </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SFINAE</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، التي تم استخدامها بالفعل من </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">قبل</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">هنا فقط نتحقق من وجود </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">عامل ==</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> لحالات فئة معينة. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">وبهذه الطريقة البسيطة ، يكون تنفيذ مقارنة المعالجين - المربين جاهزين.</font></font><br><br><a name="GarbageCollection"></a><h1 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> جمع القمامة </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">كن متساهلاً ، أردت أيضًا إدراج عنوان مرتفع. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نحن نقترب من النهاية ، وحان الوقت للتخلص من العدد الهائل من الأشياء التي تم إنشاؤها والتي لا يتحكم بها أحد. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ينشئ كل إجراء حدث باستخدام معالج كائنين: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الحامل</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، الذي يخزن الجزء القابل للتنفيذ من المعالج ، و </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ربطه بالحدث. لن ننسى أنه في حالة محاولة إعادة إضافة المعالج ، لن تحدث أي إضافة - يتم تعليق شيئين في الهواء (ما لم يتم ، بالطبع ، فحص هذه الحالة بشكل منفصل في كل مرة). حالة أخرى: إزالة المعالج ؛ يتم إنشاء كائنين جديدين أيضًا للبحث عن نفس (متساوٍ) في قائمة معالجات الأحداث ؛ بالطبع ، تم حذف المعالج الموجود من القائمة (إن وجد) ، وهذا المعالج المؤقت الذي تم إنشاؤه للبحث ويتكون من شيئين ، هو مرة أخرى "في الهواء". بشكل عام ، ليس باردا. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أنتقل إلى </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">المؤشرات الذكية</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . نحتاج إلى تحديد دلالات ملكية كل من </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">كائني</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> المعالج: الملكية الوحيدة ( </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;">std :: unique_ptr</font></a><font style="vertical-align: inherit;"> ) أو المشتركة ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">حامل</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، إلى جانب استخدام الحدث نفسه عند تخزينه أو إزالته ، يجب تخزينه في </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، لذلك نستخدمه للملكية المشتركة ، وبالنسبة لـ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EventHandler فهو</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> وحيد ، لأنه بعد الإنشاء ، سيتم تخزينه فقط في قائمة معالجات الأحداث. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نحن ندرك هذه الفكرة:</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventHandler</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~AbstractEventHandler() {} . . . }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Types</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THandlerPtr</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;AbstractEventHandler&lt;Types...&gt;&gt;;</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerCast</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Types</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THandlerPtr</span></span></span><span class="hljs-class">&lt;Types...&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cast</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;THandlerPtr&lt;Types...&gt;&gt;( some ); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TPtr</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerCast</span></span></span><span class="hljs-class">&lt;std::shared_ptr&lt;TPtr&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Types</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THandlerPtr</span></span></span><span class="hljs-class">&lt;Types...&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cast</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;TPtr&gt; some ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HandlerCast&lt;TPtr&gt;::cast&lt;Types...&gt;( *some ); } }; } <span class="hljs-comment"><span class="hljs-comment">// template&lt;class ...TParams&gt; class IEvent { public: template&lt;class TSome&gt; bool operator+=( TSome&amp;&amp; some ) { return addHandler( HandlerCast&lt;TSome&gt;::cast&lt;TParams...&gt;( some ) ); } template&lt;class TSome&gt; bool operator-=( TSome&amp;&amp; some ) { return removeHandler( HandlerCast&lt;TSome&gt;::cast&lt;TParams...&gt;( some ) ); } protected: using TEventHandlerPtr = THandlerPtr&lt;TParams...&gt;; IEvent() {} virtual bool addHandler( TEventHandlerPtr eventHandler ) = 0; virtual bool removeHandler( TEventHandlerPtr eventHandler ) = 0; }; template&lt;class ...TParams&gt; class TEvent : public IEvent&lt;TParams...&gt; { using TEventHandlerIt = typename std::list&lt;TEventHandlerPtr&gt;::const_iterator; public: TEvent() { . . . } ~TEvent() { // empty } protected: virtual bool addHandler( TEventHandlerPtr eventHandler ) override { std::unique_lock&lt;std::shared_mutex&gt; _handlerListMutexLock( m_handlerListMutex ); if( findEventHandler( eventHandler ) == m_handlers.end() ) { m_handlers.push_back( std::move( eventHandler ) ); return true; } return false; } virtual bool removeHandler( TEventHandlerPtr eventHandler ) override { . . . } private: //      'm_handlerListMutex' inline TEventHandlerIt findEventHandler( const TEventHandlerPtr&amp; eventHandler ) const { return std::find_if( m_handlers.cbegin(), m_handlers.cend(), [ &amp;eventHandler ]( const TEventHandlerPtr&amp; oneHandler ) { return ( *oneHandler == *eventHandler ); } ); } //      'm_handlerListMutex' inline void deleteHandler( TEventHandlerIt it ) { m_handlers.erase( it ); } std::list&lt;TEventHandlerPtr&gt; m_handlers; . . . };</span></span></code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TMethodHolder</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodEventHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventHandler&lt;TParams...&gt; { . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TMethodHolderPtr = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;TMethodHolder&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MethodEventHandler( TMethodHolderPtr methodHolder ) : AbstractEventHandler&lt;TParams...&gt;(), m_methodHolder( methodHolder ) { assert( m_methodHolder != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: TMethodHolderPtr m_methodHolder; . . . }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodHolder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyType = MethodHolder&lt;TObject, TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TMethod = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>( TObject::* )( TParams... ); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MethodHolder( TObject&amp; object, TMethod method ) { . . . } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCallParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THandlerPtr</span></span></span><span class="hljs-class">&lt;TCallParams...&gt;() {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> THandlerPtr&lt;TCallParams...&gt;( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MethodEventHandler&lt;MyType, TCallParams...&gt;( <span class="hljs-comment"><span class="hljs-comment">/*   ? */</span></span> ) ); } . . . }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MethodHolder&lt;TObject, TParams...&gt;&gt; createMethodEventHandler( TObject&amp; object, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>( TObject::*method )( TParams... ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MethodHolder&lt;TObject, TParams...&gt;&gt;( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MethodHolder&lt;TObject, TParams...&gt;( object, method ) ); } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> METHOD_HANDLER( Object, Method ) createMethodEventHandler( Object, &amp;Method ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MY_METHOD_HANDLER( Method ) METHOD_HANDLER( *this, Method )</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الأشياء الأولى أولاً. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">للبدء ، الحدث وواجهة العمل مع المعالجات. في الأخير ، </font><font style="vertical-align: inherit;">لم يعد بإمكانك </font><font style="vertical-align: inherit;">تحويل الأنواع مباشرة باستخدام </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static_cast</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، لأن النوع الذي يتم تحويله يكمن "في الداخل" </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: Shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . الآن ، لمثل هذا التحول ، </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">سنستخدم</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> بنية </font><i><font style="vertical-align: inherit;">HandlerCast</font></i><font style="vertical-align: inherit;"> الإضافية </font><font style="vertical-align: inherit;">، والتي ، من خلال تخصصها الخاص ، ستوفر الوصول إلى الكائن داخل </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: Shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، وتعمل بالفعل معه (في تنفيذه غير المتخصص) ، ستطبق </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">البث</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> القديم الجيد </font><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الحدث نفسه ؛ هناك العديد من التغييرات المهمة هنا أيضًا. أولاً ، سنتوقف يدويًا عن حذف مثيلات المعالج في المدمر وعند الحذف ؛ يكفي الآن إزالة المؤشر الذكي باستخدام هذا المعالج من القائمة. بالإضافة إلى ذلك ، عند إضافة معالج ، من المهم ألا ننسى </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: move</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، لأن </font><font style="vertical-align: inherit;">لا يدعم </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: unique_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> النسخ (وهو أمر منطقي تمامًا لمثل هذه الدلالات). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">دعنا ننتقل إلى معالجات. وفقا للتقاليد القديمة ، يتم إعطاء واحد منهم فقط ، والثاني مشابه. وهنا ، للوهلة الأولى ، يتعلق الأمر كله بتغيير أنواع الكائنات المخزنة / التي تم إنشاؤها من الروابط / المؤشرات إلى المؤشرات الذكية. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ولكن هناك نقطة خفية واحدة. وظيفة </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">createMethodEventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> عودة </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">STD :: shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إلى مثيل</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodHolder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . بعد ذلك بقليل ، ستتم محاولة تحويله إلى نوع معالج ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodEventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) ، حيث سيتعين عليه إنشاء مثيل جديد لـ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodEventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، ثم تمريره إلى مُنشئ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: Shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> على نفسه. هذا هو بالضبط ما كان مخصصًا </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لحذف</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> مثيل </font><i><font style="vertical-align: inherit;">MethodHolder</font></i><font style="vertical-align: inherit;"> لاحقًا عند </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">حذف</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> مثيل </font><i><font style="vertical-align: inherit;">MethodEventHandler</font></i><font style="vertical-align: inherit;"> . ولكن المشكلة هي أن </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodHolder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ليس </font><i><font style="vertical-align: inherit;">لديه</font></i><font style="vertical-align: inherit;"> حق الوصول إلى </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: </font></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">Shared_ptr</font></i><font style="vertical-align: inherit;"> الذي تم إنشاؤه بالفعل </font><font style="vertical-align: inherit;">والذي يقوم بتخزينه بنفسه. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لحل المشكلة ، عليك تخزين </font><font style="vertical-align: inherit;">مؤشر ذكي لنفسك </font><font style="vertical-align: inherit;">في </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodHolder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . ومع ذلك ، حتى لا يؤثر على إزالته ، نستخدمه</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الأمراض المنقولة جنسيا ::: الضعيفة</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodHolder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyType = MethodHolder&lt;TObject, TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TMethod = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>( TObject::* )( TParams... ); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCallParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THandlerPtr</span></span></span><span class="hljs-class">&lt;TCallParams...&gt;() {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> THandlerPtr&lt;TCallParams...&gt;( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MethodEventHandler&lt;MyType, TCallParams...&gt;( m_me.lock() ) ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MyType&gt; create( TObject&amp; object, TMethod method ) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MyType&gt; result( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyType( object, method ) ); result-&gt;m_me = result; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: MethodHolder( TObject&amp; object, TMethod method ) : m_object( object ), m_method( method ) { assert( m_method != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ); } TObject&amp; m_object; TMethod m_method; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::weak_ptr&lt;MyType&gt; m_me; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MethodHolder&lt;TObject, TParams...&gt;&gt; createMethodEventHandler( TObject&amp; object, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>( TObject::*method )( TParams... ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MethodHolder&lt;TObject, TParams...&gt;::create( object, method ); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> للتوضيح ، سأعطي ترتيبًا تقريبيًا للأحداث عند إزالة معالج من حدث (أعتذر عن تورية عشوائية): </font></font><br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يزيل الحدث العنصر من القائمة ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m_handlers.erase (it)؛</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) ، مما يؤدي إلى استدعاء المدمر الخاص به ؛</font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يسمى</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> المدمر </font><i><font style="vertical-align: inherit;">std :: unique_ptr</font></i><font style="vertical-align: inherit;"> ، مما يؤدي إلى استدعاء المدمر للكائن المُدار ؛</font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ويسمى المدمر </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodEventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، الذي يزيل كافة الحقول كائن، بما في ذلك حقل </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m_methodHolder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، وهو </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">من الأمراض المنقولة جنسيا :: shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li style=";text-align:right;direction:rtl">   <i>std::shared_ptr</i> ;  ,      (..         )      ( <i>MethodHolder</i> );      ,     <i>std::weak_ptr</i>    ; </li><li style=";text-align:right;direction:rtl">   <i>MethodHolder</i> ,      ,   ,  <i>m_me</i> ,  <i>std::weak_ptr</i> ; </li><li style=";text-align:right;direction:rtl">   <i>std::weak_ptr</i> ;     ; ..   <i>std::weak_ptr</i>   ,    ; </li><li style=";text-align:right;direction:rtl"> . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">من المهم أن نتذكر أن المدمر لفئة </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AbstractEventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> يجب أن يكون ظاهريًا ؛ </font><font style="vertical-align: inherit;">خلاف ذلك ، بعد البند </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> في البند </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، سيتم استدعاء المدمر </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AbstractEventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ولن يتم تنفيذ </font><font style="vertical-align: inherit;">إجراءات أخرى.</font></font><br><br><a name="Joins"></a><h1 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> اتصال الحدث والمعالج </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في بعض الحالات ، عند إضافة / إزالة معالج واحد من حدث ما في كثير من الأحيان (وفقًا لبعض المنطق) ، لا ترغب في الإزعاج ، والحصول على نسخة من الحدث ومثيل المعالج في كل مرة ، لتنفيذ اشتراك / إلغاء اشتراك مرة أخرى من هذا الحدث. </font><font style="vertical-align: inherit;">ولكن أريد توصيلها مرة واحدة ، ثم ، عند الضرورة ، العمل مع هذا الاتصال ، بإضافة / إزالة معه معالج محدد مسبقًا من حدث محدد مسبقًا. </font><font style="vertical-align: inherit;">يمكنك تنفيذ ذلك على النحو التالي:</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Types</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THandlerPtr</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;AbstractEventHandler&lt;Types...&gt;&gt;;</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IEvent</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandlerPtr = THandlerPtr&lt;TParams...&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isHandlerAdded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TEventHandlerPtr&amp; eventHandler )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandlerPtr eventHandler )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandlerPtr eventHandler )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerEventJoin</span></span></span><span class="hljs-class">&lt;TParams...&gt;;</span></span> . . . }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEvent</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IEvent&lt;TParams...&gt; { . . . <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isHandlerAdded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TEventHandlerPtr&amp; eventHandler )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::shared_lock&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::shared_mutex&gt; _handlerListMutexLock( m_handlerListMutex ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( findEventHandler( eventHandler ) != m_handlers.end() ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandlerPtr eventHandler )</span></span></span><span class="hljs-function"> override </span></span>{ . . . } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandlerPtr eventHandler )</span></span></span><span class="hljs-function"> override </span></span>{ . . . } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">//      'm_handlerListMutex' inline TEventHandlerIt findEventHandler( const TEventHandlerPtr&amp; eventHandler ) const { . . . } std::list&lt;TEventHandlerPtr&gt; m_handlers; mutable std::shared_mutex m_handlerListMutex; . . . };</span></span></code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerEventJoin</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: HandlerEventJoin( IEvent&lt;TParams...&gt;&amp; _event, THandlerPtr&lt;TParams...&gt; handler ) : m_event( _event ), m_handler( handler ) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isJoined</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_event.isHandlerAdded( m_handler ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_event.addHandler( m_handler ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unjoin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_event.removeHandler( m_handler ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: IEvent&lt;TParams...&gt;&amp; m_event; THandlerPtr&lt;TParams...&gt; m_handler; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">كما ترى ، تمت إضافة مكان آخر محتمل لتخزين مثيل المعالج ، لذلك سنستخدم </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: Shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> بدلاً من </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: unique_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> لهذا الغرض </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ومع ذلك ، فإن هذا الفصل ، بالنسبة لي ، غير مريح قليلاً للاستخدام. أود تخزين وإنشاء نسخ اتصال بدون قائمة من المعلمات التي تنسخ قالب الصف. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ننفذ هذا باستخدام فئة السلف المجردة والمغلف:</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventJoin</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~AbstractEventJoin() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isJoined</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unjoin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: AbstractEventJoin() {} };</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerEventJoin</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventJoin { . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isJoined</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ . . . } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ . . . } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unjoin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ . . . } . . . };</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventJoinWrapper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inline</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventJoinWrapper</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IEvent</span></span></span><span class="hljs-class">&lt;TParams...&gt;&amp; _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handler</span></span></span><span class="hljs-class"> ) :</span></span> m_eventJoin( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;HandlerEventJoin&lt;TParams...&gt;&gt;( _event, HandlerCast&lt;TSome&gt;::cast&lt;TParams...&gt;( handler ) ) ) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EventJoinWrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_eventJoin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nullptr</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ } ~EventJoinWrapper() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_eventJoin != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> m_eventJoin; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isJoined(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAssigned</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( m_eventJoin != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isJoined</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( m_eventJoin != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; m_eventJoin-&gt;isJoined() ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( m_eventJoin != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ? m_eventJoin-&gt;join() : <span class="hljs-literal"><span class="hljs-literal">false</span></span> ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unjoin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( m_eventJoin != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ? m_eventJoin-&gt;unjoin() : <span class="hljs-literal"><span class="hljs-literal">false</span></span> ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: AbstractEventJoin* m_eventJoin; }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> EventJoin = EventJoinWrapper;</code> </pre><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HandlerCast</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> هو نفس الهيكل الداعم الذي تم استخدامه </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هنا</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . بالمناسبة ، من المهم عدم نسيان جعل أداة </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AbstractEventJoin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> المدمرة </font><font style="vertical-align: inherit;">افتراضية بحيث عندما تحذف </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مثيلها</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> في </font><i><font style="vertical-align: inherit;">أداة EventJoinWrapper</font></i><font style="vertical-align: inherit;"> المدمرة ، يتم </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">استدعاء أداة</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إتلاف </font><i><font style="vertical-align: inherit;">HandlerEventJoin</font></i><font style="vertical-align: inherit;"> ، وإلا فإن حقل </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">THandlerPtr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> وبالتالي ، </font><font style="vertical-align: inherit;">لن يتم إتلاف </font><font style="vertical-align: inherit;">المعالج نفسه. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يبدو أن هذا التطبيق قابل للتنفيذ ، ولكن للوهلة الأولى فقط. </font><font style="vertical-align: inherit;">سيؤدي </font><font style="vertical-align: inherit;">نسخ أو نقل مثيل </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EventJoinWrapper</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إلى حذف </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m_eventJoin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> في المدمر الخاص به </font><font style="vertical-align: inherit;">مرة أخرى </font><font style="vertical-align: inherit;">. لذلك ، نستخدم </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: Shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> لتخزين المثيل</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AbstractEventJoin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، بالإضافة إلى تنفيذ دلالات محسنة قليلاً للحركة (والنسخ) ، لأن </font><font style="vertical-align: inherit;">ستكون هذه عملية متكررة محتملة.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventJoinWrapper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: EventJoinWrapper( EventJoinWrapper&amp;&amp; other ) : m_eventJoin( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( other.m_eventJoin ) ) { } EventJoinWrapper( EventJoinWrapper&amp; other ) : m_eventJoin( other.m_eventJoin ) { } ~EventJoinWrapper() { <span class="hljs-comment"><span class="hljs-comment">/*empty*/</span></span> } EventJoinWrapper&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=( EventJoinWrapper&amp;&amp; other ) { m_eventJoin = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( other.m_eventJoin ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } EventJoinWrapper&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> EventJoinWrapper&amp; other ) { m_eventJoin = other.m_eventJoin; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } . . . <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;AbstractEventJoin&gt; m_eventJoin; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> الآن عند توصيل معالج بحدث ، يمكنك على الفور إرجاع مثيل اتصال جديد: </font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IEvent</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventJoin</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">+=( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-function"><span class="hljs-function">EventJoin </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::forward&lt;TSome&gt;( some ) )</span></span></span></span>; result.join(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } . . . };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">وبعد حل التبعية الثلاثية من خلال </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تضمين </font></font></i> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(IEvent &lt;= EventJointWrapper.hpp؛ EventJointWrapper &lt;= HandlerEventJoin.hpp؛ HandlerEventJoin &lt;= IEvent.hpp) عن طريق</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> تقسيم بعض الملفات إلى </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.h</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> و </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.hpp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> يمكنك حتى العمل مع هذا. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يتبع إنشاء مثيلات الاتصال نفس القواعد التي تعمل عند اشتراك معالج الأحداث:</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventHolder</span></span></span><span class="hljs-class"> {</span></span> TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;&gt; onEvent; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodsHolder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;&amp; )</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method5</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[] )</span></span></span><span class="hljs-function"> </span></span>{ EventHolder _eventHolder; MethodsHolder _methodsHolder; EventJoin join1 = EventJoin( _eventHolder.onEvent, METHOD_HANDLER( _methodsHolder, MethodsHolder::method1 ) ); <span class="hljs-comment"><span class="hljs-comment">// ok EventJoin join2 = EventJoin( _eventHolder.onEvent, METHOD_HANDLER( _methodsHolder, MethodsHolder::method2 ) ); // ok EventJoin join3 = EventJoin( _eventHolder.onEvent, METHOD_HANDLER( _methodsHolder, MethodsHolder::method3 ) ); // error EventJoin join4 = EventJoin( _eventHolder.onEvent, METHOD_HANDLER( _methodsHolder, MethodsHolder::method4 ) ); // error EventJoin join5 = EventJoin( _eventHolder.onEvent, METHOD_HANDLER( _methodsHolder, MethodsHolder::method5 ) ); // error return 0; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> بالإضافة إلى ذلك ، يمكنك "تمكين" / "تعطيل" معالجة الأحداث (التي تم إنشاء الاتصالات من حيث المبدأ): </font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventHolder</span></span></span><span class="hljs-class"> {</span></span> TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; onEvent; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodsHolder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; text, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Text '"</span></span> &lt;&lt; text &lt;&lt; <span class="hljs-string"><span class="hljs-string">"' handled "</span></span> &lt;&lt; count &lt;&lt; <span class="hljs-string"><span class="hljs-string">" times."</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[] )</span></span></span><span class="hljs-function"> </span></span>{ EventHolder _eventHolder; MethodsHolder methodsHolder; EventJoin eventJoin = EventJoin( _eventHolder.onEvent, METHOD_HANDLER( methodsHolder, MethodsHolder::handleEvent ) ); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> handlingText = <span class="hljs-string"><span class="hljs-string">"testing..."</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; ++i ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( eventJoin.isJoined() ) eventJoin.unjoin(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> eventJoin.join(); _eventHolder.onEvent( handlingText, i ); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">Text</span></span> <span class="hljs-string"><span class="hljs-string">'testing...'</span></span> handled <span class="hljs-number"><span class="hljs-number">0</span></span> times. <span class="hljs-type"><span class="hljs-type">Text</span></span> <span class="hljs-string"><span class="hljs-string">'testing...'</span></span> handled <span class="hljs-number"><span class="hljs-number">2</span></span> times. <span class="hljs-type"><span class="hljs-type">Text</span></span> <span class="hljs-string"><span class="hljs-string">'testing...'</span></span> handled <span class="hljs-number"><span class="hljs-number">4</span></span> times. <span class="hljs-type"><span class="hljs-type">Text</span></span> <span class="hljs-string"><span class="hljs-string">'testing...'</span></span> handled <span class="hljs-number"><span class="hljs-number">6</span></span> times. <span class="hljs-type"><span class="hljs-type">Text</span></span> <span class="hljs-string"><span class="hljs-string">'testing...'</span></span> handled <span class="hljs-number"><span class="hljs-number">8</span></span> times.</code> </pre><br><a name="Totals"></a><h1 style=";text-align:right;direction:rtl">  الملخص </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أولاً ، تجدر الإشارة إلى أن مهمة كتابة مقال قصير قدر الإمكان وفشل بإيجاز تمامًا. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">آمل أن يكون التنفيذ الناتج لمعالجة الأحداث فعالًا تمامًا وأن يكون مفيدًا لشخص ما على الأقل.</font></font><br><br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مثال مرهق للغاية يوضح الميزات الرئيسية</font></font></b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;functional&gt; #include "events/event.hpp" #include "events/handler/methodeventhandler.hpp" #include "events/handler/functoreventhandler.hpp" #include "events/join/handlereventjoin.hpp" #include "events/join/eventjoinwrapper.hpp" class Foo { public: Foo() : onMake( m_onMake ), m_onMake(), m_onMakeInner(), m_makeCount( 0 ) { m_onMakeInner += FUNCTOR_HANDLER( m_onMake ); } IEvent&lt;unsigned int&gt;&amp; onMake; void make() { m_onMakeInner( m_makeCount++ ); } private: TEvent&lt;unsigned int&gt; m_onMake, m_onMakeInner; unsigned int m_makeCount; }; namespace instances { Foo&amp; getFoo() { static Foo _foo; return _foo; } } // instances struct FunctorHandler { void operator()( unsigned int makeCount ); }; void functionHandler( unsigned int makeCount ); class ClassHandler { public: void handle( unsigned int makeCount ); }; namespace instances { FunctorHandler&amp; getFunctorHandler() { static FunctorHandler _functorHandler; return _functorHandler; } std::function&lt;void( unsigned int )&gt;&amp; getStdFunctionHandler() { static std::function&lt;void( unsigned int )&gt; _stdFunctionHandler = []( unsigned int makeCount ) { std::cout &lt;&lt; "It's std::function handler" &lt;&lt; std::endl; if( makeCount &gt;= 2 ) instances::getFoo().onMake -= STD_FUNCTION_HANDLER( instances::getStdFunctionHandler() ); }; return _stdFunctionHandler; } ClassHandler&amp; getClassHandler() { static ClassHandler _classHandler; return _classHandler; } } // instances void FunctorHandler::operator()( unsigned int makeCount ) { std::cout &lt;&lt; "It's functor handler" &lt;&lt; std::endl; if( makeCount &gt;= 0 ) instances::getFoo().onMake -= FUNCTOR_HANDLER( instances::getFunctorHandler() ); } void functionHandler( unsigned int makeCount ) { std::cout &lt;&lt; "It's function handler" &lt;&lt; std::endl; if( makeCount &gt;= 3 ) instances::getFoo().onMake -= FUNCTION_HANDLER( functionHandler ); } void ClassHandler::handle( unsigned int makeCount ) { std::cout &lt;&lt; "It's method handler" &lt;&lt; std::endl; if( makeCount &gt;= 4 ) instances::getFoo().onMake -= MY_METHOD_HANDLER( ClassHandler::handle ); } int main( int argc, char* argv[] ) { Foo&amp; foo = instances::getFoo(); auto lambdaHandler = []( unsigned int ) { std::cout &lt;&lt; "It's lambda handler" &lt;&lt; std::endl; }; foo.onMake += FUNCTOR_HANDLER( instances::getFunctorHandler() ); foo.onMake += LAMBDA_HANDLER( lambdaHandler ); EventJoin lambdaJoin = foo.onMake += LAMBDA_HANDLER( ( [ &amp;foo, &amp;lambdaHandler ]( unsigned int makeCount ) { if( makeCount &gt;= 1 ) foo.onMake -= LAMBDA_HANDLER( lambdaHandler ); } ) ); foo.onMake += STD_FUNCTION_HANDLER( instances::getStdFunctionHandler() ); foo.onMake += FUNCTION_HANDLER( functionHandler ); foo.onMake += METHOD_HANDLER( instances::getClassHandler(), ClassHandler::handle ); for( int i = 0; i &lt; 6; ++i ) { std::cout &lt;&lt; "Make " &lt;&lt; i &lt;&lt; " time:" &lt;&lt; std::endl; foo.make(); std::cout &lt;&lt; std::endl; } lambdaJoin.unjoin(); return 0; }</span></span></span></span></code> </pre><br>  الخلاصة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs powershell">Make <span class="hljs-number"><span class="hljs-number">0</span></span> time: It<span class="hljs-string"><span class="hljs-string">'s functor handler It'</span></span>s lambda handler It<span class="hljs-string"><span class="hljs-string">'s std::function handler It'</span></span>s <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Make</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">1</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">time</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lambda</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">std</span></span></span><span class="hljs-function">::</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Make</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">2</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">time</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">std</span></span></span><span class="hljs-function">::</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Make</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">3</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">time</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Make</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">4</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">time</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Make</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">5</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">time</span></span></span><span class="hljs-function">:</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> تجدر الإشارة إلى عدد من النقاط المهمة: </font></font><br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> لم يتم تحديده بشكل منفصل ، لذلك سأذكر أن الحدث نفسه في هذا التنفيذ هو ممول ، مما يعني أنه يمكن أن يكون بمثابة معالج لحدث آخر ؛ </font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الآن لا يمكنك استخدام طرق ثابتة (وظائف أعضاء الفئة) كمعالجات ؛ </font><font style="vertical-align: inherit;">أعتقد أنه إذا كانت هناك حاجة إلى مثل هذه الفرصة ، فليس من الصعب كتابة نوع جديد من المعالج لهذا بناءً على الأنواع الموجودة.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> بالإضافة إلى ذلك ، في النسخة النهائية ، هناك بعض النقاط المحذوفة في المقالة لمزيد من الرؤية والقدرة على قراءة الكود: </font></font><br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يمكن أن يكون نوع القيمة المرتجعة للطريقة (وظيفة العضو في الفئة) للمعالج المقابل أيًا ، وليس بالضرورة </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لاغيًا</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (بالنسبة إلى المعالجين ، تم إجراء ذلك أيضًا) ؛</font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يتم تطبيق التنفيذ بالكامل في </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مساحات الأسماء</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> لسهولة الاستخدام في المشاريع (إذا كان هذا يبدو غير ضروري لشخص ما ، يمكنك دائمًا إزالته) ؛</font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تمت إضافة محدد </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">noexcept</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> في </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;">بعض الأماكن</font></a><font style="vertical-align: inherit;"> .</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لجميع أولئك الذين قرأوا هنا على الأقل قطريا ، القوس المنخفض. </font><font style="vertical-align: inherit;">أرفق جميع التعليمات البرمجية ؛ </font><font style="vertical-align: inherit;">يمكن أيضًا أخذه </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هنا</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (مع جميع التحسينات الأخيرة).</font></font><br><br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">كود كامل</font></font></b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/helpers/is_equatable.hpp</font></font></b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;type_traits&gt; template&lt;class T&gt; class is_equatable { private: template&lt;class U&gt; static constexpr std::true_type exists( decltype( std::declval&lt;U&gt;() == std::declval&lt;U&gt;() )* = nullptr ) noexcept; template&lt;class U&gt; static constexpr std::false_type exists( ... ) noexcept; public: static constexpr bool value = decltype( exists&lt;T&gt;( nullptr ) )::value; };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/handlers/ab abstracteventhandler.hpp</font></font></b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"eventhandlerptr.h"</span></span></span><span class="hljs-meta"> namespace events { namespace handlers { template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class ...TParams&gt; class AbstractEventHandler { using MyType = AbstractEventHandler&lt;TParams...&gt;; public: virtual ~AbstractEventHandler() {} virtual void call( TParams... params ) = 0; bool operator==( const MyType&amp; other ) const noexcept { return isEquals( other ); } bool operator!=( const MyType&amp; other ) const noexcept { return !( *this == other ); } protected: AbstractEventHandler() {} virtual bool isEquals( const MyType&amp; other ) const noexcept = 0; }; } // handlers } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/handlers/eventhandlerptr.h</font></font></b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; namespace events { namespace handlers { template&lt;class ...TParams&gt; class AbstractEventHandler; template&lt;class ...Types&gt; using TEventHandlerPtr = std::shared_ptr&lt;AbstractEventHandler&lt;Types...&gt;&gt;; } // handlers } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/handlers/functoreventhandler.hpp</font></font></b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;assert.h&gt; #include "abstracteventhandler.hpp" #include "../helpers/is_equatable.hpp" namespace events { namespace handlers { namespace { template&lt;class TFunctor, class ...TParams&gt; struct IsFunctorParamsCompatible { private: template&lt;class TCheckedFunctor, class ...TCheckedParams&gt; static constexpr std::true_type exists( decltype( std::declval&lt;TCheckedFunctor&gt;()( std::declval&lt;TCheckedParams&gt;()... ) )* = nullptr ) noexcept; template&lt;class TCheckedFunctor, class ...TCheckedParams&gt; static constexpr std::false_type exists( ... ) noexcept; public: static constexpr bool value = decltype( exists&lt;TFunctor, TParams...&gt;( nullptr ) )::value; }; } // template&lt;class TFunctor&gt; class FunctorHolder; template&lt;class TFunctor, class ...TParams&gt; class FunctorEventHandler : public AbstractEventHandler&lt;TParams...&gt; { using MyType = FunctorEventHandler&lt;TFunctor, TParams...&gt;; using TFunctorHolderPtr = std::shared_ptr&lt;FunctorHolder&lt;TFunctor&gt;&gt;; public: FunctorEventHandler( TFunctorHolderPtr functorHolder ) : AbstractEventHandler&lt;TParams...&gt;(), m_functorHolder( functorHolder ) { assert( m_functorHolder != nullptr ); } virtual void call( TParams... params ) override { static_assert( IsFunctorParamsCompatible&lt;TFunctor, TParams...&gt;::value, "Event and functor arguments are not compatible" ); m_functorHolder-&gt;m_functor( params... ); } protected: virtual bool isEquals( const AbstractEventHandler&lt;TParams...&gt;&amp; other ) const noexcept override { const MyType* _other = dynamic_cast&lt;const MyType*&gt;( &amp;other ); return ( _other != nullptr &amp;&amp; *m_functorHolder == *_other-&gt;m_functorHolder ); } private: TFunctorHolderPtr m_functorHolder; }; namespace { template&lt;class TEqu, class TEnabled = void&gt; struct EqualityChecker; template&lt;class TEquatable&gt; struct EqualityChecker&lt;TEquatable, typename std::enable_if&lt;is_equatable&lt;TEquatable&gt;::value&gt;::type&gt; { static constexpr bool isEquals( const TEquatable&amp; operand1, const TEquatable&amp; operand2 ) noexcept { return ( operand1 == operand2 ); } }; template&lt;class TNonEquatable&gt; struct EqualityChecker&lt;TNonEquatable, typename std::enable_if&lt;!is_equatable&lt;TNonEquatable&gt;::value&gt;::type&gt; { static constexpr bool isEquals( const TNonEquatable&amp; operand1, const TNonEquatable&amp; operand2 ) noexcept { return ( &amp;operand1 == &amp;operand2 ); } }; } // template&lt;class TFunctor&gt; class FunctorHolder { using MyType = FunctorHolder&lt;TFunctor&gt;; public: template&lt;class ...TCallParams&gt; operator TEventHandlerPtr&lt;TCallParams...&gt;() { return TEventHandlerPtr&lt;TCallParams...&gt;( new FunctorEventHandler&lt;TFunctor, TCallParams...&gt;( m_me.lock() ) ); } bool operator==( const MyType&amp; other ) const noexcept { return EqualityChecker&lt;TFunctor&gt;::isEquals( m_functor, other.m_functor ); } bool operator!=( const MyType&amp; other ) const noexcept { return !( *this == other ); } template&lt;class TFunctor&gt; static std::shared_ptr&lt;MyType&gt; create( TFunctor&amp;&amp; functor ) { std::shared_ptr&lt;MyType&gt; result( new MyType( functor ) ); result-&gt;m_me = result; return result; } private: FunctorHolder( TFunctor&amp; functor ) : m_functor( functor ), m_me() { } TFunctor&amp; m_functor; std::weak_ptr&lt;MyType&gt; m_me; template&lt;class TFunctor, class ...TParams&gt; friend class FunctorEventHandler; }; template&lt;class TFunctor&gt; std::shared_ptr&lt;FunctorHolder&lt;TFunctor&gt;&gt; createFunctorEventHandler( TFunctor&amp;&amp; functor ) { return FunctorHolder&lt;TFunctor&gt;::create( functor ); } } // handlers } // events #define FUNCTOR_HANDLER( Functor ) ::events::handlers::createFunctorEventHandler( Functor ) #define LAMBDA_HANDLER( Lambda ) FUNCTOR_HANDLER( Lambda ) #define STD_FUNCTION_HANDLER( StdFunction ) FUNCTOR_HANDLER( StdFunction ) #define FUNCTION_HANDLER( Function ) FUNCTOR_HANDLER( &amp;Function )</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/handlers/methodeventhandler.hpp</font></font></b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;assert.h&gt; #include "abstracteventhandler.hpp" namespace events { namespace handlers { namespace { template&lt;class TMethodHolder, class ...TParams&gt; struct IsMethodParamsCompatible { private: template&lt;class TCheckedMethodHolder, class ...TCheckedParams&gt; static constexpr std::true_type exists( decltype( ( std::declval&lt;TCheckedMethodHolder&gt;().m_object.*std::declval&lt;TCheckedMethodHolder&gt;().m_method )( std::declval&lt;TCheckedParams&gt;()... ) )* = nullptr ) noexcept; template&lt;class TCheckedMethodHolder, class ...TCheckedParams&gt; static constexpr std::false_type exists( ... ) noexcept; public: static constexpr bool value = decltype( exists&lt;TMethodHolder, TParams...&gt;( nullptr ) )::value; }; } // template&lt;class TMethodHolder, class ...TParams&gt; class MethodEventHandler : public AbstractEventHandler&lt;TParams...&gt; { using MyType = MethodEventHandler&lt;TMethodHolder, TParams...&gt;; using TMethodHolderPtr = std::shared_ptr&lt;TMethodHolder&gt;; public: MethodEventHandler( TMethodHolderPtr methodHolder ) : AbstractEventHandler&lt;TParams...&gt;(), m_methodHolder( methodHolder ) { assert( m_methodHolder != nullptr ); } virtual void call( TParams... params ) override { static_assert( IsMethodParamsCompatible&lt;TMethodHolder, TParams...&gt;::value, "Event and method arguments are not compatible" ); ( m_methodHolder-&gt;m_object.*m_methodHolder-&gt;m_method )( params... ); } protected: virtual bool isEquals( const AbstractEventHandler&lt;TParams...&gt;&amp; other ) const noexcept override { const MyType* _other = dynamic_cast&lt;const MyType*&gt;( &amp;other ); return ( _other != nullptr &amp;&amp; *m_methodHolder == *_other-&gt;m_methodHolder ); } private: TMethodHolderPtr m_methodHolder; }; template&lt;class TObject, class TResult, class ...TParams&gt; class MethodHolder { using MyType = MethodHolder&lt;TObject, TResult, TParams...&gt;; using TMethod = TResult( TObject::* )( TParams... ); public: template&lt;class ...TCallParams&gt; operator TEventHandlerPtr&lt;TCallParams...&gt;() { return TEventHandlerPtr&lt;TCallParams...&gt;( new MethodEventHandler&lt;MyType, TCallParams...&gt;( m_me.lock() ) ); } bool operator==( const MyType&amp; other ) const noexcept { return ( &amp;m_object == &amp;other.m_object &amp;&amp; m_method == other.m_method ); } bool operator!=( const MyType&amp; other ) const noexcept { return !( *this == other ); } template&lt;class TObject, class ...TParams&gt; static std::shared_ptr&lt;MyType&gt; create( TObject&amp; object, TMethod method ) { std::shared_ptr&lt;MyType&gt; result( new MyType( object, method ) ); result-&gt;m_me = result; return result; } private: MethodHolder( TObject&amp; object, TMethod method ) : m_object( object ), m_method( method ) { assert( m_method != nullptr ); } TObject&amp; m_object; TMethod m_method; std::weak_ptr&lt;MyType&gt; m_me; template&lt;class TMethodHolder, class ...TParams&gt; friend class MethodEventHandler; template&lt;class TMethodHolder, class ...TParams&gt; friend struct IsMethodParamsCompatible; }; template&lt;class TObject, class TResult, class ...TParams&gt; std::shared_ptr&lt;MethodHolder&lt;TObject, TResult, TParams...&gt;&gt; createMethodEventHandler( TObject&amp; object, TResult( TObject::*method )( TParams... ) ) { return MethodHolder&lt;TObject, TResult, TParams...&gt;::create( object, method ); } } // handlers } // events #define METHOD_HANDLER( Object, Method ) ::events::handlers::createMethodEventHandler( Object, &amp;Method ) #define MY_METHOD_HANDLER( Method ) METHOD_HANDLER( *this, Method )</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/handlers/handlercast.hpp</font></font></b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include "eventhandlerptr.h" namespace events { namespace handlers { template&lt;class TSome&gt; struct HandlerCast { template&lt;class ...Types&gt; static constexpr TEventHandlerPtr&lt;Types...&gt; cast( TSome&amp; some ) { return static_cast&lt;TEventHandlerPtr&lt;Types...&gt;&gt;( some ); } }; template&lt;class TPtr&gt; struct HandlerCast&lt;std::shared_ptr&lt;TPtr&gt;&gt; { template&lt;class ...Types&gt; static constexpr TEventHandlerPtr&lt;Types...&gt; cast( std::shared_ptr&lt;TPtr&gt; some ) { return HandlerCast&lt;TPtr&gt;::cast&lt;Types...&gt;( *some ); } }; } // handlers } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title">./events/event.hpp</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;type_traits&gt; #include &lt;list&gt; #include &lt;memory&gt; #include &lt;shared_mutex&gt; #include &lt;algorithm&gt; #include &lt;assert.h&gt; #include "handlers/abstracteventhandler.hpp" #include "handlers/eventhandlerptr.h" #include "handlers/handlercast.hpp" #include "joins/eventjoinwrapper.hpp" namespace events { namespace joins { template&lt;class ...TParams&gt; class HandlerEventJoin; } template&lt;class ...TParams&gt; class IEvent { public: template&lt;class TSome&gt; EventJoin operator+=( TSome&amp;&amp; some ) { EventJoin result( *this, std::forward&lt;TSome&gt;( some ) ); result.join(); return result; } template&lt;class TSome&gt; bool operator-=( TSome&amp;&amp; some ) { return removeHandler( handlers::HandlerCast&lt;TSome&gt;::cast&lt;TParams...&gt;( some ) ); } protected: using TMyEventHandlerPtr = handlers::TEventHandlerPtr&lt;TParams...&gt;; IEvent() {} virtual bool isHandlerAdded( const TMyEventHandlerPtr&amp; eventHandler ) const = 0; virtual bool addHandler( TMyEventHandlerPtr eventHandler ) = 0; virtual bool removeHandler( TMyEventHandlerPtr eventHandler ) = 0; friend class joins::HandlerEventJoin&lt;TParams...&gt;; }; template&lt;class ...TParams&gt; class TEvent : public IEvent&lt;TParams...&gt; { using TEventHandlerIt = typename std::list&lt;TMyEventHandlerPtr&gt;::const_iterator; public: TEvent() : m_handlers(), m_currentIt(), m_isCurrentItRemoved( false ), m_handlerListMutex() { } void operator()( TParams... params ) { m_handlerListMutex.lock_shared(); m_isCurrentItRemoved = false; m_currentIt = m_handlers.begin(); while( m_currentIt != m_handlers.end() ) { m_handlerListMutex.unlock_shared(); ( *m_currentIt )-&gt;call( params... ); m_handlerListMutex.lock_shared(); if( m_isCurrentItRemoved ) { m_isCurrentItRemoved = false; TEventHandlerIt removedIt = m_currentIt; ++m_currentIt; deleteHandler( removedIt ); } else { ++m_currentIt; } } m_handlerListMutex.unlock_shared(); } protected: virtual bool isHandlerAdded( const TMyEventHandlerPtr&amp; eventHandler ) const override { std::shared_lock&lt;std::shared_mutex&gt; _handlerListMutexLock( m_handlerListMutex ); return ( findEventHandler( eventHandler ) != m_handlers.end() ); } virtual bool addHandler( TMyEventHandlerPtr eventHandler ) override { std::unique_lock&lt;std::shared_mutex&gt; _handlerListMutexLock( m_handlerListMutex ); if( findEventHandler( eventHandler ) == m_handlers.end() ) { m_handlers.push_back( std::move( eventHandler ) ); return true; } return false; } virtual bool removeHandler( TMyEventHandlerPtr eventHandler ) override { std::unique_lock&lt;std::shared_mutex&gt; _handlerListMutexLock( m_handlerListMutex ); auto it = findEventHandler( eventHandler ); if( it != m_handlers.end() ) { if( it == m_currentIt ) m_isCurrentItRemoved = true; else deleteHandler( it ); return true; } return false; } private: //      'm_handlerListMutex' inline TEventHandlerIt findEventHandler( const TMyEventHandlerPtr&amp; eventHandler ) const noexcept { return std::find_if( m_handlers.cbegin(), m_handlers.cend(), [ &amp;eventHandler ]( const TMyEventHandlerPtr&amp; oneHandler ) { return ( *oneHandler == *eventHandler ); } ); } //      'm_handlerListMutex' inline void deleteHandler( TEventHandlerIt it ) { m_handlers.erase( it ); } std::list&lt;TMyEventHandlerPtr&gt; m_handlers; //    'm_handlerListMutex' mutable TEventHandlerIt m_currentIt; mutable bool m_isCurrentItRemoved; mutable std::shared_mutex m_handlerListMutex; }; } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title">./events/joins/abstracteventjoin.h</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once namespace events { namespace joins { class AbstractEventJoin { public: virtual ~AbstractEventJoin(); virtual bool isJoined() const = 0; virtual bool join() = 0; virtual bool unjoin() = 0; protected: AbstractEventJoin(); }; } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// joins } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title">./events/joins/abstracteventjoin.cpp</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"abstracteventjoin.h"</span></span></span><span class="hljs-meta"> namespace events { namespace joins { AbstractEventJoin::AbstractEventJoin() { } AbstractEventJoin::~AbstractEventJoin() { } } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// joins } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title">./events/joins/handlereventjoin.h</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"abstracteventjoin.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../handlers/eventhandlerptr.h"</span></span></span><span class="hljs-meta"> namespace events { template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class ...TParams&gt; class IEvent; namespace joins { template&lt;class ...TParams&gt; class HandlerEventJoin : public AbstractEventJoin { public: HandlerEventJoin( IEvent&lt;TParams...&gt;&amp; _event, ::events::handlers::TEventHandlerPtr&lt;TParams...&gt; handler ) : AbstractEventJoin(), m_event( _event ), m_handler( handler ) { } virtual inline bool isJoined() const override; virtual inline bool join() override; virtual inline bool unjoin() override; private: IEvent&lt;TParams...&gt;&amp; m_event; ::events::handlers::TEventHandlerPtr&lt;TParams...&gt; m_handler; }; } // joins } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title">./events/joins/handlereventjoin.hpp</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"handlereventjoin.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../event.hpp"</span></span></span><span class="hljs-meta"> namespace events { namespace joins { template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class ...TParams&gt; bool HandlerEventJoin&lt;TParams...&gt;::isJoined() const { return m_event.isHandlerAdded( m_handler ); } template&lt;class ...TParams&gt; bool HandlerEventJoin&lt;TParams...&gt;::join() { return m_event.addHandler( m_handler ); } template&lt;class ...TParams&gt; bool HandlerEventJoin&lt;TParams...&gt;::unjoin() { return m_event.removeHandler( m_handler ); } } // joins } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title">./events/joins/eventjoinwrapper.h</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include "../handlers/eventhandlerptr.h" namespace events { template&lt;class ...TParams&gt; class IEvent; namespace joins { class AbstractEventJoin; class EventJoinWrapper { public: template&lt;class TSome, class ...TParams&gt; inline EventJoinWrapper( IEvent&lt;TParams...&gt;&amp; _event, TSome&amp;&amp; handler ); constexpr EventJoinWrapper() noexcept; EventJoinWrapper( EventJoinWrapper&amp;&amp; other ) noexcept; EventJoinWrapper( EventJoinWrapper&amp; other ) noexcept; EventJoinWrapper&amp; operator=( EventJoinWrapper&amp;&amp; other ) noexcept; EventJoinWrapper&amp; operator=( const EventJoinWrapper&amp; other ) noexcept; operator bool() const; bool isAssigned() const; bool isJoined() const; bool join(); bool unjoin(); private: std::shared_ptr&lt;AbstractEventJoin&gt; m_eventJoin; }; } // joins using EventJoin = joins::EventJoinWrapper; } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title">./events/joins/eventjoinwrapper.hpp</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"eventjoinwrapper.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"handlereventjoin.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../handlers/handlercast.hpp"</span></span></span><span class="hljs-meta"> namespace events { namespace joins { template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class TSome, class ...TParams&gt; EventJoinWrapper::EventJoinWrapper( IEvent&lt;TParams...&gt;&amp; _event, TSome&amp;&amp; handler ) : m_eventJoin( std::make_shared&lt;HandlerEventJoin&lt;TParams...&gt;&gt;( _event, ::events::handlers::HandlerCast&lt;TSome&gt;::cast&lt;TParams...&gt;( handler ) ) ) { } } // joins } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title">./events/joins/eventjoinwrapper.cpp</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"eventjoinwrapper.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;type_traits&gt; #include "abstracteventjoin.h" namespace events { namespace joins { constexpr EventJoinWrapper::EventJoinWrapper() noexcept : m_eventJoin( nullptr ) { } EventJoinWrapper::EventJoinWrapper( EventJoinWrapper&amp;&amp; other ) noexcept : m_eventJoin( std::move( other.m_eventJoin ) ) { } EventJoinWrapper::EventJoinWrapper( EventJoinWrapper&amp; other ) noexcept : m_eventJoin( other.m_eventJoin ) { } EventJoinWrapper&amp; EventJoinWrapper::operator=( EventJoinWrapper&amp;&amp; other ) noexcept { m_eventJoin = std::move( other.m_eventJoin ); return *this; } EventJoinWrapper&amp; EventJoinWrapper::operator=( const EventJoinWrapper&amp; other ) noexcept { m_eventJoin = other.m_eventJoin; return *this; } EventJoinWrapper::operator bool() const { return isJoined(); } bool EventJoinWrapper::isAssigned() const { return ( m_eventJoin != nullptr ); } bool EventJoinWrapper::isJoined() const { return ( m_eventJoin != nullptr &amp;&amp; m_eventJoin-&gt;isJoined() ); } bool EventJoinWrapper::join() { return ( m_eventJoin != nullptr ? m_eventJoin-&gt;join() : false ); } bool EventJoinWrapper::unjoin() { return ( m_eventJoin != nullptr ? m_eventJoin-&gt;unjoin() : false ); } } // joins } // events</span></span></span></span></code> </pre><br></div></div><br></div></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD1. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هنا وفي وقت سابق من المقالة ، </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يتم إعطاء</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> التعليمات البرمجية المكتوبة تحت </font><i><font style="vertical-align: inherit;">VC ++ 14</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">للتوافق مع المترجمين الآخرين ، من الأفضل أخذ الكود من الرابط. </font><font style="vertical-align: inherit;">شكر خاص إلى </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الغشاش</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> لتوفير التوافق مع </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">دول مجلس التعاون الخليجي</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><a name="ThreadRev"></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD2. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">شكرا </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lexxmark</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، الذي </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">رأى</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> حفرة في موضوع من حيث عدة استدعاءات الأحداث في وقت واحد.</font></font><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تحسينات طفيفة</font></font></b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeHelper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandlerPtr = handlers::TEventHandlerPtr&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandlerIt = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;TEventHandlerPtr&gt;::const_iterator; }; } <span class="hljs-comment"><span class="hljs-comment">// template&lt;class ...TParams&gt; class IEvent { . . . protected: using TMyEventHandlerPtr = typename TypeHelper&lt;TParams...&gt;::TEventHandlerPtr; . . . }; namespace { template&lt;class ...TParams&gt; struct EventCore { using TMyHandlerPtr = typename TypeHelper&lt;TParams...&gt;::TEventHandlerPtr; std::list&lt;TMyHandlerPtr&gt; handlers; mutable std::shared_mutex coreMutex; }; template&lt;class ...TParams&gt; class HandlerRunner { using TMyEventCore = EventCore&lt;TParams...&gt;; using TMyHandlerIt = typename TypeHelper&lt;TParams...&gt;::TEventHandlerIt; public: HandlerRunner( TMyEventCore&amp; eventCore ) : m_eventCore( eventCore ), currentIt(), wasRemoving( false ) { } void run( TParams... params ) { m_eventCore.coreMutex.lock_shared(); currentIt = m_eventCore.handlers.begin(); wasRemoving = false; while( currentIt != m_eventCore.handlers.end() ) { m_eventCore.coreMutex.unlock_shared(); ( *currentIt )-&gt;call( params... ); m_eventCore.coreMutex.lock_shared(); if( wasRemoving ) wasRemoving = false; else ++currentIt; } m_eventCore.coreMutex.unlock_shared(); } TMyHandlerIt currentIt; mutable bool wasRemoving; private: TMyEventCore&amp; m_eventCore; }; } // template&lt;class ...TParams&gt; class TEvent : public IEvent&lt;TParams...&gt; { using TMyEventHandlerPtr = typename TypeHelper&lt;TParams...&gt;::TEventHandlerPtr; using TMyEventHandlerIt = typename TypeHelper&lt;TParams...&gt;::TEventHandlerIt; using TMyHandlerRunner = HandlerRunner&lt;TParams...&gt;; public: TEvent() : m_core() { } void operator()( TParams... params ) { TMyHandlerRunner newHandlerRunner( m_core ); m_core.coreMutex.lock_shared(); auto it = m_handlerRunners.insert( m_handlerRunners.end(), &amp;newHandlerRunner ); m_core.coreMutex.unlock_shared(); newHandlerRunner.run( params... ); m_core.coreMutex.lock_shared(); m_handlerRunners.erase( it ); m_core.coreMutex.unlock_shared(); } protected: virtual bool isHandlerAdded( const TMyEventHandlerPtr&amp; eventHandler ) const override { std::shared_lock&lt;std::shared_mutex&gt; _coreMutexLock( m_core.coreMutex ); return ( findEventHandler( eventHandler ) != m_core.handlers.end() ); } virtual bool addHandler( TMyEventHandlerPtr eventHandler ) override { std::unique_lock&lt;std::shared_mutex&gt; _coreMutexLock( m_core.coreMutex ); if( findEventHandler( eventHandler ) == m_core.handlers.end() ) { m_core.handlers.push_back( std::move( eventHandler ) ); return true; } return false; } virtual bool removeHandler( TMyEventHandlerPtr eventHandler ) override { std::unique_lock&lt;std::shared_mutex&gt; _coreMutexLock( m_core.coreMutex ); auto it = findEventHandler( eventHandler ); if( it != m_core.handlers.end() ) { for( TMyHandlerRunner* oneHandlerRunner : m_handlerRunners ) { if( it == oneHandlerRunner-&gt;currentIt ) { ++oneHandlerRunner-&gt;currentIt; oneHandlerRunner-&gt;wasRemoving = true; } } m_core.handlers.erase( it ); return true; } return false; } private: //      'm_core.coreMutex' inline TMyEventHandlerIt findEventHandler( const TMyEventHandlerPtr&amp; eventHandler ) const { return std::find_if( m_core.handlers.cbegin(), m_core.handlers.cend(), [ &amp;eventHandler ]( const TMyEventHandlerPtr&amp; oneHandler ) { return ( *oneHandler == *eventHandler ); } ); } EventCore&lt;TParams...&gt; m_core; std::list&lt;TMyHandlerRunner*&gt; m_handlerRunners; };</span></span></code> </pre><br>        (,  ,     )    <i>HandlerRunner</i> ,       . ,     : <i>currentIt</i> (    )  <i>wasRemoving</i> (,        ).   <i>HandlerRunner'</i>          <i>operator()</i> ;        (,  )  ,    <i>EventCore</i> .  T.O.      ,   ,        ,     ,         ,       . <br></div></div><a name="HolderImprovement"></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD3. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بفضل </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">isnullxbh</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، تم العثور على خطأ آخر. </font><font style="vertical-align: inherit;">وهو مرتبط بتخزين غير لائق والوصول اللاحق إلى الكائنات التي تم تمريرها بواسطة </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rvalue</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (بشكل رئيسي تعبيرات لامدا).</font></font><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تصحيح</font></font></b> <div class="spoiler_text" style=";text-align:right;direction:rtl">     ,   <i>lvalue</i> ,  <i>lvalue</i> -,  ,   <i>rvalue</i> ,   (,  ).      : <br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectSaver</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LValue</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectSaver</span></span></span><span class="hljs-class">&lt;LValue&amp;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TObject = LValue&amp;; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RValue</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectSaver</span></span></span><span class="hljs-class">&lt;RValue&amp;&amp;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TObject = RValue; };</code> </pre><br>  <i>Holder</i>           ( <i>lvalue</i>  <i>rvalue</i> ),        ,  «»     .     <i>type erasing</i> (   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="> </a> ).   ,   <i>Holder'</i>   . <br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TBase</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractInnerHolder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~AbstractInnerHolder() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> TBase&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> TBase&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const_cast</span></span>&lt;AbstractInnerHolder&lt;TBase&gt;&amp;&gt;( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ).get(); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TBase</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TInner</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TInnerHolder</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractInnerHolder&lt;TBase&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TInnerObject = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ObjectSaver&lt;TInner&gt;::TObject; TInnerHolder( TInner _inner ) : AbstractInnerHolder&lt;TBase&gt;(), inner( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TInner&gt;( _inner ) ) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> TBase&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;TBase&amp;&gt;( inner ); } TInnerObject inner; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TAssignBase</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgInner</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractInnerHolder</span></span></span><span class="hljs-class">&lt;TAssignBase&gt;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">createInnerHolder</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgInner</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inner</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TAssignInner = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>( inner ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TInnerHolder&lt;TAssignBase, TAssignInner&gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TArgInner&gt;( inner ) ); }</code> </pre><br>      <i>Holder'</i> .    <i>MethodHolder'</i> . <br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TResult</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodHolder</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyType = MethodHolder&lt;TObject, TResult, TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TMethod = TResult( TObject::* )( TParams... ); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ~MethodHolder() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> &amp;m_innerHolder; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &amp;m_innerHolder.get() == &amp;other.m_innerHolder.get() &amp;&amp; m_method == other.m_method ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgObject</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MyType&gt; create( TArgObject&amp;&amp; object, TMethod method ) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MyType&gt; result( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyType( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TArgObject&gt;( object ), method ) ); result-&gt;m_me = result; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgObject</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodHolder</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgObject</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TMethod</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">method</span></span></span><span class="hljs-class"> ) :</span></span> m_innerHolder( createInnerHolder&lt;TObject&gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TArgObject&gt;( object ) ) ), m_method( method ) { assert( m_method != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ); } AbstractInnerHolder&lt;TObject&gt;&amp; m_innerHolder; TMethod m_method; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::weak_ptr&lt;MyType&gt; m_me; . . . };</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TMethodHolder</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IsMethodParamsCompatible</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCheckedMethodHolder</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCheckedParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-function"><span class="hljs-function">true_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">decltype</span></span></span></span><span class="hljs-function"><span class="hljs-params">( ( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;TCheckedMethodHolder&gt;().m_innerHolder.get().*</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;TCheckedMethodHolder&gt;().m_method )( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;TCheckedParams&gt;()... ) )* = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nullptr</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>; . . . }; } <span class="hljs-comment"><span class="hljs-comment">// template&lt;class TMethodHolder, class ...TParams&gt; class MethodEventHandler : public AbstractEventHandler&lt;TParams...&gt; { public: virtual void call( TParams... params ) override { static_assert( IsMethodParamsCompatible&lt;TMethodHolder, TParams...&gt;::value, "Event and method arguments are not compatible" ); ( m_methodHolder-&gt;m_innerHolder.get().*m_methodHolder-&gt;m_method )( params... ); } private: TMethodHolderPtr m_methodHolder; . . . };</span></span></code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TResult</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MethodHolder&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::decay&lt;TObject&gt;::type, TResult, TParams...&gt;&gt; createMethodEventHandler( TObject&amp;&amp; object, TResult( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::decay&lt;TObject&gt;::type::*method )( TParams... ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MethodHolder&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::decay&lt;TObject&gt;::type, TResult, TParams...&gt;::create( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TObject&gt;( object ), method ); }</code> </pre><br>  تم. <i>FunctorHolder</i>   .        .    -    . <br></div></div><br><a name="Qt"></a><h1 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> مقارنة PS مع آلية إشارة / فتحة Qt </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أعتقد أنني لن أكون مخطئا إذا قلت أن </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> هو إطار شائع جدًا للتطوير في </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">من بين أمور أخرى ، لديها أيضًا </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">آلية معالجة الأحداث الخاصة بها</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، حيث توجد إشارات كمناظرات للأحداث وفتحات كمناظرة للمعالجات. </font><font style="vertical-align: inherit;">يتم تنفيذه باستخدام برنامج </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta-Object Compiler</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، وهو جزء من نظام </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta-Object System</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> الأكثر عمومية </font><font style="vertical-align: inherit;">، والذي يتم تنفيذه بدوره باستخدام </font><font style="vertical-align: inherit;">الوظيفة الإضافية </font><font style="vertical-align: inherit;">المستخدمة في </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> عبر </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h4 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ميزات كلا التطبيقين: </font></font></h4><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> القدرة على ربط الإشارات (الأحداث) بالأساليب (وظائف الأعضاء) ، والوظائف المساعدة والوظائف ؛ </font></font></li><li style=";text-align:right;direction:rtl">     ()  (),        ( <i>lvalue</i> , <i>rvalue</i> ); </li><li style=";text-align:right;direction:rtl">      (  ); </li><li style=";text-align:right;direction:rtl">    ()      (   ). </li></ul><br><h4 style=";text-align:right;direction:rtl">  <i>Qt</i> : </h4><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"> <i>   ;</i> <br>  <i>Qt</i>          ;     «»,  ,     « »  ;   ,        ; ,       ; <br></li><li style=";text-align:right;direction:rtl"> <i>    ;</i> <br>   <i>Qt</i>          (    )      (    );        ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Qt::UniqueConnection</a> ;      ,        ,  ,  <i>Qt</i>        ; <br></li><li style=";text-align:right;direction:rtl"> <i>     ,   ;</i> <br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Qt::QueuedConnection</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Qt::BlockingQueuedConnection</a>     ;      ()       ;          ();    ,         ,         ;  أي   ,           ; ,       . <br></li></ul><br><h4 style=";text-align:right;direction:rtl">  <i>Qt</i> : </h4><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"> <i>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">QObject</a> ;</i> <br>    , ,   <i>QObject</i> ,     ,  ,    ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="></a> : <i>Virtual inheritance with QObject is not supported.</i> );    ,   ,  ; <br></li><li style=";text-align:right;direction:rtl"> <i>   template';</i> <br>        ,     <i>public</i> - <i>QObject</i> ;     <i>moc'</i> ; ,    <br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title">,</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QObject&gt; class AbstractProperty : public QObject { Q_OBJECT protected: AbstractProperty(); signals: void valueChanged(); }; template&lt;class TSource&gt; class TProperty : public AbstractProperty { public: TProperty( const TSource&amp; value = TSource() ) : AbstractProperty(), m_value( value ) { } const TSource&amp; value() const { return m_value; } void setValue( const TSource&amp; newValue ) { if( newValue != m_value ) { m_value = newValue; emit valueChanged(); } } private: TSource m_value; };</span></span></span></span></code> </pre><br>  ,  <i>valueChanged</i>    (  ,  )  ,        . <br></div></div> ,   ,     ; <br></li><li style=";text-align:right;direction:rtl"> <strike><i>     .cpp-;</i></strike> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="></a> ; <br></li><li style=";text-align:right;direction:rtl"> <i>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">QMetaObject::Connection</a> ;</i> <br>    ,  <i>Qt</i>   (   )    ,    ;      ()   ,    ,           ;            ,          ;  <i>Qt</i>     ; <br></li><li style=";text-align:right;direction:rtl"> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">استخدام </font><font style="vertical-align: inherit;">التعليمات البرمجية التي تم </font><font style="vertical-align: inherit;">إنشاؤها بشكل إضافي </font><font style="vertical-align: inherit;">بواسطة </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">moc</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ؛ </font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هذا بالفعل موضوعي تمامًا ، ولكن القرار هو ، حيث يوجد لكل فئة تستخدم إشارات وفتحات (لا تكون الفتحات دائمًا) هناك العديد من الملفات (حسب الملف لكل تكوين) التي تسبب بعض الإزعاج ؛ </font><font style="vertical-align: inherit;">ولكن بصراحة ، هذا هو العيب الأصغر.</font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">من المهم أن نلاحظ أن هذه المقارنة مع </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">كيو تي</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> هي مع ذلك ذاتية للغاية ولا تهدف إلى تمجيد أو إدانة هذا الإطار. </font><font style="vertical-align: inherit;">يجب أن نتذكر أنه بالإضافة إلى آلية الإشارة / الفتحة ، </font><font style="vertical-align: inherit;">توفر </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> وظائف رائعة ، سواء باستخدام هذه الآلية ولا تعتمد عليها. </font><font style="vertical-align: inherit;">على أي حال ، الأمر متروك لك دائمًا لتحديد ما يجب استخدامه وما لا تستخدمه.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar424593/">https://habr.com/ru/post/ar424593/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar424583/index.html">لن تصبح بطلاً إذا كنت مطورًا</a></li>
<li><a href="../ar424585/index.html">CryEngine 5.5 صدر عن Crytek</a></li>
<li><a href="../ar424587/index.html">ملخص كتاب "المبيعات للشركات الكبرى"</a></li>
<li><a href="../ar424589/index.html">كيفية التسجيل في برنامج تعلم الآلة لدرجة الدكتوراه</a></li>
<li><a href="../ar424591/index.html">لا يوجد مثال مثالي: كيف بحثت عن لغة برمجة لنفسي</a></li>
<li><a href="../ar424595/index.html">MVC + سيناريو مقابل تحكم الدهون</a></li>
<li><a href="../ar424597/index.html">مقابلة مع رئيس مؤتمر RubyRussia ماركوس شيرب</a></li>
<li><a href="../ar424599/index.html">يجب عليك اختيار البرنامج الذي تحتاجه: مكتوب في الوقت المحدد أو بجودة عالية</a></li>
<li><a href="../ar424601/index.html">هندسة المعلومات على الإنترنت الجزء 1</a></li>
<li><a href="../ar424603/index.html">كتاب "لماذا نحن مخطئون. التفكير في الفخاخ في العمل ". مقتطفات الجزء الأول</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>