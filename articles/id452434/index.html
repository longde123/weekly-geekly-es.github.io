<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘ƒğŸ¾ ğŸ¤´ğŸ» ğŸ² Telegram bahkan lebih rahasia ğŸ‘ƒğŸ» ğŸ¥ âœ‚ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami dulu menganggap Telegram sebagai media transmisi yang andal dan aman untuk pesan apa pun. Tetapi di bawah tenda, itu memiliki kombinasi yang agak...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Telegram bahkan lebih rahasia</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452434/"><p>  Kami dulu menganggap Telegram sebagai media transmisi yang andal dan aman untuk pesan apa pun.  Tetapi di bawah tenda, itu memiliki kombinasi yang agak umum dari enkripsi a- dan simetris.  Di mana kesenangan itu?  Lagi pula, mengapa ada orang yang mempercayai pesan mereka kepada pihak ketiga? <br><img src="https://habrastorage.org/webt/fj/xl/ka/fjxlkasq2yqy1vfjle83rlnc4js.png" alt="Spy vs Spy oleh Antonio ProhÃ­as"><br>  TL; DR - menciptakan saluran rahasia pribadi di atas pengguna yang saling memblokir. </p><a name="habracut"></a><br><h2 id="covert-channels">  Saluran rahasia </h2><br><p>  Ada banyak solusi untuk mengirimkan data antara dua pengguna yang menghindari kontak langsung.  Anda dapat menggunakan perantara, metode kripto dan steganografi, jaringan relai penyiaran, dan ekstensi lain dari protokol yang ada.  Tetapi kadang-kadang berguna untuk membuat kontak aman hanya menggunakan fitur yang didokumentasikan secara resmi.  Atau seperti yang seharusnya dikatakan, atur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saluran rahasia</a> . </p><br><p> Kita dapat melihat contohnya di film mata-mata Soviet "Seventeen Moments of Spring" (yang ini, seperti, sangat bagus, coba tonton).  Di dalamnya, bunga di jendela rumah persembunyian itu digunakan untuk memberi sinyal jika mata-mata itu gagal misinya atau tidak.  Bunga itu sendiri tidak berarti apa-apa: itu bisa ada di sana dan bisa juga tidak, simbiosis semacam itu adalah hal yang umum dan hanya memberi tahu kita tentang cinta pemilik terhadap bunga.  Hanya interpretasi yang telah ditentukan membedakan informasi yang diterima oleh seorang mata-mata dari yang diterima oleh pejalan kaki acak. </p><br><p><img src="https://habrastorage.org/webt/xq/z2/bs/xqz2bs06a68qp9m11r-fpqgy6fo.jpeg" alt="dari film"></p><br><h2 id="in-window-flower-based-channels-in-telegram">  Saluran berbasis In-Window Flower di Telegram </h2><br><p>  Untuk mengatur saluran rahasia Anda sendiri dengan prinsip yang sama, Anda hanya perlu dua hal: jendela dan bunga.  Jendela tersebut merepresentasikan objek yang dapat Anda ubah keadaan dilihat oleh orang lain dan keadaan kemungkinan bunga dan cara mengubahnya. </p><br><p>  Jadi, apa yang bisa diubah Alice di Telegram yang bisa dilihat Bob?  Banyak hal, sebenarnya: avatar, nama pengguna, waktu kunjungan terakhir dan banyak lagi.  Tetapi biasanya, hal-hal ini tersedia untuk semua orang pada saat yang sama, membatasi privasi dialog - jika seseorang memiliki metode transisi, ia dapat membaca apa pun yang dikirimkan Alice.  Yang mengejutkan, adalah mungkin untuk mengatasi batasan ini tanpa melibatkan jenis enkripsi apa pun. </p><br><h3 id="im-blocking-you-haha">  Aku memblokirmu, haha </h3><br><p>  Setiap pengguna memiliki daftar hitamnya sendiri, dan jika pembaca itu cukup menjengkelkan, ia seharusnya memperhatikan setelah diblokir bahwa statusnya yang 'terakhir dikunjungi' belum berubah menjadi 'terakhir dilihat sejak lama'.  Yang benar adalah, dia bisa online beberapa detik yang lalu atau bahkan sekarang, tetapi API Telegram tidak akan mengirim informasi ini ke aplikasi Anda lagi.  Dengan begitu, ia melindungi privasi pengguna lain dari yang tidak diinginkan.  Sebagai gantinya, mereka dapat melihat apakah mereka masuk daftar hitam atau tidak. </p><br><p>  Jadi, apa yang sama dengan bunga dan terhalang?  Keduanya dapat diperiksa pada saat tertentu, memungkinkan untuk menerima sedikit informasi tergantung pada apakah Anda diblokir atau tidak.  Keuntungan lain adalah fakta bahwa Telegram mungkin tidak menyimpan log pengguna yang saling menghalangi (paling banyak untuk jangka waktu pendek dalam tujuan penjurnalan). </p><br><h2 id="organizing-bits">  Pengorganisasian bit </h2><br><p>  Kemungkinan untuk mengirim dan menerima bit itu menyenangkan dan semuanya, tetapi kita masih perlu menjelaskan mekanisme eksploitasinya.  Telegram menolak untuk memperhatikan Anda ketika diblokir, sehingga setiap tindakan 'terima bit' harus diinisialisasi oleh penerima (sebut saja dia Bob) dan tidak bergantung pada pengirim (dan dia akan menjadi Alice), yaitu dengan independen.  Ini juga mengikuti bahwa Alice dan Bob harus melakukan permintaan pada frekuensi yang sama. </p><br><p>  Algoritma pertukaran bit pada setiap jam terlihat seperti ini: </p><br><ul><li>  Cek yang mengirimkan sedikit dan jika berbeda dari nilai sebelumnya mengubahnya tergantung pada nilai: <br><ul><li>  A -&gt; T: blok B jika bit adalah 1; </li><li>  A -&gt; T: buka blokir B jika bit adalah 0. </li></ul></li><li>  B menerima sedikit: <br><ul><li>  B -&gt; T: menyelesaikan A; </li><li>  T -&gt; B: tersedia untuk informasi B tentang A; </li><li>  B: memeriksa apakah informasi yang diterima memiliki status: <br><ul><li>  B: jika -&gt; dia tidak diblokir dan bitnya 0 </li><li>  B: jika tidak -&gt; dia diblokir dan bitnya 1 </li></ul></li></ul></li></ul><br><p>  Sebagian besar PC modern memiliki generator frekuensi yang baik (jam sistem, misalnya) sehingga kami dapat menyinkronkan jam kami dengan mereka tanpa menggunakan saluran untuk mengirimkan apa pun kecuali bit pesan.  Yang patut diperhatikan adalah permintaan API Telegram, baik pemblokiran (tidak) dan penyelesaian status pengguna, adalah panggilan jaringan dan cenderung tidak berfungsi dengan cepat, terutama jika Anda menggunakan proxy atau VPN.  Ini menghasilkan batasan: panjang jam harus lebih lama, daripada waktu respons rata-rata (karena kita perlu menyesuaikan satu dengan yang lain) dan itulah mengapa kecepatan transmisi data kita akan terbatas. </p><br><h3 id="encoding-messages">  Menyandikan pesan </h3><br><p>  Teks dalam bahasa alami memiliki redundansi yang cukup tinggi, dan pesan yang diterima dengan kesalahan sebagian besar masih dapat dibaca oleh manusia.  Dan karena Telegram adalah pembawa pesan (mengabaikan beberapa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hal gila</a> ), kita dapat mengabaikan koreksi kesalahan yang membatasi kemungkinan pengiriman data ke pesan teks sederhana. </p><br><p>  Saluran kami memiliki bandwidth yang sangat rendah, jadi mengapa kami perlu menggunakan pengkodean pesan paling efektif yang tersedia untuk pesan yang mungkin.  Beruntung kami, nama utusan itu mengingatkan tentang kali masalah seperti itu biasa terjadi. </p><br><p>  Itu sebabnya kita, yang hidup di abad ke-21, akan menyandikan teks kita dengan salah satu penyandian paling efisien yang tersedia untuk penyandian seratus tahun yang lalu - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode Baudot</a> .  Lebih tepatnya, variasi terakhir ITA-2 yang dibuat oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Donald Murray</a> untuk melakukan lebih sedikit panggilan API pada simbol bahasa yang paling sering. </p><br><p> Satu-satunya yang tersisa untuk berhasil mengirimkan pesan adalah menemukan batas-batas sesi transmisi sehingga penerima dapat menemukan yang terkirim di antara aliran bit kontinu.  Sebelum transmisi dimulai, Bob diblokir atau tidak, dan kondisinya tidak berubah dengan sendirinya dalam waktu dekat.  Itu sebabnya Alice dapat memberi sinyal tentang awal sesi dengan menukarnya dengan berlawanan hanya untuk satu jam.  Di akhir sesi yang sukses, dia akan membuka blokirnya dan pergi dengan damai.  Dia, di sisi lain, akan terus menerima nol bit sampai memutuskan mereka bukan bagian dari pesan - kode Baudot tidak memiliki simbol <code>00000</code> . </p><br><p><img src="https://habrastorage.org/webt/vx/fa/0q/vxfa0q7-ko6isor152okxwclvto.png" alt="Di timeline"></p><br><p>  Kerugian dari metode ini adalah ketidakmungkinan praktis untuk terhubung (Anda bisa, tetapi kemungkinan akan membutuhkan koreksi kesalahan manual karena pergeseran bit) untuk terjemahan yang sedang berlangsung dan kebutuhan untuk memisahkan simbol nol yang diterima dengan kesalahan dari yang telah dikirim.  Namun ada semua masalah implementasi. </p><br><h2 id="high-tech">  Teknologi tinggi </h2><br><p>  Setelah menghabiskan beberapa jam mencoba menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan resmi</a> untuk menggunakan API, saya lelah dan menulis semuanya dengan Python menggunakan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Telethon yang lebih</a> ramah manusia.  Ia bahkan memiliki API gaya sinkron untuk beberapa alasan aneh yang jarang terjadi saat ini.  Pengkodean pesan dengan ITA-2 yang saya tulis sendiri karena tidak menemukan sesuatu yang berguna di Internet. </p><br><p>  Sinkronisasi jam dibuat dengan jam sistem (dan ya, itu sleep () s! Di antara) karena itu cukup tepat mengingat waktu yang dibutuhkan pada setiap panggilan jaringan API lebih dari sepersepuluh detik dalam kebanyakan kasus.  Pengguna dapat mengatur kecepatan transmisi sesuai keinginannya, tetapi saya sarankan untuk mengikuti aturan 'tidak lebih dari permintaan per detik' jika Anda tidak ingin keduanya melihat kesalahan di sisi lain dan menemukan diri Anda dilarang oleh sistem pencegahan banjir.  Telegram ternyata sangat pilih-pilih tentang penggunaan API, membekukan akses saya selama sehari bahkan dari beberapa upaya otorisasi sederhana (berhasil!) Berturut-turut dan hanya memblokir secara acak untuk banjir selama transmisi untuk alasan yang tidak diketahui.  Anda harus selalu menyatakan batas penggunaan API Anda, kawan. </p><br><p>  Jika pengguna memutuskan untuk menggunakan saluran aneh untuk bertukar pesan, ia tidak perlu peduli dengan fitur antarmuka pengguna grafis.  Dan tidak semua sistem memilikinya, itu sebabnya saya menulis aplikasi saya dalam bentuk alat terminal.  Hal ini memungkinkan untuk mengirim dan menerima pesan melalui saluran dengan id pengguna argumen-baris perintah yang diberikan, tetapi hanya satu operasi per peluncuran.  Tentu saja, tidak ada yang akan membatasi Anda untuk hanya menjalankan satu salinan program sekaligus dan menggunakan beberapa saluran secara bersamaan dalam kedua cara, Anda hanya perlu menjalankan beberapa salinan skrip yang sama dengan parameter yang berbeda. </p><br><h3 id="using-the-stuff">  Menggunakan barang-barang </h3><br><p>  Anda dapat membaca lebih lanjut tentang menggunakan hal ini sebagai utilitas baris perintah dan pustaka python3 melalui API di GitHub (repositori yang ditautkan di akhir).  Satu-satunya masalah adalah untuk memperoleh kredensial API Anda sendiri ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">manual</a> sederhana cukup membantu) karena Telegram tidak mengizinkan untuk mengungkapkan tambang dan mengatur sesuai dengan nilai-nilai dalam salinan skrip lokal Anda.  Semuanya melewati argumen baris perintah kecuali untuk bagian otorisasi yang secara default dibuat melalui stdio) dan terlihat seperti ini: </p><br><pre> <code class="plaintext hljs">For Alice: For Bob: Enter your phone number: XXX | Enter your phone number: XXX Enter auth code: YYY | Enter auth code: YYY Started message transmission... | Listening for the message... ---++ ('O', '9') | ---++ ('O', '9') --+-+ ('H', '#') | --+-+ ('H', '#') +++++ (1, 1) | +++++ (1, 1) --++- ('N', ',') | --++- ('N', ',') --+-- (' ', ' ') | --+-- (' ', ' ') ++-++ (0, 0) | ++-++ (0, 0) --+-+ ('H', '#') | --+-+ ('H', '#') -++-- ('I', '8') | -++-- ('I', '8') --+-- (' ', ' ') | --+-- (' ', ' ') --+++ ('M', '.') | --+++ ('M', '.') ++--- ('A', '-') | ++--- ('A', '-') -+-+- ('R', "'") | -+-+- ('R', "'") ++++- ('K', '(') | ++++- ('K', '(') +++++ (1, 1) | +++++ (1, 1) +-++- ('F', '!') | +-++- ('F', '!') --+++ ('M', '.') | --+++ ('M', '.') --+++ ('M', '.') | --+++ ('M', '.') Done, exiting... | ----- ('', '') | ----- ('', '') | Automatically decoded: OH, HI MARK!..</code> </pre> <br><p>  Pesan yang diterima diterjemahkan secara otomatis, tetapi jika Anda ingin memperbaiki beberapa kesalahan secara manual atau melacak kemajuan dapat melakukannya dengan melihat output baris perintah. </p><br><h2 id="outside-of-the-telegram">  Di luar telegram </h2><br><p>  Patut diperhatikan bahwa saluran tersebut dapat diimplementasikan melalui messenger dan / atau jejaring sosial tempat seseorang dapat mendeteksi apakah diblokir atau tidak oleh pengguna lain.  Antarmuka yang serupa dapat dengan mudah diganti dalam kode yang ada, jadi jika Anda ingin melakukannya, cukup gunakan pekerjaan dasar saya.  Kinerja python yang rendah (dibandingkan dengan yang biasa untuk hal-hal seperti C / ++) tidak akan menjadi faktor pembatas karena kecepatan transmisi yang rendah dan API memanggil waktu respons. </p><br><p>  Terima kasih khusus untuk cinta saya yang menggelora karena menghalangi saya </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Versi Rusia</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cermin sedang</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Github</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id452434/">https://habr.com/ru/post/id452434/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id452424/index.html">Kekurangan Helium dapat memperlambat perkembangan komputer kuantum - mendiskusikan situasi</a></li>
<li><a href="../id452426/index.html">Masuk ke Azure DevOps menggunakan kredensial GitHub</a></li>
<li><a href="../id452428/index.html">Kamus Yandex cepat</a></li>
<li><a href="../id452430/index.html">TA: Hackathons</a></li>
<li><a href="../id452432/index.html">Dari humaniora hingga pengembang dalam jumlah dan warna</a></li>
<li><a href="../id452436/index.html">Belajar Bahasa Inggris: Lima Kesalahan Tertulis yang Tidak Jelas, dan Cara Menghindarinya</a></li>
<li><a href="../id452438/index.html">Sejarah perjuangan melawan sensor: bagaimana metode flash proxy yang dibuat oleh para ilmuwan dari MIT dan Stanford bekerja</a></li>
<li><a href="../id452440/index.html">Kecil, ya hapus: tampilan nyata pada proyek Jepang, Minimal Fab</a></li>
<li><a href="../id452442/index.html">Kami bermain di konsol browser</a></li>
<li><a href="../id452444/index.html">Kesepakatan untuk $ 39 juta: mengapa pencipta DBMS open source memutuskan untuk melakukan pengembangan mobile</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>