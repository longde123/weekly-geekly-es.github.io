<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧔🏻 🖲️ 😠 Doom of SceneKit. Pengalaman Yandex dengan grafik 3D di iOS 🍼 ☃️ 👩🏾‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="- Aku terlalu muda untuk mati. 


 SceneKit adalah kerangka kerja grafik 3D tingkat tinggi di iOS yang membantu membuat adegan dan efek animasi. Ini t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Doom of SceneKit. Pengalaman Yandex dengan grafik 3D di iOS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/431880/"><p>  <i>- Aku terlalu muda untuk mati.</i> </p><br><p>  SceneKit adalah kerangka kerja grafik 3D tingkat tinggi di iOS yang membantu membuat adegan dan efek animasi.  Ini termasuk mesin fisik, generator partikel dan serangkaian tindakan sederhana untuk objek 3D yang memungkinkan Anda untuk menggambarkan adegan dalam hal konten - geometri, bahan, pencahayaan, kamera - dan menganimasinya melalui deskripsi perubahan untuk objek-objek ini. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/de8/eb3/a60/de8eb3a6080bb48be4f407c07d1b122a.gif"></p><br><p> Hari ini kita akan melihat SceneKit dengan tampilan penuh perhatian, sedikit keras, tetapi pertama-tama, mari kita membahas dasar-dasarnya dan melihat seperti apa adegan 3D itu dan apa yang perlu dilakukan untuk membuatnya. <a name="habracut"></a></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1fa/7d7/138/1fa7d71381bc0f217fe6ddff8a08e77f.png" alt="Adegan paling sederhana dari tiga simpul dengan geometri di dalamnya."><br>  <em>Adegan paling sederhana dari tiga node dengan geometri di dalamnya</em> </p><br><p>  Pertama, Anda perlu membuat struktur dasar adegan, yang terdiri dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">node</a> atau node adegan.  Setiap node dapat berisi geometri dan node lainnya.  Geometri bisa sederhana, seperti bola, kubus, atau piramida, atau lebih kompleks, dibuat di editor eksternal. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a9c/dd6/3ae/a9cdd63aeb3c662009d721feff5a2fa2.png" alt="Hamparan bahan"><br>  <em>Bahan overlay</em> </p><br><p>  Kemudian, untuk geometri ini, Anda perlu menentukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bahan</a> yang akan menentukan representasi dasar dari objek.  Setiap bahan itu sendiri mengatur model pencahayaannya sendiri dan, tergantung padanya, menggunakan serangkaian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">properti yang</a> berbeda.  Setiap properti seperti itu biasanya berwarna atau tekstur, tetapi selain opsi yang biasa digunakan ini, ada juga opsi untuk menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CALayer</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AVPlayer</a> , dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SKScene</a> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0c1/ca5/831/0c1ca58318327b07263caf4f9d67ea63.png" alt="Tambahkan sumber pencahayaan"><br>  <em>Tambahkan sumber pencahayaan</em> </p><br><p>  Setelah itu, perlu menambahkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sumber cahaya</a> yang menentukan seberapa baik objek terlihat di satu atau beberapa bagian adegan.  Mereka, dengan analogi dengan geometri, harus berbaring di dalam sebuah simpul.  SceneKit mendukung berbagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jenis pencahayaan</a> , serta beberapa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jenis bayangan</a> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c16/a8e/f8e/c16a8ef8ebcfb7242eef1d8142b70dea.png" alt="Efek Out of the Box Boke"><br>  <em>Efek Out of the Box Boke</em> </p><br><p>  Maka Anda perlu membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kamera</a> (dan meletakkannya di node terpisah) dan mengatur parameter dasar untuk itu.  Ada banyak dari mereka, tetapi dengan bantuan mereka, Anda dapat membuat efek keren.  Didukung di luar kotak, bokeh (atau blur), HDR dengan adaptasi, cahaya, SSAO, dan rona / saturasi didukung. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/76f/62c/908/76f62c908bda6280380c922e3a1e8ca3.gif" alt="Animasi sederhana di SceneKit"><br>  <em>Animasi sederhana di SceneKit</em> </p><br><p>  Akhirnya, SceneKit mencakup serangkaian tindakan sederhana untuk objek 3D yang memungkinkan Anda mengatur perubahan adegan seiring waktu.  SceneKit juga mendukung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tindakan yang dijelaskan dalam JavaScript</a> , tetapi ini adalah topik untuk artikel terpisah. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/08c/0dc/2e4/08c0dc2e44e627e369af7dea6f18d27d.gif" alt="Interaksi generator partikel dengan mesin fisik dapat menyebabkan tornado!"><br>  <em>Interaksi generator partikel dengan mesin fisik dapat menyebabkan tornado!</em> </p><br><p>  Selain grafis, fitur utama SceneKit adalah generator partikel dan mesin fisik canggih yang memungkinkan Anda untuk mengatur properti fisik nyata untuk objek dan partikel biasa dari generator. </p><br><p>  Sejumlah besar tutorial terperinci telah ditulis tentang semua chip ini.  Namun dalam proses pengembangan, kami praktis tidak menggunakan peluang ini ... </p><br><h2 id="hey-not-too-rough">  <strong>Hei, tidak terlalu kasar</strong> </h2><br><blockquote>  <em>Suatu kali saya menulis model pencahayaan untuk game 3D yang lebih baik daripada sinar matahari nyata, memberikan FPS yang dapat diterima pada Nvidia 8800, tetapi saya memutuskan untuk tidak merilis mesinnya, karena Tuhan baik kepada saya dan saya tidak ingin menunjukkan ketidakmampuannya dalam hal ini.</em> <br>  <em>- John Carmack</em> </blockquote><p>  Kami akan memulai studi terperinci dengan tugas yang agak sederhana yang muncul untuk hampir semua orang yang bekerja cukup serius dengan SceneKit: bagaimana cara memuat model dengan geometri kompleks dan bahan yang terhubung, pencahayaan, dan bahkan animasi? </p><br><p>  Ada beberapa cara, dan mereka semua memiliki pro dan kontra: </p><br><ol><li><p>  SCNScene (bernama :) - mendapat heboh dari sebuah bundel, </p><br></li><li><p>  SCNScene (url: options :) - memuat adegan dengan URL, </p><br></li><li><p>  SCNScene (mdlAsset :) - mengonversi adegan dari berbagai format, </p><br></li><li><p>  SCNReferenceNode (url :) - malas memuat adegan. </p><br></li></ol><br><h3 id="poluchaem-scenu-iz-bandla">  Dapatkan adegan dari bundel </h3><br><p>  Anda dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">metode standar</a> : letakkan model kami dalam format dae atau scn di bundel scnasset dan muat dari sana dengan analogi dengan UIImage (bernama :). </p><br><p>  Tetapi bagaimana jika Anda ingin mengontrol sendiri pembaruan model tanpa merilis pembaruan di App Store setiap kali Anda perlu mengubah beberapa tekstur?  Atau misalkan Anda perlu mendukung peta dan model yang dibuat pengguna.  Atau - Anda tidak ingin menambah ukuran aplikasi, karena grafik 3D di dalamnya bukan fungsi utama. </p><br><h3 id="zagruzhaem-scenu-po-url">  Memuat adegan dengan URL </h3><br><p>  Anda dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konstruktor adegan dari URL</a> file scn.  Metode ini mendukung pengunduhan tidak hanya dari sistem file, tetapi juga dari jaringan, tetapi dalam kasus terakhir, Anda dapat melupakan kompresi.  Plus, Anda perlu mengonversi model ke format scn terlebih dahulu.  Anda bisa, tentu saja, menggunakan dae, tetapi dengan itu muncul serangkaian pembatasan.  Misalnya, kurangnya rendering berbasis fisik. </p><br><p>  Keuntungan utama metode ini adalah memungkinkan Anda mengkonfigurasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengaturan impor secara</a> fleksibel.  Anda dapat, misalnya, memodifikasi siklus hidup animasi dan membuatnya berulang tanpa henti.  Anda dapat secara eksplisit menentukan sumber untuk memuat sumber daya eksternal seperti tekstur, Anda dapat mengubah orientasi dan skala adegan, membuat normals yang hilang untuk geometri, menggabungkan seluruh geometri adegan menjadi satu simpul besar atau membuang semua elemen adegan yang tidak sesuai dengan standar format. </p><br><h3 id="konvertiruem-scenu-iz-raznyh-formatov">  Konversi pemandangan dari berbagai format </h3><br><p>  Opsi ketiga adalah menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konstruktor dengan MDLAsset</a> .  Artinya, pertama-tama kita membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">set MDLAs</a> , tersedia dalam kerangka ModelIO, dan kemudian meneruskannya ke konstruktor untuk adegan tersebut. </p><br><p>  Opsi ini bagus karena memungkinkan Anda mengunduh banyak format berbeda.  Secara resmi, MDLAsset dapat memuat format obj, ply, stl, dan usd, tetapi setelah kehabisan daftar semua format yang mungkin, setidaknya terkait dengan grafik komputer, saya menemukan empat lagi: abc, bsp, vox dan md3, tetapi mereka mungkin tidak sepenuhnya didukung atau tidak di semua sistem, dan bagi mereka Anda perlu memeriksa kebenaran impor. </p><br><p>  Penting juga untuk mempertimbangkan bahwa metode ini memiliki overhead untuk konversi, dan menggunakannya dengan sangat hati-hati. </p><br><p>  Metode-metode ini memiliki satu perangkap umum: mereka mengembalikan SCNScene, bukan SCNNode.  Satu-satunya cara untuk menambahkan konten ke adegan yang ada adalah dengan menyalin semua node anak, dan - Anda dapat dengan mudah melewati langkah ini - animasi dari node root (misalnya, mereka dapat muncul di sana ketika bekerja dengan dae).  Selain itu, Anda perlu mempertimbangkan bahwa dalam adegan hanya ada satu lingkungan tekstur (jika Anda tidak menggunakan kustom shaders untuk refleksi). </p><br><h3 id="lenivo-zagruzhaem-scenu">  Lazily memuat adegan </h3><br><p>  Opsi keempat adalah menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SCNReferenceNode</a> .  Ini mengembalikan bukan adegan, tetapi sebuah simpul, yang dengan sendirinya dapat malas (atau atas permintaan) memuat ke dalam dirinya sendiri seluruh hirarki adegan.  Dengan demikian, metode ini mirip dengan yang pertama, tetapi di dalam dirinya menyembunyikan semua masalah dengan penyalinan. </p><br><p>  Dia memiliki satu hal tetapi: parameter global dari adegan itu hilang. </p><br><p>  Ternyata ini adalah cara termudah dan tercepat untuk mengunduh model Anda, tetapi jika Anda memerlukan penyetelan file, metode pertama akan lebih baik. </p><br><p>  Sebagai hasilnya, kami memilih opsi pertama, karena paling nyaman bagi kami untuk bekerja dalam format scn, dan bagi para desainer - untuk mengonversi dari format dae ke format itu.  Selain itu, kami membutuhkan animasi penyetelan file saat boot. </p><br><h3 id="vovse-ne-prezhdevremennye-optimizacii">  Sama sekali tidak optimasi prematur </h3><br><p>  Setelah bermain-main dengan proses ini untuk waktu yang lama, saya dapat memberikan Anda beberapa saran. </p><br><p>  Tip yang paling penting adalah untuk mengkonversi file ke scn terlebih dahulu.  Kemudian Anda bisa, dengan membuka file di editor adegan bawaan di Xcode, melihat bagaimana objek Anda akan terlihat di SceneKit. </p><br><p>  Selain itu, pada kenyataannya, file scn hanyalah representasi biner dari adegan tersebut, jadi memuat darinya akan memakan waktu paling sedikit.  Untuk dae yang sama, Anda harus mengurai xml terlebih dahulu, kemudian mengonversi semua jerat, animasi dan bahan.  Selain itu, konversi animasi dan materi merupakan sumber masalah potensial.  Kami ingat kurangnya dukungan PBR di dae: ternyata jika Anda ingin menggunakannya, Anda harus mengubah jenis semua materi setelah konversi dan secara manual meletakkan tekstur yang sesuai. </p><br><p>  Dengan operasi ini, Anda bisa mendapatkan efek samping yang sangat berguna: kompresi tekstur yang signifikan.  Cukup dengan membukanya di "Lihat" dan ekspor, ubah format menjadi heic.  Rata-rata, operasi sederhana ini menghemat 5 megabyte per model. </p><br><p>  Juga, jika Anda mengunduh adegan dari Internet, saya dapat menyarankan Anda untuk mengunduhnya dalam arsip, membongkar dan mentransfer URL dari file scn yang belum dibongkar.  Ini akan menghemat Anda dan pengguna megabita tambahan - yang, pada gilirannya, akan mempercepat unduhan, dan juga mengurangi jumlah titik kegagalan.  Setuju: membuat permintaan terpisah untuk setiap sumber daya eksternal, dan bahkan di Internet seluler bukanlah cara terbaik untuk meningkatkan keandalan. </p><br><h2 id="hurt-me-plenty">  <strong>Sakit saya banyak</strong> </h2><br><blockquote>  <em>Ketika saya mengendarai mobil, saya sering mendengar hard drive alam semesta berderak, memuat jalan berikutnya.</em> <br>  <em>- John Carmack</em> </blockquote><p>  Jadi, ketika pekerjaan memuat dan mengimpor model dijalankan, tugas baru muncul: menambahkan berbagai efek dan fitur ke tempat kejadian.  Dan percayalah, ada sesuatu untuk diceritakan.  Kita mulai dengan menelusuri berbagai konstanta di SceneKit. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1e3/c0e/ffd/1e3c0effdc9c72b19d6e3d0a19a13796.png" alt="Batasan dalam SceneKit segera dipertimbangkan setelah fisika.  Dan sebelum merender bingkai"><br>  <em>Batasan dalam SceneKit dianggap segera setelah fisika.</em>  <em>Dan sebelum merender bingkai</em> </p><br><p>  Batasan, katamu?  Apa konstanta?  Hanya sedikit orang yang tahu, dan bahkan lebih banyak membicarakannya, tetapi SceneKit memiliki konstanta sendiri.  Dan meskipun mereka tidak sefleksibel konstanta di UIkit, Anda masih bisa melakukan banyak hal menarik dengannya. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/006/c01/3a3/006c013a36d0bc0f615ca4f4378e4767.gif" alt="SCNReplicatorConstraint"><br>  <em>SCNReplicatorConstraint</em> </p><br><p>  Mari kita mulai dengan konstanta sederhana - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SCNReplicatorConstraint</a> .  Semua yang ia lakukan adalah menduplikasi posisi, rotasi, dan ukuran objek lain dengan offset tambahan.  Seperti halnya semua konstanta lain, ia dapat mengubah kekuatan dan mengatur bendera inkrementalitas.  Kedua parameter terbaik dapat ditampilkan pada konstanta ini. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/dd7/98d/a46/dd798da468df11e71ab53c7a41e187c5.gif" alt="Mengurangi Kekuatan 10 Kali"><br>  <em>Mengurangi Kekuatan 10 Kali</em> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kekuatan</a> memengaruhi seberapa banyak transformasi yang diterapkan pada objek.  Dan karena posisi objek target berubah setiap frame - objek bayangan mendekati sepersepuluh dari perbedaan jarak.  Karena itu, efek penundaan muncul. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/535/ec5/0bc/535ec50bce2b4e57f30c71226bc783da.gif" alt="Peningkatan meningkat dan meningkat 10 kali lipat"><br>  <em>Peningkatan meningkat dan kekuatan berkurang 10 kali lipat</em> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Inkrementalitas</a> , pada gilirannya, mempengaruhi apakah konstanta dibatalkan setelah rendering.  Misalkan kita mematikannya.  Kemudian kita melihat bahwa pada setiap frame, konstanta diterapkan sebelum rendering, dan setelah rendering dibatalkan, sehingga setiap frame diulang.  Hasilnya, dengan menggabungkan kedua parameter ini, Anda bisa mendapatkan efek jarum jam yang agak menarik. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/74d/5c5/cfd/74d5c5cfd7bde6252adf7855705ec5ad.gif" alt="Pesawat selalu menghadap kamera."><br>  <em>Pesawat selalu menghadap kamera.</em> </p><br><p>  Mari kita beralih ke konstanta yang lebih menarik: papan reklame. </p><br><p>  Misalkan, perlu bahwa beberapa objek selalu "menghadap" kita.  Untuk melakukan ini, cukup gunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SCNBillboardConstraint</a> , tunjukkan sumbu mana yang dapat diputar objek.  Selanjutnya, sebelum menghitung setiap frame (setelah langkah dengan fisika), posisi dan orientasi semua objek akan diperbarui untuk memenuhi semua konstanta. </p><br><p>  Di sini Anda dapat menyebutkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lihat At Constraint</a> : ini mirip dengan papan reklame, hanya objek yang dapat diatur menghadap objek lain dalam adegan, bukan kamera saat ini. </p><br><p>  Apa yang bisa dilakukan dengan bantuan mereka?  Tentu saja, paling sering konstanta ini digunakan untuk menggambar pohon atau benda kecil.  Mereka juga menciptakan efek khusus seperti api atau ledakan.  Selain itu, dengan bantuan mereka, Anda dapat membuat kamera mengikuti objek di atas panggung. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/077/6ed/96d/0776ed96d0d6116c12ababd108bfe180.gif" alt="Menjaga jarak antar objek"><br>  <em>Menjaga jarak antar objek</em> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SCNDistanceConstraint</a> memungkinkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Anda</a> untuk mengatur jarak minimum dan / atau maksimum ke posisi objek lain.  Dan ya, Anda bisa menggunakannya untuk membuat ular.  :) Batasan ini juga dapat digunakan untuk mengikat kamera ke karakter, meskipun posisi kamera biasanya lebih rumit, dan menggambarkannya dengan constrates saja bukanlah tugas yang mudah.  Efek yang sama dapat dicapai dengan menambahkan pegas di mesin fisik, tetapi pegas ini dapat ditambah dengan ketegangan jika Anda perlu menghindari masalah dengan peregangan yang berlebihan atau kompresi pegas. </p><br><p>  Banyak yang telah melihat di Hitman, Fallout atau Skyrim: Anda menyeret tubuh dengan Anda, menyentuh rintangan - dan mulai berperilaku seolah-olah iblis telah memasukinya.  Konstanta ini akan membantu menghindari bug semacam itu. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f8f/578/aca/f8f578aca5e9d78034dcef18062349b8.gif" alt="SCNSliderConstraint"><br>  <em>SCNSliderConstraint</em> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SCNSliderConstraint</a> memungkinkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Anda</a> untuk mengatur jarak minimum antara objek yang diberikan dan tubuh fisik dengan topeng tabrakan yang sesuai.  Konstanta cukup lucu, tetapi sekali lagi, mereka mencoba mensimulasikannya menggunakan interaksi fisik.  Gagasan utamanya adalah mengatur jari-jari zona mati dengan tubuh fisik untuk objek yang tidak memiliki tubuh fisik. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/357/930/7df/3579307dfcf69c026734b0c35d7c6f04.gif" alt="Kinematika terbalik sedang bekerja"><br>  <em>Kinematika terbalik sedang bekerja</em> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SCNIKConstraint</a> adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konstanta</a> yang paling menarik, tetapi juga yang paling kompleks, yang menggunakan apa yang disebut kinematika terbalik.  Menggunakan rantai node induk, kinematika terbalik secara berulang mencoba membawa posisi simpul yang Anda terapkan konstan ini ke titik yang diperlukan.  Bahkan, ini memungkinkan Anda untuk tidak berpikir dalam posisi apa bahu dan lengan seharusnya, tetapi hanya untuk mengatur posisi tangan dan kemungkinan sudut rotasi dari simpul penghubung.  Sisanya akan dihitung untuk Anda.  Kelemahan utama dari batasan ini adalah memungkinkan Anda untuk hanya mengatur posisi tangan, tetapi bukan orientasinya, dan batasan sudut dapat dibuat mendunia, tanpa menghancurkan sumbu. </p><br><p>  Jadi, kami bertemu secara detail dengan konstanta dan dengan apa yang mereka tahu bagaimana melakukannya.  Mari kita lanjutkan mengeksplorasi efek yang menarik.  Kami akan berurusan dengan efek bayangan. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5d9/d62/4a4/5d9d624a480d96c5654a8df80be14115.gif" alt="Ada pesawat, tetapi tidak"><br>  <em>Ada pesawat, tetapi tidak</em> </p><br><p>  Tampaknya akan lebih mudah di mesin yang mendukung bayangan daripada membuat bayangan?  Namun terkadang bayangan harus dilemparkan ke bidang yang benar-benar transparan.  Ini sangat berguna di ARKit, karena gambar kamera ditampilkan di belakang pesawat, dan bayangan harus dilemparkan ke suatu tempat.  Triknya ternyata cukup sederhana: pertama Anda harus mengaktifkan bayangan yang ditangguhkan dan mematikan perekaman di semua komponen pesawat pada tab material, dan bayangan akan terus menumpuknya.  Satu-satunya masalah adalah bahwa pesawat ini akan tumpang tindih dengan objek di belakangnya. </p><br><p>  Tapi bayangan bukan satu-satunya efek yang dipelajari dengan buruk di SceneKit.  Mari kita berurusan dengan cermin sekarang. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/32d/75b/1ba/32d75b1ba50036e814d21bacb0104523.png" alt="Cermin SCNFloor - apa yang bisa lebih sederhana"><br>  <em>Cermin SCNFloor - apa yang bisa lebih sederhana</em> </p><br><p>  Setiap orang yang bermain dengan SceneKit mungkin tahu tentang scnfloor, yang menambahkan pantulan cermin ke lantai.  Tetapi untuk beberapa alasan, sangat sedikit yang menggunakannya untuk refleksi cermin yang jujur, karena Anda dapat menempatkan model Anda pada geometri lantai, memiringkannya sedikit dan mengubahnya ... menjadi cermin biasa. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1c4/bdf/289/1c4bdf289fd13dd45489765512bc2d2a.png"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fdd/950/d98/fdd950d9889d35a4d8e66b871c0c2767.png" alt="Teteskan pada kaca dan cermin melengkung"><br>  <em>Teteskan pada kaca dan cermin melengkung</em> </p><br><p>  Tapi, apa yang bahkan kurang diketahui, peta normal dapat diatur untuk jenis kelamin ini.  Karena itu, pada gilirannya, Anda dapat membuat banyak efek menarik yang berbeda, seperti efek goresan atau cermin melengkung. </p><br><h2 id="ultra-violence">  <strong>Sangat ungu</strong> </h2><br><blockquote>  <em>Suatu kali saya mencium seorang gadis dengan mata terbuka.</em>  <em>Gadis itu memotong wajahnya dengan bidang guntingan dekat.</em>  <em>Sejak itu saya hanya mencium dengan mata tertutup.</em> <br>  <em>- John Carmack</em> </blockquote><p>  Bayangan, cermin - efek menarik.  Tetapi ada satu efek yang, ketika digunakan dengan terampil, bisa berubah menjadi lebih menarik - tekstur video. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/998/047/b54/998047b5496741e28e66d6faeb04f4a1.gif"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8b7/91c/a6b/8b791ca6b8f464f5bd7401bdc07225ac.gif" alt="Video biasa dan tinggi peta"><br>  <em>Video biasa dan tinggi peta</em> </p><br><p>  Anda mungkin membutuhkannya hanya untuk menampilkan video di dalam gim.  Tetapi jauh lebih menarik bahwa dengan bantuan tekstur video Anda dapat memodifikasi geometri.  Untuk melakukan ini, Anda perlu menempatkan tekstur video dengan peta ketinggian di properti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpindahan</a> material Anda dan menggunakan material di pesawat dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jumlah segmen yang</a> cukup besar.  Masih memahami bagaimana menaruhnya di sana. </p><br><p>  Saya sebutkan dalam deskripsi proses pembuatan adegan yang dapat Anda gunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SKScene</a> sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">properti</a> material, dan ini adalah adegan SpriteKit.  SpriteKit seperti SceneKit, tetapi untuk grafis 2D.  Ini memiliki dukungan untuk menampilkan video menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SKVideoNode</a> .  Anda hanya perlu memasukkan SKVideoNode di SKScene, dan SKScene di SCNMaterialProperty, dan Anda selesai. </p><br><p>  Tapi setelah mengekspor adegan 3D yang dihasilkan dan membukanya di tempat lain, kita akan melihat kotak hitam.  Mengaduk-aduk file scn, saya menemukan alasannya.  Ternyata saat menyimpan kode video, itu tidak menyimpan URL video.  Tampaknya Anda mengambil dan memerintah.  Tapi tidak semuanya begitu sederhana: file scn adalah yang disebut binary plist, yang berisi hasil NSKeyedArchiver.  Dan materi, yang merupakan adegan SpriteKit, adalah plist biner yang sama, yang, ternyata, sudah ada di dalam plist biner lain!  Bagus bahwa hanya ada dua tingkat sarang. </p><br><p>  Nah, sekarang kita bahkan akan beralih ke efek, tetapi ke alat yang memungkinkan Anda untuk membuat segala jenis efek.  Ini adalah pengubah shader. </p><br><p>  Sebelum Anda memodifikasi sesuatu, Anda perlu memahami apa yang kami modifikasi.  Shader, menurut definisi, adalah program untuk GPU yang berjalan untuk setiap titik dan untuk setiap piksel.  Jadi, shader adalah program yang menentukan bagaimana suatu objek terlihat di layar. </p><br><p>  Nah, pengubah shader memungkinkan Anda untuk mengubah hasil shader standar menjadi GLSL atau Bahasa Shading Metal.  Mereka juga tersedia di editor visual, yang memungkinkan Anda untuk melihat perubahan dalam pengubah secara real time. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/663/9d1/9a7/6639d19a72901a50caea2b969816a1ae.png"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1d1/94a/660/1d194a660488fe33aa392c0573834ca4.png" alt="Pemetaan bulu dan paralaks"><br>  <em>Pemetaan Bulu dan Paralaks</em> </p><br><p>  Dengan bantuan pengubah shader, Anda dapat membuat efek visual yang kompleks.  Misalnya, beberapa efek paling terkenal: Fur dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Parallax Mapping</a> . </p><br><pre><code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#pragma arguments texture2d bg; texture2d height; float depth; float layers; #pragma transparent #pragma body constexpr sampler sm = sampler(filter::linear, s_address::repeat, t_address::repeat); float3 bitangent = cross(_surface.tangent, _surface.normal); float2 direction = float2(-dot(_surface.view.rgb, _surface.tangent), dot(_surface.view.rgb, _surface.bitangent)); _output.color.rgba = float4(0); for(int i = 0; i </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; int(floor(layers)); i++) { float coeff = float(i) / floor(layers); float2 defaultCoords = _surface.diffuseTexcoord + direction * (1 - coeff) * depth; float2 adjustment = float2(scn_frame.sinTime + defaultCoords.x, scn_frame.cosTime) * depth * coeff * 0.1; float2 coords = defaultCoords + adjustment; _output.color.rgb += bg.sample(sm, coords).rgb * coeff * (height.sample(sm, coords).r + 0.1) * (1.0 - coeff); _output.color.a += (height.sample(sm, coords).r + 0.1) * (1.0 - coeff); } return _output;</span></span></span></span></code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/7aa/b5f/b0e/7aab5fb0e907d2a7290f0f31e415e4be.gif" alt="Ray Casting dengan kaustik real-time."><br>  <em>Ray Casting dengan Real-Time Caustics</em> </p><br><p>  Lebih menarik lagi, tidak ada yang mengganggu untuk sepenuhnya membuang hasil pekerjaan mereka dan menulis renderer mereka sendiri.  Misalnya, Anda dapat mencoba mengimplementasikan Ray Casting di shader.  Dan semua ini bekerja cukup cepat untuk memberikan 30 FPS bahkan pada perhitungan yang rumit.  Tetapi ini adalah topik untuk laporan terpisah.  Ayo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mobius</a> ! </p><br><h2 id="nightmare">  <strong>Mimpi buruk!</strong> </h2><br><blockquote>  <em>Saya tidak suka berkedip, karena kelopak mata tertutup dengan tajam memuat GPU untuk BDPT karena kurangnya pencahayaan.</em> <br>  <em>- John Carmack</em> </blockquote><p>  Jadi, kami memiliki banyak objek dengan efek keren.  Sekarang tinggal belajar bagaimana merekamnya.  Untuk melakukan ini, mari kita beralih ke topik yang lebih kompleks: bagaimana kita belajar cara merekam video langsung dari SceneKit tanpa UI eksternal dan bagaimana kita mengoptimalkan rekaman ini puluhan kali. </p><br><p>  Mari kita beralih ke solusi paling sederhana: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ReplayKit</a> .  Cari tahu mengapa itu tidak cocok.  Secara umum, solusi ini memungkinkan Anda untuk membuat entri layar dalam beberapa baris kode dan menyimpannya melalui pratinjau sistem.  Tapi  Ini memiliki minus besar - ia merekam semuanya, seluruh UI, termasuk semua tombol di layar.  Ini adalah keputusan pertama kami, tetapi karena alasan yang jelas tidak mungkin untuk membuatnya menjadi produksi: pengguna harus membagikan video, dan membagikannya bukan dari pratinjau sistem. </p><br><p>  Kami menemukan diri kami dalam situasi di mana solusi perlu ditulis dari awal.  Sepenuhnya dari awal.  Jadi, mari kita lihat bagaimana di iOS Anda dapat membuat video Anda sendiri dan merekam frame Anda di sana.  Semuanya cukup sederhana: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/bd5/ce3/0f8/bd5ce30f8b449cba0a5fbe8d68d2a420.png" alt="Proses perekaman"><br>  <em>Proses perekaman</em> </p><br><p>  Kita perlu membuat entitas yang akan merekam file - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AVAssetWriter</a> , tambahkan stream video - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AVAssetWriterInput</a> , dan buat adaptor untuk stream ini yang akan mengubah buffer piksel kami ke dalam format yang diperlukan oleh stream - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AVAssetWriterPixelBufferAdaptor</a> . </p><br><p>  Untuk jaga-jaga, saya mengingatkan Anda bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyangga piksel</a> adalah suatu entitas, yang merupakan bagian dari memori di mana data untuk piksel entah bagaimana ditulis.  Ini pada dasarnya adalah representasi gambar tingkat rendah. </p><br><p>  Tapi bagaimana cara mendapatkan buffer pixel ini?  Solusinya sederhana.  SCNView memiliki fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">.snapshot ()</a> yang bagus yang mengembalikan UIImage.  Kami hanya perlu membuat penyangga piksel dari UIImage ini. </p><br><pre> <code class="objectivec hljs">var unsafePixelBuffer: CVPixelBuffer? CVPixelBufferPoolCreatePixelBuffer(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.pixelBufferPool, &amp;unsafePixelBuffer) guard let pixelBuffer = maybePixelBuffer <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } CVPixelBufferLockBaseAddress(pixelBuffer, <span class="hljs-number"><span class="hljs-number">0</span></span>) let data = CVPixelBufferGetBaseAddress(pixelBuffer) let rgbColorSpace = <span class="hljs-built_in"><span class="hljs-built_in">CGColorSpaceCreateDeviceRGB</span></span>() let bitmapInfo = <span class="hljs-built_in"><span class="hljs-built_in">CGBitmapInfo</span></span>(rawValue: <span class="hljs-built_in"><span class="hljs-built_in">CGBitmapInfo</span></span>.byteOrder32Little.rawValue | <span class="hljs-built_in"><span class="hljs-built_in">CGImageAlphaInfo</span></span>.premultipliedFirst.rawValue) let rowBytes = <span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>(CVPixelBufferGetBytesPerRow(pixelBuffer)) let context = <span class="hljs-built_in"><span class="hljs-built_in">CGContext</span></span>( data: data, width: image.width, height: image.height, bitsPerComponent: <span class="hljs-number"><span class="hljs-number">8</span></span>, bytesPerRow: CVPixelBufferGetBytesPerRow(pixelBuffer), space: rgbColorSpace, bitmapInfo: bitmapInfo.rawValue ) context?.draw(image, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span>(x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span>, width: image.width, height: image.height)) CVPixelBufferUnlockBaseAddress(pixelBuffer, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.appendPixelBuffer(pixelBuffer, withPresentationTime: presentationTime)</code> </pre> <br><p>  Kami hanya mengalokasikan tempat di memori, menjelaskan format apa yang dimiliki piksel ini, memblokir buffer untuk mengubah, mendapatkan alamat memori, membuat konteks di alamat yang diterima, di mana kami menggambarkan bagaimana piksel dikemas, berapa banyak garis dalam gambar dan ruang warna apa yang kami gunakan.  Kemudian kami menyalin piksel dari UIImage di sana, mengetahui format final, dan membuka kunci perubahan. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ba0/e25/5a0/ba0e255a03515ee7e299bfa3d2757526.png"></p><br><p>  Sekarang Anda perlu melakukan ini setiap frame.  Untuk melakukan ini, kami membuat tautan tampilan yang akan memanggil panggilan balik untuk setiap frame, di mana kami, pada gilirannya, akan memanggil metode snapshot dan membuat buffer piksel dari gambar.  Semuanya sederhana! </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ab9/6fa/841/ab96fa8410458c0854d2c6b74bfb488c.gif"></p><br><p>  Tapi tidak.  Solusi semacam itu, bahkan pada telepon yang kuat, menyebabkan kelambatan yang mengerikan dan penarikan FPS.  Ayo lakukan optimasi. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b13/562/6e6/b135626e6d19559cb931b0d62e20e0d3.png"></p><br><p>  Katakanlah kita tidak membutuhkan 60 FPS.  Kami bahkan akan senang dengan tanggal 25.  Tetapi apa cara termudah untuk mencapai hasil ini?  Tentu saja, Anda hanya perlu meletakkan semua ini di utas latar belakang.  Apalagi menurut pengembang, fungsi ini aman untuk thread. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/701/d7c/a26/701d7ca267899b726966bcefacd2921e.gif"></p><br><p>  Hmm, lag sudah kurang, tapi videonya sudah berhenti merekam ... </p><br><p>  Semuanya sederhana.  Seperti yang mereka katakan, jika Anda memiliki masalah, dan Anda akan menyelesaikannya dengan bantuan beberapa utas, Anda akan memiliki 2 masalah. </p><br><p>  Jika Anda mencoba merekam penyangga piksel dengan stempel waktu lebih rendah dari yang direkam terakhir, maka seluruh video akan tidak valid. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/643/ed3/f61/643ed3f61dd84093f38c4447952d2a8b.png"></p><br><p>  Maka jangan tulis buffer baru sampai tulisan sebelumnya berakhir. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/335/c9f/544/335c9f544b1bfd080a34cfe03847235a.gif"></p><br><p>  Hmm, ini jauh lebih baik.  Tapi semua sama, mengapa kelambatan muncul awalnya? </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ef1/b9d/838/ef1b9d8381334a5b0d6c9c4952eea020.png"></p><br><p>  Ternyata fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">.snapshot ()</a> , yang dengannya kita mendapatkan gambar dari layar, membuat penyaji baru untuk setiap panggilan, menggambar bingkai dari awal dan mengembalikannya, bukan gambar yang ada di layar.  Ini mengarah pada efek yang menyenangkan.  Misalnya, simulasi fisik dua kali lebih cepat. </p><br><p>  Tapi tunggu - mengapa kita mencoba membuat bingkai baru setiap saat?  Tentunya di suatu tempat Anda dapat menemukan buffer yang ditampilkan di layar.  Memang, ada akses ke buffer seperti itu, tetapi sangat tidak trivial.  Kita perlu mendapatkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CAMetalDrawable</a> dari Metal. </p><br><p>  Sayangnya, mendapatkan ke Logam langsung dari SCNView tidak begitu mudah untuk alasan yang cukup dapat dimengerti - di SceneKit Anda dapat memilih jenis API sendiri, tetapi jika Anda melihat di bawah tenda dan melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lapisannya</a> , Anda dapat melihat bahwa itu bertindak seperti itu, dalam kasus Metal, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CAMetalLayer</a> . </p><br><p>  Tapi di sini juga, kegagalan menunggu kita: di CAMetalLayer, satu-satunya cara untuk berinteraksi dengan tampilan adalah fungsi nextDrawable, yang mengembalikan CAMetalDrawable yang tidak digunakan.  Dipahami bahwa Anda akan menulis data ke dalamnya dan memanggil fungsi sekarang di atasnya, yang akan menampilkannya di layar. </p><br><p>  Solusinya sebenarnya ada.  Faktanya adalah bahwa setelah menghilang dari layar, penyangga tidak dialokasikan, tetapi hanya ditempatkan kembali ke kolam.  Memang, mengapa mengalokasikan memori setiap kali jika dua atau tiga buffer sudah cukup: satu ditampilkan di layar, yang kedua untuk rendering dan yang ketiga, misalnya, untuk postprocessing, jika Anda memilikinya. </p><br><p>  Ternyata setelah menampilkan buffer, data darinya tidak hilang di mana pun dan Anda dapat mengaksesnya dengan aman dan aman. </p><br><p>  Dan jika kita sebagai penerus mulai merespons setiap panggilan ke nextDrawable () untuk menyimpannya, kita mendapatkan hampir apa yang kita butuhkan.  Masalahnya adalah bahwa CAMetalDrawable yang disimpan adalah di mana gambar sedang diambil sekarang. </p><br><p>  Lompatan ke solusi nyata sangat sederhana - kami menyimpan Drawable saat ini dan yang sebelumnya. </p><br><p>  Dan ini dia, akses langsung ke memori melalui CAMetalDrawable. </p><br><pre> <code class="objectivec hljs">var unsafePixelBuffer: CVPixelBuffer? CVPixelBufferPoolCreatePixelBuffer(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.pixelBufferPool, &amp;unsafePixelBuffer) guard let pixelBuffer = maybePixelBuffer <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } CVPixelBufferLockBaseAddress(pixelBuffer, <span class="hljs-number"><span class="hljs-number">0</span></span>) let data = CVPixelBufferGetBaseAddress(pixelBuffer) let width: <span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span> = lastDrawable.texture.width let height: <span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span> = lastDrawable.texture.height let rowBytes: <span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>(CVPixelBufferGetBytesPerRow(pixelBuffer) lastDrawable.texture.getBytes( data, bytesPerRow: rowBytes, fromRegion: <span class="hljs-built_in"><span class="hljs-built_in">MTLRegionMake2D</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, width, height), mipmapLevel: <span class="hljs-number"><span class="hljs-number">0</span></span> ) CVPixelBufferUnlockBaseAddress(pixelBuffer, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.appendPixelBuffer(pixelBuffer, withPresentationTime: presentationTime)</code> </pre> <br><p>  Jadi, sekarang kita tidak membuat konteks dan menggambar UIImage di dalamnya, tetapi menyalin satu keping memori ke yang lain.  Muncul pertanyaan: bagaimana dengan format pixel? .. </p><br><p>  Itu tidak cocok dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">deviceColorSpace</a> ... Dan itu tidak cocok dengan ruang warna yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">umum digunakan</a> ... </p><br><p>  Inilah titik di mana penulis dari salah satu perapian umum, yang melakukan tugas yang sama, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mogok</a> .  Semua orang bahkan tidak sampai di sini. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/198/181/bc7/198181bc7d908bca2ec56df495010106.gif"></p><br><p>  Nah, semua trik ini - demi filter yang menyeramkan? </p><br><p>  Ya tidak!  Dalam artikel tentang ARKit, Anda dapat menemukan penyebutan bahwa gambar dari kamera tidak menggunakan ruang warna standar, tetapi diperluas.  Dan bahkan matriks transformasi ruang warna disajikan.  Tetapi mengapa terlibat dalam transformasi, jika Anda dapat mencoba merekam langsung dalam format ini?  Masih mencari tahu format apa dari 60 yang tersedia ... </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/75d/802/781/75d8027810eb481eaa1775bd122cb79a.gif"></p><br><p>  Dan kemudian saya mulai bangkrut.  Saya merekam tiga video dalam aliran yang berbeda dengan format yang berbeda, menggantikannya dengan setiap rekaman. </p><br><p>  Sebagai hasilnya, dalam tentang format keempat puluh, kita mendapatkan namanya.  Ternyata itu tidak lain adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kCVPixelFormatType_30RGBLEPackedWideGamut</a> .  Bagaimana saya tidak menebak? </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d6e/2e6/31e/d6e2e631e3dfdc690c85222a51561446.gif"></p><br><p>  Tapi kegembiraan saya bertahan sampai penguji pertama.  Saya tidak punya kata-kata.  Bagaimana?  Saya hanya menghabiskan banyak waktu mencari format yang tepat.  Ada baiknya masalah dilokalisasi dengan cepat - bug bereproduksi secara stabil dan hanya pada 6s dan 6s Plus.  Hampir segera setelah itu, saya ingat bahwa tampilan dengan dukungan gamut luas mulai dipasang hanya di iPhone ketujuh. </p><br><p>  Mengubah gamut lebar menjadi 32RGBA lama yang baik, saya mendapatkan catatan kerja!  Masih memahami bagaimana menentukan bahwa perangkat mendukung wide-gamut.  Ada iPad dengan berbagai jenis tampilan, dan saya pikir pasti Anda bisa mendapatkan jenis tampilan ENUM dari sistem.  Mengaduk-aduk dokumentasi, saya menemukannya - ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">displayGamut</a> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">UITraitCollection</a> . </p><br><p>  Setelah memberikan perakitan kepada penguji, saya menerima berita menyenangkan dari mereka - semuanya bekerja tanpa penundaan, bahkan pada perangkat lama! </p><br><p>  Kesimpulannya, saya ingin memberi tahu Anda - lakukan 3D-grafis!  Dalam aplikasi kami, yang augmented reality bukan kasus penggunaan utama, selama akhir pekan, orang-orang bepergian lebih dari 2.000 kilometer, menonton lebih dari 3.000 objek dan merekam lebih dari 1.000 video dengan mereka!  Bayangkan apa yang dapat Anda lakukan jika Anda melakukannya sendiri. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id431880/">https://habr.com/ru/post/id431880/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id431870/index.html">Pengembang buku interaktif dengan LED mengeluh tentang pencurian ide oleh karyawan Google</a></li>
<li><a href="../id431872/index.html">Panduan JavaScript Bagian 9: Tinjauan Umum tentang Standar ES7, ES8, dan ES9</a></li>
<li><a href="../id431874/index.html">Imba: Bahasa yang kompatibel dengan JavaScript untuk kerja cepat dengan DOM</a></li>
<li><a href="../id431876/index.html">Optimalisasi aplikasi Angular</a></li>
<li><a href="../id431878/index.html">Fitur JavaScript yang kurang dikenal</a></li>
<li><a href="../id431884/index.html">Microsoft melampaui Apple dalam kapitalisasi pasar: bagaimana ini terjadi?</a></li>
<li><a href="../id431886/index.html">Al Lowy mengunggah koleksi kode sumbernya untuk produk Sierra di eBay</a></li>
<li><a href="../id431888/index.html">“Saya pikir ide tim adalah yang paling penting ketika mengembangkan suatu produk.”</a></li>
<li><a href="../id431890/index.html">Cara melakukan pemesanan di bursa lepas</a></li>
<li><a href="../id431892/index.html">Kami menggunakan Veeam Backup & Replication untuk menguji sistem dan aplikasi baru sebelum memutakhirkan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>