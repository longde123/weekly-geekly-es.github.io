<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â“‚ï¸ ğŸ§šğŸ¿ ğŸ¹ Bagaimana Flutter Bekerja ğŸ¤ğŸ» â› â</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagaimana cara Flutter bekerja? 


 Apa itu Widget, Elemen, BuildContext, RenderOject, Bindings? .. 


 Kesulitan: Pemula 
 Entri 


 Tahun lalu ( cat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana Flutter Bekerja</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476018/"><p><img src="https://habrastorage.org/webt/xo/f8/wq/xof8wqtuioee7o5ztrhyyb7hriq.png"></p><br><p>  Bagaimana cara Flutter bekerja? </p><br><p>  Apa itu Widget, Elemen, BuildContext, RenderOject, Bindings? .. </p><br><p>  Kesulitan: <em>Pemula</em> </p><br><h1 id="vstuplenie">  Entri </h1><br><p>  Tahun lalu ( <em>catatan: pada tahun 2018</em> ), ketika saya memulai perjalanan saya ke dunia Flutter yang luar biasa, hanya ada sedikit informasi di Internet dibandingkan dengan sekarang.  Sekarang, terlepas dari kenyataan bahwa banyak materi telah ditulis, hanya sebagian kecil dari mereka yang berbicara tentang cara Flutter bekerja. </p><br><p>  Apa itu Widget ( <em>widget</em> ), Elemen ( <em>elemen</em> ), BuildContext?  Mengapa Flutter cepat?  Mengapa terkadang tidak bekerja seperti yang diharapkan?  Apa itu pohon dan mengapa mereka dibutuhkan? </p><br><p>  Dalam 95% kasus saat menulis aplikasi, Anda hanya akan berurusan dengan widget untuk menampilkan sesuatu atau berinteraksi dengannya.  Tetapi pernahkah Anda benar-benar bertanya-tanya bagaimana semua sihir ini bekerja di dalam?  Bagaimana sistem tahu kapan harus menyegarkan layar dan bagian mana yang harus diperbarui? </p><br><p>  <strong>Konten:</strong> </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Entri</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1: Latar Belakang</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sedikit tentang perangkat</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Antarmuka antara kode dan perangkat</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kelola Kerangka Kerja Flutter rendering Engine</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RenderView dan RenderObject</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Binding inisialisasi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penjadwal Penjilid</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengikat gerakan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengikat penyaji</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penjilidan widget</a> <a name="habracut"></a></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2. Dari widget ke piksel</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Konfigurasi Abadi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Struktur hierarkis widget</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hutan di belakang pohon</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memahami Elemen dalam Pohon</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3 kategori widget</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jenis Barang</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana widget dan elemen bekerja bersama</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">onDrawFrame ()</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3: Menangani Gerakan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 4: Animasi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gambar penuh</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Buildcontext</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Seberapa bermanfaat BuildContext?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Untuk bersenang-senang</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kesimpulan</a> </li></ul><br><h1 id="chast-1-predystoriya">  Bagian 1: Latar Belakang </h1><br><p>  Bagian pertama dari artikel ini menyajikan beberapa konsep utama yang akan digunakan pada bagian kedua dari materi dan membantu untuk lebih memahami Flutter. </p><br><h2 id="nemnogo-ob-ustroystve">  Sedikit tentang perangkat </h2><br><p>  Mari kita mulai dari akhir dan kembali ke dasar. </p><br><p>  Saat Anda melihat perangkat Anda atau, lebih tepatnya, pada aplikasi yang berjalan di perangkat Anda, Anda hanya melihat layar. </p><br><p>  Faktanya, yang Anda lihat hanyalah piksel, yang bersama-sama membentuk gambar 2 dimensi, dan ketika Anda menyentuh layar dengan jari Anda, perangkat hanya mengenali posisi jari Anda di atas kaca. </p><br><p>  Semua keajaiban aplikasi (dari sudut pandang visual) dalam banyak kasus adalah memperbarui gambar ini berdasarkan interaksi berikut: </p><br><ul><li>  dengan layar perangkat ( <em>misalnya, jari di atas kaca</em> ) </li><li>  dengan jaringan ( <em>misalnya, komunikasi dengan server</em> ) </li><li>  seiring waktu ( <em>mis. animasi</em> ) </li><li>  dengan sensor eksternal lainnya </li></ul><br><p>  Visualisasi gambar pada layar disediakan oleh perangkat keras (layar), yang secara teratur (biasanya 60 kali per detik) memperbarui tampilan.  Ini disebut "refresh rate" dan dinyatakan dalam Hz (Hertz). </p><br><p>  Layar menerima informasi untuk ditampilkan dari GPU (Graphics Processing Unit), yang merupakan sirkuit elektronik khusus yang dioptimalkan dan dirancang untuk dengan cepat membentuk gambar dari beberapa data (poligon dan tekstur).  Jumlah kali per detik yang prosesor grafis dapat menghasilkan "gambar" (= frame buffer) untuk ditampilkan dan mengirimkannya ke perangkat keras disebut frame rate ( <em>catatan: frame rate</em> ).  Ini diukur menggunakan blok bingkai per detik ( <em>mis. 60 frame per detik atau 60fps</em> ). </p><br><p>  Anda mungkin bertanya kepada saya mengapa saya memulai artikel ini dengan konsep gambar 2 dimensi yang ditampilkan oleh GPU / perangkat keras dan sensor kaca fisik, dan apa hubungannya dengan widget Flutter biasa? </p><br><p>  Saya pikir akan lebih mudah untuk memahami bagaimana Flutter sebenarnya bekerja jika kita melihatnya dari sudut pandang ini, karena salah satu tujuan utama aplikasi Flutter adalah untuk membuat gambar 2 dimensi ini dan memungkinkannya berinteraksi dengannya.  Juga karena di Flutter, percaya atau tidak, hampir semuanya karena kebutuhan untuk memperbarui layar dengan cepat dan pada waktu yang tepat! </p><br><h2 id="interfeys-mezhdu-kodom-i-ustroystvom">  Antarmuka antara kode dan perangkat </h2><br><p>  Bagaimanapun, semua orang yang tertarik dengan Flutter telah melihat gambar berikut yang menggambarkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">arsitektur tingkat tinggi</a> Flutter. </p><br><p><img src="https://habrastorage.org/webt/i0/tp/fo/i0tpfoumlz1ultkyzqywfm9-osa.png"></p><br><p>  Saat kami menulis aplikasi Flutter menggunakan Dart, kami tetap berada di level <em>Flutter Framework</em> (disorot dengan warna hijau). </p><br><p>  <em>Flutter Framework</em> berinteraksi dengan <em>Flutter Engine</em> (berwarna biru) melalui lapisan abstraksi yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Window</a> .  Level abstraksi ini menyediakan sejumlah API untuk interaksi tidak langsung dengan perangkat. </p><br><p>  Juga melalui level abstraksi ini, <em>Mesin Flutter</em> memberi tahu <em>Flutter Framework</em> ketika: </p><br><ul><li>  suatu peristiwa yang menarik terjadi pada tingkat perangkat (perubahan orientasi, perubahan pengaturan, masalah memori, kondisi operasi aplikasi ...) </li><li>  beberapa peristiwa terjadi pada level gelas (= gerakan) </li><li>  saluran platform mengirim beberapa data </li><li>  tetapi juga terutama saat <strong>Flutter Engine siap membuat bingkai baru</strong> </li></ul><br><h2 id="upravlenie-flutter-framework-renderingom-flutter-engine">  Kelola Kerangka Kerja Flutter rendering Engine </h2><br><p>  Sulit dipercaya, tapi itu benar.  Kecuali dalam beberapa kasus ( <em>lihat di bawah</em> ), tidak ada kode <em>Flutter Framework</em> yang dijalankan tanpa memulai rendering <em>Flutter Engine</em> . </p><br><p>  Pengecualian: </p><br><ul><li>  Gesture / Gesture (= acara di atas kaca) </li><li>  Pesan platform (= pesan yang dihasilkan oleh perangkat, seperti GPS) </li><li>  Pesan perangkat (= pesan yang berhubungan dengan perubahan status perangkat, misalnya, orientasi, aplikasi yang dikirim di latar belakang, peringatan memori, pengaturan perangkat ...) </li><li>  Respons masa depan atau http </li></ul><br><p>  <em>(Di antara kami, Anda benar-benar dapat menerapkan perubahan visual tanpa menelepon dari Flutter Engine, tetapi ini <strong>tidak disarankan</strong> )</em> </p><br><p>  Anda bertanya kepada saya: "Jika semacam kode yang terkait dengan <em>gerakan</em> dijalankan dan menyebabkan perubahan visual, atau jika saya menggunakan <em>timer</em> untuk mengatur frekuensi tugas yang mengarah ke perubahan visual (misalnya, animasi), lalu bagaimana cara kerjanya?" </p><br><p>  Jika Anda ingin perubahan visual terjadi atau beberapa kode dijalankan berdasarkan timer, maka Anda perlu memberi tahu <em>Flutter Engine</em> bahwa ada sesuatu yang harus diambil. </p><br><p>  Biasanya, saat berikutnya <em>Flutter Engine</em> memperbarui, ia memanggil <em>Flutter Framework</em> untuk mengeksekusi beberapa kode, dan akhirnya memberikan adegan baru untuk rendering. </p><br><p>  Oleh karena itu, pertanyaan penting adalah bagaimana mesin Flutter mengatur semua perilaku aplikasi berdasarkan rendering. </p><br><p>  Untuk mendapatkan gagasan tentang mekanisme internal, lihat animasi berikut: </p><br><p><img src="https://habrastorage.org/webt/zu/7s/ig/zu7sigrkekrmz8ha_83cvr88ynk.gif"></p><br><p>  Penjelasan singkat (detail lebih lanjut akan datang nanti): </p><br><ul><li>  Beberapa peristiwa eksternal (gerakan, tanggapan http, dll.) Atau bahkan masa depan dapat memicu tugas yang membuatnya perlu untuk memperbarui tampilan.  Pesan yang sesuai dikirim ke <em>Mesin Flutter</em> (= <em>Jadwal Frame</em> ) </li><li>  Ketika <em>Mesin Flutter</em> siap untuk mulai memperbarui rendering, itu membuat permintaan <em>Begin Frame</em> </li><li>  Permintaan <em>Begin Frame</em> ini dicegat oleh <em>Flutter Framework</em> , yang melakukan tugas-tugas yang terutama terkait dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Tickers</a> (misalnya, animasi) </li><li>  Tugas-tugas ini dapat membuat kembali permintaan untuk rendering nanti (contoh: animasi belum menyelesaikan eksekusi, dan untuk menyelesaikannya, perlu mendapatkan <em>Begin Bingkai lain</em> pada tahap selanjutnya) </li><li>  Selanjutnya, <em>Mesin Flutter</em> mengirimkan <em>Draw Frame</em> , yang dicegat oleh <em>Flutter Framework</em> , yang akan mencari tugas apa pun yang berkaitan dengan memperbarui tata letak dalam hal struktur dan ukuran </li><li>  Setelah semua tugas ini selesai, ia melanjutkan ke tugas yang terkait dengan memperbarui tata letak dalam hal rendering </li><li>  Jika ada sesuatu di layar yang perlu digambar, maka adegan baru ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Scene</a> ) untuk visualisasi dikirim ke <em>Flutter Engine</em> , yang akan memperbarui layar </li><li>  <em>Flutter Framework kemudian</em> melakukan semua tugas yang akan dilakukan setelah rendering (= callback PostFrame), dan tugas-tugas berikutnya lainnya yang tidak terkait dengan rendering </li><li>  ... dan proses ini dimulai dari awal lagi </li></ul><br><h2 id="renderview-i-renderobject">  RenderView dan RenderObject </h2><br><p>  Sebelum menyelam ke rincian alur kerja, saatnya untuk memperkenalkan konsep <em>Pohon Rendering</em> . </p><br><p>  Seperti disebutkan sebelumnya, semuanya pada akhirnya akan dikonversi menjadi piksel yang akan ditampilkan di layar, dan <em>Flutter Framework akan</em> mengonversi <em>Widget</em> yang kami gunakan untuk mengembangkan aplikasi menjadi blok visual yang akan ditampilkan di layar. </p><br><p>  Bagian visual ini sesuai dengan objek yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">RenderObject</a> , yang digunakan untuk: </p><br><ul><li>  mendefinisikan area layar tertentu dalam hal ukuran, posisi, geometri, serta dalam hal <em>"konten yang diberikan"</em> </li><li>  mengidentifikasi area layar yang dapat dipengaruhi oleh gerakan (= sentuhan jari) </li></ul><br><p>  Satu set semua <em>RenderObjects</em> membentuk pohon yang disebut <em>Render Tree</em> .  Di atas pohon ini (= <em>root</em> ) kami menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">RenderView</a> . </p><br><p>  <em>RenderView</em> menyediakan permukaan umum untuk objek <em>Render Tree</em> dan merupakan versi khusus <em>RenderObject</em> . </p><br><p>  Secara visual, kami dapat mewakili semua ini sebagai berikut: <br><img src="https://habrastorage.org/webt/yi/aq/6v/yiaq6vvo9ssed0qtewkftfwrmpy.png"></p><br><p>  Hubungan antara <em>Widget</em> dan <em>RenderObject</em> akan dibahas nanti.  Sementara itu, saatnya untuk pergi sedikit lebih dalam ... </p><br><h2 id="inicializaciya-bindings">  Binding inisialisasi </h2><br><p> Ketika aplikasi Flutter dimulai, fungsi <code>main()</code> dipanggil pertama, yang akhirnya memanggil metode <code>runApp(Widget app)</code> . </p><br><p>  Ketika metode <code>runApp()</code> <em>Flutter Framework</em> menginisialisasi antarmuka antara dirinya dan <em>Flutter Engine</em> .  Antarmuka ini disebut <strong>binding</strong> ( <em>catatan: binding</em> ). </p><br><p>  <strong>Pengantar Bindings</strong> </p><br><p>  Binding dirancang untuk menjadi penghubung antara kerangka dan mesin Flutter.  Hanya melalui binding data dapat dipertukarkan antara <em>Flutter Framework</em> dan <em>Flutter Engine</em> . <br>  <em>(Hanya ada satu pengecualian untuk aturan ini -</em> RenderView <em>, tetapi kami akan membahas ini nanti).</em> </p><br><p>  Setiap penjilidan bertanggung jawab untuk memproses serangkaian tugas, tindakan, peristiwa tertentu, dikelompokkan berdasarkan bidang kegiatan. </p><br><p>  Pada saat penulisan ini, <em>Flutter Framework</em> memiliki 8 binding. </p><br><p>  Di bawah ini adalah 4 di antaranya yang akan dipertimbangkan dalam artikel ini: </p><br><ul><li>  <em>Penjadwal Penjilidan</em> </li><li>  <em>Mengikat gerakan</em> </li><li>  <em>Pengikat penyaji</em> </li><li>  <em>Penjilidan widget</em> </li></ul><br><p>  Untuk kelengkapan, saya akan menyebutkan 4 sisanya: </p><br><ul><li>  <em>ServicesBinding</em> : bertanggung jawab untuk memproses pesan yang dikirim oleh <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">saluran platform</a></em> </li><li>  <em>PaintingBinding</em> : bertanggung jawab untuk memproses cache gambar </li><li>  <em>SemanticsBinding</em> : dicadangkan untuk implementasi selanjutnya dari segala sesuatu yang berkaitan dengan semantik </li><li>  <em>TestWidgetsFlutterBinding</em> : digunakan oleh perpustakaan tes widget </li></ul><br><p>  Anda juga dapat menyebutkan <em>WidgetsFlutterBinding</em> , tetapi ini bukan benar-benar mengikat, melainkan semacam <em>"penginisialisasi mengikat</em> . <em>"</em> </p><br><p>  Diagram berikut menunjukkan interaksi antara binding, yang akan saya pertimbangkan selanjutnya, dan <em>Flutter Engine</em> . </p><br><p><img src="https://habrastorage.org/webt/ws/ph/x_/wsphx_tme3caqf0qimfk0wxur9g.png"></p><br><p>  Mari kita lihat masing-masing ikatan "inti" ini. </p><br><h3 id="schedulerbinding">  Penjadwal Penjilid </h3><br><p>  Ikatan ini memiliki dua tanggung jawab utama: </p><br><ul><li>  Katakan <em>Mesin Flutter</em> : <em>"Hei! Lain kali ketika Anda tidak sibuk, bangunkan saya agar saya bisa bekerja sedikit dan memberi tahu Anda apa yang harus dirender, atau jika saya perlu Anda menelepon saya nanti ..."</em> </li><li>  Dengarkan dan tanggapi <em>â€œkebangkitan yang menggangguâ€ tersebut</em> (lihat di bawah) </li></ul><br><p>  Kapan <em>SchedulerBinding</em> meminta <em>panggilan bangun</em> ? </p><br><ul><li><p>  Kapan <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Ticker</a></em> Harus <em>Mengerjakan Tick</em> Baru </p><br><p>  Misalnya, Anda memiliki animasi, Anda memulainya.  Animasi dipangkas menggunakan <em>Ticker</em> , yang dipanggil secara berkala (= <em>centang</em> ) untuk melakukan <em>panggilan balik</em> .  Untuk meluncurkan <em>panggilan balik</em> seperti itu, kami perlu memberi tahu <em>Flutter Engine</em> agar ia bangun selama pembaruan berikutnya (= <em>Mulai Frame</em> ).  Ini akan meluncurkan panggilan balik <em>ticker</em> untuk menyelesaikan tugasnya.  Jika <em>ticker</em> masih perlu melanjutkan eksekusi, maka di akhir tugasnya, ia akan memanggil <em>SchedulerBinding</em> untuk menjadwalkan frame lain. </p><br></li><li><p>  Kapan harus memperbarui tampilan </p><br><p>  Sebagai contoh, kita perlu membuat suatu peristiwa yang mengarah pada perubahan visual (contoh: memperbarui warna bagian layar, menggulir, menambahkan / menghapus sesuatu dari layar), untuk ini kita perlu mengambil langkah-langkah yang diperlukan untuk akhirnya menampilkan gambar yang diperbarui pada layar.  Dalam hal ini, ketika perubahan tersebut terjadi, <em>Kerangka Flutter</em> memanggil <em>Penjadwal</em> untuk mengikat frame lain menggunakan <em>Mesin Flutter</em> .  <em>(Nanti kita akan melihat bagaimana ini sebenarnya bekerja)</em> </p><br></li></ul><br><h3 id="gesturebinding">  Mengikat gerakan </h3><br><p>  Ikatan ini mendengarkan interaksi dengan mesin dalam hal <em>â€œjariâ€</em> (= <em>gesture</em> ). </p><br><p>  Secara khusus, ia bertanggung jawab untuk menerima data terkait <em>jari</em> dan untuk menentukan bagian layar mana yang digunakan untuk gerakan.  Dia kemudian memberitahukan sesuai / bagian-bagian ini. </p><br><h3 id="rendererbinding">  Pengikat penyaji </h3><br><p>  Ikatan ini adalah tautan antara <em>Flutter Engine</em> dan <em>Render Tree</em> .  Dia bertanggung jawab untuk: </p><br><ul><li>  mendengarkan peristiwa yang dihasilkan oleh mesin untuk menginformasikan tentang perubahan yang diterapkan oleh pengguna melalui pengaturan perangkat yang memengaruhi efek visual dan / atau semantik </li><li>  pesan ke mesin tentang perubahan yang akan diterapkan pada layar </li></ul><br><p>  Untuk memberikan perubahan yang akan ditampilkan di layar, <em>RendererBinding</em> bertanggung jawab untuk mengelola <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">PipelineOwner</a> dan menginisialisasi <strong>RenderView</strong> . </p><br><p>  <em>PipelineOwner</em> adalah sejenis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">orkestra</a> yang tahu apa yang perlu dilakukan dengan <em>RenderObject</em> sesuai dengan <em>komponennya</em> , dan mengoordinasikan tindakan ini. </p><br><h3 id="widgetsbinding">  Penjilidan widget </h3><br><p>  Penjilidan ini mendengarkan perubahan yang diterapkan oleh pengguna melalui pengaturan perangkat yang memengaruhi bahasa (= <em>lokal</em> ) dan <em>semantik</em> . </p><br><blockquote>  <em>Catatan kecil</em> <br><br>  <em>Saya berasumsi bahwa pada tahap selanjutnya dalam pengembangan</em> Flutter, <em>semua acara yang berhubungan dengan semantik akan ditransfer ke</em> SemanticsBinding <em>, tetapi pada saat penulisan ini, ini tidak terjadi.</em> </blockquote><p>  Selain itu, <em>WidgetsBinding</em> adalah tautan antara widget dan <em>Flutter Engine</em> .  Dia bertanggung jawab untuk: </p><br><ul><li>  manajemen proses pemrosesan perubahan struktur widget </li><li>  membuat panggilan </li></ul><br><p>  Pemrosesan perubahan pada struktur widget dilakukan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">BuildOwner</a> . </p><br><p>  <em>BuildOwner</em> melacak widget mana yang perlu dibangun kembali, dan menangani tugas-tugas lain yang berlaku untuk struktur widget secara keseluruhan. </p><br><h1 id="chast-2-ot-vidzhetov-k-pikselyam">  Bagian 2. Dari widget ke piksel </h1><br><p>  Sekarang kita telah mempelajari dasar-dasar pekerjaan internal <em>Flutter</em> , sekarang saatnya untuk berbicara tentang widget. </p><br><p>  Dalam semua dokumentasi Flutter Anda akan membaca bahwa semua <em>Widget</em> (widget). </p><br><p>  Ini hampir benar.  Tetapi agar lebih tepat, saya lebih suka mengatakan: </p><br><blockquote>  Dari sisi pengembang, semua yang terkait dengan antarmuka pengguna dalam hal tata letak dan interaksi dilakukan menggunakan widget. </blockquote><p>  Mengapa begitu akurat?  Selain kenyataan bahwa <em>Widget</em> memungkinkan pengembang untuk menentukan bagian dari layar dalam hal ukuran, konten, tata letak dan interaksi, <strong>TETAPI</strong> ada lebih banyak untuk itu.  Jadi apa sebenarnya <em>Widget itu</em> ? </p><br><h2 id="neizmenyaemaya-konfiguraciya">  Konfigurasi Abadi </h2><br><p>  Jika Anda melihat kode sumber <em>Flutter</em> , Anda akan melihat definisi berikut dari kelas <em>Widget</em> . </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DiagnosticableTree</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({ </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.key })</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Key key; ... }</code> </pre> <br><p>  Apa artinya ini? </p><br><p>  Anotasi <strong>"@immutable"</strong> sangat penting dan memberi tahu kami bahwa <strong>variabel apa pun di kelas Widget harus FINAL</strong> , dengan kata lain: "didefinisikan dan ditetapkan <strong>SEKALI UNTUK SEMUA ORANG</strong> ."  Dengan demikian, setelah membuat sebuah instance, Widget tidak akan lagi dapat mengubah variabel internalnya. </p><br><blockquote>  <em>Karena Widget tidak dapat diubah, ini dapat dianggap sebagai konfigurasi statis.</em> </blockquote><br><h2 id="ierarhicheskaya-struktura-vidzhetov">  Struktur hierarkis widget </h2><br><p>  Saat Anda mendesain dengan Flutter, Anda menentukan struktur layar Anda menggunakan widget seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SafeArea( child: Scaffold( appBar: AppBar( title: Text(<span class="hljs-string"><span class="hljs-string">'My title'</span></span>), ), body: Container( child: Center( child: Text(<span class="hljs-string"><span class="hljs-string">'Centered Text'</span></span>), ), ), ), ); }</code> </pre> <br><p>  Contoh ini menggunakan 7 widget yang bersama-sama membentuk struktur hierarkis.  Skema yang sangat disederhanakan berdasarkan kode ini adalah sebagai berikut: </p><br><p><img src="https://habrastorage.org/webt/f2/ke/dt/f2kedtux7_ot2issfzbv64n3uak.png"></p><br><p>  Seperti yang Anda lihat, diagram yang disajikan terlihat seperti pohon, di mana <em>SafeArea</em> adalah akarnya. </p><br><h2 id="les-za-derevyami">  Hutan di belakang pohon </h2><br><p>  Seperti yang sudah Anda ketahui, widget itu sendiri bisa menjadi agregasi dari widget lain.  Sebagai contoh, Anda dapat mengubah kode sebelumnya sebagai berikut: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyOwnWidget(); }</code> </pre> <br><p>  Opsi ini mengasumsikan bahwa widget <em>"MyOwnWidget"</em> itu sendiri akan menampilkan <em>SafeArea</em> , <em>Scaffold</em> .  Tetapi hal yang paling penting dalam contoh ini adalah itu </p><br><blockquote>  <em>Widget</em> dapat mewakili daun, simpul di pohon, bahkan pohon itu sendiri atau, mengapa tidak, hutan pohon ... </blockquote><br><h2 id="ponimanie-element-v-dereve">  Memahami <em>Elemen</em> dalam Pohon </h2><br><p>  Apa hubungannya ini dengan itu? </p><br><p>  Seperti yang akan ditampilkan nanti, untuk dapat menghasilkan piksel yang membentuk gambar yang ditampilkan pada perangkat, <em>Flutter</em> harus mengetahui secara rinci semua bagian kecil yang membentuk layar, dan untuk menentukan semua bagian, perlu diketahui <strong>perluasan</strong> semua widget. </p><br><p>  Untuk mengilustrasikan hal ini, pertimbangkan prinsip boneka bersarang: ketika ditutup, Anda hanya melihat 1 boneka, tetapi mengandung satu boneka lain, yang pada gilirannya berisi boneka lain dan seterusnya ... </p><br><p><img src="https://habrastorage.org/webt/9x/kq/lb/9xkqlbngsofs0w7m71rx2yucnzy.png"></p><br><p>  Ketika <em>Flutter</em> memperluas semua widget <em>(bagian dari layar)</em> , itu akan seperti mendapatkan semua boneka <em>(bagian dari keseluruhan)</em> . </p><br><p>  Gambar di bawah ini menunjukkan bagian dari struktur hierarki terakhir widget yang sesuai dengan kode sebelumnya.  Dalam warna kuning, saya menyoroti widget yang disebutkan dalam kode sebelumnya, sehingga Anda dapat mendefinisikannya di pohon akhir. </p><br><p><img src="https://habrastorage.org/webt/mp/lw/-o/mplw-oisztyx_zvwf8kvpl2tpog.png"></p><br><blockquote>  <strong><em>Klarifikasi penting</em></strong> <br><br>  <em>Bahasa "Pohon widget" hanya ada untuk memudahkan pemahaman, karena programmer menggunakan widget, tetapi tidak ada pohon widget di Flutter!</em> <br><br>  <em>Bahkan, akan lebih tepat untuk mengatakan "pohon Elemen"</em> </blockquote><p>  Sudah waktunya untuk memperkenalkan konsep <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Elemen</a> . </p><br><blockquote>  <em><strong>Setiap</strong> widget memiliki <strong>satu</strong> elemen.</em>  <em>Elemen-elemen terhubung satu sama lain dan membentuk pohon.</em>  <em>Oleh karena itu, <strong>elemen</strong> adalah referensi ke sesuatu di pohon.</em> </blockquote><p>  Untuk mulai dengan, pikirkan elemen sebagai simpul yang memiliki orang tua dan mungkin anak.  Dengan menghubungkan mereka bersama melalui hubungan <em>orangtua-anak</em> , kita mendapatkan struktur pohon. </p><br><p><img src="https://habrastorage.org/webt/bd/cx/t4/bdcxt4slijkhhc5j0fnipnauyey.png"></p><br><p>  Seperti yang Anda lihat, elemen menunjuk ke satu widget, dan juga <strong>dapat</strong> menunjuk ke sebuah <em>RenderObject</em> . </p><br><blockquote>  <em>Bahkan lebih baik ... Elemen menunjuk ke Widget yang <strong>membuat</strong> Elemen ini!</em> </blockquote><p>  Mari kita simpulkan: </p><br><ul><li>  Tidak ada pohon widget, tetapi ada pohon elemen </li><li>  Elemen dibuat oleh widget. </li><li>  Item merujuk ke widget yang membuatnya. </li><li>  Elemen yang ditautkan dengan hubungan orang tua </li><li>  Item mungkin memiliki "bayi." </li><li>  Elemen juga bisa mengarah ke <em>RenderObject.</em> </li></ul><br><blockquote>  <em><strong>Elemen</strong> menentukan bagaimana bagian dari blok yang ditampilkan saling berhubungan satu sama lain.</em> </blockquote><p>  Untuk lebih membayangkan di mana konsep <em>elemen</em> cocok, mari kita lihat representasi visual berikut: </p><br><p><img src="https://habrastorage.org/webt/x5/vb/jt/x5vbjtq_5fhuyhvc2s7jnt7pbai.png"></p><br><p>  Seperti yang Anda lihat, elemen tree adalah hubungan aktual antara widget dan <em>RenderObjects</em> . </p><br><p>  Tapi mengapa <em>Widget</em> membuat <em>Elemen</em> ? </p><br><h2 id="3-kategorii-vidzhetov">  3 kategori widget </h2><br><p>  Di Flutter, widget dibagi menjadi 3 kategori, saya pribadi menyebutnya sebagai berikut <em>(tapi ini hanya cara saya mengklasifikasikannya)</em> : </p><br><ul><li><p>  Proksi </p><br><p>  Tugas utama widget ini adalah menyimpan beberapa informasi (yang harus dapat diakses oleh widget), bagian dari struktur pohon berdasarkan Proxy.  Contoh widget tersebut adalah <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">InheritedWidget</a></strong> atau <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">LayoutId</a></strong> . </p><br><p>  Widget ini tidak secara langsung berpartisipasi dalam pembentukan antarmuka pengguna, tetapi digunakan untuk memperoleh informasi yang dapat mereka berikan. </p><br></li><li><p>  Renderer </p><br><p>  Widget ini secara langsung terkait dengan tata letak layar, karena mereka menentukan (atau digunakan untuk menentukan) <em>ukuran</em> , <em>posisi</em> , <em>render</em> .  Contoh umum adalah: <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Baris</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Kolom</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Tumpukan</a></strong> , serta <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Padding</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Align</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Opacity</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">RawImage</a></strong> ... </p><br></li><li><p>  Komponen </p><br><p>  Ini adalah widget lain yang menyediakan secara langsung bukan informasi final terkait dengan ukuran, posisi, penampilan, melainkan data (atau kiat) yang akan digunakan untuk mendapatkan informasi yang paling final.  Widget ini biasanya disebut sebagai komponen. </p><br><p>  Contoh: <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">RaisedButton</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Scaffold</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Text</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">GestureDetector</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Container</a></strong> ... </p><br></li></ul><br><p><img src="https://habrastorage.org/webt/oe/j0/j7/oej0j75h_3ycogohqdckq5e03im.png"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">File PDF ini</a> mencantumkan sebagian besar widget yang dikelompokkan berdasarkan kategori. </p><br><p>  Mengapa pemisahan ini penting?  Karena tergantung pada kategori widget, jenis elemen yang terkait dikaitkan dengan ... </p><br><h2 id="tipy-elementov">  Jenis Barang </h2><br><p>  Ada beberapa jenis elemen: </p><br><p><img src="https://habrastorage.org/webt/or/au/yc/orauycfegkvfnjlmjws4x4ftpuw.png"></p><br><p>  Seperti yang Anda lihat pada gambar di atas, elemen-elemen dibagi menjadi 2 jenis utama: </p><br><ul><li><p>  Komponen </p><br><p>  Elemen-elemen <strong>ini</strong> tidak <strong>secara langsung</strong> bertanggung jawab untuk menampilkan bagian mana pun dari tampilan. </p><br></li><li><p>  RenderObjectElement </p><br><p>  Elemen-elemen ini bertanggung jawab atas bagian-bagian dari gambar yang ditampilkan di layar. </p><br></li></ul><br><p>  Hebat!  Begitu banyak informasi, tetapi bagaimana semua ini terkait satu sama lain dan mengapa menarik untuk membicarakannya? </p><br><h2 id="kak-vidzhety-i-elementy-rabotayut-vmeste">  Bagaimana widget dan elemen bekerja bersama </h2><br><blockquote>  <em>Dalam Flutter, semua mekanisme didasarkan pada pembatalan suatu elemen atau renderObject.</em> </blockquote><p>  Pembatalan elemen dapat dilakukan dengan cara-cara berikut: </p><br><ul><li>  menggunakan <code>setState</code> , yang membatalkan seluruh <strong>StatefulElement</strong> (perhatikan bahwa saya sengaja tidak mengatakan <em>StatefulWidget</em> ) </li><li>  melalui pemberitahuan yang diproses oleh <strong>proxyElement</strong> (misalnya, InheritedWidget), yang membatalkan <em>elemen</em> apa pun yang bergantung pada <em>proxyElement</em> ini </li></ul><br><p>  Hasil dari <em>pembatalan</em> adalah bahwa tautan ke <em>elemen yang</em> sesuai muncul di daftar elemen <strong>kotor</strong> . </p><br><p>  <em>Pembatalan renderObject</em> berarti bahwa struktur elemen tidak berubah sama sekali, tetapi ada perubahan di tingkat <em>renderObject</em> , misalnya: </p><br><ul><li>  mengubah ukuran, posisi, geometri ... </li><li>  sesuatu perlu dicat ulang, misalnya, ketika Anda baru saja mengubah warna latar belakang, gaya font ... </li></ul><br><p>  Hasil dari <em>pembatalan tersebut</em> adalah tautan ke <em>renderObject yang</em> sesuai dalam daftar objek render <em>(renderObjects)</em> yang perlu dibangun kembali atau dicat ulang. </p><br><p>  Terlepas dari jenis invalidation, <strong>SchedulerBinding</strong> disebut (ingat ini?) Untuk meminta <strong>Mesin Flutter</strong> menjadwalkan frame baru. </p><br><p>  Inilah saat ketika <em>Mesin Flutter</em> "membangunkan" <em>Penjadwal Penjilidan</em> dan semua keajaiban terjadi ... </p><br><h2 id="ondrawframe">  onDrawFrame () </h2><br><p>  Sebelumnya dalam artikel ini, kami mencatat bahwa <em>SchedulerBinding memiliki</em> dua tanggung jawab utama, salah satunya adalah kesiapannya untuk menangani permintaan yang dibuat oleh <em>Flutter Engine</em> terkait dengan pembangunan kembali bingkai.  Ini adalah saat yang tepat untuk fokus pada hal ini. </p><br><p>  Diagram urutan parsial di bawah ini menunjukkan apa yang terjadi ketika <em>SchedulerBinding</em> menerima permintaan <em>onDrawFrame ()</em> dari <em>Flutter Engine</em> . </p><br><p><img src="https://habrastorage.org/webt/b8/mz/ba/b8mzbav2krwuwat0ibyvd5gngs4.png"></p><br><p>  <strong>Langkah 1. Elemen</strong> </p><br><p>  <em>WidgetsBinding disebut</em> , dan pengikatan ini pertama kali mempertimbangkan perubahan yang terkait dengan elemen.  <em>WidgetsBinding</em> memanggil metode <em>buildScope</em> dari objek <em>buildOwner</em> , karena <strong>BuildOwner</strong> bertanggung jawab untuk memproses pohon item.  Metode ini melewati daftar elemen <em>kotor</em> dan meminta mereka <strong>membangun kembali</strong> . </p><br><p>  Prinsip-prinsip utama dari metode <code>rebuild()</code> ini ( <code>rebuild()</code> ) adalah: </p><br><ol><li>  Ada permintaan untuk membangun kembali elemen (ini akan menghabiskan sebagian besar waktu), memanggil metode <code>build()</code> dari widget yang mengacu pada elemen ini (= <code>Widget build (BuildContext context) {...}</code> metode).  Metode <code>build()</code> ini akan mengembalikan widget baru </li><li>  Jika elemen tidak memiliki "anak-anak," maka elemen dibuat untuk widget baru (lihat di bawah) ( <em>catatan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">inflateWidget</a></em> ), jika tidak </li><li>  widget baru dibandingkan dengan yang direferensikan oleh anak elemen <br><ul><li>  Jika dapat dipertukarkan (= <em>jenis dan kunci widget yang sama</em> ), maka pembaruan terjadi dan anak disimpan. </li><li>  Jika tidak dapat dipertukarkan, maka anak tersebut dibuang ( <em>~ dibuang</em> ) dan sebuah elemen dibuat untuk widget baru </li></ul></li><li>  Item baru ini dipasang sebagai anak dari item tersebut.  ( <em>terpasang)</em> = dimasukkan ke dalam elemen tree) </li></ol><br><p>  Animasi berikut akan mencoba membuat penjelasan ini sedikit lebih jelas. </p><br><p><img src="https://habrastorage.org/webt/71/91/xc/7191xcnbg00lbho_ol_9vaczdca.gif"></p><br><p>  <strong>Catatan tentang widget dan elemen</strong> </p><br><p>  Untuk widget baru, elemen <em>tipe tertentu</em> dibuat yang sesuai dengan <em>kategori</em> widget, yaitu: </p><br><ul><li>  <em>InheritedWidget</em> -&gt; <em>InheritedElement</em> </li><li>  <em>StatefulWidget</em> -&gt; <em>StatefulElement</em> </li><li>  <em>StatelessWidget</em> -&gt; <em>StatelessElement</em> </li><li>  <em>InheritedModel</em> -&gt; <em>InheritedModelElement</em> </li><li>  <em>InheritedNotifier</em> -&gt; <em>InheritedNotifierElement</em> </li><li>  <em>LeafRenderObjectWidget</em> -&gt; <em>LeafRenderObjectElement</em> </li><li>  <em>SingleChildRenderObjectWidget</em> -&gt; <em>SingleChildRenderObjectElement</em> </li><li>  <em>MultiChildRenderObjectWidget</em> -&gt; <em>MultiChildRenderObjectElement</em> </li><li>  <em>ParentDataWidget</em> -&gt; <em>ParentDataElement</em> </li></ul><br><p>  Masing-masing tipe elemen ini memiliki perilaku masing-masing.  Sebagai contoh: </p><br><ul><li>  <em>StatefulElement</em> akan memanggil metode <code>widget.createState()</code> pada inisialisasi, yang akan membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Negara</a> dan mengaitkannya dengan elemen </li><li>  Ketika elemen tipe <em>RenderObjectElement</em> dipasang, itu membuat <em>RenderObject</em> .  <em>RenderObject</em> ini akan ditambahkan ke <em>Render Tree</em> dan dikaitkan dengan elemen. </li></ul><br><p>  <strong>Langkah 2. renderObjects</strong> </p><br><p>  Sekarang setelah menyelesaikan semua tindakan yang terkait dengan elemen <em>kotor</em> , <em>Pohon Elemen</em> stabil.  Jadi sudah waktunya untuk mempertimbangkan proses visualisasi. </p><br><p>  Karena <em>RendererBinding</em> bertanggung jawab untuk merender <em>Render Tree</em> , <em>WidgetsBinding</em> memanggil metode <code>drawFrame</code> <em>RendererBinding</em> . </p><br><p>  Diagram parsial di bawah ini menunjukkan urutan tindakan yang dilakukan selama permintaan <em>drawFrame ()</em> . </p><br><p><img src="https://habrastorage.org/webt/dp/sw/v3/dpswv3gszlwj3f_zwsak0xq91k0.png"></p><br><p>  Pada langkah ini, tindakan berikut dilakukan: </p><br><ul><li>  Setiap <em>renderObject yang</em> ditandai sebagai <em>kotor</em> diminta untuk menyusunnya (mis., Menghitung ukuran dan geometrinya) </li><li>  Setiap <em>renderObject</em> ditandai sebagai "perlu redrawing" digambar ulang menggunakan metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">lapisan</a> sendiri </li><li>  Adegan yang dihasilkan terbentuk dan dikirim ke <em>Flutter Engine</em> , sehingga yang terakhir mentransfernya ke layar perangkat </li><li>  Akhirnya, semantik juga diperbarui dan dikirim ke <em>Flutter Engine</em> </li></ul><br><p>  Di akhir alur kerja ini, layar perangkat disegarkan. </p><br><h1 id="chast-3-obrabotka-zhestov">  Bagian 3: Menangani Gerakan </h1><br><p>  Gerakan (= <em>peristiwa yang berkaitan dengan aksi jari pada kaca</em> ) diproses menggunakan <em>GestureBinding</em> . </p><br><p>  Ketika <em>Flutter Engine</em> mengirim informasi tentang peristiwa gerakan melalui <strong>jendela.onPointerDataPacket</strong> API, <strong>GestureBinding</strong> menyadapnya, melakukan beberapa buffering, dan: </p><br><ol><li>  mengonversi koordinat yang diberikan oleh <em>Mesin Flutter</em> agar sesuai dengan <strong>rasio piksel perangkat</strong> , lalu </li><li>  mengambil dari <em>render, Melihat</em> daftar semua objek <em>Render</em> yang ada di bagian layar yang terkait dengan koordinat acara </li><li>  kemudian <em>beralih</em> melalui daftar <em>renderObjects yang dihasilkan</em> dan mengirimkan acara terkait ke masing-masing </li><li>  jika <em>renderObject</em> "mendengarkan" untuk kejadian seperti ini, maka ia memprosesnya </li></ol><br><p>  Semoga sekarang saya mengerti betapa pentingnya <em>renderObjects</em> . </p><br><h1 id="chast-4-animacii">  Bagian 4: Animasi </h1><br><p>  Bagian artikel ini adalah tentang konsep <strong>animasi</strong> dan pemahaman mendalam tentang <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Ticker</a></strong> . </p><br><p>  Saat Anda bekerja dengan animasi, Anda biasanya menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">AnimationController</a> atau widget apa pun untuk animasi ( <em>catatan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">AnimatedCrossFade</a></em> ). </p><br><p>  Di <em>Flutter,</em> semua yang terkait dengan animasi merujuk ke <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Ticker</a></em> .  <em>Ticker</em> , ketika aktif, hanya memiliki satu tugas: "ia meminta <em>SchedulerBinding untuk</em> mendaftarkan panggilan balik dan memberi tahu <em>Flutter Engine</em> untuk membangunkannya ketika panggilan balik baru muncul."  Ketika <em>Mesin Flutter</em> siap, ia memanggil <em>Penjadwal</em> melalui permintaan: " <em>onBeginFrame</em> ".  <em>SchedulerBinding</em> mengakses daftar panggilan balik <em>ticker</em> dan mengeksekusi masing-masing. </p><br><p>  Setiap <em>centang</em> dicegat oleh pengontrol "tertarik" untuk memprosesnya.  Jika animasinya selesai, maka <em>ticker</em> â€œnonaktifâ€, jika tidak <em>ticker</em> meminta <em>Penjadwal</em> untuk menjadwalkan panggilan balik baru.  Dan seterusnya ... </p><br><h1 id="polnaya-kartina">  Gambar penuh </h1><br><p>  Sekarang kita telah belajar bagaimana <em>Flutter</em> bekerja: </p><br><p><img src="https://habrastorage.org/webt/5s/tw/w7/5stww7o_izlc6ywpnkmcfkkllbk.png"></p><br><h1 id="buildcontext">  Buildcontext </h1><br><p>  Akhirnya, kembali ke diagram yang menunjukkan berbagai jenis elemen, dan perhatikan tanda tangan <em>Elemen</em> root: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Element</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DiagnosticableTree</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BuildContext</span></span></span><span class="hljs-class"> </span></span>{ ... }</code> </pre> <br><p>  Kami melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">BuildContext yang</a> sangat terkenal!  Tapi apa itu? </p><br><p>  <strong>BuildContext</strong> adalah antarmuka yang mendefinisikan sejumlah getter dan metode yang dapat diimplementasikan oleh suatu elemen.  Kebanyakan <em>BuildContext</em> digunakan dalam metode <code>build()</code> dari <em>StatelessWidget</em> atau <em>State</em> for <em>StatefulWidget</em> . </p><br><blockquote>  <em><strong>BuildContext</strong> tidak lain adalah <strong>Elemen</strong> itu sendiri, yang cocok</em> <br><ul><li>  <em>widget sedang diperbarui (di dalam metode <code>build</code> atau <code>builder</code> )</em> </li><li>  <em>StatefulWidget dikaitkan dengan Status tempat Anda mereferensikan variabel konteks.</em> </li></ul><br></blockquote><p>  Ini berarti bahwa sebagian besar pengembang terus bekerja dengan elemen tanpa menyadarinya. </p><br><h2 id="naskolko-poleznym-mozhet-byt-buildcontext">     BuildContext? </h2><br><p>  <em>BuildContext</em>  ,   ,      ,  <em>BuildContext</em>   ,  : </p><br><ul><li>     <em>RenderObject</em> ,   (,     <em>Renderer</em> ,  -) </li><li>   <em>RenderObject</em> </li><li>   .     ,     <code>of</code> (, <code>MediaQuery.of(context)</code> , <code>Theme.of(context)</code> â€¦) </li></ul><br><h2 id="zabavy-radi">   </h2><br><p> ,   ,  <em>BuildContext</em> â€“  <em></em> ,         .  <strong> </strong>   <em>StatelessWidget</em>   ,      <em>StatefulWidget</em> ,    <code>setState()</code> ,    <em>BuildContext</em> . </p><br><blockquote> <strong></strong> <br> <strong>,    !</strong> <br><br>    â€“ ,  <em>StatelessWidget</em>   . <br>       , ,  <em>StatefulWidget</em> . </blockquote><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ runApp(MaterialApp(home: TestPage(),)); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestPage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// final because a Widget is immutable (remember?) final bag = {"first": true}; @override Widget build(BuildContext context){ return Scaffold( appBar: AppBar(title: Text('Stateless ??')), body: Container( child: Center( child: GestureDetector( child: Container( width: 50.0, height: 50.0, color: bag["first"] ? Colors.red : Colors.blue, ), onTap: (){ bag["first"] = !bag["first"]; // // This is the trick // (context as Element).markNeedsBuild(); } ), ), ), ); } }</span></span></code> </pre> <br><p> <em> ,    <code>setState()</code> ,         : <code>_element.markNeedsBuild()</code> .</em> </p><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p>  : "   ".   ,      ,    <em>Flutter</em> ,   ,    ,   ,      .  ,  ,   <em>Widget</em> , <em>Element</em> , <em>BuildContext</em> , <em>RenderObject</em> ,     .   ,       . </p><br><p>     .       . </p><br><p> PS  ,          () . <br> PSS       <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Flutter internals</a></strong>  Didier Boelens,           ) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id476018/">https://habr.com/ru/post/id476018/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id476000/index.html">Pembaruan Pembuat Model ML.NET</a></li>
<li><a href="../id476002/index.html">Pengalaman dalam menemukan posisi mahasiswa PhD di Jerman</a></li>
<li><a href="../id476004/index.html">Manajer proyek - mitos atau kenyataan? Atau mengapa diperlukan di bidang efek visual?</a></li>
<li><a href="../id476006/index.html">Mitos dan legenda pembangun SOC, atau 3 kesalahpahaman tentang pusat pemantauan dan menanggapi serangan cyber</a></li>
<li><a href="../id476008/index.html">Rapat MOSDROID: Sambungkan ke Siaran</a></li>
<li><a href="../id476022/index.html">Vue Storefront: Meningkatkan backend</a></li>
<li><a href="../id476024/index.html">Arsitektur terbaik untuk MVP: monolith, SOA, microservices atau serverless? .. Bagian 1</a></li>
<li><a href="../id476026/index.html">Cool Life Hacks untuk Bekerja dengan WSL (Windows Subsystem untuk Linux)</a></li>
<li><a href="../id476032/index.html">Brunner Elektronik - Dari sistem CAD ke kokpit</a></li>
<li><a href="../id476034/index.html">Yang paling tak berdaya adalah Peregrine Falcon</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>