<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚è≠Ô∏è üò¢ ü•í Reconstrucci√≥n 3D de caras a partir de fotograf√≠as y su animaci√≥n mediante video. Conferencia en Yandex üñêüèæ üåÇ üé≤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En la pel√≠cula Mission Impossible 3, se mostr√≥ el proceso de creaci√≥n de las famosas m√°scaras de esp√≠as, gracias a las cuales algunos personajes se vu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reconstrucci√≥n 3D de caras a partir de fotograf√≠as y su animaci√≥n mediante video. Conferencia en Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/421353/"> En la pel√≠cula Mission Impossible 3, se mostr√≥ el proceso de creaci√≥n de las famosas m√°scaras de esp√≠as, gracias a las cuales algunos personajes se vuelven indistinguibles de otros.  Seg√∫n la trama, al principio se requer√≠a fotografiar a la persona a quien el h√©roe quer√≠a convertir desde varios √°ngulos.  En 2018, un simple modelo de cara en 3D puede que ni siquiera se imprima, sino que al menos se cree en forma digital, y se base en una sola foto.  Un investigador de VisionLabs describi√≥ en detalle el proceso en el evento Yandex " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mundo a trav√©s de los ojos de los robots</a> " de la serie Data &amp; Science, con detalles sobre m√©todos y f√≥rmulas espec√≠ficos. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/zy9fxYDgUQw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Buenas tardes  Mi nombre es Nikolai, trabajo para VisionLabs, una compa√±√≠a de visi√≥n por computadora.  Nuestro perfil principal es el reconocimiento facial, pero tambi√©n tenemos tecnolog√≠as que son aplicables en realidad aumentada y virtual.  En particular, tenemos una tecnolog√≠a para construir una cara en 3D a partir de una foto, y hoy hablar√© sobre ello. <br><br><a name="habracut"></a><img src="https://habrastorage.org/webt/hi/ks/fu/hiksfukx8cknqrbhf5kv-c9xwbs.jpeg"><br><br>  Comencemos con una historia sobre lo que es.  En la diapositiva, ver√° la foto original de Jack Ma y un modelo 3D construido a partir de esta foto en dos variaciones: con y sin textura, solo geometr√≠a.  Esta es la tarea que estamos resolviendo. <br><br><img src="https://habrastorage.org/webt/qo/sy/10/qosy10ijsqqmfgyqiemsloakdqg.jpeg"><br><br>  Tambi√©n queremos poder animar este modelo, cambiar la direcci√≥n de nuestra mirada, expresi√≥n facial, agregar expresiones faciales, etc. <br><br>  La aplicaci√≥n se encuentra en diferentes √°reas.  Los m√°s obvios son los juegos, incluida la realidad virtual.  Tambi√©n puede hacer probadores virtuales: pruebe con anteojos, barbas y peinados.  Puede imprimir en 3D, porque algunas personas est√°n interesadas en accesorios personalizados para su cara.  Y puede hacer caras para los robots: tanto imprimir como mostrar en alguna pantalla del robot. <br><br><img src="https://habrastorage.org/webt/uh/d4/1b/uhd41bqzarsfib5oao3zven7gxk.jpeg"><br><br>  Comenzar√© dici√©ndole c√≥mo generar caras 3D en general, y luego pasaremos a la tarea de reconstrucci√≥n 3D como una tarea de generaci√≥n inversa.  Despu√©s de eso, nos centraremos en la animaci√≥n y pasaremos a los desaf√≠os que surgen en esta √°rea. <br><br><img src="https://habrastorage.org/webt/bk/yb/sj/bkybsja0tr11pleorczx4okgk3g.jpeg"><br><br>  ¬øCu√°l es la tarea de generar caras?  Nos gustar√≠a tener alguna forma de generar caras tridimensionales que difieran en forma y expresi√≥n.  Aqu√≠ hay dos filas con ejemplos.  La primera fila muestra caras de diferentes formas, que pertenecen a diferentes personas.  Y debajo est√° la misma cara con una expresi√≥n diferente. <br><br><img src="https://habrastorage.org/webt/_s/md/94/_smd94kpe-kgilpu8c2ncguhgve.jpeg"><br><br>  Una forma de resolver el problema de generaci√≥n son los modelos deformables.  La cara m√°s a la izquierda de la diapositiva es un tipo de modelo promediado al que podemos aplicar deformaciones ajustando los controles deslizantes.  Aqu√≠ hay tres controles deslizantes.  En la fila superior hay caras en la direcci√≥n de aumentar la intensidad del control deslizante, en la fila inferior, en la direcci√≥n de disminuir.  Por lo tanto, tendremos varios par√°metros personalizables.  Al instalarlos, puede darle a las personas diferentes formas. <br><br><img src="https://habrastorage.org/webt/rs/gj/bd/rsgjbdm2ekfclog-l9r24yj05zq.jpeg"><br><br>  Un ejemplo de un modelo deformable es el famoso modelo de rostro de Basilea, construido a partir de escaneos faciales.  Para construir un modelo deformable, primero debe llevar a algunas personas, llevarlas a un laboratorio especial y dispararles a la cara con un equipo especial, traduci√©ndolos en 3D.  Luego, en base a esto, puedes hacer nuevas caras. <br><br><img src="https://habrastorage.org/webt/da/lm/zi/dalmziafwox1_wosdsp25pjphiu.jpeg"><br><br>  ¬øC√≥mo se arregla matem√°ticamente?  Podemos imaginar un modelo tridimensional de una cara como un vector en un espacio tridimensional.  Aqu√≠ n es el n√∫mero de v√©rtices en el modelo, cada v√©rtice corresponde a tres coordenadas en 3D, y as√≠ obtenemos 3n coordenadas. <br><br><img src="https://habrastorage.org/webt/fr/h2/ek/frh2ekb0ts7xoeymvoxdthm7_ak.jpeg"><br><br>  Si tenemos un conjunto de escaneos, cada escaneo est√° representado por dicho vector, y tenemos un conjunto de n de tales vectores. <br><br>  Adem√°s, podemos construir nuevas caras como combinaciones lineales de vectores desde nuestra base de datos.  Al mismo tiempo, nos gustar√≠a que los coeficientes sean significativos.  Obviamente, no pueden ser completamente arbitrarios, y pronto mostrar√© por qu√©.  Se puede establecer una de las restricciones para que todos los coeficientes se encuentren en el rango de 0 a 1. Esto debe hacerse, porque si los coeficientes son completamente arbitrarios, las caras resultar√°n inveros√≠miles. <br><br><img src="https://habrastorage.org/webt/43/x3/m_/43x3m_fwzwj8xcsvywqjusbijmm.jpeg"><br><br>  Aqu√≠ me gustar√≠a dar a los par√°metros un significado probabil√≠stico.  Es decir, queremos ver un conjunto de par√°metros y comprender si es probable que una persona resulte o no.  Con esto queremos que las distorsiones bajas correspondan a caras distorsionadas. <br><br><img src="https://habrastorage.org/webt/ge/m4/yb/gem4ybi9ha0puz8tcjv3nomiwiy.jpeg"><br><br>  Aqu√≠ te explicamos c√≥mo hacerlo.  Podemos aplicar el m√©todo del componente principal a un conjunto de escaneos.  En la salida, obtenemos la cara promedio S0, obtenemos la matriz V, un conjunto de componentes principales, y tambi√©n obtenemos variaciones de datos a lo largo de los componentes principales.  Luego, podemos ver de nuevo la generaci√≥n de caras, representaremos las caras como una cara promedio, m√°s la matriz de los componentes principales, multiplicada por el vector de par√°metros. <br><br>  El valor de los par√°metros es la intensidad de los controles deslizantes de los que habl√© en una de las diapositivas anteriores.  Y tambi√©n podemos asignar alg√∫n valor probabil√≠stico al vector de par√°metros.  En particular, podemos aceptar que este vector sea gaussiano. <br><br><img src="https://habrastorage.org/webt/pv/bk/qq/pvbkqqdess7l175ginfuz9vkzmw.jpeg"><br><br>  Por lo tanto, obtenemos un m√©todo que le permite generar caras en 3D, y esta generaci√≥n est√° controlada por los siguientes par√°metros.  Como en la diapositiva anterior, tenemos dos conjuntos de par√°metros, dos vectores Œ± id y Œ± exp, son los mismos que en la diapositiva anterior, pero Œ± id es responsable de la forma de la cara, y Œ± exp ser√° responsable de la emoci√≥n. <br><br>  Tambi√©n aparece un nuevo vector T: un vector de textura.  Tiene la misma dimensi√≥n que el vector de forma, y ‚Äã‚Äãcada v√©rtice en este vector tiene tres valores RGB.  De manera similar, se genera un vector de textura utilizando el vector de par√°metros Œ≤.  Aqu√≠ no se formalizan los par√°metros que ser√°n responsables de iluminar la cara y su posici√≥n, sino que tambi√©n existen. <br><br><img src="https://habrastorage.org/webt/ab/bx/23/abbx2327nyov76ewuzl_s_fa9qo.jpeg"><br><br>  Aqu√≠ hay ejemplos de caras que se pueden generar utilizando un modelo deformado.  Tenga en cuenta que difieren en forma, color de piel y tambi√©n se dibujan en diferentes condiciones de iluminaci√≥n. <br><br><img src="https://habrastorage.org/webt/-n/ht/eu/-nhteuzhzcomppfvup80sevyhhc.jpeg"><br><br>  Ahora podemos pasar a la reconstrucci√≥n 3D.  Esto se llama el problema inverso, porque queremos seleccionar dichos par√°metros para el modelo deformable para que la cara que dibujemos sea lo m√°s similar posible al original.  Esta diapositiva difiere de la primera en que la cara aqu√≠ es completamente sint√©tica a la derecha.  Si en la primera diapositiva nuestra textura fue tomada de una fotograf√≠a, entonces aqu√≠ la textura fue tomada de un modelo deformable. <br><br>  En la salida, tendremos todos los par√°metros, en la diapositiva se presentan la identificaci√≥n Œ± y la Œ± exp, y tambi√©n tendremos iluminaci√≥n, par√°metros de textura, etc. <br><br><img src="https://habrastorage.org/webt/qa/ci/ql/qaciqlkbflxmqo1a1pzzn01g4d8.jpeg"><br><br>  Dijimos que queremos asegurarnos de que el modelo generado se vea como una fotograf√≠a.  Esta similitud se determina utilizando la funci√≥n de energ√≠a.  Aqu√≠ solo tomamos la diferencia p√≠xel por p√≠xel de las im√°genes en aquellos p√≠xeles en los que creemos que la cara es visible.  Por ejemplo, si se gira la cara, se producir√° una superposici√≥n.  Por ejemplo, parte del p√≥mulo estar√° cubierto por la nariz.  Y la matriz de visibilidad M deber√≠a mostrar tal superposici√≥n. <br><br>  En esencia, la reconstrucci√≥n 3D es para minimizar esta funci√≥n de energ√≠a.  Pero para resolver este problema de minimizaci√≥n, ser√≠a bueno tener inicializaci√≥n y regularizaci√≥n.  La regularizaci√≥n es necesaria por una raz√≥n obvia, ya que dijimos que si no regularizamos los par√°metros y los hacemos completamente arbitrarios, podemos obtener caras distorsionadas.  La inicializaci√≥n es necesaria porque la tarea en su conjunto es compleja, tiene m√≠nimos locales y no desea ocuparse de ellos. <br><br><img src="https://habrastorage.org/webt/jq/i-/ns/jqi-nskft-v7pvl8tadsmrldaco.jpeg"><br><br>  ¬øC√≥mo se puede hacer la inicializaci√≥n?  Para esto, puede usar 68 puntos clave de la cara.  Desde 2013-2014, han aparecido muchos algoritmos que permiten detectar 68 puntos con una precisi√≥n bastante buena, y ahora se est√°n acercando a una saturaci√≥n de su precisi√≥n.  Por lo tanto, tenemos una manera de detectar de manera confiable 68 puntos de la cara. <br><br>  Podemos agregar un nuevo t√©rmino a nuestra funci√≥n de energ√≠a, que dir√° que queremos que las proyecciones de los mismos 68 puntos del modelo coincidan con los puntos clave de la cara.  Marcamos estos puntos en el modelo, luego de alguna manera deformamos el modelo, lo giramos, proyectamos los puntos y nos aseguramos de que las posiciones de los puntos coincidan.  En la foto de la izquierda hay puntos de dos colores, violeta y amarillo.  El algoritmo detect√≥ algunos puntos, mientras que otros se proyectaron a partir del modelo.  Marcar puntos en el modelo a la derecha, pero para los puntos a lo largo del borde de la cara, no se marca un punto, sino una l√≠nea completa.  Esto se hace porque cuando se gira la cara, las marcas de estos puntos deben cambiar y el punto se selecciona con una l√≠nea. <br><br><img src="https://habrastorage.org/webt/sb/kg/n0/sbkgn0oajeqf_z-bleo0qfhzguy.jpeg"><br><br>  Aqu√≠ est√° el t√©rmino del que habl√©, es la diferencia de coordenadas de dos vectores que describen los puntos clave de la cara y los puntos clave proyectados desde el modelo. <br><br><img src="https://habrastorage.org/webt/wj/ku/eq/wjkueqaneclilvcxhbdsimu-gik.jpeg"><br><br>  Volvamos a la regularizaci√≥n y consideremos todo el problema desde la perspectiva de la conclusi√≥n bayesiana.  La probabilidad de que el vector Œ± sea igual a algo dado en una imagen conocida es proporcional al producto de la probabilidad de observar la imagen para un Œ± dado, multiplicado por la probabilidad Œ±.  Si tomamos el logaritmo negativo de esta expresi√≥n, que tendremos que minimizar, veremos que el t√©rmino responsable de la regularizaci√≥n tendr√° una forma concreta aqu√≠.  En particular, este es el segundo t√©rmino.  Recordando que previamente supusimos que el vector Œ± es gaussiano, vemos que el t√©rmino responsable de la regularizaci√≥n es la suma de los cuadrados de los par√°metros reducidos a variaciones a lo largo de los componentes principales. <br><br><img src="https://habrastorage.org/webt/9t/hj/y2/9thjy2x8qmvgcqxayk7rrddusra.jpeg"><br><br>  Entonces, podemos escribir la funci√≥n de energ√≠a completa, que contiene tres t√©rminos.  El primer t√©rmino es responsable de la textura, de la diferencia de p√≠xeles entre la imagen generada y la imagen objetivo.  El segundo t√©rmino es responsable de los puntos clave, y el tercero es responsable de la regularizaci√≥n. <br><br>  Los coeficientes de los t√©rminos en el proceso de minimizaci√≥n no est√°n optimizados, simplemente se establecen. <br>  Aqu√≠, la funci√≥n de energ√≠a se representa como una funci√≥n de todos los par√°metros.  Œ± id - par√°metros de forma de la cara, Œ± exp - par√°metros de expresi√≥n, Œ≤ - par√°metros de textura, p - otros par√°metros de los que hablamos pero no formalizamos, estos son par√°metros de posici√≥n e iluminaci√≥n. <br><br><img src="https://habrastorage.org/webt/tn/ki/np/tnkinpazftdmbqj3cyiij4vxn8s.jpeg"><br><br>  Deteng√°monos en este comentario.  Esta funci√≥n energ√©tica puede simplificarse.  A partir de √©l, puede descartar el t√©rmino responsable de la textura y utilizar solo la informaci√≥n transmitida por 68 puntos.  Y esto le permitir√° construir alg√∫n tipo de modelo 3D.  Sin embargo, preste atenci√≥n al perfil del modelo.  A la izquierda hay un modelo construido solo en puntos clave.  A la derecha hay un modelo que usa textura al construir.  Tenga en cuenta que el perfil de la derecha es m√°s consistente con la fotograf√≠a central, que representa la vista frontal de la cara. <br><br><img src="https://habrastorage.org/webt/r2/kp/p9/r2kpp94wnxg7vhfz1nha-ewl4xg.jpeg"><br><br>  La animaci√≥n con el algoritmo existente para construir un modelo 3D de la cara funciona de manera bastante simple.  Recuerde que al construir un modelo 3D, obtenemos dos vectores de par√°metros, uno responsable de la forma y el otro de la expresi√≥n.  Estos vectores de par√°metros para el usuario y el avatar siempre tendr√°n los suyos.  El usuario tiene un vector de par√°metros de formulario, el avatar tiene uno diferente.  Sin embargo, podemos hacer que los vectores responsables de la expresi√≥n se vuelvan iguales para ellos.  Tomaremos los par√°metros que son responsables de la expresi√≥n facial del usuario, y simplemente los sustituiremos en el modelo de avatar.  Por lo tanto, transferiremos la expresi√≥n facial del usuario al avatar. <br><br>  Hablemos de dos desaf√≠os en esta √°rea: la velocidad del trabajo y el modelo deformable limitado. <br><br><img src="https://habrastorage.org/webt/d8/s6/q8/d8s6q8yjlm76pcdoa2p4pavf-vw.jpeg"><br><br>  La velocidad es realmente un problema.  Minimizar la funci√≥n de energ√≠a total es una tarea computacionalmente intensiva.  En particular, puede tomar de 20 a 40, un promedio de 30 segundos.  Esto es lo suficientemente largo.  Si construimos un modelo tridimensional solo en puntos clave, resultar√° mucho m√°s r√°pido, pero la calidad se ver√° afectada por esto. <br><br><img src="https://habrastorage.org/webt/wk/se/zq/wksezqkjmdzs3v25feuanneaf84.jpeg"><br><br>  ¬øC√≥mo lidiar con este problema?  Puede usar m√°s recursos, algunas personas resuelven este problema en la GPU.  Solo se pueden usar puntos clave, pero la calidad se ver√° afectada.  Y puede usar m√©todos de aprendizaje autom√°tico. <br><br><img src="https://habrastorage.org/webt/p2/8m/fa/p28mfavfwitizfwss5fhreauviq.jpeg"><br><br>  A ver en orden.  Aqu√≠ est√° el trabajo de 2016, en el que la expresi√≥n facial del usuario se transfiere a un video espec√≠fico, puede controlar el video usando su cara.  Aqu√≠, la construcci√≥n del modelo 3D se lleva a cabo en tiempo real utilizando la GPU. <br><br><img src="https://habrastorage.org/webt/dn/qx/yj/dnqxyjywcjbx5yus2v7pvcyq8vm.jpeg"><br><br>  Estos son los m√©todos que utilizan el aprendizaje autom√°tico.  La idea es que primero podamos tomar una gran base de caras, para cada cara usando un algoritmo largo pero preciso para construir modelos 3D, presentar cada modelo como un conjunto de par√°metros y luego entrenar la cuadr√≠cula para predecir estos par√°metros.  En particular, en este trabajo de 2016, se utiliza ResNet, que lleva una imagen a la entrada y proporciona los par√°metros del modelo a la salida. <br><br><img src="https://habrastorage.org/webt/p6/ng/t6/p6ngt6gzn-4mps27709zhmeuzwk.jpeg"><br><br>  El modelo tridimensional se puede representar de otra manera.  En este trabajo de 2017, el modelo 3D se presenta no como un conjunto de par√°metros, sino como un conjunto de v√≥xeles.  La red predice v√≥xeles, convirtiendo la imagen en una representaci√≥n tridimensional.  Vale la pena se√±alar que las opciones de capacitaci√≥n en red son posibles para las cuales no se requieren modelos 3D. <br><br><img src="https://habrastorage.org/webt/yw/__/ot/yw__otysknuehp7kdjgikvziijc.jpeg"><br><br>  Esto funciona de la siguiente manera.  Aqu√≠ la parte m√°s importante es la capa, que puede tomar los par√°metros del modelo deformable como entrada y representar la imagen.  Tiene una propiedad tan maravillosa que a trav√©s de ella puede hacer la propagaci√≥n inversa del error.  La red acepta una imagen como entrada, predice los par√°metros, alimenta estos par√°metros a una capa que representa la imagen, compara esta imagen con la entrada, recibe un error, propaga el error y contin√∫a aprendiendo.  Por lo tanto, la red aprende a predecir los par√°metros del modelo tridimensional, teniendo solo im√°genes como datos de entrenamiento.  Y es muy interesante. <br><br><img src="https://habrastorage.org/webt/m_/kx/vc/m_kxvcoekvrrgp41k410ikd_viu.jpeg"><br><br>  Hablamos mucho sobre la precisi√≥n, en particular, que se resiente si descartamos algunos t√©rminos de la funci√≥n de la energ√≠a.  Formalicemos lo que esto significa, c√≥mo puede evaluar la precisi√≥n de la reconstrucci√≥n facial 3D.  Para hacer esto, necesitamos una base de escaneos de verdad y verdad obtenidos utilizando equipos especiales, utilizando m√©todos con respecto a los cuales hay algunas garant√≠as de precisi√≥n.  Si existe tal base, entonces podemos comparar nuestros modelos reconstruidos con la verdad b√°sica.  Esto se hace simplemente: calculamos la distancia promedio desde los v√©rtices de nuestro modelo, que construimos, hasta los v√©rtices en la verdad del terreno, y normalizamos al tama√±o del escaneo.  Esto debe hacerse porque las caras son diferentes, algunas son m√°s grandes, otras son m√°s peque√±as y el error en la cara peque√±a ser√≠a m√°s peque√±o, simplemente porque la cara misma es m√°s peque√±a.  Por lo tanto, se necesita normalizaci√≥n. <br><br><img src="https://habrastorage.org/webt/a0/us/rq/a0usrqlogscnks2yygnrestgf9o.jpeg"><br><br>  Me gustar√≠a hablar sobre nuestro trabajo, ser√° en talleres, hay ECCV.  Hacemos cosas similares, ense√±amos a MobileNet a predecir los par√°metros de un modelo deformable.  Como datos de entrenamiento, utilizamos modelos 3D creados para fotograf√≠as del conjunto de datos de 300W.  Evaluar la precisi√≥n basada en exploraciones BU4DFE. <br><br><img src="https://habrastorage.org/webt/oa/db/ha/oadbhaivdnukffi7vcdwye8vsmu.jpeg"><br><br>  Aqu√≠ est√° el resultado.  Comparamos nuestros dos algoritmos con el estado del arte.  La curva amarilla en este gr√°fico es un algoritmo que toma 30 segundos y consiste en minimizar la funci√≥n de energ√≠a total.  Aqu√≠, a lo largo del eje X, est√° el error del que acabamos de hablar, la distancia promedio entre los v√©rtices.  El eje Y es la fracci√≥n de im√°genes en las que este error es menor que el del eje X. En este gr√°fico, cuanto mayor sea la curva, mejor.  La siguiente curva es nuestra red basada en MobileNet.  A continuaci√≥n, los tres trabajos de los que hablamos.  Red predictiva de par√°metros y red predictiva de v√≥xel. <br><br><img src="https://habrastorage.org/webt/p3/ku/82/p3ku82pa5bgvee5_k7mj2w5bfne.jpeg"><br><br>  Tambi√©n comparamos nuestra red con sus pares en t√©rminos de tama√±o y velocidad del modelo.  Esto es una victoria porque usamos MobileNet, que es bastante f√°cil. <br><br>  El segundo desaf√≠o es la limitaci√≥n del modelo deformable. <br><br><img src="https://habrastorage.org/webt/u1/6a/9j/u16a9jeq3vc6lvwvc0hu82ymqd8.jpeg"><br><br>  Presta atenci√≥n a la cara izquierda, mira las alas de la nariz.  Hay sombras en las alas de la nariz.  Los bordes de las sombras no coinciden con los bordes de la nariz en la foto, por lo tanto, se obtiene un defecto.  La raz√≥n de esto puede ser que el modelo deformable, en principio, no puede construir la nariz de la forma requerida, porque este modelo deformable se obtuvo a partir de escaneos de solo 200 caras.  Nos gustar√≠a que la nariz sea correcta, como en la foto de la derecha.  Por lo tanto, tenemos que ir m√°s all√° del marco del modelo deformable. <br><br><img src="https://habrastorage.org/webt/eh/83/a5/eh83a5w3ovjb0t3v0d3slmazsgc.jpeg"><br><br>  Esto se puede hacer usando la deformaci√≥n no param√©trica de la malla.  Aqu√≠ hay tres tareas que nos gustar√≠a resolver: modificar la parte local de la cara, por ejemplo, la nariz, luego incrustarla en el modelo original de la cara, e incluso para que todo lo dem√°s permanezca sin cambios. <br><br><img src="https://habrastorage.org/webt/kr/dt/j5/krdtj5freppwfivlapbiqtlyz-y.jpeg"><br><br>  Esto se puede hacer de la siguiente manera.  Volvamos a la designaci√≥n de la malla como un vector en un espacio tridimensional y observemos el operador de promedio.  Este es un operador que en S con un encabezado reemplaza cada v√©rtice con el promedio de sus vecinos.  Los vecinos del pico son aquellos que est√°n conectados por un borde. <br><br>  Definiremos una determinada funci√≥n de energ√≠a que describa la posici√≥n del v√©rtice en relaci√≥n con sus vecinos.  Queremos que la posici√≥n del pico con respecto a sus vecinos permanezca sin cambios, o al menos no cambie mucho.  Pero al mismo tiempo, modificaremos de alguna manera S. Esta funci√≥n de energ√≠a se llama interna, porque tambi√©n habr√° alg√∫n t√©rmino externo, que dir√° que, por ejemplo, la nariz debe tomar una forma determinada. <br><br><img src="https://habrastorage.org/webt/9r/0g/-o/9r0g-o4tyxpzkzgfl_3bx7_xjue.jpeg"><br><br>  Dichas t√©cnicas se utilizaron, por ejemplo, en el trabajo de 2015.  Hicieron una reconstrucci√≥n facial en 3D a partir de varias fotograf√≠as.  Tomamos varias fotos desde el tel√©fono, recibimos una nube de puntos y luego adaptamos el modelo de rostro a esta nube usando modificaciones no param√©tricas. <br><br><img src="https://habrastorage.org/webt/1q/9c/yh/1q9cyhw6dspqkz57ese7dwbezyc.jpeg"><br><br>  Puede ir m√°s all√° del modelo deformable de otra manera.  Deteng√°monos en la acci√≥n del operador de suavizado.  Aqu√≠, por simplicidad, se presenta una malla bidimensional a la que se ha aplicado este operador.  Hay muchos detalles sobre el modelo a la izquierda; en el modelo a la derecha, estos detalles se han suavizado.  Pero, ¬øpodemos hacer algo para agregar detalles en lugar de eliminarlos? <br><br><img src="https://habrastorage.org/webt/5k/je/ir/5kjeirpdi5wtjeapi2v6h7tsxm8.jpeg"><br><br>          .          . <br><br>      ?    -:     -  .                   .      ,     2016 .     ,  . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es421353/">https://habr.com/ru/post/es421353/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es421343/index.html">Protecci√≥n de datos en la nube de Microsoft Office 365 con Veeam</a></li>
<li><a href="../es421345/index.html">Angular: caracter√≠sticas no obvias de los selectores de directivas</a></li>
<li><a href="../es421347/index.html">CORS, CSP, HTTPS, HSTS: acerca de las tecnolog√≠as de seguridad web</a></li>
<li><a href="../es421349/index.html">Desarrollo de una aplicaci√≥n web Nothing Progressive en 15 minutos</a></li>
<li><a href="../es421351/index.html">Teor√≠a de la felicidad. La maldici√≥n del director y las impresoras malditas</a></li>
<li><a href="../es421355/index.html">Go 1.11 lanzado - WebAssembly y m√≥dulos nativos</a></li>
<li><a href="../es421357/index.html">A la cuesti√≥n de lo imposible. Parte 3</a></li>
<li><a href="../es421359/index.html">El festival es como un juego. Taxonom√≠a de personas de TI</a></li>
<li><a href="../es421361/index.html">AMD ha abierto el c√≥digo fuente de V-EZ, una plataforma Vulkan API multiplataforma de bajo nivel</a></li>
<li><a href="../es421365/index.html">La evoluci√≥n de una startup. √Ågil de Yaytselov a Chiken Invaders</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>