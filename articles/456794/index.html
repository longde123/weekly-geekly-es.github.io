<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📹 🧒🏽 🌍 Arquitectura de la interfaz de usuario web: un pasado de madera, un presente extraño y un futuro brillante 🚠 🙌🏿 🎯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La comunidad moderna de desarrolladores está ahora más que nunca sujeta a la moda y las tendencias, y esto es especialmente cierto para el mundo del d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arquitectura de la interfaz de usuario web: un pasado de madera, un presente extraño y un futuro brillante</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456794/"><img src="https://habrastorage.org/webt/g1/rr/97/g1rr97vliagp-2dndxhmubahvrg.png" alt="imagen"><br><br>  La comunidad moderna de desarrolladores está ahora más que nunca sujeta a la moda y las tendencias, y esto es especialmente cierto para el mundo del desarrollo front-end.  Nuestros marcos y nuevas prácticas son el valor principal, y la mayoría de los CV, vacantes y programas de conferencias consisten en enumerarlos.  Y aunque el desarrollo de ideas y herramientas no es negativo en sí mismo, sino que debido al deseo constante de los desarrolladores de seguir tendencias evasivas, comenzamos a olvidar la importancia del conocimiento teórico general sobre la arquitectura de aplicaciones. <br><br>  La prevalencia del valor de ajuste sobre el conocimiento de la teoría y las mejores prácticas ha llevado al hecho de que la mayoría de los proyectos nuevos de hoy en día tienen un nivel extremadamente bajo de mantenimiento, creando así inconvenientes significativos para los desarrolladores (la alta complejidad constante de estudiar y modificar el código) y para los clientes (tasas bajas y alto costo de desarrollo). <br><br>  Para influir al menos de alguna manera en la situación actual, hoy me gustaría contarles sobre qué es una buena arquitectura, cómo es aplicable a las interfaces web y, lo más importante, cómo evoluciona con el tiempo. <br><br>  <i><b>NB</b> : Como ejemplos en el artículo, solo se usarán los marcos con los que el autor trató directamente, y se prestará una atención significativa a React y Redux aquí.</i>  <i>Pero, a pesar de esto, muchas de las ideas y principios descritos aquí son de naturaleza general y pueden proyectarse con más o menos éxito en otras tecnologías de desarrollo de interfaces.</i> <br><br><a name="habracut"></a><h2>  Arquitectura para tontos </h2><br>  Para comenzar, tratemos con el término en sí.  En palabras simples, la arquitectura de cualquier sistema es la definición de sus componentes y el esquema de interacción entre ellos.  Este es un tipo de base conceptual sobre la cual se implementará más adelante la implementación. <br><br>  La tarea de la arquitectura es satisfacer los requisitos externos para el sistema diseñado.  Estos requisitos varían de un proyecto a otro y pueden ser bastante específicos, pero en el caso general son para facilitar los procesos de modificación y expansión de las soluciones desarrolladas. <br><br>  En cuanto a la calidad de la arquitectura, generalmente se expresa en las siguientes propiedades: <br><br>  - <b>Acompañamiento</b> : la predisposición ya mencionada del sistema para estudiar y modificar (la dificultad de detectar y corregir errores, ampliar la funcionalidad, adaptar la solución a otro entorno o condiciones) <br>  - <b>Reemplazabilidad</b> : la capacidad de cambiar la implementación de cualquier elemento del sistema sin afectar a otros elementos <br>  - <b>Testabilidad</b> : la capacidad de verificar el correcto funcionamiento del elemento (la capacidad de controlar el elemento y observar su estado) <br>  - <b>Portabilidad</b> : la capacidad de reutilizar un elemento en otros sistemas <br>  - <b>Usabilidad</b> : el grado general de conveniencia del sistema cuando es operado por el usuario final <br><br>  También se menciona por separado uno de los principios clave de la construcción de una arquitectura de calidad: el principio de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">separación de preocupaciones</a> .  Consiste en el hecho de que cualquier elemento del sistema debe ser responsable exclusivamente de una sola tarea (aplicada, por cierto, al código de la aplicación: ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">principio de responsabilidad única</a> ). <br><br>  Ahora que tenemos una idea del concepto de arquitectura, veamos qué patrones de diseño arquitectónico nos pueden ofrecer en el contexto de las interfaces. <br><br><h2>  Las tres palabras mas importantes </h2><br>  Uno de los patrones más famosos de desarrollo de interfaz es MVC (Model-View-Controller), cuyo concepto clave es dividir la lógica de la interfaz en tres partes separadas: <br><br>  1. <b>Modelo</b> : es responsable de recibir, almacenar y procesar datos <br>  2. <b>Vista</b> : responsable de la visualización de datos <br>  3. <b>Controlador</b> : controla el modelo y la vista <br><br>  Este patrón también incluye una descripción de la interacción entre ellos, pero aquí esta información se omitirá debido al hecho de que después de algún tiempo al público en general se le presentó una modificación mejorada de este patrón llamado MVP (Model-View-Presenter), que es este esquema original interacción muy simplificada: <br><br><img src="https://habrastorage.org/webt/sv/j_/r2/svj_r22lb39syciykkximzlk-vy.png" alt="imagen"><br><br>  Como estamos hablando específicamente de interfaces web, utilizamos otro elemento bastante importante que generalmente acompaña a la implementación de estos patrones: un enrutador.  Su tarea es leer la URL y llamar a los presentadores asociados con ella. <br><br>  El esquema anterior funciona de la siguiente manera: <br><br>  1. El enrutador lee la URL y llama al presentador asociado <br>  2-5.  El presentador recurre al modelo y obtiene los datos necesarios de él. <br>  6. El presentador transfiere datos del Modelo a la Vista, lo que implementa su visualización. <br>  7. Durante la interacción del usuario con la interfaz, View notifica al presentador sobre esto, lo que nos devuelve al segundo punto <br><br>  Como ha demostrado la práctica, MVC y MVP no son una arquitectura ideal y universal, pero aún hacen una cosa muy importante: indican tres áreas clave de responsabilidad, sin las cuales no se puede implementar ninguna interfaz de una forma u otra. <br><br>  <i>NB: En general, los conceptos de Controlador y Presentador significan lo mismo, y la diferencia en su nombre es necesaria solo para diferenciar los patrones mencionados, que solo difieren en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">implementación de las comunicaciones</a> .</i> <br><br><h2>  MVC y representación del servidor </h2><br>  A pesar de que MVC es un patrón para implementar un cliente, también encuentra su aplicación en el servidor.  Además, es en el contexto del servidor que es más fácil demostrar los principios de su funcionamiento. <br><br>  En los casos en que se trata de sitios de información clásicos, donde la tarea del servidor web es generar páginas HTML para el usuario, MVC también nos permite organizar una arquitectura de aplicación bastante concisa: <br><br>  - El enrutador lee los datos de la solicitud HTTP recibida <i>(GET / user-profile / 1)</i> y llama al controlador asociado <i>(UsersController.getProfilePage (1))</i> <br>  - El controlador llama al Modelo para obtener la información necesaria de la base de datos <i>(UsersModel.get (1))</i> <br>  - El controlador pasa los datos recibidos a View <i>(View.render ('users / profile', user))</i> y recibe el marcado HTML de él, que lo devuelve al cliente <br><br>  En este caso, View generalmente se implementa de la siguiente manera: <br><br><img src="https://habrastorage.org/webt/1j/q6/_f/1jq6_frux0usp6akgw91lj3bq5o.png" alt="imagen"><br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> templates = { <span class="hljs-string"><span class="hljs-string">'users/profile'</span></span>: <span class="hljs-string"><span class="hljs-string">` &lt;div class="user-profile"&gt; &lt;h2&gt;{{ name}}&lt;/h2&gt; &lt;p&gt;E-mail: {{ email }}&lt;/p&gt; &lt;p&gt; Projects: {{#each projects}} &lt;a href="/projects/{{id}}"&gt;{{name}}&lt;/a&gt; {{/each}} &lt;/p&gt; &lt;a href=/user-profile/1/edit&gt;Edit&lt;/a&gt; &lt;/div&gt; `</span></span> }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span></span>{ render(templateName, data) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> htmlMarkup = TemplateEngine.render(templates[templateName], data); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> htmlMarkup; } }</code> </pre> <br>  <i>NB: el código anterior se ha simplificado intencionalmente para usarlo como ejemplo.</i>  <i>En proyectos reales, las plantillas se exportan a archivos separados y pasan por la etapa de compilación antes de su uso (ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Handlebars.compile ()</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">_.template ()</a> ).</i> <br><br>  Aquí se utilizan los llamados motores de plantillas, que nos proporcionan herramientas para una descripción conveniente de las plantillas de texto y mecanismos para sustituir datos reales en ellos. <br><br>  Tal enfoque para la implementación de View no solo demuestra una separación ideal de responsabilidades, sino que también proporciona un alto grado de comprobabilidad: para verificar la exactitud de la pantalla, es suficiente para nosotros comparar la línea de referencia con la línea que obtuvimos del motor de plantillas. <br><br>  Por lo tanto, al usar MVC, obtenemos una arquitectura casi perfecta, donde cada uno de sus elementos tiene un propósito muy específico, conectividad mínima y también tiene un alto nivel de capacidad de prueba y portabilidad. <br><br>  En cuanto al enfoque con la generación de marcado HTML utilizando herramientas de servidor, debido a la baja UX, este enfoque gradualmente comenzó a ser reemplazado por SPA. <br><br><h2>  Backbone y MVP </h2><br>  Uno de los primeros marcos para llevar completamente la lógica de visualización al cliente fue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Backbone.js</a> .  La implementación de Router, Presenter y Model en ella es bastante estándar, pero la nueva implementación de View merece nuestra atención: <br><br><img src="https://habrastorage.org/webt/e6/iv/ye/e6ivye6jq6mo0gq_r1re8fua5uq.png" alt="imagen"><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UserProfile = Backbone.View.extend({ <span class="hljs-attr"><span class="hljs-attr">tagName</span></span>: <span class="hljs-string"><span class="hljs-string">'div'</span></span>, <span class="hljs-attr"><span class="hljs-attr">className</span></span>: <span class="hljs-string"><span class="hljs-string">'user-profile'</span></span>, <span class="hljs-attr"><span class="hljs-attr">events</span></span>: { <span class="hljs-string"><span class="hljs-string">'click .button.edit'</span></span>: <span class="hljs-string"><span class="hljs-string">'openEditDialog'</span></span>, }, <span class="hljs-attr"><span class="hljs-attr">openEditDialog</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... }, initialize: function() { this.listenTo(this.model, 'change', this.render); }, template: _.template(` &lt;h2&gt;&lt;%= name %&gt;&lt;/h2&gt; &lt;p&gt;E-mail: &lt;%= email %&gt;&lt;/p&gt; &lt;p&gt; Projects: &lt;% _.each(projects, project =&gt; { %&gt; &lt;a href="/projects/&lt;%= project.id %&gt;"&gt;&lt;%= project.name %&gt;&lt;/a&gt; &lt;% }) %&gt; &lt;/p&gt; &lt;button class="edit"&gt;Edit&lt;/button&gt; `), render: function() { this.$el.html(this.template(this.model.attributes)); } });</span></span></code> </pre><br>  Obviamente, la implementación del mapeo se ha vuelto mucho más complicada: se ha agregado a la estandarización elemental escuchar los eventos del modelo y el DOM, así como la lógica de su procesamiento.  Además, para mostrar los cambios en la interfaz, es altamente deseable no volver a renderizar completamente la Vista, sino hacer un trabajo más fino con elementos DOM específicos (generalmente usando jQuery), lo que requiere escribir mucho código adicional. <br><br>  Debido a la complicación general de la implementación de View, sus pruebas se volvieron más complicadas, ya que ahora estamos trabajando directamente con el árbol DOM, para las pruebas necesitamos usar herramientas adicionales que proporcionen o emulen el entorno del navegador. <br><br>  Y los problemas con la nueva implementación de View no terminaron allí: <br><br>  Además de lo anterior, es bastante difícil de usar anidado en la Vista de cada uno.  Con el tiempo, este problema se resolvió con la ayuda de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Regions</a> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Marionette.js</a> , pero antes de eso, los desarrolladores tuvieron que inventar sus propios trucos para resolver este problema bastante simple y que a menudo surge. <br><br>  Y el último.  Las interfaces diseñadas de esta manera estaban predispuestas a datos no sincronizados, ya que todos los modelos existían aislados a nivel de diferentes presentadores, luego, al cambiar los datos en una parte de la interfaz, generalmente no se actualizaban en otra. <br><br>  Pero, a pesar de estos problemas, este enfoque fue más que viable, y el desarrollo mencionado anteriormente de Backbone en forma de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Marionette</a> todavía se puede aplicar con éxito para el desarrollo de SPA. <br><br><h2>  Reaccionar y vacío </h2><br>  Es difícil de creer, pero en el momento de su lanzamiento inicial, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">React.js</a> causó mucho escepticismo entre la comunidad de desarrolladores.  Este escepticismo fue tan grande que durante mucho tiempo se publicó el siguiente texto en el sitio web oficial: <br><br><blockquote>  Dale cinco minutos <br>  Reaccionar desafía mucha sabiduría convencional, y a primera vista algunas de las ideas pueden parecer locas. </blockquote><br>  Y esto a pesar del hecho de que, a diferencia de la mayoría de sus competidores y predecesores, React no era un marco completo y era solo una pequeña biblioteca para facilitar la visualización de datos en el DOM: <br><br><blockquote>  React es una biblioteca de JavaScript para crear interfaces de usuario de Facebook e Instagram.  Muchas personas optan por pensar en React como la V en MVC. <br></blockquote><br>  El concepto principal que nos ofrece React es el concepto de un componente, que, de hecho, nos proporciona una nueva forma de implementar View: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ handleEdit() { <span class="hljs-comment"><span class="hljs-comment">// .. } render() { const { name, email, projects } = this.props; return ( &lt;div className="user-profile"&gt; &lt;h2&gt;{name}&lt;/h2&gt; &lt;p&gt;E-mail: {email}&lt;/p&gt; &lt;p&gt; Projects: { projects.map(project =&gt; &lt;a href="/projects/{project.id}"&gt;{project.name}&lt;/a&gt;) } &lt;/p&gt; &lt;button onClick={this.handleEdit}&gt;Edit&lt;/button&gt; &lt;/div&gt; ); } }</span></span></code> </pre> <br>  Reaccionar fue increíblemente agradable de usar.  Entre sus ventajas innegables se encontraban hasta el día de hoy: <br><br>  1) <b>Declaración y reactividad</b> .  Ya no es necesario actualizar manualmente el DOM al cambiar los datos mostrados. <br><br>  2) <b>La composición de los componentes</b> .  Construir y explorar el árbol de Vista se ha convertido en una acción completamente elemental. <br><br>  Pero, desafortunadamente, React tiene varios problemas.  Uno de los más importantes es el hecho de que React no es un marco completo y, por lo tanto, no nos ofrece ningún tipo de arquitectura de aplicación o herramientas completas para su implementación. <br><br>  ¿Por qué esto está escrito en defectos?  Sí, porque ahora React es la solución más popular para desarrollar aplicaciones web ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">prueba</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">otra prueba</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">y otra prueba</a> ), es un punto de entrada para los nuevos desarrolladores front-end, pero al mismo tiempo no ofrece ni promueve arquitectura, ni enfoques y mejores prácticas para construir aplicaciones completas.  Además, inventa y promueve sus propios enfoques personalizados como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HOC</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hooks</a> , que no se usan fuera del ecosistema React.  Como resultado, cada aplicación React resuelve problemas típicos a su manera, y generalmente no lo hace de la manera más correcta. <br><br>  Este problema se puede demostrar con la ayuda de uno de los errores más comunes de los desarrolladores de React, que consiste en el abuso de componentes: <br><br><blockquote>  Si la única herramienta que tienes es un martillo, todo comienza a parecerse a un clavo. </blockquote><br>  Con su ayuda, los desarrolladores resuelven una gama completamente impensable de tareas que van mucho más allá del alcance de la visualización de datos.  En realidad, con la ayuda de componentes, implementan absolutamente todo, desde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">consultas de medios</a> desde CSS hasta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enrutamiento</a> . <br><br><h2>  Reaccionar y Redux </h2><br>  La restauración del orden en la estructura de las aplicaciones React se vio facilitada en gran medida por la aparición y popularización de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Redux</a> .  Si React es una vista de MVP, entonces Redux nos ofreció una variación bastante conveniente de Model. <br><br>  La idea principal de Redux es la transferencia de datos y la lógica de trabajar con ellos en un único almacén de datos centralizado: el denominado Almacén.  Este enfoque resuelve completamente el problema de la duplicación y desincronización de datos, del que hablamos un poco antes, y también ofrece muchas otras comodidades, que, entre otras cosas, incluyen la facilidad de estudiar el estado actual de los datos en la aplicación. <br><br>  Otra característica igualmente importante es la forma de comunicación entre la Tienda y otras partes de la aplicación.  En lugar de acceder directamente a la Tienda o sus datos, se nos ofrece usar las llamadas Acciones (objetos simples que describen el evento o comando), que proporcionan un nivel débil de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">acoplamiento flojo</a> entre la Tienda y la fuente del evento, lo que aumenta significativamente el grado de mantenimiento del proyecto.  Por lo tanto, Redux no solo obliga a los desarrolladores a utilizar enfoques arquitectónicos más correctos, sino que también le permite aprovechar las diversas ventajas del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">abastecimiento</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">eventos</a> : ahora en el proceso de depuración podemos ver fácilmente el historial de acciones en la aplicación, su impacto en los datos y, si es necesario, toda esta información puede exportarse , que también es extremadamente útil al analizar errores de producción. <br><br>  El esquema general de la aplicación que usa React / Redux se puede representar de la siguiente manera: <br><br><img src="https://habrastorage.org/webt/rw/x6/8f/rwx68f3sxe_rrnh609ul6rmgrsw.png" alt="imagen"><br><br>  Los componentes de reacción siguen siendo responsables de mostrar los datos.  Idealmente, estos componentes deben ser limpios y funcionales, pero si es necesario, pueden tener un estado local y una lógica asociada (por ejemplo, para implementar la ocultación / visualización de un elemento específico o el preprocesamiento básico de una acción del usuario). <br><br>  Cuando un usuario realiza una acción en la interfaz, el componente simplemente llama a la función de controlador correspondiente, que recibe del exterior junto con los datos para su visualización. <br><br>  Los llamados componentes de contenedor actúan como presentadores para nosotros: son los que ejercen el control sobre los componentes de la pantalla y su interacción con los datos.  Se crean utilizando la función de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conexión</a> , que amplía la funcionalidad del componente que se le pasa, agregando una suscripción para cambiar los datos en la Tienda y permitiéndonos determinar qué manejadores de datos y eventos se le deben pasar. <br><br>  Y si todo está claro con los datos aquí (simplemente asignamos datos del almacenamiento a los "accesorios" esperados), entonces me gustaría detenerme en los controladores de eventos con más detalle: no solo envían Acciones a la Tienda, sino que también pueden contener lógica adicional para procesar el evento. por ejemplo, incluir ramificación, realizar redireccionamientos automáticos y realizar cualquier otro trabajo específico para el presentador. <br><br>  Otro punto importante con respecto a los componentes del contenedor: debido al hecho de que se crean a través del HOC, los desarrolladores a menudo describen componentes de visualización y componentes del contenedor dentro de un solo módulo y exportan solo el contenedor.  Este no es el enfoque correcto, ya que para la posibilidad de probar y reutilizar el componente de visualización, debe estar completamente separado del contenedor y preferiblemente extraído en un archivo separado. <br><br>  Bueno, lo último que aún no hemos considerado es la Tienda.  Nos sirve como una implementación bastante específica del Modelo y consta de varios componentes: Estado (un objeto que contiene todos nuestros datos), Middleware (un conjunto de funciones que preprocesan todas las Acciones recibidas), Reductor (una función que modifica los datos en Estado) y algunos o un controlador de efectos secundarios responsable de ejecutar operaciones asincrónicas (acceder a sistemas externos, etc.). <br><br>  El problema más común aquí es la forma de nuestro Estado.  Formalmente, Redux no nos impone ninguna restricción y no da recomendaciones sobre cuál debería ser este objeto.  Los desarrolladores pueden almacenar absolutamente cualquier información en él (incluido el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">estado de los formularios</a> y la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">información del enrutador</a> ), estos datos pueden ser de cualquier tipo (no está <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">prohibido</a> almacenar incluso funciones e instancias de objetos) y tener cualquier nivel de anidamiento.  De hecho, esto nuevamente lleva al hecho de que de un proyecto a otro obtenemos un enfoque completamente diferente al uso de State, lo que una vez más causa cierto desconcierto. <br><br>  Para empezar, aceptamos que no tenemos que mantener absolutamente todos los datos de la aplicación en el estado; esto se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">indica</a> claramente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en la documentación</a> .  Aunque almacenar parte de los datos dentro del estado de los componentes crea ciertos inconvenientes al navegar por el historial de acciones durante el proceso de depuración (el estado interno de los componentes siempre permanece sin cambios), la transferencia de estos datos al Estado crea aún más dificultades: esto aumenta significativamente su tamaño y requiere la creación de aún más Acciones y reductores. <br><br>  En cuanto al almacenamiento de cualquier otro dato local en estado, generalmente tratamos con alguna configuración de interfaz general, que es un conjunto de pares clave-valor.  En este caso, podemos hacerlo fácilmente con un objeto simple y un reductor para él. <br><br>  Y si estamos hablando de almacenar datos de fuentes externas, en función del hecho de que en el desarrollo de interfaces en la gran mayoría de los casos estamos tratando con CRUD clásico, entonces para almacenar datos del servidor tiene sentido tratar State como un RDBMS: las claves son el nombre recursos, y detrás de ellos hay matrices almacenadas de objetos cargados ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sin anidamiento</a> ) e información opcional para ellos (por ejemplo, el número total de registros en el servidor para crear paginación).  La forma general de estos datos debe ser lo más uniforme posible; esto nos permitirá simplificar la creación de reductores para cada tipo de recurso: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getModelReducer = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">modelName</span></span></span><span class="hljs-function"> =&gt;</span></span> (models = [], action) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isModelAction = modelActionTypes.includes(action.type); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isModelAction &amp;&amp; action.modelName === modelName) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'ADD_MODELS'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collection.add(action.models, models); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'CHANGE_MODEL'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collection.change(action.model, models); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'REMOVE_MODEL'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collection.remove(action.model, models); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'RESET_STATE'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> []; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> models; };</code> </pre> <br>  Bueno, otro punto que me gustaría discutir en el contexto del uso de Redux es la implementación de efectos secundarios. <br><br>  En primer lugar, olvídate por completo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Redux Thunk</a> : la transformación de las acciones propuestas por él en funciones con efectos secundarios, aunque es una solución funcional, pero combina los conceptos básicos de nuestra arquitectura y reduce sus ventajas a nada.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Redux Saga</a> nos ofrece un enfoque mucho más correcto para implementar efectos secundarios, aunque hay algunas preguntas con respecto a su implementación técnica. <br><br>  A continuación, intente unificar lo más posible sus efectos secundarios que acceden al servidor.  Al igual que la forma de estado y los reductores, casi siempre podemos implementar la lógica de crear solicitudes al servidor utilizando un único controlador.  Por ejemplo, en el caso de la API RESTful, esto se puede lograr escuchando acciones generalizadas como: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'CREATE_MODEL'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: { <span class="hljs-attr"><span class="hljs-attr">model</span></span>: <span class="hljs-string"><span class="hljs-string">'reviews'</span></span>, <span class="hljs-attr"><span class="hljs-attr">attributes</span></span>: { <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'...'</span></span>, <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">'...'</span></span> } } }</code> </pre><br>  ... y creando las mismas solicitudes HTTP generalizadas en ellos: <br><br><pre> <code class="plaintext hljs">POST /api/reviews { title: '...', text: '...' }</code> </pre> <br>  Siguiendo conscientemente todos los consejos anteriores, puede obtener, si no una arquitectura ideal, al menos cerca de ella. <br><br><h2>  Futuro brillante </h2><br>  El desarrollo moderno de las interfaces web realmente ha dado un importante paso adelante, y ahora estamos viviendo en un momento en que una parte importante de los principales problemas ya se han resuelto de una forma u otra.  Pero esto no significa en absoluto que en el futuro no habrá nuevas revoluciones. <br><br>  Si intenta mirar hacia el futuro, lo más probable es que veamos lo siguiente: <br><br>  <b>1. Enfoque de componentes sin JSX</b> <br><br>  El concepto de componentes ha demostrado ser extremadamente exitoso y, muy probablemente, veremos su popularización aún mayor.  Pero JSX en sí puede y debe morir.  Sí, es realmente bastante conveniente de usar, pero, sin embargo, no es un estándar generalmente aceptado ni un código JS válido.  Las bibliotecas para implementar interfaces, sin importar cuán buenas sean, no deberían inventar nuevos estándares, que luego deben implementarse una y otra vez en cada posible kit de herramientas de desarrollo. <br><br>  <b>2. Contenedores estatales sin Redux</b> <br><br>  El uso de un almacén de datos centralizado, propuesto por Redux, también fue una solución extremadamente exitosa, y en el futuro debería convertirse en una especie de estándar en el desarrollo de interfaces, pero su arquitectura interna y su implementación pueden sufrir ciertos cambios y simplificaciones. <br><br>  <b>3. Mejora de la intercambiabilidad de la biblioteca.</b> <br><br>  Creo que con el tiempo, la comunidad de desarrolladores front-end se dará cuenta de los beneficios de maximizar la intercambiabilidad de la biblioteca y dejará de encerrarse en sus pequeños ecosistemas.  Todos los componentes de las aplicaciones (enrutadores, contenedores de estado, etc.) deben ser extremadamente universales y su reemplazo no debe requerir una refactorización masiva o una reescritura de la aplicación desde cero. <br><br><h2>  ¿Por qué todo esto? </h2><br>  Si tratamos de generalizar la información presentada anteriormente y reducirla a una forma más simple y corta, obtenemos algunos puntos bastante generales: <br><br>  - Para el desarrollo exitoso de aplicaciones, el conocimiento del lenguaje y el marco no es suficiente, se debe prestar atención a las cosas teóricas generales: arquitectura de aplicaciones, mejores prácticas y patrones de diseño. <br><br>  "La única constante es el cambio".  Los enfoques de labranza y desarrollo continuarán cambiando, por lo que los proyectos grandes y de larga duración deben prestar la debida atención a la arquitectura; sin ella, la introducción de nuevas herramientas y prácticas será extremadamente difícil. <br><br>  Y eso es probablemente todo para mí.  Muchas gracias a todos los que encontraron la fuerza para leer el artículo hasta el final.  Si tiene alguna pregunta o comentario, lo invito a comentar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/456794/">https://habr.com/ru/post/456794/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../456774/index.html">Lo que extraño en Java después de trabajar con Kotlin / Scala</a></li>
<li><a href="../456780/index.html">9 maneras de impulsar la eficiencia del desarrollador de aplicaciones móviles</a></li>
<li><a href="../456782/index.html">Diseño orientado a modelos: cómo no repetir Chernobyl</a></li>
<li><a href="../456790/index.html">Resumen de noticias de PostgreSQL. Edición n. 16</a></li>
<li><a href="../456792/index.html">Implemente Kubernetes Cluster en OpenStack con Kubespray</a></li>
<li><a href="../456796/index.html">Svalbard - nuevo nombre para el proyecto Have I Been Pwned antes de la venta</a></li>
<li><a href="../456798/index.html">Tutoriales de SDL 2: Lección 5 - Texturas</a></li>
<li><a href="../456804/index.html">Siga el dinero: cómo el grupo RTM comenzó a ocultar las direcciones de los servidores C&C en una billetera criptográfica</a></li>
<li><a href="../456806/index.html">Un bot de todas las preocupaciones</a></li>
<li><a href="../456808/index.html">Cómo mejorar el rendimiento de las aplicaciones web front-end: cinco consejos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>