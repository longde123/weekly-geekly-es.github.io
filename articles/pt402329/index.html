<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ûñ üì≠ üôèüèª Memo. AVR Buzic üîÑ üëêüèΩ ‚è©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Essence 
 Eu j√° criei v√°rios dispositivos eletr√¥nicos de hobby diferentes e tenho uma caracter√≠stica estranha: se houver um emissor piezoel√©trico (cam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memo. AVR Buzic</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/402329/"><img src="https://habrastorage.org/files/a62/a7b/0f9/a62a7b0f93e34b378c415b8d4b1873bb.jpg"><br><h3>  Essence </h3><br>  Eu j√° criei v√°rios dispositivos eletr√¥nicos de hobby diferentes e tenho uma caracter√≠stica estranha: se houver um emissor piezoel√©trico (campainha) no quadro, depois de terminar o trabalho principal do projeto, come√ßo a sofrer besteiras e faz√™-lo tocar v√°rias melodias (o m√°ximo poss√≠vel) )  √â especialmente √∫til incluir uma melodia no final de um longo processo para atrair aten√ß√£o.  Por exemplo, usei-o quando constru√≠ uma c√¢mera de exposi√ß√£o improvisada para iluminar o fotorresistente etc. <br><br>  Mas quando comecei a procurar exemplos de gera√ß√£o de frequ√™ncia para AVR na rede, por algum motivo me deparei com projetos monstruosos ou insuficientemente concisos implementando a gera√ß√£o de frequ√™ncia sonora de maneira puramente program√°tica.  E ent√£o eu decidi descobrir isso sozinho ... <br><a name="habracut"></a><br><h3>  Digress√£o l√≠rica </h3><br>  Meu hobby inclui a cria√ß√£o de v√°rios dispositivos em microcontroladores, porque isso n√£o se cruza com o meu professor.  atividade (desenvolvimento de software), eu me considero um autodidata absoluto, e em eletr√¥nica n√£o √© muito forte.  Na verdade, eu prefiro microcontroladores PIC, mas aconteceu que acumulei um certo n√∫mero de microcontroladores Atmel AVR (agora Microchip).  Fa√ßa imediatamente uma reserva de que eu nunca tinha o AVR em minhas m√£os, ou seja,  Este √© o meu primeiro projeto no Atmel MCU, o Atmega48pa.  O projeto em si realiza alguma carga √∫til, mas aqui descreverei apenas parte dele relacionada √† gera√ß√£o de frequ√™ncias sonoras.  O teste para gerar frequ√™ncias chamei de "buzic", como uma abrevia√ß√£o de m√∫sica de campainha.  Sim, eu quase esqueci: no Habr, existe um usu√°rio com o apelido <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">buzic</a> , eu queria avisar imediatamente que esse memorando n√£o se aplica a ele de nenhuma maneira e, apenas no caso, pe√ßo desculpas imediatamente por usar a combina√ß√£o de letras "Buzic". <br><br><h3>  Ent√£o vamos </h3><br>  Eu me familiarizei com um grande n√∫mero de exemplos da rede - todos eles s√£o constru√≠dos no ciclo mais simples no corpo principal do firmware ou na interrup√ß√£o do temporizador.  Mas todos eles usam a mesma abordagem para gerar frequ√™ncia: <br><br><ol><li>  alimente um n√≠vel alto ao p√© do microcontrolador </li><li>  atrasar </li><li>  alimenta√ß√£o baixa ao p√© do microcontrolador </li></ol><br>  Altera√ß√£o dos atrasos e das configura√ß√µes do timer - ajuste a frequ√™ncia. <br><br>  Essa abordagem n√£o me agradou muito, porque  Eu n√£o queria escrever c√≥digo para o controle manual do p√© do microcontrolador.  Eu gostaria que a ‚Äúpedra‚Äù gerasse a frequ√™ncia do som para mim e apenas defina os valores de certos registros, alterando-a (frequ√™ncia). <br><br>  Ao estudar a folha de dados (doravante denominada DS), ainda encontrei o modo de timer que eu precisava - e esse modo, como voc√™ deve ter adivinhado, √© o modo CTC (Clear Timer on Compare Match).  Como a fun√ß√£o de tocar m√∫sica n√£o √©, para dizer o m√≠nimo, a principal funcionalidade, preferi selecionar o temporizador 2 para ela (par√°grafo 22 do SD). <br><br>  Todo mundo sabe que praticamente qualquer microcontrolador tem um modo de gera√ß√£o de sinal PWM que √© implementado em temporizadores e √© completamente hardware.  Mas nesta tarefa, o PWM n√£o √© adequado porque  apenas uma frequ√™ncia ser√° gerada no hardware.  Portanto, precisamos de PFM (modula√ß√£o de frequ√™ncia de pulso).  Alguma similaridade do PFM √© o modo do temporizador CTC (cl√°usula 22.7.2 LH). <br><br><h3>  Modo CTC </h3><br>  O temporizador 2 no microcontrolador Atmega48pa √© de 8 bits, ou seja, ‚Äúmarca‚Äù de 0 a 255 e depois circula.  A prop√≥sito, o cron√¥metro pode ir em uma dire√ß√£o diferente, mas n√£o no nosso caso.  O pr√≥ximo componente necess√°rio √© a Unidade de compara√ß√£o.  Falando muito grosseiramente, este m√≥dulo √© o iniciador de qualquer evento relacionado ao cron√¥metro.  Os eventos podem ser diferentes - como interrup√ß√µes, mudan√ßas no n√≠vel de certas pernas do microcontrolador, etc. (Obviamente, estamos interessados ‚Äã‚Äãno segundo).  Como voc√™ pode imaginar, o m√≥dulo de compara√ß√£o n√£o √© apenas nomeado - ele compara um valor espec√≠fico selecionado pelo desenvolvedor do firmware com o valor atual do timer.  Se o valor do timer atingir o valor definido, ocorrer√° um evento.  Eventos tamb√©m podem ocorrer quando o cron√¥metro exceder o limite ou durante uma redefini√ß√£o.  <b>Ok, chegamos √† conclus√£o de que √© conveniente para n√≥s, em determinados momentos, que o timer, juntamente com o m√≥dulo de compara√ß√£o, altere independentemente o n√≠vel no p√© do microcontrolador para o oposto - gerando pulsos.</b> <br><br>  A segunda tarefa √© definir os intervalos entre esses pulsos - ou seja,  controlar a frequ√™ncia de gera√ß√£o.  Toda a singularidade do modo CTC reside no fato de que, neste modo, o temporizador n√£o chega ao fim (255), mas √© redefinido quando o valor definido √© atingido.  Assim, alterando esse valor, podemos realmente controlar a frequ√™ncia.  Por exemplo, se definirmos o valor do m√≥dulo de compara√ß√£o como 10, a mudan√ßa de n√≠vel no p√© do microcontrolador ocorrer√° 20 vezes mais frequentemente do que se o configur√°ssemos (o valor do m√≥dulo de compara√ß√£o) para 200. <b>Agora podemos controlar a frequ√™ncia!</b> <br><br><img src="https://habrastorage.org/files/d45/90e/b7a/d4590eb7acd543a59fc71057cc6ae5b5.png"><br><br><h3>  Ferro </h3><br><img src="https://habrastorage.org/files/8f9/dbb/8f5/8f9dbb8f514f4819863dff1a4dff4690.png"><br>  A pinagem do microcontrolador mostra que precisamos conectar nossa campainha √† perna do PB3 (OC2A) ou √† perna do PD3 (OC2B), porque  OC2A e OC2B significam exatamente que nessas pernas, o timer 2 pode gerar sinais. <br><br>  O esquema que eu costumo usar para conectar a campainha √©: <br><img src="https://habrastorage.org/files/8c8/a1e/7c6/8c8a1e7c67cf433989b5b94b89fa3e55.png"><br><br>  <b>E assim montamos o dispositivo.</b> <br><br><h3>  Registros </h3><br>  No par√°grafo anterior, decidimos sobre a escolha da perna - este √© o PB3 (OC2A), vamos trabalhar com ele.  Se voc√™ precisar de PD3, para ela tudo ser√° o mesmo, o que ser√° claramente vis√≠vel na hist√≥ria. <br><br>  Vamos configurar nosso timer 2 alterando 3 registros: <br><ol><li>  TCCR2A - configura√ß√µes de modo e sele√ß√£o de comportamento </li><li>  TCCR2B - configura√ß√µes de modo e divisor de frequ√™ncia do temporizador (tamb√©m bits FOC - n√£o os usamos) </li><li>  OCR2A (OCR2B para o estojo PD3) - valor do m√≥dulo de compara√ß√£o </li></ol><br><br>  Considere primeiro os registros TCCR2A e TCCR2B <br><img src="https://habrastorage.org/files/37b/def/522/37bdef52208b48b381b06405d9eddcb5.png"><br>  Como voc√™ pode ver, temos 3 grupos de bits que s√£o significativos para n√≥s - estes s√£o bits das s√©ries COM2xx, WGM2x e CS2x <br>  A primeira coisa que precisamos mudar √© o WGM2x - essa √© a principal op√ß√£o para escolher o modo de gera√ß√£o - esses bits s√£o usados ‚Äã‚Äãpara selecionar o modo CTC. <br><br><img src="https://habrastorage.org/files/f34/28d/3e3/f3428d3e3ecc4e1aafcef3c82b061d23.png"><br>  <i>nota: obviamente, no LH, o erro de digita√ß√£o em "Atualiza√ß√£o do OCR0x em" deve ser OCR2x</i> <br><br>  I.e.  o c√≥digo ser√° assim: <br><pre><code class="cpp hljs">TCCR2A = _BV(WGM21) ;</code> </pre> <br>  Como voc√™ pode ver, o TCCR2B ainda n√£o √© usado.  WGM22 deve ser zero, mas j√° √© zero. <br><br>  O pr√≥ximo passo √© configurar os bits COM2xx, mais precisamente COM2Ax - porque  trabalhamos com a perna PB3 (para PD3, COM2Bx s√£o usados ‚Äã‚Äãde maneira semelhante).  O que acontecer√° com a nossa perna PB3 depende deles. <br><br>  Os bits COM2xx dependem do modo que selecionamos com os bits WGM2x, portanto, teremos que encontrar a se√ß√£o correspondente no LH.  Porque  temos o modo CTC, ou seja,  PWM, procure a placa ‚ÄúCompare Output Mode, non-PWM‚Äù, aqui est√°: <br><img src="https://habrastorage.org/files/771/054/3e2/7710543e25404353b1c1056cd3a58483.png"><br>  Aqui voc√™ precisa selecionar "Alternar" - para que o n√≠vel na perna mude para o oposto quando o timer atingir o valor definido.  A mudan√ßa constante de n√≠vel e implementa a gera√ß√£o da frequ√™ncia que precisamos. <br><br>  Porque  os bits COM2xx tamb√©m est√£o no registro TCCR2A - somente ele muda: <br><pre> <code class="cpp hljs">TCCR2A = _BV(COM2A0) | _BV(WGM21) ;</code> </pre><br>  Naturalmente, voc√™ tamb√©m precisa selecionar o divisor de frequ√™ncia com bits CS2x e, √© claro, definir o p√© PB3 para a sa√≠da ... mas ainda n√£o o faremos para que, quando ligarmos o MK, n√£o obteremos um grito agudo a uma frequ√™ncia incompreens√≠vel, mas quando fizermos todas as outras configura√ß√µes e ligue o p√© para sair - ser√° descrito abaixo. <br><br>  Ent√£o, vamos dar uma olhada completa na nossa inicializa√ß√£o: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;avr/io.h&gt; //set bit - using bitwise OR operator #define sbi(x,y) x |= _BV(y) //clear bit - using bitwise AND operator #define cbi(x,y) x &amp;= ~(_BV(y)) #define BUZ_PIN PB3 void timer2_buzzer_init() { // PB3 cbi(PORTB, BUZ_PIN); // PB3  ,    cbi(DDRB, BUZ_PIN); //  TCCR2A = _BV(COM2A0) | _BV(WGM21) ; //   (      ) OCR2A = 0; }</span></span></span></span></code> </pre><br>  Usei as macros cbi e sbi (espionadas em algum lugar da rede) para definir bits individuais e as deixei assim.  Essas macros, √© claro, foram colocadas no arquivo de cabe√ßalho, mas para maior clareza, eu as coloquei aqui. <br><br><h3>  C√°lculo da frequ√™ncia e dura√ß√£o das notas </h3><br>  Agora chegamos √† ess√™ncia da quest√£o.  H√° algum tempo, conhecidos de m√∫sicos tentaram introduzir no meu c√©rebro um programador com algumas informa√ß√µes sobre a equipe musical, meu c√©rebro quase ferveu, mas ainda assim eu trouxe um gr√£o √∫til dessas conversas. <br>  Eu o aviso imediatamente - s√£o poss√≠veis grandes imprecis√µes. <br><ol><li>  cada medida consiste em 4 quartos </li><li>  Cada melodia tem um ritmo - ou seja,  o n√∫mero de tais quartos por minuto </li><li>  Cada nota pode ser tocada como um compasso inteiro, assim como sua parte 1/2, 1/3, 1/4, etc. </li><li>  Cada nota, √© claro, tem uma certa frequ√™ncia </li></ol><br>  Examinamos o caso mais comum; ali√°s, tudo √© mais complicado, pelo menos para mim, por isso n√£o discutirei esse t√≥pico no quadro desta hist√≥ria. <br><br>  Bem, tudo bem, vamos trabalhar com o que temos.  O mais importante para n√≥s √© obter a frequ√™ncia da nota (na verdade, o valor do registro OCR2A) e sua dura√ß√£o, por exemplo, em milissegundos.  Portanto, √© necess√°rio fazer alguns c√°lculos. <br><br>  Porque  Como estamos dentro da estrutura de uma linguagem de programa√ß√£o, as melodias s√£o mais f√°ceis de armazenar em uma matriz.  A maneira mais l√≥gica de definir cada elemento da matriz no formato √© nota + dura√ß√£o.  √â necess√°rio calcular o tamanho do elemento em bytes, porque escrevemos sob o microcontrolador e com recursos aqui est√° apertado - isso significa que o tamanho do elemento em bytes deve ser adequado. <br><br><h4>  Frequ√™ncia </h4><br>  Vamos come√ßar com a frequ√™ncia.  Porque  temos o temporizador 2 de 8 bits, o registro de compara√ß√£o do OCR2A tamb√©m √© de 8 bits.  Ou seja, nosso elemento da matriz de melodia j√° ter√° pelo menos 2 bytes, porque voc√™ ainda precisar√° salvar a dura√ß√£o.  De fato, 2 bytes √© o limite para esse tipo de embarca√ß√£o.  Ainda n√£o conseguimos um bom som, para dizer o m√≠nimo, e gastar mais bytes n√£o √© razo√°vel.  <b>Ent√£o, paramos em 2 bytes.</b> <br><br>  <b>Ao contar a frequ√™ncia, de fato, surge outro grande problema.</b> <br>  Se voc√™ observar as frequ√™ncias das notas, veremos que elas s√£o divididas em oitavas. <br><img src="https://habrastorage.org/files/240/294/17a/24029417a547408aa6806c9ddf66d593.jpg"><br>  Para a maioria das melodias simples, 3 oitavas s√£o suficientes, mas eu decidi me esquivar e implementar 6: grande, pequena e as pr√≥ximas 4. <br><br>  Agora vamos desviar da m√∫sica e voltar ao mundo da programa√ß√£o de microcontroladores. <br>  Qualquer temporizador no AVR (e a grande maioria dos outros MK) est√° vinculado √† frequ√™ncia do pr√≥prio MK.  A frequ√™ncia do quartzo no meu circuito √© 16Mhz.  A mesma frequ√™ncia √© determinada pelo F_CPU "define" para ser igual a 16000000 no meu caso. No registro TCCR2B, podemos selecionar divisores de frequ√™ncia para que nosso timer 2 n√£o "marque" a uma velocidade fren√©tica de 16000000 vezes por segundo, mas um pouco mais lenta.  O divisor de frequ√™ncia √© selecionado pelos bits CS2x, como mencionado acima. <br><br><img src="https://habrastorage.org/files/9bd/ca6/247/9bdca624740e4dd787574c6604291dc3.png"><br>  <i>nota: obviamente, no LH, um erro de digita√ß√£o em vez de "CA2x" deve ser CS2x</i> <br><br>  Surge a pergunta - como configurar o divisor? <br><br>  Para fazer isso, voc√™ precisa entender como calcular os valores para o registro OCR2A.  E calcular √© bem simples: <br>  <b>OCR2A = F_CPU / (divisor de frequ√™ncia de quartzo * 2) / frequ√™ncia de notas</b> <br>  Por exemplo, tome a nota ANTES da primeira oitava e do divisor 256 (CS22 = 1, CS21 = 1, CS20 = 0): <br>  OCR2A = 16000000 / (256 * 2) / 261 = 119 <br><br>  Explicarei imediatamente de onde veio a multiplica√ß√£o por 2. O fato √© que selecionamos o modo "Alternar" com os registros COM2Ax, o que significa que a altera√ß√£o dos n√≠veis no p√© de baixo para alto (ou vice-versa) e vice-versa ocorrer√° em 2 passagens do temporizador: primeiro o temporizador atinge o valor de OCR2A e altera o p√© do microcontrolador, por exemplo, de 1 para 0, √© redefinido e apenas na segunda volta muda de 0 para 1. Portanto, 2 voltas do temporizador v√£o para cada onda completa, respectivamente, o divisor deve ser multiplicado por 2, caso contr√°rio, obteremos apenas metade da frequ√™ncia da nossa nota. <br><br>  Da√≠ o infort√∫nio mencionado ... <br><br>  Se tomarmos a nota ANTES da grande oitava e deixar o divisor 256: <br>  OCR2A = 16000000 / (256 * 2) / 65 = 480 !!! <br>  <b>480 - esse n√∫mero √© claramente superior a 255 e n√£o se encaixa fisicamente no registro OCR2A de 8 bits.</b> <br><br>  O que fazer?  Obviamente, alterando o divisor, mas se colocarmos o divisor 1024, com uma oitava grande, tudo ficar√° bem.  Os problemas come√ßar√£o com as oitavas superiores: <br>  LA quarta oitava - OCR2A = 16000000 / (1024 * 2) / 3520 = 4 <br>  Uma quarta oitava acentuada - OCR2A = 16000000 / (1024 * 2) / 3729 = 4 <br>  <b>Os valores do OCR2A n√£o s√£o mais diferentes, o que significa que o som tamb√©m para de diferente.</b> <br><br>  <b>Existe apenas uma sa√≠da: para a frequ√™ncia das notas, √© necess√°rio armazenar n√£o apenas os valores do registro OCR2A, mas tamb√©m os bits do divisor de frequ√™ncia de quartzo.</b>  <b>Porque</b>  <b>para oitavas diferentes, haver√° um valor diferente do divisor de frequ√™ncia de quartzo, que precisaremos definir no registro TCCR2B!</b> <br><br>  Agora tudo se encaixa - e finalmente expliquei por que n√£o conseguimos preencher imediatamente o valor do divisor na fun√ß√£o timer2_buzzer_init (). <br><br>  Infelizmente, o divisor de frequ√™ncia tem mais 3 bits.  E eles ter√£o que ser obtidos no segundo byte do elemento da matriz de melodia. <br><br><div class="spoiler">  <b class="spoiler_title">Viva as macros</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DIV_MASK (_BV(CS20) | _BV(CS21) | _BV(CS22)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DIV_1024 (_BV(CS20) | _BV(CS21) | _BV(CS22)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DIV_256 (_BV(CS21) | _BV(CS22)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DIV_128 (_BV(CS20) | _BV(CS22)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DIV_64 _BV(CS22) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DIV_32 (_BV(CS20) | _BV(CS21)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NOTE_1024( x ) ((F_CPU / (1024 * 2) / x) | (DIV_1024 &lt;&lt; 8)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NOTE_256( x ) ((F_CPU / (256 * 2) / x) | (DIV_256 &lt;&lt; 8)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NOTE_128( x ) ((F_CPU / (128 * 2) / x) | (DIV_128 &lt;&lt; 8)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NOTE_64( x ) ((F_CPU / (64 * 2) / x) | (DIV_64 &lt;&lt; 8)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NOTE_32( x ) ((F_CPU / (32 * 2) / x) | (DIV_32 &lt;&lt; 8)) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  #define DOB NOTE_1024( 65 ) #define DO_B NOTE_1024( 69 ) #define REB NOTE_1024 ( 73 ) #define RE_B NOTE_1024 ( 78 ) #define MIB NOTE_1024 ( 82 ) #define FAB NOTE_1024 ( 87 ) #define FA_B NOTE_1024 ( 93 ) #define SOLB NOTE_1024 ( 98 ) #define SOL_B NOTE_1024 ( 104 ) #define LAB NOTE_1024 ( 110 ) #define LA_B NOTE_1024 ( 116 ) #define SIB NOTE_1024 ( 123 ) //  #define DOS NOTE_256( 131 ) #define DO_S NOTE_256( 138 ) #define RES NOTE_256 ( 146 ) #define RE_S NOTE_256 ( 155 ) #define MIS NOTE_256 ( 164 ) #define FAS NOTE_256 ( 174 ) #define FA_S NOTE_256 ( 185 ) #define SOLS NOTE_256 ( 196 ) #define SOL_S NOTE_256 ( 207 ) #define LAS NOTE_256 ( 219 ) #define LA_S NOTE_256 ( 233 ) #define SIS NOTE_256 ( 246 ) //  #define DO1 NOTE_256( 261 ) #define DO_1 NOTE_256( 277 ) #define RE1 NOTE_256 ( 293 ) #define RE_1 NOTE_256 ( 310 ) #define MI1 NOTE_256 ( 329 ) #define FA1 NOTE_256 ( 348 ) #define FA_1 NOTE_256 ( 369 ) #define SOL1 NOTE_256 ( 391 ) #define SOL_1 NOTE_256 ( 414 ) #define LA1 NOTE_256 ( 439 ) #define LA_1 NOTE_256 ( 465 ) #define SI1 NOTE_256 ( 493 ) //  #define DO2 NOTE_128( 522 ) #define DO_2 NOTE_128( 553 ) #define RE2 NOTE_128 ( 586 ) #define RE_2 NOTE_128 ( 621 ) #define MI2 NOTE_128 ( 658 ) #define FA2 NOTE_128 ( 697 ) #define FA_2 NOTE_128 ( 738 ) #define SOL2 NOTE_128 ( 782 ) #define SOL_2 NOTE_128 ( 829 ) #define LA2 NOTE_128 ( 878 ) #define LA_2 NOTE_128 ( 930 ) #define SI2 NOTE_128 ( 985 ) //  #define DO3 NOTE_64( 1047 ) #define DO_3 NOTE_64( 1109 ) #define RE3 NOTE_64 ( 1175 ) #define RE_3 NOTE_64 ( 1245 ) #define MI3 NOTE_64 ( 1319 ) #define FA3 NOTE_64 ( 1397 ) #define FA_3 NOTE_64 ( 1480 ) #define SOL3 NOTE_64 ( 1568 ) #define SOL_3 NOTE_64 ( 1661 ) #define LA3 NOTE_64 ( 1760 ) #define LA_3 NOTE_64 ( 1865 ) #define SI3 NOTE_64 ( 1976 ) //  #define DO4 NOTE_32( 2093 ) #define DO_4 NOTE_32( 2217 ) #define RE4 NOTE_32 ( 2349 ) #define RE_4 NOTE_32 ( 2489 ) #define MI4 NOTE_32 ( 2637 ) #define FA4 NOTE_32 ( 2794 ) #define FA_4 NOTE_32 ( 2960 ) #define SOL4 NOTE_32 ( 3136 ) #define SOL_4 NOTE_32 ( 3322 ) #define LA4 NOTE_32 ( 3520 ) #define LA_4 NOTE_32 ( 3729 ) #define SI4 NOTE_32 ( 3951 )</span></span></span></span></code> </pre><br></div></div><br><br>  E para a dura√ß√£o da nota, temos apenas 5 bits restantes, ent√£o vamos calcular a dura√ß√£o. <br><br><h4>  Dura√ß√£o </h4><br>  Primeiro, voc√™ precisa traduzir o valor do andamento em unidades tempor√°rias (por exemplo, em milissegundos) - eu fiz assim: <br>  <b>Dura√ß√£o de uma medida musical em ms = (60.000 ms * 4 quartos) / valor do andamento.</b> <br><br>  Portanto, se estamos falando de partes de batida, esse valor precisa ser dividido e, a princ√≠pio, pensei que o turno √† esquerda usual para os divisores seria suficiente.  I.e.  o c√≥digo era este: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> calc_note_delay(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> precalced_tempo, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> note) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (precalced_tempo / _BV((note &gt;&gt; <span class="hljs-number"><span class="hljs-number">11</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0b00111</span></span>)); }</code> </pre> <br><br>  I.e.  Eu usei 3 bits (dos 5 restantes) e consegui partes da batida musical dos graus 2 para 1/128.  Mas quando eu dei a um amigo que me pedia para escrever algum tipo de toque no meu peda√ßo de ferro, havia perguntas sobre por que n√£o havia 1/3 ou 1/6 e comecei a pensar ... <br><br>  No final, criei um sistema complicado para obter tais dura√ß√µes.  Um pouco do restante de 2x - gastei no sinal de multiplica√ß√£o por 3 para o divisor de rel√≥gio obtido ap√≥s o turno.  E o √∫ltimo bit √© indicar se voc√™ deve subtrair 1. √â dif√≠cil descrever, √© mais f√°cil ver o c√≥digo: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> calc_note_delay(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> precalced_tempo, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> note) { note &gt;&gt;= <span class="hljs-number"><span class="hljs-number">11</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> divider = _BV(note &amp; <span class="hljs-number"><span class="hljs-number">0b00111</span></span>); note &gt;&gt;= <span class="hljs-number"><span class="hljs-number">3</span></span>; divider *= ((note &amp; <span class="hljs-number"><span class="hljs-number">0b01</span></span>) ? <span class="hljs-number"><span class="hljs-number">3</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>); divider -= (note &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (precalced_tempo / divider); }</code> </pre> <br>  Ent√£o, eu "defini" todas as notas poss√≠veis (exceto aquelas que s√£o menores que 1/128). <br><div class="spoiler">  <b class="spoiler_title">Aqui est√£o eles</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_MINUS_1 0b10000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_MUL_3 0b01000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N2 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N3 (2 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N4 2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N5 (1 | DEL_MINUS_1 | DEL_MUL_3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N6 (1 | DEL_MUL_3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N7 (3 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N8 3 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N11 (2 | DEL_MUL_3 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N12 (2 | DEL_MUL_3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N15 (4 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N16 4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N23 (3 | DEL_MUL_3 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N24 (3 | DEL_MUL_3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N31 (5 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N32 5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N47 (4 | DEL_MUL_3 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N48 (4 | DEL_MUL_3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N63 (6 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N64 6 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N95 (5 | DEL_MUL_3 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N96 (5 | DEL_MUL_3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N127 (7 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N128 7</span></span></code> </pre><br></div></div><br><br><h4>  Juntando tudo </h4><br>  Total, temos o seguinte formato para o elemento da nossa matriz de toques. <br><br><ul><li>  1bit: divisor de atraso - 1 </li><li>  1bit: divisor de atraso * 3 </li><li>  3bit: deslocamento do divisor de atraso </li><li>  3bit: divisor do rel√≥gio da cpu </li><li>  8bit: valor OCR2A </li></ul><br>  Apenas 16 bits. <br><br>  Caro leitor, se desejar, voc√™ mesmo pode sonhar com o formato, talvez algo mais amplo do que o meu nascer√°. <br><br>  Esquecemos de adicionar uma nota vazia, ou seja,  sil√™ncio.  E, finalmente, expliquei por que, no in√≠cio, na fun√ß√£o timer2_buzzer_init (), definimos especialmente o trecho do PB3 na entrada e n√£o na sa√≠da.  Alterando o registro DDRB, ligamos e desligamos a reprodu√ß√£o do "sil√™ncio" ou da composi√ß√£o como um todo.  Porque  n√£o podemos ter notas com o valor 0 - ser√° uma nota "vazia". <br><br>  Defina as macros ausentes e a fun√ß√£o para ativar a gera√ß√£o de som: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EMPTY_NOTE 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NOTE(delay, note) (uint16_t)((delay </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; 11) | note) ........ ........ ........ void play_music_note(uint16_t note) { if (note) { TCCR2B = (note &gt;&gt; 8) &amp; DIV_MASK; OCR2A = note &amp; 0xff; sbi(DDRB, BUZ_PIN); } else cbi(DDRB, BUZ_PIN); }</span></span></span></span></code> </pre><br>  Agora vou mostrar como √© um toque escrito de acordo com esse princ√≠pio: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> king[] PROGMEM = { NOTE(DEL_1N4, MI3), NOTE(DEL_1N4, FA_3), NOTE(DEL_1N4, SOL3), NOTE(DEL_1N4, LA3), NOTE(DEL_1N4, SI3), NOTE(DEL_1N4, SOL3), NOTE(DEL_1N2, SI3), NOTE(DEL_1N4, LA_3), NOTE(DEL_1N4, FA_3), NOTE(DEL_1N4, LA_3), NOTE(DEL_1N4, EMPTY_NOTE), NOTE(DEL_1N4, LA3), NOTE(DEL_1N4, FA3), NOTE(DEL_1N2, LA3), NOTE(DEL_1N4, MI3), NOTE(DEL_1N4, FA_3), NOTE(DEL_1N4, SOL3), NOTE(DEL_1N4, LA3), NOTE(DEL_1N4, SI3), NOTE(DEL_1N4, SOL3), NOTE(DEL_1N4, SI3), NOTE(DEL_1N4, MI4), NOTE(DEL_1N4, RE4), NOTE(DEL_1N4, SI3), NOTE(DEL_1N4, SOL3), NOTE(DEL_1N4, SI3), NOTE(DEL_1N2, RE4), NOTE(DEL_1N2, EMPTY_NOTE), };</code> </pre><br><br><h3>  Tocando toque </h3><br>  Ainda temos uma tarefa - tocar a melodia.  Para fazer isso, precisamos "executar" o arranjo de toques, suportando as pausas apropriadas e alterando as frequ√™ncias das notas.  Obviamente, precisamos de outro temporizador, que, a prop√≥sito, possa ser usado para outras tarefas gerais, como eu normalmente fa√ßo.  Al√©m disso, voc√™ pode alternar entre os elementos da matriz na interrup√ß√£o deste timer ou no loop principal e usar o timer para calcular o tempo.  Neste exemplo, usei a segunda op√ß√£o. <br><br>  Como voc√™ sabe, o corpo de qualquer programa para MK inclui um loop infinito: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { <span class="hljs-comment"><span class="hljs-comment">//   } return 0; }</span></span></code> </pre><br>  Nele, "correremos" ao longo de nossa matriz.  Mas precisamos de uma fun√ß√£o semelhante ao GetTickCount do WinApi, que retorne o n√∫mero de milissegundos nos sistemas operacionais Windows.  Mas, naturalmente, no mundo do MK n√£o existem essas fun√ß√µes "prontas para uso", ent√£o devemos escrev√™-lo. <br><br><h4>  Temporizador 1 </h4><br>  Para calcular os intervalos de tempo (n√£o intencionalmente escrevo milissegundos, mais tarde voc√™ entender√° o porqu√™). Usei o timer 1 em conjunto com o modo CTC j√° conhecido por n√≥s.  O timer 1 √© um timer de 16 bits, o que significa que o valor do m√≥dulo de compara√ß√£o j√° est√° indicado por 2 registros de 8 bits OCR1AH ‚Äã‚Äãe OCR1AL - para os bytes alto e baixo, respectivamente.  N√£o quero descrever em detalhes o trabalho com o timer 1, pois isso n√£o se aplica ao t√≥pico principal deste memorando.  Portanto, direi apenas em duas palavras. <br><br>  Na verdade, precisamos de 3 fun√ß√µes: <br><ul><li>  Inicializa√ß√£o do timer </li><li>  Manipulador de interrup√ß√£o do temporizador </li><li>  fun√ß√£o que retorna o n√∫mero de intervalos de tempo. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Arquivo de c√≥digo C</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;avr/io.h&gt; #include &lt;avr/interrupt.h&gt; #include &lt;util/atomic.h&gt; #include "timer1_ticks.h" volatile unsigned long timer1_ticks; //  ISR (TIMER1_COMPA_vect) { timer1_ticks++; } void timer1_ticks_init() { //   // CTC ,     8 TCCR1B |= (1 &lt;&lt; WGM12) | (1 &lt;&lt; CS11); //     OCR1AH = (uint8_t)(CTC_MATCH_OVERFLOW &gt;&gt; 8); OCR1AL = (uint8_t) CTC_MATCH_OVERFLOW; //    TIMSK1 |= (1 &lt;&lt; OCIE1A); } unsigned long ticks() { unsigned long ticks_return; //  ,   ticks_return   //     ATOMIC_BLOCK(ATOMIC_FORCEON) { ticks_return = timer1_ticks; } return ticks_return; }</span></span></span></span></code> </pre><br></div></div><br><br>  Antes de mostrar o arquivo de cabe√ßalho com uma certa constante CTC_MATCH_OVERFLOW, precisamos voltar no tempo para a <b>se√ß√£o "Dura√ß√£o"</b> e determinar a macro mais importante para a melodia, que calcula o andamento da melodia.  Esperei muito tempo para determin√°-lo, pois ele est√° diretamente conectado ao player e, portanto, ao timer 1. <br>  Em uma primeira aproxima√ß√£o, ficou assim (consulte os c√°lculos na se√ß√£o "Dura√ß√£o"): <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TEMPO( x ) (60000 * 4 / x)</span></span></code> </pre><br>  O valor que obtemos na sa√≠da, deve substituir posteriormente o primeiro argumento na fun√ß√£o <b>calc_note_delay</b> .  Agora, observe atentamente a fun√ß√£o calc_note_delay, a saber a linha: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (precalced_tempo / divider);</code> </pre><br>  Vemos que o valor obtido pelo c√°lculo da macro TEMPO √© dividido por um determinado divisor.  Lembre-se de que o divisor m√°ximo que definimos √© <b>DEL_1N128</b> , ou seja,  o divisor ser√° 128. <br><br>  Agora vamos pegar o valor do andamento comum igual a 240 e fazer alguns c√°lculos simples: <br>  <b>60000 * 4/240 = 1000</b> <br>  Oh horror!  Temos apenas 1000, j√° que esse valor ainda ser√° dividido por 128, corremos o risco de cair para 0, a taxas altas.  <b>Esta √© a segunda quest√£o de dura√ß√£o.</b> <br><br>  Como resolver isso?  Obviamente, para expandir o intervalo de valores de andamento, precisamos aumentar o n√∫mero obtido calculando a macro TEMPO.  Isso pode ser feito de apenas uma maneira - para evitar milissegundos e contar o tempo em determinados intervalos de tempo.  Agora voc√™ entende por que todo esse tempo eu evitei mencionar "milissegundos" na hist√≥ria.  Vamos definir outra macro: <br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MS_DIVIDER 4</span></span></code> </pre> <br>  Seja o nosso divisor de milissegundos - divida o milissegundo, por exemplo, por 4 (250 Œºs). <br>  Ent√£o voc√™ precisa alterar a macro TEMPO: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TEMPO( x ) (60000 * MS_DIVIDER * 4 / x)</span></span></code> </pre> <br><br>  Agora, com a consci√™ncia limpa, darei o arquivo de cabe√ßalho para trabalhar com o timer 1: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> TIMER1_TICKS_H_INCLUDED #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TIMER1_TICKS_H_INCLUDED #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MS_DIVIDER 4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTC_MATCH_OVERFLOW ((F_CPU / 1000) / (8 * MS_DIVIDER)) void timer1_ticks_init(); unsigned long ticks(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// TIMER1_TICKS_H_INCLUDED</span></span></span></span></code> </pre> <br>  Agora podemos, alterando MS_DIVIDER, ajustar o intervalo para nossas tarefas - eu tenho 4 no meu c√≥digo - isso foi suficiente para minhas tarefas.  <b>Aten√ß√£o: se voc√™ ainda tiver alguma tarefa "vinculada" ao timer 1, n√£o se esque√ßa de multiplicar / dividir os valores de controle de tempo para eles por MS_DIVIDER.</b> <br><br><h4>  Plataforma girat√≥ria </h4><br>  Agora vamos escrever nosso player.  Eu acho que tudo ficar√° claro com o c√≥digo e os coment√°rios. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ timer1_ticks_init(); <span class="hljs-comment"><span class="hljs-comment">//   sei(); timer2_buzzer_init(); //    MS_DIVIDER long time_since = ticks(); //       MS_DIVIDER uint16_t note_delay = 0; //     uint16_t note_pos = 0; //  uint16_t length = sizeof(king) / sizeof(king[0]); //     uint16_t tempo = TEMPO(240); for(;;) { unsigned long time_current = ticks(); if (time_current - time_since &gt; note_delay) { //   uint16_t note = pgm_read_word(&amp;king[note_pos]); //   play_music_note(note); //    note_delay = calc_note_delay(tempo, note); //  if (++note_pos &gt;= length) note_pos = 0; time_since = time_current; } } return 0; }</span></span></code> </pre><br><br><h3>  Conclus√£o </h3><br>  Espero que este memorando seja √∫til para um leitor respeitado e para mim, para n√£o esquecer todas as nuances da reprodu√ß√£o de m√∫sicas, caso eu pegue os microcontroladores AVR novamente. <br><br>  Bem, tradicionalmente, o v√≠deo e o c√≥digo-fonte (eu o desenvolvi no ambiente Code Blocks, portanto, n√£o tenha medo de arquivos obscuros): <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/j60UCr2q0Ak" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C√≥digo fonte</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt402329/">https://habr.com/ru/post/pt402329/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt402319/index.html">A Universidade Jagiellonian desenvolve um aplicativo de treinamento usando os recursos do IBM Watson</a></li>
<li><a href="../pt402321/index.html">Revis√£o Livall: um capacete inteligente com um controlador, microfone e aplicativo nativo</a></li>
<li><a href="../pt402323/index.html">"Tamb√©m funciona": a arte de ouvir m√∫sica</a></li>
<li><a href="../pt402325/index.html">"Mundo magro". Cap√≠tulo 7</a></li>
<li><a href="../pt402327/index.html">WayRay anuncia parceria estrat√©gica com Banma Technologies com apoio ao investimento do Alibaba Group</a></li>
<li><a href="../pt402345/index.html">Dados sobre diversidade de esp√©cies</a></li>
<li><a href="../pt402347/index.html">Uma sele√ß√£o de fones de ouvido esportivos de at√© 2500 rublos</a></li>
<li><a href="../pt402351/index.html">Internet em todo o mundo: Jap√£o e Cingapura</a></li>
<li><a href="../pt402355/index.html">Xadrez qu√¢ntico</a></li>
<li><a href="../pt402357/index.html">Posso substituir o Adobe Premiere e o Sony Vegas por editores de v√≠deo gratuitos?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>