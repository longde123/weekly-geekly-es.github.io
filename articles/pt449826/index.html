<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§µüèæ üì≥ üë©‚Äç‚ù§Ô∏è‚Äçüë® [Tradu√ß√£o] Modelo de encadeamento enviado üë∞üèº üôåüèΩ ‚óºÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° Habr! Apresento a voc√™ a tradu√ß√£o do artigo ‚ÄúEnvoy threading model‚Äù de Matt Klein. 

 Este artigo me pareceu interessante o suficiente e, como o E...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>[Tradu√ß√£o] Modelo de encadeamento enviado</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449826/">  Ol√° Habr!  Apresento a voc√™ a tradu√ß√£o do artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">‚ÄúEnvoy threading model‚Äù</a> de Matt Klein. <br><br>  Este artigo me pareceu interessante o suficiente e, como o Envoy √© mais frequentemente usado como parte do "istio" ou simplesmente como "kubernetes" do controlador de entrada ", portanto, a maioria das pessoas n√£o tem a mesma intera√ß√£o direta com ele, como por exemplo nas instala√ß√µes t√≠picas do Nginx ou Haproxy.  No entanto, se algo quebrar, seria bom entender como funciona por dentro.  Tentei traduzir o m√°ximo de texto poss√≠vel para o russo, incluindo palavras especiais, para quem √© doloroso de ver isso, deixei os originais entre par√™nteses.  Bem-vindo ao gato. <br><a name="habracut"></a><br>  A documenta√ß√£o t√©cnica de baixo n√≠vel na base de c√≥digo do Envoy √© atualmente bastante escassa.  Para corrigir isso, pretendo fazer uma s√©rie de artigos de blog sobre os v√°rios subsistemas da Envoy.  Como este √© o primeiro artigo, informe-me o que pensa e o que pode interessar nos artigos a seguir. <br><br>  Uma das perguntas t√©cnicas mais comuns que recebo sobre o Envoy √© uma solicita√ß√£o de uma descri√ß√£o de baixo n√≠vel do modelo de encadeamento usado.  Nesta postagem, descreverei como o Envoy mapeia conex√µes com threads, bem como uma descri√ß√£o do sistema Thread Local Storage, que √© usado internamente para tornar o c√≥digo mais paralelo e de alto desempenho. <br><br><h1>  Vis√£o geral do encadeamento </h1><br><img src="https://habrastorage.org/webt/jy/46/yw/jy46ywgcjdk8zvrpwyeisan8hzm.png"><br><br>  <b>O Enviado usa tr√™s tipos diferentes de fluxos:</b> <br><br><ul><li>  <b>Principal:</b> Esse encadeamento controla o in√≠cio e o fim do processo, todo o processamento da API XDS (xDiscovery Service), incluindo DNS, verifica√ß√£o de integridade, cluster geral e gerenciamento de servi√ßos (tempo de execu√ß√£o), redefini√ß√£o de estat√≠sticas, administra√ß√£o e gerenciamento geral processos - sinais do Linux, reinicializa√ß√£o a quente, etc. Tudo o que acontece nesse encadeamento √© ass√≠ncrono e sem bloqueio.  Em geral, o encadeamento principal coordena todos os processos cr√≠ticos de funcionalidade, que n√£o exigem um grande n√∫mero de CPUs para serem conclu√≠dos.  Isso permite que a maior parte do c√≥digo de controle seja gravada como se fosse de thread √∫nico. </li><li>  <b>Worker:</b> Por padr√£o, o Envoy cria um thread de trabalho para cada segmento de hardware no sistema, que pode ser controlado usando a op√ß√£o <code>--concurrency</code> .  Cada encadeamento de trabalhador inicia um loop de eventos "sem bloqueio", respons√°vel por ouvir cada ouvinte, no momento da escrita (29 de julho de 2017), n√£o h√° fragmenta√ß√£o do ouvinte, recebendo novos conex√µes, criando uma inst√¢ncia da pilha de filtros para conectar e processando todas as opera√ß√µes de E / S durante a vida √∫til da conex√£o.  Novamente, isso permite que a maior parte do c√≥digo de processamento de conex√£o seja gravada como se fosse de thread √∫nico. </li><li>  <b>Lavador de arquivos:</b> cada arquivo que o Envoy grava, principalmente acessa logs, atualmente possui um fluxo de bloqueio independente.  Isso se deve ao fato de que a grava√ß√£o em arquivos armazenados em cache pelo sistema de arquivos, mesmo ao usar <code>O_NONBLOCK</code> , √†s vezes pode ser bloqueada (suspiro).  Quando os threads de trabalho precisam gravar em um arquivo, os dados s√£o realmente movidos para um buffer na mem√≥ria, onde eventualmente s√£o liberados pelo fluxo de libera√ß√£o do <b>arquivo</b> .  Essa √© uma √°rea do c√≥digo em que tecnicamente todos os threads de trabalho podem bloquear o mesmo bloqueio enquanto tentam preencher o buffer de mem√≥ria. </li></ul><br><h1>  Manipula√ß√£o de conex√£o </h1><br>  Como discutido brevemente acima, todos os threads de trabalho ouvem todos os ouvintes sem nenhuma segmenta√ß√£o.  Assim, o kernel √© usado para enviar corretamente os soquetes recebidos para threads de trabalho.  Os n√∫cleos modernos geralmente s√£o muito bons nisso, eles usam recursos como aumentar a prioridade de entrada / sa√≠da (E / S) para tentar preencher o encadeamento com trabalho, antes de come√ßar a usar outros encadeamentos que tamb√©m escutam no mesmo soquete e tamb√©m n√£o usam bloqueio circular (Spinlock) para lidar com cada solicita√ß√£o. <br><br>  Depois que uma conex√£o √© aceita em um encadeamento de trabalho, ela nunca sai desse encadeamento.  Todo o processamento adicional da conex√£o √© totalmente processado no encadeamento de trabalho, incluindo qualquer comportamento de encaminhamento. <br><br>  <b>Isso tem v√°rias consequ√™ncias importantes:</b> <br><br><ul><li>  <u>Todos os conjuntos de conex√µes no Envoy est√£o em um fluxo de trabalho.</u>  <u>Portanto, embora os conjuntos de conex√µes HTTP / 2 estabele√ßam apenas uma conex√£o para cada host upstream por vez, se houver quatro threads de trabalho, haver√° quatro conex√µes HTTP / 2 para o host upstream em um estado est√°vel.</u> </li><li>  O motivo pelo qual o Envoy funciona dessa maneira √© porque, armazenando tudo em um fluxo de trabalho, quase todo o c√≥digo pode ser gravado sem bloqueio e como se fosse de thread √∫nico.  Esse design facilita a escrita de muito c√≥digo e √© incrivelmente bem dimensionado para um n√∫mero quase ilimitado de fluxos de trabalho. </li><li>  No entanto, uma das principais conclus√µes √© que, do ponto de vista do pool de mem√≥ria e da efici√™ncia da conex√£o, √© realmente muito importante configurar o par√¢metro <code>--concurrency</code> .  Ter mais threads de trabalho do que o necess√°rio levar√° √† perda de mem√≥ria, criando mais conex√µes inativas e diminuindo a velocidade de entrada no pool de conex√µes.  Na Lyft, nossos cont√™ineres de side-car enviados trabalham com simultaneidade muito baixa, portanto o desempenho √© aproximadamente equivalente aos servi√ßos aos quais eles se encontram.  Executamos o Envoy como um proxy de borda (borda) somente com simultaneidade m√°xima. </li></ul><br><h1>  O que significa n√£o-bloqueio? </h1><br>  At√© o momento, o termo "sem bloqueio" foi usado v√°rias vezes para discutir como os threads principal e de trabalho funcionam.  Todo o c√≥digo √© escrito, desde que nada seja bloqueado.  No entanto, isso n√£o √© inteiramente verdade (o que n√£o √© totalmente verdade?). <br><br>  <b>O enviado usa v√°rios bloqueios de processo demorados:</b> <br><br><ul><li>  Como j√° mencionado, ao gravar logs de acesso, todos os threads de trabalho obt√™m o mesmo bloqueio antes de preencher o buffer de log na mem√≥ria.  O tempo de espera do bloqueio deve ser muito baixo, mas √© poss√≠vel que esse bloqueio seja desafiado com alta simultaneidade e alta taxa de transfer√™ncia. </li><li>  O Enviado usa um sistema muito sofisticado para processar estat√≠sticas locais no fluxo.  Este ser√° o t√≥pico de uma postagem separada.  No entanto, mencionarei brevemente que, como parte do processamento local das estat√≠sticas de fluxo, √†s vezes √© necess√°rio obter um bloqueio para o "armazenamento de estat√≠sticas" central.  Esse bloqueio nunca deve ser necess√°rio. </li><li>  O thread principal periodicamente precisa de coordena√ß√£o com todos os fluxos de trabalho.  Isso √© feito ‚Äúpublicando‚Äù do thread principal nos threads de trabalho e, √†s vezes, dos threads de trabalho de volta ao thread principal.  Para enviar, o bloqueio √© necess√°rio para que a mensagem publicada possa ser enfileirada para entrega subsequente.  Esses bloqueios nunca devem ser submetidos a uma concorr√™ncia s√©ria, mas ainda podem ser tecnicamente bloqueados. </li><li>  Quando o Envoy grava um log no fluxo de erros do sistema (erro padr√£o), ele recebe um bloqueio em todo o processo.  No geral, o registro local da Envoy √© considerado terr√≠vel em termos de desempenho, portanto n√£o h√° muita aten√ß√£o para melhor√°-lo. </li><li>  Existem v√°rios outros bloqueios aleat√≥rios, mas nenhum deles √© cr√≠tico para o desempenho e nunca deve ser contestado. </li></ul><br><h1>  Encadear armazenamento local </h1><br>  Devido √† maneira como o Envoy separa as responsabilidades do encadeamento principal das tarefas do fluxo de trabalho, √© necess√°rio que o processamento complexo possa ser executado no encadeamento principal e, em seguida, fornecido a cada fluxo de trabalho com um alto grau de simultaneidade.  Esta se√ß√£o descreve o sistema TLS (Envoy Thread Local Storage) em um n√≠vel alto.  Na pr√≥xima se√ß√£o, descreverei como √© usado para gerenciar o cluster. <br><br><img src="https://habrastorage.org/webt/hc/e4/bs/hce4bsjgfljckbekacfilceotyq.png"><br><br>  Como j√° descrito, o encadeamento principal processa quase todas as fun√ß√µes de gerenciamento e a funcionalidade do plano de controle no processo do Envoy.  O plano de controle est√° um pouco sobrecarregado aqui, mas se voc√™ o observar no pr√≥prio processo Envoy e compar√°-lo com o encaminhamento que os threads de trabalho executam, isso parece apropriado.  Como regra geral, o processo principal do encadeamento realiza algum trabalho e, em seguida, ele precisa atualizar cada encadeamento de trabalho de acordo com o resultado deste trabalho, <u>enquanto o encadeamento de trabalho n√£o precisa definir um bloqueio em todos os acessos</u> . <br><br>  <b>O sistema Envoy TLS (Thread local storage) funciona da seguinte maneira:</b> <br><br><ul><li>  O c√≥digo em execu√ß√£o no encadeamento principal pode alocar um slot TLS para todo o processo.  Embora isso seja abstra√≠do, na pr√°tica √© um √≠ndice em um vetor que fornece acesso a O (1). </li><li>  O fluxo principal pode definir dados arbitr√°rios em seu slot.  Quando isso √© feito, os dados s√£o publicados em cada fluxo de trabalho como um evento de loop de eventos regular. </li><li>  Os encadeamentos de trabalho podem ler do slot TLS e recuperar qualquer dado de encadeamento local dispon√≠vel l√°. </li></ul><br>  Embora este seja um paradigma muito simples e incrivelmente poderoso, √© muito semelhante ao conceito de bloqueio de RCU (Read-Copy-Update).  Em ess√™ncia, os fluxos de trabalho nunca veem altera√ß√µes de dados nos slots TLS em tempo de execu√ß√£o.  A mudan√ßa ocorre apenas durante o per√≠odo de descanso entre eventos de trabalho. <br><br>  <b>O enviado usa isso de duas maneiras diferentes:</b> <br><br><ul><li>  Ao armazenar v√°rios dados em cada fluxo de trabalho, o acesso a esses dados √© realizado sem nenhum bloqueio. </li><li>  Armazenando um ponteiro global para dados globais no modo somente leitura em cada encadeamento de trabalho.  Assim, cada encadeamento de trabalho possui um contador de refer√™ncia de dados, que n√£o pode ser reduzido durante a execu√ß√£o do trabalho.  Somente quando todos os funcion√°rios se acalmarem e enviarem novos dados compartilhados, os dados antigos ser√£o destru√≠dos.  √â id√™ntico ao RCU. </li></ul><br><h1>  Thread de atualiza√ß√£o de cluster </h1><br>  Nesta se√ß√£o, descreverei como o TLS (Thread Local Storage) √© usado para gerenciar um cluster.  O gerenciamento de cluster inclui processamento de API xDS e / ou DNS, bem como verifica√ß√£o de integridade. <br><br><img src="https://habrastorage.org/webt/by/jw/4q/byjw4qhlo9xjsprdu9ngi9dop_y.png"><br><br>  <b>O gerenciamento de fluxo de cluster inclui os seguintes componentes e etapas:</b> <br><br><ol><li>  O Cluster Manager √© um componente do Envoy que gerencia todos os upstream de cluster conhecido, APIs CDS (Servi√ßo de Descoberta de Cluster), SDS (Servi√ßo de Descoberta Secreta) e EDS (Servi√ßo de Descoberta de Endpoint), DNS e verifica√ß√µes externas ativas sa√∫de (verifica√ß√£o de sa√∫de).  Ele √© respons√°vel por criar uma representa√ß√£o ‚Äúconsistente‚Äù de cada cluster upstream que inclui os hosts descobertos, bem como o status de integridade. </li><li>  O verificador de integridade executa uma verifica√ß√£o de integridade ativa e relata as altera√ß√µes no estado de integridade para o gerenciador de cluster. </li><li>  CDS (Servi√ßo de Descoberta de Cluster) / SDS (Servi√ßo de Descoberta Secreta) / EDS (Servi√ßo de Descoberta de Endpoint) / DNS s√£o executados para determinar a associa√ß√£o ao cluster.  A mudan√ßa de estado √© retornada ao gerenciador de cluster. </li><li>  Cada fluxo de trabalho executa constantemente um loop de eventos. </li><li>  Quando o gerenciador de cluster determina que o estado do cluster foi alterado, ele cria um novo instant√¢neo de cluster somente leitura e o envia para cada encadeamento de trabalho. </li><li>  Durante o pr√≥ximo per√≠odo inativo, o fluxo de trabalho atualizar√° o instant√¢neo no slot TLS dedicado. </li><li>  Durante um evento de E / S que o host deve determinar para o balanceamento de carga, o balanceador de carga solicitar√° um slot TLS (Thread local storage) para obter informa√ß√µes do host.  Nenhum bloqueio √© necess√°rio para isso.  Observe tamb√©m que o TLS tamb√©m pode disparar eventos durante a atualiza√ß√£o, para que os balanceadores de carga e outros componentes possam recontar caches, estruturas de dados etc.  Isso est√° al√©m do escopo desta postagem, mas √© usado em v√°rios lugares do c√≥digo. </li></ol><br>  Usando o procedimento acima, o Envoy pode processar cada solicita√ß√£o sem nenhum bloqueio (al√©m dos descritos anteriormente).  Al√©m da complexidade do pr√≥prio c√≥digo TLS, a maior parte do c√≥digo n√£o precisa entender como o multithreading funciona e pode ser gravado no modo de thread √∫nico.  Isso facilita a grava√ß√£o da maior parte do c√≥digo, al√©m do desempenho superior. <br><br><h1>  Outros subsistemas que fazem uso do TLS </h1><br>  TLS (Thread local storage) e RCU (Read Copy Update) s√£o amplamente utilizados no Envoy. <br><br>  <b>Exemplos de uso:</b> <br><br><ul><li>  <b>O mecanismo de altera√ß√£o da funcionalidade durante a execu√ß√£o: A</b> lista atual de funcionalidades ativadas √© calculada no encadeamento principal.  Cada fluxo de trabalho √© fornecido com um instant√¢neo somente leitura usando a sem√¢ntica de RCU. </li><li>  <b>Substituindo tabelas de rotas</b> : para tabelas de rotas fornecidas pelo RDS (Route Discovery Service), as tabelas de rotas s√£o criadas no encadeamento principal.  Um instant√¢neo somente leitura ser√° fornecido posteriormente para cada fluxo de trabalho usando a sem√¢ntica de RCU (Read Copy Update).  Isso torna a modifica√ß√£o de tabelas de rotas atomicamente eficiente. </li><li>  <b>Armazenamento em cache do cabe√ßalho HTTP:</b> o c√°lculo do cabe√ßalho HTTP para cada solicita√ß√£o (ao executar ~ 25K + RPS por n√∫cleo) √© bastante caro.  O enviado calcula centralmente o cabe√ßalho aproximadamente a cada meio segundo e o fornece a todos os funcion√°rios por meio de TLS e RCU. </li></ul><br>  Existem outros casos, mas os exemplos anteriores devem fornecer uma boa compreens√£o do uso do TLS. <br><br><h1>  Armadilhas conhecidas de desempenho </h1><br>  Embora o Envoy funcione muito bem no geral, existem algumas √°reas conhecidas que precisam de aten√ß√£o quando usadas com simultaneidade e largura de banda muito altas: <br><br><ul><li>  Como j√° descrito neste artigo, atualmente todos os threads de trabalho est√£o bloqueados quando gravados no buffer de mem√≥ria do log de acesso.  Com alta simultaneidade e alta taxa de transfer√™ncia, ser√° necess√°rio empacotar logs de acesso para cada fluxo de trabalho devido a entrega n√£o ordenada ao gravar no arquivo final.  Como alternativa, voc√™ pode criar um log de acesso separado para cada fluxo de trabalho. </li><li>  Embora as estat√≠sticas sejam muito otimizadas, com simultaneidade e taxa de transfer√™ncia muito altas, √© prov√°vel que exista concorr√™ncia at√¥mica nas estat√≠sticas individuais.  A solu√ß√£o para esse problema √© contadores por um fluxo de trabalho com redefini√ß√£o peri√≥dica dos contadores centrais.  Isso ser√° discutido em um post subsequente. </li><li>  A arquitetura existente n√£o funcionar√° bem se o Envoy for implantado em um cen√°rio em que existem muito poucas conex√µes que exijam recursos significativos de processamento.  N√£o h√° garantia de que as comunica√ß√µes ser√£o distribu√≠das igualmente entre os fluxos de trabalho.  Isso pode ser resolvido equilibrando as conex√µes de trabalho, nas quais a capacidade de trocar conex√µes entre fluxos de trabalho ser√° realizada. </li></ul><br><h1>  Conclus√£o </h1><br>  O modelo de encadeamento Envoy foi projetado para fornecer facilidade de programa√ß√£o e simultaneidade massiva devido ao uso potencialmente desperdi√ßador de mem√≥ria e conex√µes, se n√£o estiverem configuradas corretamente.  Esse modelo permite que ele funcione muito bem com um n√∫mero muito alto de threads e taxa de transfer√™ncia. <br><br>  Como mencionei brevemente no Twitter, um design tamb√©m pode ser executado em cima de uma pilha de rede totalmente funcional no modo de usu√°rio, como o DPDK (Data Plane Development Kit), que pode fazer com que servidores regulares processem milh√µes de solicita√ß√µes por segundo com processamento L7 completo.  Ser√° muito interessante ver o que ser√° constru√≠do nos pr√≥ximos anos. <br><br>  Um √∫ltimo coment√°rio r√°pido: muitas vezes me perguntam por que escolhemos o C ++ para o Envoy.  A raz√£o, como antes, √© que ainda √© a √∫nica linguagem de n√≠vel industrial amplamente falada na qual construir a arquitetura descrita neste post.  Definitivamente, o C ++ n√£o √© adequado para todos ou para muitos projetos, mas, em certos casos de uso, ainda √© a √∫nica ferramenta para fazer o trabalho (para fazer o trabalho). <br><br><h1>  Links para c√≥digo </h1><br>  <b>Links para arquivos com interfaces e implementa√ß√µes de cabe√ßalho discutidos neste post:</b> <br><br><ul><li>  <a href="">github.com/lyft/envoy/blob/master/include/envoy/thread_local/thread_local.h</a> </li><li>  <a href="">github.com/lyft/envoy/blob/master/source/common/thread_local/thread_local_impl.h</a> </li><li>  <a href="">github.com/lyft/envoy/blob/master/include/envoy/upstream/cluster_manager.h</a> </li><li>  <a href="">github.com/lyft/envoy/blob/master/source/common/upstream/cluster_manager_impl.h</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt449826/">https://habr.com/ru/post/pt449826/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt449808/index.html">Experi√™ncia positiva do Hack Days 9: como o pensamento cr√≠tico ajuda na vida e no trabalho</a></li>
<li><a href="../pt449814/index.html">O Windows XP est√° oficialmente morto, agora finalmente</a></li>
<li><a href="../pt449818/index.html">Estat√≠sticas e monitoramento de scripts PHP em tempo real. ClickHouse e Grafana v√£o para Pinba para obter ajuda</a></li>
<li><a href="../pt449820/index.html">Personalize instantaneamente associa√ß√µes de arquivos familiares</a></li>
<li><a href="../pt449824/index.html">As aventuras da startup de ferro na R√∫ssia: forma√ß√£o de equipes</a></li>
<li><a href="../pt449828/index.html">"Ratos choraram e picaram .." Substitui√ß√£o de importa√ß√£o na pr√°tica. Parte 4 (te√≥rica, final). Sistemas e Servi√ßos</a></li>
<li><a href="../pt449830/index.html">Controle de linha de energia HD44780</a></li>
<li><a href="../pt449832/index.html">Futuro qu√¢ntico</a></li>
<li><a href="../pt449836/index.html">Dell U2419HC: monitor elegante de 24 polegadas com Full HD e USB-C</a></li>
<li><a href="../pt449840/index.html">Barra de inicia√ß√£o: um novo m√©todo de phishing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>