<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôæ üëçüèø üïê Seluruh kebenaran tentang RTOS. Artikel # 25. Saluran Data: Pengantar dan Layanan Dasar üßëüèæ‚Äçü§ù‚Äçüßëüèª ‚õ™Ô∏è üëçüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Setelah istirahat sebentar, kami terus menerbitkan terjemahan The Whole Truth About RTOS oleh Colin Walls. Kali ini kita akan berbicara tentang salura...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Seluruh kebenaran tentang RTOS. Artikel # 25. Saluran Data: Pengantar dan Layanan Dasar</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433046/"><img src="https://habrastorage.org/webt/kk/zy/_j/kkzy_j5jujof9pkubwwgfiapg3o.jpeg"><br><br>  Setelah istirahat sebentar, kami terus menerbitkan terjemahan The Whole Truth About RTOS oleh Colin Walls.  Kali ini kita akan berbicara tentang saluran transmisi data (selanjutnya disebut saluran), yang telah disebutkan di salah satu artikel sebelumnya, yaitu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di # 5</a> .  Saluran, dibandingkan dengan kotak surat ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="># 21</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="># 22</a> ) atau antrian ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="># 23</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="># 24</a> ), menyediakan cara yang lebih fleksibel untuk mentransfer pesan sederhana antar tugas. <br><a name="habracut"></a><br>  Artikel sebelumnya dalam seri: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 24.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Antrian: layanan tambahan dan struktur data</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Antrian: pengantar dan layanan dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kotak Surat: Layanan Tambahan dan Struktur Data</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kotak Surat: Pengantar dan Layanan Dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Semaphores: Layanan Tambahan dan Struktur Data</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Semaphores: pengantar dan layanan dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Grup Bendera Acara: Layanan Pembantu dan Struktur Data</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Grup Bendera Acara: Pengantar dan Layanan Dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sinyal</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Partisi Memori: Layanan dan Struktur Data</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian memori: pengantar dan layanan dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Struktur data tugas dan panggilan API yang tidak didukung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Layanan untuk bekerja dengan tugas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas: konfigurasi dan pengantar API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penjadwal: fitur canggih dan pelestarian konteks</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penjadwal: implementasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nucleus SE: Desain dan Penyebaran Internal</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nucleus SE: Pendahuluan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Layanan RTOS lainnya</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Interaksi tugas dan sinkronisasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas, pengalihan konteks, dan interupsi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas dan Perencanaan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RTOS: Struktur dan mode waktu-nyata</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RTOS: pengantar.</a> <br><br><h2>  Menggunakan saluran </h2><br>  Dalam Nucleus SE, saluran diidentifikasi selama fase perakitan.  Setiap aplikasi dapat memiliki hingga 16 saluran.  Jika tidak ada saluran yang dikonfigurasi dalam aplikasi, struktur data atau kode panggilan layanan yang terkait dengan saluran tidak akan disertakan dalam aplikasi. <br><br>  Saluran transmisi data - satu set penyimpanan, ukuran masing-masing memungkinkan Anda untuk menempatkan satu elemen data dengan panjang yang ditentukan pengguna dalam byte.  Akses ke data dikendalikan sedemikian rupa sehingga beberapa tugas dapat dengan aman menggunakannya.  Tugas dapat menulis data ke saluran sampai semua area penuh.  Tugas dapat membaca data dari saluran, dan data diterima sesuai dengan prinsip FIFO.  Mencoba menulis ke saluran yang ramai atau membaca dari saluran yang kosong dapat mengakibatkan kesalahan atau penangguhan tugas, tergantung pada pengaturan panggilan API yang dipilih dan konfigurasi Nucleus SE. <br><br><h2>  Saluran dan Antrian </h2><br>  Nucleus SE juga mendukung antrian yang telah dibahas secara rinci dalam artikel sebelumnya (# 23 dan # 24).  Perbedaan utama antara saluran dan antrian adalah ukuran pesan.  Antrian berisi pesan yang terdiri dari satu variabel jenis ADDR, biasanya pointer.  Saluran ini berisi pesan-pesan berukuran sewenang-wenang, masing-masing untuk setiap saluran dalam aplikasi dan ditugaskan selama pengaturan parameter. <br><br><h2>  Pengaturan saluran </h2><br><h3>  Jumlah saluran </h3><br>  Seperti kebanyakan objek Nucleus SE, kustomisasi saluran dikendalikan oleh arahan <b>#define</b> di <b>nuse_config.h</b> .  Parameter utama adalah <b>NUSE_PIPE_NUMBER</b> , yang menentukan jumlah saluran yang dikonfigurasi dalam aplikasi.  Secara default, nilai ini adalah nol (yaitu, tidak ada saluran dalam aplikasi) dan dapat mengambil nilai hingga 16. Nilai yang salah akan menyebabkan kesalahan kompilasi, yang akan dihasilkan dengan memeriksa file <b>nuse_config_check.h</b> (file ini termasuk dalam <b>nuse_config.c</b> dan kompilasi bersamaan dengan itu), yang akan memicu arahan <b>#error</b> . <br><br>  Memilih nilai bukan nol berfungsi sebagai penggerak utama saluran.  Parameter ini digunakan untuk menentukan struktur data dan ukurannya tergantung pada nilainya (lebih lanjut tentang ini di artikel berikutnya).  Selain itu, nilai bukan nol mengaktifkan pengaturan API. <br><br><h3>  Aktifkan Panggilan API </h3><br>  Setiap fungsi API (panggilan utilitas) di Nucleus SE memiliki <b>#define</b> directive pengaktif di <b>nuse_config.h</b> .  Untuk saluran, simbol-simbol ini adalah: <br><br>  <b>NUSE_PIPE_SEND</b> <br>  <b>NUSE_PIPE_RECEIVE</b> <br>  <b>NUSE_PIPE_JAM</b> <br>  <b>NUSE_PIPE_RESET</b> <br>  <b>NUSE_PIPE_INFORMATION</b> <br>  <b>NUSE_PIPE_COUNT</b> <br><br>  Secara default, mereka disetel ke <b>FALSE</b> , sehingga semua panggilan layanan dinonaktifkan, memblokir penyertaan kode yang mengimplementasikannya.  Untuk mengonfigurasi saluran dalam aplikasi, Anda harus memilih panggilan layanan API yang diperlukan dan mengaturnya ke <b>TRUE</b> . <br><br>  Di bawah ini adalah potongan kode dari file <b>nuse_config.h</b> default. <br><br><pre><code class="plaintext hljs">#define NUSE_PIPE_NUMBER 0 /* Number of pipes in the system - 0-16 */ /* Service call enablers */ #define NUSE_PIPE_SEND FALSE #define NUSE_PIPE_RECEIVE FALSE #define NUSE_PIPE_JAM FALSE #define NUSE_PIPE_RESET FALSE #define NUSE_PIPE_INFORMATION FALSE #define NUSE_PIPE_COUNT FALSE</code> </pre> <br>  Jika fungsi API diaktifkan, tetapi tidak ada saluran dalam aplikasi (kecuali <b>NUSE_Pipe_Count ()</b> , yang selalu diaktifkan), kesalahan kompilasi akan terjadi.  Jika kode Anda menggunakan panggilan API yang belum diaktifkan, kesalahan tata letak akan terjadi karena kode implementasi tidak termasuk dalam aplikasi. <br><br><h2>  Panggilan saluran overhead </h2><br>  Nucleus RTOS mendukung sepuluh saluran overhead yang menyediakan fungsi berikut: <br><br><ul><li>  Mengirim pesan ke saluran.  Nucleus SE diimplementasikan dalam fungsi <b>NUSE_Pipe_Send ()</b> . </li><li>  Terima pesan dari saluran.  Nucleus SE diimplementasikan dalam fungsi <b>NUSE_Pipe_Receive ()</b> . </li><li>  Kirim pesan ke bagian atas saluran.  Nucleus SE diimplementasikan dalam <b>NUSE_Pipe_Jam ()</b> . </li><li>  Mengembalikan saluran ke kondisi yang tidak digunakan dengan melepaskan semua tugas yang ditangguhkan (reset).  Di Nucleus SE, diterapkan di <b>NUSE_Pipe_Reset ()</b> . </li><li>  Mendapatkan informasi tentang saluran tertentu.  Nucleus SE diimplementasikan menggunakan <b>NUSE_Pipe_Information ()</b> . </li><li>  Mengembalikan penghitung saluran yang saat ini dikonfigurasi dalam aplikasi.  Nucleus SE diimplementasikan menggunakan <b>NUSE_Pipe_Count ()</b> . </li><li>  Menambahkan saluran baru ke aplikasi (pembuatan).  Tidak diterapkan di Nucleus SE. </li><li>  Menghapus saluran dari aplikasi.  Tidak diterapkan di Nucleus SE. </li><li>  Kembalikan pointer ke semua saluran dalam aplikasi.  Tidak diterapkan di Nucleus SE. </li><li>  Mengirim pesan ke semua tugas yang ditangguhkan di saluran (siaran).  Tidak diterapkan di Nucleus SE. </li></ul><br>  Pertimbangkan implementasi dari masing-masing panggilan layanan ini secara lebih rinci. <br><br><h2>  Panggilan layanan untuk menulis dan membaca dari saluran </h2><br>  Operasi dasar yang dilakukan pada saluran adalah merekam (juga disebut mengirim) dan membaca (juga dikenal sebagai menerima pesan).  Selain itu, dimungkinkan untuk merekam data di awal saluran (macet).  Nucleus RTOS dan Nucleus SE menyediakan tiga panggilan API utama untuk operasi ini, yang akan dibahas di bawah ini. <br><br><h3>  Rekaman saluran </h3><br>  Panggilan utilitas Nucleus RTOS API untuk menulis ke saluran sangat fleksibel, yang memungkinkan Anda untuk menjeda tugas secara implisit atau dengan batas waktu jika operasi tidak dapat diselesaikan segera (misalnya, ketika mencoba menulis ke saluran yang ramai).  Nucleus SE memiliki tantangan yang serupa, tetapi tugas jeda adalah opsional dan batas waktu tidak diterapkan. <br><br>  Nucleus RTOS juga menyediakan layanan siaran saluran, tetapi tidak didukung pada Nucleus SE.  Ini akan dijelaskan di bagian Panggilan API yang belum direalisasi pada artikel berikutnya. <br><br>  <b><i>Panggilan untuk mengirim pesan ke saluran di Nucleus RTOS</i></b> <br><br>  Prototipe panggilan layanan: <br><br>  <b>STATUS NU_Send_To_Pipe (NU_PIPE * pipa, pesan VOID *, ukuran TIDAK DITANDATANGANI, penangguhan tidak ditandatangani);</b> <br><br>  Parameter: <br><br>  <b>pipe</b> - pointer ke blok kontrol saluran yang disediakan oleh pengguna; <br>  <b>message</b> - penunjuk ke pesan yang akan dikirim; <br>  <b>size</b> - jumlah byte dalam pesan.  Jika saluran mendukung pesan panjang variabel, parameter ini harus sama dengan atau kurang dari panjang pesan yang didukung oleh saluran.  Jika saluran mendukung pesan dengan panjang tetap, parameter ini harus sama dengan ukuran pesan yang didukung oleh saluran; <br>  <b>menangguhkan</b> - spesifikasi penangguhan tugas, dapat mengambil nilai <b>NU_NO_SUSPEND</b> , <b>NU_SUSPEND</b> atau nilai batas waktu. <br><br>  Nilai pengembalian: <br><br>  <b>NUSE_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NU_INVALID_PIPE</b> - pointer tidak valid ke saluran; <br>  <b>NU_INVALID_POINTER</b> - null pointer ke pesan ( <b>NULL</b> ); <br>  <b>NU_INVALID_SIZE</b> - ukuran pesan tidak kompatibel dengan ukuran pesan yang didukung oleh saluran; <br>  <b>NU_INVALID_SUSPEND</b> - upaya untuk menangguhkan dari utas yang tidak terkait tugas; <br>  <b>NU_PIPE_FULL</b> - saluran sudah penuh dan jenis penangguhan tugas tidak ditentukan; <br>  <b>NU_TIMEOUT</b> - saluran penuh bahkan setelah tugas ditangguhkan untuk jangka waktu tertentu; <br>  <b>NU_PIPE_DELETED</b> - saluran telah dihapus saat tugas ditangguhkan; <br>  <b>NU_PIPE_RESET</b> - Saluran diatur ulang saat tugas ditangguhkan. <br><br>  <b><i>Panggilan untuk mengirim pesan ke saluran di Nucleus SE</i></b> <br><br>  Panggilan layanan API ini mendukung fungsionalitas inti API Nucleus RTOS. <br><br>  Prototipe panggilan layanan: <br><br>  <b>STATUS NUSE_Pipe_Send (pipa NUSE_PIPE, pesan U8 *, U8 ditangguhkan);</b> <br><br>  Parameter: <br><br>  <b>pipa</b> - indeks (ID) dari saluran yang digunakan; <br>  <b>message</b> - pointer ke pesan yang akan dikirim (urutan byte panjang yang diizinkan untuk saluran tertentu); <br>  <b>menangguhkan</b> - spesifikasi penangguhan tugas, dapat mengambil nilai <b>NUSE_NO_SUSPEND</b> dan <b>NUSE_SUSPEND</b> . <br><br>  Nilai pengembalian: <br><br>  <b>NUSE_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NUSE_INVALID_PIPE</b> - indeks saluran tidak valid; <br>  <b>NUSE_INVALID_POINTER</b> - null pointer ke pesan ( <b>NULL</b> ); <br>  <b>NUSE_INVALID_SUSPEND</b> - upaya untuk menangguhkan dari utas yang tidak terkait tugas atau ketika penguncian tugas dinonaktifkan; <br>  <b>NUSE_PIPE_FULL</b> - saluran sudah penuh dan jenis penangguhan tugas tidak ditentukan; <br>  <b>NUSE_PIPE_WAS_RESET</b> - Saluran diatur ulang saat tugas ditangguhkan. <br><br>  <b><i>Menerapkan posting saluran di Nucleus SE</i></b> <br><br>  Versi kode fungsi API <b>NUSE_Pipe_Send ()</b> (setelah memeriksa parameter) dipilih menggunakan kompilasi bersyarat tergantung pada apakah dukungan untuk panggilan API diaktifkan untuk memblokir (jeda) tugas atau tidak.  Di bawah ini kami mempertimbangkan kedua opsi. <br><br>  Jika kunci dinonaktifkan, kode untuk panggilan API ini cukup sederhana: <br><br><pre> <code class="plaintext hljs">if (NUSE_Pipe_Items[pipe] == NUSE_Pipe_Size[pipe]) /* pipe full */ { return_value = NUSE_PIPE_FULL; } else /* pipe element available */ { data = &amp;NUSE_Pipe_Data[pipe][NUSE_Pipe_Head[pipe]]; for (i=0; i&lt;msgsize; i++) { *data++ = *message++; } NUSE_Pipe_Head[pipe] += msgsize; if (NUSE_Pipe_Head[pipe] == (NUSE_Pipe_Size[pipe] * msgsize)) { NUSE_Pipe_Head[pipe] = 0; } NUSE_Pipe_Items[pipe]++; return_value = NUSE_SUCCESS; }</code> </pre><br>  Fungsi ini memeriksa apakah ada ruang kosong di saluran dan menggunakan indeks <b>NUSE_Pipe_Head []</b> untuk menempatkan pesan di area data saluran. <br><br>  Jika penguncian tugas diaktifkan, kode menjadi lebih kompleks: <br><br><pre> <code class="plaintext hljs">do { if (NUSE_Pipe_Items[pipe] == NUSE_Pipe_Size[pipe]) /* pipe full */ { if (suspend == NUSE_NO_SUSPEND) { return_value = NUSE_PIPE_FULL; } else { /* block task */ NUSE_Pipe_Blocking_Count[pipe]++; NUSE_Suspend_Task(NUSE_Task_Active, (pipe &lt;&lt; 4) | NUSE_PIPE_SUSPEND); return_value = NUSE_Task_Blocking_Return[NUSE_Task_Active]; if (return_value != NUSE_SUCCESS) { suspend = NUSE_NO_SUSPEND; } } } else /* pipe element available */ { data = &amp;NUSE_Pipe_Data[pipe][NUSE_Pipe_Head[pipe]]; for (i=0; i&lt;msgsize; i++) { *data++ = *message++; } NUSE_Pipe_Head[pipe] += msgsize; if (NUSE_Pipe_Head[pipe] == (NUSE_Pipe_Size[pipe] * msgsize)) { NUSE_Pipe_Head[pipe] = 0; } NUSE_Pipe_Items[pipe]++; if (NUSE_Pipe_Blocking_Count[pipe] != 0) { U8 index; /* check whether a task is blocked on this pipe */ NUSE_Pipe_Blocking_Count[pipe]--; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_PIPE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == pipe)) { NUSE_Task_Blocking_Return[index] = NUSE_SUCCESS; NUSE_Wake_Task(index); break; } } } return_value = NUSE_SUCCESS; suspend = NUSE_NO_SUSPEND; } } while (suspend == NUSE_SUSPEND);</code> </pre><br>  Beberapa klarifikasi mungkin bermanfaat. <br><br>  Kode terlampir dalam <b>do ... while</b> , yang berjalan ketika parameter jeda tugas adalah <b>NUSE_SUSPEND</b> . <br><br>  Jika saluran penuh dan parameter penangguhan adalah <b>NUSE_NO_SUSPEND</b> , panggilan API berakhir dengan nilai <b>NUSE_PIPE_FULL</b> .  Jika parameter <b>penangguhan</b> adalah <b>NUSE_SUSPEND</b> , tugas dihentikan sementara.  Setelah selesai (yaitu, ketika tugas dilanjutkan), jika nilai kembali adalah <b>NUSE_SUCCESS</b> , yaitu, tugas dilanjutkan karena pesan dibaca (dan bukan karena saluran diatur ulang), kode kembali ke awal loop. <br><br>  Jika saluran tidak penuh, pesan yang disediakan disimpan menggunakan indeks <b>NUSE_Pipe_Head []</b> di area data saluran.  Ia memeriksa untuk melihat apakah saluran telah menjeda tugas (pesan yang ditangguhkan).  Jika ada tugas seperti itu, yang pertama dilanjutkan.  Variabel <b>penangguhan</b> diatur ke <b>NUSE_NO_SUSPEND</b> , dan panggilan API selesai dengan nilai <b>NUSE_SUCCESS</b> . <br><br><h3>  Membaca dari saluran </h3><br>  Panggilan utilitas Nucleus RTOS API untuk membaca dari saluran sangat fleksibel, yang memungkinkan Anda untuk menjeda tugas secara implisit atau dengan batas waktu jika operasi tidak dapat diselesaikan dengan segera (misalnya, ketika Anda mencoba membaca saluran kosong).  Nucleus SE memiliki panggilan utilitas yang serupa, tetapi tugas jeda adalah opsional dan batas waktu tidak diterapkan. <br><br>  <b><i>Tantangan Baca Saluran di RTOS Inti</i></b> <br><br>  Prototipe panggilan layanan: <br><br>  <b>STATUS NU_Receive_From_Pipe (NU_PIPE * pipa, pesan VOID *, ukuran TANDA TANGAN, TANDA TANDA * actual_size, tunda sementara TANDA TANGAN);</b> <br><br>  Parameter: <br><br>  <b>pipe</b> - pointer ke blok kontrol saluran yang disediakan oleh pengguna; <br>  <b>message</b> - pointer ke penyimpanan untuk pesan yang diterima; <br>  <b>size</b> - jumlah byte dalam pesan.  Harus cocok dengan ukuran pesan yang ditentukan saat membuat saluran; <br>  <b>menangguhkan</b> - spesifikasi penangguhan tugas, dapat mengambil <b>NU_NO_SUSPEND</b> , <b>NU_SUSPEND</b> atau nilai batas waktu. <br><br>  Nilai pengembalian: <br><br>  <b>NU_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NU_INVALID_PIPE</b> - pointer tidak valid ke saluran; <br>  <b>NU_INVALID_POINTER</b> - null pointer ke pesan ( <b>NULL</b> ); <br>  <b>NU_INVALID_SUSPEND</b> - berupaya menjeda tugas dari utas yang tidak terkait dengan tugas; <br>  <b>NU_PIPE_EMPTY</b> - salurannya kosong, dan jenis penangguhan tugas tidak ditentukan; <br>  <b>NU_TIMEOUT</b> - saluran kosong bahkan setelah tugas ditangguhkan untuk nilai batas waktu yang ditentukan; <br>  <b>NU_PIPE_DELETED</b> - saluran telah dihapus saat tugas ditangguhkan; <br>  <b>NU_PIPE_RESET</b> - Saluran dihapus saat tugas ditangguhkan. <br><br>  <b><i>Tantangan Baca Saluran di Nucleus SE</i></b> <br><br>  Panggilan layanan API ini mendukung fungsionalitas inti API Nucleus RTOS. <br><br>  Prototipe panggilan layanan: <br><br>  <b>STATUS NUSE_Pipe_Receive (pipa NUSE_PIPE, pesan U8 *, U8 ditangguhkan);</b> <br><br>  Parameter: <br><br>  <b>pipa</b> - indeks (ID) dari saluran yang digunakan; <br>  <b>message</b> - pointer ke penyimpanan untuk pesan yang diterima (urutan byte, panjangnya bertepatan dengan ukuran pesan saluran); <br>  <b>menangguhkan</b> - spesifikasi penangguhan tugas, dapat mengambil nilai <b>NUSE_NO_SUSPEND</b> dan <b>NU_SUSPEND</b> . <br><br>  Nilai pengembalian: <br><br>  <b>NUSE_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NUSE_INVALID_PIPE</b> - indeks saluran tidak valid; <br>  <b>NUSE_INVALID_POINTER</b> - null pointer ke pesan ( <b>NULL</b> ); <br>  <b>NUSE_INVALID_SUSPEND</b> - upaya untuk menangguhkan tugas dari utas yang tidak terkait dengan tugas atau dengan dukungan untuk penangguhan tugas yang dinonaktifkan; <br>  <b>NUSE_PIPE_EMPTY</b> - salurannya kosong, dan jenis penangguhan tugas tidak ditentukan; <br>  <b>NUSE_PIPE_WAS_RESET</b> - Saluran diatur ulang saat tugas ditangguhkan. <br><br>  <b><i>Menerapkan pembaca feed di Nucleus SE</i></b> <br><br>  Versi kode fungsi API <b>NUSE_Pipe_Receive ()</b> (setelah memeriksa parameter) dipilih oleh kompilasi bersyarat, tergantung pada apakah dukungan API untuk panggilan kunci (penangguhan tugas) diaktifkan atau tidak.  Kami akan mempertimbangkan kedua opsi di bawah ini. <br><br>  Jika kunci dinonaktifkan, kode untuk panggilan API ini cukup sederhana: <br><br><pre> <code class="plaintext hljs">if (NUSE_Pipe_Items[pipe] == 0) /* pipe empty */ { return_value = NUSE_PIPE_EMPTY; } else { /* message available */ data = &amp;NUSE_Pipe_Data[pipe][NUSE_Pipe_Tail[pipe]]; for (i=0; i&lt;msgsize; i++) { *message++ = *data++; } NUSE_Pipe_Tail[pipe] += msgsize; if (NUSE_Pipe_Tail[pipe] == (NUSE_Pipe_Size[pipe] * msgsize)) { NUSE_Pipe_Tail[pipe] = 0; } NUSE_Pipe_Items[pipe]--; *actual_size = msgsize; return_value = NUSE_SUCCESS; }</code> </pre><br>  Fungsi memeriksa keberadaan pesan di saluran dan menggunakan indeks <b>NUSE_Pipe_Tail []</b> untuk mendapatkan pesan dari area data saluran, dan mengembalikan data melalui penunjuk pesan. <br><br>  Jika penguncian tugas diaktifkan, kode menjadi lebih kompleks: <br><br><pre> <code class="plaintext hljs">do { if (NUSE_Pipe_Items[pipe] == 0) /* pipe empty */ { if (suspend == NUSE_NO_SUSPEND) { return_value = NUSE_PIPE_EMPTY; } else { /* block task */ NUSE_Pipe_Blocking_Count[pipe]++; NUSE_Suspend_Task(NUSE_Task_Active, (pipe &lt;&lt; 4) | NUSE_PIPE_SUSPEND); return_value = NUSE_Task_Blocking_Return[NUSE_Task_Active]; if (return_value != NUSE_SUCCESS) { suspend = NUSE_NO_SUSPEND; } } } else { /* message available */ data = &amp;NUSE_Pipe_Data[pipe][NUSE_Pipe_Tail[pipe]]; for (i=0; i&lt;msgsize; i++) { *message++ = *data++; } NUSE_Pipe_Tail[pipe] += msgsize; if (NUSE_Pipe_Tail[pipe] == (NUSE_Pipe_Size[pipe] * msgsize)) { NUSE_Pipe_Tail[pipe] = 0; } NUSE_Pipe_Items[pipe]--; if (NUSE_Pipe_Blocking_Count[pipe] != 0) { U8 index; /* check whether a task is blocked */ /* on this pipe */ NUSE_Pipe_Blocking_Count[pipe]--; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_PIPE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == pipe)) { NUSE_Task_Blocking_Return[index] = NUSE_SUCCESS; NUSE_Wake_Task(index); break; } } } *actual_size = msgsize; return_value = NUSE_SUCCESS; suspend = NUSE_NO_SUSPEND; } } while (suspend == NUSE_SUSPEND);</code> </pre><br>  Beberapa klarifikasi mungkin bermanfaat. <br><br>  Kode terlampir dalam <b>do ... while</b> , yang berjalan ketika parameter jeda tugas adalah <b>NUSE_SUSPEND</b> . <br><br>  Jika saluran kosong dan parameter penangguhan adalah <b>NUSE_NO_SUSPEND</b> , panggilan API berakhir dengan nilai <b>NUSE_PIPE_EMPTY</b> .  Jika parameter penangguhan adalah <b>NUSE_SUSPEND</b> , tugas dihentikan sementara.  Setelah selesai (yaitu, ketika tugas dilanjutkan), jika nilai kembali adalah <b>NUSE_SUCCESS</b> , yaitu, tugas dilanjutkan karena pesan dikirim (dan bukan karena saluran diatur ulang), kode kembali ke awal loop. <br><br>  Jika saluran berisi pesan, pesan yang disimpan dikembalikan menggunakan indeks <b>NUSE_Pipe_Tail []</b> .  Memeriksa apakah ada tugas yang dijeda (menunggu untuk dikirim) di saluran ini.  Jika ada tugas seperti itu, yang pertama dilanjutkan.  Variabel penangguhan diatur ke <b>NUSE_NO_SUSPEND</b> , dan panggilan API berakhir dengan kode <b>NUSE_SUCCESS</b> . <br><br><h3>  Rekam ke awal saluran </h3><br>  Panggilan utilitas Nucleus RTOS API untuk menulis ke awal saluran sangat fleksibel, yang memungkinkan Anda untuk menjeda tugas secara implisit atau dengan batas waktu jika operasi tidak dapat diselesaikan dengan segera (misalnya, ketika mencoba menulis ke saluran penuh).  Nucleus SE memiliki panggilan utilitas yang serupa, tetapi tugas jeda adalah opsional dan batas waktu tidak diterapkan. <br><br>  <b><i>Panggilan untuk menulis ke awal saluran di Nucleus RTOS</i></b> <br><br>  Prototipe panggilan layanan: <br><br>  <b>STATUS NU_Send_To_Front_Of_Pipe (NU_PIPE * pipa, pesan VOID *, ukuran TIDAK DITANDATANGANI, penangguhan yang TIDAK DIKETAHUI);</b> <br><br>  Parameter: <br><br>  <b>pipe</b> - pointer ke blok kontrol saluran yang disediakan oleh pengguna; <br>  <b>message</b> - penunjuk ke pesan yang akan dikirim; <br>  <b>size</b> - jumlah byte dalam pesan.  Jika saluran mendukung pesan panjang variabel, parameter ini harus sama dengan atau kurang dari ukuran pesan yang didukung oleh saluran.  Jika saluran mendukung pesan panjang tetap, parameter ini harus cocok dengan ukuran pesan yang didukung oleh saluran; <br>  <b>menangguhkan</b> - spesifikasi penangguhan tugas, dapat mengambil <b>NU_NO_SUSPEND</b> , <b>NU_SUSPEND</b> atau nilai batas waktu. <br><br>  Nilai pengembalian: <br><br>  <b>NU_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NU_INVALID_PIPE</b> - pointer tidak valid ke saluran; <br>  <b>NU_INVALID_POINTER</b> - null pointer ke pesan ( <b>NULL</b> ); <br>  <b>NU_INVALID_SIZE</b> - ukuran pesan tidak sesuai dengan ukuran pesan yang didukung oleh saluran; <br>  <b>NU_INVALID_SUSPEND</b> - upaya untuk menangguhkan dari utas yang tidak terkait dengan tugas; <br>  <b>NU_PIPE_FULL</b> - salurannya penuh, dan jenis penangguhan tugas tidak ditentukan; <br>  <b>NU_TIMEOUT</b> - saluran penuh bahkan setelah tugas ditangguhkan untuk jangka waktu tertentu; <br>  <b>NU_PIPE_DELETED</b> - saluran telah dihapus saat tugas ditangguhkan; <br>  <b>NU_PIPE_RESET</b> - Saluran diatur ulang saat tugas ditangguhkan. <br><br>  <b><i>Panggilan untuk menulis ke awal saluran di Nucleus SE</i></b> <br><br>  Panggilan utilitas ini mendukung fungsionalitas inti API Nucleus RTOS. <br><br>  Prototipe panggilan layanan: <br><br>  <b>STATUS NUSE_Pipe_Jam (pipa NUSE_PIPE, pesan ADDR *, U8 ditangguhkan);</b> <br><br>  Parameter: <br><br>  <b>pipa</b> - indeks (ID) dari saluran yang digunakan; <br>  <b>message</b> - pointer ke pesan yang akan dikirim, yang merupakan urutan byte yang sama dengan ukuran pesan yang dikonfigurasi di saluran; <br>  menangguhkan - spesifikasi penangguhan tugas, dapat berupa <b>NUSE_NO_SUSPEND</b> atau <b>NUSE_SUSPEND</b> . <br><br>  Nilai pengembalian: <br><br>  <b>NUSE_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NUSE_INVALID_PIPE</b> - indeks saluran tidak valid; <br>  <b>NUSE_INVALID_POINTER</b> - null pointer ke pesan ( <b>NULL</b> ); <br>  <b>NUSE_INVALID_SUSPEND</b> - upaya untuk menangguhkan tugas dari utas yang tidak terkait dengan tugas atau saat kunci tugas dinonaktifkan; <br>  <b>NUSE_PIPE_FULL</b> - salurannya penuh, dan jenis penangguhan tugas tidak ditentukan; <br>  <b>NUSE_PIPE_WAS_RESET</b> - Saluran diatur ulang saat tugas ditangguhkan. <br><br>  <b><i>Menerapkan Perekaman Entri Saluran di Nucleus SE</i></b> <br><br>  Kode varian fungsi <b>NUSE_Pipe_Jam ()</b> sangat mirip dengan <b>NUSE_Pipe_Send ()</b> , kecuali bahwa indeks <b>NUSE_Pipe_Tail []</b> digunakan untuk menyimpan data di dalamnya, oleh karena itu: <br><br><pre> <code class="plaintext hljs">if (NUSE_Pipe_Items[pipe] == NUSE_Pipe_Size[pipe]) /* pipe full */ { return_value = NUSE_PIPE_FULL; } else /* pipe element available */ { if (NUSE_Pipe_Tail[pipe] == 0) { NUSE_Pipe_Tail[pipe] = (NUSE_Pipe_Size[pipe] - 1) * msgsize; } else { NUSE_Pipe_Tail[pipe] -= msgsize; } data = &amp;NUSE_Pipe_Data[pipe][NUSE_Pipe_Tail[pipe]]; for (i=0; i&lt;msgsize; i++) { *data++ = *message++; } NUSE_Pipe_Items[pipe]++; return_value = NUSE_SUCCESS; }</code> </pre><br>  Pada artikel berikutnya, kami akan mempertimbangkan panggilan layanan tambahan yang terkait dengan saluran, serta struktur data yang sesuai. <br><br>  <b>Tentang Pengarang:</b> Colin Walls telah bekerja di industri elektronik selama lebih dari tiga puluh tahun, mencurahkan sebagian besar waktunya untuk firmware.  Dia sekarang adalah seorang insinyur firmware di Mentor Embedded (sebuah divisi dari Mentor Graphics).  Colin Walls sering berbicara di konferensi dan seminar, penulis berbagai artikel teknis dan dua buku tentang firmware.  Tinggal di Inggris.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Blog</a> profesional <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Colin</a> , email: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433046/">https://habr.com/ru/post/id433046/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433034/index.html">Injeksi spel</a></li>
<li><a href="../id433036/index.html">Kiat untuk Mengatur TI dalam Bisnis Kecil</a></li>
<li><a href="../id433038/index.html">Mengapa pemasar belajar pemrograman</a></li>
<li><a href="../id433042/index.html">Intel akan merilis prosesor dengan arsitektur tiga dimensi Foveros pada 2019</a></li>
<li><a href="../id433044/index.html">Kode sumber OpenJDK mengandung terlalu banyak kata-kata umpatan</a></li>
<li><a href="../id433048/index.html">Bagaimana 2019 akan mengubah toko-toko Rusia</a></li>
<li><a href="../id433050/index.html">Dari perancang pesawat hingga programmer dalam satu tahun, atau bagaimana menjadi Jedi</a></li>
<li><a href="../id433052/index.html">snap & flatpack - tragedi komunitas</a></li>
<li><a href="../id433054/index.html">Jarum dalam tumpukan sesi, atau bytecode ekspresi reguler</a></li>
<li><a href="../id433056/index.html">Kementerian Komunikasi memperketat aturan untuk perangkat lunak dengan elemen yang berasal dari luar negeri</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>