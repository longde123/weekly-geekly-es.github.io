<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüíª üàØÔ∏è ‚úèÔ∏è Indizes in PostgreSQL - 8 (RUM) ü§ì üë©üèø‚Äçüé® üåá</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir haben bereits die PostgreSQL- Indizierungs-Engine , die Schnittstelle von Zugriffsmethoden und Hauptzugriffsmethoden wie Hash-Indizes , B-B√§ume , ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Indizes in PostgreSQL - 8 (RUM)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/452116/">  Wir haben bereits die PostgreSQL- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Indizierungs-Engine</a> , die Schnittstelle von Zugriffsmethoden und Hauptzugriffsmethoden wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hash-Indizes</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">B-B√§ume</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GiST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SP-GiST</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GIN</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">er√∂rtert</a> .  In diesem Artikel werden wir sehen, wie aus Gin Rum wird. <br><br><h1>  RUM </h1><br>  Obwohl die Autoren behaupten, Gin sei ein m√§chtiger Geist, hat das Thema Getr√§nke schlie√ülich gewonnen: GIN der n√§chsten Generation wurde RUM genannt. <br><br>  Diese Zugriffsmethode erweitert das Konzept, das GIN zugrunde liegt, und erm√∂glicht es uns, die Volltextsuche noch schneller durchzuf√ºhren.  In dieser Artikelserie ist dies die einzige Methode, die nicht in einer Standard-PostgreSQL-Lieferung enthalten ist und eine externe Erweiterung darstellt.  Hierf√ºr stehen mehrere Installationsoptionen zur Verf√ºgung: <br><br><ul><li>  Nehmen Sie das Paket "yum" oder "apt" aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dem PGDG-Repository</a> .  Wenn Sie beispielsweise PostgreSQL aus dem Paket "postgresql-10" installiert haben, installieren Sie auch "postgresql-10-rum". </li><li>  Erstellen Sie aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellcode auf Github</a> und installieren Sie es selbst (die Anweisung ist ebenfalls vorhanden). </li><li>  Verwenden Sie es als Teil von Postgres Pro Enterprise (oder lesen Sie zumindest <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Dokumentation</a> von dort). </li></ul><br><h2>  Einschr√§nkungen von Gin </h2><br>  Welche Einschr√§nkungen von GIN k√∂nnen wir mit RUM √ºberwinden? <br><br>  Erstens enth√§lt der Datentyp "tsvector" nicht nur Lexeme, sondern auch Informationen zu ihren Positionen innerhalb des Dokuments.  Wie wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letztes Mal</a> festgestellt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">haben</a> , speichert der GIN-Index diese Informationen nicht.  Aus diesem Grund werden Operationen zur Suche nach Phrasen, die in Version 9.6 enthalten waren, vom GIN-Index ineffizient unterst√ºtzt und m√ºssen zur erneuten √úberpr√ºfung auf die Originaldaten zugreifen. <br><br>  Zweitens geben Suchsysteme die Ergebnisse normalerweise sortiert nach Relevanz zur√ºck (was auch immer das bedeutet).  Zu diesem Zweck k√∂nnen wir die Ranking-Funktionen "ts_rank" und "ts_rank_cd" verwenden, aber sie m√ºssen f√ºr jede Zeile des Ergebnisses berechnet werden, was sicherlich langsam ist. <br><br>  In erster N√§herung kann die RUM-Zugriffsmethode als GIN betrachtet werden, die zus√§tzlich Positionsinformationen speichert und die Ergebnisse in einer erforderlichen Reihenfolge <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zur√ºckgibt</a> (wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GiST</a> die n√§chsten Nachbarn zur√ºckgeben kann).  Gehen wir Schritt f√ºr Schritt vor. <br><a name="habracut"></a><br><h2>  Nach Phrasen suchen </h2><br>  Eine Volltextsuchabfrage kann spezielle Operatoren enthalten, die den Abstand zwischen Lexemen ber√ºcksichtigen.  Zum Beispiel k√∂nnen wir Dokumente finden, in denen "Hand" mit zwei weiteren W√∂rtern von "Oberschenkel" getrennt ist: <br><br><pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'Clap your hands, slap your thigh'</span></span>) @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hand &lt;3&gt; thigh'</span></span>);</code> </pre> <pre> <code class="plaintext hljs"> ?column? ---------- t (1 row)</code> </pre><br>  Oder wir k√∂nnen angeben, dass die W√∂rter nacheinander stehen m√ºssen: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'Clap your hands, slap your thigh'</span></span>) @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hand &lt;-&gt; slap'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- t (1 row)</code> </pre><br>  Der regul√§re GIN-Index kann die Dokumente zur√ºckgeben, die beide Lexeme enthalten, aber wir k√∂nnen den Abstand zwischen ihnen nur √ºberpr√ºfen, indem wir in tsvector schauen: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'Clap your hands, slap your thigh'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> to_tsvector -------------------------------------- 'clap':1 'hand':3 'slap':4 'thigh':6 (1 row)</code> </pre><br>  Im RUM-Index verweist jedes Lexem nicht nur auf die Tabellenzeilen: Jede TID wird mit der Liste der Positionen geliefert, an denen das Lexem im Dokument vorkommt.  So k√∂nnen wir uns den Index vorstellen, der f√ºr die "Slit-Sheet" -Tabelle erstellt wurde, die uns bereits bekannt ist (die Operatorklasse "rum_tsvector_ops" wird standardm√§√üig f√ºr tsvector verwendet): <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> rum; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> rum(doc_tsv);</code> </pre><br><br><img src="https://habrastorage.org/webt/k0/up/gn/k0upgnbhka1wfwq6oozy9qo24ka.png"><br><br>  Graue Quadrate in der Abbildung enthalten die hinzugef√ºgten Positionsinformationen: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ctid, left(doc,<span class="hljs-number"><span class="hljs-number">20</span></span>), doc_tsv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts;</code> </pre><pre> <code class="plaintext hljs"> ctid | left | doc_tsv -------+----------------------+--------------------------------------------------------- (0,1) | Can a sheet slitter | 'sheet':3,6 'slit':5 'slitter':4 (0,2) | How many sheets coul | 'could':4 'mani':2 'sheet':3,6 'slit':8 'slitter':7 (0,3) | I slit a sheet, a sh | 'sheet':4,6 'slit':2,8 (1,1) | Upon a slitted sheet | 'sheet':4 'sit':6 'slit':3 'upon':1 (1,2) | Whoever slit the she | 'good':7 'sheet':4,8 'slit':2 'slitter':9 'whoever':1 (1,3) | I am a sheet slitter | 'sheet':4 'slitter':5 (2,1) | I slit sheets. | 'sheet':3 'slit':2 (2,2) | I am the sleekest sh | 'ever':8 'sheet':5,10 'sleekest':4 'slit':9 'slitter':6 (2,3) | She slits the sheet | 'sheet':4 'sit':6 'slit':2 (9 rows)</code> </pre><br>  GIN bietet auch eine verschobene Einf√ºgung, wenn der Parameter "fastupdate" angegeben ist.  Diese Funktionalit√§t wird aus RUM entfernt. <br><br>  Um zu sehen, wie der Index f√ºr Live-Daten funktioniert, verwenden wir das vertraute <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Archiv</a> der Mailingliste von pgsql-hackers. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> tsv <span class="hljs-type"><span class="hljs-type">tsvector</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> default_text_search_config = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> tsv = to_tsvector(body_plain);</code> </pre><pre> <code class="plaintext hljs">... UPDATE 356125</code> </pre><br>  So wird eine Abfrage ausgef√ºhrt, bei der nach Phrasen gesucht wird, mit dem GIN-Index: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> tsv_gin <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(tsv); fts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello &lt;-&gt; hackers'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------------------- Bitmap Heap Scan on mail_messages (actual time=2.490..18.088 rows=259 loops=1) Recheck Cond: (tsv @@ to_tsquery('hello &lt;-&gt; hackers'::text)) Rows Removed by Index Recheck: 1517 Heap Blocks: exact=1503 -&gt; Bitmap Index Scan on tsv_gin (actual time=2.204..2.204 rows=1776 loops=1) Index Cond: (tsv @@ to_tsquery('hello &lt;-&gt; hackers'::text)) Planning time: 0.266 ms Execution time: 18.151 ms (8 rows)</code> </pre><br>  Wie aus dem Plan hervorgeht, wird der GIN-Index verwendet, der jedoch 1776 potenzielle √úbereinstimmungen zur√ºckgibt, von denen 259 √ºbrig bleiben und 1517 bei der erneuten √úberpr√ºfung gel√∂scht werden. <br><br>  L√∂schen wir den GIN-Index und erstellen RUM. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> tsv_gin; fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> tsv_rum <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> rum(tsv);</code> </pre><br>  Der Index enth√§lt jetzt alle erforderlichen Informationen, und die Suche wird genau durchgef√ºhrt: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello &lt;-&gt; hackers'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------------------------------- Bitmap Heap Scan on mail_messages (actual time=2.798..3.015 rows=259 loops=1) Recheck Cond: (tsv @@ to_tsquery('hello &lt;-&gt; hackers'::text)) Heap Blocks: exact=250 -&gt; Bitmap Index Scan on tsv_rum (actual time=2.768..2.768 rows=259 loops=1) Index Cond: (tsv @@ to_tsquery('hello &lt;-&gt; hackers'::text)) Planning time: 0.245 ms Execution time: 3.053 ms (7 rows)</code> </pre><br><h2>  Sortieren nach Relevanz </h2><br>  Um Dokumente problemlos in der erforderlichen Reihenfolge zur√ºckzugeben, unterst√ºtzt der RUM-Index <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bestelloperatoren</a> , die wir in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem</a> Artikel zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GiST</a> besprochen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">haben</a> .  Die RUM-Erweiterung definiert einen solchen Operator <code>&lt;=&gt;</code> , der einen gewissen Abstand zwischen dem Dokument ("tsvector") und der Abfrage ("tsquery") zur√ºckgibt.  Zum Beispiel: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'Can a sheet slitter slit sheets?'</span></span>) &lt;=&amp;gtl to_tsquery(<span class="hljs-string"><span class="hljs-string">'slit'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- 16.4493 (1 row)</code> </pre><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'Can a sheet slitter slit sheets?'</span></span>) &lt;=&gt; to_tsquery(<span class="hljs-string"><span class="hljs-string">'sheet'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- 13.1595 (1 row)</code> </pre><br>  Das Dokument schien f√ºr die erste Abfrage relevanter zu sein als f√ºr die zweite: Je √∂fter das Wort vorkommt, desto weniger "wertvoll" ist es. <br><br>  Versuchen wir noch einmal, GIN und RUM bei einer relativ gro√üen Datenmenge zu vergleichen: Wir werden zehn relevanteste Dokumente ausw√§hlen, die "Hallo" und "Hacker" enthalten. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello &amp; hackers'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> ts_rank(tsv,to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello &amp; hackers'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------------------------------- Limit (actual time=27.076..27.078 rows=10 loops=1) -&gt; Sort (actual time=27.075..27.076 rows=10 loops=1) Sort Key: (ts_rank(tsv, to_tsquery('hello &amp; hackers'::text))) Sort Method: top-N heapsort Memory: 29kB -&gt; Bitmap Heap Scan on mail_messages (actual ... rows=1776 loops=1) Recheck Cond: (tsv @@ to_tsquery('hello &amp; hackers'::text)) Heap Blocks: exact=1503 -&gt; Bitmap Index Scan on tsv_gin (actual ... rows=1776 loops=1) Index Cond: (tsv @@ to_tsquery('hello &amp; hackers'::text)) Planning time: 0.276 ms Execution time: 27.121 ms (11 rows)</code> </pre><br>  Der GIN-Index gibt 1776 √úbereinstimmungen zur√ºck, die dann als separater Schritt sortiert werden, um die zehn besten Treffer auszuw√§hlen. <br><br>  Beim RUM-Index wird die Abfrage mithilfe eines einfachen Index-Scans ausgef√ºhrt: Es werden keine zus√§tzlichen Dokumente durchsucht und es ist keine separate Sortierung erforderlich: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello &amp; hackers'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> tsv &lt;=&gt; to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello &amp; hackers'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------------------------------------------- Limit (actual time=5.083..5.171 rows=10 loops=1) -&gt; Index Scan using tsv_rum on mail_messages (actual ... rows=10 loops=1) Index Cond: (tsv @@ to_tsquery('hello &amp; hackers'::text)) Order By: (tsv &lt;=&gt; to_tsquery('hello &amp; hackers'::text)) Planning time: 0.244 ms Execution time: 5.207 ms (6 rows)</code> </pre><br><h2>  Zus√§tzliche Informationen </h2><br>  Der RUM-Index sowie GIN k√∂nnen auf mehreren Feldern erstellt werden.  W√§hrend GIN Lexeme aus jeder Spalte unabh√§ngig von denen aus einer anderen Spalte speichert, k√∂nnen wir mit RUM das Hauptfeld (in diesem Fall "tsvector") einem zus√§tzlichen Feld "zuordnen".  Dazu ben√∂tigen wir eine spezielle Operatorklasse "rum_tsvector_addon_ops": <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> rum(tsv RUM_TSVECTOR_ADDON_OPS, sent) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (ATTACH=<span class="hljs-string"><span class="hljs-string">'sent'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span>=<span class="hljs-string"><span class="hljs-string">'tsv'</span></span>);</code> </pre><br>  Wir k√∂nnen diesen Index verwenden, um die nach dem zus√§tzlichen Feld sortierten Ergebnisse zur√ºckzugeben: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> id, sent, sent &lt;=&gt; <span class="hljs-string"><span class="hljs-string">'2017-01-01 15:00:00'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> sent &lt;=&gt; <span class="hljs-string"><span class="hljs-string">'2017-01-01 15:00:00'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | sent | ?column? ---------+---------------------+---------- 2298548 | 2017-01-01 15:03:22 | 202 2298547 | 2017-01-01 14:53:13 | 407 2298545 | 2017-01-01 13:28:12 | 5508 2298554 | 2017-01-01 18:30:45 | 12645 2298530 | 2016-12-31 20:28:48 | 66672 2298587 | 2017-01-02 12:39:26 | 77966 2298588 | 2017-01-02 12:43:22 | 78202 2298597 | 2017-01-02 13:48:02 | 82082 2298606 | 2017-01-02 15:50:50 | 89450 2298628 | 2017-01-02 18:55:49 | 100549 (10 rows)</code> </pre><br>  Hier suchen wir nach √ºbereinstimmenden Zeilen, die dem angegebenen Datum so nahe wie m√∂glich kommen, unabh√§ngig davon, ob sie fr√ºher oder sp√§ter vorliegen.  Um die Ergebnisse zu erhalten, die genau vor (oder nach) dem angegebenen Datum liegen, m√ºssen wir <code>&lt;=|</code>  (oder <code>|=&gt;</code> ) Operator. <br><br>  Wie erwartet wird die Abfrage nur durch einen einfachen Index-Scan ausgef√ºhrt: <br><br><pre> <code class="pgsql hljs">ts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> id, sent, sent &lt;=&gt; <span class="hljs-string"><span class="hljs-string">'2017-01-01 15:00:00'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> sent &lt;=&gt; <span class="hljs-string"><span class="hljs-string">'2017-01-01 15:00:00'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------------------- Limit -&gt; Index Scan using mail_messages_tsv_sent_idx on mail_messages Index Cond: (tsv @@ to_tsquery('hello'::text)) Order By: (sent &lt;=&gt; '2017-01-01 15:00:00'::timestamp without time zone) (4 rows)</code> </pre><br>  Wenn wir den Index ohne die zus√§tzlichen Informationen zur Feldzuordnung erstellen w√ºrden, m√ºssten wir f√ºr eine √§hnliche Abfrage alle Ergebnisse des Indexscans sortieren. <br><br>  Zus√§tzlich zum Datum k√∂nnen wir dem RUM-Index sicherlich Felder anderer Datentypen hinzuf√ºgen.  Nahezu alle Basistypen werden unterst√ºtzt.  Beispielsweise kann ein Online-Shop Waren schnell nach Neuheit (Datum), Preis (numerisch) und Beliebtheit oder Rabattwert (Ganzzahl oder Gleitkomma) anzeigen. <br><br><h2>  Andere Operatorklassen </h2><br>  Um das Bild zu vervollst√§ndigen, sollten wir andere verf√ºgbare Operatorklassen erw√§hnen. <br><br>  Beginnen wir mit <strong>"rum_tsvector_hash_ops"</strong> und <strong>"rum_tsvector_hash_addon_ops"</strong> .  Sie √§hneln den bereits diskutierten "rum_tsvector_ops" und "rum_tsvector_addon_ops", aber der Index speichert den Hash-Code des Lexems und nicht des Lexems selbst.  Dies kann die Indexgr√∂√üe verringern, aber nat√ºrlich wird die Suche ungenauer und erfordert eine erneute √úberpr√ºfung.  Au√üerdem unterst√ºtzt der Index die Suche nach einer Teil√ºbereinstimmung nicht mehr. <br><br>  Es ist interessant, sich die Operatorklasse <strong>"rum_tsquery_ops" anzusehen</strong> .  Es erm√∂glicht uns, ein "inverses" Problem zu l√∂sen: Abfragen zu finden, die mit dem Dokument √ºbereinstimmen.  Warum k√∂nnte das n√∂tig sein?  Zum Beispiel, um einen Benutzer nach seinem Filter f√ºr neue Waren zu abonnieren oder neue Dokumente automatisch zu kategorisieren.  Schauen Sie sich dieses einfache Beispiel an: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> categories(query <span class="hljs-type"><span class="hljs-type">tsquery</span></span>, category <span class="hljs-type"><span class="hljs-type">text</span></span>); fts=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> categories <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (to_tsquery(<span class="hljs-string"><span class="hljs-string">'vacuum | autovacuum | freeze'</span></span>), <span class="hljs-string"><span class="hljs-string">'vacuum'</span></span>), (to_tsquery(<span class="hljs-string"><span class="hljs-string">'xmin | xmax | snapshot | isolation'</span></span>), <span class="hljs-string"><span class="hljs-string">'mvcc'</span></span>), (to_tsquery(<span class="hljs-string"><span class="hljs-string">'wal | (write &amp; ahead &amp; log) | durability'</span></span>), <span class="hljs-string"><span class="hljs-string">'wal'</span></span>); fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> categories <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> rum(query); fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> array_agg(category) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> categories <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> to_tsvector( <span class="hljs-string"><span class="hljs-string">'Hello hackers, the attached patch greatly improves performance of tuple freezing and also reduces size of generated write-ahead logs.'</span></span> ) @@ query;</code> </pre><pre> <code class="plaintext hljs"> array_agg -------------- {vacuum,wal} (1 row)</code> </pre><br>  Die verbleibenden Operatorklassen <strong>"rum_anyarray_ops"</strong> und <strong>"rum_anyarray_addon_ops"</strong> dienen zur Manipulation von Arrays anstelle von "tsvector".  Dies wurde bereits beim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letzten Mal</a> f√ºr GIN besprochen und muss nicht wiederholt werden. <br><br><h2>  Die Gr√∂√üe des Index und des Write-Ahead-Protokolls (WAL) </h2><br>  Es ist klar, dass RUM, da es mehr Informationen als GIN speichert, eine gr√∂√üere Gr√∂√üe haben muss.  Wir haben beim letzten Mal die Gr√∂√üen verschiedener Indizes verglichen.  F√ºgen wir dieser Tabelle RUM hinzu: <br><br><pre> <code class="plaintext hljs"> rum | gin | gist | btree --------+--------+--------+-------- 457 MB | 179 MB | 125 MB | 546 MB</code> </pre><br>  Wie wir sehen k√∂nnen, ist die Gr√∂√üe erheblich gewachsen, was die Kosten f√ºr eine schnelle Suche sind. <br><br>  Es lohnt sich, auf einen weiteren nicht offensichtlichen Punkt zu achten: RUM ist eine Erweiterung, dh sie kann ohne √Ñnderungen am Systemkern installiert werden.  Dies wurde in Version 9.6 dank eines Patches von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alexander Korotkov erm√∂glicht</a> .  Eines der Probleme, die zu diesem Zweck gel√∂st werden mussten, war die Erstellung von Protokolldatens√§tzen.  Eine Technik zur Protokollierung von Vorg√§ngen muss absolut zuverl√§ssig sein, daher kann eine Erweiterung nicht in diese K√ºche eingelassen werden.  Anstatt der Erweiterung zu erlauben, ihre eigenen Arten von Protokolldatens√§tzen zu erstellen, ist Folgendes vorhanden: Der Code der Erweiterung teilt ihre Absicht mit, eine Seite zu √§ndern, nimmt √Ñnderungen daran vor und signalisiert den Abschluss, und es ist der Systemkern. Hiermit werden die alten und neuen Versionen der Seite verglichen und die erforderlichen einheitlichen Protokolldatens√§tze generiert. <br><br>  Der aktuelle Protokollgenerierungsalgorithmus vergleicht Seiten Byte f√ºr Byte, erkennt aktualisierte Fragmente und protokolliert jedes dieser Fragmente zusammen mit seinem Versatz vom Seitenanfang.  Dies funktioniert gut, wenn nur einige Bytes oder die gesamte Seite aktualisiert werden.  Wenn wir jedoch ein Fragment innerhalb einer Seite hinzuf√ºgen, den Rest des Inhalts nach unten verschieben (oder umgekehrt, ein Fragment entfernen, den Inhalt nach oben verschieben), √§ndern sich erheblich mehr Bytes als tats√§chlich hinzugef√ºgt oder entfernt wurden. <br><br>  Aus diesem Grund k√∂nnen durch eine intensive √Ñnderung des RUM-Index Protokolldatens√§tze mit einer erheblich gr√∂√üeren Gr√∂√üe als GIN generiert werden (das keine Erweiterung, sondern Teil des Kerns ist und das Protokoll selbst verwaltet).  Das Ausma√ü dieses st√∂renden Effekts h√§ngt stark von der tats√§chlichen Arbeitsbelastung ab. Um jedoch einen Einblick in das Problem zu erhalten, versuchen wir, mehrere Zeilen mehrmals zu entfernen und hinzuzuf√ºgen, wobei diese Vorg√§nge mit ‚ÄûVakuum‚Äú verschachtelt werden.  Wir k√∂nnen die Gr√∂√üe von Protokolldatens√§tzen wie folgt bewerten: Merken Sie sich am Anfang und am Ende die Position im Protokoll mit der Funktion "pg_current_wal_location" ("pg_current_xlog_location" in fr√ºheren Versionen als zehn) und sehen Sie sich dann den Unterschied an. <br><br>  Aber nat√ºrlich sollten wir hier viele Aspekte ber√ºcksichtigen.  Wir m√ºssen sicherstellen, dass nur ein Benutzer mit dem System arbeitet (andernfalls werden "zus√§tzliche" Datens√§tze ber√ºcksichtigt).  Selbst wenn dies der Fall ist, ber√ºcksichtigen wir nicht nur RUM, sondern auch Aktualisierungen der Tabelle selbst und des Index, der den Prim√§rschl√ºssel unterst√ºtzt.  Die Werte der Konfigurationsparameter wirken sich auch auf die Gr√∂√üe aus (hier wurde die Protokollstufe "Replikat" ohne Komprimierung verwendet).  Aber lass es uns trotzdem versuchen. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_current_wal_location() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> start_lsn \gset</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> mail_messages(parent_id, sent, subject, author, body_plain, tsv) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> parent_id, sent, subject, author, body_plain, tsv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> id % <span class="hljs-number"><span class="hljs-number">100</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><pre> <code class="plaintext hljs">INSERT 0 3576</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> id % <span class="hljs-number"><span class="hljs-number">100</span></span> = <span class="hljs-number"><span class="hljs-number">99</span></span>;</code> </pre><pre> <code class="plaintext hljs">DELETE 3590</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">vacuum</span></span> mail_messages;</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> mail_messages(parent_id, sent, subject, author, body_plain, tsv) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> parent_id, sent, subject, author, body_plain, tsv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> id % <span class="hljs-number"><span class="hljs-number">100</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs">INSERT 0 3605</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> id % <span class="hljs-number"><span class="hljs-number">100</span></span> = <span class="hljs-number"><span class="hljs-number">98</span></span>;</code> </pre><pre> <code class="plaintext hljs">DELETE 3637</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">vacuum</span></span> mail_messages;</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> mail_messages(parent_id, sent, subject, author, body_plain, tsv) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> parent_id, sent, subject, author, body_plain, tsv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> id % <span class="hljs-number"><span class="hljs-number">100</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs">INSERT 0 3625</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> id % <span class="hljs-number"><span class="hljs-number">100</span></span> = <span class="hljs-number"><span class="hljs-number">97</span></span>;</code> </pre><pre> <code class="plaintext hljs">DELETE 3668</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">vacuum</span></span> mail_messages;</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_current_wal_location() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> end_lsn \gset fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(:<span class="hljs-string"><span class="hljs-string">'end_lsn'</span></span>::pg_lsn - :<span class="hljs-string"><span class="hljs-string">'start_lsn'</span></span>::pg_lsn);</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 3114 MB (1 row)</code> </pre><br>  Wir bekommen also ungef√§hr 3 GB.  Wenn wir jedoch dasselbe Experiment mit dem GIN-Index wiederholen, ergibt dies nur etwa 700 MB. <br><br>  Daher ist es w√ºnschenswert, einen anderen Algorithmus zu haben, der die minimale Anzahl von Einf√ºge- und L√∂schvorg√§ngen findet, die einen Zustand der Seite in einen anderen umwandeln k√∂nnen.  Das Dienstprogramm "Diff" funktioniert auf √§hnliche Weise.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Oleg Ivanov</a> hat einen solchen Algorithmus bereits implementiert und sein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Patch</a> wird diskutiert.  Im obigen Beispiel k√∂nnen wir mit diesem Patch die Gr√∂√üe von Protokolldatens√§tzen auf Kosten einer kleinen Verlangsamung um das 1,5-fache auf 1900 MB reduzieren. <br><br><blockquote>  Leider ist der Patch h√§ngen geblieben und es gibt keine Aktivit√§t um ihn herum. <br></blockquote><br><h2>  Eigenschaften </h2><br>  Schauen wir uns wie √ºblich die Eigenschaften der RUM-Zugriffsmethode an und achten wir dabei auf die Unterschiede zu GIN (Abfragen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wurden bereits bereitgestellt</a> ). <br><br>  Im Folgenden sind die Eigenschaften der Zugriffsmethode aufgef√ºhrt: <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- rum | can_order | f rum | can_unique | f rum | can_multi_col | t rum | can_exclude | t -- f for gin</code> </pre><br>  Die folgenden Indexschicht-Eigenschaften sind verf√ºgbar: <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | f index_scan | t -- f for gin bitmap_scan | t backward_scan | f</code> </pre><br>  Beachten Sie, dass RUM im Gegensatz zu GIN den Index-Scan unterst√ºtzt. Andernfalls w√§re es nicht m√∂glich gewesen, bei Abfragen mit der "limit" -Klausel genau die erforderliche Anzahl von Ergebnissen zur√ºckzugeben.  Das Gegenst√ºck zum Parameter "gin_fuzzy_search_limit" ist dementsprechend nicht erforderlich.  Infolgedessen kann der Index zur Unterst√ºtzung von Ausschlussbeschr√§nkungen verwendet werden. <br><br>  Die folgenden Eigenschaften sind Spaltenebenen: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f distance_orderable | t -- f for gin returnable | f search_array | f search_nulls | f</code> </pre><br>  Der Unterschied besteht darin, dass RUM Bestelloperatoren unterst√ºtzt.  Dies gilt jedoch nicht f√ºr alle Operatorklassen. Dies gilt beispielsweise f√ºr "tsquery_ops". <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lesen Sie weiter</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452116/">https://habr.com/ru/post/de452116/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452106/index.html">Wir laden Redner zum Sommer-DIY-Meeting am 16. Juni 2019 ein</a></li>
<li><a href="../de452108/index.html">Docker: harmloser Rat</a></li>
<li><a href="../de452110/index.html">Automatisieren Sie den Festplattenaustausch mit Ansible</a></li>
<li><a href="../de452112/index.html">CRM ++</a></li>
<li><a href="../de452114/index.html">HolyJS 2019: Nachbesprechung von SEMrush (Teil 1)</a></li>
<li><a href="../de452118/index.html">Wissenschaftler bricht den Code des mysteri√∂sen Manuskripts von Voynich</a></li>
<li><a href="../de452122/index.html">"Pille vom D√§mon" in Bewegung</a></li>
<li><a href="../de452124/index.html">‚ÄûWir brauchen Wissens- und Leistungshunger‚Äú - wie ist es, Tester bei der Alfa-Bank zu sein?</a></li>
<li><a href="../de452128/index.html">Beliebte Missverst√§ndnisse √ºber die Strahlungsbest√§ndigkeit von Mikroschaltungen</a></li>
<li><a href="../de452130/index.html">Der Mond schrumpft, er verursacht Mondbeben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>