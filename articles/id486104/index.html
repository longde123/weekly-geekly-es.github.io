<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>„äóÔ∏è üé± ü§±üèº MVCC dalam PostgreSQL-7. Autovacuum üèâ ü§Ωüèº üê™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Untuk mengingatkan Anda, kami mulai dengan masalah yang berkaitan dengan isolasi , melakukan penyimpangan tentang struktur data tingkat rendah , memba...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC dalam PostgreSQL-7. Autovacuum</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/486104/">  Untuk mengingatkan Anda, kami mulai dengan masalah yang berkaitan dengan <a href="https://habr.com/ru/company/postgrespro/blog/467437/">isolasi</a> , melakukan penyimpangan tentang <a href="https://habr.com/ru/company/postgrespro/blog/469087/">struktur data tingkat rendah</a> , membahas <a href="https://habr.com/ru/company/postgrespro/blog/477648/">versi baris</a> secara terperinci dan mengamati bagaimana <a href="https://habr.com/ru/company/postgrespro/blog/479512/">snapshot data</a> diperoleh dari versi baris. <br><br>  Lalu kami menjelajahi <a href="https://habr.com/ru/company/postgrespro/blog/483768/">vakum halaman (dan pembaruan HOT)</a> dan <a href="https://habr.com/ru/company/postgrespro/blog/484106/">vakum</a> .  Sekarang kita akan melihat autovacuum. <br><br><h1>  Autovacuum </h1><br>  Kami sudah menyebutkan bahwa biasanya (yaitu, ketika tidak ada yang memegang cakrawala transaksi untuk waktu yang lama) VACUUM biasanya melakukan tugasnya.  Masalahnya adalah seberapa sering menyebutnya. <br><br>  Jika kita menyedot meja ganti terlalu jarang, ukurannya akan tumbuh lebih dari yang diinginkan.  Selain itu, operasi vakum berikutnya mungkin memerlukan beberapa melewati indeks jika terlalu banyak perubahan dilakukan. <br><br>  Jika kita menyedot meja terlalu sering, server akan terus melakukan pemeliharaan daripada pekerjaan yang bermanfaat - dan ini juga tidak baik. <br><br>  Perhatikan bahwa meluncurkan VACUUM sesuai jadwal tidak berarti menyelesaikan masalah karena beban kerja dapat berubah seiring waktu.  Jika tabel mulai berubah lebih intensif, itu harus disedot lebih sering. <br><br>  Autovacuum adalah teknik tepat yang memungkinkan kami meluncurkan penyedotan tergantung pada seberapa intensif perubahan tabelnya. <br><a name="habracut"></a><br>  Ketika autovacuum dihidupkan (set parameter konfigurasi <em>autovacuum</em> diatur), proses daemon <strong>peluncur autovacuum</strong> dimulai, yang merencanakan pekerjaan.  Vakum sendiri dilakukan oleh proses <strong>pekerja autovacuum</strong> , beberapa contoh yang dapat berjalan secara paralel. <br><br>  Proses <strong>peluncur autovacuum</strong> menyusun daftar basis data tempat aktivitas apa pun terjadi.  Aktivitas ditentukan dari statistik, dan untuk mengumpulkannya, parameter <em>track_counts</em> harus ditetapkan.  Jangan pernah mematikan <em>autovacuum</em> dan <em>track_counts</em> , jika tidak, fitur autovacuum tidak akan berfungsi. <br><br>  Setelah setiap detik <em>autovacuum_naptime</em> , <strong>peluncur autovacuum</strong> dimulai (menggunakan proses <strong>postmaster</strong> ) proses pekerja untuk setiap database dalam daftar.  Dengan kata lain, jika ada beberapa aktivitas dalam database, proses pekerja akan dikirim ke sana pada interval detik <em>autovacuum_naptime</em> .  Untuk tujuan ini, jika beberapa (N) database aktif tersedia, proses pekerja diluncurkan N kali sesering setiap detik <em>autovacuum_naptime</em> .  Tetapi jumlah total proses pekerja yang berjalan bersamaan dibatasi oleh parameter <em>autovacuum_max_workers</em> . <br><br>  Ketika dimulai, proses pekerja terhubung ke database yang ditugaskan untuknya dan mulai dengan membuat daftar: <br><br><ul><li>  Semua tabel, tampilan terwujud dan tabel TOAST yang membutuhkan penghisap debu. </li><li>  Semua tabel dan tampilan terwujud yang memerlukan analisis (tabel TOAST tidak dianalisis karena selalu dijangkau dengan akses indeks). </li></ul><br>  Kemudian pekerja memproses vakuum dan / atau menganalisis objek pada daftar satu per satu dan selesai saat menyedot debu selesai. <br><br>  Jika proses tidak dapat melakukan semua pekerjaan yang direncanakan dalam detik <em>autovacuum_naptime</em> , proses <strong>peluncur autovacuum</strong> akan mengirimkan satu proses pekerja lagi ke database ini, dan mereka akan bekerja bersama.  "Bersama" hanya berarti bahwa proses kedua akan membangun daftar sendiri dan bekerja melewatinya.  Jadi, hanya tabel yang berbeda yang akan diproses secara paralel, tetapi tidak ada paralelisme di tingkat satu tabel - jika salah satu proses pekerja sudah menangani tabel, proses lain akan melewatkannya dan melanjutkan lebih jauh. <br><br>  Sekarang mari kita perjelas lebih rinci apa yang dimaksud dengan "memerlukan penghisap debu" dan "memerlukan analisis". <br><br><blockquote>  Baru-baru ini <a href="https://commitfest.postgresql.org/23/1774/">patch</a> dilakukan yang memungkinkan vakum untuk memproses indeks secara paralel dengan pekerja latar belakang. <br></blockquote><br><h1>  Tabel apa yang membutuhkan penghisap debu? </h1><br>  Penyedotan debu dianggap diperlukan jika jumlah tupel yang mati (yaitu kedaluwarsa) melebihi ambang batas yang ditentukan.  Kolektor statistik secara permanen melacak jumlah tupel mati, yang disimpan dalam tabel <code>pg_stat_all_tables</code> .  Dan dua parameter menentukan ambang batas: <br><br><ul><li>  <em>autovacuum_vacuum_threshold</em> mendefinisikan nilai absolut (jumlah tupel). </li><li>  <em>autovacuum_vacuum_scale_factor</em> mendefinisikan pembagian baris dalam tabel. </li></ul><br>  Singkatnya: menyedot debu diperlukan jika <code>pg_stat_all_tables.n_dead_tup</code> &gt; = <em>autovacuum_vacuum_threshold</em> + <em>autovacuum_vacuum_valeum_scale_factor</em> * <code>pg_class.reltupes</code> . <br><br>  Dengan pengaturan default, <em>autovacuum_vacuum_threshold</em> = 50 dan <em>autovacuum_vacuum_scale_factor</em> = 0.2.  <em>autovacuum_vacuum_scale_factor</em> , tentu saja, yang paling penting di sini - parameter ini yang sangat penting untuk tabel besar (dan itu adalah mereka yang mungkin terkait dengan masalah).  Nilai 20% tampaknya terlalu tinggi, dan kemungkinan besar itu harus sangat dikurangi. <br><br>  Nilai optimal dari parameter dapat bervariasi untuk tabel yang berbeda dan tergantung pada ukuran tabel dan spesifikasi perubahan.  Masuk akal untuk menetapkan nilai yang umumnya sesuai dan, jika perlu, lakukan penyesuaian khusus pada parameter pada tingkat tabel tertentu dengan menggunakan parameter penyimpanan: <br><br><ul><li>  <em>autovacuum_vacuum_threshold</em> dan <em>bersulang.autovacuum_vacuum_threshold</em> . </li><li>  <em>autovacuum_vacuum_scale_factor</em> dan <em>bersulang.autovacuum_vacuum_scale_factor</em> . </li></ul><br>  Untuk menghindari kebingungan, ini masuk akal untuk dilakukan hanya untuk beberapa tabel yang dibedakan di antara yang lainnya dengan jumlah dan intensitas perubahan dan hanya ketika nilai yang ditetapkan secara global gagal berfungsi dengan baik. <br><br>  Selain itu, Anda dapat mematikan autovacuum di tingkat meja (meskipun kami hampir tidak dapat memikirkan alasan mengapa itu bisa diperlukan): <br><br><ul><li>  <em>autovacuum_enabled</em> dan <em>bersulang.autovacuum_enabled</em> . </li></ul><br>  Misalnya, terakhir kali kami membuat tabel <code>vac</code> dengan autovacuum dimatikan untuk mengontrol penyedotan debu secara manual untuk tujuan demo.  Parameter penyimpanan dapat diubah sebagai berikut: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>);</code> </pre><br>  Untuk memformalkan semua hal di atas, mari kita buat tampilan yang menunjukkan tabel mana yang perlu disedot pada saat ini.  Ini akan menggunakan fungsi yang mengembalikan nilai parameter saat ini dan memperhitungkan bahwa nilai tersebut dapat didefinisikan ulang di tingkat tabel: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> get_value(param <span class="hljs-type"><span class="hljs-type">text</span></span>, reloptions <span class="hljs-type"><span class="hljs-type">text</span></span>[], relkind "char") <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="ruby"><span class="ruby"> SELECT coalesce( -- </span><span class="hljs-keyword"><span class="ruby"><span class="hljs-keyword">if</span></span></span><span class="ruby"> the storage parameter is set, we take its value (SELECT option_value FROM pg_options_to_table(reloptions) WHERE option_name = CASE -- </span><span class="hljs-keyword"><span class="ruby"><span class="hljs-keyword">for</span></span></span><span class="ruby"> TOAST tables, the parameter name differs WHEN relkind = </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">'t'</span></span></span><span class="ruby"> THEN </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">'toast.'</span></span></span><span class="ruby"> ELSE </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">''</span></span></span><span class="ruby"> </span><span class="hljs-keyword"><span class="ruby"><span class="hljs-keyword">END</span></span></span><span class="ruby"> </span><span class="hljs-params"><span class="ruby"><span class="hljs-params">||</span></span></span><span class="ruby"> param ), -- otherwise, we take the value of the configuration parameter current_setting(param) )</span><span class="hljs-symbol"><span class="ruby"><span class="hljs-symbol">:</span></span></span><span class="hljs-symbol"><span class="ruby"><span class="hljs-symbol">:float</span></span></span><span class="ruby">; $$</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br>  Dan inilah pandangannya: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> st.schemaname || <span class="hljs-string"><span class="hljs-string">'.'</span></span> || st.relname tablename, st.n_dead_tup dead_tup, get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_vacuum_threshold'</span></span>, c.reloptions, c.relkind) + get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_vacuum_scale_factor'</span></span>, c.reloptions, c.relkind) * c.reltuples max_dead_tup, st.last_autovacuum <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_all_tables st, pg_class c <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c.oid = st.relid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> c.relkind <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'r'</span></span>,<span class="hljs-string"><span class="hljs-string">'m'</span></span>,<span class="hljs-string"><span class="hljs-string">'t'</span></span>);</code> </pre><br><h1>  Tabel apa yang membutuhkan analisis? </h1><br>  Situasi dengan analisis otomatis serupa.  Tabel-tabel tersebut dianggap memerlukan analisis yang jumlah tupel yang diperbarui (sejak analisis terakhir) melebihi ambang yang ditentukan oleh dua parameter yang serupa: <code>pg_stat_all_tables.n_mod_since_analyze</code> &gt; = <em>autovacuum_analyze_threshold</em> + <em>autovacuum_analyze_scale_factor</em> * <code>pg_class.reltupes</code> . <br><br>  Pengaturan default analisis otomatis agak berbeda: <em>autovacuum_analyze_threshold</em> = 50 dan <em>autovacuum_analyze_scale_factor</em> = 0,1.  Mereka juga dapat didefinisikan pada tingkat parameter penyimpanan tabel terpisah: <br><br><ul><li>  <em>autovacuum_analyze_threshold</em> </li><li>  <em>autovacuum_analyze_scale_factor</em> </li></ul><br>  Karena tabel TOAST tidak dianalisis, mereka tidak memiliki parameter seperti itu. <br><br>  Mari kita juga membuat tampilan untuk analisis: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> need_analyze <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> st.schemaname || <span class="hljs-string"><span class="hljs-string">'.'</span></span> || st.relname tablename, st.n_mod_since_analyze mod_tup, get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_analyze_threshold'</span></span>, c.reloptions, c.relkind) + get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_analyze_scale_factor'</span></span>, c.reloptions, c.relkind) * c.reltuples max_mod_tup, st.last_autoanalyze <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_all_tables st, pg_class c <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c.oid = st.relid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> c.relkind <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'r'</span></span>,<span class="hljs-string"><span class="hljs-string">'m'</span></span>);</code> </pre><br><h1>  Contoh </h1><br>  Mari tetapkan nilai parameter berikut untuk percobaan: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> autovacuum_naptime = <span class="hljs-string"><span class="hljs-string">'1s'</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- to aviod waiting long =&gt; ALTER SYSTEM SET autovacuum_vacuum_scale_factor = 0.03; -- 3% =&gt; ALTER SYSTEM SET autovacuum_vacuum_threshold = 0; =&gt; ALTER SYSTEM SET autovacuum_analyze_scale_factor = 0.02; -- 2% =&gt; ALTER SYSTEM SET autovacuum_analyze_threshold = 0;</span></span></code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><pre> <code class="plaintext hljs"> pg_reload_conf ---------------- t (1 row)</code> </pre><br>  Sekarang mari kita buat tabel yang mirip dengan yang digunakan terakhir kali dan masukkan seribu baris ke dalamnya.  Autovacuum dimatikan di tingkat meja, dan kami akan menyalakannya sendiri.  Tanpa ini, contoh-contoh tidak akan dapat direproduksi karena autovacuuming dapat dipicu pada waktu yang buruk. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> g.id,<span class="hljs-string"><span class="hljs-string">'A'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1000</span></span>) g(id);</code> </pre><br>  Inilah yang akan ditampilkan oleh pandangan kami untuk menyedot debu: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+----------------- public.autovac | 0 | 0 | (1 row)</code> </pre><br>  Perhatian di sini harus diberikan pada dua hal.  Pertama, <code>max_dead_tup</code> = 0 walaupun 3% dari 1000 baris menghasilkan 30 baris.  Masalahnya adalah kita belum memiliki statistik di atas meja karena INSERT tidak memperbaruinya sendiri.  Sampai tabel dianalisis, nol akan tetap ada sejak <code>pg_class.reltuples</code> = 0. Tapi mari kita lihat tampilan kedua untuk analisis: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_analyze <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | mod_tup | max_mod_tup | last_autoanalyze ----------------+---------+-------------+------------------ public.autovac | 1000 | 0 | (1 row)</code> </pre><br>  Karena 1000 baris telah diubah (ditambahkan) dalam tabel, yang lebih besar dari nol, analisis otomatis harus dipicu.  Mari kita periksa ini: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>);</code> </pre><br>  Setelah jeda singkat, kita dapat melihat bahwa tabel telah dianalisis dan perbaiki 20 baris ditampilkan dalam <code>max_dead_tup</code> alih-alih nol: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_analyze <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | mod_tup | max_mod_tup | last_autoanalyze ----------------+---------+-------------+------------------------------- public.autovac | 0 | 20 | 2019-05-21 11:59:48.465987+03 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> reltuples, relpages <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> reltuples | relpages -----------+---------- 1000 | 17 (1 row)</code> </pre><br>  Mari kita kembali ke autovacuuming: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+----------------- public.autovac | 0 | 30 | (1 row)</code> </pre><br>  Seperti yang bisa kita lihat, <code>max_dead_tup</code> sudah diperbaiki.  Hal lain yang perlu diperhatikan adalah <code>dead_tup</code> = 0. Statistik menunjukkan bahwa tabel tidak memiliki tuple mati ..., dan ini benar.  Belum ada yang vakum di meja.  Setiap tabel yang digunakan secara eksklusif dalam mode append-only tidak akan disedot dan oleh karena itu, peta visibilitas tidak akan diperbarui untuknya.  Tetapi hal ini membuat pemindaian hanya-indeks tidak mungkin dilakukan. <br><br>  (Lain kali kita akan melihat bahwa menyedot debu cepat atau lambat akan mencapai tabel hanya-append, tetapi ini akan terjadi terlalu jarang.) <br><br>  Pelajaran yang dipetik: jika pemindaian hanya indeks sangat penting, mungkin diperlukan untuk memanggil proses vakum secara manual. <br><br>  Sekarang mari kita matikan lagi autovacuum dan perbarui 31 baris, yang merupakan satu baris lebih besar dari ambang batas. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id &lt;= <span class="hljs-number"><span class="hljs-number">31</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+----------------- public.autovac | 31 | 30 | (1 row)</code> </pre><br>  Sekarang kondisi pemicu vakum terpenuhi.  Mari aktifkan autovacuum dan setelah jeda singkat kita akan melihat bahwa tabel telah diproses: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+------------------------------- public.autovac | 0 | 30 | 2019-05-21 11:59:52.554571+03 (1 row)</code> </pre><br><h1>  Muatkan pelambatan </h1><br>  VACUUM tidak memblokir proses lain karena ini bekerja halaman demi halaman, tetapi menghasilkan beban tambahan pada sistem dan secara signifikan dapat mempengaruhi kinerja. <br><br><h2>  Mencekik untuk vakum </h2><br>  Untuk dapat mengontrol intensitas vakum dan karena itu, efeknya pada sistem, proses bergantian bekerja dan menunggu.  Prosesnya akan melakukan tentang <em>vacuum_cost_limit</em> unit kerja konvensional dan kemudian akan tidur untuk ms <em>vacuum_cost_delay</em> . <br><br>  Pengaturan default adalah <em>vacuum_cost_limit</em> = 200 dan <em>vacuum_cost_delay</em> = 0. Nol terakhir sebenarnya berarti bahwa VACUUM tidak tidur, jadi nilai spesifik dari <em>vacuum_cost_limit</em> tidak masalah sama sekali.  Alasan di balik ini adalah bahwa jika seorang administrator memang harus meluncurkan VACUUM secara manual, ia kemungkinan berharap penyedotan debu dilakukan secepat mungkin. <br><br>  Namun demikian, jika kita mengatur waktu tidur, jumlah pekerjaan yang ditentukan dalam <em>vacuum_cost_limit</em> akan terdiri dari biaya pekerjaan dengan halaman dalam cache buffer.  Setiap akses halaman diperkirakan sebagai berikut: <br><br><ul><li>  Jika halaman ditemukan dalam cache buffer, <em>vacuum_cost_page_hit</em> = 1. </li><li>  Jika tidak ditemukan, <em>vacuum_cost_page_miss</em> = 10. </li><li>  Jika tidak ditemukan dan halaman yang kotor harus digusur dari cache buffer, <em>vacuum_cost_page_dirty</em> = 20. </li></ul><br>  Artinya, dengan pengaturan default <em>vacuum_cost_limit</em> , 200 halaman cache atau 20 halaman disk atau 10 halaman dengan penggusuran dapat diproses dalam sekali jalan.  Jelas bahwa angka-angka ini cukup sementara, tetapi tidak masuk akal untuk memilih yang lebih akurat. <br><br><h2>  Pembatasan untuk autovacuuming </h2><br>  Untuk proses vakum, pelambatan beban bekerja dengan cara yang sama seperti untuk VACUUM.  Tetapi untuk proses autovacuum dan secara manual meluncurkan VACUUM untuk bekerja dengan intensitas yang berbeda, autovacuum memiliki parameter sendiri: <em>autovacuum_vacuum_cost_limit</em> dan <em>autovacuum_vacuum_cost_delay</em> .  Jika parameter ini memiliki nilai -1, nilai <em>vacuum_cost_limit</em> dan / atau <em>vacuum_cost_delay</em> digunakan. <br><br>  Secara default <em>autovacuum_vacuum_cost_limit</em> = -1 ( <em>mis</em> . Nilai <em>vacuum_cost_limit</em> = 200 digunakan) dan <em>autovacuum_vacuum_cost_delay</em> = 20 ms.  Pada perangkat keras modern, autovacuum akan sangat lambat. <br><br>  Dalam versi 12, nilai <em>autovacuum_vacuum_cost_delay</em> dikurangi menjadi 2 ms, yang dapat diambil untuk perkiraan pertama yang lebih tepat. <br><br>  Selain itu, kita harus mencatat bahwa batas yang ditentukan oleh pengaturan ini adalah umum untuk semua proses pekerja.  Dengan kata lain, ketika jumlah proses pekerja simultan berubah, beban keseluruhan tetap tidak berubah.  Jadi, untuk meningkatkan kinerja autovacuum, ketika menambahkan proses pekerja, masuk akal juga untuk meningkatkan <em>autovacuum_vacuum_cost_limit</em> . <br><br><h2>  Penggunaan memori dan pemantauan </h2><br>  <a href="https://habr.com/ru/company/postgrespro/blog/484106/">Terakhir kali</a> kami mengamati bagaimana VACUUM menggunakan RAM dengan ukuran <em>maintenance_work_mem</em> untuk menyimpan data yang akan disedot. <br><br>  Autovacuum benar-benar sama.  Tetapi bisa ada banyak proses pekerja simultan jika <em>autovacuum_max_workers</em> diatur ke nilai yang besar.  Selain itu, semua memori dialokasikan sekaligus daripada saat diperlukan.  Oleh karena itu, untuk proses pekerja, batasannya sendiri dapat ditetapkan dengan menggunakan parameter <em>autovacuum_work_mem</em> .  Nilai default dari parameter ini adalah -1, yaitu tidak digunakan. <br><br>  Seperti yang telah disebutkan, VACUUM juga dapat bekerja dengan ukuran memori minimum.  Tetapi jika indeks dibuat di atas meja, nilai kecil <em>maintenance_work_mem</em> dapat memerlukan pemindaian indeks berulang.  Hal yang sama berlaku untuk autovacuum.  Idealnya, <em>autovacuum_work_mem</em> harus memiliki nilai minimum sehingga tidak terjadi pemindaian berulang. <br><br>  Kami telah melihat bahwa untuk memantau VACUUM, opsi VERBOSE dapat digunakan (yang tidak dapat ditentukan untuk autovacuum) atau tampilan <code>pg_stat_progress_vacuum</code> (yang, bagaimanapun, hanya menampilkan informasi terkini).  Oleh karena itu, sarana utama untuk memantau autovacuuming adalah dengan menggunakan parameter <em>log_autovacuum_min_duration</em> , yang menampilkan informasi ke log pesan server.  Secara default dimatikan (diatur ke -1).  Masuk akal untuk mengaktifkan parameter ini (dengan nilai 0, informasi tentang semua proses autovacuum akan menjadi output) dan perhatikan angka-angkanya. <br><br>  Seperti inilah informasi output: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> log_autovacuum_min_duration = <span class="hljs-number"><span class="hljs-number">0</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><pre> <code class="plaintext hljs"> pg_reload_conf ---------------- t (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id &lt;= <span class="hljs-number"><span class="hljs-number">31</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">student$ tail -n 7 /var/log/postgresql/postgresql-11-main.log</code> </pre><pre> <code class="plaintext hljs">2019-05-21 11:59:55.675 MSK [9737] LOG: automatic vacuum of table "test.public.autovac": index scans: 0 pages: 0 removed, 18 remain, 0 skipped due to pins, 0 skipped frozen tuples: 31 removed, 1000 remain, 0 are dead but not yet removable, oldest xmin: 4040 buffer usage: 78 hits, 0 misses, 0 dirtied avg read rate: 0.000 MB/s, avg write rate: 0.000 MB/s system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s 2019-05-21 11:59:55.676 MSK [9737] LOG: automatic analyze of table "test.public.autovac" system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s</code> </pre><br>  Semua informasi yang diperlukan tersedia di sini. <br><br>  Untuk mengingatkan Anda, sering kali masuk akal untuk menurunkan ambang batas untuk pemicu vakum untuk memproses lebih sedikit data pada satu waktu daripada meningkatkan ukuran memori. <br><br>  Mungkin juga masuk akal untuk menggunakan tampilan di atas untuk memonitor panjang daftar tabel yang membutuhkan penyedotan.  Peningkatan panjang daftar akan menunjukkan bahwa proses autovacuum tidak memiliki waktu untuk melakukan pekerjaan mereka dan pengaturan perlu diubah. <br><br>  Untuk dilanjutkan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id486104/">https://habr.com/ru/post/id486104/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id486070/index.html">ACL beralih secara detail</a></li>
<li><a href="../id486080/index.html">Izinkan saya memperkenalkan: Veeam Availability Suite v10</a></li>
<li><a href="../id486084/index.html">Mengganti disk yang lebih kecil dengan disk yang lebih besar di Linux</a></li>
<li><a href="../id486094/index.html">House Demokrat Bertempur di Lembah Silikon</a></li>
<li><a href="../id486100/index.html">Bagaimana cara membuat aplikasi terdesentralisasi yang berkembang? Gunakan lebih sedikit blockchain</a></li>
<li><a href="../id486106/index.html">Backlight Adaptif untuk Raspberry Pi TV - Ambilight Analog</a></li>
<li><a href="../id486114/index.html">Ilmuwan terkemuka di bidang ilmu saraf akan berkumpul di kongres tahunan serikat industri neuronet</a></li>
<li><a href="../id486120/index.html">Normalisasi penyimpangan. Bagaimana praktik yang salah menjadi norma di industri kami</a></li>
<li><a href="../id486122/index.html">Child ReactJS dengan 135 baris kode</a></li>
<li><a href="../id486124/index.html">Impala vs Hive vs Spark SQL: Memilih mesin SQL yang tepat untuk bekerja dengan baik di Gudang Data Cloudera</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>