<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äçüè´ üßìüèø üï¥üèª (in) Guerra finita üèáüèæ üññüèæ üïõ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tenemos un problema El problema con las pruebas. El problema con probar componentes React, y es bastante fundamental. Se trata de la diferencia entre ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>(in) Guerra finita</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436692/"><p><img src="https://habrastorage.org/webt/4w/m4/cc/4wm4ccdyq2tqs2giqspeys3e9sa.jpeg" alt="guerra infinita"></p><br><p> Tenemos un problema  El problema con las pruebas.  El problema con probar componentes React, y es bastante fundamental.  Se trata de la diferencia entre las <code>unit testing</code> y las <code>integration testing</code> .  Se trata de la diferencia entre lo que llamamos pruebas unitarias y lo que llamamos pruebas de integraci√≥n, el tama√±o y el alcance. </p><br><p>  No se trata de probarse a s√≠ mismo, sino de Arquitectura de componentes.  Acerca de la diferencia entre probar <strong>componentes</strong> , bibliotecas independientes y <strong>aplicaciones</strong> finales. </p><br><p>  Todos saben c√≥mo probar componentes simples (son simples), probablemente sepan c√≥mo probar aplicaciones (E2E).  C√≥mo probar cosas <em>finitas</em> e <em>infinitas</em> ... </p><a name="habracut"></a><br><h2 id="define-the-problem">  Definir el problema </h2><br><p>  Hay 2 formas diferentes de probar React Component: <code>shallow</code> y todo lo dem√°s, incluido el <code>mount</code> , <code>react-testing-library</code> <code>webdriver</code> , el <code>webdriver</code> , etc.  Solo <code>shallow</code> es especial: el resto se comporta de la misma manera. </p><br><p>  Y esta diferencia es sobre <em>el tama√±o y el alcance</em> : sobre QU√â se probar√≠a, y solo parcialmente <em>c√≥mo</em> . </p><br><p>  En resumen: <code>shallow</code> solo registrar√° llamadas a React.createElement, pero no ejecutar√° ning√∫n efecto secundario, incluida la representaci√≥n de elementos DOM: es un efecto secundario (algebraico) de React.createElement. </p><br><p>  Cualquier otro comando ejecutar√° el c√≥digo que proporcion√≥ con todos y cada uno de los efectos secundarios que tambi√©n se ejecutan.  Como ser√≠a en real, y ese es el objetivo. </p><br><p>  Y <strong>el problema</strong> es el siguiente: <code>you can NOT run each and every side effect</code> . </p><br><h3 id="why-not">  Por que no </h3><br><p>  Funci√≥n de pureza?  Pureza e Inmutabilidad: las vacas santas de hoy.  Y est√°s matando a uno de ellos.  Los axiomas de las pruebas unitarias: sin efectos secundarios, aislamiento, burlas, todo bajo control. </p><br><ul><li><p>  Pero eso <em>no</em> es <em>un problema</em> para ... <code>dumb components</code> .  Son tontos, contienen solo la capa de presentaci√≥n, pero no "efectos secundarios". </p><br></li><li><p>  Pero eso es <em>un problema</em> para los <code>Containers</code> .  Siempre y cuando no sean tontos, contengan lo que quieran y est√©n completamente relacionados con los efectos secundarios.  Ellos son el problema! </p><br></li></ul><br><p>  Probablemente, si definimos las reglas de "El Componente Correcto" podr√≠amos probar f√°cilmente: nos guiar√° y nos ayudar√°. </p><br><blockquote>  TRDL: el componente finito </blockquote><br><h2 id="smart-and-dumb-components">  Componentes inteligentes y tontos </h2><br><p>  De acuerdo con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dan Abramov, los</a> componentes de presentaci√≥n del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo</a> son: </p><br><ul><li>  Les preocupa c√≥mo se ven las cosas. </li><li>  Puede contener componentes de presentaci√≥n y contenedor <code>**</code> interior y, por lo general, tiene algunas marcas DOM y estilos propios. </li><li>  A menudo permiten la contenci√≥n a trav√©s de this.props.children. </li><li>  No dependa del resto de la aplicaci√≥n, como acciones o tiendas Flux. </li><li>  No especifique c√≥mo se cargan o mutan los datos. </li><li>  Reciba datos y devoluciones de llamadas exclusivamente a trav√©s de accesorios. </li><li>  Raramente tienen su propio estado (cuando lo hacen, es el estado de la interfaz de usuario en lugar de los datos). </li><li>  Se escriben como componentes funcionales a menos que necesiten estado, ganchos de ciclo de vida u optimizaciones de rendimiento. </li><li>  Ejemplos: p√°gina, barra lateral, historia, informaci√≥n de usuario, lista. </li><li>  .... </li><li>  Y los contenedores son solo proveedores de datos / accesorios para estos componentes. </li></ul><br><p>  Seg√∫n los or√≠genes: <strong>en la aplicaci√≥n ideal ...</strong> <strong><br></strong>  <strong>Los contenedores son el √°rbol.</strong>  <strong>Los componentes son hojas de √°rbol.</strong> </p><br><h4 id="find-the-black-cat-in-the-dark-room">  Encuentra al gato negro en el cuarto oscuro </h4><br><p>  La salsa secreta aqu√≠, un cambio que tenemos que enmendar en esta definici√≥n, est√° oculto dentro de <em>"Puede contener componentes tanto de presentaci√≥n como de contenedor <code>**</code> "</em> , perm√≠tanme citar el art√≠culo original: </p><br><blockquote>  En una versi√≥n anterior de este art√≠culo, afirm√© que los componentes de presentaci√≥n solo deber√≠an contener otros componentes de presentaci√≥n.  Ya no creo que este sea el caso.  Si un componente es un componente de presentaci√≥n o un contenedor es su detalle de implementaci√≥n.  Deber√≠a poder reemplazar un componente de presentaci√≥n con un contenedor sin modificar ninguno de los sitios de llamadas.  Por lo tanto, tanto los componentes de presentaci√≥n como los de contenedor pueden contener otros componentes de presentaci√≥n o de contenedor perfectamente. </blockquote><p>  Ok, pero ¬øqu√© pasa con la regla, que hace que la unidad de componentes de presentaci√≥n sea comprobable: <em>"No tiene dependencias del resto de la aplicaci√≥n"</em> ? </p><br><p>  Desafortunadamente, al incluir contenedores en los componentes de la presentaci√≥n, los segundos se vuelven <strong>infinitos</strong> y se inyecta dependencia al resto de la aplicaci√≥n. </p><br><p>  Probablemente eso no sea algo que deb√≠as hacer.  Entonces, no tengo otra opci√≥n, pero hacer que el componente tonto sea finito: </p><br><p>  <strong>LOS COMPONENTES DE PRESENTACI√ìN SOLO DEBEN CONTENER OTROS COMPONENTES DE PRESENTACI√ìN</strong> </p><br><p>  Y la √∫nica pregunta que debe hacer (mirando su base de c√≥digo actual): <em>¬øC√≥mo?</em>  : tableflip:?! </p><br><p>  Hoy, los componentes y contenedores de presentaci√≥n no solo est√°n enredados, sino que a veces no se extraen como entidades "puras" (hola GraphQL). </p><br><h4 id="solution-1---di">  Soluci√≥n 1 - DI </h4><br><p>  La soluci√≥n 1 es simple: no contenga contenedores anidados en el componente tonto: contenga <code>slots</code> .  Simplemente acepte "contenido" (ni√±os), como accesorios, y eso resolver√≠a el problema: </p><br><ul><li>  puede probar el componente tonto sin "el resto de su aplicaci√≥n" </li><li>  puede probar la integraci√≥n con prueba de humo / integraci√≥n / e2e, no pruebas. </li></ul><br><pre> <code class="plaintext hljs">// Test me with mount, with "slots emty". const PageChrome = ({children, aside}) =&gt; ( &lt;section&gt; &lt;aside&gt;{aside}&lt;/aside&gt; {children} &lt;/section&gt; ); // test me with shallow, or real integration test const PageChromeContainer = () =&gt; ( &lt;PageChrome aside={&lt;ASideContainer /&gt;}&gt; &lt;Page /&gt; &lt;/PageChrome&gt; );</code> </pre> <br><p>  Aprobado por el propio Dan: <br>  {% twitter 1021850499618955272%} </p><br><p>  La DI (tanto la inyecci√≥n de dependencia como la inversi√≥n de dependencia), probablemente, es la t√©cnica m√°s reutilizable aqu√≠, capaz de hacerte la vida mucho m√°s f√°cil. </p><br><blockquote>  Se√±ale aqu√≠: ¬°los componentes tontos son tontos! </blockquote><br><h4 id="solution-2---boundaries">  Soluci√≥n 2 - L√≠mites </h4><br><p>  Esta es una soluci√≥n bastante declarativa, y podr√≠a extender la <code>Solution 1</code> : simplemente declare todos los puntos de <em>extensi√≥n</em> .  Solo envu√©lvelos con ... <code>Boundary</code> </p><br><pre> <code class="plaintext hljs">const Boundary = ({children}) =&gt; ( process.env.NODE_ENV === 'test' ? null : children // or `jest.mock` ); const PageChrome = () =&gt; ( &lt;section&gt; &lt;aside&gt;&lt;Boundary&gt;&lt;ASideContainer /&gt;&lt;/Boundary&gt;&lt;/aside&gt; &lt;Boundary&gt;&lt;Page /&gt;&lt;/Boundary&gt; &lt;/section&gt; );</code> </pre> <br><p>  Luego, puede desactivar, solo cero, <code>Boundary</code> para reducir el alcance del Componente y hacerlo <em>finito</em> . </p><br><blockquote>  Punto aqu√≠: el l√≠mite est√° en el nivel de componente tonto.  El componente tonto controla cu√°n tonto es. </blockquote><br><h3 id="solution-3---tier">  Soluci√≥n 3 - Nivel </h3><br><p>  Es lo mismo que la Soluci√≥n 2, pero con un l√≠mite m√°s inteligente, capaz de simular <em>capa</em> o <em>nivel</em> , o lo que usted diga: </p><br><pre> <code class="plaintext hljs">const checkTier = tier =&gt; tier === currentTier; const withTier = tier =&gt; WrapperComponent =&gt; (props) =&gt; ( (process.env.NODE_ENV !== 'test' || checkTier(tier)) &amp;&amp; &lt;WrapperComponent{...props} /&gt; ); const PageChrome = () =&gt; ( &lt;section&gt; &lt;aside&gt;&lt;ASideContainer /&gt;&lt;/aside&gt; &lt;Page /&gt; &lt;/section&gt; ); const ASideContainer = withTier('UI')(...) const Page = withTier('Page')(...) const PageChromeContainer = withTier('UI')(PageChrome);</code> </pre> <br><blockquote>  Incluso si esto es casi similar al ejemplo de l√≠mite: el componente tonto es tonto y los contenedores controlan la visibilidad de otros contenedores. </blockquote><br><h4 id="solution-4---separate-concerns">  Soluci√≥n 4 - Preocupaciones separadas </h4><br><p>  ¬°Otra soluci√≥n es solo separar las preocupaciones!  Quiero decir, ya lo hiciste, y probablemente es hora de utilizarlo. </p><br><blockquote>  Al <code>connect</code> componente a Redux o GQL, est√° produciendo contenedores <em>conocidos</em> .  Quiero decir, con nombres <em>conocidos</em> , <code>Container(WrapperComponent)</code> .  Puedes burlarte de ellos por sus nombres </blockquote><br><pre> <code class="plaintext hljs">const PageChrome = () =&gt; ( &lt;section&gt; &lt;aside&gt;&lt;ASideContainer /&gt;&lt;/aside&gt; &lt;Page /&gt; &lt;/section&gt; ); // remove all components matching react-redux pattern reactRemock.mock(/Connect\(\w\)/) // all any other container reactRemock.mock(/Container/)</code> </pre> <br><p>  Este enfoque es un poco grosero: lo borrar√° <em>todo</em> , lo que har√° que sea m√°s dif√≠cil probar los Contaiers, y puede usar burlas un poco m√°s complejas para mantener el "primero": </p><br><pre> <code class="plaintext hljs">import {createElement, remock} from 'react-remock'; // initially "open" const ContainerCondition = React.createContext(true); reactRemock.mock(/Connect\(\w\)/, (type, props, children) =&gt; ( &lt;ContainerCondition.Consumer&gt; { opened =&gt; ( opened ? ( // "close" and render real component &lt;ContainerCondition.Provider value={false}&gt; {createElement(type, props, ...children)} &lt;ContainerCondition.Provider&gt; ) // it's "closed" : null )} &lt;/ContainerCondition.Consumer&gt; )</code> </pre> <br><blockquote>  Se√±ale aqu√≠: no hay l√≥gica dentro ni Presentaci√≥n, no Contenedor: toda la l√≥gica est√° afuera. </blockquote><br><h4 id="bonus-solution---separate-concerns">  Soluci√≥n adicional: preocupaciones separadas </h4><br><p>  Puede mantener <em>un acoplamiento estrecho</em> con <code>defaultProps</code> y anular estos accesorios en las pruebas ... </p><br><pre> <code class="plaintext hljs">const PageChrome = ({Content = Page, Aside = ASideContainer}) =&gt; ( &lt;section&gt; &lt;aside&gt;&lt;Aside/&gt;&lt;/aside&gt; &lt;Content/&gt; &lt;/section&gt; );</code> </pre> <br><h2 id="so">  Entonces? </h2><br><p>  As√≠ que acabo de publicar algunas formas de reducir el alcance de cualquier componente y hacer que sean mucho m√°s comprobables.  La forma simple de sacar un <code>gear</code> de la <code>gearbox</code> de <code>gearbox</code> .  Un patr√≥n simple para hacerte la vida m√°s f√°cil. </p><br><p>  Las pruebas E2E son excelentes, pero es dif√≠cil simular algunas condiciones, que podr√≠an ocurrir dentro de una caracter√≠stica profundamente anidada y estar listas para ellas.  Debe tener pruebas unitarias para poder simular diferentes escenarios.  Debe tener pruebas de integraci√≥n para asegurarse de que todo est√© conectado correctamente. </p><br><p>  Ya sabes, como Dan escribi√≥ en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">su otro art√≠culo</a> : </p><br><blockquote>  Por ejemplo, si un bot√≥n puede estar en uno de los 5 estados diferentes (normal, activo, flotante, peligro, desactivado), el c√≥digo que actualiza el bot√≥n debe ser correcto para 5 √ó 4 = 20 posibles transiciones, o prohibir algunas de ellas.  ¬øC√≥mo domesticamos la explosi√≥n combinatoria de posibles estados y hacemos que la salida visual sea predecible? </blockquote><p>  Si bien la soluci√≥n correcta aqu√≠ son las m√°quinas de estado, el requisito b√°sico es poder elegir un solo √°tomo o mol√©cula y jugar con √©l. </p><br><h3 id="the-main-points-of-this-article">  Los puntos principales de este art√≠culo. </h3><br><ol><li>  Los componentes de presentaci√≥n solo deben contener otros componentes de presentaci√≥n. </li><li>  Los contenedores son el √°rbol.  Los componentes son hojas de √°rbol. </li><li>  No <em>siempre</em> tiene que contener contenedores dentro de los de presentaci√≥n, pero <em>no debe contenerlos</em> solo en las pruebas. </li></ol><br><blockquote>  Puede profundizar en el problema leyendo el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo medio</a> , pero aqu√≠ omita todo el az√∫car. </blockquote><p>  PD: Esta es una traducci√≥n del art√≠culo <em>ru-</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">habr versi√≥n habr</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es436692/">https://habr.com/ru/post/es436692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es436682/index.html">No cree su propio JL (DSL) para ampliar la funcionalidad de la aplicaci√≥n</a></li>
<li><a href="../es436684/index.html">Aniversario de Android 10 (Q). ¬øQu√© se sabe ahora?</a></li>
<li><a href="../es436686/index.html">JPEG del mundo 3D. ¬øQu√© es glTF?</a></li>
<li><a href="../es436688/index.html">El gigante de TI abandona el mercado de chips para centros de datos: cu√©ntenos qu√© significa para la industria</a></li>
<li><a href="../es436690/index.html">[Preguntar - responder] sobre propiedad intelectual y protecci√≥n de datos</a></li>
<li><a href="../es436694/index.html">Mi compilador Pascal y arte contempor√°neo polaco</a></li>
<li><a href="../es436696/index.html">C√≥mo generar sonido binaural en una pista de audio monocanal: el video ayudar√°</a></li>
<li><a href="../es436698/index.html">¬øDe cu√°ntas maneras puedo escribir factorial en Scheme?</a></li>
<li><a href="../es436700/index.html">Anti-spoofing: ¬øc√≥mo resisten los sistemas de reconocimiento facial a los estafadores?</a></li>
<li><a href="../es436704/index.html">La historia de c√≥mo elegimos escalas para la automatizaci√≥n de cajas registradoras</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>