<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÄ üî£ üñäÔ∏è Konvertierung von polygonalen Maschen in B-Rep-Volumenk√∂rper: Algorithmusdetails und C ++ - Codebeispiele üèá ‚èÆÔ∏è ü§±</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Grenzdarstellung (B-rep) ist die prim√§re Methode zur Darstellung modellierter Objekte in den meisten geometrischen Kerneln, einschlie√ülich unseres...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Konvertierung von polygonalen Maschen in B-Rep-Volumenk√∂rper: Algorithmusdetails und C ++ - Codebeispiele</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465237/"> Die Grenzdarstellung (B-rep) ist die prim√§re Methode zur Darstellung modellierter Objekte in den meisten geometrischen Kerneln, einschlie√ülich unseres C3D Modeler-Kernels.  Die Kernalgorithmen, mit denen Modelle bearbeitet werden, z. B. das Anwenden von Verrundungsoperationen, das Durchf√ºhren von Schneidoperationen und das Erhalten flacher Projektionen, erfordern die Pr√§zision von B-Rep-Darstellungen.  Die schnell wachsende Vielfalt von 3D-Daten in polygonalen Formaten macht die Aufgabe der Modelltransformation von Polygonen in Grenzdarstellung immer relevanter.  Aus diesem Grund haben wir ein neues SDK entwickelt, C3D B-Shaper, das Teil unseres C3D Toolkits ist. <br><br><img src="https://habrastorage.org/webt/jt/2y/jv/jt2yjvnxfahxck-a1poawxfx8vc.png" alt="Bild"><br><a name="habracut"></a><br>  Die Verwendung eines Triangulationsalgorithmus (bekannt als Tessellation) f√ºr die Grenzdarstellung eines Modells ist relativ einfach.  Das Erstellen polygonaler (tessellierter) Darstellungen ist n√ºtzlich f√ºr Visualisierungszwecke und f√ºr geometrische Berechnungen. <br><br>  Die umgekehrte Transformation - von der polygonalen Darstellung zu B-rep - ist jedoch mit einer Reihe von Problemen verbunden, die mit der Komplexit√§t beim Erkennen verschiedener Arten von Oberfl√§chen, einschlie√ülich Freiformtypen, zusammenh√§ngen.  Es gibt auch das Problem des Rauschens in polygonalen Modellen, die typischerweise als Ergebnis des 3D-Scannens auftreten. <br><br>  Der allgemeine Prozess, mit dem C3D B-Shaper Modelle von polygonalen in B-rep-Formate umwandelt, besteht aus drei Schritten: Segmentierung, Rekonstruktion von Oberfl√§chen und Konstruktion von b-rep-Modellen.  Der Transformationsprozess ist iterativ: Wenn Benutzer aus irgendeinem Grund mit den Ergebnissen unzufrieden sind, k√∂nnen Korrekturen w√§hrend der Segmentierungs- und Oberfl√§chenrekonstruktionsphase vorgenommen werden. <br><br><img src="https://habrastorage.org/webt/qx/wf/jp/qxwfjpqgfavnukkhjusspnjdzjg.png" alt="Bild"><br>  <i>Umwandlung einer polygonalen Darstellung in eine B-Wiederholung</i> <br><br>  Bevor wir jedoch mit dem Prozess der b-rep-Transformation beginnen, verbessern wir die Qualit√§t des polygonalen Quellnetzes, indem wir die folgenden Korrekturen anwenden: Koordinieren Sie die Richtungen der Normalen in benachbarten Polygonen;  L√∂cher beseitigen;  und ggf. Gl√§ttungsalgorithmen auf verrauschte Netzquellen anwenden. <br><br><h1>  <font color="#00B2FF">Segmentierung des polygonalen Modells</font> </h1><br>  Die erste Stufe der Transformation ist die Segmentierung des polygonalen Modells.  Wir klassifizieren das Netzpolygon in Teilmengen (Segmente).  Informationen √ºber die Normalen an jedem Netzscheitelpunkt erm√∂glichen es, eine Segmentierung erster Ordnung durchzuf√ºhren und dann die anf√§ngliche Netzaufteilung durchzuf√ºhren sowie Bereiche als flach oder stark gekr√ºmmt zu klassifizieren.  Die anf√§ngliche Netzaufteilung basiert auf der Definition "scharfer" Kanten.  Dies sind die Kanten zwischen zwei dreieckigen Polygonen, bei denen der Winkel zwischen ihren durchschnittlichen Normalen einen vordefinierten Wert √ºberschreitet. <br><br>  Eine Segmentierung zweiter Ordnung analysiert das Netz anhand seiner Hauptkr√ºmmung, die zur Klassifizierung elementarer Oberfl√§chen ausreicht.  Bei der Berechnung von Kr√ºmmungen an Netzscheitelpunkten verwenden wir die Ergebnisse von Meyers Arbeiten (Mark Meyer, Mathieu Desbrun, Peter Schroder und Alan H. Barr, "Diskrete Differentialgeometrieoperatoren f√ºr dreieckige 2-Mannigfaltigkeiten", Visualization and Mathematics III, 2003). Bei der Definition eines diskreten Differentialoperators f√ºr triangulierte Bereiche wird f√ºr jeden anf√§nglichen Netzscheitelpunkt ein Satz benachbarter Scheitelpunkte (bezogen auf einen bestimmten Scheitelpunkt √ºber eine Kante) ber√ºcksichtigt.  Als n√§chstes wird ein diskreter Operator <i>K</i> f√ºr den Scheitelpunkt berechnet.  Basierend auf dem Operator werden die durchschnittlichen normalen, mittleren <i><sub>KH-</sub></i> und Gau√üschen <i>KG-</i> Kr√ºmmungen am Netzscheitelpunkt definiert. <br><br><img src="https://habrastorage.org/webt/rz/ni/kf/rznikfmo-7jumijuvqo4pjgmurs.png" alt="Bild"><br>  <i>Definieren diskreter Differentialoperatoren f√ºr triangulierte Regionen</i> <br><br>  Auf diese Weise wird der Kr√ºmmungstensor f√ºr jeden Maschenscheitelpunkt berechnet, aus dem die Hauptkr√ºmmungswerte <i>K <sub>1</sub></i> und <i>K <sub>2</sub></i> und die Hauptkr√ºmmungsrichtungen extrahiert werden. <br><br>  Netzscheitelpunkte werden durch die Werte ihrer Hauptkr√ºmmungen <i>K <sub>1</sub></i> und <i>K <sub>2</sub></i> klassifiziert und dann f√ºr sie berechnet.  Der Scheitelpunktklassifizierungsalgorithmus basiert auf k-Mitteln, d. H. Minimieren der gesamten quadratischen Abweichung von Clusterpunkten von den Zentren der Cluster.  Die resultierende Ausgabe des Algorithmus enth√§lt einen Netzscheitelpunkt, der einem Cluster zugeordnet ist <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi><mi>i</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.569ex" height="2.057ex" viewBox="0 -780.1 1106 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/465237/&amp;usg=ALkJrhheJvLaKPwdVbyI2R9E97WbGKsUaA#MJMATHI-43" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/465237/&amp;usg=ALkJrhheJvLaKPwdVbyI2R9E97WbGKsUaA#MJMATHI-69" x="760" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi><mi>i</mi></math></span></span><script type="math/tex" id="MathJax-Element-1"> Ci </script>  und ein Paar Kr√ºmmungen (Cluster-Zentrum - L. Guillaume, "Curvature Tensor Based Triangle Mesh Segmentation with Boundary Rectification", Proceedings Computer Graphics International (CGI), 2004). <br><br><img src="https://habrastorage.org/webt/rr/sf/zg/rrsfzgnpnkdjbk6tkaj2huigmno.png" alt="Bild"><br>  <i>Klassifizieren von polygonalen Netzscheitelpunkten im Kr√ºmmungsraum</i> <br><br>  Sobald wir die Eckpunkte des Polygonnetzes klassifiziert haben, fahren wir mit der Klassifizierung der Polygone fort.  Um diesen Vorgang zu starten, w√§hlen wir ein dreieckiges Polygon, dessen Kr√ºmmung als vollst√§ndig definiert betrachtet werden kann.  Dies ist einer, dessen drei Eckpunkte innerhalb eines einzelnen Clusters liegen oder zwei Eckpunkte an einer scharfen Kante haben.  Das Polygon wird als neues Segment bezeichnet und wird zum Ausgangspunkt f√ºr eine rekursive Prozedur, die das Segment erweitert: F√ºr jedes dreieckige Polygon werden benachbarte Polygone ber√ºcksichtigt, solange die Kante zwischen ihnen nicht "scharf" ist.  Wenn sich ein benachbarter Polygonscheitelpunkt, der einer gemeinsamen Kante gegen√ºberliegt, auf einer scharfen Kante befindet oder zu demselben Cluster geh√∂rt, wird das Polygon dem Segment hinzugef√ºgt.  Der Vorgang wird wiederholt, bis alle Polygone, aus denen das Netz besteht, verschwunden sind. <br><br><img src="https://habrastorage.org/webt/dm/19/to/dm19tosiw5tu-_p97ufs380khyy.png" alt="Bild"><br>  <i>Polygonale Netzsegmentierung</i> <br><br>  Sobald der Segmenterstellungsvorgang abgeschlossen ist, setzt ein anderer Algorithmus benachbarte Segmente zusammen, um die √úber-Segmentierung des Netzes zu beseitigen. <br><br><h1>  <font color="#00B2FF">Oberfl√§chenerkennung</font> </h1><br>  Die zweite Stufe ist die Oberfl√§chenerkennung.  Jedes Segment muss durch eine Oberfl√§che mit einer vom System oder vom Benutzer festgelegten Genauigkeit angen√§hert werden. <br><br>  Zun√§chst wird anhand der Hauptkr√ºmmungswerte der Segmente bestimmt, ob es √ºberhaupt m√∂glich ist, die Form des Segments durch eine der folgenden Elementarfl√§chen zu beschreiben: <br><br><ul><li>  Ebene: <i>k <sub>1</sub></i> = <i>k <sub>2</sub></i> = 0 </li><li>  Kugel: <i>k <sub>1</sub></i> = <i>k <sub>2</sub></i> = <i>K</i> &gt; 0 </li><li>  Zylinder: <i>k <sub>1</sub></i> = <i>K</i> &gt; 0, <i>k <sub>2</sub></i> = 0 </li><li>  Kegel: <i>k <sub>1</sub></i> ‚àà [ <i>a</i> , <i>b</i> ], <i>k <sub>2</sub></i> = 0 </li><li>  Toroid: <i>k <sub>1</sub></i> = <i>K</i> , <i>k <sub>2</sub></i> ‚àà [ <i>a</i> , <i>b</i> ] </li></ul><br>  Um elementare Oberfl√§chen zu erstellen, passen wir einfache geometrische Objekte mit dem entsprechenden Algorithmus an Punktmengen an.  Um beispielsweise einen Kreis und eine Kugel an eine Reihe von Punkten anzupassen, wird die Methode der kleinsten Quadrate verwendet.  Um eine Ebene anzupassen, wird die Hauptkomponentenanalyse verwendet.  Das System stellt sicher, dass jede rekonstruierte Oberfl√§che innerhalb einer vordefinierten Erkennungsgenauigkeit mit einem Segment verkn√ºpft ist. <br><br>  Die folgende Abbildung zeigt erkannte Oberfl√§chen nach Farbe: Ebenen sind blau dargestellt, Zylinder rot, Kugeln gr√ºn, Zapfen gelb und Toroide violett. <br><br><img src="https://habrastorage.org/webt/az/z_/jh/azz_jhkz6xkn0ffe8z95dhrfzum.png" alt="Bild"><br>  <i>Quell-Polygonnetz (links) und segmentiertes Netz (rechts) mit erkannten Oberfl√§chensegmenten</i> <br><br>  Wenn keine Elementarfl√§che das Segment beschreiben kann, versucht das System, eine Extrusionsfl√§che oder eine Rotationsfl√§che zu erkennen. <br><br>  Wenn das System letztendlich keine analytische Oberfl√§che findet, anhand derer die Segmentform beschrieben werden kann, wird eine NURBS-Oberfl√§che daf√ºr erstellt. <br><br><h1>  <font color="#00B2FF">Erstellung von B-Rep-Modellen</font> </h1><br>  Die letzte Phase der Transformation besteht darin, das B-rep-Modell basierend auf der Segmentierung und den rekonstruierten Oberfl√§chendaten zu erstellen.  Aus den segmentierten Bereichen wird ein Adjazenzdiagramm erstellt, um die Topologie des Modells darzustellen. Es bildet die Grundlage f√ºr die Erstellung des resultierenden B-rep-Modells.  B-Rep-Modelle werden im Gegensatz zu den vorhergehenden Schritten in einem vollautomatischen Modus zusammengebaut: <br><br><ul><li>  B-Rep-Kanten werden aus Schnittkurven benachbarter rekonstruierter Fl√§chen erstellt </li><li>  B-Wiederholungsfl√§chen werden durch begrenzte erkannte Oberfl√§chen und B-Wiederholungskanten konstruiert </li></ul><br>  Es ist jedoch nicht immer m√∂glich, eine Shell mit der richtigen Topologie zu erstellen.  Nehmen Sie zum Beispiel zwei Oberfl√§chen wie einen Zylinder und eine Ebene, die im Raum nahezu tangential zueinander sind.  Aufgrund der f√ºr die rekonstruierten Oberfl√§chen angegebenen Toleranz schneiden sie sich m√∂glicherweise √ºberhaupt nicht.  Infolgedessen kann die erstellte Shell Fehler aufweisen.  Benutzer k√∂nnen Fehler beseitigen, indem sie die Oberfl√§chenparameter korrigieren. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/UPasZTasOps" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h1>  <font color="#00B2FF">Arten von polygonalen Modellen</font> </h1><br>  Es gibt zahlreiche Quellen f√ºr polygonale Modelle, die online verf√ºgbar sind: <br><br><ul><li>  Online-Kataloge und -Datenbanken bieten 3D-Modelle in polygonalen Formaten wie STL, VRML und OBJ von 3D Warehouse, Cults 3D usw. an </li><li>  Dateien, die beim 3D-Scannen entstehen </li><li>  Ausgabe der topologischen Optimierung von Modellen mithilfe von CAE-Algorithmen </li></ul><br>  Polygonale Modelle aus diesen Quellen k√∂nnen in zwei Gruppen unterteilt werden: Modelle, die aus B-rep-Objekten trianguliert (vermascht) wurden, und alle anderen Modelle.  Ein f√ºr die erste Gruppe spezifisches Merkmalspaar ist das Fehlen von polygonalem Netzrauschen und die Dominanz analytischer Oberfl√§chen.  Dies bedeutet, dass Modelle aus der ersten Gruppe im vollautomatischen Modus oder mit minimalem Benutzeraufwand problemlos in B-Wiederholungen umgewandelt werden k√∂nnen. <br><br>  Polygonale Netze von Modellen der zweiten Gruppe weisen Rauschen auf, enthalten organische Oberfl√§chen und erfordern daher eher die interaktive Teilnahme von Benutzern. <br><br>  Daher bieten wir zwei Modi f√ºr den Betrieb von C3D B-Shape, vollautomatisch und interaktiv.  Benutzer k√∂nnen w√§hrend des Rekonstruktionsprozesses zwischen Erkennungsmodi wechseln und Oberfl√§chentypen verwalten.  Die Auswahl eines Modus kann vom Zweck der Durchf√ºhrung der Transformation abh√§ngen: Benutzer m√∂chten manchmal die topologische Konnektivit√§t der resultierenden Shell oder ihre allgemeine Korrektheit au√üer Acht lassen.  Dies ist h√§ufig der Fall, wenn die Anzeige in BIM-Anwendungen optimiert wird, in denen Benutzer dem Architekturmodell benutzerdefinierte Innenelemente hinzuf√ºgen. <br><br>  Andererseits erfordern Reverse Engineering-Aufgaben eine m√∂glichst genaue Kopie der Quellmodelle, damit das resultierende Modell eine korrekte Topologie aufweist.  Daher ist es notwendig, die Genauigkeit der Koaxialit√§t von Zylindern oder die Tangentialit√§t zweier Oberfl√§chen vorab zu definieren.  In solchen F√§llen ist die Beteiligung der Benutzer am Transformationsprozess von entscheidender Bedeutung. <br><br>  Die automatische Transformation von C3D B-Shaper verwendet die folgenden Funktionen, die als Eingabedaten das Quellnetz und die Transformationseinstellungen verwenden: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">MbResultType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertMeshToShell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( MbMesh &amp; mesh, MbFaceShell *&amp; shell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MbMeshProcessorValues &amp; params )</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">MbResultType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertCollectionToShell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( MbCollection &amp; collection, MbFaceShell *&amp; shell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MbMeshProcessorValues &amp; params )</span></span></span></span>;</code> </pre> <br>  Eine der Transformationseinstellungen ist ein Erkennungsgenauigkeitswert, der die maximale Toleranz f√ºr Abst√§nde zwischen Segmentscheitelpunkten und erkannten Fl√§chen festlegt.  Die Genauigkeit kann absolut oder relativ sein.  Bei Verwendung der relativen Genauigkeit werden die Abweichungen der Fl√§chen von den Netzk√∂rpern relativ zur Modellgr√∂√üe gemessen. <br><br>  Die MbMesh Processor-Schnittstellenklasse bietet erweiterte Optionen zum Verwalten der Segmentierung und Erkennung von Oberfl√§chen: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MbMeshProcessor</span></span></span><span class="hljs-class"> {</span></span> .. <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// Mesh rectification. void SetUseMeshSmoothing( bool useSmoothing ); // Mesh segmentation management. const MbCollection &amp; GetSegmentedMesh(); MbResultType SegmentMesh( bool createSurfaces = true ); void ResetSegmentation(); void UniteSegments( size_t firstSegmentIdx, size_t secondSegmentIdx ); MbResultType SegmentMeshBySeparators( const std::vector&lt;std::vector&lt;uint&gt;&gt; &amp; sep ); // Surface recognition management. void FitSurfaceToSegment( size_t idxSegment ); void FitSurfaceToSegment( size_t idxSegment, MbeSpaceType surfaceType ); const MbSurface * GetSegmentSurface( size_t idxSegment ) const; // B-rep shell construction. MbResultType CreateBRepShell( MbFaceShell *&amp; pShell ); .. }</span></span></code> </pre> <br>  Um beispielsweise die Ergebnisse der automatischen Segmentierung zu korrigieren, bietet C3D B-Shaper Tools zum Zusammenf√ºhren und Teilen von Segmenten usw.  Benutzer k√∂nnen Oberfl√§chen bestimmter Typen an das ausgew√§hlte Segment anpassen und die Parameter erkannter Oberfl√§chen √§ndern. <br><br><h1>  <font color="#00B2FF">Zusammenfassung</font> </h1><br>  Das Ergebnis der Transformationsalgorithmen von C3D B-Shaper wird in den folgenden Abbildungen veranschaulicht, in denen ein komplexes 3D-Modell erfolgreich von seiner polygonalen Netzdarstellung in einen Festk√∂rper mit Grenzdarstellung transformiert wird. <br><br><img src="https://habrastorage.org/webt/om/i7/zw/omi7zwcrrc3qzdvyfkvzphvsyra.png" alt="Bild"><br><br><img src="https://habrastorage.org/webt/is/zt/nw/isztnwvohh4t9nzgj4pusg9awek.png" alt="Bild"><br>  <i>Polygonales Netz (links) und B-Rep-Modell (rechts), konvertiert mit C3D B-Shaper</i> <br><br>  Unser Ziel ist es, ein leistungsstarkes SDK f√ºr die Transformation von Modellen von polygonal zu B-rep zu erstellen. Daher wird die Entwicklung von C3D B-Shaper fortgesetzt.  Wir arbeiten unter anderem daran, die automatischen Segmentierungsalgorithmen weiterzuentwickeln, Werkzeuge f√ºr die Segmentierungsbearbeitung zu entwickeln, die Konstruktion von Freiform-NURBS-Oberfl√§chen zu verbessern und die Qualit√§t von B-rep-Shell-Baugruppen zu verbessern. <br><br>  Kunden, die den geometrischen C3D-Kernel verwenden, sind auch ein Faktor f√ºr die Entwicklung von C3D B-Shaper. <br><br>  Entwickler k√∂nnen C3D B-Shaper gerne als Teil des C3D Toolkit oder als eigenst√§ndige Komponente testen. <br><br> <a href="" rel="nofollow"><img src="https://habrastorage.org/webt/k8/za/vg/k8zavgo-xihodwssql3y-aqlmam.jpeg"></a>  Von Andrey Tumanin, Leiter der Softwareentwicklung bei C3D Labs </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de465237/">https://habr.com/ru/post/de465237/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de465217/index.html">Acronis True Image 2020: Neue Replikationsschemata und verbesserter Schutz</a></li>
<li><a href="../de465221/index.html">Wie Register in 1C in Gegenwart von OOP aussehen k√∂nnten</a></li>
<li><a href="../de465223/index.html">Wie Sie die Papiersicherheit in der Praxis nutzen k√∂nnen oder warum 152-–§–ó- und PCI-DSS in einer Cloud eingehalten werden m√ºssen</a></li>
<li><a href="../de465227/index.html">Augmented Reality im Online-Handel</a></li>
<li><a href="../de465229/index.html">‚ÄûBerater +‚Äú: √Ñnderung des Materialflusses. Schriftarten, Stile, Textausrichtung mit Python</a></li>
<li><a href="../de465239/index.html">Komm und hol B√ºcher auf Englisch</a></li>
<li><a href="../de465241/index.html">Mein siebter Tag mit Haiku: Auflisten, Scannen, Netzwerk</a></li>
<li><a href="../de465245/index.html">Sehen Sie die Benutzeroberfl√§che ‚Äûmit den Augen des Designers‚Äú: √ºber die Interaktion des Frontends mit dem Designer</a></li>
<li><a href="../de465247/index.html">Winkelig Grundlegendes zu @Input, @Output und EventEmitter</a></li>
<li><a href="../de465249/index.html">Vortrag von Richard Stallman am Moskauer Polytechnikum. August 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>