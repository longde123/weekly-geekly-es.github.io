<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😖 🚹 🎡 JavaScript funcional: ¿qué son las funciones de orden superior y por qué son necesarias? 🤚🏻 💇🏽 📦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Funciones de un orden superior" es una de esas frases que a menudo se encuentran dispersas. Pero rara vez alguien puede detenerse y explicar de qué s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript funcional: ¿qué son las funciones de orden superior y por qué son necesarias?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/458896/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/st/le/mw/stlemwjifksb6iqurxqvutclf9s.jpeg"></div><br>  "Funciones de un orden superior" es una de esas frases que a menudo se encuentran dispersas.  Pero rara vez alguien puede detenerse y explicar de qué se trata.  Es posible que ya sepa lo que se llaman funciones de orden superior.  Pero, ¿cómo los usamos en proyectos reales?  ¿Cuándo y por qué son útiles?  ¿Podemos manipular el DOM con su ayuda?  ¿O las personas que usan estas funciones simplemente se muestran?  ¿Quizás sin sentido complican el código? <br><br>  Solía ​​pensar que las funciones de orden superior son útiles.  Ahora considero que son la propiedad más importante de JavaScript como lenguaje.  Pero antes de discutir esto, primero descubramos qué son exactamente las funciones de orden superior.  Y comenzaremos con funciones como variables. <br><a name="habracut"></a><br><h2>  Funciones como objetos de primera clase </h2><br>  En JavaScript, hay al menos tres formas (hay más en total) para escribir una nueva función.  Primero, puede escribir <i>una declaración de función</i> : <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Take a DOM element and wrap it in a list item element. function itemise(el) { const li = document.createElement('li'); li.appendChild(el); return li; }</span></span></code> </pre> <br>  Espero que lo entiendas todo.  Además, probablemente sepa que puede escribir una <i>expresión de función</i> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> itemise = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> li = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'li'</span></span>); li.appendChild(el); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> li; }</code> </pre> <br>  Y finalmente, hay otra forma de escribir la misma función, como una <i>función de flecha</i> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> itemise = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> li = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'li'</span></span>); li.appendChild(el); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> li; }</code> </pre> <br>  En este caso, los tres métodos son equivalentes.  Aunque esto no siempre sucede, en la práctica, cada método tiene pequeñas diferencias asociadas con lo que sucede con la magia de una palabra clave y etiquetas en particular en los seguimientos de pila. <br><br>  Pero tenga en cuenta que los dos últimos ejemplos asignan la función a una variable.  Parece una bagatela.  ¿Por qué no asignar una función a una variable?  Pero es muy importante.  Las funciones en JavaScript pertenecen a la " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primera clase</a> ".  Por lo tanto, podemos: <br><br><ul><li>  Asignar funciones a variables. <br></li><li>  Pase funciones como argumentos a otras funciones. <br></li><li>  Funciones de retorno de otras funciones. <br></li></ul><br>  Esto es maravilloso, pero ¿qué tiene que ver todo esto con las funciones de orden superior?  Presta atención a los últimos dos puntos.  Pronto volveremos a ellos, pero por ahora veamos algunos ejemplos. <br><br>  Vimos la asignación de funciones a variables.  ¿Qué hay de pasarlos como parámetros?  Escribamos una función que se pueda usar con elementos DOM.  Si ejecutamos <code>document.querySelectorAll()</code> , a cambio no obtenemos una matriz, sino una <code>NodeList</code> .  <code>NodeList</code> no tiene un método <code>.map()</code> , como las matrices, por lo que escribimos esto: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Apply a given function to every item in a NodeList and return an array. function elListMap(transform, list) { // list might be a NodeList, which doesn't have .map(), so we convert // it to an array. return [...list].map(transform); } // Grab all the spans on the page with the class 'for-listing'. const mySpans = document.querySelectorAll('span.for-listing'); // Wrap each one inside an &lt;li&gt; element. We re-use the // itemise() function from earlier. const wrappedList = elListMap(itemise, mySpans);</span></span></code> </pre> <br>  Aquí pasamos la función itemise como argumento a la función <code>elListMap</code> .  Pero podemos usar <code>elListMap</code> no solo para crear listas.  Por ejemplo, con su ayuda, puede agregar una clase a un conjunto de elementos: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addSpinnerClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function">) </span></span>{ el.classList.add(<span class="hljs-string"><span class="hljs-string">'spinner'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> el; } <span class="hljs-comment"><span class="hljs-comment">// Find all the buttons with class 'loader' const loadButtons = document.querySelectorAll('button.loader'); // Add the spinner class to all the buttons we found. elListMap(addSpinnerClass, loadButtons);</span></span></code> </pre><br>  <code>elLlistMap</code> toma otra función como parámetro y convierte.  Es decir, podemos usar <code>elListMap</code> para resolver diferentes problemas. <br><br>  Observamos un ejemplo de pasar funciones como parámetros.  Ahora hablemos de devolver una función de una función.  ¿Cómo se ve? <br><br>  Primero, escribimos la función antigua habitual.  Necesitamos tomar una lista de elementos <code>li</code> y envolverlos en <code>ul</code> .  Fácil: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrapWithUl</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">children</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ul = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'ul'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [...children].reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">listEl, child</span></span></span><span class="hljs-function">) =&gt;</span></span> { listEl.appendChild(child); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> listEl; }, ul); }</code> </pre> <br>  ¿Y si entonces tenemos un montón de elementos de párrafo que queremos envolver en un <code>div</code> ?  No hay problema, escribiremos una función más para esto: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrapWithDiv</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">children</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> div = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'div'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [...children].reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">divEl, child</span></span></span><span class="hljs-function">) =&gt;</span></span> { divEl.appendChild(child); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> divEl; }, div); }</code> </pre> <br>  Funciona muy bien  Sin embargo, estas dos funciones son muy similares, la única diferencia está en el elemento padre que creamos. <br><br>  Ahora <i>podríamos</i> escribir una función que tome dos parámetros: el tipo del elemento primario y la lista de elementos secundarios.  Pero hay otra opción.  Podemos crear una función que devuelve una función.  Por ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createListWrapperFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">elementType</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Straight away, we return a function. return function wrap(children) { // Inside our wrap function, we can 'see' the elementType parameter. const parent = document.createElement(elementType); return [...children].reduce((parentEl, child) =&gt; { parentEl.appendChild(child); return parentEl; }, parent); } }</span></span></code> </pre> <br>  Puede parecer un poco complicado al principio, así que dividamos el código.  Creamos una función que simplemente devuelve otra función.  Pero esta función de retorno <i>recuerda</i> el parámetro <code>elementType</code> .  Y luego, cuando llamamos a la función devuelta, ya sabe qué elemento crear.  Por lo tanto, puede crear <code>wrapWithUl</code> y <code>wrapWithDiv</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wrapWithUl = createListWrapperFunction(<span class="hljs-string"><span class="hljs-string">'ul'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Our wrapWithUl() function now 'remembers' that it creates a ul element. const wrapWithDiv = createListWreapperFunction('div'); // Our wrapWithDiv() function now 'remembers' that it creates a div element.</span></span></code> </pre> <br>  Este truco, cuando la función devuelta "recuerda" algo, se llama <i>cierre</i> .  Puedes leer más sobre ellos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> .  Los cierres son increíblemente convenientes, pero por ahora, no pensaremos en ellos. <br><br>  Entonces, resolvimos: <br><br><ul><li>  Asignación de una función a una variable. <br></li><li>  Pasando una función como parámetro. <br></li><li>  Devolver una función de otra función ... <br></li></ul><br>  En general, las funciones de la primera clase son algo agradable.  Pero, ¿qué tiene que ver <i>la función de orden superior</i> con ella?  Veamos la definición. <br><br><h2>  ¿Qué es una función de orden superior? </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Definición</a> : <i>esta es una función que toma una función como argumento o devuelve una función como resultado.</i> <br><br>  ¿Eso es familiar?  En JavaScript, estas son funciones de primera clase.  Es decir, las "funciones de orden superior" tienen exactamente las mismas ventajas.  En otras palabras, es solo un nombre fantasioso para una idea simple. <br><br><h2>  Ejemplos de funciones de orden superior </h2><br>  Si comienzas a buscar, entonces comienzas a notar funciones de orden superior en todas partes.  Las más comunes son las funciones que toman otras funciones como parámetros. <br><br><h3>  Funciones que toman otras funciones como parámetros. </h3><br>  Cuando pasa una devolución de llamada, utiliza una función de orden superior.  En el desarrollo front-end, se encuentran en todas partes.  Uno de los más comunes es el método <code>.addEventListener()</code> .  Lo usamos cuando queremos realizar acciones en respuesta a algunos eventos.  Por ejemplo, quiero hacer un botón que muestre una advertencia: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showAlert</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">'Fallacies do not cease to be fallacies because they become fashions'</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.innerHTML += <span class="hljs-string"><span class="hljs-string">`&lt;button type="button" class="js-alertbtn"&gt; Show alert &lt;/button&gt;`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> btn = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'.js-alertbtn'</span></span>); btn.addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, showAlert);</code> </pre> <br>  Aquí creamos una función que muestra una advertencia, agregamos un botón a la página y pasamos la función <code>showAlert()</code> como argumento a <code>btn.addEventListener()</code> . <br><br>  También encontramos funciones de orden superior cuando usamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">métodos de iteración de matriz</a> : por ejemplo, <code>.map()</code> , <code>.filter()</code> y <code>.reduce()</code> .  Como en la función <code>elListMap()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">elListMap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">transform, list</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [...list].map(transform); }</code> </pre> <br>  Las funciones de orden superior también ayudan a trabajar con retrasos y tiempos.  Las <code>setTimeout()</code> y <code>setInterval()</code> ayudan a controlar <i>cuándo</i> se ejecutan las funciones.  Por ejemplo, si necesita eliminar la clase de <code>highlight</code> después de 30 segundos, puede hacer esto de la siguiente manera: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeHighlights</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> highlightedElements = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'.highlighted'</span></span>); elListMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> el.classList.remove(<span class="hljs-string"><span class="hljs-string">'highlighted'</span></span>), highlightedElements); } setTimeout(removeHighlights, <span class="hljs-number"><span class="hljs-number">30000</span></span>);</code> </pre> <br>  Nuevamente, creamos una función y la pasamos a otra función como argumento. <br><br>  Como puede ver, JavaScript a menudo tiene funciones que aceptan otras funciones.  Y probablemente ya los uses. <br><br><h3>  Funciones Funciones de retorno </h3><br>  Las funciones de este tipo no se encuentran con tanta frecuencia como las anteriores.  Pero también son útiles.  Uno de los mejores ejemplos es la función <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">maybe ()</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Adapte</a> una variante del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">libro Allongé JavaScript</a> : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">maybe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_maybe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Note that the == is deliberate. if ((args.length === 0) || args.some(a =&gt; (a == null)) { return undefined; } return fn.apply(this, args); } }</span></span></code> </pre> <br>  En lugar de comprender el código, primero veamos cómo se puede aplicar.  Veamos <code>elListMap()</code> función <code>elListMap()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Apply a given function to every item in a NodeList and return an array. function elListMap(transform, list) { // list might be a NodeList, which doesn't have .map(), so we convert // it to an array. return [...list].map(transform); }</span></span></code> </pre> <br>  ¿Qué sucede si accidentalmente paso un valor nulo o indefinido a <code>elListMap()</code> ?  Obtendremos un TypeError y una caída de la operación actual, sea lo que sea.  Esto se puede evitar con la función <code>maybe()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> safeElListMap = maybe(elListMap); safeElListMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ￩ undefined</span></span></code> </pre> <br>  En lugar de caer, la función volverá <code>undefined</code> .  Y si pasáramos esto a otra función protegida por <code>maybe()</code> , volveríamos a estar <code>undefined</code> .  <code>maybe()</code> pueda proteger cualquier número de funciones, es mucho más fácil escribir mil millones de <code>if</code> . <br><br>  Las funciones que devuelven funciones también son comunes en el mundo React.  Por ejemplo, <code>connect()</code> . <br><br><h2>  Entonces, ¿qué sigue? </h2><br>  Vimos varios ejemplos de uso de funciones de orden superior.  Entonces, ¿qué sigue?  ¿Qué nos pueden dar lo que no podemos obtener sin ellos? <br><br>  Para responder a esta pregunta, veamos otro ejemplo: el método de matriz <code>.sort()</code> .  Sí, tiene fallas.  Cambia la matriz en lugar de devolver una nueva.  Pero olvidémoslo por ahora.  El método <code>.sort()</code> es una función de orden superior; toma otra función como uno de los parámetros. <br><br>  Como funciona  Si queremos ordenar una matriz de números, primero debemos crear una función de comparación: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compareNumbers</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a === b) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt; b) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* else */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre> <br>  Ahora ordena la matriz: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> nums = [<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]; nums.sort(compareNumbers); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(nums); <span class="hljs-comment"><span class="hljs-comment">// 〕[1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span></code> </pre> <br>  Puedes ordenar listas de números.  ¿Pero de qué sirve?  ¿Con qué frecuencia tenemos una lista de números para ordenar?  No a menudo  Por lo general, necesito ordenar una variedad de objetos: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> typeaheadMatches = [ { <span class="hljs-attr"><span class="hljs-attr">keyword</span></span>: <span class="hljs-string"><span class="hljs-string">'bogey'</span></span>, <span class="hljs-attr"><span class="hljs-attr">weight</span></span>: <span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-attr"><span class="hljs-attr">matchedChars</span></span>: [<span class="hljs-string"><span class="hljs-string">'bog'</span></span>], }, { <span class="hljs-attr"><span class="hljs-attr">keyword</span></span>: <span class="hljs-string"><span class="hljs-string">'bog'</span></span>, <span class="hljs-attr"><span class="hljs-attr">weight</span></span>: <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-attr"><span class="hljs-attr">matchedChars</span></span>: [<span class="hljs-string"><span class="hljs-string">'bog'</span></span>], }, { <span class="hljs-attr"><span class="hljs-attr">keyword</span></span>: <span class="hljs-string"><span class="hljs-string">'boggle'</span></span>, <span class="hljs-attr"><span class="hljs-attr">weight</span></span>: <span class="hljs-number"><span class="hljs-number">0.3</span></span>, <span class="hljs-attr"><span class="hljs-attr">matchedChars</span></span>: [<span class="hljs-string"><span class="hljs-string">'bog'</span></span>], }, { <span class="hljs-attr"><span class="hljs-attr">keyword</span></span>: <span class="hljs-string"><span class="hljs-string">'bogey'</span></span>, <span class="hljs-attr"><span class="hljs-attr">weight</span></span>: <span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-attr"><span class="hljs-attr">matchedChars</span></span>: [<span class="hljs-string"><span class="hljs-string">'bog'</span></span>], }, { <span class="hljs-attr"><span class="hljs-attr">keyword</span></span>: <span class="hljs-string"><span class="hljs-string">'toboggan'</span></span>, <span class="hljs-attr"><span class="hljs-attr">weight</span></span>: <span class="hljs-number"><span class="hljs-number">0.15</span></span>, <span class="hljs-attr"><span class="hljs-attr">matchedChars</span></span>: [<span class="hljs-string"><span class="hljs-string">'bog'</span></span>], }, { <span class="hljs-attr"><span class="hljs-attr">keyword</span></span>: <span class="hljs-string"><span class="hljs-string">'bag'</span></span>, <span class="hljs-attr"><span class="hljs-attr">weight</span></span>: <span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-attr"><span class="hljs-attr">matchedChars</span></span>: [<span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-string"><span class="hljs-string">'g'</span></span>], } ];</code> </pre> <br>  Supongamos que quiero ordenar esta matriz por el peso de cada registro.  <i>Podría</i> escribir una nueva función de clasificación desde cero.  Pero por qué, si puedes crear una nueva función de comparación: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compareTypeaheadResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">word1, word2</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> * compareNumbers(word1.weight, word2.weight); } typeaheadMatches.sort(compareTypeaheadResult); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(typeaheadMatches); <span class="hljs-comment"><span class="hljs-comment">// 〕[{keyword: "bog", weight: 0.5, matchedChars: ["bog"]}, … ]</span></span></code> </pre> <br>  Puede escribir una función de comparación para cualquier tipo de matriz.  El método <code>.sort()</code> nos ayuda: “Si me das una función de comparación, <code>.sort()</code> cualquier matriz.  No te preocupes por su contenido.  Si le das una función de clasificación, la ordenaré ”.  Por lo tanto, no necesitamos escribir un algoritmo de clasificación por nuestra cuenta, nos centraremos en la tarea mucho más simple de comparar dos elementos. <br><br>  Ahora imagine que no estamos utilizando funciones de orden superior.  No podemos pasar una función al método <code>.sort()</code> .  Tendremos que escribir una nueva función de clasificación cada vez que necesitemos ordenar una matriz de un tipo diferente.  O tiene que reinventar lo mismo con punteros de función u objetos.  En cualquier caso, resultará muy incómodo. <br><br>  Sin embargo, tenemos funciones de orden superior que nos permiten separar la función de clasificación de la función de comparación.  Digamos que un desarrollador de navegador inteligente ha actualizado <code>.sort()</code> para usar un algoritmo más rápido.  Entonces su código solo ganará, independientemente de lo que esté dentro de las matrices ordenables.  Y este esquema es cierto para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un conjunto completo de funciones de matrices de orden superior</a> . <br><br>  Esto nos lleva a tal idea.  El método <code>.sort()</code> <i>abstrae</i> la tarea de <i>clasificación</i> del <i>contenido de la</i> matriz.  Esto se llama separación de preocupaciones.  Las funciones de orden superior le permiten crear abstracciones que sin ellas serían muy engorrosas o incluso imposibles.  Y la creación de abstracciones representa el 80% del trabajo de los ingenieros de software. <br><br>  Cuando refactorizamos el código para eliminar repeticiones, creamos abstracciones.  Vemos el patrón y lo reemplazamos con una representación abstracta.  Como resultado, el código se vuelve más significativo y más fácil de entender.  Al menos ese es el objetivo. <br><br>  Las funciones de orden superior son una herramienta poderosa para crear abstracciones.  Y con las abstracciones, se asocia toda una rama de las matemáticas, la teoría de categorías.  Más precisamente, la teoría de categorías se dedica a la búsqueda de abstracciones de abstracciones.  En otras palabras, estamos hablando de encontrar patrones de patrones.  Y en los últimos 70 años, los programadores inteligentes tomaron prestadas muchas ideas de allí, que se convirtieron en propiedades de idiomas y bibliotecas.  Si aprendemos estos patrones, a veces podemos reemplazar grandes piezas de código.  O simplifique problemas complejos a combinaciones elegantes de bloques de construcción simples.  Estos bloques son funciones de orden superior.  Por lo tanto, son tan importantes que nos brindan una herramienta poderosa para combatir la complejidad de nuestro código. <br><br>  Materiales adicionales sobre funciones de orden superior: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Funciones de orden superior</a> : el quinto capítulo de <i>JavaScript elocuente</i> . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Funciones de orden superior</a> : parte de la serie de artículos <i>Composing Sofware</i> . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Funciones de orden superior en JavaScript</a> . <br></li></ul><br>  Probablemente ya esté utilizando funciones de orden superior.  Esto es tan fácil en JavaScript que ni siquiera pensamos en ello.  Pero es mejor saber de qué están hablando las personas cuando dicen esta frase.  Esto no es dificil.  Pero detrás de una idea simple hay mucho poder. <br><br>  Si tiene experiencia en programación funcional, puede notar que no utilicé funciones puras y algunos ... nombres detallados de funciones.  Esto no se debe a que no haya escuchado sobre las funciones inmundas o los principios generales de la programación funcional.  Y no escribo ese código en producción.  Traté de recoger ejemplos prácticos que serían claros para los principiantes.  A veces tenía que comprometerme.  Si está interesado, ya escribí sobre la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">limpieza funcional</a> y los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">principios generales de la programación funcional</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/458896/">https://habr.com/ru/post/458896/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458886/index.html">Los documentos más útiles de Mail.ru Design Conf × Dribbble Meetup 2019 de True Engineering</a></li>
<li><a href="../458888/index.html">Meetup de Summer Droid</a></li>
<li><a href="../458890/index.html">Muestreo y precisión de cálculo</a></li>
<li><a href="../458892/index.html">Sugerencias para vulnerabilidades y protección de modelos de aprendizaje automático</a></li>
<li><a href="../458894/index.html">Las personas típicas y las redes en las que viven.</a></li>
<li><a href="../458900/index.html">Cartuchos de consola como módems</a></li>
<li><a href="../458902/index.html">5 errores comunes de Python para principiantes</a></li>
<li><a href="../458904/index.html">Visualización del número de victorias para los equipos de la NBA utilizando gráficos de barras animados en R</a></li>
<li><a href="../458906/index.html">[Ekaterimburgo, anuncio] Flutteron - un taller sobre desarrollo en Flutter</a></li>
<li><a href="../458908/index.html">Escaneo de documentos a través de la red</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>