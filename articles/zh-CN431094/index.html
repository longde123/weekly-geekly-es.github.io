<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🤝‍👩🏼 👱🏿 👩🏿‍🎓 纸牌排序 🎙️ 👰 ⏮️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在前几篇文章的评论中，有时会有一些指责-如果世界上已经有最快的快速排序，为什么还要研究其他任何排序。 他们说，所有这些奇特的异国情调都没有用，也没有人需要。 


 珀西·迪亚科尼斯 （ Percy Diaconis ）一直研究纸牌排序，认为这是手动排列一副纸牌的最快方法。 

 因此，如果没有一位...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>纸牌排序</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/431094/"><div style="text-align:center;"><img width="700" height="420" src="https://habrastorage.org/webt/mz/at/0f/mzat0flvov5qixshl-awj9xffne.jpeg"></div><br><a name="habracut"></a><br> 在前几篇文章的评论中，有时会有一些指责-如果世界上已经有最快的快速排序，为什么还要研究其他任何排序。 他们说，所有这些奇特的异国情调都没有用，也没有人需要。 <br><br><img width="330" height="185" align="right" src="https://habrastorage.org/webt/ep/x5/pz/epx5pzwetbrzejtl0oukkvduozm.jpeg"><br clear="left">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">珀西·迪亚科尼斯</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Percy Diaconis</a> ）一直研究纸牌排序，认为这是手动排列一副纸牌的最快方法。 <br><br> 因此，如果没有一位受人尊敬的数学家（和一位经验丰富的纸牌魔术师）说谎，那么根据该算法的实际价值，一切都会井井有条。 <br><br> 现在注意你的手。 <br><br><h1> 阶段1.叠放 </h1><br><br> 因此，从甲板上取走蠕虫。 它们将代表13个随机元素的数组。 <br><br><img src="https://habrastorage.org/webt/j_/ik/zg/j_ikzgnokw8bkhj9_frik-mai_e.png"><br><br> 我们需要将卡片分解成几堆，以使卡片在每个堆中都是有序的序列。 <br><br> 换句话说，我们现阶段的任务是从现有的未排序数组中快速创建几个有序子数组。 同时，非常希望这些子阵列的数量更少，这意味着您需要努力确保这些子阵列更真实。 这样做如下。 <br><br> 第一张牌是第一堆的开始。 <br><br><img src="https://habrastorage.org/webt/d9/sp/bn/d9spbncxz30rhzxqrzfvywhhm6k.png"><br><br> 我们依次将卡片转移到该堆叠中，直到下一张转移的卡片小于堆叠中最上面的卡片为止。 <br><br> 而且，每个堆栈都是一个堆栈-我们不使用整个堆栈，而只能使用放在最后的最上面的卡。 <br><br><img src="https://habrastorage.org/webt/gf/gd/q-/gfgdq-oqzknwkou2dbcncafersa.png"><br><br> 如果当前卡大于堆栈中的最小卡，则必须创建一个新的卡堆，当前卡会打开一个新的堆栈。 <br><br><img src="https://habrastorage.org/webt/ab/97/z3/ab97z3z2dfaobk9tqveawpybhis.png"><br><br> 堆栈的顺序很重要！ 如果他们的数量已经超过一个，则我们将下一张牌不是放在最后一堆中，而是放在最左边的一堆中，我们可以将它放在其中。 <br><br> 现在，那位女士之后，我需要在某个地方附加一个9。 从机械上讲，我想将卡片放在第二堆中，但是在第一堆中，最上面的卡片是九个以上。 因此，我们可以继续第一个堆栈而不会违反其顺序。 顺便说一句，接下来的三个，紧跟着九个，进入第一堆。 <br><br><img src="https://habrastorage.org/webt/-4/ww/it/-4wwit3yrqc3gjywezucwhyh9lo.png"><br><br> 不能将七个和六个添加到第一堆中（它们大于其中的顶部卡片），但是它们在第二个堆中仍具有位置。 <br><br><img src="https://habrastorage.org/webt/zp/su/yc/zpsuycgew4jezzv44p3axcytg_i.png"><br><br> 王牌开始了新的一堆。 剩余的琐事将落入不同的托盘中，具体取决于可将其插入的堆栈向左多远。 <br><br><img src="https://habrastorage.org/webt/uw/qw/r6/uwqwr6gzjdpdyogbzcts-whxoae.png"><br><br> 结果，卡片被分成几堆。 在每堆中，纸牌是降序排列，顶部是最小的纸牌。 桩是堆。 <br><br> 因为我们首先尝试填充左侧的堆栈，所以我们形成了最小的数量。 如果我们只是在数组中四处走动并从中提取出递减的子数组，那么堆自然会变得更大。 <br><br><img src="https://habrastorage.org/webt/yb/wi/op/ybwiopvdmkgw_xhzswumhhpsy-c.png"><br><br><h1> 第二阶段。最底行 </h1><br><br> 向下移动可用的顶部卡，使它们排成一排。 如果堆栈是堆栈，那么我们将像队列一样处理最下面一行。 <br><br><img src="https://habrastorage.org/webt/-p/wo/sl/-pwosl95hk_iiqivtdkoypbk0oc.png"><br><br> 重要的是，堆中可用的顶牌也是有序的。 最下面一行已按升序排序。 这并不奇怪-形成纸牌叠时，较小的纸牌被发送到左侧。 <br><br> 将来，直到分类结束，我们对桌上摆放的所有卡牌都不感兴趣。 只需要这些： <br><br><ul><li> 队列最底端的最左边的卡片（我们称之为当前卡片）。 </li><li> 在堆栈堆栈中，我们仅与可用的顶级卡一起使用。 在这种情况下，仅需要直接位于当前地图上和左侧的那些桩。 此时不需要右边的桩。 </li></ul><br><br> 在底行中，我们从卡片的左到右对卡片进行排序。 最左边是当前的最小值，我们将其返回到原始的第一行。 同时，每次我们将另一张卡返还给基地时，有必要将另一张卡放回原处。 从哪里得到的？ 在当前地图上方和左侧（在可用卡中）的堆中，选择一个最小值，该最小值将移动到底部行中当前左侧卡的空位置，然后从此处移至主阵列。 <br><br> 数组中的两个立即返回。 空出的位置由三元组占据（我们将其从第一堆移至最下面的行），并且从最下面的行开始，该三元组作为当前的最小值到达主数组。 在前两堆中，再次搜索最小值（这是四堆），这也会返回。 五成为当前的最小值，依此类推。 <br><br><img src="https://habrastorage.org/webt/gi/ej/3x/giej3x5chmm4aggloxtewxvutem.png"><br><br> 很快地将工作与队列的升序和堆栈的降序结合起来，我们得到了从最小到最大的所有元素。 总的来说就是这样。 <br><br> 此过程的动画。 <br><br><img src="https://habrastorage.org/webt/gh/ks/gj/ghksgjmfx72fmeugocim2gnvmsm.gif"><br><br> 如果将以上所有内容翻译成Python，则会得到以下结果： <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> functools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> total_ordering <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bisect <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> bisect_left <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> heapq <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> merge @total_ordering <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pile</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(list)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__lt__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, other)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self[<span class="hljs-number"><span class="hljs-number">-1</span></span>] &lt; other[<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__eq__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, other)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self[<span class="hljs-number"><span class="hljs-number">-1</span></span>] == other[<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">patience_sort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span> piles = [] <span class="hljs-comment"><span class="hljs-comment"># sort into piles for x in n: new_pile = Pile([x]) i = bisect_left(piles, new_pile) if i != len(piles): piles[i].append(x) else: piles.append(new_pile) # use a heap-based merge to merge piles efficiently n[:] = merge(*[reversed(pile) for pile in piles])</span></span></code> </pre> <br><br><h2> 参考文献 </h2><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">耐心排序</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://translate.google.com.ua/translate%3Fsl%3Den%26tl%3Dru%26js%3Dy%26prev%3D_t%26hl%3Dru%26ie%3DUTF-8%26u%3D">Google-translate</a> ） <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img width="30" height="30" src="https://habrastorage.org/webt/m8/db/1t/m8db1tyvn-pmm4ugyopcyiv7k4i.png"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">耐心排序源</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img width="84" height="30" src="https://habrastorage.org/webt/yv/lm/2t/yvlm2t2kl5affkpm0hzqh7qw5ly.png"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">普林斯顿CS：增长最快的子序列</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img width="84" height="30" src="https://habrastorage.org/webt/yv/lm/2t/yvlm2t2kl5affkpm0hzqh7qw5ly.png"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">耐心分类桩的组合</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://translate.google.com.ua/translate%3Fsl%3Den%26tl%3Dru%26js%3Dy%26prev%3D_t%26hl%3Dru%26ie%3DUTF-8%26u%3D">Google-translate</a> ） <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wiki摘要：患者分类</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">字对齐</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://translate.google.com.ua/translate%3Fsl%3Den%26tl%3Dru%26js%3Dy%26prev%3D_t%26hl%3Dru%26ie%3DUTF-8%26u%3D">Google翻译</a> ） <br><br><h3> 系列文章： </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Excel应用程序AlgoLab.xlsm</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">交换排序</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">插入排序</a> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">图书管理员排序</a> </li><li>  <b>纸牌排序</b> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">排序“河内塔”</a> </li><li> 年轻表排序 </li><li> 反转排序 </li><li> 插入排序比较 </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">按选择排序</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">合并排序</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">按分布排序</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">混合排序</a> </li></ul><br><br> 在AlgoLab应用程序中，此排序现在处于活动状态。 同时，可视化有两种模式：卡形式（默认模式）和数字形式。 但是，对于纸牌样式，必须使数组中的最大元素和最小元素之差小于54（甲板上的纸牌数量，包括两个小丑）。 如果不满足此条件，或者完全关闭了卡模式（为此，您需要在带有排序名称的单元格的注释中写入card = 0），那么可视化将采用钝数字形式。 <br><br> 西服按优先级排列： <nobr>峰&lt;俱乐部&lt;手鼓&lt;心。</nobr> <br><br><div style="text-align:center;"><img width="722" height="311" src="https://habrastorage.org/webt/_c/mz/s7/_cmzs7o5v7qaa9dxap4dcrjfznq.gif"></div><br> 就是说，手鼓的<i>任何</i>卡片比俱乐部套的<i>任何</i>卡片大，心服的<i>任何</i>卡片比高峰套的<i>任何</i>卡片大，等等。 如果我们用数字进行类比，则峰值从0到9，棍棒从10到19，菱形从20到29，心从30到39（是的，当然，在西服套装中，卡的数量不完全是10，但是您了解什么意思）。 至于<i>诉讼中的</i>资历，这很普通：从平局到王牌。 您还可以选择比所有其他牌都老的小丑。 在这种情况下，红色小丑比黑色更重。 <br><br><blockquote> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="EDISON软件-网络开发"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISON软件-网络开发"></a> <br clear="right"> 本文是在EDISON Software（一家专业的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Web开发</a>公司，最近<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">重新设计其网站）</a>的支持下撰写的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">。</a> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN431094/">https://habr.com/ru/post/zh-CN431094/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN431084/index.html">在任何无法理解的情况下-编写脚本</a></li>
<li><a href="../zh-CN431086/index.html">您想要了解的有关PVS-Studio的所有信息，可以随时询问</a></li>
<li><a href="../zh-CN431088/index.html">文件管理做错了-第1部分：最初是90年代</a></li>
<li><a href="../zh-CN431090/index.html">一个VK机器人，一个C＃和一个橙色</a></li>
<li><a href="../zh-CN431092/index.html">ROS：Raspberry Pi“低血”的深度图</a></li>
<li><a href="../zh-CN431096/index.html">如何构建聊天机器人产品</a></li>
<li><a href="../zh-CN431098/index.html">即使是火灾也不是障碍，也不是灾难发生后的Zimbra Speed Recovery</a></li>
<li><a href="../zh-CN431102/index.html">物理地址如何显示在DRAM字符串和存储区中</a></li>
<li><a href="../zh-CN431104/index.html">我们Neoflex如何开发DevOps专业知识</a></li>
<li><a href="../zh-CN431106/index.html">美国人在这个黑色星期五花了多少钱，智能手机与它有什么关系？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>