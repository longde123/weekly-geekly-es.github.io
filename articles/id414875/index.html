<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏂🏼 ▪️ ✌🏾 Kubernet mengandung integrasi yang menggantikan Docker yang siap diproduksi 👨🏽‍🎓 🆚 ⚡️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Catatan perev. : Kami telah menulis lebih dari sekali tentang contenterd dan runtime lainnya untuk Kubernetes. Publikasi baru adalah terjemahan dari p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kubernet mengandung integrasi yang menggantikan Docker yang siap diproduksi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/414875/"><img src="https://habrastorage.org/webt/bw/-e/lu/bw-elulxcq_ts7y7ln0cjnwyxng.png"><br><br>  <i><b>Catatan</b></i>  <i><b>perev.</b></i>  <i>: Kami telah menulis lebih dari sekali tentang contenterd dan runtime <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lainnya</a> untuk Kubernetes.</i>  <i>Publikasi baru adalah terjemahan dari pengumuman baru-baru ini tentang tonggak penting dalam pengembangan contenterd, yang diterbitkan di blog resmi proyek Kubernetes.</i>  <i>Teks ini ditulis oleh karyawan Google dan IBM, yang (tentu saja, bersama dengan Docker Inc) berkontribusi signifikan terhadap peningkatan konten.</i> <br><br>  Sebelumnya di blog - dalam catatan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Containerd Membawa Lebih Banyak Opsi Runtime Kontainer untuk Kubernetes</a> - kami memperkenalkan versi alpha dari integrasi contenterd dengan Kubernetes.  6 bulan ke depan pembangunan mengarah pada fakta bahwa integrasi telah tersedia untuk umum!  Ini berarti bahwa sekarang Anda dapat menggunakan contenterd <a href="">1.1</a> sebagai runtime untuk kontainer di kluster Kubernet dalam produksi. <br><br>  Containerd 1.1 bekerja dengan Kubernetes versi 1.10 dan lebih tinggi, mendukung semua fitur Kubernetes.  Dalam infrastruktur pengujian Kubernetes, cakupan pengujian integrasi contenterd di Google Cloud Platform telah menjadi sama dengan integrasi dengan Docker (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dasbor uji</a> ). <a name="habracut"></a><br><br><blockquote>  “Kami senang melihat contenterd cepat mencapai tonggak penting ini.  Di Alibaba Cloud, kami mulai menggunakan contenterd secara aktif sejak awal dan, berkat penekanannya pada kesederhanaan dan keandalan, menjadikan containerd sebagai mesin kontainer standar di produk Serverless Kubernet kami, yang menempatkan tuntutan tinggi pada kinerja dan stabilitas.  Containerd tidak diragukan lagi akan menjadi mesin utama di era kontainer dan mengarah pada pengembangan inovasi. ”  <i>- Xinwei, seorang insinyur penuh waktu dari Alibaba Cloud</i> </blockquote><br><h2>  Perbaikan arsitektur </h2><br>  Arsitektur untuk mengintegrasikan contenterd dengan Kubernetes telah berubah dua kali.  Setiap langkah evolusionernya menstabilkan dan meningkatkan efisiensi tumpukan. <br><br><h3>  Containerd 1.0 - CRI-Containerd (tidak ada) </h3><br><img src="https://habrastorage.org/webt/8q/n4/2o/8qn42ofstq8qrrucp5txrrb2wze.png"><br><br>  Dalam <i>contenterd</i> 1.0, daemon cri- <i>conteerd</i> diperlukan untuk interaksi antara <i>Kubelet</i> dan <i>conteerd</i> <i>(kami menulis tentang hal itu di akhir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini</a> - <b>kira</b> - <b>kira Terjemahkan.</b> )</i> .  Daemon ini melayani permintaan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Container Runtime Interface (CRI)</a> dari <i>Kubelet</i> dan menggunakan <i>contenterd</i> untuk mengelola kontainer dan gambar kontainer dengan benar.  Pendekatan ini menghilangkan satu tautan tambahan di stack jika dibandingkan dengan implementasi Docker CRI ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dockershim</a> ) - <i>lihat ilustrasi di atas</i> . <br><br>  Namun, cri-containerd dan containerd 1.0 adalah dua daemon terpisah yang berinteraksi melalui GRPC.  Daemon tambahan dalam bundel ini membuat hidup lebih sulit bagi pengguna baik dalam memahami perangkat dan selama penyebaran, dan juga menghasilkan overhead yang tidak perlu untuk interaksi. <br><br><h3>  Containerd 1.1 - Plugin CRI (versi saat ini) </h3><br><img src="https://habrastorage.org/webt/sc/hl/uw/schluwslee8y_n4kihjgseh0kpw.png"><br><br>  Di containerd 1.1, daemon cri-containerd diulang kembali ke plugin containerd CRI.  Plugin ini dibangun ke dalam file 1.1 dan diaktifkan secara default.  Tidak seperti cri-containerd, plugin berinteraksi dengan containerd dengan langsung memanggil fungsi yang diperlukan.  Arsitektur baru telah membuat integrasi lebih stabil dan produktif, menghilangkan tautan lain (GRPC) dari tumpukan.  Sekarang contenterd 1.1 dapat digunakan langsung di Kubernetes, dan daemon cri-containerd tidak lagi diperlukan. <br><br><h2>  Performa </h2><br>  Salah satu tujuan utama untuk contenterd 1.1 adalah untuk meningkatkan kinerja.  Optimalisasi dilakukan di area waktu start-up dan sumber daya yang digunakan oleh iblis. <br><br>  Hasil-hasil berikut adalah perbandingan dari contenterd 1.1 dan Docker 18.03 CE.  Integration Conteerd 1.1 menggunakan plugin CRI built-in, dan integrasi untuk Docker 18.03 CE bekerja dengan dockershim.  Hasilnya dihasilkan menggunakan benchmark kinerja simpul Kubernetes, yang merupakan bagian dari <a href="">tes e2e untuk node K8s</a> .  Sebagian besar data perbandingan tersedia untuk umum di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dasbor kinerja node</a> . <br><br><h3>  Tunda perapian mulai </h3><br>  Hasil <i>benchmark startup 105 pod batch</i> menunjukkan bahwa integrasi 1.1 1.1 integrasi memiliki penundaan lebih sedikit dalam memulai pod dari Docker 18.03 CE dengan dockershim (semakin kecil semakin baik). <br><br><img src="https://habrastorage.org/webt/1e/20/re/1e20rewi6uzg9ixrkmfsybifidk.png"><br><br><h3>  CPU dan memori </h3><br>  Dalam kondisi siaga, integrasi 1.1 1.1 dengan 105 perapian mengkonsumsi lebih sedikit prosesor dan memori dibandingkan dengan integrasi Docker 18.03 CE dengan dockershim.  Hasilnya dapat bervariasi tergantung pada jumlah perapian yang diluncurkan pada node - jumlah 105 perapian dipilih, karena  default sekarang adalah nilai maksimum untuk custom hearths pada node. <br><br>  Seperti yang dapat dilihat dari grafik di bawah ini, integrasi integrasi 1.1 dengan <i>Kubelet</i> mengkonsumsi CPU 30,89% lebih sedikit dan memori RSS 11,30% lebih sedikit (resident set size), serta 12,78% lebih sedikit memori RSS yang dikonsumsi oleh runtime kontainer . <br><br><img src="https://habrastorage.org/webt/ic/w6/rf/icw6rfbsd1rqn6byqbzosaalkim.png"><br><br><h3>  <i>Tambahan dari penerjemah</i> </h3><br>  <i>Perlu diperhatikan bahwa solusi alternatif lain, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CRI-O</a> , terus berkembang.</i>  <i>Secara khusus, pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">KTT Open Source Jepang 2018</a> hari ini, seorang karyawan NTT menyajikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan</a> dengan perbandingan luas dari lingkungan yang dapat dieksekusi yang ada untuk kontainer.</i>  <i>Dan inilah salah satu slide yang membandingkan kinerja mereka:</i> <br><br><img src="https://habrastorage.org/webt/q8/vv/zf/q8vvzfa4zw7ydge80hhj_higkhi.png"><br><br><h2>  crictl </h2><br>  Container Runtime Console Interface (CLI) adalah alat yang berguna untuk mengidentifikasi masalah dalam sistem dan aplikasi.  Saat menggunakan Docker sebagai lingkungan wadah di Kubernetes, administrator sistem terkadang pergi ke situs Kubernetes untuk menjalankan perintah Docker dan mengumpulkan informasi tentang sistem dan / atau aplikasi.  Misalnya, mereka dapat menggunakan <code>docker ps</code> dan <code>docker inspect</code> untuk memeriksa status proses, <code>docker images</code> untuk mendapatkan daftar gambar pada node, <code>docker info</code> untuk mendapatkan konfigurasi runtime untuk wadah, dll. <br><br>  Untuk contenterd dan semua lingkungan yang kompatibel dengan CRI lainnya seperti dockershim, kami sarankan menggunakan <i>crictl</i> sebagai alternatif CLI untuk perintah konsol Docker untuk menganalisis masalah pada pod, wadah, dan gambar kontainer yang di-host di node Kubernetes. <br><br>  <i>crictl</i> adalah utilitas yang menawarkan fitur yang mirip dengan Docker CLI dan berfungsi sama baiknya untuk semua lingkungan runtime untuk wadah yang kompatibel dengan CRI.  Itu dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori kubernetes-incubator / cri-tools</a> ;  versi saat ini adalah <a href="">cri-tools v1.11.0</a> <i>(versi ini telah diperbaiki untuk rilis saat ini 3 hari lalu alih-alih <a href="">v1.0.0-beta.1</a> , ditunjukkan dalam artikel asli, <b>kira-kira terjemahan.</b> )</i> .  Meskipun utilitas <i>crictl</i> dirancang agar mirip dengan Docker CLI, menawarkan transisi sederhana bagi pengguna, itu bukan salinan lengkapnya.  Beberapa perbedaan penting dijelaskan di bawah ini. <br><br><h3>  Penggunaan terbatas: crictl adalah alat pemecahan masalah </h3><br>  <i>crictl</i> bukan pengganti <code>kubectl</code> <code>docker</code> atau <code>kubectl</code> - penggunaannya terbatas pada ruang lingkup identifikasi dan analisis masalah.  Antarmuka Docker konsol menawarkan serangkaian perintah yang kaya, menjadikannya alat pengembangan yang sangat berguna.  Namun, ini bukan opsi terbaik untuk pemecahan masalah pada node Kubernetes.  Beberapa perintah Docker (mis. <code>docker network</code> dan <code>docker build</code> ) tidak berguna untuk Kubernetes, dan beberapa (mis. Nama <code>docker rename</code> ) dapat merusak segalanya.  Tujuan dari <i>crictl</i> adalah untuk menyediakan perintah yang cukup untuk mengidentifikasi masalah pada node yang aman digunakan di lingkungan produksi. <br><br><h3>  Fokus Kubernetes </h3><br>  <i>crictl</i> menawarkan tampilan kontainer yang lebih dimengerti di dunia Kubernetes.  Antarmuka konsol Docker tidak beroperasi dengan konsep Kubernet dasar, seperti di bawah (pod) dan namespace ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">namespace</a> ), yang mencegah representasi visual dari wadah dan perapian <i>(pentingnya masalah ini benar, sudah dalam konteks pemantauan, baru-baru ini kita bicarakan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan ini</a> - <b>catatan .perev.</b> )</i> .  Salah satu contohnya adalah <code>docker ps</code> menunjukkan nama lama yang tidak jelas untuk wadah Docker dan daftar wadah jeda bersama dengan wadah aplikasi: <br><br><img src="https://habrastorage.org/webt/4w/ne/cs/4wnecsys4wdvacswvpxcfgmhtj8.png"><br><br>  Namun, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wadah jeda</a> adalah bagian dari implementasi perapian, di mana satu wadah tersebut digunakan untuk masing-masing perapian;  mereka tidak boleh ditampilkan saat menampilkan wadah yang merupakan bagian dari perapian. <br><br>  <i>crictl</i> , sebaliknya, diciptakan untuk Kubernetes.  Utilitas ini menyediakan serangkaian perintah berbeda untuk perapian dan wadah.  Misalnya, <code>crictl pods</code> menampilkan informasi tentang <code>crictl pods</code> , dan <code>crictl ps</code> hanya menampilkan informasi tentang wadah aplikasi.  Semua data diformat dalam tampilan tabel: <br><br><img src="https://habrastorage.org/webt/fq/su/ck/fqsuckdyowdo74u-u88okijpjsk.png"><br><br><img src="https://habrastorage.org/webt/iy/xg/tf/iyxgtfzobswe9woyeay9lqylwsy.png"><br><br>  Contoh lain - di <code>crictl pods</code> terdapat argumen <code>--namespace</code> , yang memungkinkan pemfilteran pod berdasarkan namespaces yang didefinisikan dalam Kubernetes: <br><br><img src="https://habrastorage.org/webt/ib/gq/3u/ibgq3udmdsf_wbjdw5lto57ckqa.png"><br><br>  Untuk informasi lebih lanjut tentang cara menggunakan crictl dengan contenterd, lihat di sini: <br><br><ul><li>  <a href="">Dokumentasi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">demo video di asciinema</a> . </li></ul><br><h2>  Tapi bagaimana dengan Docker Engine? </h2><br>  Kita sering mendengar pertanyaan berikut: "Apakah beralih ke contenterd berarti bahwa saya tidak bisa lagi menggunakan Docker Engine?", Dan jawaban singkatnya adalah "TIDAK". <br><br>  Docker Engine dibangun berdasarkan contenterd.  Rilis Docker Community Edition (Docker CE) selanjutnya akan menggunakan contenterd versi 1.1.  Dengan demikian, itu akan memiliki built-in dan diaktifkan oleh plugin CRI default.  Ini berarti bahwa pengguna akan memiliki kesempatan untuk terus bekerja dengan Docker Engine untuk skenario tipikal lainnya, serta kemampuan untuk mengkonfigurasi Kubernetes untuk menggunakan contenterd yang mendasarinya yang datang dengan Docker Engine dan yang secara bersamaan digunakan oleh Docker Engine pada host yang sama.  Lihatlah diagram arsitektur di bawah ini yang menunjukkan bagaimana konten yang sama digunakan oleh Docker Engine dan <i>Kubelet</i> : <br><br><img src="https://habrastorage.org/webt/qj/f2/r2/qjf2r2vn_j4odysnyxytokycz9u.png"><br><br>  Karena <i>contenterd</i> digunakan oleh <i>Kubelet</i> dan Docker Engine, pengguna yang memilih untuk berintegrasi dengan contenterd tidak hanya akan mendapatkan semua fitur baru untuk Kubernetes, peningkatan kinerja dan stabilitas, tetapi juga opsi untuk menggunakan Docker Engine, seperti sebelumnya, untuk kebutuhan lainnya. <br><br>  Mekanisme <a href="">namespace</a> di <i>contenterd</i> memastikan bahwa <i>Kubelet</i> dan Docker Engine tidak akan memiliki akses ke kontainer dan gambar yang tidak dibuat oleh mereka.  Ini berarti bahwa mereka tidak akan saling mengganggu, juga: <br><br><ul><li>  Pengguna yang memasuki perintah <code>docker ps</code> tidak akan melihat wadah yang dibuat di Kubernetes.  Gunakan <code>crictl ps</code> untuk ini.  Sebaliknya, pengguna tidak akan melihat wadah yang dibuat di Docker CLI di Kubernetes atau perintah <code>crictl ps</code> .  Perintah <code>crictl create</code> dan <code>crictl run</code> hanya untuk pemecahan masalah.  Tidak dianjurkan menjalankan perapian atau wadah secara manual menggunakan <code>crictl</code> pada simpul produksi. </li><li>  Pengguna yang memasuki <code>docker images</code> tidak akan melihat gambar dari Kubernetes.  Untuk melakukan ini, gunakan perintah <code>crictl images</code> .  Sebaliknya, Kubernetes tidak akan melihat gambar yang dibuat oleh <code>docker pull</code> , <code>docker load</code> dan <code>docker build</code> commands.  Untuk melakukan ini, gunakan perintah <code>crictl pull</code> , serta <code><a href="">ctr</a> cri load</code> , jika Anda ingin memuat gambar. </li></ul><br><h2>  Ringkasan </h2><br><ul><li>  Containerd 1.1 memiliki dukungan CRI asli.  Itu dapat digunakan langsung oleh Kubernetes. </li><li>  Containerd 1.1 siap diproduksi. </li><li>  Containerd 1.1 memiliki kinerja yang baik dalam hal waktu mulai pod dan pemanfaatan sumber daya sistem. </li><li>  crictl adalah utilitas konsol (CLI) untuk berkomunikasi dengan containerd 1.1 dan lingkungan runtime lainnya untuk kontainer yang mematuhi CRI untuk mengidentifikasi masalah pada node. </li><li>  Containerd 1.1 akan dimasukkan dalam rilis stabil berikutnya Docker CE.  Pengguna akan dibiarkan dengan opsi untuk terus bekerja dengan Docker dalam kasus non-Kubernetes dan mengonfigurasi Kubernetes untuk menggunakan server konten yang mendasarinya yang merupakan bagian dari Docker. </li></ul><br>  Kami ingin mengucapkan terima kasih kepada semua orang dari Google, IBM, Docker, ZTE, ZJU dan pengembang individual yang telah berkontribusi dan membuat semua ini menjadi mungkin! <br><br>  Untuk daftar terperinci dari perubahan dalam konten 1.1, lihat <a href="">Catatan Rilis</a> . <br><br><h2>  Bagaimana cara mencoba </h2><br>  Petunjuk untuk menyiapkan kluster Kubernet untuk menggunakan contenterd sebagai runtime default: <br><br><ul><li>  untuk sebuah cluster di GCE, dibesarkan menggunakan <code>kube-up.sh</code> , - di <a href="">sini</a> ; </li><li>  untuk menginstal sekelompok banyak node menggunakan Ansible dan kubeadm - di <a href="">sini</a> ; </li><li>  untuk membuat cluster dari awal di Google Cloud - lihat " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kubernetes the Hard Way</a> "; </li><li>  untuk instalasi manual dari arsip tarball - di <a href="">sini</a> ; </li><li>  untuk instalasi menggunakan LinuxKit pada mesin virtual lokal - di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </li></ul><br><h2>  Bagaimana cara berkontribusi </h2><br>  Plugin Containerd CRI - Proyek open source di GitHub, yang merupakan bagian dari containerd: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/containerd/cri</a> .  Semua perubahan yang diajukan diterima dalam bentuk ide, tiket, koreksi.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan</a> memulai pengembang ini adalah titik awal yang baik untuk melakukan perubahan. <br><br><h2>  PS dari penerjemah </h2><br>  Baca juga di blog kami: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CRI-O - sebuah alternatif untuk Docker untuk meluncurkan kontainer di Kubernetes</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa dan mengapa Docker melakukan Moby untuk berintegrasi dengan Kubernetes?"</a>  "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Empat CNCF merilis 1.0 dan pengumuman besar tentang Kubernetes dengan KubeCon 2017</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengapa kita perlu contenterd dan mengapa itu dipisahkan dari Docker</a> "; </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa inti dari proyek Moby dan mengapa moby / moby tiba-tiba menjadi gudang Docker utama?</a>  " </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414875/">https://habr.com/ru/post/id414875/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414865/index.html">iMaterialist Furniture Challenge atau 50 warna kursi</a></li>
<li><a href="../id414867/index.html">ThinkingHome.Migrator - migrasi skema database dengan platform .NET Core</a></li>
<li><a href="../id414869/index.html">Kerangka kerja yang hilang</a></li>
<li><a href="../id414871/index.html">Badai debu di Mars mencapai skala planet, bahkan Curiosity terpengaruh</a></li>
<li><a href="../id414873/index.html">IDisposable - bahwa ibumu tidak berbicara tentang membebaskan sumber daya. Bagian 1</a></li>
<li><a href="../id414877/index.html">Lensa yang tidak biasa untuk kamera biasa atau cara berhenti memikirkan fokus</a></li>
<li><a href="../id414879/index.html">Mengapa 2 ekstruder di printer 3D?</a></li>
<li><a href="../id414881/index.html">Sedikit di belakang panggung VK</a></li>
<li><a href="../id414883/index.html">Kenangan terdengar dengan cara baru: BBC memperbarui arsip suara proyek RemArc</a></li>
<li><a href="../id414885/index.html">Kami menangani kesalahan dan "penopang" dalam Daftar Badan Hukum Negara Bersatu - register negara dari badan hukum</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>