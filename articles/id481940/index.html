<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🏭 🚈 🏝️ Pekerjaan cepat dan efektif di baris perintah 🚑 🤢 👨🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ada banyak tips dan tip baris perintah di internet. Kebanyakan dari mereka menggambarkan hal-hal sepele seperti "pelajari hotkey" atau " sudo !! akan ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pekerjaan cepat dan efektif di baris perintah</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481940/"><p> Ada banyak tips dan tip baris perintah di internet.  Kebanyakan dari mereka menggambarkan hal-hal sepele seperti "pelajari hotkey" atau " <code>sudo !!</code> akan menjalankan perintah sebelumnya dengan sudo".  Alih-alih itu, saya akan memberi tahu Anda apa yang harus dilakukan ketika Anda sudah mempelajari hotkey dan tahu tentang <code>sudo !!</code>  . </p><a name="habracut"></a><br><h3 id="the-terminal-should-start-instantly">  Terminal harus mulai secara instan </h3><br><p>  Berapa banyak waktu yang Anda habiskan untuk meluncurkan terminal?  Dan satu lagi?  Untuk waktu yang lama saya telah menggunakan Ctrl + Alt + T pintas untuk meluncurkan terminal dan saya pikir itu cepat.  Ketika saya telah bermigrasi dari Openbox ke i3, saya mulai meluncurkan terminal melalui Win + Enter, yang mengikat bekerja di luar kotak.  Anda tahu?  Sekarang saya tidak berpikir bahwa Ctrl + Alt + T cukup cepat. </p><br><p>  Tentu saja, masalahnya bukan speedup milidetik, tetapi Anda membuka terminal pada tingkat refleks, sama sekali tidak menyadari hal itu. </p><br><p>  Jadi, jika Anda sering menggunakan terminal, tetapi ambil mouse untuk meluncurkannya, cobalah untuk mengkonfigurasi hotkey berguna.  Saya yakin, Anda akan menyukainya. </p><br><h3 id="zsh-instead-of-bash">  Zsh bukannya bash </h3><br><p>  Ini adalah topik perang suci, saya tahu.  Anda harus menginstal Zsh untuk setidaknya tiga fitur: pelengkapan otomatis lanjutan, koreksi salah ketik dan penyelesaian beberapa pathname: ketika satu Tab mengubah <code>/u/s/d</code> menjadi <code>/usr/share/doc</code> .  Arch Linux sudah bermigrasi ke Zsh di CD instalasinya.  Saya harap Zsh akan menjadi shell default di Ubuntu.  Itu akan menjadi momen bersejarah. </p><br><p>  Mulai menggunakan Zsh tidak sulit sama sekali.  Instal saja melalui manajer paket dan temukan konfigurasi yang cantik.  Saya sarankan untuk menggunakan config yang digunakan di Arch Linux: </p><br><pre> <code class="plaintext hljs">$ wget -O ~/.zshrc https://git.grml.org/f/grml-etc-core/etc/zsh/zshrc</code> </pre> <br><p>  Satu-satunya yang tersisa adalah mengubah shell default dan login kembali. </p><br><pre> <code class="plaintext hljs">$ chsh -s $(which zsh)</code> </pre> <br><p>  Itu semua, tetap bekerja seperti tidak ada yang terjadi. </p><br><h3 id="how-the-shell-prompt-should-look-like">  Seperti apa tampilan shell prompt </h3><br><p>  Shell prompt adalah sepotong kecil teks yang ditampilkan di terminal di awal baris perintah Anda.  Ini harus dikonfigurasi untuk jenis pekerjaan Anda.  Anda dapat melihatnya sebagai dashbord kendaraan.  Tolong, letakkan beberapa informasi berguna di sana, biarkan itu membantu Anda menavigasi!  Jadikan berguna terutama jika Anda melihatnya setiap hari! </p><br><p>  Shell prompt harus diwarnai.  Tidak setuju?  Coba hitung berapa banyak perintah yang dieksekusi di terminal ini: </p><br><p><img src="https://habrastorage.org/webt/yh/mu/s7/yhmus7x5-abqnlrho5u5djwau8o.png"></p><br><p>  Dan sekarang dengan warna: </p><br><p><img src="https://habrastorage.org/webt/re/1b/ln/re1blnqfemmydwf99758sbirqai.png"></p><br><p>  Shell prompt harus menampilkan direktori kerja shell saat ini.  Jika direktori kerja saat ini tidak ditampilkan, Anda harus mengingatnya dan secara berkala memeriksanya dengan perintah <code>pwd</code> .  Tolong jangan lakukan itu.  Ingatlah beberapa hal yang sangat penting dan jangan buang waktu Anda untuk perintah <code>pwd</code> . </p><br><p>  Jika Anda terkadang beralih ke root akun, Anda memerlukan indikasi "pengguna saat ini".  Nama pengguna tertentu seringkali tidak penting, tetapi statusnya (reguler atau root) adalah.  Solusinya adalah menggunakan warna: prompt shell merah untuk root dan hijau untuk pengguna biasa.  Dan Anda tidak akan pernah mengambil alih shell root seperti biasa. </p><br><p>  Jika Anda terhubung ke server menggunakan ssh, Anda perlu membedakan shell lokal dan remote Anda.  Untuk tujuan itu, prompt shell Anda harus berisi nama host, atau bahkan lebih baik - menunjukkan koneksi ssh. </p><br><p>  Shell prompt dapat menampilkan kode keluar dari perintah terakhir.  Ingatlah bahwa kode keluar nol berarti perintah berhasil keluar, bukan nol - perintah tidak berhasil.  Anda dapat memperoleh kode keluar perintah terakhir melalui <code>echo $?</code>  , tapi mengetik semua itu adalah hal yang sangat panjang.  Biarkan shell menunjukkan Anda gagal keluar sebagai gantinya. </p><br><p>  Jika Anda bekerja dengan repositori Git, akan berguna untuk melihat status repositori dalam prompt shell: cabang saat ini dan status direktori kerja.  Anda akan menghemat waktu pada <code>git status</code> <code>git branch</code> dan perintah <code>git branch</code> dan tidak akan melakukan ke cabang yang salah.  Ya, perhitungan status mungkin membutuhkan waktu yang signifikan dalam repositori gemuk, tetapi bagi saya kelebihannya adalah kelebihannya. </p><br><p>  Beberapa orang menambahkan jam ke prompt shell atau bahkan nama terminal virtual (tty), atau beberapa coretan arbitrer.  Itu semua berlebihan.  Lebih baik menyimpan banyak ruang untuk perintah. </p><br><p>  Seperti itulah tampilan shell saya dalam kondisi yang berbeda: </p><br><p><img src="https://habrastorage.org/webt/ka/q3/gf/kaq3gfz9idb6pkxdglx44qyuxlq.png"></p><br><p>  Anda dapat melihat pada tangkapan layar bahwa batang judul terminal melakukan pekerjaan serupa.  Ini juga sepotong dasbor dan juga harus dikonfigurasi. </p><br><p>  Jadi, bagaimana semua hal ini harus diimplementasikan dalam <code>.zshrc</code> ?  Variabel <code>PROMPT</code> menetapkan prompt kiri dan <code>RPROMPT</code> mengatur prompt kanan.  Variabel <code>EUID</code> mendefinisikan status pengguna (reguler atau root) dan kehadiran <code>SSH2_CLIENT</code> atau <code>SSH2_CLIENT</code> menunjukkan koneksi ssh.  Jadi kita dapat memiliki templat: </p><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ -n <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$SSH_CLIENT</span></span></span><span class="hljs-string">"</span></span> || -n <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$SSH2_CLIENT</span></span></span><span class="hljs-string">"</span></span> ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">$EUID</span></span> == 0 ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> PROMPT=... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> PROMPT=... <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment"># not SSH if [[ $EUID == 0 ]]; then PROMPT=... else PROMPT=... fi fi</span></span></code> </pre> <br><p>  Saya tidak menunjukkan kode copy-paste-ready karena implementasi yang tepat adalah masalah selera.  Jika Anda tidak ingin repot dan tangkapan layar di atas tidak masalah untuk Anda, daripada mengambil cofig saya dari <a href="" rel="nofollow">Github</a> . </p><br><p>  Ringkasan: </p><br><ul><li>  Prompt shell berwarna harus dimiliki. </li><li>  Minimum yang diperlukan adalah direktori kerja saat ini. </li><li>  Shell root harus terlihat jelas. </li><li>  Nama pengguna tidak peduli dengan muatan jika Anda hanya menggunakan satu akun. </li><li>  Nama host berguna jika Anda terhubung ke server melalui ssh, itu tidak wajib jika tidak. </li><li>  Sangat berguna untuk melihat kode keluar yang gagal dari perintah terakhir. </li><li>  Git repo status menghemat waktu pada <code>git status</code> dan perintah <code>git branch</code> dan membawa sangat mudah. </li></ul><br><h3 id="heavily-use-the-command-history">  Sangat menggunakan sejarah perintah </h3><br><p>  Sebagian besar perintah dalam hidup Anda Anda masukkan lebih dari satu kali, jadi akan lebih baik untuk mengeluarkannya dari riwayat alih-alih mengetik lagi.  Semua shell modern menyimpan sejarah perintah dan menyediakan beberapa cara untuk mencari melalui sejarah itu. </p><br><p>  Mungkin Anda sudah bisa menggali sejarah menggunakan Ctrl + R keybinding.  Sayangnya ia memiliki dua kelemahan: </p><br><ol><li>  Baris perintah harus kosong untuk memulai pencarian, yaitu dalam hal "seseorang mulai mengetik perintah - ingat tentang pencarian" Anda harus membersihkan mengetik Anda terlebih dahulu, kemudian tekan Ctrl + R dan ulangi input Anda.  Itu terlalu lama. </li><li>  Pencarian maju tidak bekerja dengan defaul karena Ctrl + S menghentikan terminal. </li></ol><br><p>  Jenis pencarian yang paling cepat dan nyaman bekerja dengan cara ini: </p><br><ol><li>  Anda mulai mengetik perintah, </li><li>  Anda ingat tentang pencarian, </li><li>  Anda menekan tombol pintas dan shell menawarkan perintah dari sejarah yang dimulai dengan cara yang sama. </li></ol><br><p>  Misalnya Anda ingin menyinkronkan direktori lokal dengan yang jauh menggunakan Rsync dan Anda sudah melakukannya dua jam sebelumnya.  Anda mengetik <code>rsync</code> , tekan hotkey satu atau dua kali dan perintah yang diinginkan siap diluncurkan.  Anda tidak perlu mengaktifkan mode pencarian terlebih dahulu, prompt shell tidak berubah menjadi <code>(reverse-i-search)':</code> , dan tidak ada yang melompat di mana pun.  Anda hanya menelusuri sejarah dengan cara yang sama Anda menekan panah ↑ ↓ untuk menggulir melalui perintah yang dimasukkan sebelumnya tetapi dengan pemfilteran tambahan.  Itu sangat keren dan menghemat banyak waktu. </p><br><p>  Pencarian semacam ini tidak berfungsi secara default di Bash dan Zsh, jadi Anda harus mengaktifkannya secara manual.  Saya telah memilih PgUp untuk mencari maju dan PgDown untuk mencari mundur.  Ini jauh untuk menjangkau mereka, tetapi saya sudah membuat kebiasaan.  Mungkin nanti saya akan beralih ke sesuatu yang lebih dekat seperti Ctrl + P dan Ctrl + N. </p><br><p>  Untuk Bash Anda perlu menambahkan beberapa string ke <code>/etc/inputrc</code> dari <code>~/.inputrc</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-string"><span class="hljs-string">"\e[5~"</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-search-backward <span class="hljs-string"><span class="hljs-string">"\e[6~"</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-search-forward</code> </pre> <br><p>  Jika Anda telah mengambil <code>.zshrc</code> lengkap asing, sangat mungkin bahwa PgUp dan PgDown sudah melakukan pekerjaan itu.  Jika tidak, tambahkan ke <code>~/.zshrc</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">bindkey</span></span> <span class="hljs-string"><span class="hljs-string">"^[[5~"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-beginning-search-backward <span class="hljs-comment"><span class="hljs-comment"># pg up bindkey "^[[6~" history-beginning-search-forward # pg down</span></span></code> </pre> <br><p>  Kerang Ikan dan Ipython sudah memiliki pencarian yang diikat ke panah ↑ ↓.  Saya pikir banyak pengguna bermigrasi ke Fish hanya karena perilaku panah.  Tentu saja, mungkin untuk mengikat panah dengan cara ini di Bash dan Zsh jika Anda mau.  Gunakan ini di <code>/etc/inputrc</code> dari <code>~/.inputrc</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-string"><span class="hljs-string">"\e[A"</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-search-backward <span class="hljs-string"><span class="hljs-string">"\e[B"</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-search-forward</code> </pre> <br><p>  Dan ini untuk di <code>~/.zshrc</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">autoload</span></span> -U up-line-or-beginning-search <span class="hljs-built_in"><span class="hljs-built_in">autoload</span></span> -U down-line-or-beginning-search <span class="hljs-built_in"><span class="hljs-built_in">zle</span></span> -N up-line-or-beginning-search <span class="hljs-built_in"><span class="hljs-built_in">zle</span></span> -N down-line-or-beginning-search <span class="hljs-built_in"><span class="hljs-built_in">bindkey</span></span> <span class="hljs-string"><span class="hljs-string">"^[[A"</span></span> up-line-or-beginning-search <span class="hljs-built_in"><span class="hljs-built_in">bindkey</span></span> <span class="hljs-string"><span class="hljs-string">"^[[B"</span></span> down-line-or-beginning-search</code> </pre> <br><p>  Sangat mengherankan bahwa lama-kelamaan saya mulai menulis perintah dengan mengingat bahwa nanti saya akan menariknya keluar dari sejarah.  Mari saya tunjukkan beberapa teknik. </p><br><p>  <strong>Bergabunglah dengan perintah</strong> yang selalu mengikuti satu sama lain: </p><br><pre> <code class="plaintext hljs"># ip link set eth1 up &amp;&amp; dhclient eth1 # mkdir /tmp/t &amp;&amp; mount /dev/sdb1 /tmp/t</code> </pre> <br><p>  <strong>Path absolut alih-alih relatif</strong> membiarkan Anda menjalankan perintah dari direktori apa pun: <br>  <code>vim ~/.ssh/config</code> alih-alih <code>vim .ssh/config</code> , <code>systemd-nspawn /home/chroot/stretch</code> bukannya <code>systemd-nspawn /home/chroot/stretch</code> <code>systemd-nspawn stretch</code> dan seterusnya. </p><br><p>  <strong>Penggunaan wildcard</strong> menjadikan perintah Anda lebih universal.  Saya biasanya menggunakannya bersamaan dengan <code>chmod</code> dan <code>chown</code> . </p><br><pre> <code class="plaintext hljs"># chown root:root /var/www/*.sq &amp;&amp; chmod 644 /var/www/*.sq</code> </pre> <br><h3 id="keyboard-shortcuts">  Pintasan keyboard </h3><br><p>  Inilah minimum yang diwajibkan. </p><br><p>  Alt +.  - Mengganti argumen terakhir dari perintah sebelumnya.  Ini juga dapat diakses dengan <code>!$</code> . <br>  Ctrl + A, Ctrl + E - masing-masing melompat ke awal dan akhir baris. <br>  Ctrl + U, Ctrl + Y - potong dan tempel.  Ini berguna ketika Anda mengetik perintah yang rumit dan memperhatikan bahwa Anda perlu menjalankan yang lain terlebih dahulu.  Hmm, di mana menyimpan input saat ini?  Di sini <br>  Ctrl + W - membunuh satu kata sebelum kursor.  Ini membersihkan garis ketika ditekan dan tahan.  Secara default input disimpan ke clipboard (digunakan untuk Ctrl + Y). <br>  Ctrl + K - memotong bagian garis setelah kursor, menambahkannya ke clipboard.  Ctrl + A Ctrl + K dengan cepat menghapus garis. <br>  PgUp, PgDown, Ctrl + R - pencarian riwayat. <br>  Ctrl + L membersihkan terminal. </p><br><h3 id="keyboard-responsiveness">  Keyboard responsif </h3><br><p>  Saya ingin menunjukkan kepada Anda pengaturan kecil yang memungkinkan Anda untuk menggulir, menavigasi, dan menghapus lebih cepat.  Apa yang kita lakukan ketika kita ingin menghapus sesuatu yang besar?  Kami menekan dan menahan Backspace dan melihatnya berlari kembali menyeka karakter.  Apa yang sebenarnya terjadi?  Setelah Backspace ditekan, satu karakter menghilang, lalu tunda kecil, lalu ulang otomatis dipicu: Backspace menghapus karakter satu per satu, seperti Anda menekannya berulang kali. </p><br><p>  Saya sarankan Anda untuk mengatur penundaan dan frekuensi ulang otomatis untuk kecepatan jari-jari Anda.  Penundaan diperlukan saat Anda ingin menghapus hanya satu karakter - ini memberi Anda waktu untuk melepaskan kunci.  Penundaan terlalu besar membuat Anda menunggu untuk mengulangi secara otomatis.  Tidak cukup bagi Anda untuk terganggu, tetapi cukup untuk memperlambat pemindahan pikiran Anda dari kepala ke komputer.  Semakin besar frekuensi berulang otomatis, semakin cepat teks dihapus dan semakin sulit untuk menghentikan proses ini.  Tujuannya adalah untuk menemukan nilai optimal. </p><br><p>  Jadi, perintah ajaibnya adalah: </p><br><pre> <code class="plaintext hljs">$ xset r rate 190 20</code> </pre> <br><p>  190 - durasi penundaan dalam milidetik, <br>  20 - frekuensi dalam pengulangan per detik. </p><br><p>  Saya merekomendasikan untuk memulai dari nilai-nilai ini dan meningkatkan sedikit demi sedikit keterlambatan sampai positif palsu, kemudian kembali sedikit.  Jika penundaannya terlalu kecil, Anda tidak akan dapat menggunakan keyboard.  Untuk memperbaikinya X-server atau komputer lengkap harus di-restart.  Jadi, harap berhati-hati. </p><br><p>  Untuk menyimpan parameter, Anda perlu menambahkan perintah ini di suatu tempat di X autostart. </p><br><h3 id="process-exit-indication">  Proses indikasi keluar </h3><br><p>  Saya sering harus memulai beberapa proses jangka panjang: cadangan lemak, transfer data besar, pengepakan arsip / penggalian, pembuatan paket dan sebagainya.  Biasanya saya memulai proses seperti itu, beralih ke tugas lain dan sesekali menatap jika proses jangka panjang saya telah keluar.  Terkadang saya menyelam terlalu dalam ke pekerjaan dan melupakannya.  Solusinya adalah dengan menambahkan notifikasi proses keluar yang akan membawa saya keluar dari trance. </p><br><p>  Ada banyak alat untuk tujuan itu: notify-send, dzen2, beep, aplay, wall.  Semuanya entah bagaimana bagus, tetapi tidak bekerja dengan koneksi ssh.  Itu sebabnya saya menggunakan terminal bip: </p><br><pre> <code class="plaintext hljs">$ long-running-command; echo $'\a'</code> </pre> <br><p>  Pengkodean ASCII memiliki karakter 0x7, bernama <a href="https://en.wikipedia.org/wiki/Bell_character" rel="nofollow">bell</a> .  Ini digunakan untuk membunyikan bip speaker PC.  PC-speaker bukanlah hal yang modern, tidak semua komputer memilikinya dan tidak terdengar di headphone.  Itu sebabnya beberapa terminal menggunakan apa yang disebut bel visual.  Saya menggunakan urxvt, dan melakukan lonceng visual dengan menaikkan bendera urgensi.  Apa itu  Ini adalah hal yang digunakan ketika sebuah jendela ingin memberi tahu Anda bahwa ini mendesak. </p><br><p>  Anda dapat memeriksa bagaimana terminal Anda bereaksi pada karakter bel sekarang: </p><br><pre> <code class="plaintext hljs">$ sleep 3; echo $'\a'</code> </pre> <br><p>  Tiga detik diberikan bagi Anda untuk beralih ke jendela lain, mungkin diperlukan. </p><br><p>  Sayangnya, tidak setiap terminal dapat menampilkan bel visual dengan mengibarkan bendera urgensi.  Saya sudah memeriksa yang paling populer. </p><br><div class="scrollable-table"><table><thead><tr><th>  Terminal emulator </th><th>  bel visual sebagai bendera urgensi </th></tr></thead><tbody><tr><td>  konsole </td><td>  dapat diaktifkan dalam preferensi </td></tr><tr><td>  urxvt </td><td>  iya </td></tr><tr><td>  terminal xfce4 </td><td>  dapat diaktifkan dalam preferensi </td></tr><tr><td>  xterm </td><td>  tidak </td></tr><tr><td>  istilah retro keren </td><td>  tidak </td></tr><tr><td>  Lxterminal </td><td>  tidak </td></tr><tr><td>  terminal gnome </td><td>  tidak </td></tr></tbody></table></div><br><p>  Terlalu panjang untuk mengetikkan <code>echo $'\a'</code> , jadi saya membuat alias <code>wake</code> . </p><br><h3 id="aliases">  Alias </h3><br><p>  Secara default perintah <code>cp</code> , <code>scp</code> dan <code>rm</code> bekerja secara non-rekursif dan itu payah!  Ini warisan buruk!  Yah, mungkin diperbaiki menggunakan alias.  Tapi pertama-tama mari kita lihat ketika perilaku non-rekursif dapat bermanfaat. </p><br><pre> <code class="plaintext hljs">$ mkdir foodir $ cp * foodir</code> </pre> <br><p>  Hanya file yang akan disalin ke dalam <code>foodir</code> , tetapi bukan direktori.  Situasi yang sama berlaku dengan <code>rm</code> : </p><br><pre> <code class="plaintext hljs">$ rm *</code> </pre> <br><p>  hanya akan menghapus file dan symlink, tetapi menyimpan direktori.  Tetapi seberapa sering Anda membutuhkan fitur ini?  Saya suka berpikir bahwa <code>cp</code> dan <code>rm</code> selalu bekerja secara rekursif. </p><br><p>  Ok, tapi bagaimana dengan keamanan?  Mungkin perilaku non-rekursif melindungi file Anda?  Ada satu kasus ketika Anda memiliki symlink ke direktori dan Anda ingin menghapus symlink itu, tetapi simpan direktori tersebut.  Jika garis miring ditambahkan (sengaja atau sesekali) ke nama direktori dan mode rekursif diaktifkan melalui <code>-r</code> , direktori akan menjadi kosong!  KOSONG! </p><br><pre> <code class="plaintext hljs">$ ln -s foodir dir_link $ rm -r dir_link/</code> </pre> <br><p>  Tanpa <code>-r</code> arg itu akan menyalahgunakan dan tidak menghapus apa pun.  Jadi, <code>rm</code> rekursif meningkatkan risiko kehilangan data sedikit. </p><br><p>  Saya mengaktifkan mode rekursif untuk <code>cp</code> , <code>scp</code> dan <code>rm</code> , dan juga menambahkan <code>-p</code> untuk <code>mkdir</code> untuk membuat direktori bersarang dengan mudah. </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> cp=<span class="hljs-string"><span class="hljs-string">'cp -r'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> scp=<span class="hljs-string"><span class="hljs-string">'scp -r'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> rm=<span class="hljs-string"><span class="hljs-string">'rm -r'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> mkdir=<span class="hljs-string"><span class="hljs-string">'mkdir -p'</span></span></code> </pre> <br><p>  Selama dua tahun saya tidak pernah menyesal tentang alias ini dan tidak pernah kehilangan data.  Ada juga kelemahan: itu mungkin untuk menyalin / menghapus lebih sedikit data, daripada yang dibutuhkan dan tidak bisa melihatnya ketika bekerja pada sistem tanpa alias.  Jadi, harap berhati-hati.  Saya tahu apa yang saya lakukan dan selalu menjalankan <code>rm</code> dengan hati-hati. </p><br><p>  Yang paling populer adalah alias <code>ls</code> dan Anda mungkin sudah menggunakannya: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> ls=<span class="hljs-string"><span class="hljs-string">'ls -F --color=auto'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> la=<span class="hljs-string"><span class="hljs-string">'ls -A'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> ll=<span class="hljs-string"><span class="hljs-string">'ls -lh'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> lla=<span class="hljs-string"><span class="hljs-string">'ll -A'</span></span></code> </pre> <br><p>  Juga grep berwarna jauh lebih cantik daripada tidak berwarna: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> grep=<span class="hljs-string"><span class="hljs-string">'grep --colour=auto'</span></span></code> </pre> <br><p>  Alias ​​tidak bekerja dalam skrip, jangan lupa fakta itu!  Anda harus secara eksplisit menentukan semua argumen. </p><br><h3 id="touch-typing">  Sentuhan mengetik </h3><br><p>  Jelas, tetapi saya ingatkan Anda: pengetikan sentuh membantu pengetikan lebih cepat.  Ini akan sulit pada awalnya, tetapi Anda akan mengatasi batas waktu. </p><br><p>  Waktu terbaik untuk belajar mengetik adalah liburan, ketika tidak ada yang mengganggu Anda.  Tolong jangan terburu-buru saat belajar!  Tujuan Anda adalah <em>untuk mengingat di</em> mana setiap karakter berada, tidak dengan pikiran Anda, tetapi dengan jari-jari Anda.  Lebih baik mengetik lambat, tetapi tanpa kesalahan daripada cepat dengan kesalahan.  Ingatlah bahwa tuan memiliki hasil yang baik bukan dengan jari cepat tetapi tidak melakukan kesalahan. </p><br><p>  Jangan lupa istirahat.  Otak dan jari Anda perlu istirahat.  Ketika kesalahan mulai muncul, itu artinya Anda perlu istirahat. </p><br><h3 id="that-is-all-for-today">  Itu saja untuk hari ini </h3><br><p>  Saya harap tips ini akan sangat membantu Anda.  Semoga beruntung </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481940/">https://habr.com/ru/post/id481940/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481926/index.html">Memenuhi Cadangan Veeam Baru untuk Solusi AWS</a></li>
<li><a href="../id481930/index.html">Budaya Pembangunan: Bagaimana Kinerja dan Efisiensi Dievaluasi</a></li>
<li><a href="../id481932/index.html">Penerapan dan Basis Data Downtime Nol</a></li>
<li><a href="../id481934/index.html">Analisis: mengapa harga saham Tesla tumbuh</a></li>
<li><a href="../id481936/index.html">Pro dan Kontra Pengujian A / B: Pengalaman Perusahaan Besar</a></li>
<li><a href="../id481942/index.html">Kembali ke masa depan: apa yang disajikan game modern pada tahun 2010</a></li>
<li><a href="../id481944/index.html">Apa yang menentukan posisi situs pada halaman pencarian?</a></li>
<li><a href="../id481946/index.html">Metode Komunikasi dalam Tim Microsoft: Saluran VS Obrolan</a></li>
<li><a href="../id481948/index.html">Bagaimana cara membuat robot virtual?</a></li>
<li><a href="../id481950/index.html">Tutorial: Boot Musim Semi Reaktif</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>