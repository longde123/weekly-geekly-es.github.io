<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐉 🖕🏾 🤚🏿 覆盖Equals和GetHashCode。 但是有必要吗？ 👂🏻 🌗 🤜🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="如果您熟悉C＃，则很可能知道必须始终重写Equals以及GetHashCode以避免性能GetHashCode 。 但是如果不这样做会怎样？ 今天，我们将性能与两个调整选项进行比较，并考虑使用有助于避免错误的工具。 



 这个问题有多严重？ 
 并非每个潜在的性能问题都会影响应用程序的运行时间。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>覆盖Equals和GetHashCode。 但是有必要吗？</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/418515/">如果您熟悉C＃，则很可能知道必须始终重写<code>Equals</code>以及<code>GetHashCode</code>以避免性能<code>GetHashCode</code> 。 但是如果不这样做会怎样？ 今天，我们将性能与两个调整选项进行比较，并考虑使用有助于避免错误的工具。 <br><br><img src="https://habrastorage.org/webt/w9/iq/7g/w9iq7gen1fjdvh3j6jcxai470ec.jpeg"><a name="habracut"></a><br><br><h2> 这个问题有多严重？ </h2><br> 并非每个潜在的性能问题都会影响应用程序的运行时间。  <code>Enum.HasFlag</code>方法的效率不是很高（*），但是如果您不将其用于资源密集的代码段，则项目中不会出现严重的问题。 对于由只读上下文中的非只读结构类型创建的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">受保护副本</a> ，情况也是如此。 存在该问题，但在普通应用程序中不太可能引起注意。 <br><br>  <i>（*）已在.NET Core 2.1中修复，并且正如我<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在先前的出版物中</a>提到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的那样</a> ，现在可以使用针对较早版本的自配置HasFlag减轻后果。</i> <br><br> 但是，我们今天要谈论的问题是特殊的。 如果未在结构中创建<code>Equals</code>和<code>GetHashCode</code>方法，则<code>System.ValueType</code>的标准版本。 而且它们会大大降低最终应用程序的性能。 <br><br><h2> 为什么标准版本比较慢？ </h2><br>  CLR作者竭尽全力使Equals和GetHashCode的标准版本对值类型尽可能有效。 但是，有几种原因会导致这些方法失去用户版本的有效性，这些版本是手动为某种类型编写的（或由编译器生成的）。 <br><br>  1.配送包装转换。  CLR的设计方式是，每次对<code>System.ValueType</code>或<code>System.Enum</code>类型中定义的元素的调用都会触发包装转换（**）。 <br><br>  <i>（**）如果该方法不支持JIT编译。</i>  <i>例如，在Core CLR 2.1中，JIT编译器识别<code>Enum.HasFlag</code>方法并生成不会开始包装的合适代码。</i> <br><br>  2.标准版本的<code>GetHashCode</code>方法中可能存在冲突。 在实现哈希函数时，我们面临一个难题：使哈希函数的分布良好或快速。 在某些情况下，您可以同时执行两种操作，但是在<code>ValueType.GetHashCode</code>类型中，这通常很困难。 <br><br> 类型为struct的传统哈希函数“组合”所有字段的哈希码。 但是，在<code>ValueType</code>方法中获取字段哈希码的唯一方法是使用反射。 这就是CLR作者决定为分发而牺牲速度的原因，而标准版本的<code>GetHashCode</code>仅返回第一个非零字段的哈希码，并<a href="">使用类型标识符</a> （***）“ <code>RegularGetValueTypeHashCode</code> <a href="">”它</a> （有关更多详细信息，请参阅github上<code>RegularGetValueTypeHashCode</code>中的RegularGetValueTypeHashCode）。 <br><br>  <i>（***）根据CoreCLR存储库中的注释判断，将来情况可能会有所变化。</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Location { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Path { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Position { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Location</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position</span></span></span><span class="hljs-function">)</span></span> =&gt; (Path, Position) = (path, position); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Location(path: <span class="hljs-string"><span class="hljs-string">""</span></span>, position: <span class="hljs-number"><span class="hljs-number">42</span></span>).GetHashCode(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Location(path: <span class="hljs-string"><span class="hljs-string">""</span></span>, position: <span class="hljs-number"><span class="hljs-number">1</span></span>).GetHashCode(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Location(path: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, position: <span class="hljs-number"><span class="hljs-number">42</span></span>).GetHashCode(); <span class="hljs-comment"><span class="hljs-comment">// hash1 and hash2 are the same and hash1 is different from hash3</span></span></code> </pre> <br> 这是一个合理的算法，直到出现问题为止。 但是，如果您不走运，并且在大多数情况下struct类型的第一个字段的值相同，那么hash函数将始终产生相同的结果。 您可能已经猜到了，如果将这些实例保存在哈希集或哈希表中，则性能会下降。 <br><br>  3.基于反射的实现速度较低。 很低 如果正确使用，反射是一个强大的工具。 但是，如果您在占用大量资源的代码上运行它，后果将是可怕的。 <br><br> 让我们看看失败的哈希函数（可能由（2）和基于反射的实现导致）如何影响性能： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Location1 { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Path { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Position { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Location1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position</span></span></span><span class="hljs-function">)</span></span> =&gt; (Path, Position) = (path, position); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Location2 { <span class="hljs-comment"><span class="hljs-comment">// The order matters! // The default GetHashCode version will get a hashcode of the first field public int Position { get; } public string Path { get; } public Location2(string path, int position) =&gt; (Path, Position) = (path, position); } public readonly struct Location3 : IEquatable&lt;Location3&gt; { public string Path { get; } public int Position { get; } public Location3(string path, int position) =&gt; (Path, Position) = (path, position); public override int GetHashCode() =&gt; (Path, Position).GetHashCode(); public override bool Equals(object other) =&gt; other is Location3 l &amp;&amp; Equals(l); public bool Equals(Location3 other) =&gt; Path == other.Path &amp;&amp; Position == other.Position; } private HashSet&lt;Location1&gt; _locations1; private HashSet&lt;Location2&gt; _locations2; private HashSet&lt;Location3&gt; _locations3; [Params(1, 10, 1000)] public int NumberOfElements { get; set; } [GlobalSetup] public void Init() { _locations1 = new HashSet&lt;Location1&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location1("", n))); _locations2 = new HashSet&lt;Location2&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location2("", n))); _locations3 = new HashSet&lt;Location3&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location3("", n))); _locations4 = new HashSet&lt;Location4&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location4("", n))); } [Benchmark] public bool Path_Position_DefaultEquality() { var first = new Location1("", 0); return _locations1.Contains(first); } [Benchmark] public bool Position_Path_DefaultEquality() { var first = new Location2("", 0); return _locations2.Contains(first); } [Benchmark] public bool Path_Position_OverridenEquality() { var first = new Location3("", 0); return _locations3.Contains(first); }</span></span></code> </pre> <br><br><pre> <code class="cs hljs"> Method | NumOfElements | Mean | Gen <span class="hljs-number"><span class="hljs-number">0</span></span> | Allocated | -------------------------------- |------ |--------------:|--------:|----------:| Path_Position_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1</span></span> | <span class="hljs-number"><span class="hljs-number">885.63</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0286</span></span> | <span class="hljs-number"><span class="hljs-number">92</span></span> B | Position_Path_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1</span></span> | <span class="hljs-number"><span class="hljs-number">127.80</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0050</span></span> | <span class="hljs-number"><span class="hljs-number">16</span></span> B | Path_Position_OverridenEquality | <span class="hljs-number"><span class="hljs-number">1</span></span> | <span class="hljs-number"><span class="hljs-number">47.99</span></span> ns | - | <span class="hljs-number"><span class="hljs-number">0</span></span> B | Path_Position_DefaultEquality | <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">214.02</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.2441</span></span> | <span class="hljs-number"><span class="hljs-number">776</span></span> B | Position_Path_DefaultEquality | <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">130.04</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0050</span></span> | <span class="hljs-number"><span class="hljs-number">16</span></span> B | Path_Position_OverridenEquality | <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">47.67</span></span> ns | - | <span class="hljs-number"><span class="hljs-number">0</span></span> B | Path_Position_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1000</span></span> | <span class="hljs-number"><span class="hljs-number">589</span></span>,<span class="hljs-number"><span class="hljs-number">014.52</span></span> ns | <span class="hljs-number"><span class="hljs-number">23.4375</span></span> | <span class="hljs-number"><span class="hljs-number">76025</span></span> B | Position_Path_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1000</span></span> | <span class="hljs-number"><span class="hljs-number">133.74</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0050</span></span> | <span class="hljs-number"><span class="hljs-number">16</span></span> B | Path_Position_OverridenEquality | <span class="hljs-number"><span class="hljs-number">1000</span></span> | <span class="hljs-number"><span class="hljs-number">48.51</span></span> ns | - | <span class="hljs-number"><span class="hljs-number">0</span></span> B |</code> </pre> <br> 如果第一个字段的值始终相同，则默认情况下，哈希函数对所有元素返回相等的值，并且哈希集通过O（N）插入和搜索操作有效地转换为链接列表。 填充集合的操作数变为O（N ^ 2）（其中N是每个插入的复杂度为O（N）的插入数）。 这意味着将其插入到1000个元素集中将产生对<code>ValueType.Equals</code>近500,000次调用。 这是使用反射方法的后果！ <br><br> 如测试所示，如果您幸运并且结构的第一个元素是唯一的（对于<code>Position_Path_DefaultEquality</code> ），则性能可以接受。 但是，如果不是这样，那么生产率将非常低。 <br><br><h2> 真正的问题 </h2><br> 我想现在您可以猜到我最近遇到了什么问题。 几周前，我收到一条错误消息：我正在处理的应用程序的运行时间从10秒增加到60秒。 幸运的是，该报告非常详细，并且包含Windows事件的痕迹，因此很快发现了问题点<code>ValueType.Equals</code>加载了50秒。 <br><br> 快速查看代码后，很清楚问题出在哪里： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HashSet&lt;(ErrorLocation, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)&gt; _locationsWithHitCount; <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ErrorLocation { <span class="hljs-comment"><span class="hljs-comment">// Empty almost all the time public string OptionalDescription { get; } public string Path { get; } public int Position { get; } }</span></span></code> </pre> <br> 我使用了一个包含自定义结构类型和标准版本<code>Equals</code>的元组。 不幸的是，它有一个可选的第一字段，几乎总是等于<code>String.equals</code> 。 生产率一直很高，直到集合中的元素数量显着增加。 在短短的几分钟内，就初始化了一个包含成千上万个元素的集合。 <br><br><h2> 默认的<code>ValueType.Equals/GetHashCode</code>实现是否总是运行缓慢？ </h2><br>  <code>ValueType.Equals</code>和<code>ValueType.GetHashCode</code>都有特殊的优化方法。 如果类型没有“指针”并且已正确包装（我将在稍后显示示例），则使用优化版本：对实例块执行<code>GetHashCode</code>迭代，使用4字节的XOR， <code>Equals</code>方法使用<code>memcmp</code>比较两个实例。 <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Optimized ValueType.GetHashCode implementation static INT32 FastGetValueTypeHashCodeHelper(MethodTable *mt, void *pObjRef) { INT32 hashCode = 0; INT32 *pObj = (INT32*)pObjRef; // this is a struct with no refs and no "strange" offsets, just go through the obj and xor the bits INT32 size = mt-&gt;GetNumInstanceFieldBytes(); for (INT32 i = 0; i &lt; (INT32)(size / sizeof(INT32)); i++) hashCode ^= *pObj++; return hashCode; } // Optimized ValueType.Equals implementation FCIMPL2(FC_BOOL_RET, ValueTypeHelper::FastEqualsCheck, Object* obj1, Object* obj2) { TypeHandle pTh = obj1-&gt;GetTypeHandle(); FC_RETURN_BOOL(memcmp(obj1-&gt;GetData(), obj2-&gt;GetData(), pTh.GetSize()) == 0); }</span></span></code> </pre> <br> 该检查本身在<code>ValueTypeHelper::CanCompareBits</code>执行，从<code>ValueType.Equals</code>的迭代和<code>ValueType.Equals</code>的迭代中调用。 <br><br> 但是优化是一件非常隐蔽的事情。 <br><br> 首先，很难理解它何时打开。 即使对代码进行很小的更改也可以将其打开和关闭： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Case1 { <span class="hljs-comment"><span class="hljs-comment">// Optimization is "on", because the struct is properly "packed" public int X { get; } public byte Y { get; } } public struct Case2 { // Optimization is "off", because struct has a padding between byte and int public byte Y { get; } public int X { get; } }</span></span></code> </pre> <br> 有关内存结构的更多信息，请参见我的博客<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“托管对象的内部元素，第4部分</a> 。 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">字段结构”</a> 。 <br><br> 其次，比较内存并不一定会得到正确的结果。 这是一个简单的示例： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> MyDouble { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> Value { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyDouble</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> =&gt; Value = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d1 = <span class="hljs-number"><span class="hljs-number">-0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d2 = +<span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// True bool b1 = d1.Equals(d2); // False! bool b2 = new MyDouble(d1).Equals(new MyDouble(d2));</span></span></code> </pre> <br>  <code>-0,0</code>和<code>+0,0</code>相等，但是具有不同的二进制表示形式。 这意味着<code>Double.Equals</code>为true，而<code>MyDouble.Equals</code>为false。 在大多数情况下，差异并不大，但请想象一下您将花费多少小时来解决由该差异引起的问题。 <br><br><h2> 如何避免类似的问题？ </h2><br> 您能问我在现实情况下上述情况如何发生吗？ 在结构类型中运行<code>Equals</code>和<code>GetHashCode</code>方法的一种明显方法是使用FxCop <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CA1815规则</a> 。 但是有一个问题：这太严格了。 <br><br> 对于性能至关重要的应用程序可以具有数百个结构类型，这些结构类型不一定在哈希集或字典中使用。 因此，应用程序开发人员可以禁用该规则，如果结构类型使用修改后的功能，则将导致不愉快的后果。 <br><br> 一种更正确的方法是，如果将具有（在应用程序或第三方库中定义的）元素默认值相同的“不适当”类型结构存储在哈希集中，则警告开发人员。 当然，我谈论的是<a href="">ErrorProne.NET</a>以及我遇到此问题后在其中添加的规则： <br><br><img src="https://habrastorage.org/webt/fx/dp/2u/fxdp2u0isbov-7e2vh0stw70x2m.png"><br><br>  ErrorProne.NET版本并不完美，如果在构造函数中使用了自定义的相等解析器，则会“怪罪”正确的代码： <br><br><img src="https://habrastorage.org/webt/9b/16/0p/9b160peycjwrjmiblktkuroajk0.png"><br><br> 但我仍然认为，如果在生成时默认不使用具有相等元素的结构，则值得警告。 例如，当我检查规则时，我意识到mscorlib中定义的<code>System.Collections.Generic.KeyValuePair &lt;TKey, TValue&gt;</code>结构不会覆盖<code>Equals</code>和<code>GetHashCode</code> 。 今天不太可能有人会定义像<code>HashSet &lt;KeyValuePair&lt;string, int&gt;&gt;</code>这样的变量，但是我相信，即使BCL也会违反规则。 因此，在为时已晚之前发现它很有用。 <br><br><h2> 结论 </h2><br><ul><li> 实现结构类型的默认相等性可能会对您的应用程序造成严重后果。 这是一个实际的问题，而不是理论问题。 </li><li> 值类型的默认相等元素基于反射。 </li><li> 如果许多实例的第一个字段具有相同的值，则由标准版本的<code>GetHashCode</code>执行的分发将非常糟糕。 </li><li> 标准<code>Equals</code>和<code>GetHashCode</code>方法有优化的版本，但您不应依赖它们，因为即使很小的代码更改也可以将其关闭。 </li><li> 使用FxCop规则确保每个结构类型都覆盖均等元素。 但是，如果将“不合适的”结构存储在哈希集或哈希表中，则最好防止分析器出现问题。 </li></ul><br><h2> 其他资源 </h2><br><ul><li>  <a href="">GitHub上的ErrorProne.NET</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">商店中的ErrorProne.NET结构</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN418515/">https://habr.com/ru/post/zh-CN418515/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN418503/index.html">2020年后，英国将获得第一个太空港-苏格兰</a></li>
<li><a href="../zh-CN418505/index.html">门级量子软件平台的概述和比较</a></li>
<li><a href="../zh-CN418507/index.html">宇宙航行给了我们什么？</a></li>
<li><a href="../zh-CN418509/index.html">亚马逊承认承认28名美国国会议员为罪犯</a></li>
<li><a href="../zh-CN418513/index.html">如何只写好的代码</a></li>
<li><a href="../zh-CN418517/index.html">代码覆盖率：如何提高测试质量</a></li>
<li><a href="../zh-CN418519/index.html">在别人的代码中可以找到什么？ .NET的一些有用的材料</a></li>
<li><a href="../zh-CN418521/index.html">从阿拉斯加发射升空的秘密面纱</a></li>
<li><a href="../zh-CN418523/index.html">零售商为什么要“倾听”他们的员工，为什么他们仍然使用音频技术</a></li>
<li><a href="../zh-CN418525/index.html">歌剧公开</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>