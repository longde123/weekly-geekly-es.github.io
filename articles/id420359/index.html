<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍟 🛠️ 🤹🏾 Var, biarkan atau const? Masalah Lingkup Variabel dan ES6 👩🏿 🕺🏻 👨🏿‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lingkup dalam JavaScript selalu menjadi topik yang rumit, terutama bila dibandingkan dengan bahasa yang lebih ketat seperti C dan Java. Selama bertahu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Var, biarkan atau const? Masalah Lingkup Variabel dan ES6</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/420359/"> Lingkup dalam JavaScript selalu menjadi topik yang rumit, terutama bila dibandingkan dengan bahasa yang lebih ketat seperti C dan Java.  Selama bertahun-tahun, ruang lingkup JS tidak terlalu banyak dibahas, karena bahasa tersebut tidak memiliki sarana yang secara signifikan akan mempengaruhi situasi saat ini.  Tetapi dalam ECMAScript 6 ada beberapa fitur baru yang memungkinkan pengembang untuk lebih mengontrol ruang lingkup variabel.  Fitur-fitur ini sekarang sangat didukung oleh browser, mereka cukup dapat diakses oleh sebagian besar pengembang.  Namun, kata kunci baru untuk mendeklarasikan variabel, dengan mempertimbangkan fakta bahwa kata kunci <code>var</code> lama belum hilang, berarti tidak hanya peluang baru, tetapi juga munculnya pertanyaan baru.  Kapan harus menggunakan kata kunci <code>let</code> dan <code>const</code> ?  Bagaimana mereka berperilaku?  Dalam situasi apa kata kunci <code>var</code> masih relevan?  Bahan, terjemahan yang kami terbitkan hari ini, bertujuan untuk mengeksplorasi masalah ruang lingkup variabel dalam JavaScript. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/v4/6q/as/v46qas_2e_rx9sypmgyz4trnhr0.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Lingkup Variabel: Tinjauan</font> </h2><br>  Ruang lingkup variabel adalah konsep penting dalam pemrograman, yang, bagaimanapun, dapat membingungkan beberapa pengembang, terutama pemula.  Lingkup suatu variabel adalah bagian dari program tempat variabel ini dapat diakses. <br><br>  Lihatlah contoh berikut: <br><br><pre> <code class="hljs matlab">var myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMyVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myVar</span></span></span><span class="hljs-function"> = 2; } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMyVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(myVar)</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>  Apa yang akan dihasilkan oleh metode <code>console.log</code> ?  Jawaban untuk pertanyaan ini tidak akan mengejutkan siapa pun: itu akan menghasilkan <code>2</code> .  Variabel <code>myVar</code> dideklarasikan di luar fungsi, yang memberitahu kita bahwa itu dinyatakan dalam lingkup global.  Oleh karena itu, fungsi apa pun yang dideklarasikan dalam cakupan yang sama akan dapat mengakses <code>myVar</code> .  Bahkan, ketika datang ke kode dieksekusi di browser, bahkan fungsi yang dideklarasikan dalam file lain yang terhubung ke halaman akan memiliki akses ke variabel ini. <br><br>  Sekarang lihat kode berikut: <br><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMyVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">var</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myVar</span></span></span><span class="hljs-function"> = 2; } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMyVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(myVar)</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>  Secara lahiriah, perubahannya, dibandingkan dengan contoh sebelumnya, tidak signifikan.  Yaitu, kita hanya meletakkan deklarasi variabel di dalam fungsi.  Apa yang akan menghasilkan <code>console.log</code> sekarang?  Pada kenyataannya, tidak ada, karena variabel ini tidak dideklarasikan dan ketika Anda mencoba mengaksesnya, pesan tentang kesalahan <code>ReferenceError</code> tidak ditangani akan ditampilkan.  Itu terjadi karena variabel dinyatakan di dalam fungsi menggunakan kata kunci <code>var</code> .  Akibatnya, ruang lingkup variabel ini terbatas pada ruang lingkup fungsi.  Dapat diakses di tubuh fungsi ini, fungsi yang tertanam dalam fungsi ini dapat bekerja dengannya, tetapi tidak dapat diakses dari luar.  Jika kita memerlukan beberapa fungsi pada level yang sama untuk menggunakan variabel tertentu, kita perlu mendeklarasikan variabel ini di tempat yang sama di mana fungsi-fungsi ini dideklarasikan, yaitu, satu tingkat lebih tinggi dari cakupan internal mereka. <br><br>  Berikut ini adalah satu pengamatan yang menarik: kode sebagian besar situs web dan aplikasi web tidak berlaku untuk pekerjaan salah satu programmer.  Sebagian besar proyek perangkat lunak adalah hasil dari pengembangan tim, dan di samping itu, mereka menggunakan perpustakaan dan kerangka kerja pihak ketiga.  Bahkan jika hanya satu programmer yang terlibat dalam pengembangan situs web, ia biasanya menggunakan sumber daya eksternal.  Karena itu, biasanya tidak disarankan untuk mendeklarasikan variabel dalam lingkup global, karena Anda tidak dapat mengetahui terlebih dahulu variabel mana yang akan dideklarasikan oleh pengembang lain yang kodenya akan digunakan dalam proyek.  Untuk mengatasi masalah ini, beberapa trik dapat digunakan, khususnya, pola " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Modul</a> " dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IIFE</a> ketika menerapkan pendekatan berorientasi objek untuk pengembangan JavaScript, meskipun enkapsulasi data dan fungsi dalam objek biasa dapat mencapai efek yang sama.  Secara umum, dapat dicatat bahwa variabel yang cakupannya melampaui apa yang mereka butuhkan biasanya merupakan masalah yang perlu dilakukan sesuatu. <br><br><h2>  <font color="#3AC1EF">Masalah kata kunci Var</font> </h2><br>  Jadi, kami menemukan konsep "ruang lingkup".  Sekarang mari kita beralih ke hal-hal yang lebih kompleks.  Lihatlah kode berikut: <br><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">varTest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(var i = 0; i &lt; 3; i++)</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function">; } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function">; } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">varTest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>  Apa yang akan sampai ke konsol setelah eksekusi?  Jelas bahwa nilai-nilai penghitung yang meningkat <code>i</code> : <code>0</code> , <code>1</code> dan <code>2</code> akan ditampilkan di dalam loop.  Setelah loop berakhir, program terus berjalan.  Sekarang kita mencoba mengakses variabel penghitung yang sama yang dideklarasikan dalam <code>for</code> loop, di luar loop ini.  Apa yang akan terjadi dengan ini? <br><br>  Setelah memanggil <code>i</code> luar loop, 3 akan masuk ke konsol, karena kata kunci <code>var</code> bertindak pada tingkat fungsi.  Jika Anda mendeklarasikan variabel menggunakan <code>var</code> , maka Anda dapat mengaksesnya dalam suatu fungsi bahkan setelah keluar dari konstruksi di mana ia dideklarasikan. <br><br>  Ini bisa berubah menjadi masalah ketika fungsi menjadi lebih kompleks.  Perhatikan contoh berikut: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) {   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myVar = <span class="hljs-number"><span class="hljs-number">2</span></span>;   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); } doSomething();</code> </pre> <br>  Apa yang akan sampai ke konsol sekarang?  <code>2</code> dan <code>2</code> .  Kami mendeklarasikan variabel, menginisialisasinya dengan angka 1, dan kemudian mencoba mendefinisikan kembali variabel yang sama di dalam <code>if</code> .  Karena dua deklarasi ini ada dalam cakupan yang sama, kami tidak dapat mendeklarasikan variabel baru dengan nama yang sama, meskipun kami jelas ingin melakukan hal itu.  Akibatnya, variabel pertama ditimpa di dalam <code>if</code> . <br><br>  Ini justru cacat terbesar dari kata kunci <code>var</code> .  Ruang lingkup variabel yang dinyatakan menggunakannya terlalu besar.  Hal ini dapat menyebabkan penulisan ulang data yang tidak disengaja dan kesalahan lainnya.  Area visibilitas yang luas sering kali mengarah pada program yang tidak akurat.  Secara umum, variabel harus memiliki ruang lingkup yang dibatasi oleh kebutuhannya, tetapi tidak melebihi mereka.  Akan menyenangkan untuk dapat mendeklarasikan variabel yang cakupannya tidak sebesar ketika menggunakan <code>var</code> , yang akan memungkinkan, jika perlu, untuk menggunakan konstruksi perangkat lunak yang lebih stabil dan lebih baik dari kesalahan.  Sebenarnya, ECMAScript 6 memberi kita peluang seperti itu. <br><br><h2>  <font color="#3AC1EF">Cara-cara baru untuk mendeklarasikan variabel</font> </h2><br>  Standar ECMAScript 6 (serangkaian fitur JavaScript baru, juga dikenal sebagai ES6 dan ES2015) memberi kita dua cara baru untuk mendeklarasikan variabel yang berbeda dalam cakupan, dibandingkan dengan <code>var</code> , dan memiliki beberapa fitur lainnya.  Ini adalah kata kunci <code>let</code> dan <code>const</code> .  Keduanya memberi kita apa yang disebut ruang lingkup blok.  Ini berarti bahwa ruang lingkup penggunaannya dapat dibatasi pada satu blok kode, seperti perulangan <code>for</code> atau <code>if</code> .  Ini memberi pengembang lebih banyak fleksibilitas dalam memilih ruang lingkup variabel.  Pertimbangkan kata kunci baru. <br><br><h3>  <font color="#3AC1EF">▍Gunakan kata kunci let</font> </h3><br>  Kata kunci <code>let</code> sangat mirip dengan <code>var</code> , perbedaan utamanya adalah lingkup variabel yang dideklarasikan dengannya terbatas.  Kami menulis ulang salah satu contoh di atas, menggantikan <code>var</code> dengan <code>let</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) {   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myVar = <span class="hljs-number"><span class="hljs-number">2</span></span>;   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); } doSomething();</code> </pre> <br>  Dalam hal ini, angka <code>2</code> dan <code>1</code> akan sampai ke konsol.  Ini terjadi karena <code>if</code> menetapkan ruang lingkup baru untuk variabel yang dideklarasikan dengan kata kunci <code>let</code> .  Ini mengarah pada fakta bahwa variabel yang dideklarasikan kedua adalah entitas yang sepenuhnya independen, tidak terkait dengan yang pertama.  Anda dapat bekerja dengan mereka secara independen satu sama lain.  Namun, ini tidak berarti bahwa blok kode bersarang, seperti <code>if</code> kami, benar-benar terputus dari variabel yang dideklarasikan dengan kata kunci <code>let</code> dalam lingkup di mana mereka sendiri berada.  Lihatlah kode berikut: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); } } doSomething();</code> </pre> <br>  Dalam contoh ini, konsol akan mendapatkan nomor <code>1</code> .  Kode di dalam <code>if</code> memiliki akses ke variabel yang kami buat di luarnya.  Oleh karena itu, ini menampilkan nilainya di konsol.  Dan apa yang terjadi jika Anda mencoba untuk mencampur ruang lingkup?  Sebagai contoh, lakukan ini: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar);   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myVar = <span class="hljs-number"><span class="hljs-number">2</span></span>;   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); } } doSomething();</code> </pre> <br>  Tampaknya panggilan pertama ke <code>console.log</code> akan menghasilkan <code>1</code> , tetapi pada kenyataannya, ketika Anda mencoba untuk mengeksekusi kode ini, kesalahan <code>ReferenceError</code> akan muncul yang memberi tahu kita bahwa variabel <code>myVar</code> untuk lingkup ini tidak ditentukan atau tidak diinisialisasi (teks kesalahan ini berbeda dalam berbagai browser).  Dalam JavaScript, ada yang namanya menaikkan variabel ke bagian atas cakupannya.  Artinya, jika suatu variabel dideklarasikan dalam lingkup tertentu, JavaScript menyediakan tempat untuk itu bahkan sebelum perintah untuk menyatakannya dijalankan.  Bagaimana tepatnya hal ini terjadi berbeda ketika menggunakan <code>var</code> dan <code>let</code> . <br><br>  Perhatikan contoh berikut: <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(varTest); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> varTest = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(letTest); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> letTest = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br>  Dalam kedua kasus, kami mencoba menggunakan variabel sebelum mendeklarasikannya.  Tetapi perintah output konsol berperilaku berbeda.  Yang pertama, menggunakan variabel yang nantinya akan dideklarasikan menggunakan kata kunci <code>var</code> , akan menghasilkan output yang <code>undefined</code> - yaitu, apa yang akan ditulis ke variabel ini.  Perintah kedua, yang mencoba mengakses variabel, yang nantinya akan dideklarasikan menggunakan kata kunci <code>let</code> , akan melempar <code>ReferenceError</code> dan memberi tahu kami bahwa kami mencoba menggunakan variabel sebelum dideklarasikan atau diinisialisasi.  Ada apa? <br><br>  Dan masalahnya di sini adalah bahwa sebelum kode dijalankan, mekanisme yang bertanggung jawab untuk pelaksanaannya melihat kode ini, mencari tahu apakah ada variabel yang akan dideklarasikan di dalamnya, dan, jika demikian, tingkatkan dengan reservasi ruang untuk mereka.  Dalam hal ini, variabel yang dideklarasikan menggunakan kata kunci <code>var</code> diinisialisasi untuk <code>undefined</code> dalam ruang lingkupnya, bahkan jika mereka diakses sebelum dideklarasikan.  Masalah utama di sini adalah bahwa nilai yang <code>undefined</code> dalam suatu variabel tidak selalu menunjukkan bahwa mereka mencoba menggunakan variabel sebelum deklarasi.  Lihatlah contoh berikut: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> var1; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(var1); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(var2); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> var2 = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Dalam hal ini, meskipun <code>var1</code> dan <code>var2</code> dideklarasikan secara berbeda, kedua panggilan ke <code>console.log</code> akan menghasilkan keluaran yang <code>undefined</code> .  Intinya di sini adalah bahwa dalam variabel yang dideklarasikan dengan <code>var</code> , tetapi tidak diinisialisasi, nilai <code>undefined</code> secara otomatis ditulis.  Pada saat yang sama, seperti yang telah kami katakan, variabel yang dideklarasikan menggunakan <code>var</code> , yang diakses sebelum dideklarasikan, juga mengandung <code>undefined</code> .  Akibatnya, jika terjadi kesalahan dalam kode tersebut, tidak mungkin untuk memahami apa sebenarnya sumber kesalahan - menggunakan variabel yang tidak diinisialisasi atau menggunakan variabel sebelum deklarasi. <br><br>  Tempat untuk variabel yang dideklarasikan dengan kata kunci <code>let</code> dicadangkan di blok mereka, tetapi, sebelum mereka dinyatakan, mereka jatuh ke zona mati sementara (TDZ, Zona Mati Temporal).  Ini mengarah pada fakta bahwa mereka tidak dapat digunakan sebelum dideklarasikan, dan upaya untuk mengakses variabel semacam itu mengarah pada kesalahan.  Namun, sistem tahu persis penyebab masalahnya dan melaporkannya.  Ini terlihat jelas dalam contoh ini: <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> var1; console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(var1); console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(var2); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> var2 = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Di sini, panggilan pertama ke <code>console.log</code> akan menampilkan <code>undefined</code> , dan yang kedua akan melemparkan kesalahan <code>ReferenceError</code> , memberi tahu kami bahwa variabel belum dideklarasikan atau diinisialisasi. <br><br>  Akibatnya, jika menggunakan <code>var</code> tampak <code>undefined</code> , kami tidak tahu alasan perilaku program ini.  Variabel dapat dideklarasikan dan tidak diinisialisasi, atau mungkin belum dinyatakan dalam lingkup ini, tetapi akan dinyatakan dalam kode yang terletak di bawah perintah untuk mengaksesnya.  Dengan menggunakan kata kunci <code>let</code> , kita dapat memahami apa yang sebenarnya terjadi, yang jauh lebih berguna untuk debugging. <br><br><h3>  <font color="#3AC1EF">▍Gunakan kata kunci const</font> </h3><br>  Kata kunci <code>const</code> sangat mirip dengan <code>let</code> , tetapi mereka memiliki satu perbedaan penting.  Kata kunci ini digunakan untuk mendeklarasikan konstanta.  Nilai konstanta tidak dapat diubah setelah inisialisasi mereka.  Perlu dicatat bahwa ini hanya berlaku untuk nilai tipe primitif, air, string atau angka.  Jika konstanta adalah sesuatu yang lebih kompleks, misalnya, sebuah objek atau array, struktur internal dari entitas seperti itu dapat dimodifikasi, Anda tidak bisa hanya menggantinya dengan yang lain.  Lihatlah kode berikut: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">let</span></span> mutableVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">const</span></span> immutableVar = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">mutableVar</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">immutableVar</span></span> = <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre> <br>  Kode ini akan dieksekusi hingga baris terakhir.  Mencoba untuk menetapkan nilai baru ke konstanta akan menghasilkan kesalahan <code>TypeError</code> .  Ini adalah bagaimana konstanta berperilaku, tetapi, seperti telah disebutkan, objek yang diinisialisasi oleh konstanta dapat diubah, mereka dapat mengalami mutasi, yang dapat menyebabkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kejutan</a> . <br><br>  Mungkin Anda, sebagai pengembang JavaScript, bertanya-tanya mengapa kekebalan variabel penting.  Konstanta adalah fenomena baru dalam JavaScript, sementara konstanta adalah bagian penting dari bahasa seperti C atau Java.  Mengapa konsep ini begitu populer?  Faktanya adalah bahwa menggunakan konstanta membuat kita berpikir tentang cara kerja kode kita.  Dalam beberapa situasi, mengubah nilai variabel dapat mengganggu kode, misalnya, jika nomor Pi ditulis di dalamnya dan itu selalu diakses, atau jika variabel memiliki tautan ke elemen HTML yang Anda perlu bekerja dengan terus-menerus.  Katakanlah, ini adalah konstanta di mana tautan ke tombol tertentu ditulis: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myButton = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'#my-button'</span></span>);</code> </pre> <br>  Jika kode bergantung pada tautan ke elemen HTML, maka kami perlu memastikan keabadian tautan ini.  Sebagai hasilnya, kita dapat mengatakan bahwa kata kunci <code>const</code> tidak hanya berjalan di sepanjang jalur peningkatan di bidang visibilitas, tetapi juga di sepanjang jalur membatasi kemungkinan memodifikasi nilai-nilai konstanta yang dinyatakan menggunakan kata kunci ini.  Ingat bagaimana kita mengatakan bahwa suatu variabel harus memiliki ruang lingkup yang dibutuhkannya.  Gagasan ini dapat dilanjutkan dengan mengedepankan rekomendasi, yang menurutnya suatu variabel seharusnya hanya memiliki kemampuan untuk berubah, yang diperlukan untuk pekerjaan yang tepat dengannya, dan tidak lebih.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berikut ini adalah</a> bahan yang baik tentang topik kekebalan, dari mana kesimpulan penting dapat diambil, yang dengannya penggunaan variabel tidak berubah membuat kita berpikir dengan hati-hati tentang kode kita, yang mengarah pada peningkatan kemurnian kode dan pada pengurangan jumlah kejutan tidak menyenangkan yang muncul selama operasinya. <br><br>  Ketika saya pertama kali mulai menggunakan kata kunci <code>let</code> dan <code>const</code> , pada dasarnya saya menggunakan <code>let</code> , menggunakan <code>const</code> hanya ketika menulis nilai baru ke variabel yang dideklarasikan dengan <code>let</code> dapat merusak program.  Tapi, belajar lebih banyak tentang pemrograman, saya berubah pikiran tentang hal ini.  Sekarang alat utama saya adalah <code>const</code> , dan <code>let</code> saya menggunakannya hanya ketika nilai variabel perlu ditulis ulang.  Ini membuat saya berpikir apakah benar-benar perlu mengubah nilai variabel tertentu.  Dalam kebanyakan kasus, ini tidak perlu. <br><br><h2>  <font color="#3AC1EF">Apakah kita memerlukan kata kunci var?</font> </h2><br>  Kata kunci <code>let</code> dan <code>const</code> berkontribusi pada pendekatan pemrograman yang lebih bertanggung jawab.  Apakah ada situasi di mana kata kunci <code>var</code> masih diperlukan?  Ya ada.  Ada beberapa situasi di mana kata kunci ini masih berguna bagi kami.  Pertimbangkan dengan seksama apa yang akan kita bicarakan sebelum mengubah <code>var</code> menjadi <code>let</code> atau <code>const</code> . <br><br><h3>  <font color="#3AC1EF">▍ Tingkat dukungan kata kunci Var oleh browser</font> </h3><br>  Variabel yang dideklarasikan dengan kata kunci <code>var</code> memiliki satu fitur yang sangat penting yang <code>let</code> dan kekurangannya.  Yaitu, kita berbicara tentang fakta bahwa benar-benar semua browser mendukung kata kunci ini.  Meskipun dukungan untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">let</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">const oleh</a> browser sangat bagus, namun, ada risiko bahwa program Anda akan berakhir di browser yang tidak mendukungnya.  Untuk memahami konsekuensi dari insiden semacam itu, Anda perlu mempertimbangkan bagaimana browser menangani kode JavaScript yang tidak didukung, sebagai lawan, misalnya, bagaimana mereka bereaksi terhadap kode CSS yang tidak mereka mengerti. <br><br>  Jika browser tidak mendukung beberapa fitur CSS, maka ini pada dasarnya mengarah ke beberapa distorsi dari apa yang akan ditampilkan di layar.  Situs di peramban yang tidak mendukung gaya apa pun yang digunakan oleh situs tidak akan terlihat seperti yang diharapkan, tetapi kemungkinan besar dapat digunakan.  Jika Anda menggunakan, misalnya, <code>let</code> , dan browser tidak mendukung kata kunci ini, maka kode JS Anda tidak akan berfungsi di sana.  Tidak akan - itu saja.  Mengingat bahwa JavaScript adalah salah satu komponen penting dari web modern, ini dapat menjadi masalah serius jika Anda memerlukan program Anda untuk bekerja di browser yang sudah ketinggalan zaman. <br><br>  Ketika orang berbicara tentang dukungan browser untuk situs, mereka biasanya bertanya di browser mana situs akan bekerja secara optimal.  Jika kita berbicara tentang situs yang fungsinya didasarkan pada penggunaan <code>let</code> dan <code>const</code> , maka pertanyaan serupa harus diajukan secara berbeda: "Di browser mana situs kita tidak akan berfungsi?".  Dan ini jauh lebih serius daripada berbicara tentang apakah menggunakan <code>display: flex</code> atau tidak.  Untuk sebagian besar situs web, jumlah pengguna dengan browser yang usang tidak akan cukup besar untuk dikhawatirkan.  Namun, jika kita berbicara tentang sesuatu seperti toko online, atau situs yang pemiliknya membeli iklan, ini bisa menjadi pertimbangan yang sangat penting.  Sebelum menggunakan peluang baru dalam proyek semacam itu, nilai tingkat risiko. <br><br>  Jika Anda perlu mendukung browser yang sangat lama, tetapi Anda ingin menggunakan fitur <code>let</code> , <code>const</code> , dan ES6 baru lainnya, salah satu solusi untuk masalah ini adalah dengan menggunakan transporter JavaScript seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Babel</a> .  Transpiler memberikan terjemahan kode baru ke dalam apa yang browser lama akan mengerti.  Menggunakan Babel, Anda dapat menulis kode modern yang menggunakan fitur bahasa terbaru, dan kemudian mengubahnya menjadi kode yang dapat dijalankan oleh browser lama. <br><br>   ,   ?   ,        . ,      ,     ,     ,   .  ,   .  ,      ,      .     ES6-,     Babel,   Babel   ,      ,   .      ,      ,      .     .     ?   -  IE8     ? ,           ,  ,   ,  ,     . <br><br><h3> <font color="#3AC1EF">▍ var     </font> </h3><br>    ,     <code>var</code>  ,    .    .   : <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myVar = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ,     myVar    ! }</span></span></code> </pre> <br> ,     <code>myVar</code>    ,      ,        .  ,         .     ,    , ,    ,      .     ,        .        <code>var</code> . <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myVar = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); <span class="hljs-comment"><span class="hljs-comment">// 2 console.log(window.myVar); // 1 }</span></span></code> </pre> <br>          <code>var</code> ,       <code>window</code> .   <code>let</code>  <code>const</code>   .       ,     JS-   ,          (,  ,     )  ,     . <br><br>  ,         .       ,           .    ,  ,   ,    : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myGlobalVars = {}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; myGlobalVars.myVar = myVar; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myVar = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); <span class="hljs-comment"><span class="hljs-comment">// 2 console.log(myGlobalVars.myVar); // 1 }</span></span></code> </pre> <br> ,     ,     ,      , .   ,  ,      <code>var</code>  , ,     ,   ,  ,   . <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br> ,  ?   ?      : <br><br><ul><li>    IE10  -  ?              —       <code>var</code> . </li><li>         JavaScript,    ,  ,      <code>var</code> ,  <code>const</code> .  -      (,      ,        ) —  <code>let</code> . </li></ul><br>    <code>let</code>  <code>const</code> ,   ECMAScript 6,           ( )   -  -.       ,    ,       ,    . ,    - ,    «»  «»     , ,  <code>let</code>  <code>const</code> ,          . <br><br> <b> !</b>     ,       <code>const</code>       <code>var</code> ,   <code>let</code>    ,   ,   ,  ? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id420359/">https://habr.com/ru/post/id420359/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id420349/index.html">Daftar periksa outsourcing IT: bekerja tanpa risiko</a></li>
<li><a href="../id420351/index.html">Cara melakukan pencarian pengguna di GitHub menggunakan Vue</a></li>
<li><a href="../id420353/index.html">Kami menjadikan Shrimp lebih bermanfaat: menambahkan transcoding gambar ke format lain</a></li>
<li><a href="../id420355/index.html">Smart watch Pebble: bagaimana menjadi langka dalam semalam</a></li>
<li><a href="../id420357/index.html">Vuex: menyusun proyek-proyek besar dan bekerja dengan modul</a></li>
<li><a href="../id420361/index.html">Bug saat menjalankan TextBox.GetLineText di .NET WPF</a></li>
<li><a href="../id420363/index.html">Webinar HPE pada Agustus-Oktober: topik baru (+ SHD, praktik AI, penyimpanan turnkey petabyte)</a></li>
<li><a href="../id420367/index.html">Kiamat ber-AC: skenario smart grid blackout</a></li>
<li><a href="../id420369/index.html">Extreme Extended Edge, atau Switching IEEE 802.1BR</a></li>
<li><a href="../id420371/index.html">Pada masalah konstruksi sepeda di bidang penyimpanan surat listrik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>