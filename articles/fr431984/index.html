<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëäüèΩ ‚úãüèΩ ü§∏ Interface de g√©n√©ration de client bas√©e sur la base de donn√©es Golang üöá ‚¨úÔ∏è üçÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="G√©n√©rateur de client de base de donn√©es Golang bas√© sur l'interface. 





 Pour travailler avec des bases de donn√©es, Golang propose le package datab...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Interface de g√©n√©ration de client bas√©e sur la base de donn√©es Golang</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431984/"><p>  G√©n√©rateur de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">client de</a> base de donn√©es Golang bas√© sur l'interface. </p><br><p><img src="https://habrastorage.org/webt/jn/y8/f1/jny8f1pghqry-6htgynybbcufbi.png"></p><br><p> Pour travailler avec des bases de donn√©es, Golang propose le package <code>database/sql</code> , qui est une abstraction de l'interface de programmation de base de donn√©es relationnelle.  D'une part, le package comprend de puissantes fonctionnalit√©s pour g√©rer le pool de connexions, travailler avec des instructions pr√©par√©es, des transactions et l'interface de requ√™te de base de donn√©es.  D'autre part, vous devez √©crire une quantit√© consid√©rable du m√™me type de code dans une application Web pour interagir avec une base de donn√©es.  La biblioth√®que go-gad / sal propose une solution sous forme de g√©n√©ration du m√™me type de code bas√© sur l'interface d√©crite. </p><a name="habracut"></a><br><h2 id="motivation">  La motivation </h2><br><p>  Aujourd'hui, il existe un nombre suffisant de biblioth√®ques qui proposent des solutions sous la forme d'ORM, d'aides pour la cr√©ation de requ√™tes, de g√©n√©ration d'aides bas√©es sur un sch√©ma de base de donn√©es. </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/jmoiron/sqlx</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/go-reform/reform</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/jinzhu/gorm</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/Masterminds/squirrel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/volatiletech/sqlboiler</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/drone/sqlgen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/gocraft/dbr</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/go-gorp/gorp</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/doug-martin/goqu</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/src-d/go-kallax</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/go-pg/pg</a> </li></ul><br><p>  Lorsque je suis pass√© √† la langue Golang il y a plusieurs ann√©es, j'avais d√©j√† de l'exp√©rience avec des bases de donn√©es dans diff√©rentes langues.  Utiliser ORM, comme ActiveRecord, et sans.  Apr√®s √™tre pass√© de l'amour √† la haine, n'ayant aucun probl√®me √† √©crire quelques lignes de code suppl√©mentaires, l'interaction avec la base de donn√©es de Golang a abouti √† quelque chose comme un mod√®le de r√©f√©rentiel.  Nous d√©crivons l'interface pour travailler avec la base de donn√©es, nous l'impl√©mentons en utilisant la norme db.Query, row.Scan.  Utiliser des emballages suppl√©mentaires n'avait tout simplement pas de sens, c'√©tait opaque, cela obligerait √† √™tre en alerte. </p><br><p>  Le langage SQL lui-m√™me est d√©j√† une abstraction entre votre programme et les donn√©es du r√©f√©rentiel.  Il m'a toujours sembl√© illogique d'essayer de d√©crire un sch√©ma de donn√©es, puis de cr√©er des requ√™tes complexes.  Dans ce cas, la structure de r√©ponse est diff√©rente du sch√©ma de donn√©es.  Il s'av√®re que le contrat doit √™tre d√©crit non pas au niveau du sch√©ma de donn√©es, mais au niveau de la demande et de la r√©ponse.  Nous utilisons cette approche dans le d√©veloppement Web lorsque nous d√©crivons les structures de donn√©es des demandes et des r√©ponses d'API.  Lors de l'acc√®s au service en utilisant RESTful JSON ou gRPC, nous d√©clarons le contrat au niveau de la demande et de la r√©ponse en utilisant le sch√©ma JSON ou Protobuf, et non le sch√©ma de donn√©es des entit√©s √† l'int√©rieur des services. </p><br><p>  Autrement dit, l'interaction avec la base de donn√©es se r√©sumait √† une m√©thode similaire: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> User <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Store <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { FindUser(id <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>) (*User, error) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Postgres <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { DB *sql.DB } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pg *Postgres)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*User, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resp User err := pg.DB.QueryRow(<span class="hljs-string"><span class="hljs-string">"SELECT id, name FROM users WHERE id=$1"</span></span>, id).Scan(&amp;resp.ID, &amp;resp.Name) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;resp, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HanlderFindUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s Store, id </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*User, error)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// logic of service object user, err := s.FindUser(id) //... }</span></span></code> </pre> <br><p>  De cette fa√ßon, votre programme est pr√©visible.  Mais pour √™tre honn√™te, ce n'est pas le r√™ve d'un po√®te.  Nous voulons r√©duire la quantit√© de code standard pour composer une requ√™te, remplir des structures de donn√©es, utiliser la liaison de variables, etc.  J'ai essay√© de formuler une liste d'exigences auxquelles l'ensemble d'utilitaires souhait√© devrait satisfaire. </p><br><h2 id="requirements">  Pr√©requis </h2><br><ul><li>  Description de l'interaction sous forme d'interface. </li><li>  L'interface est d√©crite par des m√©thodes et des messages de demandes et de r√©ponses. </li><li>  Prise en charge des variables de liaison et des instructions pr√©par√©es. </li><li>  Prise en charge des arguments nomm√©s. </li><li>  Lier la r√©ponse de la base de donn√©es aux champs de la structure de donn√©es du message. </li><li>  Prise en charge des structures de donn√©es atypiques (array, json). </li><li>  Travail transparent avec les transactions. </li><li>  Prise en charge native du middleware. </li></ul><br><p>  Nous voulons r√©sumer l'impl√©mentation de l'interaction avec la base de donn√©es √† l'aide de l'interface.  Cela nous permettra d'impl√©menter quelque chose de similaire √† un mod√®le de conception tel qu'un r√©f√©rentiel.  Dans l'exemple ci-dessus, nous avons d√©crit l'interface Store.  Maintenant, nous pouvons l'utiliser comme d√©pendance.  Au stade du test, nous pouvons passer un stub g√©n√©r√© sur la base de cette interface, et dans le produit, nous utiliserons notre impl√©mentation bas√©e sur la structure Postgres. </p><br><p>  Chaque m√©thode d'interface d√©crit une requ√™te de base de donn√©es.  Les param√®tres d'entr√©e et de sortie de la m√©thode doivent faire partie du contrat de la demande.  La cha√Æne de requ√™te doit pouvoir √™tre format√©e en fonction des param√®tres d'entr√©e.  Cela est particuli√®rement vrai lors de la compilation de requ√™tes avec une condition d'√©chantillonnage complexe. </p><br><p>  Lors de la compilation d'une requ√™te, nous voulons utiliser la substitution et la liaison de variables.  Par exemple, dans PostgreSQL, vous √©crivez <code>$1</code> au lieu d'une valeur et, avec la requ√™te, passez un tableau d'arguments.  Le premier argument sera utilis√© comme valeur dans la requ√™te convertie.  La prise en charge des expressions pr√©par√©es vous permet de ne pas vous soucier d'organiser le stockage de ces m√™mes expressions.  La biblioth√®que de base de donn√©es / sql fournit un outil puissant pour prendre en charge les expressions pr√©par√©es; elle s'occupe elle-m√™me du pool de connexions, des connexions ferm√©es.  Mais de la part de l'utilisateur, une action suppl√©mentaire est n√©cessaire pour r√©utiliser l'expression pr√©par√©e dans la transaction. </p><br><p>  Les bases de donn√©es, telles que PostgreSQL et MySQL, utilisent une syntaxe diff√©rente pour utiliser des substitutions et des liaisons de variables.  PostgreSQL utilise le format <code>$1</code> , <code>$2</code> , ... MySQL utilise <code>?</code>  quel que soit l'emplacement de la valeur.  La biblioth√®que de base de donn√©es / sql a propos√© un format universel pour les arguments nomm√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://golang.org/pkg/database/sql/#NamedArg</a> .  Exemple d'utilisation: </p><br><pre> <code class="go hljs">db.ExecContext(ctx, <span class="hljs-string"><span class="hljs-string">`DELETE FROM orders WHERE created_at &lt; @end`</span></span>, sql.Named(<span class="hljs-string"><span class="hljs-string">"end"</span></span>, endTime))</code> </pre> <br><p>  La prise en charge de ce format est pr√©f√©rable √† utiliser par rapport aux solutions PostgreSQL ou MySQL. </p><br><p>  La r√©ponse de la base de donn√©es qui traite le pilote logiciel peut √™tre conditionnellement repr√©sent√©e comme suit: </p><br><pre> <code class="sql hljs">dev &gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> rubrics; id | created_at | title | url <span class="hljs-comment"><span class="hljs-comment">----+-------------------------+-------+------------ 1 | 2012-03-13 11:17:23.609 | Tech | technology 2 | 2015-07-21 18:05:43.412 | Style | fashion (2 rows)</span></span></code> </pre> <br><p>  Du point de vue de l'utilisateur au niveau de l'interface, il est commode de d√©crire le param√®tre de sortie comme un tableau de structures de la forme: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GetRubricsResp <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CreatedAt time.Time Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> URL <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> }</code> </pre> <br><p>  Ensuite, <code>resp.ID</code> valeur <code>id</code> sur <code>resp.ID</code> et ainsi de suite.  En g√©n√©ral, cette fonctionnalit√© couvre la plupart des besoins. </p><br><p>  Lors de la d√©claration de messages via des structures de donn√©es internes, la question se pose de savoir comment prendre en charge les types de donn√©es non standard.  Par exemple, un tableau.  Si vous utilisez le pilote github.com/lib/pq lorsque vous travaillez avec PostgreSQL, vous pouvez utiliser des fonctions auxiliaires comme <code>pq.Array(&amp;x)</code> lors du passage d'arguments de requ√™te ou de l'analyse d'une r√©ponse.  Exemple tir√© de la documentation: </p><br><pre> <code class="go hljs">db.Query(<span class="hljs-string"><span class="hljs-string">`SELECT * FROM t WHERE id = ANY($1)`</span></span>, pq.Array([]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">235</span></span>, <span class="hljs-number"><span class="hljs-number">401</span></span>})) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x []sql.NullInt64 db.QueryRow(<span class="hljs-string"><span class="hljs-string">'SELECT ARRAY[235, 401]'</span></span>).Scan(pq.Array(&amp;x))</code> </pre> <br><p>  En cons√©quence, il doit exister des moyens de pr√©parer des structures de donn√©es. </p><br><p>  Lors de l'ex√©cution de l'une des m√©thodes d'interface, une connexion √† la base de donn√©es peut √™tre utilis√©e sous la forme d'un <code>*sql.DB</code>  Si vous devez ex√©cuter plusieurs m√©thodes au sein d'une m√™me transaction, je souhaite utiliser une fonctionnalit√© transparente avec une approche similaire pour travailler en dehors d'une transaction, sans passer d'arguments suppl√©mentaires. </p><br><p>  Lorsque vous travaillez avec des impl√©mentations d'interface, il est essentiel pour nous de pouvoir int√©grer la bo√Æte √† outils.  Par exemple, consigner toutes les demandes.  La bo√Æte √† outils doit avoir acc√®s aux variables de demande, √† l'erreur de r√©ponse, √† l'ex√©cution et au nom de la m√©thode d'interface. </p><br><p>  Pour la plupart, les exigences ont √©t√© formul√©es comme une syst√©matisation des sc√©narios de base de donn√©es. </p><br><h2 id="solution-go-gadsal">  Solution: go-gad / sal </h2><br><p>  Une fa√ßon de g√©rer le code passe-partout est de le g√©n√©rer.  Heureusement, Golang a des outils et des exemples pour ce <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://blog.golang.org/generate</a> .  L'approche <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/golang/mock</a> de GoMock a √©t√© consid√©r√©e comme une solution architecturale pour la g√©n√©ration, o√π l'analyse d'interface est effectu√©e par r√©flexion.  Sur la base de cette approche, selon les exigences, l'utilitaire salgen et la biblioth√®que sal ont √©t√© √©crits, qui g√©n√®rent du code d'impl√©mentation d'interface et fournissent un ensemble de fonctions auxiliaires. </p><br><p>  Afin de commencer √† utiliser cette solution, il est n√©cessaire de d√©crire une interface qui d√©crit le comportement de la couche d'interaction avec la base de donn√©es.  Sp√©cifiez la directive <code>go:generate</code> avec un ensemble d'arguments et lancez la g√©n√©ration.  Vous obtiendrez un constructeur et un tas de code passe-partout, pr√™ts √† l'emploi. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> repo <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-comment"><span class="hljs-comment">//go:generate salgen -destination=./postgres_client.go -package=dev/taxi/repo dev/taxi/repo Postgres type Postgres interface { CreateDriver(ctx context.Context, r *CreateDriverReq) error } type CreateDriverReq struct { taxi.Driver } func (r *CreateDriverReq) Query() string { return `INSERT INTO drivers(id, name) VALUES(@id, @name)` }</span></span></code> </pre> <br><h4 id="interface">  Interface </h4><br><p>  Tout commence par d√©clarer l'interface et une commande sp√©ciale pour l'utilitaire <code>go generate</code> : </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//go:generate salgen -destination=./client.go -package=github.com/go-gad/sal/examples/profile/storage github.com/go-gad/sal/examples/profile/storage Store type Store interface { ...</span></span></code> </pre> <br><p>  Ici, il est d√©crit que pour notre interface <code>Store</code> , l'utilitaire de console <code>salgen</code> sera appel√© √† partir du package, avec deux options et deux arguments.  La premi√®re option <code>-destination</code> d√©termine dans quel fichier le code g√©n√©r√© sera √©crit.  La deuxi√®me option <code>-package</code> d√©finit le chemin complet (chemin d'importation) de la biblioth√®que pour l'impl√©mentation g√©n√©r√©e.  Voici deux arguments.  Le premier d√©crit le chemin complet du package ( <code>github.com/go-gad/sal/examples/profile/storage</code> ) o√π se trouve l'interface, le second indique le nom de l'interface elle-m√™me.  Notez que la commande <code>go generate</code> peut √™tre situ√©e n'importe o√π, pas n√©cessairement √† c√¥t√© de l'interface cible. </p><br><p>  Apr√®s avoir ex√©cut√© la commande <code>go generate</code> , nous obtenons un constructeur dont le nom est construit en ajoutant le <code>New</code> pr√©fixe au nom de l'interface.  Le constructeur prend un param√®tre requis correspondant √† l'interface <code>sal.QueryHandler</code> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> QueryHandler <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { QueryContext(ctx context.Context, query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, args ...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) (*sql.Rows, error) ExecContext(ctx context.Context, query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, args ...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) (sql.Result, error) PrepareContext(ctx context.Context, query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) (*sql.Stmt, error) }</code> </pre> <br><p>  Cette interface correspond √† l'objet <code>*sql.DB</code> </p><br><pre> <code class="go hljs">connStr := <span class="hljs-string"><span class="hljs-string">"user=pqgotest dbname=pqgotest sslmode=verify-full"</span></span> db, err := sql.Open(<span class="hljs-string"><span class="hljs-string">"postgres"</span></span>, connStr) client := storage.NewStore(db)</code> </pre> <br><h4 id="methods">  Les m√©thodes </h4><br><p>  Les m√©thodes d'interface d√©terminent l'ensemble des requ√™tes de base de donn√©es disponibles. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Store <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { CreateAuthor(ctx context.Context, req CreateAuthorReq) (CreateAuthorResp, error) GetAuthors(ctx context.Context, req GetAuthorsReq) ([]*GetAuthorsResp, error) UpdateAuthor(ctx context.Context, req *UpdateAuthorReq) error }</code> </pre> <br><ul><li>  Le nombre d'arguments est toujours strictement deux. </li><li>  Le premier argument est le contexte. </li><li>  Le deuxi√®me argument contient des donn√©es pour les variables de liaison et d√©finit la cha√Æne de requ√™te. </li><li>  Le premier param√®tre de sortie peut √™tre un objet, un tableau d'objets ou absent. </li><li>  Le dernier param√®tre de sortie est toujours une erreur. </li></ul><br><p>  Le premier argument est toujours l'objet <code>context.Context</code> .  Ce contexte sera transmis lors de l'appel de la base de donn√©es et de la bo√Æte √† outils.  Le deuxi√®me argument attend un param√®tre avec le type de <code>struct</code> (ou un pointeur vers <code>struct</code> ).  Le param√®tre doit satisfaire l'interface suivante: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Queryer <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Query() <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> }</code> </pre> <br><p>  La m√©thode <code>Query()</code> sera appel√©e avant d'ex√©cuter une requ√™te de base de donn√©es.  La cha√Æne r√©sultante sera convertie dans un format sp√©cifique √† la base de donn√©es.  Autrement dit, pour PostgreSQL, <code>@end</code> sera remplac√© par <code>$1</code> , et la valeur <code>&amp;req.End</code> sera transmise au tableau d'arguments </p><br><p>  En fonction des param√®tres de sortie, il est d√©termin√© laquelle des m√©thodes (Query / Exec) sera appel√©e: </p><br><ul><li>  Si le premier param√®tre est de type <code>struct</code> (ou un pointeur vers <code>struct</code> ), la m√©thode <code>QueryContext</code> sera appel√©e.  Si la r√©ponse de la base de donn√©es ne contient pas une seule ligne, l'erreur <code>sql.ErrNoRows</code> sera <code>sql.ErrNoRows</code> .  Autrement dit, le comportement est similaire √† <code>db.QueryRow</code> . </li><li>  Si le premier param√®tre est avec la <code>slice</code> type de base, la m√©thode <code>QueryContext</code> sera appel√©e.  Si la r√©ponse de la base de donn√©es ne contient pas de lignes, une liste vide sera retourn√©e.  Le type de base de l'√©l√©ment de liste doit √™tre <code>stuct</code> (ou un pointeur vers une <code>struct</code> ). </li><li>  Si le param√®tre de sortie est un avec le type d' <code>error</code> , la m√©thode <code>ExecContext</code> sera appel√©e. </li></ul><br><h4 id="prepared-statements">  D√©clarations pr√©par√©es </h4><br><p>  Le code g√©n√©r√© prend en charge les expressions pr√©par√©es.  Les expressions pr√©par√©es sont mises en cache.  Apr√®s la premi√®re pr√©paration de l'expression, elle est mise en cache.  La biblioth√®que de base de donn√©es / sql elle-m√™me garantit que les expressions pr√©par√©es sont appliqu√©es de mani√®re transparente √† la connexion de base de donn√©es souhait√©e, y compris le traitement des connexions ferm√©es.  √Ä son tour, la biblioth√®que <code>go-gad/sal</code> se charge de r√©utiliser l'instruction pr√©par√©e dans le contexte de la transaction.  Lorsque l'expression pr√©par√©e est ex√©cut√©e, les arguments sont transmis √† l'aide d'une liaison de variable, transparente pour le d√©veloppeur. </p><br><p>  Pour prendre en charge les arguments nomm√©s du c√¥t√© de la biblioth√®que <code>go-gad/sal</code> , la demande est convertie en une vue adapt√©e √† la base de donn√©es.  Il existe d√©sormais un support de conversion pour PostgreSQL.  Les noms de champ de l'objet de requ√™te sont utilis√©s pour se substituer aux arguments nomm√©s.  Pour sp√©cifier un nom diff√©rent au lieu du nom de champ d'objet, vous devez utiliser la balise <code>sql</code> pour les champs de structure.  Prenons un exemple: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> DeleteOrdersRequest <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { UserID <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"user_id"`</span></span> CreateAt time.Time <span class="hljs-string"><span class="hljs-string">`sql:"created_at"`</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r * DeleteOrdersRequest)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`DELETE FROM orders WHERE user_id=@user_id AND created_at&lt;@end`</span></span> }</code> </pre> <br><p>  La cha√Æne de requ√™te sera convertie et en utilisant la table de correspondance et la liaison de variable, une liste sera transmise aux arguments d'ex√©cution de la requ√™te: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// generated code: db.Query("DELETE FROM orders WHERE user_id=$1 AND created_at&lt;$2", &amp;req.UserID, &amp;req.CreatedAt)</span></span></code> </pre> <br><h4 id="map-structs-to-requests-arguments-and-response-messages">  Mapper les structures aux arguments de la requ√™te et aux messages de r√©ponse </h4><br><p>  La biblioth√®que <code>go-gad/sal</code> s'occupe d'associer les lignes de r√©ponse de la base de donn√©es aux structures de r√©ponse, les colonnes de table aux champs de structure: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GetRubricsReq <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r GetRubricReq)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`SELECT * FROM rubrics`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Rubric <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"id"`</span></span> CreateAt time.Time <span class="hljs-string"><span class="hljs-string">`sql:"created_at"`</span></span> Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"title"`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GetRubricsResp []*Rubric <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Store <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { GetRubrics(ctx context.Context, req GetRubricsReq) (GetRubricsResp, error) }</code> </pre> <br><p>  Et si la r√©ponse de la base de donn√©es est: </p><br><pre> <code class="sql hljs">dev &gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> rubrics; id | created_at | title <span class="hljs-comment"><span class="hljs-comment">----+-------------------------+------- 1 | 2012-03-13 11:17:23.609 | Tech 2 | 2015-07-21 18:05:43.412 | Style (2 rows)</span></span></code> </pre> <br><p>  Ensuite, la liste GetRubricsResp nous reviendra, dont les √©l√©ments seront des pointeurs vers Rubric, o√π les champs sont remplis avec des valeurs des colonnes qui correspondent aux noms des balises. </p><br><p>  Si la r√©ponse de la base de donn√©es contient des colonnes du m√™me nom, les champs de structure correspondants seront s√©lectionn√©s dans l'ordre de d√©claration. </p><br><pre> <code class="sql hljs">dev &gt; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rubrics, subrubrics; id | title | id | title <span class="hljs-comment"><span class="hljs-comment">----+-------+----+---------- 1 | Tech | 3 | Politics</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Rubric <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"id"`</span></span> Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"title"`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Subrubric <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"id"`</span></span> Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"title"`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GetCategoryResp <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Rubric Subrubric }</code> </pre> <br><h4 id="non-standard-data-types">  Types de donn√©es non standard </h4><br><p>  Le package <code>database/sql</code> en charge les types de donn√©es de base (cha√Ænes, nombres).  Afin de traiter des types de donn√©es tels que tableau ou json dans une demande ou une r√©ponse, il est n√©cessaire de prendre en charge les <code>sql.Scanner</code> <code>driver.Valuer</code> et <code>sql.Scanner</code> .  Diff√©rentes impl√©mentations de pilotes ont des fonctions d'assistance sp√©ciales.  Par exemple, <code>lib/pq.Array</code> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://godoc.org/github.com/lib/pq#Array</a> ): </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span> { driver.Valuer sql.Scanner }</code> </pre> <br><p>  Par d√©faut, la biblioth√®que <code>go-gad/sql</code> pour les champs de structure de vue </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> DeleteAuthrosReq <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Tags []<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"tags"`</span></span> }</code> </pre> <br><p>  utilisera la valeur <code>&amp;req.Tags</code> .  Si la structure satisfait l'interface <code>sal.ProcessRower</code> , </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ProcessRower <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { ProcessRow(rowMap RowMap) }</code> </pre> <br><p>  alors la valeur utilis√©e peut √™tre ajust√©e </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *DeleteAuthorsReq)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessRow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rowMap sal.RowMap)</span></span></span></span> { rowMap.Set(<span class="hljs-string"><span class="hljs-string">"tags"</span></span>, pq.Array(r.Tags)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *DeleteAuthorsReq)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`DELETE FROM authors WHERE tags=ANY(@tags::UUID[])`</span></span> }</code> </pre> <br><p>  Ce gestionnaire peut √™tre utilis√© pour les arguments de demande et de r√©ponse.  Dans le cas d'une liste dans la r√©ponse, la m√©thode doit appartenir √† l'√©l√©ment de liste. </p><br><h4 id="transactions">  Les transactions </h4><br><p>  Pour prendre en charge les transactions, l'interface (Store) doit √™tre √©tendue avec les m√©thodes suivantes: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Store <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { BeginTx(ctx context.Context, opts *sql.TxOptions) (Store, error) sal.Txer ...</code> </pre> <br><p>  L'impl√©mentation des m√©thodes sera g√©n√©r√©e.  La m√©thode <code>BeginTx</code> utilise la connexion de l'objet <code>sal.QueryHandler</code> actuel et ouvre la transaction <code>db.BeginTx(...)</code> ;  renvoie un nouvel objet d'impl√©mentation de l'interface <code>Store</code> , mais utilise l'objet <code>*sql.Tx</code> re√ßu comme <code>*sql.Tx</code> </p><br><h4 id="middleware">  Middleware </h4><br><p>  Des crochets sont fournis pour les outils d'int√©gration. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> BeforeQueryFunc <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, query </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, req </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context.Context, FinalizerFunc)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FinalizerFunc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, err error)</span></span></span></span></code> </pre> <br><p>  Le hook <code>BeforeQueryFunc</code> sera appel√© avant l' <code>db.PrepareContext</code> ou <code>db.Query</code> .  Autrement dit, au d√©but du programme, lorsque le cache d'expression pr√©par√© est vide, lorsque <code>store.GetAuthors</code> appel√©, le crochet <code>BeforeQueryFunc</code> sera appel√© deux fois.  Le hook <code>BeforeQueryFunc</code> peut renvoyer un hook <code>FinalizerFunc</code> , qui sera appel√© avant de quitter la m√©thode utilisateur, dans notre case <code>store.GetAuthors</code> , en utilisant <code>store.GetAuthors</code> . </p><br><p>  Au moment de l'ex√©cution des hooks, le contexte est rempli de cl√©s de service avec les valeurs suivantes: </p><br><ul><li>  <code>ctx.Value(sal.ContextKeyTxOpened)</code> valeur bool√©enne d√©termine si la m√©thode est appel√©e ou non dans le contexte de la transaction. </li><li>  <code>ctx.Value(sal.ContextKeyOperationType)</code> , la valeur de cha√Æne du type d'op√©ration, <code>"QueryRow"</code> , <code>"Query"</code> , <code>"Exec"</code> , <code>"Commit"</code> , etc. </li><li>  <code>ctx.Value(sal.ContextKeyMethodName)</code> valeur de cha√Æne de la m√©thode d'interface, telle que <code>"GetAuthors"</code> . </li></ul><br><p>  En tant qu'arguments, le hook <code>BeforeQueryFunc</code> accepte la cha√Æne sql de la requ√™te et l'argument <code>req</code> de la m√©thode de requ√™te utilisateur.  Le hook <code>FinalizerFunc</code> prend une variable <code>err</code> comme argument. </p><br><pre> <code class="go hljs">beforeHook := <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, query </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, req </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context.Context, sal.FinalizerFunc)</span></span></span></span> { start := time.Now() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ctx, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, err error)</span></span></span></span> { log.Printf( <span class="hljs-string"><span class="hljs-string">"%q &gt; Opeartion %q: %q with req %#v took [%v] inTx[%v] Error: %+v"</span></span>, ctx.Value(sal.ContextKeyMethodName), ctx.Value(sal.ContextKeyOperationType), query, req, time.Since(start), ctx.Value(sal.ContextKeyTxOpened), err, ) } } client := NewStore(db, sal.BeforeQuery(beforeHook))</code> </pre> <br><p>  Exemples de sortie: </p><br><pre> <code class="plaintext hljs">"CreateAuthor" &gt; Opeartion "Prepare": "INSERT INTO authors (Name, Desc, CreatedAt) VALUES($1, $2, now()) RETURNING ID, CreatedAt" with req &lt;nil&gt; took [50.819¬µs] inTx[false] Error: &lt;nil&gt; "CreateAuthor" &gt; Opeartion "QueryRow": "INSERT INTO authors (Name, Desc, CreatedAt) VALUES(@Name, @Desc, now()) RETURNING ID, CreatedAt" with req bookstore.CreateAuthorReq{BaseAuthor:bookstore.BaseAuthor{Name:"foo", Desc:"Bar"}} took [150.994¬µs] inTx[false] Error: &lt;nil&gt;</code> </pre> <br><h3 id="whats-next">  Et ensuite </h3><br><ul><li>  Prise en charge des variables de liaison et des expressions pr√©par√©es pour MySQL. </li><li>  Crochet RowAppender pour ajuster la r√©ponse. </li><li>  Renvoie la valeur de <code>Exec.Result</code> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr431984/">https://habr.com/ru/post/fr431984/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr431972/index.html">Fuite des donn√©es utilisateur Quora</a></li>
<li><a href="../fr431974/index.html">Tumblr abandonne compl√®tement le contenu "fraise"</a></li>
<li><a href="../fr431976/index.html">Journ√©e de l'informatique en Russie: l'histoire du premier projet d'un ordinateur automatique</a></li>
<li><a href="../fr431978/index.html">Promotion de la boutique en ligne: ce qui devra √™tre corrig√©</a></li>
<li><a href="../fr431982/index.html">Digerati, Hakerazzi et Cholesterol dans les donn√©es: √† propos de l'argot informatique</a></li>
<li><a href="../fr431986/index.html">Histoire de Fuck Up: comment j'ai √©t√© d√©√ßu par les services num√©riques pour les entreprises et que j'avais ma propre entreprise (enfin, presque)</a></li>
<li><a href="../fr431988/index.html">Quand le th√©or√®me est devenu un axiome: ONYX BOOX Euclid review</a></li>
<li><a href="../fr431990/index.html">Des lacunes ont gagn√©. Traduction de la documentation des conventions de codage Kotlin √† partir de JetBrains</a></li>
<li><a href="../fr431992/index.html">Biom√©trie: comment √ßa se passe avec nous et avec eux</a></li>
<li><a href="../fr431994/index.html">Discussion sur la licence PVS-Studio gratuite pour les projets h√©berg√©s sur GitHub</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>