<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçù üë®‚Äçüë®‚Äçüëß‚Äçüë¶ üíâ Todo lo que necesitas es URL ‚ùóÔ∏è üôãüèº ü§Ω</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Los usuarios de VKontakte intercambian 10 mil millones de mensajes diarios. Se env√≠an fotos, c√≥mics, memes y otros archivos adjuntos. Le diremos c√≥mo ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Todo lo que necesitas es URL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/vk/blog/467605/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/g6/l2/us/g6l2usvzzisf7ezfubycuyoty08.jpeg" alt="imagen"></div><br>  Los usuarios de VKontakte intercambian 10 mil millones de mensajes diarios.  Se env√≠an fotos, c√≥mics, memes y otros archivos adjuntos.  Le diremos c√≥mo se nos ocurri√≥ una aplicaci√≥n iOS para cargar im√°genes usando <b><code>URLProtocol</code></b> , y paso a paso descubriremos c√≥mo implementar la nuestra. <br><a name="habracut"></a><br>  Hace aproximadamente un a√±o y medio, el desarrollo de una nueva secci√≥n de mensajes en la aplicaci√≥n VK para iOS estaba en pleno apogeo.  Esta es la primera secci√≥n escrita completamente en Swift.  Se encuentra en un m√≥dulo separado <code>vkm</code> (VK Messages), que no sabe nada sobre el dispositivo de la aplicaci√≥n principal.  Incluso se puede ejecutar en un proyecto separado: la funcionalidad b√°sica de leer y enviar mensajes continuar√° funcionando.  En la aplicaci√≥n principal, los controladores de mensajes se agregan a trav√©s del controlador de vista de contenedor correspondiente para mostrar, por ejemplo, una lista de conversaciones o mensajes en una conversaci√≥n. <br><br>  Messages es una de las secciones m√°s populares de la aplicaci√≥n m√≥vil VKontakte, por lo que es importante que funcione como un reloj.  En el proyecto de <code>messages</code> , luchamos por cada l√≠nea de c√≥digo.  Siempre nos gust√≥ lo bien que se integran los mensajes en la aplicaci√≥n, y nos esforzamos por garantizar que todo siga igual. <br><br>  Llenando gradualmente la secci√≥n con nuevas funciones, abordamos la siguiente tarea: era necesario hacer que la foto que se adjunta al mensaje se muestre primero en un borrador, y despu√©s de enviarla a la lista general de mensajes.  Podr√≠amos agregar un m√≥dulo para trabajar con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>PHImageManager</code></a> , pero las condiciones adicionales dificultaron la tarea. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0l/7t/hm/0l7thmey5vyyonmpbt5wicd-vjm.gif" alt="imagen"></div><br><br>  Al elegir una imagen, el usuario puede procesarla: aplicar un filtro, rotar, recortar, etc. En la aplicaci√≥n VK, esta funcionalidad se implementa en un componente <code>AssetService</code> separado.  Ahora era necesario aprender a trabajar con √©l desde el proyecto del mensaje. <br><br><blockquote>  Bueno, la tarea es bastante simple, lo haremos.  Esta es aproximadamente la soluci√≥n promedio, porque hay muchas variaciones.  Tomamos el protocolo, lo volcamos en mensajes y comenzamos a llenarlo con m√©todos.  ¬°Agregamos al AssetService, adaptamos el protocolo y agregamos nuestra implementaci√≥n de cach√©!  para viscosidad  Luego colocamos la implementaci√≥n en mensajes, la agregamos a alg√∫n servicio o administrador que funcionar√° con todo esto y comenzamos a usarla.  Al mismo tiempo, todav√≠a llega un nuevo desarrollador y, mientras trata de resolverlo todo, lo condena en un susurro ... (bueno, ya entiendes).  Al mismo tiempo, el sudor aparece en su frente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7i/ze/q8/7izeq8h2gkpsgj2qybfro74kobc.jpeg" alt="imagen"></div><br></blockquote><br>  Esta decisi√≥n <i>no</i> fue <i>de nuestro agrado</i> .  Aparecen nuevas entidades que los componentes del mensaje deben conocer al trabajar con im√°genes de <code>AssetService</code> .  El desarrollador tambi√©n necesita hacer un trabajo extra para descubrir c√≥mo funciona este sistema.  Finalmente, hab√≠a un enlace impl√≠cito adicional a los componentes del proyecto principal, que tratamos de evitar para que la secci√≥n de mensajes contin√∫e funcionando como un m√≥dulo independiente. <br><br>  Quer√≠a resolver el problema para que el proyecto no supiera nada sobre qu√© tipo de imagen se eligi√≥, c√≥mo almacenarla, si necesitaba una carga y representaci√≥n especial.  Adem√°s, ya tenemos la capacidad de descargar im√°genes convencionales de Internet, solo que no se descargan a trav√©s de un servicio adicional, sino simplemente por <code>URL</code> .  Y, de hecho, no hay diferencia entre los dos tipos de im√°genes.  Solo algunos se almacenan localmente, mientras que otros se almacenan en el servidor. <br><br>  Entonces se nos ocurri√≥ una idea muy simple: ¬øqu√© pasa si los activos locales tambi√©n se pueden aprender a cargar a trav√©s de <code>URL</code> ?  Parece que con un solo clic de <s>los</s> dedos de <s>Thanos</s> resolver√≠a todos nuestros problemas: no necesita saber nada sobre <code>AssetService</code> , agregar nuevos tipos de datos y aumentar la entrop√≠a en vano, aprender a cargar un nuevo tipo de imagen, cuidar el almacenamiento en cach√© de datos.  Suena como un plan. <br><br><h2>  Todo lo que necesitamos es una URL </h2><br>  Consideramos esta idea y decidimos definir el formato de <code>URL</code> que usaremos para cargar activos locales: <br><br><pre> <code class="json hljs">asset://?id=<span class="hljs-number"><span class="hljs-number">123</span></span>&amp;width=<span class="hljs-number"><span class="hljs-number">1920</span></span>&amp;height=<span class="hljs-number"><span class="hljs-number">1280</span></span></code> </pre> <br>  Usaremos el valor de la propiedad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>localIdentifier</code></a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>localIdentifier</code></a> como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>PHObject</code></a> , y pasaremos los par√°metros <code>width</code> y <code>height</code> para cargar las im√°genes del tama√±o deseado.  Tambi√©n agregamos algunos par√°metros m√°s como <code>crop</code> , <code>filter</code> , <code>rotate</code> , que le permitir√°n trabajar con la informaci√≥n de la imagen procesada. <br><br>  Para manejar estas <code>URL</code> crearemos un <code>AssetURLProtocol</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AssetURLProtocol</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLProtocol</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br>  Su tarea es cargar la imagen a trav√©s de <code>AssetService</code> y devolver los datos que ya est√°n listos para su uso. <br><br>  Todo esto nos permitir√° delegar casi por completo el trabajo del protocolo <code>URL Loading System</code> y el <code>URL Loading System</code> . <br><br>  Dentro de los mensajes ser√° posible operar con las <code>URL</code> m√°s comunes, solo en un formato diferente.  Tambi√©n ser√° posible reutilizar el mecanismo existente para cargar im√°genes, es muy sencillo serializar en la base de datos e implementar el almacenamiento en cach√© de datos a trav√©s de <code>URLCache</code> est√°ndar. <br><br>  ¬øFuncion√≥?  Si, al leer este art√≠culo, puede adjuntar una foto de la galer√≠a al mensaje en la aplicaci√≥n VKontakte, entonces s√≠ :) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bm/6j/tb/bm6jtb7mkd489czjvwhzpy-dpo0.jpeg" alt="imagen"></div><br>  Para dejar en claro c√≥mo implementar su <code>URLProtocol</code> , propongo considerar esto con un ejemplo. <br><br>  Nos propusimos la tarea: implementar una aplicaci√≥n simple con una lista en la que necesita mostrar una lista de instant√°neas de mapa en las coordenadas dadas.  Para descargar instant√°neas, utilizaremos el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>MKMapSnapshotter</code></a> est√°ndar de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>MapKit</code></a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>MapKit</code></a> datos a trav√©s del <code>URLProtocol</code> personalizado <code>URLProtocol</code> .  El resultado podr√≠a verse m√°s o menos as√≠: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l1/bg/s8/l1bgs8g0xzehoxt49oddmmtbuoe.gif" alt="imagen"></div><br>  Primero implementamos el mecanismo para cargar datos por <code>URL</code> .  Para mostrar la instant√°nea del mapa, necesitamos conocer las coordenadas del punto: su latitud y longitud ( <code>latitude</code> , <code>longitude</code> ).  Defina el formato de <code>URL</code> personalizado mediante el cual queremos cargar informaci√≥n: <br><br><pre> <code class="json hljs">map://?latitude=<span class="hljs-number"><span class="hljs-number">59.935634</span></span>&amp;longitude=<span class="hljs-number"><span class="hljs-number">30.325935</span></span></code> </pre> <br>  Ahora implementamos <code>URLProtocol</code> , que procesar√° dichos enlaces y generar√° el resultado deseado.  <code>MapURLProtocol</code> clase <code>MapURLProtocol</code> , que <code>MapURLProtocol</code> de la clase base <code>URLProtocol</code> .  Sin <code>URLProtocol</code> , a pesar de su nombre, <code>URLProtocol</code> es una clase abstracta.  No se averg√ºence, aqu√≠ usamos otros conceptos: <code>URLProtocol</code> representa exactamente el protocolo <code>URL</code> y no tiene relaci√≥n con los t√©rminos de OOP.  Entonces <code>MapURLProtocol</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MapURLProtocol</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLProtocol</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br>  Ahora redefinimos algunos m√©todos requeridos sin los cuales el protocolo <code>URL</code> no funcionar√≠a: <br><br><h3>  1. <code>canInit(with:)</code> </h3><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">func</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">canInit</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLRequest</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bool</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.url?.scheme == <span class="hljs-string"><span class="hljs-string">"map"</span></span> }</code> </pre> <br>  El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>canInit(with:)</code></a> es necesario para indicar qu√© tipos de solicitudes puede manejar nuestro protocolo <code>URL</code> .  Para este ejemplo, suponga que el protocolo solo procesar√° solicitudes con un esquema de <code>map</code> en la <code>URL</code> .  Antes de comenzar cualquier solicitud, la <code>URL Loading System</code> pasa por todos los protocolos registrados para la sesi√≥n y llama a este m√©todo.  El primer protocolo registrado, que en este m√©todo devolver√° <code>true</code> , se utilizar√° para procesar la solicitud. <br><br><h4>  <code>canonicalRequest(for:)</code> </h4><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">func</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">canonicalRequest</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">for</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLRequest</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLRequest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request }</code> </pre> <br>  El m√©todo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>canonicalRequest(for:)</code></a> est√° destinado a reducir la solicitud a la forma can√≥nica.  La documentaci√≥n dice que la implementaci√≥n del protocolo en s√≠ mismo decide qu√© considerar como la definici√≥n de este concepto.  Aqu√≠ puede normalizar el esquema, agregar encabezados a la solicitud, si es necesario, etc. El √∫nico requisito para que este m√©todo funcione es que para cada solicitud entrante siempre debe haber el mismo resultado, incluso porque este m√©todo tambi√©n se utiliza para buscar respuestas almacenadas en cach√© solicitudes en <code>URLCache</code> . <br><br><h4>  3. <code>startLoading()</code> </h4><br>  El m√©todo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>startLoading()</code></a> describe toda la l√≥gica para cargar los datos necesarios.  En este ejemplo, debe analizar la <code>URL</code> solicitud y, en funci√≥n de los valores de sus par√°metros de <code>latitude</code> y <code>longitude</code> , recurrir a <code>MKMapSnapshotter</code> y cargar la instant√°nea de mapa deseada. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = request.url, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> components = <span class="hljs-type"><span class="hljs-type">URLComponents</span></span>(url: url, resolvingAgainstBaseURL: <span class="hljs-literal"><span class="hljs-literal">false</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> queryItems = components.queryItems <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fail(with: .badURL) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } load(with: queryItems) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with queryItems: [URLQueryItem])</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> snapshotter = <span class="hljs-type"><span class="hljs-type">MKMapSnapshotter</span></span>(queryItems: queryItems) snapshotter.start( with: <span class="hljs-type"><span class="hljs-type">DispatchQueue</span></span>.global(qos: .background), completionHandler: handle ) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(snapshot: MKMapSnapshotter.Snapshot?, error: Error?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> snapshot = snapshot, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = snapshot.image.jpegData(compressionQuality: <span class="hljs-number"><span class="hljs-number">1</span></span>) { complete(with: data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error = error { fail(with: error) } }</code> </pre> <br>  Despu√©s de recibir los datos, es necesario apagar correctamente el protocolo: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">complete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with data: Data)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = request.url, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> client = client <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> response = <span class="hljs-type"><span class="hljs-type">URLResponse</span></span>( url: url, mimeType: <span class="hljs-string"><span class="hljs-string">"image/jpeg"</span></span>, expectedContentLength: data.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>, textEncodingName: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> ) client.urlProtocol(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didReceive: response, cacheStoragePolicy: .allowed) client.urlProtocol(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didLoad: data) client.urlProtocolDidFinishLoading(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) }</code> </pre> <br>  En primer lugar, cree un objeto de tipo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>URLResponse</code></a> .  Este objeto contiene metadatos importantes para responder a una solicitud.  Luego ejecutamos tres m√©todos importantes para un objeto de tipo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>URLProtocolClient</code></a> .  La propiedad del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>client</code></a> de este tipo contiene cada entidad del protocolo <code>URL</code> .  Act√∫a como un proxy entre el protocolo <code>URL</code> y la <code>URL Loading System</code> completa <code>URL Loading System</code> , que, cuando se invocan estos m√©todos, saca conclusiones sobre lo que se debe hacer con los datos: cach√©, pasar solicitudes a <code>completionHandler</code> , de alguna manera procesar el cierre del protocolo, etc. y el n√∫mero de llamadas a estos m√©todos puede variar seg√∫n la implementaci√≥n del protocolo.  Por ejemplo, podemos descargar datos de la red con lotes y notificar peri√≥dicamente a <code>URLProtocolClient</code> sobre esto para mostrar el progreso de la carga de datos en la interfaz. <br><br>  Si se produce un error en el funcionamiento del protocolo, tambi√©n es necesario procesar y notificar correctamente a <code>URLProtocolClient</code> sobre esto: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with error: Error)</span></span></span></span> { client?.urlProtocol(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didFailWithError: error) }</code> </pre> <br>  Es este error el que luego se enviar√° al <code>completionHandler</code> la solicitud, donde se puede procesar y mostrar un hermoso mensaje al usuario. <br><br><h4>  4. <code>stopLoading()</code> </h4><br>  Se llama al m√©todo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>stopLoading()</code></a> cuando se completa la operaci√≥n del protocolo por alg√∫n motivo.  Esto puede ser una finalizaci√≥n exitosa, o una finalizaci√≥n de error o una cancelaci√≥n de solicitud.  Este es un buen lugar para liberar recursos ocupados o eliminar datos temporales. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stopLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { }</code> </pre> <br>  Esto completa la implementaci√≥n del protocolo <code>URL</code> ; se puede usar en cualquier lugar de la aplicaci√≥n.  Para saber d√≥nde aplicar nuestro protocolo, agregue un par de cosas m√°s. <br><br><h4> <code>URLImageView</code> </h4> <br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLImageView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIImageView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> task: <span class="hljs-type"><span class="hljs-type">URLSessionDataTask?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> taskId: <span class="hljs-type"><span class="hljs-type">Int?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url: URL)</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(task == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> || task?.taskIdentifier != taskId) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>(url: url) task = session.dataTask(with: request, completionHandler: complete) taskId = task?.taskIdentifier task?.resume() } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">complete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data: Data?, response: URLResponse?, error: Error?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.taskId == task?.taskIdentifier, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = data, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> image = <span class="hljs-type"><span class="hljs-type">UIImage</span></span>(data: data) { didLoadRemote(image: image) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didLoadRemote</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image: UIImage)</span></span></span></span> { <span class="hljs-type"><span class="hljs-type">DispatchQueue</span></span>.main.async { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.image = image } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepareForReuse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { task?.cancel() taskId = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> image = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } }</code> </pre> <br>  Esta es una clase simple, descendiente de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>UIImageView</code></a> , una implementaci√≥n similar de la que probablemente tenga en cualquier aplicaci√≥n.  Aqu√≠ simplemente cargamos la imagen por la <code>URL</code> en el m√©todo <code>render(url:)</code> y la escribimos en la propiedad de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>image</code></a> .  La conveniencia es que puede cargar absolutamente cualquier imagen, ya sea por <code>http</code> / <code>https</code> <code>URL</code> o por nuestra <code>URL</code> personalizada. <br><br>  Para ejecutar solicitudes para cargar im√°genes, tambi√©n necesitar√° un objeto de tipo <code>URLSession</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> config: <span class="hljs-type"><span class="hljs-type">URLSessionConfiguration</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = <span class="hljs-type"><span class="hljs-type">URLSessionConfiguration</span></span>.ephemeral <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.protocolClasses = [ <span class="hljs-type"><span class="hljs-type">MapURLProtocol</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> }() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> session = <span class="hljs-type"><span class="hljs-type">URLSession</span></span>( configuration: config, delegate: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, delegateQueue: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> )</code> </pre> <br>  La configuraci√≥n de la sesi√≥n es especialmente importante aqu√≠.  En <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>URLSessionConfiguration</code></a> hay una propiedad importante para nosotros: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>protocolClasses</code></a> .  Esta es una lista de los tipos de protocolos <code>URL</code> que puede manejar una sesi√≥n con esta configuraci√≥n.  De manera predeterminada, la sesi√≥n admite el procesamiento de protocolos <code>http</code> / <code>https</code> , y si se requiere soporte personalizado, deben especificarse.  Para nuestro ejemplo, especifique <code>MapURLProtocol</code> . <br><br>  Todo lo que queda por hacer es implementar el controlador de vista, que mostrar√° instant√°neas del mapa.  Su c√≥digo fuente se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br>  Aqu√≠ est√° el resultado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ed/gf/c8/edgfc8crekglljfq33hfggic520.gif" alt="imagen"></div><br><h2>  ¬øQu√© pasa con el almacenamiento en cach√©? </h2><br>  Todo parece funcionar bien, excepto un punto importante: cuando desplazamos la lista de un lado a otro, aparecen puntos blancos en la pantalla.  Parece que las instant√°neas no se almacenan en cach√© de ninguna manera y para cada llamada al m√©todo <code>render(url:)</code> , <code>MKMapSnapshotter</code> datos a trav√©s de <code>MKMapSnapshotter</code> .  Esto lleva tiempo y, por lo tanto, tales brechas en la carga.  Vale la pena implementar un mecanismo de almacenamiento en cach√© de datos para que las instant√°neas ya creadas no se vuelvan a descargar.  Aqu√≠ usamos el poder del <code>URL Loading System</code> , que ya cuenta con un mecanismo de almacenamiento en cach√© para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>URLCache</code></a> . <br><br>  Considere este proceso con m√°s detalle y divida el trabajo con el cach√© en dos etapas importantes: lectura y escritura. <br><br><h3>  Lectura </h3><br>  Para leer correctamente los datos en cach√©, la <code>URL Loading System</code> necesita ayuda para obtener respuestas a varias preguntas importantes: <br><br>  <b>1. ¬øQu√© URLCache usar?</b> <br><br>  Por supuesto, ya ha finalizado <code>URLCache.shared</code> , pero la <code>URL Loading System</code> no siempre puede usarlo; despu√©s de todo, el desarrollador puede querer crear y usar su propia entidad <code>URLCache</code> .  Para responder a esta pregunta, la <code>URLSessionConfiguration</code> sesi√≥n <code>URLSessionConfiguration</code> tiene una propiedad <code>urlCache</code> .  Se utiliza para leer y registrar respuestas a solicitudes.  <code>URLCache</code> algunos <code>URLCache</code> para estos fines en nuestra configuraci√≥n existente. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> config: <span class="hljs-type"><span class="hljs-type">URLSessionConfiguration</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = <span class="hljs-type"><span class="hljs-type">URLSessionConfiguration</span></span>.ephemeral <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.urlCache = <span class="hljs-type"><span class="hljs-type">ImageURLCache</span></span>.current <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.protocolClasses = [ <span class="hljs-type"><span class="hljs-type">MapURLProtocol</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> }()</code> </pre> <br>  <b>2. ¬øNecesito usar datos en cach√© o descargar nuevamente?</b> <br><br>  La respuesta a esta pregunta depende de la solicitud de <code>URLRequest</code> que estamos a punto de ejecutar.  Al crear una solicitud, tenemos la oportunidad de especificar una pol√≠tica de cach√© en el argumento <code>cachePolicy</code> adem√°s de la <code>URL</code> . <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>( url: url, cachePolicy: .returnCacheDataElseLoad, timeoutInterval: <span class="hljs-number"><span class="hljs-number">30</span></span> )</code> </pre> <br>  El valor predeterminado es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>.useProtocolCachePolicy</code></a> , que tambi√©n est√° escrito en la documentaci√≥n.  Esto significa que en esta versi√≥n, la tarea de encontrar una respuesta en cach√© a una solicitud y determinar su relevancia recae completamente en la implementaci√≥n del protocolo <code>URL</code> .  Pero hay una manera m√°s f√°cil.  Si establece el valor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>.returnCacheDataElseLoad</code></a> , al crear la siguiente entidad <code>URLProtocol</code> <code>URL Loading System</code> asumir√° parte del trabajo: solicitar√° a <code>urlCache</code> respuesta en cach√© a la solicitud actual utilizando el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>cachedResponse(for:)</code></a> .  Si hay datos en cach√©, entonces un objeto de tipo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>CachedURLResponse</code></a> se transferir√° inmediatamente cuando el <code>URLProtocol</code> inicialice y se almacene en la propiedad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>cachedResponse</code></a> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>( request: <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>, cachedResponse: <span class="hljs-type"><span class="hljs-type">CachedURLResponse?</span></span>, client: <span class="hljs-type"><span class="hljs-type">URLProtocolClient?</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>( request: request, cachedResponse: cachedResponse, client: client ) }</code> </pre> <br>  <code>CachedURLResponse</code> es una clase simple que contiene datos ( <code>Data</code> ) y metainformaci√≥n para ellos ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>URLResponse</code></a> ). <br><br>  Solo podemos cambiar un <code>startLoading</code> m√©todo <code>startLoading</code> y verificar el valor de esta propiedad dentro de √©l, e inmediatamente finalizar el protocolo con estos datos: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cachedResponse = cachedResponse { complete(with: cachedResponse.data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = request.url, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> components = <span class="hljs-type"><span class="hljs-type">URLComponents</span></span>(url: url, resolvingAgainstBaseURL: <span class="hljs-literal"><span class="hljs-literal">false</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> queryItems = components.queryItems <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fail(with: .badURL) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } load(with: queryItems) } }</code> </pre> <br><h3>  Registro </h3><br>  Para encontrar datos en la memoria cach√©, debe colocarlos all√≠.  El <code>URL Loading System</code> tambi√©n se encarga de este trabajo.  Todo lo que se requiere de nosotros es decirle que queremos almacenar en cach√© los datos cuando el protocolo se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>cacheStoragePolicy</code></a> usando la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>cacheStoragePolicy</code></a> pol√≠tica de cach√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>cacheStoragePolicy</code></a> .  Esta es una enumeraci√≥n simple con los siguientes valores: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StoragePolicy</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> allowed <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> allowedInMemoryOnly <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> notAllowed }</code> </pre> <br>  Significan que el almacenamiento en cach√© est√° permitido en la memoria y en el disco, solo en la memoria o est√° prohibido.  En nuestro ejemplo, indicamos que el almacenamiento en cach√© est√° permitido en la memoria y en el disco, porque ¬øpor qu√© no? <br><br><pre> <code class="swift hljs">client.urlProtocol(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didReceive: response, cacheStoragePolicy: .allowed)</code> </pre> <br>  Entonces, siguiendo algunos pasos simples, admitimos la capacidad de almacenar en cach√© las instant√°neas del mapa.  Y ahora la aplicaci√≥n funciona as√≠: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l1/bg/s8/l1bgs8g0xzehoxt49oddmmtbuoe.gif" alt="imagen"></div><br>  Como puede ver, no hay m√°s puntos blancos: las tarjetas se cargan una vez y luego simplemente se reutilizan del cach√©. <br><br><h2>  No siempre es facil </h2><br>  Al implementar el protocolo <code>URL</code> , encontramos una serie de bloqueos. <br><br>  El primero estaba relacionado con la implementaci√≥n interna de la interacci√≥n del <code>URL Loading System</code> con <code>URLCache</code> al almacenar en cach√© las respuestas a las solicitudes.  La documentaci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">indica</a> : a pesar de la seguridad del <code>URLCache</code> de <code>URLCache</code> , el funcionamiento de los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>cachedResponse(for:)</code></a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>storeCachedResponse(_:for:)</code></a> para leer / escribir respuestas a las solicitudes puede conducir a una raza de estados, por lo que este punto debe tenerse en cuenta en <code>URLCache</code> subclases de <code>URLCache</code> .  Esper√°bamos que usando <code>URLCache.shared</code> este problema se resolviera, pero result√≥ ser incorrecto.  Para solucionar esto, utilizamos un cach√© de <code>ImageURLCache</code> separado, un descendiente de <code>URLCache</code> , en el que ejecutamos los m√©todos especificados sincr√≥nicamente en una cola separada.  Como beneficio adicional, podemos configurar por separado la capacidad de cach√© en la memoria y en el disco por separado de otras entidades de <code>URLCache</code> . <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> accessQueue = <span class="hljs-type"><span class="hljs-type">DispatchQueue</span></span>( label: <span class="hljs-string"><span class="hljs-string">"image-urlcache-access"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cachedResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request: URLRequest)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CachedURLResponse?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">ImageURLCache</span></span>.accessQueue.sync { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.cachedResponse(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: request) } } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">storeCachedResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> response: CachedURLResponse, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request: URLRequest)</span></span></span></span> { <span class="hljs-type"><span class="hljs-type">ImageURLCache</span></span>.accessQueue.sync { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.storeCachedResponse(response, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: request) } }</code> </pre> <br>  Otro problema se reprodujo solo en dispositivos con iOS 9. Los m√©todos para iniciar y finalizar la carga del protocolo <code>URL</code> se pueden realizar en diferentes subprocesos, lo que puede provocar bloqueos raros pero desagradables.  Para resolver el problema, guardamos el hilo actual en el m√©todo <code>startLoading</code> y luego ejecutamos el c√≥digo de finalizaci√≥n de descarga directamente en este hilo. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread: <span class="hljs-type"><span class="hljs-type">Thread!</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = request.url, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> components = <span class="hljs-type"><span class="hljs-type">URLComponents</span></span>(url: url, resolvingAgainstBaseURL: <span class="hljs-literal"><span class="hljs-literal">false</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> queryItems = components.queryItems <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fail(with: .badURL) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } thread = <span class="hljs-type"><span class="hljs-type">Thread</span></span>.current <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cachedResponse = cachedResponse { complete(with: cachedResponse) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { load(request: request, url: url, queryItems: queryItems) } }</code> </pre> <br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(snapshot: MKMapSnapshotter.Snapshot?, error: Error?)</span></span></span></span> { thread.execute { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> snapshot = snapshot, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = snapshot.image.jpegData(compressionQuality: <span class="hljs-number"><span class="hljs-number">0.7</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.complete(with: data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error = error { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.fail(with: error) } } }</code> </pre> <br><h2>  ¬øCu√°ndo puede ser √∫til un protocolo URL? </h2><br>  Como resultado, casi todos los usuarios de nuestra aplicaci√≥n iOS de una forma u otra encuentran elementos que funcionan a trav√©s del protocolo <code>URL</code> .  Adem√°s de descargar medios de la galer√≠a, varias implementaciones de protocolos <code>URL</code> nos ayudan a mostrar mapas y encuestas, as√≠ como a mostrar avatares de chat compuestos por fotos de sus participantes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5v/jz/sl/5vjzsliedpi6l9qt6qhnaloi1l8.jpeg" alt="imagen"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p0/g4/rz/p0g4rzbdjqqbx3oc-ochol6ilwy.jpeg" alt="imagen"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n4/1e/mb/n41embtawargx2zofdmevlyq_nk.jpeg" alt="imagen"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/j4/dn/gj/j4dngjkluh5gyxb3od9vwkse9zu.jpeg" alt="imagen"></div><br>  Como cualquier soluci√≥n, <code>URLProtocol</code> tiene sus ventajas y desventajas. <br><br><h3>  Desventajas de <code>URLProtocol</code> </h3><br><ul><li>  <b>Falta de escritura estricta</b> : al crear una <code>URL</code> esquema y los par√°metros de enlace se especifican manualmente a trav√©s de cadenas.  Si realiza un error tipogr√°fico, el par√°metro deseado no se procesar√°.  Esto puede complicar la depuraci√≥n de la aplicaci√≥n y la b√∫squeda de errores en su funcionamiento.  En la aplicaci√≥n VKontakte, utilizamos <code>URLBuilder</code> especiales que forman la <code>URL</code> final en funci√≥n de los par√°metros pasados.  Esta decisi√≥n no es muy hermosa y de alguna manera contradice el objetivo de no producir entidades adicionales, pero a√∫n no hay una mejor idea.  Pero sabemos que si necesita crear alg√∫n tipo de <code>URL</code> personalizada, entonces seguramente hay un <code>URLBuilder</code> especial que lo ayudar√° a no cometer un error. </li><li>  <code>URLProtocol</code> <b>no obvios</b> : ya describ√≠ un par de escenarios que podr√≠an hacer que una aplicaci√≥n que usa <code>URLProtocol</code> bloquee.  Quiz√°s hay otros.   ,  ,      ,    stack trace'    . </li></ul><br><h3>  URLProtocol </h3><br><ul><li> <b>  </b> ‚Äî  ,      ,      ,   :     ,   .       <code>URL</code> ‚Äî     . </li><li> <b> </b> ‚Äî    <code>URL</code> -        .         . </li><li> <b>  </b> ‚Äî       ,      ,   <code>URL</code> -.       <code>URL</code> , <code>URLSession</code> , <code>URLSessionDataTask</code> . </li><li> <b> </b> ‚Äî    <code>URL</code> -   <code>URL</code> -,             <code>URL Loading System</code> . </li><li> <b>*  API</b> ‚Äî      .     ,        API,   -  ,   <code>URL</code> -.       ,       API         ,  .         <code>URL</code> -      <code>http</code> / <code>https</code> . </li></ul><br> <code>URL</code> - ‚Äî         .      .  -   ,   -    ,   ,    , ‚Äî  ,      .  ,     , ‚Äî  <code>URL</code> . <br><br> <b>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  GitHub</a></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/467605/">https://habr.com/ru/post/467605/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../467591/index.html">La nueva prueba resuelve la aproximaci√≥n de n√∫meros como pi</a></li>
<li><a href="../467593/index.html">(No relevante, reparado) Nota. C√≥mo Tele2 comparte el acceso a la cuenta personal de los nuevos suscriptores</a></li>
<li><a href="../467595/index.html">Recorriendo los centros de datos de Selectel. Dinosaur on Fire, VMware, C2F5H y el hombre lobo invisible</a></li>
<li><a href="../467597/index.html">Personalizaci√≥n de pautas de productos de Big Data con Vowpal Wabbit</a></li>
<li><a href="../467599/index.html">Representaci√≥n de gr√°ficos en 3D con OpenGL</a></li>
<li><a href="../467607/index.html">Confesi√≥n del enemigo del estibador</a></li>
<li><a href="../467609/index.html">Crear una aplicaci√≥n m√≥vil en React Native</a></li>
<li><a href="../467611/index.html">Algoritmos de detecci√≥n de esquema de imagen</a></li>
<li><a href="../467615/index.html">C√≥mo crear Python wrapper y no volverse loco</a></li>
<li><a href="../467617/index.html">Kaspresso: el marco de autotest que estabas esperando</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>