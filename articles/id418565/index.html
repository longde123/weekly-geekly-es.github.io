<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤’ ğŸ¯ ğŸ•µï¸ Dalam perjalanan ke cakupan kode 100% dengan tes di Go menggunakan sql-dumper sebagai contoh ğŸ‘©â€ğŸ’» ğŸ¡ ğŸŒ¡ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam posting ini saya akan berbicara tentang bagaimana saya menulis program konsol dalam bahasa Go untuk mengunggah data dari database ke file, menco...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dalam perjalanan ke cakupan kode 100% dengan tes di Go menggunakan sql-dumper sebagai contoh</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418565/"><p><img src="https://habrastorage.org/getpro/habr/post_images/cc4/3fe/2c1/cc43fe2c1f16d831ccbf66843bded446.png" alt="gambar"></p><br><p>  Dalam posting ini saya akan berbicara tentang bagaimana saya menulis program konsol dalam bahasa Go untuk mengunggah data dari database ke file, mencoba untuk menutupi seluruh kode dengan tes 100%.  Saya akan mulai dengan deskripsi mengapa saya membutuhkan program ini.  Saya akan terus menggambarkan kesulitan pertama, beberapa di antaranya disebabkan oleh fitur bahasa Go.  Selanjutnya, saya akan menyebutkan sedikit build di Travis CI, dan kemudian saya akan berbicara tentang bagaimana saya menulis tes, mencoba untuk menutupi kode 100%.  Saya akan menyentuh sedikit pengujian pekerjaan dengan database dan sistem file.  Sebagai kesimpulan, saya akan mengatakan apa yang menjadi keinginan untuk menutup kode dengan pengujian dan apa yang dikatakan indikator ini.  Saya akan memberikan materi dengan tautan ke dokumentasi dan contoh komitmen dari proyek saya. </p><a name="habracut"></a><br><h1 id="naznachenie-programmy">  Tujuan Program </h1><br><p>  Program harus diluncurkan dari baris perintah dengan indikasi daftar tabel dan beberapa kolomnya, rentang data untuk kolom yang ditentukan pertama, penghitungan hubungan tabel yang dipilih satu sama lain, dengan kemampuan untuk menentukan file dengan pengaturan koneksi database.  Hasil karya harus berupa file yang menjelaskan permintaan untuk membuat tabel yang ditentukan dengan kolom yang ditentukan dan menyisipkan ekspresi dari data yang dipilih.  Diasumsikan bahwa penggunaan program semacam itu akan menyederhanakan skenario penggalian sebagian data dari basis data besar dan penggelaran bagian ini secara lokal.  Selain itu, ini membongkar file sql yang seharusnya diproses oleh program lain, yang menggantikan bagian dari data sesuai dengan templat tertentu. </p><br><p>  Hasil yang sama dapat dicapai dengan menggunakan salah satu klien populer ke database dan sejumlah besar pekerjaan manual.  Aplikasi itu seharusnya menyederhanakan proses ini dan mengotomatisasi sebanyak mungkin. </p><br><p>  Program ini seharusnya dikembangkan oleh pekerja magang saya untuk tujuan pelatihan dan penggunaan selanjutnya dalam pelatihan mereka selanjutnya.  Tapi situasinya berubah sehingga mereka menolak gagasan ini.  Tetapi saya memutuskan untuk mencoba menulis program semacam itu di waktu luang saya untuk tujuan praktik saya mengembangkan bahasa Go. </p><br><p>  Solusinya tidak lengkap, ia memiliki sejumlah keterbatasan, yang dijelaskan dalam README.  Bagaimanapun, ini bukan proyek pertempuran. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh penggunaan dan kode sumber</a> . </p><br><h1 id="pervye-trudnosti">  Kesulitan pertama </h1><br><p> Daftar tabel dan kolomnya diteruskan ke program sebagai argumen dalam bentuk string, yaitu, tidak diketahui sebelumnya.  Sebagian besar contoh bekerja dengan database di Go menyiratkan bahwa struktur basis data sudah diketahui sebelumnya, kami cukup membuat <code>struct</code> menunjukkan jenis-jenis setiap kolom.  Tetapi dalam hal ini tidak berhasil seperti itu. </p><br><p>  Solusi untuk ini adalah dengan menggunakan metode <code>MapScan</code> dari <code>github.com/jmoiron/sqlx</code> , yang menciptakan irisan antarmuka dalam ukuran yang sama dengan jumlah kolom sampel.  Pertanyaan selanjutnya adalah bagaimana cara mendapatkan tipe data nyata dari antarmuka ini.  Solusinya adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saklar-kasus dengan jenis</a> .  Solusi semacam itu tidak terlihat sangat indah, karena akan perlu untuk membuang semua tipe ke string: bilangan bulat seperti apa adanya, string untuk melarikan diri dan melampirkan tanda kutip, tetapi pada saat yang sama menggambarkan semua tipe yang dapat berasal dari database.  Saya tidak menemukan cara yang lebih elegan untuk menyelesaikan masalah ini. </p><br><p>  Dengan tipe-tipe itu, fitur bahasa Go juga dimanifestasikan - variabel tipe string tidak dapat mengambil nilai <code>nil</code> , tetapi string kosong dan <code>NULL</code> dapat berasal dari database.  Untuk mengatasi masalah ini, ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">solusi</a> dalam paket <code>database/sql</code> - gunakan <code>strut</code> khusus, yang menyimpan nilai dan tanda, apakah <code>NULL</code> atau tidak. </p><br><h1 id="sborka-i-vychislenie-procenta-pokrytiya-koda-testami">  Perakitan dan perhitungan persentase cakupan kode dengan tes </h1><br><p>  Untuk perakitan saya menggunakan Travis CI, untuk mendapatkan persentase cakupan kode dengan tes - Baju.  File <code>.travis.yml</code> untuk perakitan cukup sederhana: </p><br><pre> <code class="hljs powershell">language: go go: - <span class="hljs-number"><span class="hljs-number">1.9</span></span> script: - go get <span class="hljs-literal"><span class="hljs-literal">-t</span></span> <span class="hljs-literal"><span class="hljs-literal">-v</span></span> ./... - go get golang.org/x/tools/cmd/cover - go get github.com/mattn/goveralls - go test <span class="hljs-literal"><span class="hljs-literal">-v</span></span> <span class="hljs-literal"><span class="hljs-literal">-covermode</span></span>=count <span class="hljs-literal"><span class="hljs-literal">-coverprofile</span></span>=coverage.out ./... - <span class="hljs-variable"><span class="hljs-variable">$HOME</span></span>/gopath/bin/goveralls <span class="hljs-literal"><span class="hljs-literal">-coverprofile</span></span>=coverage.out <span class="hljs-literal"><span class="hljs-literal">-service</span></span>=travis<span class="hljs-literal"><span class="hljs-literal">-ci</span></span> <span class="hljs-literal"><span class="hljs-literal">-repotoken</span></span> <span class="hljs-variable"><span class="hljs-variable">$COVERALLS_TOKEN</span></span></code> </pre> <br><p>  Dalam pengaturan Travis CI, Anda hanya perlu menentukan variabel lingkungan <code>COVERALLS_TOKEN</code> , yang nilainya harus diambil di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs</a> . </p><br><p>  Coveralls memungkinkan Anda untuk dengan mudah mengetahui berapa persen dari keseluruhan proyek, untuk setiap file, menyoroti satu baris kode sumber yang ternyata merupakan tes yang tidak tertutup.  Sebagai contoh, pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">build pertama</a> jelas bahwa saya tidak menulis tes untuk beberapa kasus kesalahan saat mem-parsing permintaan pengguna. </p><br><p>  Cakupan kode 100% berarti bahwa tes ditulis, antara lain, jalankan kode untuk setiap cabang di <code>if</code> .  Ini adalah pekerjaan yang paling banyak ketika menulis tes, dan, secara umum, ketika mengembangkan aplikasi. </p><br><p>  Anda dapat menghitung cakupan dengan tes secara lokal, misalnya, dengan <code>go test -v -covermode=count -coverprofile=coverage.out ./...</code> sama <code>go test -v -covermode=count -coverprofile=coverage.out ./...</code> , tetapi Anda dapat melakukannya dengan lebih baik di CI, Anda dapat menempatkan piring di Github. </p><br><p>  Karena kita berbicara tentang dadu, maka saya menemukan dadu dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://goreportcard.com</a> berguna, yang menganalisis indikator berikut: </p><br><ul><li>  gofmt - pemformatan kode, termasuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyederhanaan konstruksi</a> </li><li>  go_vet - memeriksa konstruksi yang mencurigakan </li><li>  gocyclo - menunjukkan masalah dalam kompleksitas siklomatik </li><li>  golint - bagi saya itu memeriksa ketersediaan semua komentar yang diperlukan </li><li>  lisensi - proyek harus memiliki lisensi </li><li>  ineffassign - memeriksa penugasan yang tidak efektif </li><li>  salah mengeja - memeriksa kesalahan ketik </li></ul><br><h1 id="trudnosti-pokrytiya-koda-testami-na-100">  Kesulitan menutupi kode dengan tes 100% </h1><br><p>  Jika parsing permintaan pengguna kecil untuk komponen terutama bekerja dengan mengubah string ke beberapa struktur dari string dan cukup mudah dicakup oleh tes, maka untuk pengujian kode yang bekerja dengan database, solusinya tidak begitu jelas. </p><br><p>  Atau, sambungkan ke server database nyata, pra-isi dengan data di setiap tes, buat pilihan, dan hapus.  Tetapi ini adalah solusi yang sulit, jauh dari pengujian unit dan memaksakan persyaratannya pada lingkungan, termasuk pada server CI. </p><br><p>  Pilihan lain bisa menggunakan database dalam memori, misalnya, sqlite ( <code>sqlx.Open("sqlite3", ":memory:")</code> ), tetapi ini menyiratkan bahwa kode tersebut harus terikat dengan lemah ke mesin database mungkin, dan ini sangat menyulitkan proyek tetapi untuk tes integrasi cukup baik. </p><br><p>  Untuk pengujian unit, menggunakan tiruan untuk basis data cocok.  Saya menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> .  Dengan menggunakan paket ini, Anda dapat menguji perilaku baik dalam hal hasil normal, dan dalam hal kesalahan, menunjukkan permintaan mana yang harus mengembalikan kesalahan mana. </p><br><p>  Tes menulis menunjukkan bahwa fungsi yang menghubungkan ke database nyata perlu dipindahkan ke main.go, sehingga dapat didefinisikan ulang dalam tes untuk salah satu yang akan mengembalikan contoh tiruan. </p><br><p>  Selain bekerja dengan database, perlu untuk membuat pekerjaan dengan sistem file ketergantungan terpisah.  Ini akan memungkinkan mengganti rekaman file nyata dengan menulis ke memori untuk kemudahan pengujian dan mengurangi kopling.  Ini adalah bagaimana antarmuka <code>FileWriter</code> muncul, dan dengan itu antarmuka file itu kembali.  Untuk menguji skenario kesalahan, implementasi tambahan dari antarmuka ini dibuat dan ditempatkan di file <code>filewriter_test.go</code> , sehingga tidak termasuk dalam build umum, tetapi dapat digunakan dalam pengujian. </p><br><p>  Setelah beberapa waktu, saya punya pertanyaan bagaimana cara menutupi <code>main()</code> tes.  Saat itu, saya punya cukup kode di sana.  Seperti yang ditunjukkan hasil pencarian, ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak dilakukan</a> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Go</a> .  Sebagai gantinya, semua kode yang dapat ditarik dari <code>main()</code> perlu ditarik.  Dalam kode saya, saya hanya menyisakan opsi parsing dan argumen baris perintah (paket <code>flag</code> ), menghubungkan ke database, membuat instance objek yang akan menulis file, dan memanggil metode yang akan melakukan sisa pekerjaan.  Tetapi jalur ini tidak memungkinkan Anda untuk mendapatkan cakupan persis 100%. </p><br><p>  Dalam pengujian Go, ada yang namanya " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh Function</a> ".  Ini adalah fungsi tes yang membandingkan output dengan apa yang dijelaskan dalam komentar di dalam fungsi tersebut.  Contoh tes tersebut dapat ditemukan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode sumber untuk paket go</a> .  Jika file tersebut tidak mengandung tes dan tolok ukur, maka mereka dinamai dengan awalan <code>example_</code> dan diakhiri dengan <code>_test.go</code> .  Nama masing-masing fungsi tes harus dimulai dengan <code>Example</code> .  Pada ini, saya menulis tes untuk objek yang menulis sql ke file, mengganti catatan nyata dalam file dengan tiruan, dari mana Anda bisa mendapatkan konten dan menampilkannya.  Kesimpulan ini dibandingkan dengan standar.  Dengan mudah, Anda tidak perlu menulis perbandingan dengan tangan Anda, dan mudah untuk menulis beberapa baris dalam komentar.  Tetapi ketika datang ke tes untuk objek yang menulis data ke file csv, kesulitan muncul.  Menurut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RFC4180,</a> baris dalam CSV harus dipisahkan oleh CRLF, dan <code>go fmt</code> mengganti semua baris dengan LF, yang mengarah pada fakta bahwa standar dari komentar tidak cocok dengan output aktual karena pemisah baris yang berbeda.  Saya harus menulis tes reguler untuk objek ini, sementara juga mengganti nama file dengan menghapus <code>example_</code> dari itu. </p><br><p>  Pertanyaannya tetap, jika file, misalnya, <code>query.go</code> diuji menggunakan contoh dan tes konvensional, haruskah ada dua file <code>example_query_test.go</code> dan <code>query_test.go</code> ?  Di sini, misalnya, hanya ada satu <code>example_test.go</code> .  Gunakan pencarian untuk "contoh uji coba" masih menyenangkan. </p><br><p>  Saya belajar menulis tes di Go menurut panduan yang diberikan Google untuk "tes menulis go".  Sebagian besar yang saya temui ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3</a> , <a href="">4</a> ) menyarankan membandingkan hasilnya dengan desain bentuk yang diharapkan </p><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v != <span class="hljs-number"><span class="hljs-number">1.5</span></span> { t.<span class="hljs-keyword"><span class="hljs-keyword">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Expected 1.5, got "</span></span>, v) }</code> </pre> <br><p>  Tetapi ketika datang untuk membandingkan jenis, konstruksi yang akrab berkembang secara evolusioner menjadi tumpukan menggunakan "mencerminkan" atau jenis ketegasan.  Atau contoh lain, ketika Anda perlu memeriksa bahwa slice atau peta memiliki nilai yang diperlukan.  Kode menjadi rumit.  Jadi saya ingin menulis <a href="">fungsi bantu</a> saya untuk ujian.  Meskipun solusi yang baik di sini adalah menggunakan perpustakaan untuk pengujian.  Saya menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/stretchr/testify</a> .  Ini memungkinkan Anda untuk membuat <a href="">perbandingan dalam satu baris</a> .  Solusi ini mengurangi jumlah kode dan menyederhanakan pembacaan dan dukungan tes. </p><br><h1 id="droblenie-koda-i-testirovanie">  Fragmentasi dan pengujian kode </h1><br><p>  Menulis tes untuk fungsi tingkat tinggi yang bekerja dengan beberapa objek memungkinkan Anda untuk secara signifikan meningkatkan nilai cakupan kode dengan tes sekaligus, karena selama tes ini banyak baris kode objek individual dieksekusi.  Jika Anda menetapkan sendiri target hanya 100% cakupan, maka motivasi untuk menulis unit test pada komponen kecil sistem menghilang, karena ini tidak mempengaruhi nilai cakupan kode. </p><br><p>  Selain itu, jika Anda tidak memeriksa hasil dalam fungsi tes, ini juga tidak akan mempengaruhi nilai cakupan kode.  Anda bisa mendapatkan nilai cakupan tinggi, tetapi Anda tidak dapat mendeteksi kesalahan serius dalam aplikasi. </p><br><p>  Di sisi lain, jika Anda memiliki <a href="">kode dengan banyak cabang</a> , setelah fungsi tebal dipanggil, maka akan sulit untuk menutupinya dengan tes.  Dan di sini Anda memiliki insentif untuk meningkatkan kode ini, misalnya, <a href="">untuk mengambil</a> semua cabang menjadi fungsi terpisah dan menulis <a href="">tes terpisah</a> di atasnya.  Ini secara positif akan mempengaruhi keterbacaan kode. </p><br><p>  Jika kode memiliki kopling yang kuat, maka kemungkinan besar Anda tidak akan dapat menulis tes di atasnya, yang berarti Anda harus membuat perubahan padanya, yang secara positif akan mempengaruhi kualitas kode. </p><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p>  Sebelum proyek ini, saya tidak perlu menetapkan target cakupan 100% dari kode dengan tes.  Saya bisa mendapatkan aplikasi yang berfungsi dalam 10 jam pengembangan, tetapi butuh 20-30 jam untuk mencapai cakupan 95%.  Dengan menggunakan contoh kecil, saya mendapat ide tentang bagaimana nilai cakupan kode mempengaruhi kualitasnya, dan berapa banyak upaya yang diperlukan untuk mempertahankannya. </p><br><p>  Kesimpulan saya adalah bahwa jika Anda melihat dasbor dengan nilai cakupan kode tinggi untuk seseorang, hampir tidak ada yang mengatakan tentang seberapa baik aplikasi ini telah diuji.  Bagaimanapun, Anda harus menonton tes sendiri.  Tetapi jika Anda sendiri telah menetapkan kursus untuk 100% jujur, maka ini akan membantu Anda menulis aplikasi dengan lebih baik. </p><br><p>  Anda dapat membaca lebih lanjut tentang ini di bahan-bahan berikut dan mengomentarinya: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tragedi cakupan kode 100%</a> , ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HabrÃ©</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tentang bagaimana Anda dapat memiliki cakupan 100%, tetapi tidak memeriksa apa pun</a> </li></ul><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><p>  Kata "coating" digunakan sekitar 20 kali.  Maaf </p></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418565/">https://habr.com/ru/post/id418565/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418553/index.html">Kotlin + Bereaksi vs Javasript + Bereaksi</a></li>
<li><a href="../id418557/index.html">Perhitungan proses gelombang dalam saluran hidrolik menggunakan metode karakteristik</a></li>
<li><a href="../id418559/index.html">NL2API: Membuat Antarmuka Bahasa Alami untuk API Web</a></li>
<li><a href="../id418561/index.html">Mesin negara dalam layanan MVP. Kuliah Yandex</a></li>
<li><a href="../id418563/index.html">Intisari materi menarik untuk pengembang seluler # 263 (23 Juli - 29 Juli)</a></li>
<li><a href="../id418567/index.html">Dell akan berhenti menjadi perusahaan swasta dan untuk pertama kalinya dalam 5 tahun akan menempatkan saham di bursa saham</a></li>
<li><a href="../id418569/index.html">Satelit baru - bug baru: Sensor inframerah satelit GOES-17 tidak sejuk</a></li>
<li><a href="../id418573/index.html">Waterius: Transfer pembacaan air ke telepon melalui Wi-Fi (4 tahun dengan baterai)</a></li>
<li><a href="../id418575/index.html">"Jangan lepas landas": 6 gadget audio yang tidak biasa</a></li>
<li><a href="../id418577/index.html">Kelola bookmark Anda dengan tag - untuk menyenangkan diri sendiri dan kolega Anda</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>