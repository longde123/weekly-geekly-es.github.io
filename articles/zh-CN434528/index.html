<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👲🏼 👨‍👧‍👦 🥅 明信片大小的射线追踪器解密 ♨️ ♨️ 👩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="“他又做了一次！”-这是我看着皮克斯传单[1]的背面时想到的第一件事，传单完全充满了代码。 在右下角，由安德鲁·肯斯勒（Andrew Kensler）签名了一组构造和表达。 对于那些不认识他的人，我会说：Andrew是一位程序员，他于2009年发明了1337字节名片大小的射线追踪器 。 

 这次，...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>明信片大小的射线追踪器解密</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434528/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/cr/xz/vj/crxzvjqqbw5gl4mv3wxxx2zw6wa.png"></div><br>  “他又做了一次！”-这是我看着皮克斯传单<sup>[1]</sup>的背面时想到的第一件事，传单完全充满了代码。 在右下角，由安德鲁·肯斯勒（Andrew Kensler）签名了一组构造和表达。 对于那些不认识他的人，我会说：Andrew是一位程序员，他于2009年发明了1337字节<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">名片大小的射线追踪器</a> 。 <br><br> 这次，安德鲁想出了很多东西，但视觉效果却更有趣。 自从我写完有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wolf3D</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DOOM的</a>游戏引擎黑皮书<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">以来</a> ，我就有时间学习其隐秘代码的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内幕</a> 。 几乎立即，我对他身上发现的技术着迷了。 它们与安德鲁以前的工作完全不同，后者基于“标准”射线追踪器。 我感兴趣的是了解射线行进，构造体积几何的功能，蒙特卡洛渲染/路径跟踪以及他用来将代码压缩到这么小的纸上的许多其他技巧。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yc/z4/nt/ycz4ntg3qh91i6m2wymfccaekvk.png"></div><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lf/2o/qv/lf2oqvd5d39pyfwxyixvjnrmlqq.png"></div><br><h2> 源代码 </h2><br><hr><br> 传单的正面是皮克斯招聘部门的广告。 在背面，打印了2037个字节的C ++代码，它们经过混淆处理以占据尽可能小的表面。 <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; // card &gt; pixar.ppm #include &lt;stdio.h&gt; #include &lt;math.h&gt; #define R return #define O operator typedef float F;typedef int I;struct V{F x,y,z;V(F v=0){x=y=z=v;}V(F a,F b,F c=0){x=a;y=b;z=c;}V O+(V r){RV(x+rx,y+ry,z+rz);}VO*(V r){RV(x*rx,y*r. y,z*rz);}FO%(V r){R x*r.x+y*r.y+z*rz;}VO!(){R*this*(1/sqrtf(*this%*this) );}};FL(F l,F r){R l&lt;r?l:r;}FU(){R(F)rand()/RAND_MAX;}FB(V p,V l,V h){l=p +l*-1;h=h+p*-1;RL(L(L(lx,hx),L(ly,hy)),L(lz,hz));}FS(V p,I&amp;m){F d=1\ e9;V f=p;fz=0;char l[]="5O5_5W9W5_9_COC_AOEOA_E_IOQ_I_QOUOY_Y_]OWW[WaOa_aW\ eWa_e_cWiO";for(I i=0;i&lt;60;i+=4){V b=V(l[i]-79,l[i+1]-79)*.5,e=V(l[i+2]-79,l [i+3]-79)*.5+b*-1,o=f+(b+e*L(-L((b+f*-1)%e/(e%e),0),1))*-1;d=L(d,o%o);}d=sq\ rtf(d);V a[]={V(-11,6),V(11,6)};for(I i=2;i--;){V o=f+a[i]*-1;d=L(d,ox&gt;0?f\ absf(sqrtf(o%o)-2):(o.y+=oy&gt;0?-2:2,sqrtf(o%o)));}d=powf(powf(d,8)+powf(pz, 8),.125)-.5;m=1;F r=L(-L(B(p,V(-30,-.5,-30),V(30,18,30)),B(p,V(-25,17,-25),V (25,20,25))),B(V(fmodf(fabsf(px),8),py,pz),V(1.5,18.5,-25),V(6.5,20,25))) ;if(r&lt;d)d=r,m=2;F s=19.9-py;if(s&lt;d)d=s,m=3;R d;}IM(V o,V d,V&amp;h,V&amp;n){I m,s= 0;F t=0,c;for(;t&lt;100;t+=c)if((c=S(h=o+d*t,m))&lt;.01||++s&gt;99)R n=!V(S(h+V(.01,0 ),s)-c,S(h+V(0,.01),s)-c,S(h+V(0,0,.01),s)-c),m;R 0;}VT(V o,V d){V h,n,r,t= 1,l(!V(.6,.6,1));for(I b=3;b--;){I m=M(o,d,h,n);if(!m)break;if(m==1){d=d+n*( n%d*-2);o=h+d*.1;t=t*.2;}if(m==2){F i=n%l,p=6.283185*U(),c=U(),s=sqrtf(1-c), g=nz&lt;0?-1:1,u=-1/(g+nz),v=nx*ny*u;d=V(v,g+ny*ny*u,-ny)*(cosf(p)*s)+V( 1+g*nx*nx*u,g*v,-g*nx)*(sinf(p)*s)+n*sqrtf(c);o=h+d*.1;t=t*.2;if(i&gt;0&amp;&amp;M(h +n*.1,l,h,n)==3)r=r+t*V(500,400,100)*i;}if(m==3){r=r+t*V(50,80,100);break;}} R r;}I main(){I w=960,h=540,s=16;V e(-22,5,25),g=!(V(-3,4,0)+e*-1),l=!V(gz, 0,-gx)*(1./w),u(gy*lz-gz*ly,gz*lx-gx*lz,gx*ly-gy*lx);printf("P\ 6 %d %d 255 ",w,h);for(I y=h;y--;)for(I x=w;x--;){V c;for(I p=s;p--;)c=c+T(e ,!(g+l*(xw/2+U())+u*(yh/2+U())));c=c*(1./s)+14./241;V o=c+1;c=V(cx/ox,c. y/oy,cz/oz)*255;printf("%c%c%c",(I)cx,(I)cy,(I)cz);}}// Andrew Kensler</span></span></span></span></code> </pre> <br><h2> 他甚至工作吗？ </h2><br><hr><br> 有了代码，便有一个启动说明。 这个想法是将标准输出重定向到文件。 通过扩展，我们可以假设输出格式是一种称为NetPBM <sup>[2]</sup>的文本图像格式。 <br><br><pre>  $ clang -o card2 -O3 raytracer.cpp
 $时间./card&gt; pixar.ppm<font></font>
<font></font>
真实2m58.524s
用户2m57.567s
 sys 0m0.415s </pre><br> 在2分58秒<sup>[3]之后</sup> ，将生成以下图像。 令人惊讶的是，几乎不需要多少代码。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cae/b34/b5c/caeb34b5c6c57c4598adc8f6b3f28f38.webp"></div><br> 您可以从上图中提取很多内容。 坚韧是“路径追踪器”的明显标志。 这种类型的渲染器与射线跟踪的不同之处在于，射线不会追溯到光源。 在这种方法中，每个像素从光源发射出数千条光线，程序对其进行监视，希望它们能够找到光源。 这是一种有趣的技术，它比光线跟踪好得多，它可以处理环境光遮挡，柔和阴影，焦散和放射线的渲染。 <br><br><h2> 我们将把代码分成几部分 </h2><br><hr><br> 将输入传递给CLion会格式化代码（请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>的输出），并将其分成较小的部分/任务。 <br><br><pre>  <font color="grey">#include &lt;stdlib.h&gt; //卡&gt; pixar.ppm</font> <font color="grey">
</font>  <font color="grey">#include &lt;stdio.h&gt;</font> <font color="grey">
</font>  <font color="grey">#include &lt;math.h&gt;</font> </pre><br><pre>  <font color="fuchsia">＃定义R返回</font> <font color="fuchsia">
</font>  <font color="fuchsia">＃定义O运算符</font> <font color="fuchsia">
</font>  <font color="fuchsia">typedef float F; typedef int I;</font> </pre><pre>  <font color="blue">结构V {F x，y，z; V（F v = 0）{x = y = z = v;} V（F a，F b，F</font> <font color="blue">
</font>  <font color="blue">c = 0）{x = a; y = b; z = c;} V O +（V r）{RV（x + rx，y + ry，z + rz）;} VO *（V r）{RV（ x * rx，y * r。</font> <font color="blue">
</font>  <font color="blue">y，z * rz）;} FO％（V r）{R x * r.x + y * r.y + z * rz;} VO！（）{R *此*（1 / sqrtf（*此％ *这个）</font> <font color="blue">
</font>  <font color="blue">）;}};</font> </pre><pre>  <font color="orange">FL（F l，F r）{R l &lt;r？L：r;} FU（）{R（F）rand（）/ RAND_MAX;} FB（V p，V l，V h）{l = p</font> <font color="orange">
</font>  <font color="orange">+ l * -1; h = h + p * -1; RL（L（L（L（lx，hx），L（ly，hy）），L（lz，hz））;}</font> </pre><pre>  <font color="LimeGreen">FS（V p，I＆m）{F d = 1 \</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">e9; V f = p; fz = 0; char l [] =“ 5O5_5W9W5_9_COC_AOEOA_E_IOQ_I_QOUOY_Y_] OWW [WaOa_aW \</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">eWa_e_cWiO“;对于（I i = 0; i &lt;60; i + = 4）{V b = V（l [i] -79，l [i + 1] -79）*。5，e = V（l [ i + 2] -79，l</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">[i + 3] -79）*。5 + b * -1，o = f +（b + e * L（-L（（b + f * -1）％e /（e％e），0）， 1））*-1; d = L（d，o％o）;} d = sq \</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">rtf（d）; V a [] = {V（-11.6），V（11.6）};对于（I i = 2; i-;）{V o = f + a [i] * -1; d = L（d，ox&gt; 0？F \</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">absf（sqrtf（o％o）-2）:( o.y + = oy&gt; 0？-2：2，sqrtf（o％o）））;} d = powf（powf（d，8）+ powf（pz ，</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">8）,. 125）-.5; m = 1; F r = L（-L（B（p，V（-30，-。5，-30），V（30,18,30）），B （p，V（-25.17，-25），V</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">（25,20,25））），B（V（fmodf（fabsf（px），8），py，pz），V（1.5,18.5，-25），V（6.5,20,25）））</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">；如果（r &lt;d）d = r，m = 2； F s = 19.9-py；如果（s &lt;d）d = s，m = 3; R d;}</font> </pre><pre>  <font color="black">IM（V o，V d，V＆h，V＆n）{I m，s =</font> <font color="black">
</font>  <font color="black">0; F t = 0，c;对于（; t &lt;100; t + = c）如果（（c = S（h = o + d * t，m））&lt;。01 || ++ s&gt; 99）R n =！V（S（h + V（.01,0</font> <font color="black">
</font>  <font color="black">），s）-c，S（h + V（0，.01），s）-c，S（h + V（0,0，.01），s）-c），m; R 0;}</font> </pre><pre>  <font color="SkyBlue">VT（V o，V d）{V h，n，r，t =</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">1，l（！V（.6，.6,1））;对于（I b = 3; b-;）{I m = M（o，d，h，n）;如果（！M）中断; if（m == 1）{d = d + n *（</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">n％d * -2）; o = h + d * .1; t = t * .2;}如果（m == 2）{F i = n％l，p = 6.283185 * U（），c = U（），s = sqrtf（1-c），</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">g = nz &lt;0？-1：1，u = -1 /（g + nz），v = nx * ny * u; d = V（v，g + ny * ny * u，-ny）*（cosf （p）* s）+ V（</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">1 + g * nx * nx * u，g * v，-g * nx）*（sinf（p）* s）+ n * sqrtf（c）; o = h + d * .1; t = t *。 2;如果（i&gt; 0 &amp;&amp; M（h</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">+ n * .1，l，h，n）== 3）r = r + t * V（500,400,100）* i;} if（m == 3）{r = r + t * V（50,80,100） ; break;}}</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">R r;}</font> </pre><pre>  <font color="red">I main（）{I w = 960，h = 540，s = 16; V e（-22,5,25），g =！（V（-3,4,0）+ e * -1），l =！V（gz，</font> <font color="red">
</font>  <font color="red">0，-gx）*（1./w），u（gy * lz-gz * ly，gz * lx-gx * lz，gx * ly-gy * lx）; printf（“ P \</font> <font color="red">
</font>  <font color="red">6％d％d 255“，w，h）;对于（I y = h; y-;）对于（I x = w; x-;）{V c;对于（I p = s; p- -;）c = c + T（e</font> <font color="red">
</font>  <font color="red">，！（g + l *（xw / 2 + U（））+ u *（yh / 2 + U（）））））; c = c *（1./s）+ 14/241; V o = c +1; c = V（cx / ox，c。</font> <font color="red">
</font>  <font color="red">y / oy，cz / oz）* 255; printf（“％c％c％c”，（I）cx，（I）cy，（I）cz）;}}</font> </pre><pre>  <font color="LightGray">//安德鲁·肯斯勒（Andrew Kensler）</font> </pre><br> 本文其余部分将详细介绍每个部分： <br>  <font color="fuchsia">■</font> -普通技巧， <font color="blue">■</font> -矢量类， <font color="orange">■</font> -辅助代码， <font color="LimeGreen">■</font> -数据库， <font color="black">■</font> -射线行进， <font color="SkyBlue">■</font> -采样， <font color="red">■</font> -主代码。 <br><br><h2>  #define和typedef的常见技巧 </h2><br><hr><br> 常见的技巧是使用#define和typedef来显着减少代码量。 在这里，我们表示F =浮点数，I =整数，R =返回值，以及O =运算符。 逆向工程是微不足道的。 <br><br><h2>  V级 </h2><br><hr><br> 接下来是V类，我将其重命名为Vec（尽管，正如我们将在下面看到的那样，它也用于以浮点格式存储RGB通道）。 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vec</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, y, z; Vec(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> v = <span class="hljs-number"><span class="hljs-number">0</span></span>) { x = y = z = v; } Vec(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> c = <span class="hljs-number"><span class="hljs-number">0</span></span>) { x = a; y = b; z = c;} Vec <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+(Vec r) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec(x + rx, y + ry, z + rz); } Vec <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*(Vec r) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec(x * rx, y * ry, z * rz); } <span class="hljs-comment"><span class="hljs-comment">// dot product float operator%(Vec r) { return x * rx + y * ry + z * rz; } // inverse square root Vec operator!() {return *this * (1 / sqrtf(*this % *this) );} };</span></span></code> </pre> <br> 请注意，没有减法运算符（-），因此不是使用“ X = A-B”，而是使用“ X = A + B * -1”。 平方根反数在以后方便使用以标准化向量。 <br><br><h2> 主要功能 </h2><br><hr><br>  main（）是唯一无法混淆的字符，因为它是由libc库的_start函数调用的。 通常值得一开始，因为这样做会更容易。 我花了一段时间才弄清首字母的含义，但仍然设法创建了可读的东西。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w = <span class="hljs-number"><span class="hljs-number">960</span></span>, h = <span class="hljs-number"><span class="hljs-number">540</span></span>, samplesCount = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-function"><span class="hljs-function">Vec </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">position</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-22</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">25</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Vec goal = !(Vec(<span class="hljs-number"><span class="hljs-number">-3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + position * <span class="hljs-number"><span class="hljs-number">-1</span></span>); Vec left = !Vec(goal.z, <span class="hljs-number"><span class="hljs-number">0</span></span>, -goal.x) * (<span class="hljs-number"><span class="hljs-number">1.</span></span> / w); <span class="hljs-comment"><span class="hljs-comment">// Cross-product to get the up vector Vec up(goal.y * left.z - goal.z * left.y, goal.z * left.x - goal.x * left.z, goal.x * left.y - goal.y * left.x); printf("P6 %d %d 255 ", w, h); for (int y = h; y--;) for (int x = w; x--;) { Vec color; for (int p = samplesCount; p--;) color = color + Trace(position, !(goal + left * (x - w / 2 + randomVal())+ up * (y - h / 2 + randomVal()))); // Reinhard tone mapping color = color * (1. / samplesCount) + 14. / 241; Vec o = color + 1; color = Vec(color.x / ox, color.y / oy, color.z / oz) * 255; printf("%c%c%c", (int) color.x, (int) color.y, (int) color.z); } }</span></span></code> </pre> <br> 请注意，浮点文字不包含字母“ f”，并且小数部分被丢弃以节省空间。 下面使用相同的技巧，其中删除整数部分（浮点数x = 0.5）。 同样不寻常的是在中断条件内插入了迭代表达式的“ for”构造。 <br><br> 这是光线/路径跟踪器的相当标准的主要功能。 在此设置相机矢量，并为每个像素发射光线。 光线追踪器和路径追踪器之间的区别在于，TP中的每个像素发射了几条光线，这些光线随机地随机移动。 然后，在三个浮动通道R，B，G中累积为像素中的每条射线获得的颜色。 最后，对Reinhardt方法的结果进行色调校正。 <br><br> 最重要的部分是sampleCount，理论上可以将其设置为1以加快渲染和迭代速度。 以下是样本渲染，样本值介于1到2048之间。 <br><br><div class="spoiler">  <b class="spoiler_title">扰流板方向</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/550/e66/b2b/550e66b2b1347f8cafdf18c50d89e40d.png"><br><br>  1个 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f49/724/1f0/f497241f0e3bb43fcc9913d8a2745419.png"><br><br>  2 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f71/3f3/35c/f713f335c2842b995936db1499e307e5.png"><br><br>  4 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b4f/6d4/f56/b4f6d4f56198a64b8e569a62f7159e8a.png"><br><br>  8 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a70/200/3c6/a702003c61d4080c2f92fe84844238cd.png"><br><br>  16 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bcf/0d6/43c/bcf0d643c501839c2506c7c026bc445c.png"><br><br>  32 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f0/5cf/569/8f05cf5690fa3265a1a4fa6f60a35749.png"><br><br>  64 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ebd/c87/660/ebdc87660263ff14eb6bf03a95865f34.png"><br><br>  128 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d17/0d3/1ae/d170d31aed20aeafc54d877ed447a1cc.png"><br><br>  256 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fb9/52c/4df/fb952c4dfd0a4cb14245cedd060dcf05.png"><br><br>  512 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/460/50f/715/46050f71582834ddebbeb29dd86940fc.png"><br><br>  1024 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/947/ea8/88b/947ea888b63c32f0892cc1e25b187bf8.png"><br><br>  2048 </div></div><br><h2> 帮手代码 </h2><br><hr><br> 另一段简单的代码是助手功能。 在这种情况下，我们有一个琐碎的函数min（），一个在[0,1]区间内的随机值生成器以及一个更有趣的boxTest（），它是用于切割世界的构造实体几何（CSG）系统的一部分。 下一节将讨论CSG。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> l, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l &lt; r ? l : r; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randomVal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) rand() / RAND_MAX; } <span class="hljs-comment"><span class="hljs-comment">// Rectangle CSG equation. Returns minimum signed distance from // space carved by lowerLeft vertex and opposite rectangle // vertex upperRight. float BoxTest(Vec position, Vec lowerLeft, Vec upperRight) { lowerLeft = position + lowerLeft * -1; upperRight = upperRight + position * -1; return -min( min( min(lowerLeft.x, upperRight.x), min(lowerLeft.y, upperRight.y) ), min(lowerLeft.z, upperRight.z)); }</span></span></code> </pre> <br><h2> 构造体积几何的功能 </h2><br><hr><br> 代码中没有顶点。 一切都使用CSG功能完成。 如果您不熟悉它们，只需说这些是描述坐标是在对象内部还是外部的函数。 如果函数返回正距离，则该点在对象内部。 负距离表示该点在对象外部。 有许多用于描述不同对象的函数，但是为了简化起见，让我们以一个球体和两个点A和B为例。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56f/424/13a/56f42413a77c51a3d06e12fd4b4b385e.svg" alt="图片"></div><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Signed distance point(p) to sphere(c,r) float testSphere(Vec p, Vec c, float r) { Vec delta = c - p; float distance = sqrtf(delta%delta); return radius - distance; } Vec A {4, 6}; Vec B {3, 2}; Vec C {4, 2}; float r = 2.; testSphere(A, C, r); // == -1 (outside) testSphere(B, C, r); // == 1 (inside)</span></span></code> </pre> <br>  testSphere（）函数对于点A（即在外部）返回-1，对于点B（即在内部）返回1。 远处的符号只是一个技巧，它使您可以获得两条信息，而不是单个值的信息。 可以编写类似类型的函数来描述平行四边形（这正是在BoxTest函数中执行的操作）。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/757/1cd/25b/7571cd25baa7d2f9cfbd01f62e84aef1.svg"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Signed distance point(p) to Box(c1,c2) float testRectangle(Vec p, Vec c1, Vec c2) { c1 = p + c1 * -1; c2 = c2 + position * -1; return min( min( min(c1.x, c2.x), min(c1.y, c2.y)), min(c1.z, c2.z)); } Vec A {3, 3}; Vec B {4, 6}; Vec C1 {2, 2}; Vec C2 {5, 4}; testRectangle(A, C1, C2); // 1.41 (inside) testRectangle(B, C1, C2); // -2.23 (outside)</span></span></code> </pre> <br> 现在让我们看看如果翻转返回值的符号会发生什么。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/017/bd8/dcd017bd89a9e9d3955c94be3645aa20.svg"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Signed distance point(p) to carved box(c1,c2) float testCarveBox(Vec p, Vec c1, Vec c2) { c1 = p + c1 * -1; c2 = c2 + position * -1; return -min( min( min(c1.x, c2.x), min(c1.y, c2.y)), min(c1.z, c2.z)); } Vec A {3, 3}; Vec B {4, 6}; Vec C1 {2, 2}; Vec C2 {5, 4}; testCarveBox(A, C1, C2); // == -1.41 (outside) testCarveBox(B, C1, C2); // == 2.23 (inside)</span></span></code> </pre> <br> 现在我们不描述实体，而是将整个世界声明为实体并在其中切出空白。 功能可以用作建筑用砖，将其组合起来可以描述更复杂的形式。 使用逻辑加法运算符（min函数），我们可以在一对矩形上方切出一对矩形，结果将如下所示。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48b/f78/615/48bf786150f9d37af1f51fd12987162e.svg"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Signed distance point to room float testRoom(Vec p) { Vec C1 {2, 4}; Vec C2 {5, 2}; // Lower room Vec C3 {3, 5}; Vec C4 {4, 4}; // Upper room // min() is the union of the two carved volumes. return min(testCarvedBox(p, C1, C2), testCarvedBox(p, C3, C4)); } Vec A {3, 3}; Vec B {4, 6}; testRoom(A, C1, C2); // == -1.41 (outside) testRoom(B, C1, C2); // == 1.00 (inside)</span></span></code> </pre> <br> 如果您考虑一下，它看起来就像我们正在研究的房间，因为较低的房间正是这样表达的-借助两个平行四边形。 <br><br> 现在，在掌握了CSG的强大知识之后，我们可以返回代码并考虑最难处理的数据库功能。 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HIT_NONE 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HIT_LETTER 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HIT_WALL 2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HIT_SUN 3 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Sample the world using Signed Distance Fields. float QueryDatabase(Vec position, int &amp;hitType) { float distance = 1e9; Vec f = position; // Flattened position (z=0) fz = 0; char letters[15*4+1] = // 15 two points lines "5O5_" "5W9W" "5_9_" // P (without curve) "AOEO" "COC_" "A_E_" // I "IOQ_" "I_QO" // X "UOY_" "Y_]O" "WW[W" // A "aOa_" "aWeW" "a_e_" "cWiO"; // R (without curve) for (int i = 0; i &lt; sizeof(letters); i += 4) { Vec begin = Vec(letters[i] - 79, letters[i + 1] - 79) * .5; Vec e = Vec(letters[i + 2] - 79, letters[i + 3] - 79) * .5 + begin * -1; Vec o = f + (begin + e * min(-min((begin + f * -1) % e / (e % e), 0), 1) ) * -1; distance = min(distance, o % o); // compare squared distance. } distance = sqrtf(distance); // Get real distance, not square distance. // Two curves (for P and R in PixaR) with hard-coded locations. Vec curves[] = {Vec(-11, 6), Vec(11, 6)}; for (int i = 2; i--;) { Vec o = f + curves[i] * -1; distance = min(distance, ox &gt; 0 ? fabsf(sqrtf(o % o) - 2) : (oy += oy &gt; 0 ? -2 : 2, sqrtf(o % o)) ); } distance = powf(powf(distance, 8) + powf(position.z, 8), .125) - .5; hitType = HIT_LETTER; float roomDist ; roomDist = min(// min(A,B) = Union with Constructive solid geometry //-min carves an empty space -min(// Lower room BoxTest(position, Vec(-30, -.5, -30), Vec(30, 18, 30)), // Upper room BoxTest(position, Vec(-25, 17, -25), Vec(25, 20, 25)) ), BoxTest( // Ceiling "planks" spaced 8 units apart. Vec(fmodf(fabsf(position.x), 8), position.y, position.z), Vec(1.5, 18.5, -25), Vec(6.5, 20, 25) ) ); if (roomDist &lt; distance) distance = roomDist, hitType = HIT_WALL; float sun = 19.9 - position.y ; // Everything above 19.9 is light source. if (sun &lt; distance)distance = sun, hitType = HIT_SUN; return distance; }</span></span></span></span></code> </pre> <br> 您可以在此处看到“切出”平行四边形的功能，其中仅使用两个矩形来构建整个房间（我们的大脑负责其余部分，它代表墙壁）。 水平阶梯是使用余数除法的稍微复杂一些的CSG功能。 最后，单词PIXAR的字母由15行组成，带有“原点/增量”对，以及字母P和R的曲线的两种特殊情况。 <br><br><h2> 雷行军 </h2><br><hr><br> 有了描述世界的CSG函数数据库，我们就可以跳过main（）函数中发出的所有光线。 射线行进使用距离功能。 这意味着采样位置会向前移动一定距离，直到最近的障碍物。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Perform signed sphere marching // Returns hitType 0, 1, 2, or 3 and update hit position/normal int RayMarching(Vec origin, Vec direction, Vec &amp;hitPos, Vec &amp;hitNorm) { int hitType = HIT_NONE; int noHitCount = 0; float d; // distance from closest object in world. // Signed distance marching for (float total_d=0; total_d &lt; 100; total_d += d) if ((d = QueryDatabase(hitPos = origin + direction * total_d, hitType)) &lt; .01 || ++noHitCount &gt; 99) return hitNorm = !Vec(QueryDatabase(hitPos + Vec(.01, 0), noHitCount) - d, QueryDatabase(hitPos + Vec(0, .01), noHitCount) - d, QueryDatabase(hitPos + Vec(0, 0, .01), noHitCount) - d) , hitType; // Weird return statement where a variable is also updated. return 0; }</span></span></code> </pre> <br> 基于距离的光线行进的思想是将距离向前移动到最近的对象。 最后，光束将非常接近表面，因此可以将其视为入射点。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e99/774/398/e997743989aa1cb22fb65e6d5d8e93f2.svg"></div><br> 请注意，光线行进不会返回与曲面的真实相交，而是返回近似值。 这就是为什么当d &lt;0.01f时行进在代码中停止的原因。 <br><br><h2> 放在一起：抽样 </h2><br><hr><br> 路径跟踪器的研究即将完成。 我们缺少将main（）函数与ray marcher连接起来的桥梁。 最后一部分（我将其重命名为“迹线”）是“大脑”，光线在其中反弹或停止，具体取决于它们遇到的情况。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Trace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Vec origin, Vec direction)</span></span></span><span class="hljs-function"> </span></span>{ Vec sampledPosition, normal, color, attenuation = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-function">Vec </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lightDirection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(!Vec(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">.6</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">.6</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// Directional light for (int bounceCount = 3; bounceCount--;) { int hitType = RayMarching(origin, direction, sampledPosition, normal); if (hitType == HIT_NONE) break; // No hit. This is over, return color. if (hitType == HIT_LETTER) { // Specular bounce on a letter. No color acc. direction = direction + normal * ( normal % direction * -2); origin = sampledPosition + direction * 0.1; attenuation = attenuation * 0.2; // Attenuation via distance traveled. } if (hitType == HIT_WALL) { // Wall hit uses color yellow? float incidence = normal % lightDirection; float p = 6.283185 * randomVal(); float c = randomVal(); float s = sqrtf(1 - c); float g = normal.z &lt; 0 ? -1 : 1; float u = -1 / (g + normal.z); float v = normal.x * normal.y * u; direction = Vec(v, g + normal.y * normal.y * u, -normal.y) * (cosf(p) * s) + Vec(1 + g * normal.x * normal.x * u, g * v, -g * normal.x) * (sinf(p) * s) + normal * sqrtf(c); origin = sampledPosition + direction * .1; attenuation = attenuation * 0.2; if (incidence &gt; 0 &amp;&amp; RayMarching(sampledPosition + normal * .1, lightDirection, sampledPosition, normal) == HIT_SUN) color = color + attenuation * Vec(500, 400, 100) * incidence; } if (hitType == HIT_SUN) { // color = color + attenuation * Vec(50, 80, 100); break; // Sun Color } } return color; }</span></span></code> </pre> <br> 我对该功能进行了一些实验，以更改允许的最大光束反射数量。 值“ 2”赋予字母令人惊讶的美丽漆面Vantablack颜色<sup>[4]</sup> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d10/940/a3e/d10940a3ed7efab3271097904ce50d77.png"></div><br>  <i>1个</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0c/8b2/c3b/e0c8b2c3b249057b1f5fd0d166e12014.png"></div><br>  <i>2</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fb9/52c/4df/fb952c4dfd0a4cb14245cedd060dcf05.png"></div><br>  <i>3</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65c/2f5/716/65c2f5716578caaa2fcc454a49376578.png"></div><br>  <i>4</i> <br><br><h2> 完全清理的源代码 </h2><br><hr><br> 为了将所有内容放在一起，我创建了一个完全干净的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">源代码</a> 。 <br><br><h2> 参考文献 </h2><br><hr><br>  [1]来源： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">lexfrench Twitter于2018年10月8日发布。</a> <br><br>  [2]来源： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">维基百科：NetPBM图像格式</a> <br><br>  [3]资料来源： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在功能最强大的MacBook Pro上进行的可视化，2017年</a> <br><br>  [4]来源： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">维基百科：Vantablack</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN434528/">https://habr.com/ru/post/zh-CN434528/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN434514/index.html">用于“渗透测试者”的“秘密” DPAPI或DPAPI</a></li>
<li><a href="../zh-CN434516/index.html">一种处理您的职业理想的简便方法。</a></li>
<li><a href="../zh-CN434518/index.html">掌声和欢呼声：Apple商店中经过精心控制的戏剧</a></li>
<li><a href="../zh-CN434522/index.html">任务证明模式和反模式</a></li>
<li><a href="../zh-CN434524/index.html">Kubernetes通过初学者的眼光进入</a></li>
<li><a href="../zh-CN434530/index.html">默认日历，LDAP中的修复程序以及Zimbra 8.8.11中的其他创新</a></li>
<li><a href="../zh-CN434532/index.html">一个项目的故事：当团队没有高级开发人员时</a></li>
<li><a href="../zh-CN434534/index.html">ONYX BOOX“我的第一本书”：对母婴无害阅读</a></li>
<li><a href="../zh-CN434538/index.html">太空之战：卫星互联网市场正在发生什么</a></li>
<li><a href="../zh-CN434540/index.html">与将被机器人取代的人怎么办？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>