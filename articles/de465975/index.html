<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüöí üë¶üèø üë®‚Äçüåæ SQL-Handbuch: Besseres Schreiben von Abfragen (Teil 2) üÄÑÔ∏è üí∑ ‚ùé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fortsetzung Artikel SQL-Handbuch: Besseres Schreiben von Abfragen (Teil 1) 

 Von der Anfrage bis zu den Ausf√ºhrungspl√§nen 
 Zu wissen, dass Antimuste...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SQL-Handbuch: Besseres Schreiben von Abfragen (Teil 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465975/">  Fortsetzung Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SQL-Handbuch: Besseres Schreiben von Abfragen (Teil 1)</a> <br><br><h2>  Von der Anfrage bis zu den Ausf√ºhrungspl√§nen </h2><br><img width="40%" align="left" src="https://habrastorage.org/webt/0i/6s/ac/0i6sacyjz9j7pwvkqhfnr6ryjby.jpeg">  Zu wissen, dass Antimuster nicht statisch sind und sich im Zuge Ihres Wachstums als SQL-Entwickler weiterentwickeln, und die Tatsache, dass beim √úberlegen von Alternativen viele Dinge zu beachten sind, bedeutet auch, dass es ziemlich schwierig sein kann, Antimuster zu vermeiden und Abfragen neu zu schreiben Aufgabe.  Jede Hilfe kann n√ºtzlich sein, weshalb ein strukturierterer Ansatz zur Abfrageoptimierung mit einigen Tools am effektivsten sein kann. <br><br>  Es sollte auch beachtet werden, dass einige der im letzten Abschnitt erw√§hnten Antimuster auf Leistungsproblemen beruhen, wie z. B. den Operatoren <code>AND</code> , <code>OR</code> und <code>NOT</code> und deren Abwesenheit bei der Verwendung von Indizes.  Das Nachdenken √ºber Leistung erfordert nicht nur einen strukturierteren, sondern auch einen tieferen Ansatz. <br><br>  Dieser strukturierte und detaillierte Ansatz basiert jedoch haupts√§chlich auf dem Abfrageplan, der, wie Sie sich erinnern, das Ergebnis einer Abfrage ist, die zuerst in einen ‚ÄûAnalysebaum‚Äú oder einen ‚ÄûAnalysebaum‚Äú analysiert wurde und genau bestimmt, welcher Algorithmus wird f√ºr jede Operation verwendet und wie ihre Ausf√ºhrung koordiniert wird. <br><a name="habracut"></a><br><h2>  Abfrageoptimierung </h2><br>  Wie Sie in der Einf√ºhrung lesen, m√ºssen Sie m√∂glicherweise Pl√§ne √ºberpr√ºfen und einrichten, die vom Optimierer manuell kompiliert werden.  In solchen F√§llen m√ºssen Sie Ihre Anfrage erneut analysieren, indem Sie sich den Anfrageplan ansehen. <br><br>  Um auf diesen Plan zugreifen zu k√∂nnen, m√ºssen Sie die vom Datenbankverwaltungssystem bereitgestellten Tools verwenden.  Die folgenden Tools stehen Ihnen m√∂glicherweise zur Verf√ºgung: <br><br><ul><li>  Einige Pakete enthalten Tools, die eine grafische Darstellung des Abfrageplans generieren.  Betrachten Sie das folgende Beispiel: <br><br><img src="https://habrastorage.org/webt/1y/ff/wa/1yffwafdtmxfgdeanejdy5wjelo.gif"><br></li><li>  Andere Tools bieten eine Textbeschreibung des Abfrageplans.  Ein Beispiel ist die <code>EXPLAIN PLAN</code> Anweisung in Oracle, aber der Name der Anweisung h√§ngt von dem DBMS ab, mit dem Sie arbeiten.  An anderer Stelle finden Sie <code>EXPLAIN</code> (MySQL, PostgreSQL) oder <code>EXPLAIN QUERY PLAN</code> (SQLite). </li></ul><br>  <b>Bitte beachten Sie,</b> dass Sie bei der Arbeit mit PostgreSQL zwischen <code>EXPLAIN</code> unterscheiden k√∂nnen. Hier erhalten Sie einfach eine Beschreibung, wie der Planer die Abfrage ausf√ºhren <code>EXPLAIN ANALYZE</code> ohne sie auszuf√ºhren, w√§hrend <code>EXPLAIN ANALYZE</code> die Abfrage tats√§chlich ausf√ºhrt und Ihnen die Analyse zur√ºckgibt erwartete und tats√§chliche Anfragepl√§ne.  Im Allgemeinen ist ein realer Ausf√ºhrungsplan ein Plan, in dem eine Anforderung tats√§chlich ausgef√ºhrt wird, w√§hrend ein Evaluierungsausf√ºhrungsplan bestimmt, was er tun wird, ohne die Anforderung zu erf√ºllen.  Obwohl dies logisch √§quivalent ist, ist der tats√§chliche Ausf√ºhrungsplan viel n√ºtzlicher, da er zus√§tzliche Informationen und Statistiken dar√ºber enth√§lt, was wirklich passiert ist, als die Anforderung ausgef√ºhrt wurde. <br><br>  Im Rest dieses Abschnitts erfahren Sie mehr √ºber <code>EXPLAIN</code> und <code>ANALYZE</code> sowie deren Verwendung, um weitere Informationen zum Abfrageplan und seiner m√∂glichen Leistung zu erhalten.  Beginnen Sie dazu mit einigen Beispielen, in denen Sie mit zwei Tabellen arbeiten: <code>one_million</code> und <code>half_million</code> . <br><br>  Sie k√∂nnen die aktuellen Informationen mit <code>EXPLAIN</code> aus der Tabelle <code>EXPLAIN</code> .  Stellen Sie sicher, dass Sie es direkt √ºber der Anforderung platzieren. Nach der Ausf√ºhrung wird der Abfrageplan an Sie zur√ºckgegeben: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> one_million; QUERY PLAN ____________________________________________________ Seq Scan on one_million (cost=0.00..18584.82 rows=1025082 width=36) (1 row)</code> </pre> <br>  In diesem Fall sehen Sie, dass die Kosten f√ºr die Anforderung <code>0.00..18584.82</code> und die Anzahl der Zeilen <code>1025082</code> betr√§gt.  Die Breite der Spaltenanzahl betr√§gt <code>36</code> . <br><br>  Dar√ºber hinaus k√∂nnen Sie Statistiken mit <code>ANALYZE</code> . <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> one_million; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> one_million; QUERY PLAN ____________________________________________________ Seq Scan on one_million (cost=0.00..18334.00 rows=1000000 width=37) (1 row)</code> </pre> <br>  Neben <code>EXPLAIN</code> und <code>ANALYZE</code> k√∂nnen Sie mit <code>EXPLAIN ANALYZE</code> auch die tats√§chliche Laufzeit <code>EXPLAIN ANALYZE</code> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> one_million; QUERY PLAN ___________________________________________________________ Seq Scan on one_million (cost=0.00..18334.00 rows=1000000 width=37) (actual time=0.015..1207.019 rows=1000000 loops=1) Total runtime: 2320.146 ms (2 rows)</code> </pre> <br>  Der Nachteil der Verwendung von <code>EXPLAIN ANALYZE</code> besteht darin, dass die Abfrage tats√§chlich ausgef√ºhrt wird. <code>EXPLAIN ANALYZE</code> also vorsichtig damit! <br><br>  Bisher sind alle Algorithmen, die Sie gesehen haben, <code>Seq Scan</code> (Sequential Scan) oder Full Table Scan: Dies ist ein Scan, der in einer Datenbank durchgef√ºhrt wird, in der jede Zeile der gescannten Tabelle in serieller Reihenfolge gelesen und die gefundenen Spalten √ºberpr√ºft werden Einhaltung der Bedingung oder nicht.  In Bezug auf die Leistung sind sequentielle Scans definitiv nicht der beste Ausf√ºhrungsplan, da Sie immer noch einen vollst√§ndigen Tabellenscan durchf√ºhren.  Dies ist jedoch nicht so schlimm, wenn die Tabelle nicht in den Speicher passt: Sequentielle Lesevorg√§nge sind selbst auf langsamen Festplatten ziemlich schnell. <br><br>  Sie werden sp√§ter mehr dar√ºber erfahren, wenn wir √ºber das Scannen von Indizes sprechen. <br><br>  Es gibt jedoch andere Algorithmen.  Nehmen Sie zum Beispiel diesen Abfrageplan f√ºr eine Verbindung: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> one_million <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> half_million <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (one_million.counter=half_million.counter); QUERY PLAN _________________________________________________________________ Hash Join (cost=15417.00..68831.00 rows=500000 width=42) (actual time=1241.471..5912.553 rows=500000 loops=1) Hash Cond: (one_million.counter = half_million.counter) -&gt; Seq Scan on one_million (cost=0.00..18334.00 rows=1000000 width=37) (actual time=0.007..1254.027 rows=1000000 loops=1) -&gt; Hash (cost=7213.00..7213.00 rows=500000 width=5) (actual time=1241.251..1241.251 rows=500000 loops=1) Buckets: 4096 Batches: 16 Memory Usage: 770kB -&gt; Seq Scan on half_million (cost=0.00..7213.00 rows=500000 width=5) (actual time=0.008..601.128 rows=500000 loops=1) Total runtime: 6468.337 ms</code> </pre> <br>  Sie sehen, dass der Abfrageoptimierer hier <code>Hash Join</code> hat!  Denken Sie an diesen Vorgang, da Sie ihn ben√∂tigen, um die zeitliche Komplexit√§t Ihrer Anfrage zu bewerten.  Beachten Sie <code>half_million.counter</code> , dass in <code>half_million.counter</code> kein Index <code>half_million.counter</code> , den wir im folgenden Beispiel hinzuf√ºgen: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> half_million(counter); <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> one_million <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> half_million <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (one_million.counter=half_million.counter); QUERY PLAN ________________________________________________________________ <span class="hljs-keyword"><span class="hljs-keyword">Merge</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Join</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">4.12</span></span>.<span class="hljs-number"><span class="hljs-number">.37650</span></span><span class="hljs-number"><span class="hljs-number">.65</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">500000</span></span> width=<span class="hljs-number"><span class="hljs-number">42</span></span>) (actual <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>=<span class="hljs-number"><span class="hljs-number">0.033</span></span>.<span class="hljs-number"><span class="hljs-number">.3272</span></span><span class="hljs-number"><span class="hljs-number">.940</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">500000</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">Merge</span></span> Cond: (one_million.counter = half_million.counter) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Scan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> one_million_counter_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> one_million (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">0.00</span></span>.<span class="hljs-number"><span class="hljs-number">.32129</span></span><span class="hljs-number"><span class="hljs-number">.34</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">1000000</span></span> width=<span class="hljs-number"><span class="hljs-number">37</span></span>) (actual <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>=<span class="hljs-number"><span class="hljs-number">0.011</span></span>.<span class="hljs-number"><span class="hljs-number">.694</span></span><span class="hljs-number"><span class="hljs-number">.466</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">500001</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Scan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> half_million_counter_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> half_million (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">0.00</span></span>.<span class="hljs-number"><span class="hljs-number">.14120</span></span><span class="hljs-number"><span class="hljs-number">.29</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">500000</span></span> width=<span class="hljs-number"><span class="hljs-number">5</span></span>) (actual <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>=<span class="hljs-number"><span class="hljs-number">0.010</span></span>.<span class="hljs-number"><span class="hljs-number">.683</span></span><span class="hljs-number"><span class="hljs-number">.674</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">500000</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) Total runtime: <span class="hljs-number"><span class="hljs-number">3833.310</span></span> ms (<span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>)</code> </pre> <br>  Sie sehen, dass das Abfrageoptimierungsprogramm beim Erstellen des Index jetzt entschieden hat, beim Scannen des <code>Index Scan</code> Index den <code>Merge join</code> zu verwenden. <br><br>  <b>Beachten Sie</b> den Unterschied zwischen Index-Scannen und vollst√§ndigem Tabellen-Scannen oder sequentiellem Scannen: Das erste, auch als "Tabellen-Scannen" bezeichnet, durchsucht die Daten oder Seiten des Index nach den entsprechenden Datens√§tzen, w√§hrend das zweite jede Zeile der Tabelle durchsucht. <br><br>  Sie sehen, dass die Gesamtlaufzeit abgenommen hat und die Leistung besser sein sollte, aber es gibt zwei Index-Scans, wodurch der Speicher hier wichtiger wird, insbesondere wenn die Tabelle nicht in sie passt.  In solchen F√§llen m√ºssen Sie zuerst einen vollst√§ndigen Index-Scan durchf√ºhren, der mit schnellen sequentiellen Lesevorg√§ngen durchgef√ºhrt wird und kein Problem darstellt. Anschlie√üend m√ºssen Sie jedoch viele zuf√§llige Lesevorg√§nge ausf√ºhren, um Zeilen nach Indexwert auszuw√§hlen.  Dies sind zuf√§llige Leseoperationen, die normalerweise mehrere Gr√∂√üenordnungen langsamer sind als sequentielle.  In diesen F√§llen erfolgt ein vollst√§ndiger Tabellenscan tats√§chlich schneller als ein vollst√§ndiger Indexscan. <br><br>  <b>Tipp:</b> Wenn Sie mehr √ºber EXPLAIN erfahren oder Beispiele genauer betrachten m√∂chten, lesen Sie Guillaume Lelarge <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">'s Understanding Explain</a> . <br><br><h2>  Zeitkomplexit√§t und Big O. </h2><br>  Nachdem Sie den Abfrageplan kurz durchgesehen haben, k√∂nnen Sie sich eingehender mit der Theorie der Rechenkomplexit√§t befassen und formeller √ºber die Leistung nachdenken.  Dies ist ein Bereich der theoretischen Informatik, der sich unter anderem auf die Klassifizierung von Rechenproblemen in Abh√§ngigkeit von ihrer Komplexit√§t konzentriert;  Diese Rechenprobleme k√∂nnen Algorithmen sein, aber auch Abfragen. <br><br>  Bei Abfragen werden sie jedoch nicht unbedingt nach ihrer Komplexit√§t klassifiziert, sondern in Abh√§ngigkeit von der Zeit, die erforderlich ist, um sie abzuschlie√üen und Ergebnisse zu erzielen.  Dies wird als Zeitkomplexit√§t bezeichnet, und Sie k√∂nnen die gro√üe O-Notation verwenden, um diese Art von Komplexit√§t zu formulieren oder zu messen. <br><br>  Mit der Bezeichnung big O dr√ºcken Sie die Laufzeit in Bezug darauf aus, wie schnell sie relativ zur Eingabe w√§chst, wenn die Eingabe beliebig gro√ü wird.  Die gro√üe O-Notation schlie√üt Koeffizienten und Elemente niedrigerer Ordnung aus, sodass Sie sich auf den wichtigen Teil der Ausf√ºhrungszeit Ihrer Abfrage konzentrieren k√∂nnen: die Wachstumsrate.  Wenn sie auf diese Weise ausgedr√ºckt werden und die Koeffizienten und Terme niedrigerer Ordnung verwerfen, sagen sie, dass die Zeitkomplexit√§t asymptotisch beschrieben wird.  Dies bedeutet, dass die Eingabegr√∂√üe unendlich ist. <br><br>  In einer Datenbanksprache bestimmt die Komplexit√§t, wie lange es dauert, eine Abfrage abzuschlie√üen, wenn die Gr√∂√üe der Datentabellen und damit die Datenbank w√§chst. <br><br>  <b>Bitte beachten Sie,</b> dass die Gr√∂√üe Ihrer Datenbank nicht nur durch die Zunahme der Datenmenge in den Tabellen zunimmt, sondern auch durch die Tatsache, dass Indizes vorhanden sind. <br><br>  Sch√§tzen der zeitlichen Komplexit√§t Ihres Abfrageplans <br><br>  Wie Sie bereits gesehen haben, bestimmt der Ausf√ºhrungsplan unter anderem, welcher Algorithmus f√ºr jede Operation verwendet wird. Auf diese Weise k√∂nnen Sie jede Ausf√ºhrungszeit f√ºr Abfragen als Funktion der Gr√∂√üe der im Abfrageplan enthaltenen Tabelle, die als Komplexit√§tsfunktion bezeichnet wird, logisch ausdr√ºcken.  Mit anderen Worten, Sie k√∂nnen die gro√üe O-Notation und den Ausf√ºhrungsplan verwenden, um die Komplexit√§t und Leistung der Abfrage zu bewerten. <br><br>  In den folgenden Abschnitten erhalten Sie einen √úberblick √ºber die vier Arten der Zeitkomplexit√§t und einige Beispiele daf√ºr, wie die Zeitkomplexit√§t von Abfragen je nach Kontext, in dem sie ausgef√ºhrt werden, variieren kann. <br><br>  Hinweis: Indizes sind Teil dieser Geschichte! <br><br>  <b>Es ist jedoch zu beachten,</b> dass es unterschiedliche Arten von Indizes, unterschiedliche Ausf√ºhrungspl√§ne und unterschiedliche Implementierungen f√ºr unterschiedliche Datenbanken gibt. Daher sind die unten aufgef√ºhrten vor√ºbergehenden Schwierigkeiten sehr allgemein und k√∂nnen je nach bestimmten Einstellungen variieren. <br><br><h3>  O (1): Konstante Zeit </h3><br>  Sie sagen, dass ein Algorithmus in konstanter Zeit arbeitet, wenn er unabh√§ngig von der Gr√∂√üe der Eingabedaten dieselbe Zeit ben√∂tigt.  Wenn es um eine Abfrage geht, wird sie in konstanter Zeit ausgef√ºhrt, wenn unabh√§ngig von der Gr√∂√üe der Tabelle dieselbe Zeit ben√∂tigt wird. <br><br>  Diese Art der Abfrage ist nicht wirklich √ºblich, aber hier ist ein solches Beispiel: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP <span class="hljs-number"><span class="hljs-number">1</span></span> t.* <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t</code> </pre> <br>  Die zeitliche Komplexit√§t ist konstant, da eine beliebige Zeile aus der Tabelle ausgew√§hlt wird.  Daher sollte die Zeitdauer nicht von der Gr√∂√üe der Tabelle abh√§ngen. <br><br><h3>  Lineare Zeit: O (n) </h3><br>  Sie sagen, dass der Algorithmus in linearer Zeit arbeitet, wenn seine Ausf√ºhrungszeit direkt proportional zur Gr√∂√üe der Eingabedaten ist, dh die Zeit linear mit der Gr√∂√üe der Eingabedaten zunimmt.  F√ºr Datenbanken bedeutet dies, dass die Ausf√ºhrungszeit direkt proportional zur Gr√∂√üe der Tabelle ist: Wenn die Anzahl der Zeilen in der Tabelle zunimmt, erh√∂ht sich die Ausf√ºhrungszeit der Abfrage. <br><br>  Ein Beispiel ist eine Abfrage mit einer <code>WHERE</code> f√ºr eine nicht indizierte Spalte: Ein vollst√§ndiger Tabellenscan oder <code>Seq Scan</code> ist erforderlich, was zu einer Komplexit√§t der O (n) -Zeit f√ºhrt.  Dies bedeutet, dass jede Zeile gelesen werden muss, um die Zeile mit der gew√ºnschten Kennung (ID) zu finden.  Sie haben √ºberhaupt keine Einschr√§nkungen, daher m√ºssen Sie jede Zeile z√§hlen, auch wenn die erste Zeile der Bedingung entspricht. <br><br>  Betrachten Sie auch das folgende Abfragebeispiel, das eine O (n) <code>i_id</code> wenn f√ºr das Feld <code>i_id</code> kein Index <code>i_id</code> ist: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> i_id <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> item;</code> </pre> <br><ul><li>  Das Vorstehende bedeutet auch, dass andere Abfragen, wie z. B. Abfragen zur Berechnung der Anzahl der Zeilen, <code>COUNT (*) FROM TABLE;</code>  hat eine zeitliche Komplexit√§t von <i>O (n)</i> , da ein vollst√§ndiger Tabellenscan erforderlich ist, da die Gesamtzahl der Zeilen nicht f√ºr die Tabelle gespeichert wurde.  Andernfalls w√§re die zeitliche Komplexit√§t √§hnlich wie bei <i>O (1)</i> . <br></li></ul><br>  Die lineare Laufzeit h√§ngt eng mit der Laufzeit von Pl√§nen mit Tabellenverkn√ºpfungen zusammen.  Hier einige Beispiele: <br><br><ul><li>  Der Hash-Join hat die erwartete Komplexit√§t von O (M + N). Der klassische Hash-Join-Algorithmus zum internen Verbinden von zwei Tabellen bereitet zuerst die Hash-Tabelle der kleineren Tabelle vor.  Hash-Tabelleneintr√§ge bestehen aus einem Verbindungsattribut und seiner Zeichenfolge.  Auf die Hash-Tabelle wird zugegriffen, indem die Hash-Funktion auf das Verbindungsattribut angewendet wird.  Sobald die Hash-Tabelle erstellt ist, wird eine gro√üe Tabelle gescannt und die entsprechenden Zeilen aus der kleineren Tabelle werden durch Durchsuchen der Hash-Tabelle gefunden. </li><li>  Zusammenf√ºhrungsverkn√ºpfungen haben normalerweise eine O (M + N) -Komplexit√§t, h√§ngen jedoch stark von den Verkn√ºpfungsspaltenindizes ab und, falls kein Index vorhanden ist, davon, ob die Zeilen nach den im Verkn√ºpfungen verwendeten Schl√ºsseln sortiert sind: <ul><li>  Wenn beide Tabellen nach den im Join verwendeten Schl√ºsseln sortiert sind, hat die Abfrage eine zeitliche Komplexit√§t von O (M + N). </li><li>  Wenn beide Tabellen einen Index f√ºr verkn√ºpfte Spalten haben, unterst√ºtzt der Index diese Spalten bereits in der angegebenen Reihenfolge, und eine Sortierung ist nicht erforderlich.  Die Schwierigkeit wird O (M + N) sein. </li><li>  Wenn keine der Tabellen einen Index f√ºr verbundene Spalten hat, m√ºssen Sie zuerst beide Tabellen sortieren, damit die Komplexit√§t wie O aussieht (M log M + N log N). </li><li>  Wenn nur eine der Tabellen einen Index f√ºr die verbundenen Spalten hat, muss nur die Tabelle ohne Index sortiert werden, bevor der Verkn√ºpfungsschritt ausgef√ºhrt wird, damit die Komplexit√§t wie O aussieht (M + N log N). </li></ul></li><li>  Bei verschachtelten Verkn√ºpfungen betr√§gt die Komplexit√§t normalerweise O (MN).  Dieser Join ist effektiv, wenn eine oder beide Tabellen extrem klein sind (z. B. weniger als 10 Datens√§tze). Dies ist eine sehr h√§ufige Situation bei der Auswertung von Abfragen, da einige Unterabfragen so geschrieben werden, dass sie nur eine Zeile zur√ºckgeben. </li></ul><br>  <b>Denken Sie daran: Ein</b> verschachtelter Join ist ein Join, der jeden Datensatz in einer Tabelle mit jedem Datensatz in einer anderen vergleicht. <br><br><h3>  Logarithmische Zeit: O (log (n)) </h3><br>  Es wird gesagt, dass ein Algorithmus in logarithmischer Zeit arbeitet, wenn seine Ausf√ºhrungszeit proportional zum Logarithmus der Eingabegr√∂√üe ist;  F√ºr Abfragen bedeutet dies, dass sie ausgef√ºhrt werden, wenn die Ausf√ºhrungszeit proportional zum Logarithmus der Datenbankgr√∂√üe ist. <br><br>  Diese logarithmische Zeitkomplexit√§t gilt f√ºr Abfragepl√§ne, bei denen ein <code>Index Scan</code> oder ein Clustered-Index gescannt wird.  Ein Clustered-Index ist ein Index, bei dem die endg√ºltige Indexebene die tats√§chlichen Zeilen der Tabelle enth√§lt.  Ein Clustered-Index √§hnelt jedem anderen Index: Er wird in einer oder mehreren Spalten definiert.  Sie bilden einen Indexschl√ºssel.  Der Clustering-Schl√ºssel sind die Schl√ºsselspalten eines Clustered-Index.  Das Scannen eines Clustered-Index ist im Grunde das Lesen Ihres DBMS f√ºr eine Zeile oder Zeilen von oben nach unten in einem Clustered-Index. <br><br>  Betrachten Sie das folgende <code>i_id</code> , in dem ein Index f√ºr <code>i_id</code> und der normalerweise zu einer Komplexit√§t von O (log (n)) f√ºhrt: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> i_stock <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> i_id = N;</code> </pre> <br>  Beachten Sie, dass ohne Index die zeitliche Komplexit√§t O (n) w√§re. <br><br><h3>  Quadratische Zeit: O (n ^ 2) </h3><br>  Es wird angenommen, dass der Algorithmus in quadratischer Zeit ausgef√ºhrt wird, wenn seine Ausf√ºhrungszeit proportional zum Quadrat der Eingabegr√∂√üe ist.  F√ºr Datenbanken bedeutet dies wiederum, dass die Ausf√ºhrungszeit der Abfrage proportional zum Quadrat der Datenbankgr√∂√üe ist. <br><br>  Ein m√∂gliches Beispiel f√ºr eine quadratische Zeitkomplexit√§tsabfrage ist das Folgende: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> item, author <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> item.i_a_id=author.a_id</code> </pre> <br>  Die minimale Komplexit√§t kann O (n log (n)) sein, aber die maximale Komplexit√§t kann O (n ^ 2) sein, basierend auf den Indexinformationen der Verbindungsattribute. <br><br>  Zusammenfassend k√∂nnen Sie sich auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das folgende Spickzettel</a> ansehen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">um die</a> Abfrageleistung anhand ihrer zeitlichen Komplexit√§t und ihrer Effektivit√§t zu bewerten: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dk/cq/fh/dkcqfhsmh_fxl7gorardyts9ptu.png"></div><br><h2>  SQL-Optimierung </h2><br>  Aufgrund des Abfrageausf√ºhrungsplans und der zeitlichen Komplexit√§t k√∂nnen Sie Ihre SQL-Abfrage weiter anpassen.  Sie k√∂nnen beginnen, indem Sie sich auf die folgenden Punkte konzentrieren: <br><br><ul><li>  Ersetzen Sie unn√∂tige vollst√§ndige Tabellenscans durch Indexscans. </li><li>  Stellen Sie sicher, dass die optimale Verkn√ºpfungsreihenfolge angewendet wird. </li><li>  Stellen Sie sicher, dass die Indizes optimal genutzt werden.  Und </li><li>  Das Zwischenspeichern von Volltext-Scans kleiner Tabellen (Cache von Volltabellen-Scans kleiner Tabellen) wird verwendet. </li></ul><br><h2>  Weitere Verwendung von SQL </h2><br>  Gl√ºckwunsch!  Sie sind am Ende dieses Artikels angelangt, in dem Sie nur einen kleinen Einblick in die Leistung von SQL-Abfragen erhalten haben.  Ich hoffe, Sie haben weitere Informationen zu Antipatterns, dem Abfrageoptimierer und den Tools, mit denen Sie die Komplexit√§t Ihres Abfrageplans analysieren, bewerten und interpretieren k√∂nnen.  Sie haben jedoch noch so viel zu entdecken!  Wenn Sie mehr wissen m√∂chten, lesen Sie das Buch ‚ÄûDatabase Management Systems‚Äú von R. Ramakrishnan und J. Gehrke. <br><br>  Schlie√ülich m√∂chte ich Ihnen in diesem Zitat StackOverflow nicht verweigern: <br><blockquote>  Mein Lieblings-Antimuster √ºberpr√ºft Ihre Anfragen nicht. <br><br>  Es gilt jedoch, wenn: <br><br><ul><li>  Ihre Abfrage enth√§lt mehr als eine Tabelle. </li><li>  Sie denken, dass Sie das optimale Design f√ºr die Anforderung haben, versuchen jedoch nicht, Ihre Annahmen zu √ºberpr√ºfen. </li><li>  Sie akzeptieren die erste Arbeitsanforderung, ohne zu wissen, wie nahe sie am Optimum liegt. </li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de465975/">https://habr.com/ru/post/de465975/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de465959/index.html">Stammbaum in git</a></li>
<li><a href="../de465961/index.html">Lernen Sie selbst Internet-Marketing: √úber 50 kostenlose Kurse</a></li>
<li><a href="../de465963/index.html">Gehaltsbiographie in Deutschland 2019</a></li>
<li><a href="../de465969/index.html">Politische Korrektheit durchdringt Russland durch B√ºcher √ºber das Entwerfen von Chips auf SystemVerilog f√ºr Nicht-Anf√§nger</a></li>
<li><a href="../de465973/index.html">10 beliebtesten Videoberichte vom 404fest 2018</a></li>
<li><a href="../de465977/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 31. CDP, Syslog und NTP</a></li>
<li><a href="../de465979/index.html">Denken Sie daran, alles ^ W ist genau das, was Sie brauchen. Erfahrung mit Anki. Teil 1 (einleitend, vorletzt)</a></li>
<li><a href="../de465981/index.html">Meine IBM DB2 Express-C-Verwaltungserfahrung bei Verwendung mit 1C: Enterprise</a></li>
<li><a href="../de465983/index.html">Intel Comet Lake: etwas 14 nm in der zehnten Generation</a></li>
<li><a href="../de465985/index.html">Wir beschleunigen die verteilte Verarbeitung gro√üer Graphen nicht nur mit probabilistischen Datenstrukturen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>