<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¶ üë®üèø‚Äçü§ù‚Äçüë®üèº üïµüèΩ Tratamento de erro unificado (op√ß√£o C ++ para microcontroladores) üòí ‚ñ´Ô∏è üôÜ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ao desenvolver software para microcontroladores em C ++, muitas vezes √© poss√≠vel encontrar o fato de que o uso da biblioteca padr√£o pode levar a custo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tratamento de erro unificado (op√ß√£o C ++ para microcontroladores)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441956/"> Ao desenvolver software para microcontroladores em C ++, muitas vezes √© poss√≠vel encontrar o fato de que o uso da biblioteca padr√£o pode levar a custos adicionais indesej√°veis ‚Äã‚Äãde recursos, tanto RAM quanto ROM.  Portanto, frequentemente as classes e m√©todos da biblioteca <code>std</code> n√£o s√£o adequados para implementa√ß√£o no microcontrolador.  H√° tamb√©m algumas restri√ß√µes no uso de mem√≥ria alocada dinamicamente, RTTI, exce√ß√µes e assim por diante.  Em geral, para escrever c√≥digo compacto e r√°pido, voc√™ n√£o pode simplesmente pegar a biblioteca <code>std</code> e come√ßar a usar, digamos operadores <code>typeid</code> , porque o suporte a RTTI √© necess√°rio, e isso j√° √© uma sobrecarga, embora n√£o seja muito grande. <br><br>  Portanto, √†s vezes voc√™ precisa reinventar a roda para cumprir todas essas condi√ß√µes.  Existem poucas tarefas desse tipo, mas s√£o.  Neste post, gostaria de falar sobre uma tarefa aparentemente simples - expandir os c√≥digos de retorno dos subsistemas existentes no software de microcontrolador. <br><a name="habracut"></a><br><h2>  Desafio </h2><br>  Suponha que voc√™ tenha um subsistema de diagn√≥stico da CPU e ele tenha numerosos c√≥digos de retorno, diga o seguinte: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cpu_Error</span></span></span><span class="hljs-class"> {</span></span> Ok, Alu, Rom, Ram } ;</code> </pre><br>  Se o subsistema de diagn√≥stico da CPU detectar uma falha de um dos m√≥dulos da CPU (por exemplo, ALU ou RAM), ele precisar√° retornar o c√≥digo correspondente. <br><br>  O mesmo para outro subsistema, seja um diagn√≥stico de medi√ß√£o, verificando se o valor medido est√° na faixa e geralmente √© v√°lido (n√£o √© igual a NAN ou Infinity): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Measure_Error</span></span></span><span class="hljs-class"> {</span></span> OutOfLimits, Ok, BadCode } ;</code> </pre> <br>  Para cada subsistema, permita que um m√©todo <code>GetLastError()</code> retorne o tipo de erro enumerado desse subsistema.  Para <code>CpuDiagnostic</code> c√≥digo do tipo <code>CpuDiagnostic</code> ser√° retornado, para <code>MeasureDiagnostic</code> c√≥digo do tipo <code>Measure_Error</code> . <br><br>  E h√° um certo log que, quando ocorre um erro, deve registrar o c√≥digo de erro. <br>  Para entender, vou escrever isso de uma forma muito simplificada: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Logger::Update() { Log(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt;(cpuDiagnostic.GetLastError()) ; Log(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt;(measureDiagstic.GetLastError()) ; }</code> </pre><br>  √â claro que, ao converter os tipos enumerados em um n√∫mero inteiro, podemos obter o mesmo valor para tipos diferentes.  Como distinguir que o primeiro c√≥digo de erro √© o c√≥digo de erro do subsistema de diagn√≥stico da CPU e o segundo subsistema de medi√ß√£o? <br><br><h3>  Procurar solu√ß√µes </h3><br>  Seria l√≥gico que o m√©todo <code>GetLastError()</code> retornasse um c√≥digo diferente para diferentes subsistemas.  Uma das decis√µes mais diretas na testa seria usar diferentes intervalos de c√≥digos para cada tipo enumerado.  Algo assim <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> tU32 CPU_ERROR_ALU = <span class="hljs-number"><span class="hljs-number">0x10000001</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> tU32 CPU_ERROR_ROM = <span class="hljs-number"><span class="hljs-number">0x10000002</span></span> ; ... <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> tU32 MEAS_ERROR_OUTOF = <span class="hljs-number"><span class="hljs-number">0x01000001</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> tU32 MEAS_ERROR_BAD = <span class="hljs-number"><span class="hljs-number">0x01000002</span></span> ; ... <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cpu_Error</span></span></span><span class="hljs-class"> {</span></span> Ok, Alu = CPU_ERROR_ALU, Rom = CPU_ERROR_ROM, Ram = CPU_ERROR_RAM } ; ...</code> </pre><br>  Eu acho que as desvantagens dessa abordagem s√£o √≥bvias.  Em primeiro lugar, muito trabalho manual, voc√™ precisa determinar manualmente os intervalos e os c√≥digos de retorno, o que certamente levar√° a um erro humano.  Em segundo lugar, pode haver muitos subsistemas, e adicionar enumera√ß√µes para cada subsistema n√£o √© uma op√ß√£o. <br><br>  Na verdade, seria √≥timo se fosse poss√≠vel n√£o tocar nas transfer√™ncias, expandir seus c√≥digos de uma maneira um pouco diferente, por exemplo, para poder fazer isso: <br><br><pre> <code class="cpp hljs">ResultCode result = Cpu_Error::Ok ; <span class="hljs-comment"><span class="hljs-comment">//GetLastError()   Cpu_Error result = cpuDiagnostic.GetLastError() ; if(result) //    { //       Logger::Log(result) ; } //GetLastError()   Measure_Error result = measureDiagnostic.GetLastError() ; if(result) //    { //       Logger::Log(result) ; }</span></span></code> </pre><br>  Ou ent√£o: <br><br><pre> <code class="cpp hljs">ReturnCode result ; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it: diagnostics) { <span class="hljs-comment"><span class="hljs-comment">//GetLastError()     result = it.GetLastError() ; if (result) //    { Logger::Log(result) ; //      } }</span></span></code> </pre><br>  Ou ent√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CpuDiagnostic::SomeFunction(ReturnCode errocode) { Cpu_Error status = errorcode ; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (status) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CpuError::Alu: <span class="hljs-comment"><span class="hljs-comment">// do something ; break; .... } }</span></span></code> </pre><br>  Como voc√™ pode ver no c√≥digo, alguma classe <code>ReturnCode</code> √© usada aqui, que deve conter o c√≥digo de erro e sua categoria.  Na biblioteca padr√£o, existe uma classe <code>std::error_code</code> , que na verdade faz quase tudo isso.  Muito bem, seu objetivo √© descrito aqui: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Seu pr√≥prio std :: code_error</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Suporte para erros do sistema em C ++</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Exce√ß√µes determin√≠sticas e tratamento de erros em "C ++ do futuro"</a> <br><br>  A principal reclama√ß√£o √© que, para usar essa classe, precisamos herdar <code>std::error_category</code> , que est√° claramente sobrecarregado para uso em firmware em pequenos microcontroladores.  Mesmo pelo menos usando std :: string. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CpuErrorCategory</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_category { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ev)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; };</code> </pre><br>  Al√©m disso, voc√™ tamb√©m ter√° que descrever a categoria (nome e mensagem) para cada um de seus tipos enumerados manualmente.  E tamb√©m o c√≥digo que indica a aus√™ncia de um erro em <code>std::error_code</code> √© 0. E existem casos poss√≠veis em que para cada tipo o c√≥digo de erro ser√° diferente. <br>  Eu gostaria de n√£o ter despesas gerais, exceto adicionando um n√∫mero de categoria. <br><br>  Portanto, seria l√≥gico ‚Äúinventar‚Äù algo que permitiria ao desenvolvedor fazer um m√≠nimo de movimentos em termos de adi√ß√£o de uma categoria para seu tipo enumerado. <br><br>  Primeiro, voc√™ precisa criar uma classe semelhante ao <code>std::error_code</code> , capaz de converter qualquer tipo enumerado em um n√∫mero inteiro e vice-versa de um n√∫mero inteiro para um tipo enumerado.  Al√©m desses recursos, para poder retornar a categoria, o valor real do c√≥digo e verificar: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//GetLastError()   CpuError ReturnCode result(cpuDiagnostic.GetLastError()) ; if(result) //    { ... }</span></span></code> </pre><br><h3>  Solu√ß√£o </h3><br>  A classe deve armazenar em si um c√≥digo de erro, um c√≥digo de categoria e um c√≥digo correspondente √† aus√™ncia de erros, um operador de convers√£o e um operador de atribui√ß√£o.  A classe correspondente √© a seguinte: <br><br><img src="https://habrastorage.org/webt/v9/s3/nv/v9s3nvtgcu06simqv7mahn0h3fk.png"><br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo da classe</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReturnCode</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ReturnCode() { } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">explicit</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReturnCode</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">initReturnCode</span></span></span><span class="hljs-class">):</span></span> errorValue(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU32&gt;(initReturnCode)), errorCategory(GetCategory(initReturnCode)), goodCode(GetOk(initReturnCode)) { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_enum&lt;T&gt;::value, <span class="hljs-string"><span class="hljs-string">"   "</span></span>) ; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">() </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//Cast to only enum types static_assert(std::is_enum&lt;T&gt;::value, "   ") ; return static_cast&lt;T&gt;(errorValue) ; } tU32 GetValue() const { return errorValue; } tU32 GetCategoryValue() const { return errorCategory; } operator bool() const { return (GetValue() != goodCode); } template&lt;class T&gt; ReturnCode&amp; operator=(const T returnCode) { errorValue = static_cast&lt;tU32&gt;(returnCode) ; errorCategory = GetCategory(returnCode) ; goodCode = GetOk(returnCode) ; return *this ; } private: tU32 errorValue = 0U ; tU32 errorCategory = 0U ; tU32 goodCode = 0U ; } ;</span></span></code> </pre><br></div></div><br>  √â necess√°rio explicar um pouco o que est√° acontecendo aqui.  Para come√ßar com um construtor de modelos <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">explicit</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReturnCode</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">initReturnCode</span></span></span><span class="hljs-class">):</span></span> errorValue(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU32&gt;(initReturnCode)), errorCategory(GetCategory(initReturnCode)), goodCode(GetOk(initReturnCode)) { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_enum&lt;T&gt;::value, <span class="hljs-string"><span class="hljs-string">"   "</span></span>) ; }</code> </pre><br><br>  Permite criar uma classe de objeto a partir de qualquer tipo enumerado: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ReturnCode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cpu_Error::Ok)</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-function"><span class="hljs-function">ReturnCode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(My_Error::Error1)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">ReturnCode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cpuDiagnostic.GetLatestError())</span></span></span><span class="hljs-function"> </span></span>;</code> </pre><br>  Para garantir que o construtor possa aceitar apenas um tipo enumerado, <code>static_assert</code> adicionado ao seu corpo, que em tempo de compila√ß√£o verifica o tipo passado ao construtor usando <code>std::is_enum</code> e <code>std::is_enum</code> erro com texto n√£o criptografado.  O c√≥digo real n√£o √© gerado aqui, isso √© tudo para o compilador.  Ent√£o, de fato, este √© um construtor vazio. <br><br>  O construtor tamb√©m inicializa atributos privados, voltarei a isso mais tarde ... <br>  Em seguida, o operador de convers√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">() </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//Cast to only enum types static_assert(std::is_enum&lt;T&gt;::value, "   ") ; return static_cast&lt;T&gt;(errorValue) ; }</span></span></code> </pre><br>  Tamb√©m pode levar apenas a um tipo enumerado e nos permite fazer o seguinte: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">ReturnCode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returnCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cpu_Error::Rom)</span></span></span><span class="hljs-function"> </span></span>; Cpu_Error status = errorCode ; returnCode = My_Errror::Error2; My_Errror status1 = returnCode ; returnCode = myDiagnostic.GetLastError() ; MyDiagsonticError status2 = returnCode ;</code> </pre><br>  Bem e separadamente o operador bool (): <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (GetValue() != goodCode); }</code> </pre><br>  Isso nos permitir√° verificar diretamente se h√° algum erro no c√≥digo de retorno: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//GetLastError()   Cpu_Error ReturnCode result(cpuDiagnostic.GetLastError()) ; if(result) //    { ... }</span></span></code> </pre><br>  Isso √© essencialmente tudo.  A pergunta permanece nas <code>GetCategory()</code> e <code>GetOkCode()</code> .  Como voc√™ pode imaginar, o primeiro destina-se ao tipo enumerado para comunicar de alguma forma sua categoria √† classe <code>ReturnCode</code> e o segundo ao tipo enumerado para indicar que √© um c√≥digo de retorno bem-sucedido, pois vamos compar√°-lo com o operador <code>bool()</code> . <br><br>  √â claro que essas fun√ß√µes podem ser fornecidas pelo usu√°rio, e podemos honestamente cham√°-las em nosso construtor atrav√©s do mecanismo de pesquisa dependente de argumento. <br>  Por exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CategoryError</span></span></span><span class="hljs-class"> {</span></span> Nv = <span class="hljs-number"><span class="hljs-number">100</span></span>, Cpu = <span class="hljs-number"><span class="hljs-number">200</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cpu_Error</span></span></span><span class="hljs-class"> {</span></span> Ok, Alu, Rom } ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> tU32 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCategory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cpu_Error errorNum)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU32&gt;(CategoryError::Cpu); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> tU32 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetOkCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cpu_Error)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU32&gt;(Cpu_Error::Ok); }</code> </pre><br>  Isso requer um esfor√ßo adicional do desenvolvedor.  Para cada tipo enumerado que precisamos categorizar, precisamos adicionar esses dois m√©todos e atualizar a enumera√ß√£o <code>CategoryError</code> . <br><br>  No entanto, nosso desejo √© que o desenvolvedor n√£o adicione quase nada ao c√≥digo e n√£o se preocupe em como expandir seu tipo enumerado. <br>  O que pode ser feito? <br><br><ul><li>  Primeiro, foi √≥timo que a categoria fosse calculada automaticamente e o desenvolvedor <b>n√£o</b> precisaria fornecer uma implementa√ß√£o do m√©todo <code>GetCategory()</code> para cada enumera√ß√£o. </li><li>  Em segundo lugar, em 90% dos casos em nosso c√≥digo, Ok √© usado para retornar um bom c√≥digo.  Portanto, voc√™ pode escrever uma implementa√ß√£o geral para esses 90% e, para 10%, ter√° que fazer especializa√ß√£o. </li></ul><br>  Ent√£o, vamos nos concentrar na primeira tarefa - c√°lculo autom√°tico de categoria.  A ideia sugerida pelo meu colega √© que o desenvolvedor possa registrar seu tipo enumerado.  Isso pode ser feito usando um modelo com um n√∫mero vari√°vel de argumentos.  Declarar essa estrutura <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EnumTypeRegister</span></span></span><span class="hljs-class">{</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//    </span></span></code> </pre><br>  Agora, para registrar uma nova enumera√ß√£o, que deve ser expandida por uma categoria, simplesmente definimos um novo tipo <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> CategoryErrorsList = EnumTypeRegister&lt;Cpu_Error, Measure_Error&gt;;</code> </pre><br>  Se de repente precisarmos adicionar outra enumera√ß√£o, basta adicion√°-lo √† lista de par√¢metros do modelo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> CategoryErrorsList = EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt;;</code> </pre><br>  Obviamente, a categoria para nossas listagens pode ser uma posi√ß√£o na lista de par√¢metros do modelo, ou seja,  para <code>Cpu_Error</code> √© <b>0</b> , para <code>Measure_Error</code> √© <b>1</b> , para <code>My_Error</code> √© <b>2</b> .  Resta for√ßar o compilador a calcular isso automaticamente.  Para C ++ 14, fazemos o seguinte: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> QueriedType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> tU32 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEnumPosition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EnumTypeRegister&lt;Type&gt;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;Type, QueriedType&gt;::value, <span class="hljs-string"><span class="hljs-string">"     EnumTypeRegister"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tU32(<span class="hljs-number"><span class="hljs-number">0U</span></span>) ; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> QueriedType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;Type, QueriedType&gt;::value, tU32&gt; GetEnumPosition(EnumTypeRegister&lt;Type, Types...&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0U</span></span> ; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> QueriedType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;!<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;Type, QueriedType&gt;::value, tU32&gt; GetEnumPosition(EnumTypeRegister&lt;Type, Types...&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1U</span></span> + GetEnumPosition&lt;QueriedType&gt;(EnumTypeRegister&lt;Types...&gt;()) ; }</code> </pre><br>  O que est√° acontecendo aqui.  Em resumo, a fun√ß√£o <code>GetEnumPosition&lt;T&lt;&gt;&gt;</code> , com o par√¢metro de entrada como uma lista dos tipos enumerados <code>EnumTypeRegister</code> , no nosso caso <code>EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt;</code> , e o par√¢metro de modelo <b>T</b> √© um tipo enumerado cujo √≠ndice devemos encontrar nesta lista, percorre a lista e se T corresponder a um dos tipos da lista, retornar√° seu √≠ndice, caso contr√°rio, a mensagem "Tipo n√£o est√° registrado na lista EnumTypeRegister" ser√° exibida <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//..    constexpr EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt; list //  GetEnumPosition&lt;Measure_Error&gt;(list) //   1 -    Measure_Error   .</span></span></code> </pre><br>  Vamos analisar com mais detalhes.  Menor fun√ß√£o <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> QueriedType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;!<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;Type, QueriedType&gt;::value, tU32&gt; GetEnumPosition(TypeRegister&lt;Type, Types...&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1U</span></span> + GetEnumPosition&lt;QueriedType&gt;(TypeRegister&lt;Types...&gt;()) ; }</code> </pre><br>  Aqui a ramifica√ß√£o <code>std::enable_if_t&lt; <b>!std::is_same</b> ..</code> verifica se o tipo solicitado corresponde ao primeiro tipo na lista de modelos; caso contr√°rio, o tipo retornado da fun√ß√£o <code>GetEnumPosition</code> ser√° <code>tU32</code> e o corpo da fun√ß√£o ser√° executado, ou seja, uma chamada recursiva da mesma fun√ß√£o novamente. , enquanto o n√∫mero de argumentos do modelo diminui em <b>1</b> e o valor de retorno aumenta em <b>1</b> .  Ou seja, a cada itera√ß√£o, haver√° algo semelhante a isto: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Iteration 1, 1+: tU32 GetEnumPosition&lt;T&gt;(EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt;) //Iteration 2, 1+1+: tU32 GetEnumPosition&lt;T&gt;(EnumTypeRegister&lt;Measure_Error, My_Error&gt;) //Iteration 3, 1+1+1: tU32 GetEnumPosition&lt;T&gt;(EnumTypeRegister&lt;My_Error&gt;)</span></span></code> </pre><br>  Depois que todos os tipos da lista terminarem, <code>std::enable_if_t</code> n√£o poder√° inferir o tipo do valor de retorno da fun√ß√£o <code>GetEnumPosition()</code> e, nesta itera√ß√£o, terminar√°: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//         GetEnumPosition&lt;T&gt;(TypeRegister&lt;&gt;) template &lt;typename QueriedType, typename Type&gt; constexpr tU32 GetEnumPosition(EnumTypeRegister&lt;Type&gt;) { static_assert(std::is_same&lt;Type, QueriedType&gt;::value, "     EnumTypeRegister"); return tU32(0U) ; }</span></span></code> </pre><br>  O que acontece se o tipo estiver na lista.  Nesse caso, outra ramifica√ß√£o funcionar√°, ramifica√ß√£o c <code>std::enable_if_t&lt; <b>std::is_same</b> ..</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> QueriedType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;Type, QueriedType&gt;::value, tU32&gt; GetEnumPosition(TypeRegister&lt;Type, Types...&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0U</span></span> ; }</code> </pre><br>  Aqui h√° uma verifica√ß√£o da coincid√™ncia dos tipos <code>std::enable_if_t&lt; <b>std::is_same</b> ...</code> E se, digamos, na entrada, houver um tipo <code>Measure_Error</code> , a seguinte sequ√™ncia ser√° obtida: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Iteration 1, tU32 GetEnumPosition&lt;Measure_Error&gt;(EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt;) { return 1U + GetEnumPosition&lt;Measure_Error&gt;(EnumTypeRegister&lt;Measure_Error, My_Error&gt;) } //Iteration 2: tU32 GetEnumPosition&lt;Measure_Error&gt;(EnumTypeRegister&lt;Measure_Error, My_Error&gt;) { return 0 ; }</span></span></code> </pre><br>  Na segunda itera√ß√£o, a chamada de fun√ß√£o recursiva termina e obtemos 1 (da primeira itera√ß√£o) + 0 (da segunda) = <b>1</b> na sa√≠da - este √© um √≠ndice do tipo Measure_Error na lista <code>EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt;</code> <br><br>  Como essa √© uma fun√ß√£o <code>constexpr,</code> todos os c√°lculos s√£o feitos no est√°gio de compila√ß√£o e nenhum c√≥digo √© realmente gerado. <br><br>  Tudo isso n√£o p√¥de ser escrito, esteja √† disposi√ß√£o do C ++ 17.  Infelizmente, meu compilador IAR n√£o oferece suporte completo ao C ++ 17 e, portanto, foi poss√≠vel substituir todo o cal√ßado pelo seguinte c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//for C++17 template &lt;typename QueriedType, typename Type, typename... Types&gt; constexpr tU32 GetEnumPosition(EnumTypeRegister&lt;Type, Types...&gt;) { //        if constexpr (std::is_same&lt;Type, QueriedType&gt;::value) { return 0U ; } else { return 1U + GetEnumPosition&lt;QueriedType&gt;(EnumTypeRegister&lt;Types...&gt;()) ; } }</span></span></code> </pre><br>  Resta agora criar os m√©todos de modelo <code>GetCategory()</code> e <code>GetOk()</code> , que chamar√£o <code>GetEnumPosition</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> tU32 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCategory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU32&gt;(GetEnumPosition&lt;T&gt;(categoryDictionary)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> tU32 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetOk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU32&gt;(T::Ok); }</code> </pre><br>  Isso √© tudo.  Vamos agora ver o que acontece com essa constru√ß√£o de objeto: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ReturnCode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Measure_Error::Ok)</span></span></span><span class="hljs-function"> </span></span>;</code> </pre><br>  Vamos voltar ao construtor da classe <code>ReturnCode</code> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">explicit</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReturnCode</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">initReturnCode</span></span></span><span class="hljs-class">):</span></span> errorValue(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU32&gt;(initReturnCode)), errorCategory(GetCategory(initReturnCode)), goodCode(GetOk(initReturnCode)) { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_enum&lt;T&gt;::value, <span class="hljs-string"><span class="hljs-string">"The type have to be enum"</span></span>) ; }</code> </pre><br>  √â um modelo e, se <code>T</code> √© um <code>Measure_Error</code> que significa que a instancia√ß√£o do modelo de m√©todo <code>GetCategory(Measure_Error)</code> √© chamada, para o tipo <code>Measure_Error</code> , que por sua vez chama <code>GetEnumPosition</code> com o tipo <code>Measure_Error</code> , <code>GetEnumPosition&lt;Measure_Error&gt;(EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt;)</code> que retorna a posi√ß√£o de <code>Measure_Error</code> na lista.  A posi√ß√£o √© <b>1</b> .  E, na verdade, todo o c√≥digo do construtor na instancia√ß√£o do tipo <code>Measure_Error</code> substitu√≠do pelo compilador por: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReturnCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Measure_Error initReturnCode)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">errorValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">errorCategory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">goodCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre><br><h3>  Sum√°rio </h3><br>  Para um desenvolvedor que <code>ReturnCode</code> usar o <code>ReturnCode</code> h√° apenas uma coisa a fazer: <br>  Registre seu tipo enumerado na lista. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add enum in the category using CategoryErrorsList = EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt;;</span></span></code> </pre><br>  E sem movimentos desnecess√°rios, o c√≥digo existente n√£o se move e, para a extens√£o, voc√™ s√≥ precisa registrar o tipo na lista.  Al√©m disso, tudo isso ser√° feito no est√°gio de compila√ß√£o, e o compilador n√£o apenas calcular√° todas as categorias, mas tamb√©m o alertar√° se voc√™ esquecer de registrar o tipo ou tentar passar um tipo que n√£o √© enumer√°vel. <br><br>  Para ser honesto, vale a pena notar que naqueles 10% do c√≥digo em que as enumera√ß√µes t√™m um nome diferente em vez do c√≥digo Ok, voc√™ precisar√° fazer sua pr√≥pria especializa√ß√£o para esse tipo. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> tU32 GetOk&lt;MyError&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyError) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU32&gt;(MyError::Good) ; } ;</code> </pre><br>  Eu postei um pequeno exemplo aqui: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">exemplo de c√≥digo</a> <br><br>  Em geral, aqui est√° uma aplica√ß√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cpu_Error</span></span></span><span class="hljs-class"> {</span></span> Ok, Alu, Rom, Ram } ; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Measure_Error</span></span></span><span class="hljs-class"> {</span></span> OutOfLimits, Ok, BadCode } ; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">My_Error</span></span></span><span class="hljs-class"> {</span></span> Error1, Error2, Error3, Error4, Ok } ; <span class="hljs-comment"><span class="hljs-comment">// Add enum in the category list using CategoryErrorsList = EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt;; Cpu_Error CpuCheck() { return Cpu_Error::Ram; } My_Error MyCheck() { return My_Error::Error4; } int main() { ReturnCode result(CpuCheck()); //cout &lt;&lt; " Return code: "&lt;&lt; result.GetValue() // &lt;&lt; " Return category: "&lt;&lt; result.GetCategoryValue() &lt;&lt; endl; if (result) //if something wrong { result = MyCheck() ; // cout &lt;&lt; " Return code: "&lt;&lt; result.GetValue() // &lt;&lt; " Return category: "&lt;&lt; result.GetCategoryValue() &lt;&lt; endl; } result = Measure_Error::BadCode ; //cout &lt;&lt; " Return code: "&lt;&lt; result.GetValue() // &lt;&lt; " Return category: "&lt;&lt; result.GetCategoryValue() &lt;&lt; endl; result = Measure_Error::Ok ; if (!result) //if all is Ok { Measure_Error mError = result ; if (mError == Measure_Error::Ok) { // cout &lt;&lt; "mError: "&lt;&lt; tU32(mError) &lt;&lt; endl; } } return 0; }</span></span></code> </pre> <br>  Imprima as seguintes linhas: <br><blockquote>  C√≥digo de retorno: 3 Categoria de retorno: 0 <br>  C√≥digo de retorno: 3 Categoria de retorno: 2 <br>  C√≥digo de retorno: 2 Categoria de retorno: 1 <br>  mError: 1 <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt441956/">https://habr.com/ru/post/pt441956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt441944/index.html">Por que escolhemos o Lexus RX450h</a></li>
<li><a href="../pt441946/index.html">API REST no Laravel em 100 linhas de c√≥digo</a></li>
<li><a href="../pt441950/index.html">Eclipse Che 7 j√° est√° aqui</a></li>
<li><a href="../pt441952/index.html">Escolhendo um sistema de armazenamento de arquivos para o trabalho em equipe</a></li>
<li><a href="../pt441954/index.html">Recompensa do usu√°rio aos autores de Habr</a></li>
<li><a href="../pt441962/index.html">√çndices no PostgreSQL - 1</a></li>
<li><a href="../pt441964/index.html">Dicas e truques do Kubernetes: movendo recursos de cluster para o Helm 2</a></li>
<li><a href="../pt441966/index.html">Kit de inicia√ß√£o para testes de seguran√ßa na Web</a></li>
<li><a href="../pt441968/index.html">Desenvolvimento de um novo ramo de produtos: como se livrar do impratic√°vel e se manter √∫til</a></li>
<li><a href="../pt441970/index.html">An√°lise do Butkit FinFisher</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>