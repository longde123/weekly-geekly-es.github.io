<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå¶Ô∏è üë®üèΩ‚ÄçüöÄ üî® Azure SDK f√ºr .NET: Geschichte √ºber eine schwierige Fehlersuche ‚óºÔ∏è üî≥ üë©‚Äçüëß‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Als wir uns entschieden, nach Fehlern im Azure SDK f√ºr .NET-Projekt zu suchen, waren wir angenehm √ºberrascht von seiner Gr√∂√üe. "Dreieinhalb Millionen ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Azure SDK f√ºr .NET: Geschichte √ºber eine schwierige Fehlersuche</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/478978/"><p><img src="https://habrastorage.org/getpro/habr/post_images/1d1/893/6e4/1d18936e4455beb69c69b410bbfd10f6.png" alt="Bild 2" align="left"></p><br>  Als wir uns entschieden, nach Fehlern im Azure SDK f√ºr .NET-Projekt zu suchen, waren wir angenehm √ºberrascht von seiner Gr√∂√üe.  "Dreieinhalb Millionen Codezeilen", sagten wir und studierten die Statistiken des Projekts.  M√∂glicherweise gibt es so viele Erkenntnisse.  Ach und ach!  Das Projekt erwies sich als schlau.  Was war der Reiz des Projekts und wie wurde es √ºberpr√ºft - lesen Sie in diesem Artikel. <br><a name="habracut"></a><br><h2>  √úber das Projekt </h2><br>  Ich schreibe diesen Artikel im Anschluss an meinen vorherigen, der sich auch mit einem Projekt im Zusammenhang mit Microsoft Azure befasste: <a href="https://www.viva64.com/en/b/0678/">Azure PowerShell: Mostly Harmless</a> .  Dieses Mal habe ich also auf eine solide Anzahl verschiedener und interessanter Fehler gesetzt.  Schlie√ülich ist die Projektgr√∂√üe ein sehr wichtiger Faktor f√ºr die statische Analyse, insbesondere bei der erstmaligen √úberpr√ºfung eines Projekts.  In der Praxis ist die Anwendung von Einmalpr√ºfungen nicht der richtige Ansatz.  Wenn sich Entwickler daf√ºr entscheiden, erfolgt dies jedoch erst in der Phase der Einf√ºhrung des Analyseger√§ts.  Gleichzeitig macht sich niemand daran, die enorme Anzahl von Warnungen auszusortieren und sie einfach als technische Schulden zu verwerfen, indem Massenwarnmechanismen zur Unterdr√ºckung von Warnungen eingesetzt und in speziellen Basen gespeichert werden.  Apropos: Wenn Sie das Analyseger√§t zum ersten Mal verwenden, ist es in Ordnung, eine gro√üe Anzahl von Warnungen zu erhalten.  F√ºr uns werden einmalige √úberpr√ºfungen zu Forschungszwecken durchgef√ºhrt.  Aus diesem Grund sind gro√üe Projekte f√ºr die folgende Analyse im Vergleich zu kleinen immer vorzuziehen. <br><br>  Das Azure SDK f√ºr .NET-Projekt erwies sich jedoch sofort als unrentable Testumgebung.  Sogar die beeindruckende Gr√∂√üe hat nicht geholfen, sondern die Arbeit ist kompliziert.  Der Grund ist in der folgenden Projektstatistik angegeben: <br><br><ul><li>  CS-Quelldateien (ohne Tests): 16.500 </li><li>  Visual Studio-L√∂sungen (.sln): 163 </li><li>  Nicht leere Codezeilen: 3 462 000 </li><li>  Davon automatisch generiert: ca. 3.300.000 </li><li>  Das Projekt-Repository ist auf <a href="https://github.com/Azure/azure-sdk-for-net">GitHub</a> verf√ºgbar. </li></ul><br>  Ungef√§hr 95% des Codes werden automatisch generiert, und ein Gro√üteil dieses Codes wird mehrmals wiederholt.  Das √úberpr√ºfen solcher Projekte mit einem statischen Analyseger√§t ist in der Regel zeitaufw√§ndig und nutzlos, da viele funktionsf√§hige, aber unlogische (zumindest auf den ersten Blick) und redundante Codes vorhanden sind.  Dies f√ºhrt zu einer Vielzahl von Fehlalarmen. <br><br>  Die gesamte Menge an Code, die √ºber 163 Visual Studio-L√∂sungen verteilt war, wurde zur "Kirsche an der Spitze".  Es waren einige Anstrengungen erforderlich, um den verbleibenden Code zu √ºberpr√ºfen (nicht automatisch generiert).  Was wirklich geholfen hat, war die Tatsache, dass der gesamte automatisch generierte Code in L√∂sungsunterverzeichnissen unter dem relativen Pfad "&lt;L√∂sungsverzeichnis&gt; \ src \ Generated" gespeichert wurde.  Au√üerdem enth√§lt jede .cs-Datei dieses Typs einen speziellen Kommentar im Tag <i>&lt;automatisch generiert&gt;</i> : <br><br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// &lt;auto-generated&gt; // Copyright (c) Microsoft Corporation. All rights reserved. // Licensed under the MIT License. See License.txt in the project root for // license information. // // Code generated by Microsoft (R) AutoRest Code Generator. // Changes may cause incorrect behavior and will be lost if the code is // regenerated. // &lt;/auto-generated&gt;</span></span></code> </pre> <br>  F√ºr die Reinheit des Experiments √ºberpr√ºfte ich l√ºckenhaft etwa zehn zuf√§llig ausgew√§hlte automatisch generierte L√∂sungen.  Ich werde sp√§ter √ºber das Ergebnis erz√§hlen. <br><br>  Trotz der geringen Menge des verbleibenden ‚Äûehrlichen‚Äú Codes konnte ich dennoch eine Reihe von Fehlern aus dem verbleibenden Code finden.  Dieses Mal werde ich keine Warnungen in der Reihenfolge der PVS-Studio-Diagnosecodes anf√ºhren.  Stattdessen gruppiere ich die Nachrichten nach den L√∂sungen, in denen sie gefunden wurden. <br><br>  Mal sehen, was ich im Azure SDK f√ºr .NET-Code gefunden habe. <br><br><h2>  Microsoft.Azure.Management.Advisor </h2><br>  Dies ist eine von vielen L√∂sungen, die automatisch generierten Code enthalten.  Wie ich bereits sagte, √ºberpr√ºfte ich zuf√§llig etwa ein Dutzend solcher L√∂sungen.  In jedem Fall waren die Warnungen dieselben und erwartungsgem√§√ü nutzlos.  Hier sind einige Beispiele. <br><br>  <a href="https://www.viva64.com/en/w/v3022/">V3022 Der</a> Ausdruck 'Credentials! = Null' ist immer wahr.  AdvisorManagementClient.cs 204 <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Code generated by Microsoft (R) AutoRest Code Generator. .... public ServiceClientCredentials Credentials { get; private set; } .... public AdvisorManagementClient(ServiceClientCredentials credentials, params DelegatingHandler[] handlers) : this(handlers) { if (credentials == null) { throw new System.ArgumentNullException("credentials"); } Credentials = credentials; if (Credentials != null) // &lt;= { Credentials.InitializeServiceClient(this); } }</span></span></code> </pre> <br>  Offensichtlich ist dieser Code redundant und die Pr√ºfung der <i>Berechtigungsnachweise! = Null</i> ist sinnlos.  Trotzdem funktioniert der Code.  Und wird automatisch generiert.  Aus diesem Grund hier keine Beschwerden. <br><br>  <a href="https://www.viva64.com/en/w/v3022/">V3022 Der</a> Ausdruck '_queryParameters.Count&gt; 0' ist immer falsch.  ConfigurationsOperations.cs 871 <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Code generated by Microsoft (R) AutoRest Code Generator. .... public async Task&lt;AzureOperationResponse&lt;IPage&lt;ConfigData&gt;&gt;&gt; ListBySubscriptionNextWithHttpMessagesAsync(....) { .... List&lt;string&gt; _queryParameters = new List&lt;string&gt;(); if (_queryParameters.Count &gt; 0) { .... } .... }</span></span></code> </pre> <br>  Wiederum scheint es eine unlogische Konstruktion zu sein.  Aus irgendeinem Grund √ºberpr√ºfen Codeautoren die Gr√∂√üe der neu erstellten <i>leeren</i> Liste.  In der Tat ist alles richtig.  An dieser Stelle macht die Pr√ºfung keinen Sinn. Wenn Entwickler jedoch eine Listengenerierung hinzuf√ºgen, die beispielsweise auf einer anderen Sammlung basiert, lohnt sich die Pr√ºfung auf jeden Fall.  Auch hier - nat√ºrlich keine Anspr√ºche an den Code in Bezug auf seine Herkunft. <br><br>  F√ºr jede automatisch generierte L√∂sung wurden Hunderte √§hnlicher Warnungen ausgegeben.  Angesichts ihrer Sinnlosigkeit halte ich es nicht f√ºr sinnvoll, solche F√§lle weiter zu er√∂rtern.  Als n√§chstes werden nur echte Fehler im "normalen" Code ber√ºcksichtigt. <br><br><h2>  Azure.Core </h2><br>  <a href="https://www.viva64.com/en/w/v3001/">V3001</a> Es gibt identische Unterausdr√ºcke 'buffer.Length' links und rechts vom Operator '&lt;'.  AzureBaseBuffersExtensions.cs 30 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...., ReadOnlyMemory&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; buffer, ....</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[]? array = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || buffer.Length &lt; buffer.Length) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { if (array != null) ArrayPool&lt;byte&gt;.Shared.Return(array); array = ArrayPool&lt;byte&gt;.Shared.Rent(buffer.Length); } if (!buffer.TryCopyTo(array)) throw new Exception("could not rent large enough buffer."); .... }</span></span></code> </pre> <br>  Der Fehler in der Bedingung war wahrscheinlich das Ergebnis von Copy-Paste.  Entsprechend der Tatsache, dass der <i>Puffer</i> in ein <i>Array</i> kopiert <i>wird</i> , sollte die Pr√ºfung folgenderma√üen aussehen: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || array.Length &lt; buffer.Length)</code> </pre> <br>  Wie ich immer sage, sollte sich der Autor des Codes auf jeden Fall mit der Behebung solcher Fehler befassen. <br><br>  <a href="https://www.viva64.com/en/w/v3083/">V3083</a> Unsicherer Aufruf des Ereignisses '_onChange', NullReferenceException ist m√∂glich.  √úberlegen Sie, ob Sie einer lokalen Variablen ein Ereignis zuweisen m√∂chten, bevor Sie sie aufrufen.  ClientOptionsMonitor.cs 44 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action&lt;TOptions, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; _onChange; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InvokeChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_onChange != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { _onChange.Invoke(options, name); } }</code> </pre> <br>  Nicht kritisch, aber ein Fehler ist hier.  Der Konsument kann das Ereignis zwischen dem √úberpr√ºfen des Ereignisses auf <i>Null</i> und dessen Aufruf abbestellen.  Dann ist die Variable <i>_onChange</i> <i>null</i> und es wird eine Ausnahme ausgel√∂st.  Dieser Code muss sicherer umgeschrieben werden.  Zum Beispiel wie folgt: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InvokeChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... _onChange?.Invoke(options, name); }</code> </pre> <br><h2>  Azure.Messaging.EventHubs </h2><br>  <a href="https://www.viva64.com/en/w/v3080/">V3080</a> M√∂gliche Null-Dereferenzierung.  Sehen Sie sich 'eventPropertyValue' an.  AmqpMessageConverter.cs 650 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryCreateEventPropertyForAmqpProperty</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> amqpPropertyValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eventPropertyValue</span></span></span><span class="hljs-function">)</span></span> { eventPropertyValue = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (GetTypeIdentifier(amqpPropertyValue)) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> AmqpProperty.Type.Byte: .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> AmqpProperty.Type.String: eventPropertyValue = amqpPropertyValue; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; .... } .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (amqpPropertyValue) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> AmqpSymbol symbol: eventPropertyValue = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] array: eventPropertyValue = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ArraySegment&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; segment when segment.Count == segment.Array.Length: eventPropertyValue = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ArraySegment&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; segment: .... eventPropertyValue = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">case</span></span></span><span class="hljs-function"> DescribedType described </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">when</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">described.Descriptor </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">is</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AmqpSymbol</span></span></span><span class="hljs-function">): eventPropertyValue</span></span> = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> exception = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializationException( <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(...., eventPropertyValue.GetType().FullName)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } return (eventPropertyValue != null); }</span></span></code> </pre> <br>  Mal sehen, was mit dem Variablenwert <i>eventPropertyValue</i> im angegebenen Codefragment passiert.  Die Variable erh√§lt zu Beginn der Methode den Wert <i>null</i> .  Ferner wird in einer der ersten <i>Schaltbedingungen</i> die Variable initialisiert, wonach das Verfahren beendet wird.  Der zweite <i>Schalterblock</i> enth√§lt viele Bedingungen, in denen die Variable auch einen neuen Wert erh√§lt.  W√§hrend im <i>Standardblock</i> die Variable <i>eventPropertyValue</i> ohne Pr√ºfung verwendet wird, ist dies ein Fehler, da die Variable derzeit <i>null</i> ist. <br><br>  <a href="https://www.viva64.com/en/w/v3066/">V3066</a> M√∂gliche falsche Reihenfolge der Argumente, die an den Konstruktor 'EventHubConsumer' √ºbergeben wurden: 'partitionId' und 'consumerGroup'.  TrackOneEventHubClient.cs 394 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> EventHubConsumer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateConsumer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventHubConsumer ( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TrackOneEventHubConsumer(....), TrackOneClient.EventHubName, partitionId, <span class="hljs-comment"><span class="hljs-comment">// &lt;= 3 consumerGroup, // &lt;= 4 eventPosition, consumerOptions, initialRetryPolicy ); }</span></span></code> </pre> <br>  Der Analysator vermutet beim Aufrufen des <i>EventHubConsumer-</i> Klassenkonstruktors eine verwirrte Reihenfolge des dritten und vierten Arguments.  Schauen wir uns also diese Konstruktordeklaration an: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EventHubConsumer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TransportEventHubConsumer transportConsumer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eventHubName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> consumerGroup, // &lt;= </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> partitionId, // &lt;= </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">4</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EventPosition eventPosition, EventHubConsumerOptions consumerOptions, EventHubRetryPolicy retryPolicy</span></span></span><span class="hljs-function">)</span></span> { .... }</code> </pre> <br>  In der Tat sind die Argumente verwechselt.  Ich w√ºrde es wagen vorzuschlagen, wie der Fehler gemacht wurde.  M√∂glicherweise ist hier eine falsche Code-Formatierung schuld.  Schauen Sie sich die <i>EventHubConsumer-</i> Konstruktordeklaration noch einmal an.  Aufgrund der Tatsache, dass sich der erste <i>transportConsumer-</i> Parameter in derselben Zeile wie der Klassenname befindet, scheint der <i>partitionId-</i> Parameter an dritter und nicht an vierter Stelle zu stehen (meine Kommentare mit den Parameternummern sind im Originalcode nicht verf√ºgbar). .  Das ist nur eine Vermutung, aber ich w√ºrde die Formatierung des Konstruktorcodes folgenderma√üen √§ndern: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EventHubConsumer</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> TransportEventHubConsumer transportConsumer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eventHubName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> consumerGroup, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> partitionId, EventPosition eventPosition, EventHubConsumerOptions consumerOptions, EventHubRetryPolicy retryPolicy</span></span></span><span class="hljs-function">)</span></span> { .... }</code> </pre> <br><h2>  Azure.Storage </h2><br>  <a href="https://www.viva64.com/en/w/v3112/">V3112</a> Eine Abnormalit√§t in √§hnlichen Vergleichen.  Es ist m√∂glich, dass der Ausdruck 'ContentLanguage == other.ContentEncoding' einen Tippfehler enth√§lt.  BlobSasBuilder.cs 410 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> BlobSasBuilder : IEquatable&lt;BlobSasBuilder&gt; { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BlobSasBuilder other</span></span></span><span class="hljs-function">)</span></span> =&gt; BlobName == other.BlobName &amp;&amp; CacheControl == other.CacheControl &amp;&amp; BlobContainerName == other.BlobContainerName &amp;&amp; ContentDisposition == other.ContentDisposition &amp;&amp; ContentEncoding == other.ContentEncoding &amp;&amp; <span class="hljs-comment"><span class="hljs-comment">// &lt;= ContentLanguage == other.ContentEncoding &amp;&amp; // &lt;= ContentType == other.ContentType &amp;&amp; ExpiryTime == other.ExpiryTime &amp;&amp; Identifier == other.Identifier &amp;&amp; IPRange == other.IPRange &amp;&amp; Permissions == other.Permissions &amp;&amp; Protocol == other.Protocol &amp;&amp; StartTime == other.StartTime &amp;&amp; Version == other.Version; }</span></span></code> </pre> <br>  Ein Fehler, der durch Unaufmerksamkeit begangen wurde.  Einen solchen Fehler bei der Code√ºberpr√ºfung zu finden, ist ziemlich schwierig.  Hier ist die richtige Version des Codes: <br><br><pre> <code class="cs hljs"> .... ContentEncoding == other.ContentEncoding &amp;&amp; ContentLanguage == other.ContentLanguage &amp;&amp; ....</code> </pre> <br>  <a href="https://www.viva64.com/en/w/v3112/">V3112</a> Eine Abnormalit√§t in √§hnlichen Vergleichen.  Es ist m√∂glich, dass der Ausdruck 'ContentLanguage == other.ContentEncoding' einen Tippfehler enth√§lt.  FileSasBuilder.cs 265 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> FileSasBuilder : IEquatable&lt;FileSasBuilder&gt; { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">FileSasBuilder other</span></span></span><span class="hljs-function">)</span></span> =&gt; CacheControl == other.CacheControl &amp;&amp; ContentDisposition == other.ContentDisposition &amp;&amp; ContentEncoding == other.ContentEncoding <span class="hljs-comment"><span class="hljs-comment">// &lt;= &amp;&amp; ContentLanguage == other.ContentEncoding // &lt;= &amp;&amp; ContentType == other.ContentType &amp;&amp; ExpiryTime == other.ExpiryTime &amp;&amp; FilePath == other.FilePath &amp;&amp; Identifier == other.Identifier &amp;&amp; IPRange == other.IPRange &amp;&amp; Permissions == other.Permissions &amp;&amp; Protocol == other.Protocol &amp;&amp; ShareName == other.ShareName &amp;&amp; StartTime == other.StartTime &amp;&amp; Version == other.Version ;</span></span></code> </pre> <br>  Es gibt genau den gleichen Fehler in einem sehr √§hnlichen Code.  Der Code wurde m√∂glicherweise kopiert und teilweise ge√§ndert.  Der Fehler blieb jedoch bestehen. <br><br><h2>  Microsoft.Azure.Batch </h2><br>  <a href="https://www.viva64.com/en/w/v3053/">V3053</a> Ein √ºberm√§√üiger Ausdruck.  Untersuchen Sie die Teilzeichenfolgen 'IList' und 'List'.  PropertyData.cs 157 <br><br>  <a href="https://www.viva64.com/en/w/v3053/">V3053</a> Ein √ºberm√§√üiger Ausdruck.  Untersuchen Sie die Teilzeichenfolgen 'List' und 'IReadOnlyList'.  PropertyData.cs 158 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PropertyData</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsTypeCollection =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Type.Contains(<span class="hljs-string"><span class="hljs-string">"IList"</span></span>) || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Type.Contains(<span class="hljs-string"><span class="hljs-string">"IEnumerable"</span></span>) || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Type.Contains(<span class="hljs-string"><span class="hljs-string">"List"</span></span>) || <span class="hljs-comment"><span class="hljs-comment">// &lt;= this.Type.Contains("IReadOnlyList"); // &lt;= }</span></span></code> </pre> <br>  Der Analysator gab zwei Warnungen √ºber sinnlose oder fehlerhafte √úberpr√ºfungen aus.  Im ersten Fall erscheint die Suche nach der Unterzeichenfolge "List" nach der Suche nach "IList" redundant.  Es ist wahr, diese Bedingung: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Type.Contains(<span class="hljs-string"><span class="hljs-string">"IList"</span></span>) || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Type.Contains(<span class="hljs-string"><span class="hljs-string">"List"</span></span>)</code> </pre> <br>  kann f√ºr das folgende gut ge√§ndert werden: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Type.Contains(<span class="hljs-string"><span class="hljs-string">"List"</span></span>)</code> </pre> <br>  Im zweiten Fall ist die Suche nach der Teilzeichenfolge "IReadOnlyList" sinnlos, da zuvor nach einer k√ºrzeren Teilzeichenfolge "List" gesucht wird. <br><br>  Es besteht auch die M√∂glichkeit, dass Such-Teilzeichenfolgen selbst Fehler aufweisen und etwas anderes vorhanden sein sollte.  Auf jeden Fall muss nur der Autor des Codes die richtige Codeversion vorschlagen, wobei beide Kommentare ber√ºcksichtigt werden. <br><br>  <a href="https://www.viva64.com/en/w/v3095/">V3095</a> Das Objekt 'httpRequest.Content.Headers' wurde verwendet, bevor es gegen null verifiziert wurde.  Zeilen √ºberpr√ºfen: 76, 79. BatchSharedKeyCredential.cs 76 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessHttpRequestAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HttpRequestMessage httpRequest, ....</span></span></span><span class="hljs-function">)</span></span> { .... signature.Append(httpRequest.Content != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; httpRequest.Content.Headers.Contains(<span class="hljs-string"><span class="hljs-string">"Content-Language"</span></span>) ? .... : ....; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>? contentLength = httpRequest.Content?.Headers?.ContentLength; .... }</code> </pre> <br>  Die Variable <i>httpRequest.Content.Headers</i> wird zun√§chst ohne Pr√ºfung verwendet, sp√§ter jedoch mit dem Operator f√ºr den bedingten Zugriff angesprochen. <br><br>  <a href="https://www.viva64.com/en/w/v3125/">V3125</a> Das Objekt 'omPropertyData' wurde verwendet, nachdem es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 156, 148. CodeGenerationUtilities.cs 156 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetProtocolCollectionToObjectModelCollectionString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> ...., PropertyData omPropertyData, ....</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsMappedEnumPair(omPropertyData?.GenericTypeParameter, ....)) { .... } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsTypeComplex(omPropertyData.GenericTypeParameter)) .... }</code> </pre> <br>  Und hier ist eine umgekehrte Situation.  Ein Codeblock enth√§lt eine sichere Zugriffsvariante auf die Referenz <i>omPropertyData, die</i> m√∂glicherweise null ist.  Weiter im Code wird diese Referenz ohne Pr√ºfung behandelt. <br><br>  <a href="https://www.viva64.com/en/w/v3146/">V3146</a> M√∂gliche Null-Dereferenzierung von 'Wert'.  Der 'FirstOrDefault' kann einen Standard-Nullwert zur√ºckgeben.  BatchSharedKeyCredential.cs 127 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessHttpRequestAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpRequestMessage httpRequest, ....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> canonicalHeader <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> customHeaders) { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = httpRequest.Headers. GetValues(canonicalHeader).FirstOrDefault(); <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Replace(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>).Replace(<span class="hljs-string"><span class="hljs-string">'\r'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>).TrimStart(); .... } .... }</code> </pre> <br>  Aufgrund der <i>FirstOrDefault-</i> Methode wird der Standardwert zur√ºckgegeben, der f√ºr den <i>Zeichenfolgentyp</i> <i>null</i> ist, wenn die Suche fehlschl√§gt.  Der Wert wird der Wertevariablen zugewiesen, die dann im Code mit der <i>Replace-</i> Methode ohne Pr√ºfung verwendet wird.  Der Code sollte sicherer gemacht werden.  Zum Beispiel wie folgt: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> canonicalHeader <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> customHeaders) { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = httpRequest.Headers. GetValues(canonicalHeader).FirstOrDefault(); <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>?.Replace(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>).Replace(<span class="hljs-string"><span class="hljs-string">'\r'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>).TrimStart(); .... }</code> </pre> <br><h2>  Microsoft.Azure.ServiceBus </h2><br>  <a href="https://www.viva64.com/en/w/v3121/">V3121</a> Eine Aufz√§hlung 'BlocksUsing' wurde mit dem Attribut 'Flags' deklariert, setzt jedoch keine Initialisierer, um Standardwerte zu √ºberschreiben.  Fx.cs 69 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Fx</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Tag</span></span> { .... [Flags] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> BlocksUsing { MonitorEnter, MonitorWait, ManualResetEvent, AutoResetEvent, AsyncResult, IAsyncResult, PInvoke, InputQueue, ThreadNeutralSemaphore, PrivatePrimitive, OtherInternalPrimitive, OtherFrameworkPrimitive, OtherInterop, Other, NonBlocking, } .... } .... }</code> </pre> <br>  Die Aufz√§hlung wird mit dem Attribut <i>Flags</i> deklariert.  Gleichzeitig bleiben die konstanten Werte standardm√§√üig erhalten ( <i>MonitorEnter = 0</i> , <i>MonitorWait = 1</i> , <i>ManualResetEvent = 2</i> usw.).  Dies kann in folgendem Fall auftreten: Wenn Sie versuchen, eine Flags-Kombination zu verwenden, werden beispielsweise die zweite und die dritte Konstante <i>MonitorWait (= 1)</i> | verwendet  <i>ManualResetEvent (= 2)</i> , es wird kein eindeutiger Wert empfangen, sondern standardm√§√üig die Konstante mit dem Wert 3 <i>(AutoResetEvent</i> ).  Dies kann f√ºr den Anrufercode eine √úberraschung sein.  Wenn die <i>BlocksUsing-</i> Enumeration wirklich zum Setzen von <i>Merkerkombinationen</i> (Bitfeld) verwendet werden soll, sollten Konstanten Werte erhalten, die der Zahl mit Zweierpotenzen entsprechen. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Flags</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> BlocksUsing { MonitorEnter = <span class="hljs-number"><span class="hljs-number">1</span></span>, MonitorWait = <span class="hljs-number"><span class="hljs-number">2</span></span>, ManualResetEvent = <span class="hljs-number"><span class="hljs-number">4</span></span>, AutoResetEvent = <span class="hljs-number"><span class="hljs-number">8</span></span>, AsyncResult = <span class="hljs-number"><span class="hljs-number">16</span></span>, IAsyncResult = <span class="hljs-number"><span class="hljs-number">32</span></span>, PInvoke = <span class="hljs-number"><span class="hljs-number">64</span></span>, InputQueue = <span class="hljs-number"><span class="hljs-number">128</span></span>, ThreadNeutralSemaphore = <span class="hljs-number"><span class="hljs-number">256</span></span>, PrivatePrimitive = <span class="hljs-number"><span class="hljs-number">512</span></span>, OtherInternalPrimitive = <span class="hljs-number"><span class="hljs-number">1024</span></span>, OtherFrameworkPrimitive = <span class="hljs-number"><span class="hljs-number">2048</span></span>, OtherInterop = <span class="hljs-number"><span class="hljs-number">4096</span></span>, Other = <span class="hljs-number"><span class="hljs-number">8192</span></span>, NonBlocking = <span class="hljs-number"><span class="hljs-number">16384</span></span>, }</code> </pre> <br>  <a href="https://www.viva64.com/en/w/v3125/">V3125</a> Das Objekt 'session' wurde verwendet, nachdem es gegen null gepr√ºft wurde.  √úberpr√ºfen Sie die Zeilen: 69, 68. AmqpLinkCreator.cs 69 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> Task&lt;Tuple&lt;AmqpObject, DateTime&gt;&gt; CreateAndOpenAmqpLinkAsync() { .... AmqpSession session = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Create Session .... } catch (Exception exception) { .... session?.Abort(); throw AmqpExceptionHelper.GetClientException(exception, null, session.GetInnerException(), amqpConnection.IsClosing()); } .... }</span></span></code> </pre> <br>  Beachten Sie die Behandlung der <i>Sitzungsvariablen</i> im <i>catch-</i> Block.  Die <i>Abort-</i> Methode wird vom Operator f√ºr bedingte Zugriffe sicher aufgerufen.  Aber nach der <i>GetInnerException-</i> Methode wird unsicher aufgerufen.  Dabei wird m√∂glicherweise <i>NullReferenceException</i> anstelle einer Ausnahme des erwarteten Typs ausgel√∂st.  Dieser Code muss behoben werden.  Die <i>AmqpExceptionHelper.GetClientException-</i> Methode unterst√ºtzt die √úbergabe des <i>Nullwerts</i> f√ºr den <i>innerException-</i> Parameter: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Exception </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetClientException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Exception exception, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> referenceId = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Exception innerException = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> connectionError = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { .... }</code> </pre> <br>  Daher kann beim Aufrufen von <i>session.GetInnerException ()</i> nur der Operator f√ºr bedingte Zugriffe verwendet werden: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> Task&lt;Tuple&lt;AmqpObject, DateTime&gt;&gt; CreateAndOpenAmqpLinkAsync() { .... AmqpSession session = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Create Session .... } catch (Exception exception) { .... session?.Abort(); throw AmqpExceptionHelper.GetClientException(exception, null, session?.GetInnerException(), amqpConnection.IsClosing()); } .... }</span></span></code> </pre> <br><h2>  Fazit </h2><br>  Wie Sie sehen, garantiert eine gro√üe Projektgr√∂√üe nicht immer viele Fehler.  Wir bleiben jedoch wachsam, da wir immer etwas finden k√∂nnen.  Auch in einem Projekt, das strukturell so komplex ist wie das Azure SDK f√ºr .NET.  Das Auffinden einiger entscheidender M√§ngel erfordert zus√§tzlichen Aufwand.  Aber je schwieriger, desto angenehmer das Ergebnis.  Um unn√∂tigen Aufwand zu vermeiden, empfehlen wir, beim Schreiben von neuem Code statische Analysen direkt auf den Computern der Entwickler durchzuf√ºhren.  Dies ist der effektivste Ansatz.  <a href="https://www.viva64.com/en/pvs-studio-download/">Laden Sie PVS-Studio herunter und testen Sie es</a> in Aktion.  Viel Gl√ºck bei der Bek√§mpfung von Bugs! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de478978/">https://habr.com/ru/post/de478978/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de478966/index.html">Wie kann man in der modernen Welt √ºberleben und Frontend-Entwickler werden?</a></li>
<li><a href="../de478968/index.html">SpaceX bringt Nanoracks auf den Markt, um Weltraumm√ºll-Orbitalstationen zu bauen</a></li>
<li><a href="../de478970/index.html">DIY Ruftaste Teil 2. Bildtelefon von Raspberry Pi</a></li>
<li><a href="../de478972/index.html">Gewinner des Miro-Plattformwettbewerbs</a></li>
<li><a href="../de478974/index.html">Modul Autoload mit dynamischem Import</a></li>
<li><a href="../de478980/index.html">Azure SDK f√ºr .NET: Die Geschichte eines schwierigen Fehlersuchers</a></li>
<li><a href="../de478986/index.html">Yandex hat eine popul√§re Abstimmung f√ºr Retro-Spiele gestartet. Finalisten der Retro Games Battle 2019</a></li>
<li><a href="../de478988/index.html">Venedig: wilder Gewinn auf ein paar nackten Steinen</a></li>
<li><a href="../de478990/index.html">Installation eines verteilten ausfallsicheren LeoFS-Speichers, der mit Clients kompatibel ist, die S3, NFS verwenden</a></li>
<li><a href="../de478992/index.html">Mangel an Angst und Lebensfreude in der IT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>