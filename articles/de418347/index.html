<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐍 🔰 ☎️ Wie habe ich die Standard-C ++ 11-Bibliothek geschrieben oder warum ist Boost so beängstigend? Kapitel 4.3 🖖🏾 👩🏿‍🔧 👝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Zusammenfassung der vorherigen Teile 
 Aufgrund von Einschränkungen bei der Verwendung von C ++ 11-Compilern und mangelnder Alternativen wollte boost ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie habe ich die Standard-C ++ 11-Bibliothek geschrieben oder warum ist Boost so beängstigend? Kapitel 4.3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418347/"><img src="https://habrastorage.org/webt/lr/zq/if/lrzqifvfeajppx2fdvqbxnwf4ce.png" alt="Wir setzen das Abenteuer fort." width="300" height="350" align="left"><h3>  Zusammenfassung der vorherigen Teile </h3><br>  Aufgrund von Einschränkungen bei der Verwendung von C ++ 11-Compilern und mangelnder Alternativen wollte boost seine eigene Implementierung der Standard-C ++ 11-Bibliothek über die mit dem Compiler gelieferte C ++ 98 / C ++ 03-Bibliothek schreiben. <br><br>  <b>Static_assert</b> , <b>noexcept</b> , <b>countof</b> wurden implementiert, und nach Berücksichtigung aller nicht standardmäßigen <b>Definitionen</b> und Compilerfunktionen wurden Informationen zu den vom aktuellen Compiler unterstützten Funktionen <b>angezeigt</b> .  Eine eigene Implementierung von <b>nullptr ist enthalten</b> , die bei der Kompilierung ausgewählt wird. <br><br>  Es ist Zeit für <b>type_traits</b> und all diese "besondere Vorlagenmagie".  In den vorherigen Teilen dieses Kapitels haben wir meine Implementierung der grundlegenden Vorlagen der Standardbibliothek untersucht. In diesem Teil werden wir über die Kombination der SFINAE-Technik mit Vorlagen und ein wenig über die Codegenerierung sprechen. <br><br>  Link zu GitHub mit dem Ergebnis für heute für ungeduldige und Nichtleser: <br><blockquote>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Engagements und konstruktive Kritik sind willkommen</a></b> </blockquote>  Weitere C ++ - Vorlagen unter Kat.-Nr. <br><a name="habracut"></a><br><h4>  Inhaltsverzeichnis </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einführung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kapitel 1. Viam Supervadet Vadens</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kapitel 2. #ifndef __CPP11_SUPPORT__ #define __COMPILER_SPECIFIC_BUILT_IN_AND_MACRO_HELL__ #endif</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kapitel 3. Finden der perfekten nullptr-Implementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kapitel 4. C ++ Template Magic</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.1 Wir fangen klein an</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.2 Über wie viele wundersame Fehler das Protokoll für uns kompiliert</a> <br>  .... <b>4.3 Zeiger und alles in allem</b> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.4 Was wird sonst noch für die Vorlagenbibliothek benötigt?</a> <br>  Kapitel 5 <br>  ... <br><br><h3>  Kapitel 4. Vorlage "magic" C ++.  Fortsetzung </h3><br><h4>  4.3 Zeiger und alles in allem </h4><br>  Zu diesem Zeitpunkt konnte ich nur Informationen darüber erhalten, ob der Typ ein Array für <i>std :: is_array ist,</i> und es war möglich, Vorlagen für Zeiger zu starten.  Die Implementierung war ebenfalls trivial, jedoch nicht ohne Annahmen. <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// is_array template&lt;class&gt; struct is_array : public false_type { }; template&lt;class _Tp, std::size_t _Size&gt; struct is_array&lt;_Tp[_Size]&gt; : public true_type { }; /*template&lt;class _Tp&gt; struct is_array&lt;_Tp[]&gt;: public true_type { }; */</span></span></code> </pre> <br>  Eine einfache Vorlagenspezialisierung für Arrays einer bestimmten Länge "fängt" alle Arten von Arrays ab. Das Problem tritt jedoch beim unvollständigen Typ <i>T [] auf</i> (ein Array ohne Angabe der Länge).  Tatsache ist, dass dieser Typ von einigen Compilern (C ++ Builder) bei der Spezialisierung einer Vorlage nicht definiert wird, und ich habe hier noch keine universelle Lösung gefunden. <br><br>  Nachdem der Bibliothek „beigebracht“ wurde, integrierte Typen zu definieren, im Typenspeicher auszurichten, mit Typmodifikatoren und anderen grundlegenden Dingen über Vorlagen zur Kompilierungszeit zu arbeiten, war es Zeit für Zeiger und Referenzen. <br><br><img src="https://habrastorage.org/webt/ti/rp/mi/tirpmiwggsavcvlxyjbo8dlv5ee.png" alt="Bild" width="300" height="280" align="left">  In C ++ können zwei Gruppen von Zeigern unterschieden werden - Zeiger auf Klassenmitglieder und Zeiger auf andere Objekte.  Warum ist diese Trennung für die weitere Implementierung der Standardbibliothek wichtig?  Tatsache ist, dass Zeiger auf Klassenmitglieder einen signifikanten Unterschied zu anderen Zeigern aufweisen, wenn <b>dies vorhanden ist</b> , d. H.  Zeiger auf ein Objekt dieser Klasse.  Standardmäßig haben Zeiger auf ein Klassenmitglied eine separate Syntax zum Definieren, sind ein separater Typ und können nicht durch einen regulären Zeiger dargestellt werden.  In der Praxis bedeutet dies, dass die Größe eines Zeigers auf ein Klassenmitglied normalerweise größer ist als die Größe eines regulären Zeigers (der <i>==</i> <b>sizeof (void *)</b> ), weil  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Um</a> virtuelle Elementfunktionen der Klasse zu implementieren und <b>diesen</b> Zeiger zu speichern, implementieren Compiler normalerweise Zeiger auf ein Klassenelement als Struktur (Informationen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zu</a> virtuellen Funktionen und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Strukturen</a> ).  Die Art und Weise, wie Zeiger den Klassenmitgliedern präsentiert werden, liegt gemäß dem Standard im Ermessen des Compilers, aber wir werden diesen Unterschied in Größe und Darstellung berücksichtigen, wenn wir weiteren Code in Betracht ziehen. <br><br>  Um einen regulären Zeiger auf ein Objekt zu definieren, schreiben wir eine einfache <i>is_pointer-</i> Vorlage sowie eine <i>is_lvalue_reference-</i> Vorlage für Objektreferenzen ( <i>wir</i> haben <i>den</i> is_rvalue_reference <i>beiseite</i> gelegt, da es bis zum 11. Standard keinen <i>&amp;&amp;</i> -Operator sowie die gesamte Verschiebungssemantik gab): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_pointer_helper</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> false_type { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_pointer_helper</span></span></span><span class="hljs-class">&lt;_Tp*&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type { }; } <span class="hljs-comment"><span class="hljs-comment">// is_pointer template&lt;class _Tp&gt; struct is_pointer : public detail::_is_pointer_helper&lt;typename remove_cv&lt;_Tp&gt;::type&gt;::type { }; // is_lvalue_reference template&lt;class&gt; struct is_lvalue_reference : public false_type { }; template&lt;class _Tp&gt; struct is_lvalue_reference&lt;_Tp&amp;&gt; : public true_type { };</span></span></code> </pre><br>  Hier gibt es nichts grundlegend Neues mehr, trotzdem wurde es in den vorherigen Teilen dieses Kapitels getan.  Lassen Sie uns weiterhin Zeiger auf Objekte definieren - schauen wir uns nun Zeiger auf Funktionen an. <br><blockquote>  Es ist wichtig zu verstehen, dass eine Funktion und eine Elementfunktion einer Klasse gemäß dem Standard völlig unterschiedliche Entitäten sind: <br><br><ul><li>  Der erste Zeiger ist normal (ein Zeiger auf ein Objekt), der zweite hat einen Zeiger auf ein Klassenmitglied. </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*func_ptr)(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  'func_ptr'    'void func(int){}' void (ClassType::*mem_func_ptr)(int); //  'mem_func_ptr'  -  'ClassType'  'void ClassType::func(int){}'</span></span></code> </pre><br><ul><li>  Sie können einen Link zum ersten (Objektlink) erstellen, aber keinen zweiten Link. </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (&amp;func_ref)(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  'func_ref'    'void func(int){}' //-------------------- //   -    </span></span></code> </pre></blockquote>  Hier möchte ich nur ein wenig über die Codegenerierung sprechen.  Da es vor C ++ 11 keine Vorlagen mit einer variablen Anzahl von Parametern gab, wurden alle Vorlagen, bei denen es eine andere Anzahl von Parametern geben konnte <a href="">, durch Spezialisierung der Hauptvorlage mit einer großen Anzahl von Parametern</a> am Eingang und deren Initialisierung durch Standard-Dummy-Parameter bestimmt.  Dasselbe gilt für Funktionsüberlastungen wie  Es gab auch keine Makros mit einer variablen Anzahl von Parametern.  Da Sie 60-70 Zeilen derselben Art von Vorlagenspezialisierungen mit Ihren Händen schreiben, ist das Überladen von Funktionen eine ziemlich langweilige und nutzlose Aufgabe, und es ist auch mit der Möglichkeit behaftet, einen Fehler zu machen. Ich habe für diese Zwecke einen einfachen Codegenerator für Vorlagen und Funktionsüberladungen geschrieben.  Ich habe mich darauf beschränkt, Funktionen auf 24 Parameter zu definieren, und dies sieht im Code ziemlich umständlich aus, ist aber einfach und klar: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function_ptr_helper</span></span></span><span class="hljs-class"> :</span></span> false_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function_ptr_helper</span></span></span><span class="hljs-class">&lt;R(*)()&gt; :</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function_ptr_helper</span></span></span><span class="hljs-class">&lt;R(*)(...)&gt; :</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T0</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function_ptr_helper</span></span></span><span class="hljs-class">&lt;R(*)(T0)&gt; :</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T0</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function_ptr_helper</span></span></span><span class="hljs-class">&lt;R(*)(T0 ...)&gt; :</span></span> true_type {};</code> </pre><br>  <b>...</b> <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T0</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T2</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T3</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T4</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T5</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T6</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T7</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T8</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T9</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T10</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T11</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T12</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T13</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T14</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T15</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T16</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T17</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T18</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T19</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T20</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T21</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T22</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T23</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T24</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function_ptr_helper</span></span></span><span class="hljs-class">&lt;R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24)&gt; :</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T0</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T2</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T3</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T4</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T5</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T6</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T7</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T8</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T9</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T10</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T11</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T12</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T13</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T14</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T15</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T16</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T17</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T18</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T19</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T20</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T21</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T22</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T23</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T24</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function_ptr_helper</span></span></span><span class="hljs-class">&lt;R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24 ...)&gt; :</span></span> true_type {}; }</code> </pre><br>  Wir definieren die Typen, die uns aus dem vorherigen Kapitel für die SFINAE-Technik bekannt sind: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-comment"><span class="hljs-comment">// SFINAE magic typedef char _yes_type; struct _no_type { char padding[8]; }; }</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Noch ein paar Makros</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _IS_MEM_FUN_PTR_CLR \ template </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(T::*const volatile*)(ARGS)); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(T::*const volatile*)(ARGS...)); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(T::*const volatile*)(ARGS) const); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(T::*const volatile*)(ARGS) volatile); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(T::*const volatile*)(ARGS) const volatile); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(T::*const volatile*)(ARGS...) const); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(T::*const volatile*)(ARGS...) volatile); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(T::*const volatile*)(ARGS...) const volatile); #ifdef _STDEX_CDECL _no_type _STDEX_CDECL _is_mem_function_ptr(...); #define _IS_MEM_FUN_CDECL_PTR \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__cdecl T::*const volatile*)(ARGS)); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__cdecl T::*const volatile*)(ARGS) const); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__cdecl T::*const volatile*)(ARGS) volatile); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__cdecl T::*const volatile*)(ARGS) const volatile); #define _IS_MEM_FUN_STDCALL_PTR \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__stdcall T::*const volatile*)(ARGS)); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__stdcall T::*const volatile*)(ARGS) const); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__stdcall T::*const volatile*)(ARGS) volatile); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__stdcall T::*const volatile*)(ARGS) const volatile); #define _IS_MEM_FUN_FASTCALL_PTR \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__fastcall T::*const volatile*)(ARGS)); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__fastcall T::*const volatile*)(ARGS) const); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__fastcall T::*const volatile*)(ARGS) volatile); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__fastcall T::*const volatile*)(ARGS) const volatile); #else _no_type _is_mem_function_ptr(...); #define _IS_MEM_FUN_CDECL_PTR #define _IS_MEM_FUN_STDCALL_PTR #define _IS_MEM_FUN_FASTCALL_PTR #endif #define _IS_MEM_FUN_PTR \ _IS_MEM_FUN_PTR_CLR \ _IS_MEM_FUN_CDECL_PTR \ _IS_MEM_FUN_STDCALL_PTR \ _IS_MEM_FUN_FASTCALL_PTR }</span></span></span></span></code> </pre><br></div></div><br>  Makros werden so definiert, dass es relativ bequem ist, <b>TYPEN</b> und <b>ARGS-Definitionen</b> als Liste von Typen und Parametern neu zu definieren und dann das Makro <b>_IS_MEM_FUN_PTR zu ersetzen,</b> um Definitionen für alle möglichen Funktionstypen durch den Präprozessor <b>zu</b> generieren.  Beachten Sie auch, dass für Compiler von Microsoft auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anrufvereinbarungen</a> ( <b>__fastcall</b> , <b>__stdcall</b> und <b>__cdecl</b> ) <b>wichtig sind</b> , weil  Bei unterschiedlichen Konventionen sind die Funktionen unterschiedlich, obwohl sie dieselben Argumente und denselben Rückgabewert haben.  Infolgedessen wird dieses ganze grandiose Makrodesign ziemlich kompakt verwendet: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TYPES #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ARGS _IS_MEM_FUN_PTR #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> TYPES #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> ARGS #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TYPES , class T0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ARGS T0 _IS_MEM_FUN_PTR #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> TYPES #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> ARGS #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TYPES , class T0, class T1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ARGS T0, T1 _IS_MEM_FUN_PTR #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> TYPES #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> ARGS</span></span></code> </pre><br>  <b>...</b> <br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TYPES , class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23, class T24 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ARGS T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24 _IS_MEM_FUN_PTR #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> TYPES #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> ARGS </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//      define  : #undef _IS_MEM_FUN_PTR #undef _IS_MEM_FUN_PTR_CLR #undef _IS_MEM_FUN_CDECL_PTR #undef _IS_MEM_FUN_STDCALL_PTR #undef _IS_MEM_FUN_FASTCALL_PTR }</span></span></span></span></code> </pre><br>  Und nun zu dem, was alles geschrieben wurde: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IsRef</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_mem_function_ptr_impl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> _Tp *p; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = (<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(_is_mem_function_ptr(_is_mem_function_ptr_impl::p)) == <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(_yes_type)); <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> integral_constant&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, _is_mem_function_ptr_impl::value == <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)&gt;::type type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_mem_function_ptr_impl</span></span></span><span class="hljs-class">&lt;_Tp, true&gt;:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> false_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_mem_function_ptr_helper</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> _is_mem_function_ptr_impl&lt;_Tp, is_reference&lt;_Tp&gt;::value&gt;::type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IsMemberFunctionPtr</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function_chooser_impl</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> false_type { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function_chooser_impl</span></span></span><span class="hljs-class">&lt;_Tp, false&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> _is_function_ptr_helper&lt;_Tp*&gt; { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IsRef</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">true</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function_chooser</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> false_type { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function_chooser</span></span></span><span class="hljs-class">&lt;_Tp, false&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = _is_function_chooser_impl&lt;_Tp, _is_mem_function_ptr_helper&lt;_Tp&gt;::value&gt;::value; }; }</code> </pre><br>  Um zu überprüfen, ob ein Typ eine Mitgliedsfunktion einer Klasse ist, wird zunächst geprüft, ob der Typ eine Referenz ist.  Dann wird ein Zeiger dieses Typs erstellt und in die Sondenfunktion eingesetzt.  Unter Verwendung der SFINAE-Technik wählt der Compiler die erforderliche Überladung von Sondenfunktionen für einen solchen Zeiger aus und bildet basierend auf dem Ergebnis des Vergleichs mit <i>_yes_type</i> das Ergebnis. <br><br>  Basierend auf einer Prüfung einer Mitgliedsfunktion einer Klasse wird eine Typprüfung darauf geschrieben, ob sie zum Funktionstyp gehört.  Wir prüfen, ob der Typ eine Referenz ist. Wenn nicht, suchen wir nach einer geeigneten Spezialisierung der Template-Probe-Strukturen für einen Zeiger dieses Typs, der für alle Funktionszeiger mit bis zu 24 Parametern <i>true_type</i> ist. <br><br>  Und jetzt verwenden wir das Ergebnis, um <i>is_function</i> zu implementieren.  Aus dem gleichen Grund wie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Teil</a> konnte ich diese Struktur hier nicht von <i>Integral_Konstante</i> erben, daher wird das Verhalten von <i>Integral_Konstante</i> "simuliert". <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// is_function template&lt;class _Tp&gt; struct is_function { static const bool value = detail::_is_function_chooser&lt;_Tp, is_reference&lt;_Tp&gt;::value&gt;::value; typedef const bool value_type; typedef integral_constant&lt;bool, is_function::value == bool(true)&gt; type; operator value_type() const { // return stored value return (value); } value_type operator()() const { // return stored value return (value); } };</span></span></code> </pre><br>  Und für die Implementierung von <i>is_member_function_pointer ist</i> es noch einfacher: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// is_member_function_pointer template&lt;class _Tp&gt; struct is_member_function_pointer : public detail::_is_mem_function_ptr_helper&lt;typename remove_cv&lt;_Tp&gt;::type&gt;::type { };</span></span></code> </pre><br>  Anhand dieser Muster können wir außerdem feststellen, ob der Typ im Prinzip ein Mitglied der Klasse ist: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_member_object_pointer_impl1</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> _not_&lt; _or_&lt;_is_function_ptr_helper&lt;_Tp&gt;, _is_mem_function_ptr_helper&lt;_Tp&gt; &gt; &gt;::type { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_member_object_pointer_impl2</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> false_type { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_member_object_pointer_impl2</span></span></span><span class="hljs-class">&lt;_Tp _Cp::*&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_member_object_pointer_helper</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> _and_&lt;_is_member_object_pointer_impl1&lt;_Tp&gt;, _is_member_object_pointer_impl2&lt;_Tp&gt; &gt;::type {}; } <span class="hljs-comment"><span class="hljs-comment">// is_member_object_pointer template&lt;class _Tp&gt; struct is_member_object_pointer : public detail::_is_member_object_pointer_helper&lt;typename remove_cv&lt;_Tp&gt;::type&gt;::type { };</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Verwendete logische Operationen 'und', 'oder', 'nicht' für Typen aus dem ersten Teil</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void_type</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//typedef void void_type; template&lt;class _B1 = void_type, class _B2 = void_type, class _B3 = void_type, class _B4 = void_type&gt; struct _or_ : public conditional&lt;_B1::value, _B1, _or_&lt;_B2, _or_&lt;_B3, _B4&gt; &gt; &gt;::type { }; template&lt;&gt; struct _or_&lt;void_type, void_type, void_type, void_type&gt;; template&lt;class _B1&gt; struct _or_&lt;_B1, void_type, void_type, void_type&gt; : public _B1 { }; template&lt;class _B1, class _B2&gt; struct _or_&lt;_B1, _B2, void_type, void_type&gt; : public conditional&lt;_B1::value, _B1, _B2&gt;::type { }; template&lt;class _B1, class _B2, class _B3&gt; struct _or_&lt;_B1, _B2, _B3, void_type&gt; : public conditional&lt;_B1::value, _B1, _or_&lt;_B2, _B3&gt; &gt;::type { }; template&lt;class _B1 = void_type, class _B2 = void_type, class _B3 = void_type, class _B4 = void_type&gt; struct _and_; template&lt;&gt; struct _and_&lt;void_type, void_type, void_type, void_type&gt;; template&lt;class _B1&gt; struct _and_&lt;_B1, void_type, void_type, void_type&gt; : public _B1 { }; template&lt;class _B1, class _B2&gt; struct _and_&lt;_B1, _B2, void_type, void_type&gt; : public conditional&lt;_B1::value, _B2, _B1&gt;::type { }; template&lt;class _B1, class _B2, class _B3&gt; struct _and_&lt;_B1, _B2, _B3, void_type&gt; : public conditional&lt;_B1::value, _and_&lt;_B2, _B3&gt;, _B1&gt;::type { }; template&lt;class _Pp&gt; struct _not_ { static const bool value = !bool(_Pp::value); typedef const bool value_type; typedef integral_constant&lt;bool, _not_::value == bool(true)&gt; type; operator value_type() const { // return stored value return (value); } value_type operator()() const { // return stored value return (value); } }; }</span></span></code> </pre><br></div></div><br>  Hier verwenden wir logische Operationen für Typen, die mithilfe der <i>bedingten</i> Vorlage schließlich den entsprechenden Vorlagentyp auswählen.  Die Vorlagenprogrammierung in ihrer ganzen Pracht, daher haben wir bereits in der Kompilierungsphase Informationen darüber, ob der Typ ein Mitglied der Klasse ist.  Ziemlich "wütend", aber wie spektakulär und effektiv! <br><br>  Eine etwas <i>reinere</i> Vorlagenprogrammierung auf denselben logischen Elementen und wir haben <i>is_fundamental</i> , <i>is_compound</i> usw.  Zeichen (das freut mich, aber Sie?): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// is_arithmetic template&lt;class _Tp&gt; struct is_arithmetic : public detail::_or_&lt;is_integral&lt;_Tp&gt;, is_floating_point&lt;_Tp&gt; &gt;::type { }; // is_fundamental template&lt;class _Tp&gt; struct is_fundamental : public detail::_or_&lt;is_arithmetic&lt;_Tp&gt;, is_void&lt;_Tp&gt;, is_null_pointer&lt;_Tp&gt; &gt;::type {}; // is_object template&lt;class _Tp&gt; struct is_object : public detail::_not_&lt; detail::_or_&lt; is_function&lt;_Tp&gt;, is_reference&lt;_Tp&gt;, is_void&lt;_Tp&gt; &gt; &gt;::type {}; // is_scalar template&lt;class _Tp&gt; struct is_scalar : public detail::_or_&lt;is_arithmetic&lt;_Tp&gt;, is_pointer&lt;_Tp&gt;, is_member_pointer&lt;_Tp&gt;, is_null_pointer&lt;_Tp&gt;/*, is_enum&lt;_Tp&gt;*/ &gt;::type {}; // is_compound template&lt;class _Tp&gt; struct is_compound: public detail::_not_&lt;is_fundamental&lt;_Tp&gt; &gt;::type { };</span></span></code> </pre><blockquote>  Ein aufmerksamer Leser wird feststellen, dass die Definition von <i>is_enum auskommentiert ist</i> .  Tatsache ist, dass ich keine Möglichkeit gefunden habe, <b>Enum</b> von anderen Typen zu unterscheiden, aber ich denke, dass dies ohne die Verwendung von Compiler-abhängigen Makros möglich ist.  Vielleicht sagt Ihnen ein aufmerksamer und sachkundiger Leser Ihren Weg oder Gedankengang in dieser Hinsicht. </blockquote>  Um festzustellen, dass ein Typ eine Klasse ist, wird jetzt nichts mehr benötigt: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IsReference</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_class_helper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> integral_constant&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt; type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_class_helper</span></span></span><span class="hljs-class">&lt;_Tp, false&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> integral_constant&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, (is_scalar&lt;_Tp&gt;::value == <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//&amp;&amp; !is_union&lt;_Tp&gt;::value &gt;::value &amp;&amp; (is_array&lt;_Tp&gt;::value == bool(false)) &amp;&amp; (is_void&lt;_Tp&gt;::value == bool(false)) &amp;&amp; (is_function&lt;_Tp&gt;::value == bool(false))&gt; type; }; } // is_class template&lt;class _Tp&gt; struct is_class : public detail::_is_class_helper&lt;typename remove_cv&lt;_Tp&gt;::type, is_reference&lt;_Tp&gt;::value&gt;::type { };</span></span></code> </pre><br>  Und alles wäre in Ordnung, aber <b>Union</b> in C ++ kann im allgemeinen Fall nicht von einer Klasse unterschieden werden.  Weil sie sich in ihren "externen Manifestationen" sehr ähnlich sind und ich die Unterschiede (zum Beispiel die Unfähigkeit, von <b>Union</b> zu erben) ohne Kompilierungsfehler nicht überprüfen konnte.  Vielleicht sagt Ihnen jemand ein schwieriges Manöver, um die <b>Vereinigung</b> bei der Kompilierung zu bestimmen, dann entspricht <i>is_class</i> genau dem Standard. <br><br>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letzten Teil</a> dieses Kapitels werde ich darüber sprechen, wie <i>std ::</i> <i>zerfall</i> und <i>std :: common_type implementiert</i> wurden und was noch zu <b>type_traits</b> hinzugefügt werden <b>muss</b> . <br><br>  Danke für die Aufmerksamkeit. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418347/">https://habr.com/ru/post/de418347/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418335/index.html">Konfrontation bei Positive Hack Days 8: Parsen von Angriffsketten</a></li>
<li><a href="../de418337/index.html">Heiß, Summer DataGrip 2018.2</a></li>
<li><a href="../de418339/index.html">"Manueller" Manipulator</a></li>
<li><a href="../de418341/index.html">Glücklicher Systemadministratortag! Grußkarte mit Bedeutung</a></li>
<li><a href="../de418345/index.html">Dokumentation von Informationsaustauschformaten - einfach und unkompliziert</a></li>
<li><a href="../de418349/index.html">Azure Kubernetes Service (AKS) und PowerShell</a></li>
<li><a href="../de418353/index.html">Mind Map anstelle eines Testfalls oder Wie Sie mit der Visualisierung die Anwendung schneller testen können</a></li>
<li><a href="../de418355/index.html">Sortieren ... nach einer Hash-Tabelle (auch nach einer Baumzahl und einer HashMap)</a></li>
<li><a href="../de418357/index.html">DEFCON 23. "Geständnisse eines professionellen Cyberstalkers." Ken Westin</a></li>
<li><a href="../de418359/index.html">Fintech Digest: Identifizierung der Bürger des Finanzsupermarkts, ehemaliger QIWI-Mitarbeiter, der 2,4% der Bitcoins, BRICS und Blockchain abgebaut hat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>