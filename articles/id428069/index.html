<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¾â€âš–ï¸ ğŸ”­ ğŸ§—ğŸ½ Optimalkan load balancing dalam infrastruktur Veeam Backup & Replication ğŸ¦ ğŸ„ ğŸ´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kolega saya yang luar biasa dari departemen dukungan teknis menulis tidak hanya berbahaya, tetapi juga tips dan trik yang berguna untuk menyiapkan Vee...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimalkan load balancing dalam infrastruktur Veeam Backup & Replication</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/veeam/blog/428069/">  Kolega saya yang luar biasa dari departemen dukungan teknis menulis tidak hanya berbahaya, tetapi juga tips dan trik yang berguna untuk menyiapkan Veeam Backup &amp; Replication.  Sejak publikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel untuk pengguna pemula,</a> penulisnya, Evgeny Ivanov, sambil terus bekerja sama dengan tim Rumania di Bucharest, telah pindah dari jabatan insinyur senior ke posisi pemimpin tim.  Tetapi Eugene tidak meninggalkan bidang teknis dan sastra, yang karenanya banyak terima kasih kepadanya! <br>  Artikel baru Zhenya berisi rekomendasi untuk spesialis Veeam Backup &amp; Replication yang sudah berpengalaman yang dihadapkan dengan tugas untuk memanfaatkan sumber daya infrastruktur cadangan.  Namun, artikel ini akan bermanfaat bagi mereka yang hanya berencana untuk menginstal dan mengkonfigurasi produk kami. <br><br><img src="https://habrastorage.org/webt/ml/wf/yq/mlwfyqyowbq_dg7asos37xybia4.png"><br>  <i>Optimalisasi distribusi beban di masa tabung hangat</i> <br><br>  Untuk tips yang bermanfaat, selamat datang di kucing. <br><a name="habracut"></a><br><h1>  Tentang kelebihan instalasi terdistribusi </h1><br>  Veeam Backup &amp; Replication adalah perangkat lunak modular yang terdiri dari berbagai komponen, yang masing-masing menjalankan fungsi tertentu.  Di antara komponen-komponen ini adalah direktur utama server cadangan Veeam, server proxy, repositori, akselerator WAN, dan lainnya.  Sejumlah komponen dapat diinstal pada satu mesin (tentu saja, cukup kuat), yang dilakukan banyak pengguna.  Namun, instalasi terdistribusi memiliki kelebihan, yaitu: <br><br><ul><li>  Untuk perusahaan dengan jaringan cabang, dimungkinkan untuk menginstal komponen yang diperlukan secara lokal di cabang-cabang ini.  Ini membantu untuk mengoptimalkan lalu lintas, mengatur sebagian besar lagi secara lokal. </li><li>  Seiring infrastruktur Anda tumbuh, Anda perlu meningkatkan solusi cadangan Anda.  Jika cadangan lebih lama ("jendela cadangan" semakin besar), Anda dapat menginstal server proxy tambahan.  Jika Anda perlu meningkatkan kapasitas repositori cadangan, Anda dapat mengonfigurasi repositori cadangan skala-out dan menambahkan luasan baru sesuai kebutuhan. </li><li>  Untuk beberapa komponen, Anda dapat memastikan ketersediaan konstan (Ketersediaan Tinggi) - misalnya, jika Anda memiliki beberapa server proxy yang digunakan dan salah satu dari mereka tiba-tiba dimatikan, maka yang lain akan terus bekerja dan cadangan tidak akan terpengaruh. </li></ul><br>  Harus diingat bahwa sistem terdistribusi hanya akan efektif dengan distribusi beban yang masuk akal.  Jika tidak, kemacetan dapat terjadi, kelebihan komponen individu - dan ini penuh dengan penurunan umum dalam produktivitas dan perlambatan. <br><br><h1>  Bagaimana data dikirimkan? </h1><br>  Untuk memiliki gagasan yang lebih jelas tentang di mana dan di mana data ditransfer selama proses pencadangan, pertimbangkan diagram ini (misalnya, ambil infrastruktur pada platform vSphere): <br><br><img src="https://habrastorage.org/webt/fx/fm/np/fxfmnpj4_z8qpv9yreas9ybf88c.png"><br><br>  Seperti yang Anda lihat, data ditransfer dari lokasi sumber (sumber) ke target (target) menggunakan "agen transportasi" (VeeamAgent.exe) yang bekerja di kedua lokasi.  Jadi, ketika pekerjaan cadangan berjalan, hal berikut terjadi: <br><br><ul><li>  Agen transportasi "sumber" berjalan pada server proxy;  itu membaca data dari datastore, melakukan kompresi dan deduplikasi, dan mengirimkan data dalam bentuk ini ke agen transportasi "target". </li><li>  Agen transportasi "target" berjalan langsung di repositori (Windows / Linux) atau di gateway (server gateway), jika CIFS digunakan.  Agen ini, pada gilirannya, juga melakukan deduplikasi di sisinya dan menyimpan data dalam file cadangan (.VBK, .VIB, dll.). </li></ul><br>  Dengan demikian, 2 komponen selalu terlibat dalam pengiriman data, bahkan jika mereka sebenarnya berada di mesin yang sama.  Ini harus dipertimbangkan ketika merencanakan penyebaran solusi. <br><br><h1>  Load balancing antara server proxy dan repositori </h1><br>  Pertama, mari kita mendefinisikan konsep "tugas".  Dalam terminologi Veeam Backup &amp; Replication, setiap tugas memproses satu disk mesin virtual.  Artinya, jika Anda memiliki tugas cadangan (pekerjaan), yang mencakup 5 VM dengan masing-masing 2 disk, ini berarti Anda harus memproses 10 tugas (dan jika mesin hanya memiliki 1 disk, maka 1 tugas = 1 VM).  Veeam Backup &amp; Replication mampu memproses beberapa tugas secara paralel, tetapi jumlah mereka, tentu saja, tidak terbatas. <br><br>  Untuk setiap server proxy di propertinya, Anda dapat menentukan jumlah tugas maksimum untuk eksekusi paralel: <br><br><img src="https://habrastorage.org/webt/ra/sf/b1/rasfb1_rus_8c64vjnlt-iyz80k.png"><br><br>  Untuk operasi cadangan standar, interpretasi yang sama akan untuk repositori: satu tugas adalah untuk mentransfer data dari satu disk virtual.  Di antarmuka, tampilannya sangat mirip: <br><br><img src="https://habrastorage.org/webt/ul/0w/8s/ul0w8si2kepgtfj-1y4d1srv1vs.png"><br><br>  Di sini kita harus memperbaiki <b>aturan yang</b> sangat penting <b>No. 1:</b> <i>pastikan untuk menyeimbangkan saat menetapkan sumber daya proxy dan repositori dan ketika menentukan jumlah maksimum tugas untuk pemrosesan paralel!</i> <br><br><h3>  Contoh </h3><br>  Misalkan Anda memiliki 3 proxy, yang masing-masing dapat memproses 4 tugas secara paralel (mis., Total 12 disk virtual dari sumber VM).  Tetapi repositori dikonfigurasikan untuk hanya memproses 4 tugas secara paralel (omong-omong, ini adalah nilai default).  Dengan pengaturan ini, hanya 4 drive yang akan disimpan secara paralel dari lokasi sumber ke tujuan, meskipun mereka bisa untuk semua 12. Artinya, sumber daya akan kekurangan beban. <br><br>  Namun, ketika datang untuk membuat cadangan penuh sintetis (dan operasi serupa), konsep tugas relatif ke repositori mengambil makna yang sedikit berbeda.  Kami ingat bahwa operasi seperti itu tidak melibatkan proxy, tetapi dilakukan secara lokal di repositori (Windows atau Linux) atau (dalam kasus berbagi CIFS) menggunakan gateway. <br><br>  Dalam opsi ini, saat membangun rantai cadangan normal, tugas = tugas cadangan.  Artinya, batas 4 tugas untuk pemrosesan paralel di sini akan berarti bahwa cadangan sintetis untuk 4 tugas cadangan dapat dibuat secara bersamaan di repositori. <br><br>  Ketika membangun rantai cadangan didekomposisi sesuai dengan VM asli (yang disebut "penyimpanan dengan penyimpanan" - per-VM), tugas = 1 VM.  Artinya, batas 4 tugas untuk pemrosesan paralel di sini akan berarti bahwa 4 file VBK untuk 4 mesin virtual dapat dihasilkan pada repositori secara bersamaan. <br><br>  Jadi, kita sampai pada <b>aturan No. 2:</b> <i>Bergantung pada pengaturan cadangan, jumlah tugas yang sama dapat berarti beban yang sama sekali berbeda pada repositori.</i>  <i>Karena itu, ketika merencanakan sumber daya, Anda pasti perlu memeriksa pengaturan yang sama: mode cadangan, jadwal tugas, cara mengatur rantai cadangan.</i> <br><br>  <i>Catatan:</i> Tidak seperti pengaturan proxy, repositori dapat menonaktifkan batas jumlah tugas.  Dalam hal ini, repositori akan menerima semua data yang berasal dari server proxy.  Tapi ini hanya kebebasan nyata dari pembatasan, karena ada risiko kelebihan dan penyimpanan repositori dalam pekerjaan tugas cadangan.  Karenanya, kami sangat tidak menyarankan untuk memberikan batasan ini. <br><br><h3>  Contoh lain </h3><br>  Misalkan Anda memiliki tugas cadangan yang mencakup sejumlah VM yang cukup besar dengan total 100 disk virtual.  Pada saat yang sama, repositori dikonfigurasi untuk menyimpan rantai cadangan â€œdengan tanganâ€ (per-VM).  Pengaturan pemrosesan paralel adalah sebagai berikut: untuk proxy - 10 disk sekaligus, dan untuk repositori - tidak ada batasan.  Selama cadangan tambahan, beban pada repositori akan terbatas karena pengaturan proxy, dan dengan demikian saldo akan dipertahankan.  Tetapi kemudian tiba saatnya untuk membuat cadangan penuh sintetis.  Cadangan seperti itu tidak menggunakan proxy, dan semua operasi untuk membuat "sintetis" berlangsung secara eksklusif di repositori.  Karena tidak ada batasan pada pemrosesan paralel tugas-tugas untuk repositori, server repositori akan mencoba memproses seratus keseluruhan sekaligus.  Ini akan membutuhkan tekanan sumber daya yang signifikan dan kemungkinan besar akan menyebabkan kelebihan. <br><br><h1>  Fitur menggunakan share CIFS sebagai repositori </h1><br>  Jika Anda bekerja dengan repositori yang didasarkan pada server Windows atau Linux, maka agen "target" mulai langsung di server ini.  Namun, jika Anda menggunakan folder berbagi CIFS (berbagi CIFS) sebagai repositori, maka agen "target" dimulai pada mesin yang dirancang khusus untuk tujuan ini - inilah yang disebut  "Gateway", yang akan menerima aliran data yang masuk dari agen di sisi VM sumber.  Agen "target" akan menerima data ini dan kemudian mengirim blok data ke bola CIFS.  Mesin bantu ini harus ditempatkan sedekat mungkin ke mesin yang menyediakan folder bersama SMB - ini sangat penting untuk skrip yang menggunakan konektivitas WAN. <br><br>  <b>Peraturan nomor 3:</b> <i>Anda tidak boleh menempatkan mesin bantu (proxy \ gateway) di satu situs, dan folder berbagi CIFS dibagikan di situs lain (termasuk di cloud) - jika tidak, Anda akan memiliki masalah jaringan yang konstan.</i> <br><br>  Anda juga dapat menerapkan ke gateway semua pertimbangan di atas untuk menyeimbangkan beban pada sistem.  Selain itu, Anda harus ingat bahwa gateway memiliki 2 pengaturan tambahan: server dapat ditetapkan secara eksplisit atau dipilih secara otomatis: <br><br><img src="https://habrastorage.org/webt/zp/ot/v3/zpotv33yivh4xspx_vqbsnaboom.png"><br><br>  Pada prinsipnya, setiap server Windows yang termasuk dalam infrastruktur cadangan Veeam dapat digunakan sebagai gateway.  Bergantung pada skenario penempatan Anda, salah satu opsi mungkin cocok untuk Anda: <br><br><ul><li>  Server yang ditentukan secara eksplisit - ini, tentu saja, menyederhanakan banyak hal, karena Anda akan tahu persis mesin apa yang digunakan oleh agen "target".  Opsi ini direkomendasikan, khususnya, untuk kasus-kasus ketika akses ke bola hanya diizinkan dari server tertentu, serta untuk skenario dengan infrastruktur terdistribusi - Anda mungkin ingin menggunakan agen pada mesin yang terletak di dekat file server dengan target sebagai orang yang masuk akal bolanya. </li><li>  Server yang dipilih secara otomatis (Opsi <b>pemilihan otomatis</b> ).  Di sini, hal-hal berubah menjadi menarik: jika Anda menggunakan beberapa server proxy, kemudian memilih opsi ini, ternyata, mengarah pada fakta bahwa program menggunakan lebih dari satu gateway, mendistribusikan beban.  Saya perhatikan bahwa "secara otomatis" tidak berarti "sewenang-wenang" - aturan pemilihan yang cukup spesifik diterapkan di sini. </li></ul><br><h2>  Bagaimana cara kerjanya? </h2><br>  Agen "target" dimulai pada server proxy yang melakukan pencadangan. <br><br><ul><li>  Dalam kasus rantai cadangan biasa, logikanya adalah ini: jika ada beberapa tugas yang dieksekusi secara bersamaan, masing-masing dengan server proxy sendiri, maka Anda dapat menjalankan beberapa agen "target".  Namun, dalam satu pekerjaan, logikanya berbeda: bahkan jika VM yang terkandung di dalamnya diproses oleh proxy yang berbeda, agen "target" akan diluncurkan hanya pada satu - pada yang akan mulai bekerja terlebih dahulu. </li><li>  Dalam kasus rantai cadangan "rantai", agen "target" yang terpisah diluncurkan untuk setiap VM.  Jadi, bahkan dalam tugas yang sama, distribusi beban terjadi. </li></ul><br>  <b>Saat membuat cadangan sintetis,</b> server proxy tidak digunakan, dan di sini mesin untuk memulai agen "target" dipilih sebagai berikut: ambil server mount bantu (server mount tempat file dipasang, misalnya, selama operasi pemulihan) yang terkait dengan repositori, dan itu memulai agen.  Jika server mount tidak tersedia karena alasan tertentu, dimungkinkan untuk beralih ke utara cadangan Veeam.  Seperti yang Anda pahami, tidak akan ada distribusi muatan di versi ini. <br><br>  Oleh karena itu, saya ulangi: ( <i>PENTING!</i> ) Tidak disarankan untuk skenario seperti itu untuk menghapus batas jumlah tugas yang diproses secara paralel, karena ketika melakukan operasi dengan "sintetis" ini dapat menyebabkan kelebihan yang berlebihan dari server mount atau bahkan server cadangan Veeam. <br><br><h1>  Fitur tambahan </h1><br>  <b>Repositori yang dapat diukur.</b>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SOBR</a> adalah seperangkat repositori standar (di sini mereka disebut "luasan").  Jika Anda sudah menggunakan SOBR, maka dalam tugas cadangan tentukan itu, dan tidak sejauh.  Sejauh ini, Anda dapat menggunakan beberapa pengaturan, misalnya, load balancing. <br><br>  Semua prinsip dasar yang berfungsi untuk repositori reguler juga berfungsi untuk SOBR.  Untuk mengoptimalkan penggunaan sumber daya, Anda dapat menyarankan pengaturan SOBR dengan penyimpanan cadangan "crypto" (per-VM - ini adalah opsi default), dengan kebijakan penempatan "Kinerja" ("optimalkan kinerja yang lebih baik") dan distribusi rantai di seluruh repositori-tingkat-s. <br><br>  <b>Transfer cadangan (salinan cadangan).</b>  Di sini, agen "sumber" akan bekerja pada repositori sumber.  Segala sesuatu yang disebutkan di atas juga berlaku untuk repositori sumber (kecuali untuk fakta bahwa dalam kasus pekerjaan transfer Cadangan Salin Cadangan, operasi dengan "sintetis" tidak dilakukan pada repositori sumber). <br><br>  <i>Catatan:</i> Jika repositori sumber adalah bagian CIFS, maka agen "sumber" dimulai pada server pemasangan yang sesuai (dengan kemampuan untuk beralih ke server cadangan Veeam). <br><br>  <b>Perangkat dengan deduplikasi bawaan.</b>  Untuk sistem penyimpanan DataDomain dan StoreOnce (dan mungkin untuk orang lain di masa mendatang), yang untuknya integrasi dengan Veeam dikonfigurasikan, pertimbangan yang sama berlaku untuk pangsa CIFS.  Untuk repositori di StoreOnce dengan deduplikasi di sisi sumber (mode <b>Bandwidth Rendah</b> ), hanya persyaratan untuk menempatkan gateway sedekat mungkin ke repositori mungkin kehilangan relevansi - gateway di satu situs dapat dikonfigurasi untuk mengirim data ke StoreOnce di situs lain melalui WAN. <br><br>  <b>Server proxy yang disukai.</b>  Fitur ini muncul, seperti yang Anda ingat, dalam rilis 9.5, dan bertanggung jawab untuk memelihara "daftar prioritas proxy" yang akan dipatuhi program ketika bekerja dengan repositori tertentu. <br><br><img src="https://habrastorage.org/webt/kg/vp/4o/kgvp4ojq2s7pcryr8qtc0gbhrek.png"><br><br>  Jika proksi dari daftar ini tidak tersedia, maka tugas akan berfungsi dengan yang lain tersedia.  Namun, jika ada akses ke proxy, tetapi server proxy tidak memiliki slot gratis untuk memproses tugas, maka tugas cadangan akan ditangguhkan sambil menunggu mereka.  Oleh karena itu, Anda perlu menggunakan fitur ini dengan sangat hati-hati (dan tidak dalam gaya "dihidupkan dan dilupakan") - kami memiliki pengguna yang dengan demikian "menutup" tugas cadangan.  Anda dapat membaca lebih lanjut tentang fitur ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> (dalam bahasa Inggris). <br><br><h1>  Kesimpulannya </h1><br>  Tidak masalah jika Anda menginstal Veeam Backup &amp; Replication untuk pertama kalinya atau Anda adalah pengguna lama - saya ingin percaya bahwa dalam artikel ini Anda akan menemukan informasi yang berguna bagi Anda dan dengan bantuannya mengoptimalkan operasi infrastruktur cadangan atau bahkan menghilangkan potensi risiko kehilangan data.  Berikut ini beberapa tautan yang lebih berguna: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Veeam Backup &amp; Replication: 10 Tips Pemula</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tips Berguna untuk Mengarsipkan Cadangan Veeam Tape</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel Habr tentang repositori tak terukur tak terukur (SOBR)</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id428069/">https://habr.com/ru/post/id428069/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id428059/index.html">Hubungkan Penyimpanan Multipath LUN ke VMware ESXi dan Debian GNU / Linux</a></li>
<li><a href="../id428061/index.html">Mengelola Biaya Proyek dengan Manajemen Nilai yang Diperoleh</a></li>
<li><a href="../id428063/index.html">Browser menolak dukungan untuk TLS 1.0 dan 1.1</a></li>
<li><a href="../id428065/index.html">Lebih sedikit tidak berarti lebih buruk: langit dan dinding domain di ferromagnet</a></li>
<li><a href="../id428067/index.html">AntiFuzzing: Keamanan melalui ketidakjelasan!?</a></li>
<li><a href="../id428073/index.html">Rust 1.30 Release</a></li>
<li><a href="../id428075/index.html">Sama saja, Anda tidak bisa melakukannya! - Menggunakan antarmuka dan injeksi ketergantungan untuk desain jangka panjang</a></li>
<li><a href="../id428077/index.html">React.js: A Beginner's Guide</a></li>
<li><a href="../id428079/index.html">Menerapkan Prinsip SOLID untuk Bereaksi Pengembangan Aplikasi</a></li>
<li><a href="../id428081/index.html">Menggunakan RxJS dalam React Development untuk Mengelola Status Aplikasi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>