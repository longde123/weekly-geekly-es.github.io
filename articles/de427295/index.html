<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥢 👨🏼‍🏭 🙇🏽 JavaScript-Currying-Funktionen 👟 💇🏿 🍷</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Funktionale Programmierung ist ein Stil der Programmentwicklung, bei dem einige spezifische Merkmale für die Arbeit mit Funktionen weit verbreitet sin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript-Currying-Funktionen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/427295/">  Funktionale Programmierung ist ein Stil der Programmentwicklung, bei dem einige spezifische Merkmale für die Arbeit mit Funktionen weit verbreitet sind.  Es geht insbesondere darum, Funktionen als Argumente auf andere Funktionen zu übertragen und Funktionen von anderen Funktionen zurückzugeben.  Das Konzept der „reinen Funktionen“ gehört auch zum funktionalen Programmierstil.  Die Ausgabe von reinen Funktionen hängt nur von der Eingabe ab. Wenn sie ausgeführt werden, haben sie keinen Einfluss auf den Status des Programms. <br><br>  Funktionale Programmierprinzipien werden von vielen Sprachen unterstützt.  Unter ihnen sind JavaScript, Haskell, Clojure, Erlang.  Die Verwendung funktionaler Programmiermechanismen setzt unter anderem die Kenntnis von Konzepten wie reinen Funktionen, Curry-Funktionen und Funktionen höherer Ordnung voraus. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ge/zo/ma/gezomag7bkhhzxqs3afxpu76g0k.png"></a> <br><br>  Das Material, das wir heute übersetzen, handelt vom Curry.  Wir werden darüber sprechen, wie Currying funktioniert und wie das Wissen über diesen Mechanismus für einen JS-Entwickler nützlich sein kann. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Was ist Curry?</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Currying</a> in der funktionalen Programmierung ist die Umwandlung einer Funktion mit vielen Argumenten in eine Reihe verschachtelter Funktionen mit einem Argument.  Wenn eine Curry-Funktion mit einem übergebenen Argument aufgerufen wird, gibt sie eine neue Funktion zurück, die erwartet, dass das nächste Argument eintrifft.  Neue Funktionen, die auf das nächste Argument warten, werden bei jedem Aufruf der Curry-Funktion zurückgegeben - bis die Funktion alle benötigten Argumente erhält.  Die Argumente, die dank des Schließmechanismus früher eingegangen sind, warten auf den Moment, in dem die Funktion alles erhält, was sie zur Durchführung der Berechnungen benötigt.  Nach Erhalt des letzten Arguments führt die Funktion die Berechnung durch und gibt das Ergebnis zurück. <br><br>  Wenn wir vom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Curry</a> sprechen, können wir sagen, dass dies der Prozess ist, eine Funktion mit mehreren Argumenten in eine Funktion mit weniger Arität umzuwandeln. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arity</a> ist die Anzahl der Argumente für eine Funktion.  Hier ist zum Beispiel die Deklaration eines Funktionspaares: <br><br><pre><code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span></span> {    //... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_fn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b, c)</span></span></span></span> {    //... }</code> </pre> <br>  Die <code>fn</code> Funktion <code>_fn</code> zwei Argumente (dies ist eine binäre oder 2-ary-Funktion), die <code>_fn</code> Funktion <code>_fn</code> drei Argumente (eine ternäre 3-ary-Funktion). <br><br>  Lassen Sie uns über die Situation sprechen, in der während des Currying eine Funktion mit mehreren Argumenten in eine Reihe von Funktionen konvertiert wird, von denen jede ein Argument akzeptiert. <br><br>  Betrachten Sie ein Beispiel.  Wir haben folgende Funktion: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">multiply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b, c)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a * b * c; }</code> </pre> <br>  Es dauert drei Argumente und gibt ihr Produkt zurück: <br><br><pre> <code class="hljs objectivec">multiply(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 6</span></span></code> </pre> <br>  Lassen Sie uns nun darüber nachdenken, wie Sie es in eine Reihe von Funktionen konvertieren können, von denen jede ein Argument benötigt.  Lassen Sie uns eine Curry-Version dieser Funktion erstellen und untersuchen, wie Sie beim Aufrufen mehrerer Funktionen dasselbe Ergebnis erzielen: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">multiply</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">b</span></span></span><span class="hljs-function">) =&gt;</span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c</span></span></span><span class="hljs-function">) =&gt;</span></span> {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a * b * c       }   } } log(multiply(<span class="hljs-number"><span class="hljs-number">1</span></span>)(<span class="hljs-number"><span class="hljs-number">2</span></span>)(<span class="hljs-number"><span class="hljs-number">3</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// 6</span></span></code> </pre> <br>  Wie Sie sehen können, haben wir hier den Aufruf in eine einzelne Funktion mit drei Argumenten konvertiert - <code>multiply(1,2,3)</code> mit dem Aufruf in drei Funktionen - <code>multiply(1)(2)(3)</code> . <br><br>  Es stellt sich heraus, dass aus einer Funktion mehrere Funktionen geworden sind.  Bei Verwendung der neuen Konstruktion nimmt jede Funktion mit Ausnahme der letzten, die das Ergebnis von Berechnungen zurückgibt, ein Argument und eine andere Funktion zurück, die ebenfalls ein Argument akzeptieren und eine andere Funktion zurückgeben kann.  Wenn Ihnen eine Konstruktion der Form <code>multiply(1)(2)(3)</code> nicht sehr klar erscheint, schreiben wir sie in diese Form, um dies besser zu verstehen: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mul1 = multiply(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mul2 = mul1(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = mul2(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(result); <span class="hljs-comment"><span class="hljs-comment">// 6</span></span></code> </pre> <br>  Lassen Sie uns nun Zeile für Zeile wissen, was hier passiert. <br><br>  Zuerst übergeben wir Argument <code>1</code> an die <code>multiply</code> : <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mul1 = multiply(<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Wenn diese Funktion funktioniert, funktioniert dieses Design: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">b</span></span></span><span class="hljs-function">) =&gt;</span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c</span></span></span><span class="hljs-function">) =&gt;</span></span> {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a * b * c       }   }</code> </pre> <br>  Jetzt hat <code>mul1</code> einen Verweis auf eine Funktion, die ein Argument <code>mul1</code> . <code>b</code>  Wir rufen die Funktion <code>mul1</code> und übergeben sie <code>2</code> : <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mul2 = mul1(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  Als Ergebnis dieses Aufrufs wird der folgende Code ausgeführt: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>) =&gt; {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a * b * <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>       }</code> </pre> <br>  Die <code>mul2</code> enthält einen Verweis auf eine Funktion, die sich beispielsweise aufgrund der folgenden Operation darin befinden könnte: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul2</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c)</span></span></span><span class="hljs-function"> =&gt;</span></span> {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a * b * c       }</code> </pre> <br>  Wenn wir nun die Funktion <code>mul2</code> und <code>3</code> , führt die Funktion die erforderlichen Berechnungen mit den Argumenten <code>a</code> und <code>b</code> : <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = mul2(<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>  Das Ergebnis dieser Berechnungen ist <code>6</code> : <br><br><pre> <code class="hljs lisp">log(<span class="hljs-name"><span class="hljs-name">result</span></span>)<span class="hljs-comment"><span class="hljs-comment">; // 6</span></span></code> </pre> <br>  Die <code>mul2</code> Funktion, die die höchste Verschachtelungsebene aufweist, hat Zugriff auf den Bereich, auf die Abschlüsse, die durch die <code>multiply</code> und <code>mul1</code> .  Aus diesem Grund können in der Funktion <code>mul2</code> Berechnungen mit Variablen durchgeführt werden, die in Funktionen deklariert sind, deren Ausführung bereits abgeschlossen wurde, die bereits einige Werte zurückgegeben haben und vom Garbage Collector verarbeitet werden. <br><br>  Oben haben wir ein abstraktes Beispiel untersucht, aber im Wesentlichen dieselbe Funktion, mit der das Volumen einer rechteckigen Box berechnet werden soll. <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(l,w,h)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l * w * h; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vol = volume(<span class="hljs-number"><span class="hljs-number">100</span></span>,<span class="hljs-number"><span class="hljs-number">20</span></span>,<span class="hljs-number"><span class="hljs-number">90</span></span>) <span class="hljs-comment"><span class="hljs-comment">// 180000</span></span></code> </pre> <br>  So sieht die Curry-Version aus: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volume</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">l</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">w</span></span></span><span class="hljs-function">) =&gt;</span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">h</span></span></span><span class="hljs-function">) =&gt;</span></span> {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l * w * h       }   } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vol = volume(<span class="hljs-number"><span class="hljs-number">100</span></span>)(<span class="hljs-number"><span class="hljs-number">20</span></span>)(<span class="hljs-number"><span class="hljs-number">90</span></span>) <span class="hljs-comment"><span class="hljs-comment">// 180000</span></span></code> </pre> <br>  Das Currying basiert also auf der folgenden Idee: Auf der Grundlage einer bestimmten Funktion wird eine andere Funktion erstellt, die eine spezielle Funktion zurückgibt. <br><br><h2>  <font color="#3AC1EF">Currying und teilweise Nutzung von Funktionen</font> </h2><br>  Vielleicht besteht nun das Gefühl, dass die Anzahl der verschachtelten Funktionen, wenn eine Funktion als Satz verschachtelter Funktionen dargestellt wird, von der Anzahl der Argumente für die Funktion abhängt.  Und wenn es um Curry geht, dann ist es das auch. <br><br>  Eine spezielle Version der Funktion zur Berechnung des Volumens, die wir bereits gesehen haben, kann wie folgt erstellt werden: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volume</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">l</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">w, h</span></span></span><span class="hljs-function">) =&gt;</span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l * w * h   } }</code> </pre> <br>  Hier werden Ideen angewendet, die den oben diskutierten sehr ähnlich sind.  Sie können diese Funktion wie folgt verwenden: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hV = volume(<span class="hljs-number"><span class="hljs-number">70</span></span>); hV(<span class="hljs-number"><span class="hljs-number">203</span></span>,<span class="hljs-number"><span class="hljs-number">142</span></span>); hV(<span class="hljs-number"><span class="hljs-number">220</span></span>,<span class="hljs-number"><span class="hljs-number">122</span></span>); hV(<span class="hljs-number"><span class="hljs-number">120</span></span>,<span class="hljs-number"><span class="hljs-number">123</span></span>);</code> </pre> <br>  Und Sie können dies tun: <br><br><pre> <code class="hljs lisp">volume(<span class="hljs-number"><span class="hljs-number">70</span></span>)(<span class="hljs-number"><span class="hljs-number">90</span></span>,<span class="hljs-number"><span class="hljs-number">30</span></span>)<span class="hljs-comment"><span class="hljs-comment">; volume(70)(390,320); volume(70)(940,340);</span></span></code> </pre> <br>  In der Tat können Sie hier sehen, wie wir mit dem Befehl <code>volume(70)</code> eine spezielle Funktion zur Berechnung des Volumens von Körpern erstellt haben, deren Dimensionen (nämlich Länge, <code>l</code> ) festgelegt sind.  Die <code>volume</code> Funktion erwartet 3 Argumente und enthält 2 verschachtelte Funktionen, im Gegensatz zur vorherigen Version einer ähnlichen Funktion, deren Curry-Version 3 verschachtelte Funktionen enthielt. <br><br>  Die Funktion, die nach dem Aufruf von <code>volume(70)</code> implementiert das Konzept einer Teilfunktionsanwendung.  Currying und teilweise Anwendung von Funktionen sind einander sehr ähnlich, aber die Konzepte sind unterschiedlich. <br><br>  Bei teilweiser Anwendung wird die Funktion mit weniger Argumenten (weniger Arität) in eine andere Funktion umgewandelt.  Einige Argumente einer solchen Funktion sind fest (für sie sind Standardwerte festgelegt). <br><br>  Zum Beispiel gibt es eine solche Funktion: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">acidityRatio</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y, z)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> performOp(x,y,z) }</code> </pre> <br>  Es kann in Folgendes konvertiert werden: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">acidityRatio</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">y,z</span></span></span><span class="hljs-function">) =&gt;</span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> performOp(x,y,z)   } }</code> </pre> <br>  Die Implementierung der Funktion <code>performOp()</code> wird hier nicht angegeben, da sie die betrachteten Konzepte nicht beeinflusst. <br><br>  Die Funktion, die durch Aufrufen der neuen Funktion <code>acidityRatio()</code> mit einem Argument erhalten werden kann, dessen Wert festgelegt werden muss, ist die ursprüngliche Funktion, von der eines der Argumente festgelegt ist, und diese Funktion selbst benötigt ein Argument weniger als das ursprüngliche. <br><br>  Die Curry-Version der Funktion sieht folgendermaßen aus: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">acidityRatio</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (y) = &gt; {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (z) = &gt; {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> performOp(x,y,z)       }   } }</code> </pre> <br>  Wie Sie sehen können, entspricht die Anzahl der verschachtelten Funktionen beim Curry der Anzahl der Argumente der ursprünglichen Funktion.  Jede dieser Funktionen erwartet ein eigenes Argument.  Es ist klar, dass wenn die Funktion von Argumenten nicht oder nur ein Argument akzeptiert, es nicht Curry werden kann. <br><br>  In einer Situation, in der eine Funktion zwei Argumente hat, kann gesagt werden, dass die Ergebnisse ihrer Currying- und Teilanwendung zusammenfallen.  Zum Beispiel haben wir eine solche Funktion: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">div</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x,y)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x/y; }</code> </pre> <br>  Angenommen, wir müssen es neu schreiben, damit wir beim Korrigieren des ersten Arguments eine Funktion erhalten, die Berechnungen ausführt, wenn nur das zweite Argument an das Argument übergeben wird, dh wir müssen diese Funktion teilweise anwenden.  Es wird so aussehen: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">div</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">y</span></span></span><span class="hljs-function">) =&gt;</span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x/y;   } }</code> </pre> <br>  Das Ergebnis des Currying sieht genauso aus. <br><br><h2>  <font color="#3AC1EF">Zur praktischen Anwendung der Konzepte des Currying und der teilweisen Anwendung von Funktionen</font> </h2><br>  Currying und teilweise Anwendung von Funktionen können in verschiedenen Situationen nützlich sein.  Zum Beispiel bei der Entwicklung kleiner Module, die zur Wiederverwendung geeignet sind. <br><br>  Die teilweise Verwendung von Funktionen erleichtert die Verwendung von Universalmodulen.  Zum Beispiel haben wir einen Online-Shop, in dessen Code es eine Funktion gibt, mit der der zu zahlende Betrag unter Berücksichtigung des Rabatts berechnet wird. <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(price, discount)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> price * discount }</code> </pre> <br>  Es gibt eine bestimmte Kategorie von Kunden, nennen wir sie „geliebte Kunden“, denen wir 10% Rabatt gewähren.  Wenn ein solcher Kunde beispielsweise etwas für 500 US-Dollar kauft, gewähren wir ihm einen Rabatt von 50 US-Dollar: <br><br><pre> <code class="hljs pgsql">const price = discount(<span class="hljs-number"><span class="hljs-number">500</span></span>,<span class="hljs-number"><span class="hljs-number">0.10</span></span>); // <span class="hljs-meta"><span class="hljs-meta">$50</span></span> // <span class="hljs-meta"><span class="hljs-meta">$500</span></span> - <span class="hljs-meta"><span class="hljs-meta">$50</span></span> = <span class="hljs-meta"><span class="hljs-meta">$450</span></span></code> </pre> <br>  Es ist leicht zu bemerken, dass wir bei diesem Ansatz diese Funktion ständig mit zwei Argumenten aufrufen müssen: <br><br><pre> <code class="hljs pgsql">const price = discount(<span class="hljs-number"><span class="hljs-number">1500</span></span>,<span class="hljs-number"><span class="hljs-number">0.10</span></span>); // <span class="hljs-meta"><span class="hljs-meta">$150</span></span> // <span class="hljs-meta"><span class="hljs-meta">$1</span></span>,<span class="hljs-number"><span class="hljs-number">500</span></span> - <span class="hljs-meta"><span class="hljs-meta">$150</span></span> = <span class="hljs-meta"><span class="hljs-meta">$1</span></span>,<span class="hljs-number"><span class="hljs-number">350</span></span> const price = discount(<span class="hljs-number"><span class="hljs-number">2000</span></span>,<span class="hljs-number"><span class="hljs-number">0.10</span></span>); // <span class="hljs-meta"><span class="hljs-meta">$200</span></span> // <span class="hljs-meta"><span class="hljs-meta">$2</span></span>,<span class="hljs-number"><span class="hljs-number">000</span></span> - <span class="hljs-meta"><span class="hljs-meta">$200</span></span> = <span class="hljs-meta"><span class="hljs-meta">$1</span></span>,<span class="hljs-number"><span class="hljs-number">800</span></span> const price = discount(<span class="hljs-number"><span class="hljs-number">50</span></span>,<span class="hljs-number"><span class="hljs-number">0.10</span></span>); // <span class="hljs-meta"><span class="hljs-meta">$5</span></span> // <span class="hljs-meta"><span class="hljs-meta">$50</span></span> - <span class="hljs-meta"><span class="hljs-meta">$5</span></span> = <span class="hljs-meta"><span class="hljs-meta">$45</span></span> const price = discount(<span class="hljs-number"><span class="hljs-number">5000</span></span>,<span class="hljs-number"><span class="hljs-number">0.10</span></span>); // <span class="hljs-meta"><span class="hljs-meta">$500</span></span> // <span class="hljs-meta"><span class="hljs-meta">$5</span></span>,<span class="hljs-number"><span class="hljs-number">000</span></span> - <span class="hljs-meta"><span class="hljs-meta">$500</span></span> = <span class="hljs-meta"><span class="hljs-meta">$4</span></span>,<span class="hljs-number"><span class="hljs-number">500</span></span> const price = discount(<span class="hljs-number"><span class="hljs-number">300</span></span>,<span class="hljs-number"><span class="hljs-number">0.10</span></span>); // <span class="hljs-meta"><span class="hljs-meta">$30</span></span> // <span class="hljs-meta"><span class="hljs-meta">$300</span></span> - <span class="hljs-meta"><span class="hljs-meta">$30</span></span> = <span class="hljs-meta"><span class="hljs-meta">$270</span></span></code> </pre> <br>  Die ursprüngliche Funktion kann auf ein Formular reduziert werden, mit dem Sie neue Funktionen mit einer festgelegten Rabattstufe erhalten können, wenn Sie anrufen, um den Kaufbetrag zu überweisen.  Die Funktion <code>discount()</code> in unserem Beispiel hat zwei Argumente.  So sieht es aus, in das wir es konvertieren: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discount</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">discount</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">price</span></span></span><span class="hljs-function">) =&gt;</span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> price * discount;   } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tenPercentDiscount = discount(<span class="hljs-number"><span class="hljs-number">0.1</span></span>);</code> </pre> <br>  Die Funktion <code>tenPercentDiscount()</code> ist das Ergebnis einer teilweisen Anwendung der Funktion <code>discount()</code> .  Wenn Sie <code>tenPercentDiscount()</code> dieser Funktion aufrufen, reicht es aus, den Preis zu übergeben, und ein Rabatt von 10%, <code>tenPercentDiscount()</code> das <code>discount</code> , wird bereits festgelegt: <br><br><pre> <code class="hljs pgsql">tenPercentDiscount(<span class="hljs-number"><span class="hljs-number">500</span></span>); // <span class="hljs-meta"><span class="hljs-meta">$50</span></span> // <span class="hljs-meta"><span class="hljs-meta">$500</span></span> - <span class="hljs-meta"><span class="hljs-meta">$50</span></span> = <span class="hljs-meta"><span class="hljs-meta">$450</span></span></code> </pre> <br>  Wenn es Käufer in unserem Geschäft gibt, die beschlossen haben, einen Rabatt von 20% zu gewähren, können Sie die entsprechende Funktion erhalten, um mit ihnen wie folgt zu arbeiten: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> twentyPercentDiscount = discount(<span class="hljs-number"><span class="hljs-number">0.2</span></span>);</code> </pre> <br>  Jetzt kann die Funktion <code>twentyPercentDiscount()</code> aufgerufen werden, um die Kosten der Waren unter Berücksichtigung eines Rabattes von 20% zu berechnen: <br><br><pre> <code class="hljs pgsql">twentyPercentDiscount(<span class="hljs-number"><span class="hljs-number">500</span></span>); // <span class="hljs-number"><span class="hljs-number">100</span></span> // <span class="hljs-meta"><span class="hljs-meta">$500</span></span> - <span class="hljs-meta"><span class="hljs-meta">$100</span></span> = <span class="hljs-meta"><span class="hljs-meta">$400</span></span> twentyPercentDiscount(<span class="hljs-number"><span class="hljs-number">5000</span></span>); // <span class="hljs-number"><span class="hljs-number">1000</span></span> // <span class="hljs-meta"><span class="hljs-meta">$5</span></span>,<span class="hljs-number"><span class="hljs-number">000</span></span> - <span class="hljs-meta"><span class="hljs-meta">$1</span></span>,<span class="hljs-number"><span class="hljs-number">000</span></span> = <span class="hljs-meta"><span class="hljs-meta">$4</span></span>,<span class="hljs-number"><span class="hljs-number">000</span></span> twentyPercentDiscount(<span class="hljs-number"><span class="hljs-number">1000000</span></span>); // <span class="hljs-number"><span class="hljs-number">200000</span></span> // <span class="hljs-meta"><span class="hljs-meta">$1</span></span>,<span class="hljs-number"><span class="hljs-number">000</span></span>,<span class="hljs-number"><span class="hljs-number">000</span></span> - <span class="hljs-meta"><span class="hljs-meta">$200</span></span>,<span class="hljs-number"><span class="hljs-number">000</span></span> = <span class="hljs-meta"><span class="hljs-meta">$600</span></span>,<span class="hljs-number"><span class="hljs-number">000</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Universalfunktion zur teilweisen Anwendung anderer Funktionen</font> </h2><br>  Wir werden eine Funktion entwickeln, die jede Funktion akzeptiert und ihre Variante zurückgibt, bei der es sich um eine Funktion handelt, deren Argumente bereits festgelegt sind.  Hier ist der Code, mit dem Sie dies tun können (wenn Sie eine ähnliche Funktion entwickeln möchten, ist es durchaus möglich, dass Sie dadurch etwas anderes erhalten): <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">partial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn, </span></span><span class="hljs-rest_arg"><span class="hljs-function"><span class="hljs-params"><span class="hljs-rest_arg">...args</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (..._arg) =&gt; {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(...args, ..._arg);   } }</code> </pre> <br>  Die Funktion <code>partial()</code> akzeptiert die Funktion <code>fn</code> , die wir in die teilweise angewendete Funktion konvertieren möchten, und eine variable Anzahl von Parametern <code>(...args</code> ).  Die <code>rest</code> Anweisung wird verwendet, um alle Parameter nach <code>fn</code> in <code>args</code> . <br><br>  Diese Funktion gibt eine andere Funktion zurück, die auch eine variable Anzahl von Parametern ( <code>_arg</code> ) akzeptiert.  Diese Funktion ruft wiederum die ursprüngliche <code>fn</code> Funktion auf und <code>..._arg</code> ihr die Parameter <code>...args</code> und <code>..._arg</code> (unter Verwendung des <code>spread</code> Operators).  Die Funktion führt die Berechnung durch und gibt das Ergebnis zurück. <br><br>  Mit dieser Funktion erstellen wir eine Variante der Ihnen bereits bekannten Volumenfunktion, mit der das Volumen rechteckiger Parallelepipeds berechnet wird, deren eine Seite feststeht: <br><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(l,h,w)</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">l</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">h</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">w</span></span></span><span class="hljs-function"> } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hV</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">partial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(volume,100)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hV</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(200,900)</span></span></span><span class="hljs-function">; // 18000000 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hV</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(70,60)</span></span></span><span class="hljs-function">; // 420000</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier</a> finden Sie ein Beispiel für eine universelle Funktion zum Curryen anderer Funktionen. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  In diesem Artikel haben wir über das Currying und die teilweise Anwendung von Funktionen gesprochen.  Diese Methoden zum Transformieren von Funktionen werden in JavaScript aufgrund von Abschlüssen und aufgrund der Tatsache implementiert, dass Funktionen in JS Objekte der ersten Klasse sind (sie können als Argumente an andere Funktionen übergeben, von ihnen zurückgegeben und Variablen zugewiesen werden). <br><br>  <b>Liebe Leser!</b>  Verwenden Sie in Ihren Projekten Curry-Techniken und teilweise Anwendung von Funktionen? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427295/">https://habr.com/ru/post/de427295/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de427283/index.html">Wie hoch die Verfügbarkeit bei Kubernetes ist gewährleistet</a></li>
<li><a href="../de427285/index.html">Schule über die Grundlagen digitaler Schaltkreise: Nowosibirsk - Ok, Krasnojarsk - machen Sie sich bereit</a></li>
<li><a href="../de427289/index.html">Geologische 3D-Modellierung, Protokollierung und Technologie von Aramco Innovations</a></li>
<li><a href="../de427291/index.html">Minimieren Sie den Datenverkehr in ASP.NET Web Forms, anklickbare Div- und regelmäßige Serverabfragen</a></li>
<li><a href="../de427293/index.html">JavaScript-Entwurfsmuster</a></li>
<li><a href="../de427297/index.html">Apache Ignite + Apache Spark-Datenrahmen: zusammen mehr Spaß</a></li>
<li><a href="../de427299/index.html">Lassen Sie uns noch etwas sammeln? Konstruktor 3 in 1 "Mondflotte"</a></li>
<li><a href="../de427301/index.html">GitHub stürzt Datenbank ab</a></li>
<li><a href="../de427303/index.html">Windows verlangsamen Teil 2: Prozesse erstellen</a></li>
<li><a href="../de427307/index.html">Java-Backend-Testpraxis + Rest-Assured</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>