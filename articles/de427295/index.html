<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•¢ üë®üèº‚Äçüè≠ üôáüèΩ JavaScript-Currying-Funktionen üëü üíáüèø üç∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Funktionale Programmierung ist ein Stil der Programmentwicklung, bei dem einige spezifische Merkmale f√ºr die Arbeit mit Funktionen weit verbreitet sin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript-Currying-Funktionen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/427295/">  Funktionale Programmierung ist ein Stil der Programmentwicklung, bei dem einige spezifische Merkmale f√ºr die Arbeit mit Funktionen weit verbreitet sind.  Es geht insbesondere darum, Funktionen als Argumente auf andere Funktionen zu √ºbertragen und Funktionen von anderen Funktionen zur√ºckzugeben.  Das Konzept der ‚Äûreinen Funktionen‚Äú geh√∂rt auch zum funktionalen Programmierstil.  Die Ausgabe von reinen Funktionen h√§ngt nur von der Eingabe ab. Wenn sie ausgef√ºhrt werden, haben sie keinen Einfluss auf den Status des Programms. <br><br>  Funktionale Programmierprinzipien werden von vielen Sprachen unterst√ºtzt.  Unter ihnen sind JavaScript, Haskell, Clojure, Erlang.  Die Verwendung funktionaler Programmiermechanismen setzt unter anderem die Kenntnis von Konzepten wie reinen Funktionen, Curry-Funktionen und Funktionen h√∂herer Ordnung voraus. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ge/zo/ma/gezomag7bkhhzxqs3afxpu76g0k.png"></a> <br><br>  Das Material, das wir heute √ºbersetzen, handelt vom Curry.  Wir werden dar√ºber sprechen, wie Currying funktioniert und wie das Wissen √ºber diesen Mechanismus f√ºr einen JS-Entwickler n√ºtzlich sein kann. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Was ist Curry?</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Currying</a> in der funktionalen Programmierung ist die Umwandlung einer Funktion mit vielen Argumenten in eine Reihe verschachtelter Funktionen mit einem Argument.  Wenn eine Curry-Funktion mit einem √ºbergebenen Argument aufgerufen wird, gibt sie eine neue Funktion zur√ºck, die erwartet, dass das n√§chste Argument eintrifft.  Neue Funktionen, die auf das n√§chste Argument warten, werden bei jedem Aufruf der Curry-Funktion zur√ºckgegeben - bis die Funktion alle ben√∂tigten Argumente erh√§lt.  Die Argumente, die dank des Schlie√ümechanismus fr√ºher eingegangen sind, warten auf den Moment, in dem die Funktion alles erh√§lt, was sie zur Durchf√ºhrung der Berechnungen ben√∂tigt.  Nach Erhalt des letzten Arguments f√ºhrt die Funktion die Berechnung durch und gibt das Ergebnis zur√ºck. <br><br>  Wenn wir vom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Curry</a> sprechen, k√∂nnen wir sagen, dass dies der Prozess ist, eine Funktion mit mehreren Argumenten in eine Funktion mit weniger Arit√§t umzuwandeln. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arity</a> ist die Anzahl der Argumente f√ºr eine Funktion.  Hier ist zum Beispiel die Deklaration eines Funktionspaares: <br><br><pre><code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span></span> {    //... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_fn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b, c)</span></span></span></span> {    //... }</code> </pre> <br>  Die <code>fn</code> Funktion <code>_fn</code> zwei Argumente (dies ist eine bin√§re oder 2-ary-Funktion), die <code>_fn</code> Funktion <code>_fn</code> drei Argumente (eine tern√§re 3-ary-Funktion). <br><br>  Lassen Sie uns √ºber die Situation sprechen, in der w√§hrend des Currying eine Funktion mit mehreren Argumenten in eine Reihe von Funktionen konvertiert wird, von denen jede ein Argument akzeptiert. <br><br>  Betrachten Sie ein Beispiel.  Wir haben folgende Funktion: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">multiply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b, c)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a * b * c; }</code> </pre> <br>  Es dauert drei Argumente und gibt ihr Produkt zur√ºck: <br><br><pre> <code class="hljs objectivec">multiply(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 6</span></span></code> </pre> <br>  Lassen Sie uns nun dar√ºber nachdenken, wie Sie es in eine Reihe von Funktionen konvertieren k√∂nnen, von denen jede ein Argument ben√∂tigt.  Lassen Sie uns eine Curry-Version dieser Funktion erstellen und untersuchen, wie Sie beim Aufrufen mehrerer Funktionen dasselbe Ergebnis erzielen: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">multiply</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">b</span></span></span><span class="hljs-function">) =&gt;</span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c</span></span></span><span class="hljs-function">) =&gt;</span></span> {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a * b * c       }   } } log(multiply(<span class="hljs-number"><span class="hljs-number">1</span></span>)(<span class="hljs-number"><span class="hljs-number">2</span></span>)(<span class="hljs-number"><span class="hljs-number">3</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// 6</span></span></code> </pre> <br>  Wie Sie sehen k√∂nnen, haben wir hier den Aufruf in eine einzelne Funktion mit drei Argumenten konvertiert - <code>multiply(1,2,3)</code> mit dem Aufruf in drei Funktionen - <code>multiply(1)(2)(3)</code> . <br><br>  Es stellt sich heraus, dass aus einer Funktion mehrere Funktionen geworden sind.  Bei Verwendung der neuen Konstruktion nimmt jede Funktion mit Ausnahme der letzten, die das Ergebnis von Berechnungen zur√ºckgibt, ein Argument und eine andere Funktion zur√ºck, die ebenfalls ein Argument akzeptieren und eine andere Funktion zur√ºckgeben kann.  Wenn Ihnen eine Konstruktion der Form <code>multiply(1)(2)(3)</code> nicht sehr klar erscheint, schreiben wir sie in diese Form, um dies besser zu verstehen: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mul1 = multiply(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mul2 = mul1(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = mul2(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(result); <span class="hljs-comment"><span class="hljs-comment">// 6</span></span></code> </pre> <br>  Lassen Sie uns nun Zeile f√ºr Zeile wissen, was hier passiert. <br><br>  Zuerst √ºbergeben wir Argument <code>1</code> an die <code>multiply</code> : <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mul1 = multiply(<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Wenn diese Funktion funktioniert, funktioniert dieses Design: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">b</span></span></span><span class="hljs-function">) =&gt;</span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c</span></span></span><span class="hljs-function">) =&gt;</span></span> {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a * b * c       }   }</code> </pre> <br>  Jetzt hat <code>mul1</code> einen Verweis auf eine Funktion, die ein Argument <code>mul1</code> . <code>b</code>  Wir rufen die Funktion <code>mul1</code> und √ºbergeben sie <code>2</code> : <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mul2 = mul1(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  Als Ergebnis dieses Aufrufs wird der folgende Code ausgef√ºhrt: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>) =&gt; {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a * b * <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>       }</code> </pre> <br>  Die <code>mul2</code> enth√§lt einen Verweis auf eine Funktion, die sich beispielsweise aufgrund der folgenden Operation darin befinden k√∂nnte: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul2</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c)</span></span></span><span class="hljs-function"> =&gt;</span></span> {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a * b * c       }</code> </pre> <br>  Wenn wir nun die Funktion <code>mul2</code> und <code>3</code> , f√ºhrt die Funktion die erforderlichen Berechnungen mit den Argumenten <code>a</code> und <code>b</code> : <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = mul2(<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>  Das Ergebnis dieser Berechnungen ist <code>6</code> : <br><br><pre> <code class="hljs lisp">log(<span class="hljs-name"><span class="hljs-name">result</span></span>)<span class="hljs-comment"><span class="hljs-comment">; // 6</span></span></code> </pre> <br>  Die <code>mul2</code> Funktion, die die h√∂chste Verschachtelungsebene aufweist, hat Zugriff auf den Bereich, auf die Abschl√ºsse, die durch die <code>multiply</code> und <code>mul1</code> .  Aus diesem Grund k√∂nnen in der Funktion <code>mul2</code> Berechnungen mit Variablen durchgef√ºhrt werden, die in Funktionen deklariert sind, deren Ausf√ºhrung bereits abgeschlossen wurde, die bereits einige Werte zur√ºckgegeben haben und vom Garbage Collector verarbeitet werden. <br><br>  Oben haben wir ein abstraktes Beispiel untersucht, aber im Wesentlichen dieselbe Funktion, mit der das Volumen einer rechteckigen Box berechnet werden soll. <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(l,w,h)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l * w * h; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vol = volume(<span class="hljs-number"><span class="hljs-number">100</span></span>,<span class="hljs-number"><span class="hljs-number">20</span></span>,<span class="hljs-number"><span class="hljs-number">90</span></span>) <span class="hljs-comment"><span class="hljs-comment">// 180000</span></span></code> </pre> <br>  So sieht die Curry-Version aus: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volume</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">l</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">w</span></span></span><span class="hljs-function">) =&gt;</span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">h</span></span></span><span class="hljs-function">) =&gt;</span></span> {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l * w * h       }   } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vol = volume(<span class="hljs-number"><span class="hljs-number">100</span></span>)(<span class="hljs-number"><span class="hljs-number">20</span></span>)(<span class="hljs-number"><span class="hljs-number">90</span></span>) <span class="hljs-comment"><span class="hljs-comment">// 180000</span></span></code> </pre> <br>  Das Currying basiert also auf der folgenden Idee: Auf der Grundlage einer bestimmten Funktion wird eine andere Funktion erstellt, die eine spezielle Funktion zur√ºckgibt. <br><br><h2>  <font color="#3AC1EF">Currying und teilweise Nutzung von Funktionen</font> </h2><br>  Vielleicht besteht nun das Gef√ºhl, dass die Anzahl der verschachtelten Funktionen, wenn eine Funktion als Satz verschachtelter Funktionen dargestellt wird, von der Anzahl der Argumente f√ºr die Funktion abh√§ngt.  Und wenn es um Curry geht, dann ist es das auch. <br><br>  Eine spezielle Version der Funktion zur Berechnung des Volumens, die wir bereits gesehen haben, kann wie folgt erstellt werden: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volume</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">l</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">w, h</span></span></span><span class="hljs-function">) =&gt;</span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l * w * h   } }</code> </pre> <br>  Hier werden Ideen angewendet, die den oben diskutierten sehr √§hnlich sind.  Sie k√∂nnen diese Funktion wie folgt verwenden: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hV = volume(<span class="hljs-number"><span class="hljs-number">70</span></span>); hV(<span class="hljs-number"><span class="hljs-number">203</span></span>,<span class="hljs-number"><span class="hljs-number">142</span></span>); hV(<span class="hljs-number"><span class="hljs-number">220</span></span>,<span class="hljs-number"><span class="hljs-number">122</span></span>); hV(<span class="hljs-number"><span class="hljs-number">120</span></span>,<span class="hljs-number"><span class="hljs-number">123</span></span>);</code> </pre> <br>  Und Sie k√∂nnen dies tun: <br><br><pre> <code class="hljs lisp">volume(<span class="hljs-number"><span class="hljs-number">70</span></span>)(<span class="hljs-number"><span class="hljs-number">90</span></span>,<span class="hljs-number"><span class="hljs-number">30</span></span>)<span class="hljs-comment"><span class="hljs-comment">; volume(70)(390,320); volume(70)(940,340);</span></span></code> </pre> <br>  In der Tat k√∂nnen Sie hier sehen, wie wir mit dem Befehl <code>volume(70)</code> eine spezielle Funktion zur Berechnung des Volumens von K√∂rpern erstellt haben, deren Dimensionen (n√§mlich L√§nge, <code>l</code> ) festgelegt sind.  Die <code>volume</code> Funktion erwartet 3 Argumente und enth√§lt 2 verschachtelte Funktionen, im Gegensatz zur vorherigen Version einer √§hnlichen Funktion, deren Curry-Version 3 verschachtelte Funktionen enthielt. <br><br>  Die Funktion, die nach dem Aufruf von <code>volume(70)</code> implementiert das Konzept einer Teilfunktionsanwendung.  Currying und teilweise Anwendung von Funktionen sind einander sehr √§hnlich, aber die Konzepte sind unterschiedlich. <br><br>  Bei teilweiser Anwendung wird die Funktion mit weniger Argumenten (weniger Arit√§t) in eine andere Funktion umgewandelt.  Einige Argumente einer solchen Funktion sind fest (f√ºr sie sind Standardwerte festgelegt). <br><br>  Zum Beispiel gibt es eine solche Funktion: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">acidityRatio</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y, z)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> performOp(x,y,z) }</code> </pre> <br>  Es kann in Folgendes konvertiert werden: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">acidityRatio</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">y,z</span></span></span><span class="hljs-function">) =&gt;</span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> performOp(x,y,z)   } }</code> </pre> <br>  Die Implementierung der Funktion <code>performOp()</code> wird hier nicht angegeben, da sie die betrachteten Konzepte nicht beeinflusst. <br><br>  Die Funktion, die durch Aufrufen der neuen Funktion <code>acidityRatio()</code> mit einem Argument erhalten werden kann, dessen Wert festgelegt werden muss, ist die urspr√ºngliche Funktion, von der eines der Argumente festgelegt ist, und diese Funktion selbst ben√∂tigt ein Argument weniger als das urspr√ºngliche. <br><br>  Die Curry-Version der Funktion sieht folgenderma√üen aus: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">acidityRatio</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (y) = &gt; {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (z) = &gt; {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> performOp(x,y,z)       }   } }</code> </pre> <br>  Wie Sie sehen k√∂nnen, entspricht die Anzahl der verschachtelten Funktionen beim Curry der Anzahl der Argumente der urspr√ºnglichen Funktion.  Jede dieser Funktionen erwartet ein eigenes Argument.  Es ist klar, dass wenn die Funktion von Argumenten nicht oder nur ein Argument akzeptiert, es nicht Curry werden kann. <br><br>  In einer Situation, in der eine Funktion zwei Argumente hat, kann gesagt werden, dass die Ergebnisse ihrer Currying- und Teilanwendung zusammenfallen.  Zum Beispiel haben wir eine solche Funktion: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">div</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x,y)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x/y; }</code> </pre> <br>  Angenommen, wir m√ºssen es neu schreiben, damit wir beim Korrigieren des ersten Arguments eine Funktion erhalten, die Berechnungen ausf√ºhrt, wenn nur das zweite Argument an das Argument √ºbergeben wird, dh wir m√ºssen diese Funktion teilweise anwenden.  Es wird so aussehen: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">div</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">y</span></span></span><span class="hljs-function">) =&gt;</span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x/y;   } }</code> </pre> <br>  Das Ergebnis des Currying sieht genauso aus. <br><br><h2>  <font color="#3AC1EF">Zur praktischen Anwendung der Konzepte des Currying und der teilweisen Anwendung von Funktionen</font> </h2><br>  Currying und teilweise Anwendung von Funktionen k√∂nnen in verschiedenen Situationen n√ºtzlich sein.  Zum Beispiel bei der Entwicklung kleiner Module, die zur Wiederverwendung geeignet sind. <br><br>  Die teilweise Verwendung von Funktionen erleichtert die Verwendung von Universalmodulen.  Zum Beispiel haben wir einen Online-Shop, in dessen Code es eine Funktion gibt, mit der der zu zahlende Betrag unter Ber√ºcksichtigung des Rabatts berechnet wird. <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(price, discount)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> price * discount }</code> </pre> <br>  Es gibt eine bestimmte Kategorie von Kunden, nennen wir sie ‚Äûgeliebte Kunden‚Äú, denen wir 10% Rabatt gew√§hren.  Wenn ein solcher Kunde beispielsweise etwas f√ºr 500 US-Dollar kauft, gew√§hren wir ihm einen Rabatt von 50 US-Dollar: <br><br><pre> <code class="hljs pgsql">const price = discount(<span class="hljs-number"><span class="hljs-number">500</span></span>,<span class="hljs-number"><span class="hljs-number">0.10</span></span>); // <span class="hljs-meta"><span class="hljs-meta">$50</span></span> // <span class="hljs-meta"><span class="hljs-meta">$500</span></span> - <span class="hljs-meta"><span class="hljs-meta">$50</span></span> = <span class="hljs-meta"><span class="hljs-meta">$450</span></span></code> </pre> <br>  Es ist leicht zu bemerken, dass wir bei diesem Ansatz diese Funktion st√§ndig mit zwei Argumenten aufrufen m√ºssen: <br><br><pre> <code class="hljs pgsql">const price = discount(<span class="hljs-number"><span class="hljs-number">1500</span></span>,<span class="hljs-number"><span class="hljs-number">0.10</span></span>); // <span class="hljs-meta"><span class="hljs-meta">$150</span></span> // <span class="hljs-meta"><span class="hljs-meta">$1</span></span>,<span class="hljs-number"><span class="hljs-number">500</span></span> - <span class="hljs-meta"><span class="hljs-meta">$150</span></span> = <span class="hljs-meta"><span class="hljs-meta">$1</span></span>,<span class="hljs-number"><span class="hljs-number">350</span></span> const price = discount(<span class="hljs-number"><span class="hljs-number">2000</span></span>,<span class="hljs-number"><span class="hljs-number">0.10</span></span>); // <span class="hljs-meta"><span class="hljs-meta">$200</span></span> // <span class="hljs-meta"><span class="hljs-meta">$2</span></span>,<span class="hljs-number"><span class="hljs-number">000</span></span> - <span class="hljs-meta"><span class="hljs-meta">$200</span></span> = <span class="hljs-meta"><span class="hljs-meta">$1</span></span>,<span class="hljs-number"><span class="hljs-number">800</span></span> const price = discount(<span class="hljs-number"><span class="hljs-number">50</span></span>,<span class="hljs-number"><span class="hljs-number">0.10</span></span>); // <span class="hljs-meta"><span class="hljs-meta">$5</span></span> // <span class="hljs-meta"><span class="hljs-meta">$50</span></span> - <span class="hljs-meta"><span class="hljs-meta">$5</span></span> = <span class="hljs-meta"><span class="hljs-meta">$45</span></span> const price = discount(<span class="hljs-number"><span class="hljs-number">5000</span></span>,<span class="hljs-number"><span class="hljs-number">0.10</span></span>); // <span class="hljs-meta"><span class="hljs-meta">$500</span></span> // <span class="hljs-meta"><span class="hljs-meta">$5</span></span>,<span class="hljs-number"><span class="hljs-number">000</span></span> - <span class="hljs-meta"><span class="hljs-meta">$500</span></span> = <span class="hljs-meta"><span class="hljs-meta">$4</span></span>,<span class="hljs-number"><span class="hljs-number">500</span></span> const price = discount(<span class="hljs-number"><span class="hljs-number">300</span></span>,<span class="hljs-number"><span class="hljs-number">0.10</span></span>); // <span class="hljs-meta"><span class="hljs-meta">$30</span></span> // <span class="hljs-meta"><span class="hljs-meta">$300</span></span> - <span class="hljs-meta"><span class="hljs-meta">$30</span></span> = <span class="hljs-meta"><span class="hljs-meta">$270</span></span></code> </pre> <br>  Die urspr√ºngliche Funktion kann auf ein Formular reduziert werden, mit dem Sie neue Funktionen mit einer festgelegten Rabattstufe erhalten k√∂nnen, wenn Sie anrufen, um den Kaufbetrag zu √ºberweisen.  Die Funktion <code>discount()</code> in unserem Beispiel hat zwei Argumente.  So sieht es aus, in das wir es konvertieren: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discount</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">discount</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">price</span></span></span><span class="hljs-function">) =&gt;</span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> price * discount;   } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tenPercentDiscount = discount(<span class="hljs-number"><span class="hljs-number">0.1</span></span>);</code> </pre> <br>  Die Funktion <code>tenPercentDiscount()</code> ist das Ergebnis einer teilweisen Anwendung der Funktion <code>discount()</code> .  Wenn Sie <code>tenPercentDiscount()</code> dieser Funktion aufrufen, reicht es aus, den Preis zu √ºbergeben, und ein Rabatt von 10%, <code>tenPercentDiscount()</code> das <code>discount</code> , wird bereits festgelegt: <br><br><pre> <code class="hljs pgsql">tenPercentDiscount(<span class="hljs-number"><span class="hljs-number">500</span></span>); // <span class="hljs-meta"><span class="hljs-meta">$50</span></span> // <span class="hljs-meta"><span class="hljs-meta">$500</span></span> - <span class="hljs-meta"><span class="hljs-meta">$50</span></span> = <span class="hljs-meta"><span class="hljs-meta">$450</span></span></code> </pre> <br>  Wenn es K√§ufer in unserem Gesch√§ft gibt, die beschlossen haben, einen Rabatt von 20% zu gew√§hren, k√∂nnen Sie die entsprechende Funktion erhalten, um mit ihnen wie folgt zu arbeiten: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> twentyPercentDiscount = discount(<span class="hljs-number"><span class="hljs-number">0.2</span></span>);</code> </pre> <br>  Jetzt kann die Funktion <code>twentyPercentDiscount()</code> aufgerufen werden, um die Kosten der Waren unter Ber√ºcksichtigung eines Rabattes von 20% zu berechnen: <br><br><pre> <code class="hljs pgsql">twentyPercentDiscount(<span class="hljs-number"><span class="hljs-number">500</span></span>); // <span class="hljs-number"><span class="hljs-number">100</span></span> // <span class="hljs-meta"><span class="hljs-meta">$500</span></span> - <span class="hljs-meta"><span class="hljs-meta">$100</span></span> = <span class="hljs-meta"><span class="hljs-meta">$400</span></span> twentyPercentDiscount(<span class="hljs-number"><span class="hljs-number">5000</span></span>); // <span class="hljs-number"><span class="hljs-number">1000</span></span> // <span class="hljs-meta"><span class="hljs-meta">$5</span></span>,<span class="hljs-number"><span class="hljs-number">000</span></span> - <span class="hljs-meta"><span class="hljs-meta">$1</span></span>,<span class="hljs-number"><span class="hljs-number">000</span></span> = <span class="hljs-meta"><span class="hljs-meta">$4</span></span>,<span class="hljs-number"><span class="hljs-number">000</span></span> twentyPercentDiscount(<span class="hljs-number"><span class="hljs-number">1000000</span></span>); // <span class="hljs-number"><span class="hljs-number">200000</span></span> // <span class="hljs-meta"><span class="hljs-meta">$1</span></span>,<span class="hljs-number"><span class="hljs-number">000</span></span>,<span class="hljs-number"><span class="hljs-number">000</span></span> - <span class="hljs-meta"><span class="hljs-meta">$200</span></span>,<span class="hljs-number"><span class="hljs-number">000</span></span> = <span class="hljs-meta"><span class="hljs-meta">$600</span></span>,<span class="hljs-number"><span class="hljs-number">000</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Universalfunktion zur teilweisen Anwendung anderer Funktionen</font> </h2><br>  Wir werden eine Funktion entwickeln, die jede Funktion akzeptiert und ihre Variante zur√ºckgibt, bei der es sich um eine Funktion handelt, deren Argumente bereits festgelegt sind.  Hier ist der Code, mit dem Sie dies tun k√∂nnen (wenn Sie eine √§hnliche Funktion entwickeln m√∂chten, ist es durchaus m√∂glich, dass Sie dadurch etwas anderes erhalten): <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">partial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn, </span></span><span class="hljs-rest_arg"><span class="hljs-function"><span class="hljs-params"><span class="hljs-rest_arg">...args</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (..._arg) =&gt; {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(...args, ..._arg);   } }</code> </pre> <br>  Die Funktion <code>partial()</code> akzeptiert die Funktion <code>fn</code> , die wir in die teilweise angewendete Funktion konvertieren m√∂chten, und eine variable Anzahl von Parametern <code>(...args</code> ).  Die <code>rest</code> Anweisung wird verwendet, um alle Parameter nach <code>fn</code> in <code>args</code> . <br><br>  Diese Funktion gibt eine andere Funktion zur√ºck, die auch eine variable Anzahl von Parametern ( <code>_arg</code> ) akzeptiert.  Diese Funktion ruft wiederum die urspr√ºngliche <code>fn</code> Funktion auf und <code>..._arg</code> ihr die Parameter <code>...args</code> und <code>..._arg</code> (unter Verwendung des <code>spread</code> Operators).  Die Funktion f√ºhrt die Berechnung durch und gibt das Ergebnis zur√ºck. <br><br>  Mit dieser Funktion erstellen wir eine Variante der Ihnen bereits bekannten Volumenfunktion, mit der das Volumen rechteckiger Parallelepipeds berechnet wird, deren eine Seite feststeht: <br><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(l,h,w)</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">l</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">h</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">w</span></span></span><span class="hljs-function"> } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hV</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">partial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(volume,100)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hV</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(200,900)</span></span></span><span class="hljs-function">; // 18000000 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hV</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(70,60)</span></span></span><span class="hljs-function">; // 420000</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier</a> finden Sie ein Beispiel f√ºr eine universelle Funktion zum Curryen anderer Funktionen. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  In diesem Artikel haben wir √ºber das Currying und die teilweise Anwendung von Funktionen gesprochen.  Diese Methoden zum Transformieren von Funktionen werden in JavaScript aufgrund von Abschl√ºssen und aufgrund der Tatsache implementiert, dass Funktionen in JS Objekte der ersten Klasse sind (sie k√∂nnen als Argumente an andere Funktionen √ºbergeben, von ihnen zur√ºckgegeben und Variablen zugewiesen werden). <br><br>  <b>Liebe Leser!</b>  Verwenden Sie in Ihren Projekten Curry-Techniken und teilweise Anwendung von Funktionen? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427295/">https://habr.com/ru/post/de427295/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de427283/index.html">Wie hoch die Verf√ºgbarkeit bei Kubernetes ist gew√§hrleistet</a></li>
<li><a href="../de427285/index.html">Schule √ºber die Grundlagen digitaler Schaltkreise: Nowosibirsk - Ok, Krasnojarsk - machen Sie sich bereit</a></li>
<li><a href="../de427289/index.html">Geologische 3D-Modellierung, Protokollierung und Technologie von Aramco Innovations</a></li>
<li><a href="../de427291/index.html">Minimieren Sie den Datenverkehr in ASP.NET Web Forms, anklickbare Div- und regelm√§√üige Serverabfragen</a></li>
<li><a href="../de427293/index.html">JavaScript-Entwurfsmuster</a></li>
<li><a href="../de427297/index.html">Apache Ignite + Apache Spark-Datenrahmen: zusammen mehr Spa√ü</a></li>
<li><a href="../de427299/index.html">Lassen Sie uns noch etwas sammeln? Konstruktor 3 in 1 "Mondflotte"</a></li>
<li><a href="../de427301/index.html">GitHub st√ºrzt Datenbank ab</a></li>
<li><a href="../de427303/index.html">Windows verlangsamen Teil 2: Prozesse erstellen</a></li>
<li><a href="../de427307/index.html">Java-Backend-Testpraxis + Rest-Assured</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>