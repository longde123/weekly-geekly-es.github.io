<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¥ üëÜüèª üçÉ Introducci√≥n a la programaci√≥n de sombreadores para dise√±os ü§≥ üèÇüèø üíÖüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="WebGL ha existido durante mucho tiempo, se han escrito muchos art√≠culos sobre sombreadores, hay una serie de lecciones. Pero en su mayor parte, son de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introducci√≥n a la programaci√≥n de sombreadores para dise√±os</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420847/"><p><img src="https://habrastorage.org/webt/mx/-v/ry/mx-vryd99xgt73gzsgzhfvcqpe0.jpeg"></p><br><p> WebGL ha existido durante mucho tiempo, se han escrito muchos art√≠culos sobre sombreadores, hay una serie de lecciones.  Pero en su mayor parte, son demasiado complicados para el dise√±ador de dise√±o.  Es incluso mejor decir que cubren grandes cantidades de informaci√≥n que necesita el desarrollador del motor del juego en lugar del dise√±ador de dise√±o.  Inmediatamente comienzan con la construcci√≥n de una escena compleja, una c√°mara, luz ... En un sitio normal, para crear un par de efectos con fotos, todo este conocimiento es redundante.  Como resultado, las personas crean estructuras arquitect√≥nicas muy complejas y escriben sombreadores largos y largos para acciones muy simples en esencia. </p><br><p>  Todo esto provoc√≥ una introducci√≥n a los aspectos del trabajo con sombreadores que probablemente sean √∫tiles para el dise√±ador de dise√±o para crear varios efectos 2D con im√°genes en el sitio.  Por supuesto, ajustado por el hecho de que ellos mismos son relativamente raramente utilizados en el dise√±o de interfaces.  Haremos una plantilla de inicio en JS puro sin bibliotecas de terceros y consideraremos las ideas de crear algunos efectos populares basados ‚Äã‚Äãen el cambio de p√≠xeles, que son dif√≠ciles de hacer en SVG, pero al mismo tiempo se implementan f√°cilmente usando sombreadores. </p><a name="habracut"></a><br><blockquote> Se supone que el lector ya est√° familiarizado con el <code>canvas</code> , describe qu√© es WebGL y tiene un conocimiento m√≠nimo de las matem√°ticas.  Algunos puntos se describir√°n de manera simplista, no acad√©mica, para dar una comprensi√≥n pr√°ctica de las tecnolog√≠as para trabajar con ellos, y no una teor√≠a completa de su cocina interior o t√©rminos para el aprendizaje.  Hay libros inteligentes para esto. </blockquote><p>  <em>Cabe se√±alar de inmediato que los editores integrados en el art√≠culo de CodePen tienen la capacidad de influir en el rendimiento de lo que se hace en ellos.</em>  <em>Entonces, antes de escribir un comentario de que algo se est√° desacelerando en su macbook, aseg√∫rese de que el problema no provenga de ellos.</em> </p><br><h2 id="osnovnye-idei">  Ideas principales </h2><br><p>  <strong>¬øQu√© es un sombreador?</strong> </p><br><p>  ¬øQu√© es un sombreador de fragmentos?  Este es esencialmente un peque√±o programa.  Se ejecuta para cada p√≠xel en el <code>anvas</code> .  Si tenemos un <code>canvas</code> tama√±o 1000x500px, entonces este programa se ejecutar√° 500,000 veces, recibiendo cada vez como par√°metros de entrada las coordenadas del p√≠xel para el que se est√° ejecutando actualmente.  Todo esto sucede en la GPU en una variedad de hilos paralelos.  En el procesador central, tales c√°lculos tomar√≠an mucho m√°s tiempo. </p><br><p>  Un sombreador de v√©rtices tambi√©n es un programa, pero no se ejecuta para cada p√≠xel en el <code>canvas</code> , sino para cada v√©rtice en las formas a partir de las cuales todo se construye en un espacio tridimensional.  Tambi√©n paralelo a todos los v√©rtices.  En consecuencia, la entrada recibe las coordenadas del v√©rtice, no el p√≠xel. </p><br><p>  Adem√°s en el contexto de nuestra tarea, ocurre lo siguiente: </p><br><ul><li>  Tomamos un conjunto de coordenadas de los v√©rtices del rect√°ngulo, sobre el cual la fotograf√≠a ser√° "dibujada". </li><li>  Un sombreador de v√©rtices para cada v√©rtice considera su ubicaci√≥n en el espacio.  Para nosotros, esto se reducir√° a un caso especial: un plano paralelo a la pantalla.  Fotos en 3d que no necesitamos.  La proyecci√≥n posterior en el plano de la pantalla no puede decir nada. </li><li>  Adem√°s, para cada fragmento visible, y en nuestro contexto para todos los fragmentos de p√≠xeles, se ejecuta un sombreador de fragmentos, toma una foto y las coordenadas actuales, cuenta algo y da color para este p√≠xel en particular. </li><li>  Si no hab√≠a l√≥gica en el sombreador de fragmentos, entonces el comportamiento de todo esto se <code>drawImage()</code> m√©todo <code>drawImage()</code> del <code>canvas</code> .  Pero luego agregamos esta l√≥gica y obtenemos muchas cosas interesantes. </li></ul><br><p>  Esta es una descripci√≥n muy simplificada, pero debe quedar claro qui√©n hace qu√©. </p><br><p>  <strong>Un poco sobre sintaxis</strong> </p><br><p>  Los sombreadores est√°n escritos en GLSL - OpenGL Shading Language.  Este lenguaje es muy similar a C.  No tiene sentido describir la sintasis completa y los m√©todos est√°ndar aqu√≠, pero siempre puede usar la hoja de trucos: </p><br><div class="spoiler">  <b class="spoiler_title">Spoiler con fotos</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/id/vb/6e/idvb6ew9k7ackf94bjviuxavhxc.jpeg"><br><img src="https://habrastorage.org/webt/ye/ax/b4/yeaxb44uvcjkhir92ezxcsnc2oo.jpeg"><br><img src="https://habrastorage.org/webt/f7/2q/5q/f72q5qifi99xwv5nsqfnkb2x1au.jpeg"><br><img src="https://habrastorage.org/webt/8c/ty/in/8ctyinenggjs8gutaj484oreep4.jpeg"></p></div></div><br><p>  Cada sombreador tiene una funci√≥n principal, con la que comienza su ejecuci√≥n.  Los par√°metros de entrada est√°ndar para sombreadores y la salida de los resultados de su trabajo se implementan a trav√©s de variables especiales con el prefijo <code>gl_</code> .  Se reservan por adelantado y est√°n disponibles dentro de estos mismos sombreadores.  Entonces, las coordenadas de v√©rtice para el sombreador de v√©rtices se encuentran en la variable <code>gl_Position</code> , las coordenadas de fragmento (p√≠xel) para el sombreador de fragmentos se encuentran en <code>gl_FragCoord</code> , etc.  Siempre puede encontrar la lista completa de variables especiales disponibles en la misma hoja de trucos. </p><br><p>  Los principales tipos de variables en GLSL son bastante modestos: <code>void</code> , <code>bool</code> , <code>int</code> , <code>float</code> ... Si trabaj√≥ con alg√∫n lenguaje tipo C, ya los ha visto.  Hay otros tipos, en particular vectores de diferentes dimensiones: <code>vec2</code> , <code>vec3</code> , <code>vec4</code> .  Los usaremos constantemente para coordenadas y colores.  Las variables que podemos crear son de tres modificaciones importantes: </p><br><ul><li>  <strong>Uniforme</strong> : datos globales en todos los sentidos.  Pasado desde el exterior, lo mismo para todas las llamadas de sombreadores de v√©rtices y fragmentos. </li><li>  <strong>Atributo</strong> : estos datos se transfieren con mayor precisi√≥n y para cada llamada de sombreador puede ser diferente. </li><li>  <strong>Variar</strong> : necesario para transferir datos de sombreadores de v√©rtices a sombreadores de fragmentos. </li></ul><br><blockquote>  Es √∫til prefijar u / a / v a todas las variables en los sombreadores para facilitar la comprensi√≥n de qu√© datos provienen. </blockquote><p>  Creo que vale la pena pasar a un ejemplo pr√°ctico para ver de inmediato todo esto en acci√≥n y no cargar su memoria. </p><br><h2 id="gotovim-startovyy-shablon">  Plantilla de inicio de cocci√≥n </h2><br><p>  Comencemos con JS.  Como suele suceder cuando se trabaja con el <code>canvas</code> , lo necesitamos y el contexto.  Para no cargar el c√≥digo de muestra, crearemos variables globales: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CANVAS = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(IDs.canvas); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GL = canvas.getContext(<span class="hljs-string"><span class="hljs-string">'webgl'</span></span>);</code> </pre> <br><p>  Omita el momento asociado con el tama√±o del <code>canvas</code> y su rec√°lculo al cambiar el tama√±o de la ventana del navegador.  Este c√≥digo se incluye en los ejemplos y generalmente depende del resto del dise√±o.  No tiene sentido concentrarse en √©l.  Pasemos a las acciones con WebGL. </p><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProgram</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shaders</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getShaders</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PROGRAM</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProgram</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attachShader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PROGRAM, shaders.vertex)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attachShader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PROGRAM, shaders.fragment)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">linkProgram</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PROGRAM)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useProgram</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PROGRAM)</span></span></span><span class="hljs-function">; }</span></span></code> </pre> <br><p>  Primero, compilamos los sombreadores (ser√° un poco m√°s bajo), creamos un programa, le agregamos nuestros dos sombreadores y hacemos un enlace.  En este punto, se verifica la compatibilidad de los sombreadores.  ¬øRecuerdas las variables variables que se pasan del v√©rtice al fragmento?  - En particular, sus conjuntos se comprueban aqu√≠ para que m√°s adelante en el proceso no resulte que algo no se ha transmitido o transmitido, pero no en absoluto.  Por supuesto, esta verificaci√≥n no revelar√° errores l√≥gicos, creo que esto es comprensible. </p><br><p>  Las coordenadas de los v√©rtices se almacenar√°n en una matriz de b√∫fer especial y se transmitir√°n en partes, un v√©rtice, a cada llamada de sombreador.  A continuaci√≥n, describimos algunos detalles para trabajar con estas piezas.  En primer lugar, utilizaremos las coordenadas del v√©rtice en el sombreador a trav√©s de la <code>a_position</code> atributo <code>a_position</code> .  Se le puede llamar de manera diferente, no importa.  Obtenemos su ubicaci√≥n (esto es algo as√≠ como un puntero en C, pero no un puntero, sino un n√∫mero de entidad que existe solo dentro del programa). </p><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vertexPositionAttribute = GL.getAttribLocation(<span class="hljs-keyword"><span class="hljs-keyword">PROGRAM</span></span>, <span class="hljs-string"><span class="hljs-string">'a_position'</span></span>);</code> </pre> <br><p>  A continuaci√≥n, indicamos que se pasar√° una matriz con coordenadas a trav√©s de esta variable (en el sombreador mismo, ya la percibiremos como un vector).  WebGL determinar√° de forma independiente qu√© coordenadas de qu√© puntos en nuestras formas deben pasarse a qu√© llamada de sombreador.  Solo establecemos los par√°metros para la matriz de vectores que se transmitir√°n: dimensi√≥n - 2 (transmitiremos las coordenadas <code>(x,y)</code> ), consta de n√∫meros y no est√° normalizado.  Los √∫ltimos par√°metros no nos interesan, dejamos los ceros por defecto. </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.enableVertexAttribArray</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">vertexPositionAttribute</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.vertexAttribPointer</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">vertexPositionAttribute</span></span>, 2, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.FLOAT</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">false</span></span>, 0, 0);</code> </pre> <br><p>  Ahora cree el b√∫fer en s√≠ con las coordenadas de los v√©rtices de nuestro plano, en el que se mostrar√° la foto.  Las coordenadas "2d" son m√°s claras, pero para nuestras tareas esto es lo m√°s importante. </p><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPlane</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.ARRAY_BUFFER, GL.createBuffer()</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bufferData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( GL.ARRAY_BUFFER, new Float32Array([ -1, -1, -1, 1, 1, -1, 1, 1 ])</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">STATIC_DRAW</span></span></span><span class="hljs-function"> ); }</span></span></code> </pre> <br><p>  Este cuadrado ser√° suficiente para todos nuestros ejemplos.  <code>STATIC_DRAW</code> significa que el b√∫fer se carga una vez y luego se reutilizar√°.  No volveremos a subir nada. </p><br><p>  Antes de pasar a los sombreadores, veamos su compilaci√≥n: </p><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getShaders</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">vertex</span></span>: compileShader( GL.VERTEX_SHADER, <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(IDs.shaders.vertex).textContent ), <span class="hljs-attr"><span class="hljs-attr">fragment</span></span>: compileShader( GL.FRAGMENT_SHADER, <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(IDs.shaders.fragment).textContent ) }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compileShader</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">type, source</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shader = GL.createShader(type); GL.shaderSource(shader, source); GL.compileShader(shader); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> shader; }</code> </pre> <br><p>  Obtenemos el c√≥digo de sombreador de los elementos de la p√°gina, creamos un sombreador y lo compilamos.  En teor√≠a, puede almacenar el c√≥digo del sombreador en archivos separados y cargarlo durante el ensamblaje como una cadena en el lugar correcto, pero CodePen no brinda esa oportunidad para ejemplos.  Muchas lecciones sugieren escribir c√≥digo directamente en la l√≠nea en JS, pero el idioma no lo convierte en un idioma conveniente.  Aunque, por supuesto, sabe y colorea ... </p><br><p>  Si se produce un error durante la compilaci√≥n, el script continuar√° ejecut√°ndose mostrando un par de advertencias en la consola que no tienen mucho sentido.  Es √∫til mirar los registros despu√©s de la compilaci√≥n para no acumular cerebros sobre lo que no se compil√≥ all√≠: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">console</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.log</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.getShaderInfoLog</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">shader</span></span>));</code> </pre> <br><blockquote>  WebGL proporciona varias opciones diferentes para rastrear problemas al compilar sombreadores y crear un programa, pero en la pr√°ctica resulta que en tiempo real no podemos solucionar nada de todos modos.  Muy a menudo nos guiar√° el pensamiento "se cay√≥ - luego se cay√≥" y no cargaremos el c√≥digo con un mont√≥n de comprobaciones adicionales. </blockquote><p>  <strong>Pasemos a los sombreadores mismos</strong> </p><br><p>  Como solo tendremos un plano con el que no vamos a hacer nada, un simple sombreador de v√©rtices es suficiente para nosotros, lo que haremos al principio.  Los esfuerzos principales se centrar√°n en sombreadores de fragmentos y todos los ejemplos posteriores ser√°n relevantes para ellos. </p><br><blockquote>  Intente escribir c√≥digo de sombreador con nombres de variables m√°s o menos significativos.  En la red encontrar√° ejemplos en los que las funciones con matem√°ticas vigorosas para 200 l√≠neas de texto continuo se ensamblar√°n a partir de variables de una letra, pero el hecho de que alguien lo haga no significa que valga la pena repetirlo.  Tal enfoque no es una "especificidad de trabajar con GL", es una copia pegar banal de los c√≥digos fuente del siglo pasado escritos por personas que en su juventud ten√≠an restricciones en la longitud de los nombres variables. </blockquote><p>  Primero, el sombreador de v√©rtices.  Un vector 2d con coordenadas <code>(x,y)</code> se transferir√° a la variable del atributo <code>a_position</code> , como dijimos.  El sombreador debe devolver un vector de cuatro valores <code>(x,y,z,w)</code> .  No mover√° nada en el espacio, por lo que en el eje z, simplemente ponemos a cero todo y establecemos el valor de w en la unidad est√°ndar.  Si se pregunta por qu√© hay cuatro coordenadas en lugar de tres, puede usar la b√∫squeda de red para "coordenadas uniformes". </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'vertex-shader'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'x-shader/x-vertex'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript"> precision mediump float; attribute vec2 a_position; </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">void</span></span></span><span class="actionscript"> main() { gl_Position = vec4(position, </span><span class="hljs-number"><span class="actionscript"><span class="hljs-number">0</span></span></span><span class="actionscript">, </span><span class="hljs-number"><span class="actionscript"><span class="hljs-number">1</span></span></span><span class="actionscript">); } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  El resultado del trabajo se registra en una variable especial <code>gl_Position</code> .  Los sombreadores no tienen una <code>return</code> en el sentido completo de la palabra, escriben todos los resultados de su trabajo en variables especialmente reservadas para estos fines. </p><br><blockquote>  Tenga en cuenta el trabajo de precisi√≥n para el tipo de datos flotante.  Para evitar algunos de los problemas en los dispositivos m√≥viles, la precisi√≥n deber√≠a ser peor que highp y deber√≠a ser la misma en ambos sombreadores.  Esto se muestra como un ejemplo aqu√≠, pero es una buena pr√°ctica en los tel√©fonos apagar por completo esa belleza con sombreadores. </blockquote><p>  Para empezar, el sombreador de fragmentos siempre devolver√° el mismo color.  Nuestro cuadrado ocupar√° todo el <code>canvas</code> , de modo que aqu√≠ establecemos el color para cada p√≠xel: </p><br><pre> <code class="hljs pgsql">&lt;script id=<span class="hljs-string"><span class="hljs-string">'fragment-shader'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>=<span class="hljs-string"><span class="hljs-string">'x-shader/x-fragment'</span></span>&gt; <span class="hljs-type"><span class="hljs-type">precision</span></span> mediump <span class="hljs-type"><span class="hljs-type">float</span></span>; #define GOLD vec4(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.86</span></span>, <span class="hljs-number"><span class="hljs-number">0.6</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) <span class="hljs-type"><span class="hljs-type">void</span></span> main() { gl_FragColor = GOLD; } &lt;/script&gt;</code> </pre> <br><p>  Puede prestar atenci√≥n a los n√∫meros que describen el color.  Esto es familiar para todos los tipos de letra RGBA, solo normalizado.  Los valores no son enteros de 0 a 255, sino fraccionarios de 0 a 1. El orden es el mismo. </p><br><blockquote>  No olvide usar el preprocesador para todas las constantes m√°gicas en proyectos reales; esto hace que el c√≥digo sea m√°s comprensible sin afectar el rendimiento (la sustituci√≥n, como en C, ocurre durante la compilaci√≥n). </blockquote><p>  Vale la pena se√±alar otro punto sobre el preprocesador: </p><br><blockquote>  El uso de comprobaciones constantes #ifdef GL_ES en varias lecciones carece de significado pr√°ctico.  En nuestro navegador actual, no existen otras opciones GL. </blockquote><p>  Pero es hora de mirar el resultado: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/sfi0zy/embed/preview/JaoYMj" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  El cuadrado dorado indica que los sombreadores est√°n funcionando como se esperaba.  Tiene sentido jugar un poco con ellos antes de comenzar a trabajar con fotos. </p><br><p>  <strong>Vectores gradientes y transformados</strong> </p><br><p>  Por lo general, los tutoriales de WebGL comienzan dibujando degradados.  Esto tiene poco sentido pr√°ctico, pero ser√° √∫til tener en cuenta algunos puntos. </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gl_FragColor = vec4(gl_FragCoord.zxy / <span class="hljs-number"><span class="hljs-number">500.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  En este ejemplo, usamos las coordenadas del p√≠xel actual como el color.  A menudo ver√° esto en ejemplos en la red.  Ambos son vectores.  Entonces nadie se molesta en mezclar todo en un mont√≥n.  Los evangelistas de TypeScript deber√≠an tener un ataque aqu√≠.  Un punto importante es c√≥mo obtenemos solo una parte de las coordenadas del vector.  Propiedades <code>.x</code> , <code>.y</code> , <code>.z</code> , <code>.xy</code> , <code>.zy</code> , <code>.xyz</code> , <code>.zyx</code> , <code>.xyzw</code> , etc.  en diferentes secuencias le permiten extraer los elementos de un vector en un cierto orden en forma de otro vector.  Muy convenientemente implementado.  Adem√°s, se puede hacer un vector de mayor dimensi√≥n a partir de un vector de menor dimensi√≥n agregando los valores faltantes, como lo hicimos nosotros. </p><br><blockquote>  Siempre indique expl√≠citamente la parte fraccionaria de los n√∫meros.  No hay conversi√≥n autom√°tica int -&gt; flotante aqu√≠. </blockquote><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/sfi0zy/embed/preview/vzENvx" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <strong>Uniformes y el paso del tiempo.</strong> </p><br><p>  El siguiente ejemplo √∫til es el uso de uniformes.  Estos son los datos m√°s comunes para todas las llamadas de sombreador.  Obtenemos su ubicaci√≥n de la misma manera que para las variables de atributo, por ejemplo: </p><br><pre> <code class="hljs delphi">GL.getUniformLocation(<span class="hljs-keyword"><span class="hljs-keyword">PROGRAM</span></span>, <span class="hljs-string"><span class="hljs-string">'u_time'</span></span>)</code> </pre> <br><p>  Entonces podemos establecerles valores antes de cada cuadro.  Adem√°s de los vectores, hay muchos m√©todos similares aqu√≠, comenzando con la palabra <code>uniform</code> , luego viene la dimensi√≥n de la variable (1 para n√∫meros, 2, 3 o 4 para vectores) y tipo (f - float, i - int, v - vector) . </p><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeStamp)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uniform1f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.getUniformLocation(PROGRAM, 'u_time')</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeStamp</span></span></span><span class="hljs-function"> / 1000.0); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawArrays</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TRIANGLE_STRIP, 0, 4)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">window</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestAnimationFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(draw)</span></span></span><span class="hljs-function">; }</span></span></code> </pre> <br><blockquote>  De hecho, no siempre necesitamos 60 fps en las interfaces.  Es bastante posible agregar una desaceleraci√≥n para solicitar el marco de animaci√≥n y reducir la frecuencia de los marcos de redibujado. </blockquote><p>  Por ejemplo, cambiaremos el color de relleno.  En los sombreadores, todas las funciones matem√°ticas b√°sicas est√°n disponibles: <code>sin</code> , <code>cos</code> , <code>tan</code> , <code>asin</code> , <code>acos</code> , <code>atan</code> , <code>pow</code> , <code>exp</code> , <code>log</code> , <code>sqrt</code> , <code>abs</code> y otras.  Utilizaremos dos de ellos. </p><br><pre> <code class="hljs cpp">uniform <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> u_time; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ gl_FragColor = vec4( <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(u_time)), <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(u_time * <span class="hljs-number"><span class="hljs-number">3.0</span></span>)), <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(u_time * <span class="hljs-number"><span class="hljs-number">5.0</span></span>)), <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  El tiempo en tales animaciones es un concepto relativo.  Aqu√≠ usamos los valores proporcionados por <code>requestAnimationFrame</code> , pero podemos hacer nuestro propio "tiempo".  La idea es que si algunos par√°metros se describen por una funci√≥n del tiempo, entonces podemos girar el tiempo en la direcci√≥n opuesta, reducir la velocidad, acelerarlo o volver a su estado original.  Esto puede ser muy √∫til. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/sfi0zy/embed/preview/VGYvNP" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Pero suficientes ejemplos abstractos, pasemos al uso de im√°genes. </p><br><p>  <strong>Cargando una imagen en una textura</strong> </p><br><p>  Para usar la imagen, necesitamos crear una textura, que luego se renderizar√° en nuestro plano.  Para comenzar, cargue la imagen en s√≠: </p><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTexture</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> image = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Image(); image.crossOrigin = <span class="hljs-string"><span class="hljs-string">'anonymous'</span></span>; image.onload = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// .... }; image.src = 'example.jpg'; }</span></span></code> </pre> <br><p>  Despu√©s de que se cargue, cree una textura e indique que ir√° al n√∫mero 0. En WebGL, puede haber muchas texturas al mismo tiempo y debemos indicar expl√≠citamente a qu√© comandos posteriores se referir√°.  En nuestros ejemplos, solo habr√° una textura, pero a√∫n indicamos expl√≠citamente que ser√° cero. </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> texture = GL.createTexture(); GL.activeTexture(GL.TEXTURE0); GL.bindTexture(GL.TEXTURE_2D, texture);</code> </pre> <br><p>  Queda por agregar una foto.  Tambi√©n decimos de inmediato que debe voltearse a lo largo del eje Y, porque  en WebGL, el eje est√° al rev√©s: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.pixelStorei</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.UNPACK_FLIP_Y_WEBGL</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">true</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.texImage2D</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TEXTURE_2D</span></span>, 0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.RGB</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.RGB</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.UNSIGNED_BYTE</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">image</span></span>);</code> </pre> <br><p>  En teor√≠a, la textura deber√≠a ser cuadrada.  M√°s precisamente, incluso deber√≠an tener un tama√±o igual a la potencia de dos: 32px, 64px, 128px, etc.  Pero todos entendemos que nadie procesar√° las fotos y estar√°n en diferentes proporciones cada vez.  Esto provocar√° errores incluso si el tama√±o del <code>canvas</code> ajusta perfectamente a la textura.  Por lo tanto, llenamos todo el espacio hasta los bordes del plano con los p√≠xeles extremos de la imagen.  Esta es una pr√°ctica est√°ndar, aunque parece una peque√±a muleta. </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.texParameteri</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TEXTURE_2D</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TEXTURE_WRAP_S</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.CLAMP_TO_EDGE</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.texParameteri</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TEXTURE_2D</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TEXTURE_WRAP_T</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.CLAMP_TO_EDGE</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.texParameteri</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TEXTURE_2D</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TEXTURE_MIN_FILTER</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.LINEAR</span></span>);</code> </pre> <br><p>  Queda por transferir la textura a los sombreadores.  Estos datos son comunes a todos, por lo que utilizamos el modificador <code>uniform</code> . </p><br><pre> <code class="hljs delphi">GL.uniform1i(GL.getUniformLocation(<span class="hljs-keyword"><span class="hljs-keyword">PROGRAM</span></span>, <span class="hljs-string"><span class="hljs-string">'u_texture'</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  Ahora podemos usar los colores de la textura en el sombreador de fragmentos.  Pero tambi√©n queremos que la imagen ocupe todo el <code>canvas</code> .  Si la imagen y el <code>canvas</code> tienen las mismas proporciones, esta tarea se vuelve trivial.  Primero, transferimos el tama√±o del <code>canvas</code> a los sombreadores (esto debe hacerse cada vez que cambie su tama√±o): </p><br><pre> <code class="hljs pgsql">GL.uniform1f(GL.getUniformLocation(PROGRAM, <span class="hljs-string"><span class="hljs-string">'u_canvas_size'</span></span>), Math.max(CANVAS.height, CANVAS.width));</code> </pre> <br><p>  Y divide las coordenadas en √©l: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">uniform</span></span> sampler2D u_texture; <span class="hljs-attribute"><span class="hljs-attribute">uniform</span></span> float u_canvas_size; <span class="hljs-attribute"><span class="hljs-attribute">void</span></span> main() { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_texture, gl_FragCoord.xy / u_canvas_size); }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/sfi0zy/embed/preview/QVwjeJ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <em>En este punto, puedes pausar y preparar t√©.</em>  <em>Hemos hecho todo el trabajo preparatorio y pasamos a crear varios efectos.</em> </p><br><h2 id="effekty">  Efectos </h2><br><p>  Al crear varios efectos, la intuici√≥n y la experimentaci√≥n juegan un papel importante.  A menudo, puede reemplazar un algoritmo complejo con algo completamente simple y dar un resultado similar.  El usuario final no notar√° la diferencia, pero aceleramos el trabajo y simplificamos el soporte.  WebGL no proporciona herramientas razonables para depurar sombreadores, por lo que es beneficioso para nosotros tener peque√±os fragmentos de c√≥digo que puedan caber en la cabeza como un todo. </p><br><blockquote>  Menos c√≥digo significa menos problemas.  Y es m√°s f√°cil de leer.  Siempre revise los sombreadores encontrados en la red para acciones innecesarias.  Sucede que puede eliminar la mitad del c√≥digo y nada cambiar√°. </blockquote><p>  Juguemos un poco con el sombreador.  La mayor√≠a de nuestros efectos se basar√°n en el hecho de que devolvemos el color no del p√≠xel en la textura que deber√≠a estar en este lugar, sino algunos de los vecinos.  Es √∫til intentar agregar a las coordenadas el resultado de una funci√≥n est√°ndar de las coordenadas.  El tiempo tambi√©n ser√° √∫til para usar, por lo que el resultado de la ejecuci√≥n ser√° m√°s f√°cil de rastrear y, al final, a√∫n crearemos efectos animados.  Intentemos usar el seno: </p><br><pre> <code class="hljs lisp">gl_FragColor = texture2D(<span class="hljs-name"><span class="hljs-name">u_texture</span></span>, gl_FragCoord.xy / u_canvas_size + sin(<span class="hljs-name"><span class="hljs-name">u_time</span></span> + gl_FragCoord.y))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  El resultado es extra√±o.  Obviamente, todo se mueve con demasiada amplitud.  Divide todo por alg√∫n n√∫mero: </p><br><pre> <code class="hljs lisp">gl_FragColor = texture2D(<span class="hljs-name"><span class="hljs-name">u_texture</span></span>, gl_FragCoord.xy / u_canvas_size + sin(<span class="hljs-name"><span class="hljs-name">u_time</span></span> + gl_FragCoord.y) / <span class="hljs-number"><span class="hljs-number">250.0</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Ya mejor.  Ahora est√° claro que tenemos un poco de emoci√≥n.  En teor√≠a, para aumentar cada onda, necesitamos dividir el argumento seno: la coordenada.  Hag√°moslo: </p><br><pre> <code class="hljs lisp">gl_FragColor = texture2D(<span class="hljs-name"><span class="hljs-name">u_texture</span></span>, gl_FragCoord.xy / u_canvas_size + sin(<span class="hljs-name"><span class="hljs-name">u_time</span></span> + gl_FragCoord.y / <span class="hljs-number"><span class="hljs-number">30.0</span></span>) / <span class="hljs-number"><span class="hljs-number">250.0</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/sfi0zy/embed/preview/jvEWbJ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Efectos similares a menudo van acompa√±ados de la selecci√≥n de coeficientes.  Esto se hace a simple vista.  Al igual que con la cocina, al principio ser√° dif√≠cil de adivinar, pero luego suceder√° por s√≠ solo.  Lo principal es comprender al menos aproximadamente a qu√© afecta este o aquel coeficiente en la f√≥rmula resultante.  Despu√©s de seleccionar los coeficientes, tiene sentido ponerlos en macros (como fue el primer ejemplo) y dar nombres significativos. </p><br><p>  <strong>Espejo torcido, bicicletas y experimentos.</strong> </p><br><p>  Pensar es bueno.  S√≠, hay algoritmos listos para resolver algunos problemas que podemos tomar y usar.       ,      . </p><br><p>         ,   " ",       .  Que hacer </p><br><p> ,       ,   ?      .   ,       rand()  - .    ,    ,   ,  ,   .    .                  .   ,      .         .      .    -,    .      .    ,     ,       ,   .     ,           "": </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>(vec2 <span class="hljs-keyword"><span class="hljs-keyword">seed</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fract(<span class="hljs-keyword"><span class="hljs-keyword">sin</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">dot</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">seed</span></span>, vec2(<span class="hljs-number"><span class="hljs-number">12.9898</span></span>,<span class="hljs-number"><span class="hljs-number">78.233</span></span>))) * <span class="hljs-number"><span class="hljs-number">43758.5453123</span></span>); }</code> </pre><br><p>    ,          , ,      NVIDIA  ATI     .     ,        . </p><br><p>       ,    ,          : </p><br><pre> <code class="hljs lisp">gl_FragColor = texture2D(<span class="hljs-name"><span class="hljs-name">u_texture</span></span>, gl_FragCoord.xy / u_canvas_size + rand(<span class="hljs-name"><span class="hljs-name">gl_FragCoord</span></span>.xy) / <span class="hljs-number"><span class="hljs-number">100.0</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>          : </p><br><pre> <code class="hljs lisp">gl_FragColor = texture2D(<span class="hljs-name"><span class="hljs-name">u_texture</span></span>, gl_FragCoord.xy / u_canvas_size + rand(<span class="hljs-name"><span class="hljs-name">gl_FragCoord</span></span>.xy + vec2(<span class="hljs-name"><span class="hljs-name">sin</span></span>(<span class="hljs-name"><span class="hljs-name">u_time</span></span>))) / <span class="hljs-number"><span class="hljs-number">250.0</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>    ,   ,   : </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/sfi0zy/embed/preview/pOvgbX" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p> ,        .     ,   ,     .   ‚Äî           .  Como hacerlo .      . </p><br><p>       0  1,     - .    5 ‚Äî          .       ,      . </p><br><pre> <code class="hljs matlab">vec2 texture_coord = gl_FragCoord.xy / u_canvas_size; gl_FragColor = texture2D(u_texture, texture_coord + <span class="hljs-built_in"><span class="hljs-built_in">rand</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(texture_coord * <span class="hljs-number"><span class="hljs-number">5.0</span></span>) + vec2(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(u_time))) / <span class="hljs-number"><span class="hljs-number">100.0</span></span>);</code> </pre> <br><p>   ,   -    .   -   . ,    ,   .     ? </p><br><p>        ,  ,   ,  - .     , .    , ..      -.      ,      .      . ,         ,   .        . </p><br><p>    <code>sin</code>  <code>cos</code>   ,    .   .         . </p><br><pre> <code class="hljs mel">gl_FragColor = texture2D(u_texture, texture_coord + vec2( <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>(texture_coord * <span class="hljs-number"><span class="hljs-number">10.0</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">sin</span></span>(u_time + texture_coord.x * <span class="hljs-number"><span class="hljs-number">5.0</span></span>)) / <span class="hljs-number"><span class="hljs-number">10.0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>(texture_coord * <span class="hljs-number"><span class="hljs-number">10.0</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">cos</span></span>(u_time + texture_coord.y * <span class="hljs-number"><span class="hljs-number">5.0</span></span>)) / <span class="hljs-number"><span class="hljs-number">10.0</span></span>));</code> </pre> <br><p>      .   <code>fract</code>  .    1  1 ‚Äî     : </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>(vec2 position) { vec2 block_position = <span class="hljs-keyword"><span class="hljs-keyword">floor</span></span>(position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> top_left_value = <span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>(block_position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> top_right_value = <span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>(block_position + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bottom_left_value = <span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>(block_position + vec2(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bottom_right_value = <span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>(block_position + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); vec2 computed_value = fract(position); <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>        . WebGL      <code>smoothstep</code> ,     : </p><br><pre> <code class="hljs lisp">vec2 computed_value = smoothstep(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, fract(<span class="hljs-name"><span class="hljs-name">position</span></span>))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>    ,      .   ,          X   : </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> computed_value.x;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/sfi0zy/embed/preview/mGyVBK" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p> ‚Ä¶    ,  ,    ... </p><br><blockquote>    - ,     ,     ...        . </blockquote><p>     y ‚Äî    ,   .      ? </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length(computed_value);</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/sfi0zy/embed/preview/OoPMza" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>     . </p><br><p>     .     0.5 ‚Äî      . </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">return</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mix</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">top_left_value</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">top_right_value</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">computed_value</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.x</span></span>) + (<span class="hljs-selector-tag"><span class="hljs-selector-tag">bottom_left_value</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">top_left_value</span></span>) * <span class="hljs-selector-tag"><span class="hljs-selector-tag">computed_value</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.y</span></span> * (1<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">computed_value</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.x</span></span>) + (<span class="hljs-selector-tag"><span class="hljs-selector-tag">bottom_right_value</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">top_right_value</span></span>) * <span class="hljs-selector-tag"><span class="hljs-selector-tag">computed_value</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.x</span></span> * <span class="hljs-selector-tag"><span class="hljs-selector-tag">computed_value</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.y</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.5</span></span>;</code> </pre> <br><p>      : </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/sfi0zy/embed/preview/eLmJMZ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p> <em>     ,   , ,  .</em> </p><br><p> <strong> </strong> </p><br><p>        ,     ,          .         - . </p><br><p>    uniform-,       .   0  1,  0 ‚Äî   ,  1 ‚Äî  . </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> u_intensity;</code> </pre> <br><p>       : </p><br><pre> <code class="hljs mel">gl_FragColor = texture2D(u_texture, texture_coord + vec2(<span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>(texture_coord * <span class="hljs-number"><span class="hljs-number">10.0</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">sin</span></span>(u_time + texture_coord.x * <span class="hljs-number"><span class="hljs-number">5.0</span></span>)) / <span class="hljs-number"><span class="hljs-number">10.0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>(texture_coord * <span class="hljs-number"><span class="hljs-number">10.0</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">cos</span></span>(u_time + texture_coord.y * <span class="hljs-number"><span class="hljs-number">5.0</span></span>)) / <span class="hljs-number"><span class="hljs-number">10.0</span></span>) * u_intensity);</code> </pre> <br><p>         ,      . </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/sfi0zy/embed/preview/PdwZdX" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>         (  0  1),             . </p><br><blockquote>  ,    ,         ,       .          ‚Äî         requestAnimationFrame.       ,     FPS. </blockquote><p> <strong>   </strong> </p><br><p>      ,        .   uniform-. </p><br><pre> <code class="hljs powershell">document.addEventListener(<span class="hljs-string"><span class="hljs-string">'mousemove'</span></span>, (e) =&gt; { let rect = CANVAS.getBoundingClientRect(); MOUSE_POSITION = [ <span class="hljs-type"><span class="hljs-type">e.clientX</span></span> - <span class="hljs-type"><span class="hljs-type">rect.left</span></span>, <span class="hljs-type"><span class="hljs-type">rect.height</span></span> - (<span class="hljs-type"><span class="hljs-type">e.clientY</span></span> - <span class="hljs-type"><span class="hljs-type">rect.top</span></span>) ]; GL.uniform2fv(GL.getUniformLocation(PROGRAM, <span class="hljs-string"><span class="hljs-string">'u_mouse_position'</span></span>), MOUSE_POSITION); });</code> </pre> <br><p>    ,            .      ‚Äî  ,       . </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">void</span></span> main() { <span class="hljs-attribute"><span class="hljs-attribute">vec2</span></span> texture_coord = gl_FragCoord.xy / u_canvas_size; <span class="hljs-attribute"><span class="hljs-attribute">vec2</span></span> direction = u_mouse_position / u_canvas_size - texture_coord; <span class="hljs-attribute"><span class="hljs-attribute">float</span></span> dist = distance(gl_FragCoord.xy, u_mouse_position) / u_canvas_size; <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (dist &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">4</span></span>) { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_texture, texture_coord + u_intensity * direction * dist * <span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span> ); } <span class="hljs-section"><span class="hljs-section">else</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_texture, texture_coord); } }</code> </pre> <br><p>         -    .         . </p><br><blockquote>             .    ,        . </blockquote><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/sfi0zy/embed/preview/bxNEOP" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p> <strong></strong> </p><br><p>      . Glitch-     ,      SVG.      .    ‚Äî .      ?       ‚Äî  ,   ,   ,      . </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">float</span></span> random_value = rand(vec2(texture_coord.y, u_time)); <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (random_value &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">05</span></span>) { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_texture, vec2(texture_coord.x + random_value / <span class="hljs-number"><span class="hljs-number">5</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>, texture_coord.y)); } <span class="hljs-section"><span class="hljs-section">else</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_texture, texture_coord); }</code> </pre> <br><blockquote> "     ?" ‚Äî   ,      .          . </blockquote><p>     .      ‚Äî  ,           . </p><br><pre> <code class="hljs lisp">float random_value = rand(<span class="hljs-name"><span class="hljs-name">vec2</span></span>(<span class="hljs-name"><span class="hljs-name">floor</span></span>(<span class="hljs-name"><span class="hljs-name">texture_coord</span></span>.y * 20.0), u_time));</code> </pre> <br><p>     .   ,       : </p><br><pre> <code class="hljs lisp">gl_FragColor = texture2D(<span class="hljs-name"><span class="hljs-name">u_texture</span></span>, vec2(<span class="hljs-name"><span class="hljs-name">texture_coord</span></span>.x + random_value / <span class="hljs-number"><span class="hljs-number">4.0</span></span>, texture_coord.y)) + vec4(<span class="hljs-name"><span class="hljs-name">vec3</span></span>(<span class="hljs-name"><span class="hljs-name">random_value</span></span>), <span class="hljs-number"><span class="hljs-number">1.0</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>          .          ‚Äî    . ,           ‚Äî   <code>.r</code> , <code>.g</code> , <code>.b</code> , <code>.rg</code> , <code>.rb</code> , <code>.rgb</code> , <code>.bgr</code> , ...               . </p><br><p>       : </p><br><pre> <code class="hljs lisp">float random_value = u_intensity * rand(<span class="hljs-name"><span class="hljs-name">vec2</span></span>(<span class="hljs-name"><span class="hljs-name">floor</span></span>(<span class="hljs-name"><span class="hljs-name">texture_coord</span></span>.y * 20.0), u_time));</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/sfi0zy/embed/preview/OoPMeY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="chto-v-itoge">  Cual es el resultado? </h2><br><p>         ,                   ,     .          ,  ,      ‚Äî         . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es420847/">https://habr.com/ru/post/es420847/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es420833/index.html">Errores importantes de monetizaci√≥n de aplicaciones [y c√≥mo solucionarlos]</a></li>
<li><a href="../es420837/index.html">Prueba de matrices RAID de software para dispositivos NVMe utilizando la metodolog√≠a SNIA</a></li>
<li><a href="../es420841/index.html">Revisi√≥n prehospitalaria o "¬°Hola, Swagger! ¬øD√≥nde est√°n mis errores?</a></li>
<li><a href="../es420843/index.html">7 de septiembre, Ekaterimburgo: una reuni√≥n para desarrolladores de .NET</a></li>
<li><a href="../es420845/index.html">La domesticaci√≥n del obstinado con el uso de una muleta: el orificio del adaptador Wi-Fi WF2190 (Realtek8812AU Wireless LAN 802.11ac USB)</a></li>
<li><a href="../es420853/index.html">Conozca la pseudo consola de Windows (ConPTY)</a></li>
<li><a href="../es420857/index.html">Roaming Wi-Fi sin interrupciones: teor√≠a en la pr√°ctica</a></li>
<li><a href="../es420859/index.html">A la pregunta de Wirth y cadenas</a></li>
<li><a href="../es420861/index.html">Prepar√°ndose para C ++ 20. Estudio de caso de Coroutines TS Real</a></li>
<li><a href="../es420863/index.html">Como hicimos el primer tel√©fono inteligente ruso, continu√≥</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>