<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😫 📐 🤲 Conteneurisation professionnelle des applications Node.js à l'aide de Docker 🙇🏽 🌻 🍱</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'auteur du matériel, dont nous publions la traduction aujourd'hui, est un ingénieur DevOps. Il dit qu'il doit utiliser Docker . En particulier, cette...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Conteneurisation professionnelle des applications Node.js à l'aide de Docker</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/440656/">  L'auteur du matériel, dont nous publions la traduction aujourd'hui, est un ingénieur DevOps.  Il dit qu'il doit utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Docker</a> .  En particulier, cette plate-forme de gestion de conteneurs est utilisée à différentes étapes du cycle de vie des applications Node.js.  L'utilisation de Docker, une technologie qui a récemment été extrêmement populaire, vous permet d'optimiser le processus de développement et de sortie des projets Node.js en production. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/0c1/c88/f14/0c1c88f14934b3bb68342f9c5a18eee6.png" alt="image"></a> <br><br>  Nous publions maintenant une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">série d'articles</a> sur Docker, conçus pour ceux qui veulent apprendre cette plate-forme pour son utilisation dans diverses situations.  Le même matériel se concentre principalement sur l'utilisation professionnelle de Docker dans le développement de Node.js. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Qu'est-ce qu'un docker?</font> </h2><br>  Docker est un programme conçu pour organiser la virtualisation au niveau du système d'exploitation (conteneurisation).  Au cœur des conteneurs se trouvent des images en couches.  En termes simples, Docker est un outil qui vous permet de créer, déployer et exécuter des applications à l'aide de conteneurs indépendants du système d'exploitation sur lequel ils s'exécutent.  Le conteneur comprend une image du système d'exploitation de base nécessaire au fonctionnement de l'application, la bibliothèque dont dépend cette application et cette application elle-même.  Si plusieurs conteneurs s'exécutent sur le même ordinateur, ils utilisent ensemble les ressources de cet ordinateur.  Les conteneurs Docker peuvent emballer des projets créés à l'aide de diverses technologies.  Nous sommes intéressés par des projets basés sur Node.js. <br><br><h2>  <font color="#3AC1EF">Création d'un projet Node.js</font> </h2><br>  Avant de compresser un projet Node.js dans un conteneur Docker, nous devons créer ce projet.  Faisons-le.  Voici le fichier <code>package.json</code> de ce projet: <br><br><pre> <code class="bash hljs">{ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"node-app"</span></span>, <span class="hljs-string"><span class="hljs-string">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"The best way to manage your Node app using Docker"</span></span>, <span class="hljs-string"><span class="hljs-string">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"index.js"</span></span>, <span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"start"</span></span>: <span class="hljs-string"><span class="hljs-string">"node index.js"</span></span> }, <span class="hljs-string"><span class="hljs-string">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">"Ankit Jain &lt;ankitjain28may77@gmail.com&gt;"</span></span>, <span class="hljs-string"><span class="hljs-string">"license"</span></span>: <span class="hljs-string"><span class="hljs-string">"ISC"</span></span>, <span class="hljs-string"><span class="hljs-string">"dependencies"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"express"</span></span>: <span class="hljs-string"><span class="hljs-string">"^4.16.4"</span></span> } }</code> </pre> <br>  Pour installer les dépendances du projet, exécutez la commande <code>npm install</code> .  Au cours de cette commande, entre autres, le fichier <code>package-lock.json</code> sera créé.  Créez maintenant le fichier <code>index.js</code> , qui contiendra le code du projet: <br><br><pre> <code class="bash hljs">const express = require(<span class="hljs-string"><span class="hljs-string">'express'</span></span>); const app = express(); app.get(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, (req, res) =&gt; { res.send(<span class="hljs-string"><span class="hljs-string">'The best way to manage your Node app using Docker\n'</span></span>); }); app.listen(3000); console.log(<span class="hljs-string"><span class="hljs-string">'Running on http://localhost:3000'</span></span>);</code> </pre> <br>  Comme vous pouvez le voir, nous avons décrit ici un serveur simple qui renvoie du texte en réponse à des requêtes. <br><br><h2>  <font color="#3AC1EF">Créer un Dockerfile</font> </h2><br>  Maintenant que l'application est prête, parlons de la façon de l'intégrer dans un conteneur Docker.  À savoir, il s'agira de la partie la plus importante de tout projet basé sur Docker, à propos du Dockerfile. <br><br>  Un Dockerfile est un fichier texte qui contient des instructions pour créer une image Docker pour une application.  Les instructions de ce fichier, si elles n'entrent pas dans les détails, décrivent la création de couches d'un système de fichiers à plusieurs niveaux, qui a tout ce dont une application a besoin pour fonctionner.  La plate-forme Docker peut mettre en cache des couches d'images, ce qui, lors de la réutilisation de couches qui sont déjà dans le cache, accélère le processus de création d'images. <br><br>  En programmation orientée objet, il existe une chose telle qu'une classe.  Les classes sont utilisées pour créer des objets.  Dans Docker, les images peuvent être comparées à des classes et les conteneurs peuvent être comparés à des instances d'images, c'est-à-dire à des objets.  Considérez le processus de génération d'un Dockerfile, qui nous aidera à comprendre cela. <br><br>  Créez un Dockerfile vide: <br><br><pre> <code class="bash hljs">touch Dockerfile</code> </pre> <br>  Puisque nous allons créer un conteneur pour l'application Node.js, la première chose que nous devons mettre dans le conteneur sera l'image de base du nœud, qui peut être trouvée sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Docker Hub</a> .  Nous utiliserons la version LTS de Node.js.  Par conséquent, la première déclaration de notre Dockerfile sera la déclaration suivante: <br><br><pre> <code class="bash hljs">FROM node:8</code> </pre> <br>  Après cela, créez un répertoire pour notre code.  En même temps, grâce à l'instruction <code>ARG</code> utilisée ici, nous pouvons, si nécessaire, spécifier le nom du répertoire d'application autre que <code>/app</code> lors de l'assemblage du conteneur.  Vous trouverez des détails sur ce manuel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   ARG APP_DIR=app RUN mkdir -p ${APP_DIR} WORKDIR ${APP_DIR}</span></span></code> </pre> <br>  Puisque nous utilisons l'image Node, les plates-formes Node.js et npm y seront déjà installées.  En utilisant ce qui est déjà dans l'image, vous pouvez organiser l'installation des dépendances du projet.  En utilisant l'indicateur <code>--production</code> (ou si la <code>NODE_ENV</code> environnement <code>NODE_ENV</code> définie sur <code>production</code> ), npm n'installera pas les modules répertoriés dans la section <code>devDependencies</code> du fichier <code>devDependencies</code> . <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   COPY package*.json ./ RUN npm install #     # RUN npm install --production</span></span></code> </pre> <br>  Ici, nous <code>package*.json</code> fichier <code>package*.json</code> dans l'image, au lieu, par exemple, de copier tous les fichiers du projet.  Nous le faisons précisément parce que les instructions Dockerfile <code>RUN</code> , <code>COPY</code> et <code>ADD</code> créent des couches d'image supplémentaires, vous pouvez donc utiliser les fonctionnalités de mise en cache des couches de la plateforme Docker.  Avec cette approche, la prochaine fois que nous collecterons une image similaire, Docker cherchera s'il est possible de réutiliser des couches d'images qui sont déjà dans le cache, et si c'est le cas, il tirera parti de ce qui est déjà là, au lieu d'en créer de nouvelles couches.  Cela vous permet de gagner sérieusement du temps lors de l'assemblage de couches au cours de travaux sur de grands projets, qui incluent de nombreux modules npm. <br><br>  Copiez maintenant les fichiers du projet dans le répertoire de travail actuel.  Ici, nous n'utiliserons pas l'instruction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ADD</a> , mais l'instruction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">COPY</a> .  En fait, dans la plupart des cas, il est recommandé de privilégier l'instruction <code>COPY</code> . <br><br>  L'instruction <code>ADD</code> , par rapport à <code>COPY</code> , a certaines fonctionnalités qui, cependant, ne sont pas toujours nécessaires.  Par exemple, nous parlons d'options pour décompresser les archives .tar et télécharger des fichiers par URL. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#    COPY . .</span></span></code> </pre> <br>  Les conteneurs Docker sont des environnements isolés.  Cela signifie que lorsque nous lancerons l'application dans le conteneur, nous ne pourrons pas interagir directement avec elle sans ouvrir le port sur lequel cette application écoute.  Afin d'informer Docker qu'il existe une application dans un certain conteneur écoutant sur un certain port, vous pouvez utiliser l'instruction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">EXPOSE</a> . <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   ,      EXPOSE 3000</span></span></code> </pre> <br>  À ce jour, nous, en utilisant le Dockerfile, avons décrit l'image que l'application contiendra et tout ce dont elle a besoin pour réussir le lancement.  Ajoutez maintenant l'instruction au fichier qui vous permet de démarrer l'application.  Il s'agit d'une instruction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CMD</a> .  Il vous permet de spécifier une certaine commande avec des paramètres qui seront exécutés au démarrage du conteneur et, si nécessaire, peuvent être remplacés par des outils de ligne de commande. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   CMD ["npm", "start"]</span></span></code> </pre> <br>  Voici à quoi ressemblera le Dockerfile fini: <br><br><pre> <code class="bash hljs">FROM node:8 <span class="hljs-comment"><span class="hljs-comment">#   ARG APP_DIR=app RUN mkdir -p ${APP_DIR} WORKDIR ${APP_DIR} #   COPY package*.json ./ RUN npm install #     # RUN npm install --production #    COPY . . #   ,      EXPOSE 3000 #   CMD ["npm", "start"]</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Assemblage d'images</font> </h2><br>  Nous avons préparé un fichier Dockerfile contenant des instructions pour la construction de l'image, sur la base duquel un conteneur avec une application en cours d'exécution sera créé.  Assemblez l'image en exécutant une commande de la forme suivante: <br><br><pre> <code class="bash hljs">docker build --build-arg &lt;build arguments&gt; -t &lt;user-name&gt;/&lt;image-name&gt;:&lt;tag-name&gt; /path/to/Dockerfile</code> </pre> <br>  Dans notre cas, cela ressemblera à ceci: <br><br><pre> <code class="bash hljs">docker build --build-arg APP_DIR=var/app -t ankitjain28may/node-app:V1 .</code> </pre> <br>  Dockerfile a une instruction <code>ARG</code> qui décrit l'argument <code>APP_DIR</code> .  Ici, nous définissons sa signification.  Si cela n'est pas fait, il prendra alors la valeur qui lui est affectée dans le fichier, c'est-à-dire <code>app</code> . <br><br>  Après avoir assemblé l'image, vérifiez si Docker la voit.  Pour ce faire, exécutez la commande suivante: <br><br><pre> <code class="bash hljs">docker images</code> </pre> <br>  En réponse à cette commande, approximativement les éléments suivants devraient être sortis. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51d/c22/3e0/51dc223e0030bb0275c3d61fa01562e5.png"></div><br>  <i><font color="#999999">Images Docker</font></i> <br><br><h2>  <font color="#3AC1EF">Lancement d'image</font> </h2><br>  Après avoir assemblé l'image Docker, nous pouvons l'exécuter, c'est-à-dire en créer une instance, représentée par un conteneur de travail.  Pour ce faire, utilisez une commande de ce type: <br><br><pre> <code class="bash hljs">docker run -p &lt;External-port:exposed-port&gt; -d --name &lt;name of the container&gt; &lt;user-name&gt;/&lt;image-name&gt;:&lt;tag-name&gt;</code> </pre> <br>  Dans notre cas, cela ressemblera à ceci: <br><br><pre> <code class="bash hljs">docker run -p 8000:3000 -d --name node-app ankitjain28may/node-app:V1</code> </pre> <br>  Nous demanderons au système des informations sur le fonctionnement des conteneurs à l'aide de cette commande: <br><br><pre> <code class="bash hljs">docker ps</code> </pre> <br>  En réponse à cela, le système doit produire quelque chose comme ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87f/bc0/fcf/87fbc0fcf1bdeecef051e2874d48d91e.png"></div><br>  <i><font color="#999999">Conteneurs Docker</font></i> <br><br>  Jusqu'à présent, tout se passe comme prévu, bien que nous n'ayons pas encore essayé d'accéder à l'application en cours d'exécution dans le conteneur.  À savoir, notre conteneur, nommé <code>node-app</code> , écoute sur le port <code>8000</code> .  Afin d'essayer d'y accéder, vous pouvez ouvrir un navigateur et y accéder à <code>localhost:8000</code> .  De plus, afin de vérifier l'intégrité du conteneur, vous pouvez utiliser la commande suivante: <br><br><pre> <code class="bash hljs">curl -i localhost:8000</code> </pre> <br>  Si le conteneur fonctionne vraiment, quelque chose comme celui illustré dans la figure suivante sera retourné en réponse à cette commande. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea4/407/9ba/ea44079bab09d56c402af3c58eb6a638.png"></div><br>  <i><font color="#999999">Résultat de la vérification de l'état du conteneur</font></i> <br><br>  Sur la base de la même image, par exemple, sur la base de tout juste créé, il est possible de créer de nombreux conteneurs.  De plus, vous pouvez envoyer notre image au registre Docker Hub, ce qui permettra à d'autres développeurs de télécharger notre image et de lancer les conteneurs appropriés à la maison.  Cette approche simplifie le travail avec les projets. <br><br><h2>  <font color="#3AC1EF">Recommandations</font> </h2><br>  Voici quelques suggestions qui méritent d'être examinées afin de tirer parti de la puissance de Docker et de créer des images aussi compactes que possible. <br><br><h3>  <font color="#3AC1EF">▍1.</font>  <font color="#3AC1EF">Créez toujours un fichier .dockerignore</font> </h3><br>  Dans le dossier de projet que vous prévoyez de placer dans le conteneur, vous devez toujours créer un fichier <code>.dockerignore</code> .  Il vous permet d'ignorer les fichiers et dossiers qui ne sont pas nécessaires lors de la création de l'image.  Avec cette approche, nous pouvons réduire le soi-disant contexte de construction, ce qui nous permettra d'assembler rapidement l'image et de réduire sa taille.  Ce fichier prend en charge les modèles de nom de fichier, en cela il est similaire à un fichier <code>.gitignore</code> .  Il est recommandé d'ajouter une commande à <code>.dockerignore</code> raison de laquelle Docker ignorera le dossier <code>/.git</code> , car ce dossier contient généralement de gros matériaux (en particulier pendant le développement d'un projet) et l'ajouter à l'image entraîne une augmentation de sa taille.  De plus, copier ce dossier dans une image n'a pas beaucoup de sens. <br><br><h3>  <font color="#3AC1EF">▍2.</font>  <font color="#3AC1EF">Utilisez le processus d'assemblage d'images en plusieurs étapes</font> </h3><br>  Prenons l'exemple lorsque nous collectons un projet pour une certaine organisation.  Ce projet utilise de nombreux packages npm, et chacun de ces packages peut installer des packages supplémentaires dont il dépend.  L'exécution de toutes ces opérations entraîne une augmentation du temps passé dans le processus d'assemblage de l'image (bien que cela, grâce aux capacités de mise en cache de Docker, ne soit pas si grave).  Pire, l'image résultante contenant les dépendances d'un certain projet est assez grande.  Ici, si nous parlons de projets frontaux, nous pouvons rappeler que ces projets sont généralement traités à l'aide de bundlers comme webpack, qui permettent de regrouper facilement tout ce dont une application a besoin dans un package de vente.  Par conséquent, les fichiers de package npm pour un tel projet ne sont pas nécessaires.  Et cela signifie que nous pouvons nous débarrasser de ces fichiers après avoir construit le projet en utilisant le même webpack. <br><br>  Armé de cette idée, essayez de faire ceci: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   COPY package*.json ./ RUN npm install --production # - COPY . . RUN npm run build:production #    npm- RUN rm -rf node_modules</span></span></code> </pre> <br>  Une telle approche, cependant, ne nous conviendra pas.  Comme nous l'avons déjà dit, les instructions <code>RUN</code> , <code>ADD</code> et <code>COPY</code> créent des couches mises en cache par Docker, nous devons donc trouver un moyen de gérer l'installation des dépendances, de construire le projet, puis de supprimer les fichiers inutiles avec une seule commande.  Par exemple, cela pourrait ressembler à ceci: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#      COPY . . #  ,      RUN npm install --production &amp;&amp; npm run build:production &amp;&amp; rm -rf node_module</span></span></code> </pre> <br>  Dans cet exemple, il n'y a qu'une seule instruction <code>RUN</code> qui installe les dépendances, <code>node_modules</code> projet et supprime le dossier <code>node_modules</code> .  Cela conduit au fait que la taille de l'image ne sera pas aussi grande que la taille de l'image qui inclut le dossier <code>node_modules</code> .  Nous utilisons les fichiers de ce dossier uniquement pendant le processus de génération du projet, puis nous le supprimons.  Certes, cette approche est mauvaise en ce sens que l'installation des dépendances npm prend beaucoup de temps.  Vous pouvez éliminer cet inconvénient en utilisant la technologie d'assemblage d'images en plusieurs étapes. <br><br>  Imaginez que nous travaillons sur un projet frontal qui a de nombreuses dépendances, et que nous utilisons webpack pour construire ce projet.  Avec cette approche, nous pouvons, dans le but de réduire la taille de l'image, profiter des capacités de Docker pour l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">assemblage d'images en plusieurs étapes</a> . <br><br><pre> <code class="bash hljs">FROM node:8 As build <span class="hljs-comment"><span class="hljs-comment">#  RUN mkdir /app &amp;&amp; mkdir /src WORKDIR /src #   COPY package*.json ./ RUN npm install #     # RUN npm install --production #       COPY . . RUN npm run build:production #    ,     FROM node:alpine #      build   app COPY --from=build ./src/build/* /app/ ENTRYPOINT ["/app"] CMD ["--help"]</span></span></code> </pre> <br>  Avec cette approche, l'image résultante est beaucoup plus petite que l'image précédente, et nous utilisons également le <code>node:alpine</code> image <code>node:alpine</code> , qui est elle-même très petite.  Et voici une comparaison d'une paire d'images, au cours de laquelle on peut voir que l'image de <code>node:alpine</code> beaucoup plus petite que l'image de <code>node:8</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/565/c80/c3b/565c80c3bb0498e0ebcdf53022bdab6e.png"></div><br>  <i><font color="#999999">Comparaison des images du référentiel Node</font></i> <br><br><h3>  <font color="#3AC1EF">▍3.</font>  <font color="#3AC1EF">Utiliser Docker Cache</font> </h3><br>  Efforcez-vous d'utiliser les capacités de mise en cache de Docker pour créer vos images.  Nous avons déjà prêté attention à cette fonctionnalité lorsque nous travaillions avec un fichier auquel on accédait par le <code>package*.json</code> noms <code>package*.json</code> .  Cela réduit le temps de construction de l'image.  Mais cette opportunité ne doit pas être utilisée à la légère. <br><br>  Supposons que nous décrivions dans Dockerfile l'installation de packages dans une image créée à partir de l'image <code>Ubuntu:16.04</code> base <code>Ubuntu:16.04</code> : <br><br><pre> <code class="bash hljs">FROM ubuntu:16.04 RUN apt-get update &amp;&amp; apt-get install -y \   curl \   package-1 \   .   .</code> </pre> <br>  Lorsque le système traitera ce fichier, s'il y a beaucoup de packages installés, les opérations de mise à jour et d'installation prendront beaucoup de temps.  Afin d'améliorer la situation, nous avons décidé de tirer parti des capacités de mise en cache des couches de Docker et de réécrire le Dockerfile comme suit: <br><br><pre> <code class="bash hljs">FROM ubuntu:16.04 RUN apt-get update RUN apt-get install -y \   curl \   package-1 \   .   .</code> </pre> <br>  Maintenant, lors de l'assemblage de l'image pour la première fois, tout se passe comme prévu, car le cache n'a pas encore été formé.  Imaginez maintenant que nous devons installer un autre package, <code>package-2</code> .  Pour ce faire, nous réécrivons le fichier: <br><br><pre> <code class="bash hljs">FROM ubuntu:16.04 RUN apt-get update RUN apt-get install -y \   curl \   package-1 \   package-2 \   .   .</code> </pre> <br>  À la suite d'une telle commande, le <code>package-2</code> ne sera ni installé ni mis à jour.  Pourquoi?  Le fait est que lors de l'exécution de l'instruction de <code>RUN apt-get update</code> , Docker ne voit aucune différence entre cette instruction et l'instruction exécutée précédemment, par conséquent, il prend les données du cache.  Et ces données sont déjà dépassées.  Lors du traitement de l'instruction <code>RUN apt-get install</code> système l'exécute, car elle ne ressemble pas à une instruction similaire dans le Dockerfile précédent, mais pendant l'installation, des erreurs peuvent se produire ou l'ancienne version des packages sera installée.  En conséquence, il s'avère que les commandes de <code>update</code> et d' <code>install</code> doivent être exécutées dans la même instruction <code>RUN</code> , comme cela est fait dans le premier exemple.  La mise en cache est une fonctionnalité intéressante, mais une utilisation imprudente de cette fonctionnalité peut entraîner des problèmes. <br><br><h3>  <font color="#3AC1EF">▍4.</font>  <font color="#3AC1EF">Minimisez le nombre de couches d'image</font> </h3><br>  Il est recommandé, dans la mesure du possible, de s'efforcer de minimiser le nombre de couches d'image, car chaque couche est le système de fichiers de l'image Docker, ce qui signifie que plus les couches de l'image sont petites, plus elles seront compactes.  Lors de l'utilisation du processus à plusieurs étapes d'assemblage d'image, une réduction du nombre de couches dans l'image et une réduction de la taille de l'image sont obtenues. <br><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>  Dans cet article, nous avons examiné le processus de conditionnement des applications Node.js dans des conteneurs Docker et l'utilisation de ces conteneurs.  De plus, nous avons fait quelques recommandations qui, soit dit en passant, peuvent être utilisées non seulement lors de la création de conteneurs pour les projets Node.js. <br><br>  <b>Chers lecteurs!</b>  Si vous utilisez professionnellement Docker lorsque vous travaillez avec des projets Node.js, veuillez partager des recommandations sur l'utilisation efficace de ce système avec les débutants. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr440656/">https://habr.com/ru/post/fr440656/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr440646/index.html">Frontend Weekly Digest (11-17 févr.2019)</a></li>
<li><a href="../fr440648/index.html">Aperçu de la législation russe dans le domaine de l'accessibilité du Web</a></li>
<li><a href="../fr440650/index.html">Comment fonctionne la conscience: conclusions du livre d'Alexandre Nevzorov</a></li>
<li><a href="../fr440652/index.html">Vidéo calculée en 755 mégapixels: plénoptique hier, aujourd'hui et demain</a></li>
<li><a href="../fr440654/index.html">Apprendre Python: module argparse</a></li>
<li><a href="../fr440658/index.html">Exploration de Docker, partie 4: réduction de la taille des images et accélération de leur assemblage</a></li>
<li><a href="../fr440660/index.html">Learning Docker, Partie 5: Commandes</a></li>
<li><a href="../fr440662/index.html">Tutoriel React Partie 18: La sixième phase de travail sur une application TODO</a></li>
<li><a href="../fr440666/index.html">Classification des dessins manuscrits. Signaler dans Yandex</a></li>
<li><a href="../fr440670/index.html">La Banque centrale a publié des recommandations sur la protection cryptographique d'EBS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>