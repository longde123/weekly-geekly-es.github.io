<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò´ üìê ü§≤ Conteneurisation professionnelle des applications Node.js √† l'aide de Docker üôáüèΩ üåª üç±</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'auteur du mat√©riel, dont nous publions la traduction aujourd'hui, est un ing√©nieur DevOps. Il dit qu'il doit utiliser Docker . En particulier, cette...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Conteneurisation professionnelle des applications Node.js √† l'aide de Docker</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/440656/">  L'auteur du mat√©riel, dont nous publions la traduction aujourd'hui, est un ing√©nieur DevOps.  Il dit qu'il doit utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Docker</a> .  En particulier, cette plate-forme de gestion de conteneurs est utilis√©e √† diff√©rentes √©tapes du cycle de vie des applications Node.js.  L'utilisation de Docker, une technologie qui a r√©cemment √©t√© extr√™mement populaire, vous permet d'optimiser le processus de d√©veloppement et de sortie des projets Node.js en production. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/0c1/c88/f14/0c1c88f14934b3bb68342f9c5a18eee6.png" alt="image"></a> <br><br>  Nous publions maintenant une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">s√©rie d'articles</a> sur Docker, con√ßus pour ceux qui veulent apprendre cette plate-forme pour son utilisation dans diverses situations.  Le m√™me mat√©riel se concentre principalement sur l'utilisation professionnelle de Docker dans le d√©veloppement de Node.js. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Qu'est-ce qu'un docker?</font> </h2><br>  Docker est un programme con√ßu pour organiser la virtualisation au niveau du syst√®me d'exploitation (conteneurisation).  Au c≈ìur des conteneurs se trouvent des images en couches.  En termes simples, Docker est un outil qui vous permet de cr√©er, d√©ployer et ex√©cuter des applications √† l'aide de conteneurs ind√©pendants du syst√®me d'exploitation sur lequel ils s'ex√©cutent.  Le conteneur comprend une image du syst√®me d'exploitation de base n√©cessaire au fonctionnement de l'application, la biblioth√®que dont d√©pend cette application et cette application elle-m√™me.  Si plusieurs conteneurs s'ex√©cutent sur le m√™me ordinateur, ils utilisent ensemble les ressources de cet ordinateur.  Les conteneurs Docker peuvent emballer des projets cr√©√©s √† l'aide de diverses technologies.  Nous sommes int√©ress√©s par des projets bas√©s sur Node.js. <br><br><h2>  <font color="#3AC1EF">Cr√©ation d'un projet Node.js</font> </h2><br>  Avant de compresser un projet Node.js dans un conteneur Docker, nous devons cr√©er ce projet.  Faisons-le.  Voici le fichier <code>package.json</code> de ce projet: <br><br><pre> <code class="bash hljs">{ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"node-app"</span></span>, <span class="hljs-string"><span class="hljs-string">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"The best way to manage your Node app using Docker"</span></span>, <span class="hljs-string"><span class="hljs-string">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"index.js"</span></span>, <span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"start"</span></span>: <span class="hljs-string"><span class="hljs-string">"node index.js"</span></span> }, <span class="hljs-string"><span class="hljs-string">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">"Ankit Jain &lt;ankitjain28may77@gmail.com&gt;"</span></span>, <span class="hljs-string"><span class="hljs-string">"license"</span></span>: <span class="hljs-string"><span class="hljs-string">"ISC"</span></span>, <span class="hljs-string"><span class="hljs-string">"dependencies"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"express"</span></span>: <span class="hljs-string"><span class="hljs-string">"^4.16.4"</span></span> } }</code> </pre> <br>  Pour installer les d√©pendances du projet, ex√©cutez la commande <code>npm install</code> .  Au cours de cette commande, entre autres, le fichier <code>package-lock.json</code> sera cr√©√©.  Cr√©ez maintenant le fichier <code>index.js</code> , qui contiendra le code du projet: <br><br><pre> <code class="bash hljs">const express = require(<span class="hljs-string"><span class="hljs-string">'express'</span></span>); const app = express(); app.get(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, (req, res) =&gt; { res.send(<span class="hljs-string"><span class="hljs-string">'The best way to manage your Node app using Docker\n'</span></span>); }); app.listen(3000); console.log(<span class="hljs-string"><span class="hljs-string">'Running on http://localhost:3000'</span></span>);</code> </pre> <br>  Comme vous pouvez le voir, nous avons d√©crit ici un serveur simple qui renvoie du texte en r√©ponse √† des requ√™tes. <br><br><h2>  <font color="#3AC1EF">Cr√©er un Dockerfile</font> </h2><br>  Maintenant que l'application est pr√™te, parlons de la fa√ßon de l'int√©grer dans un conteneur Docker.  √Ä savoir, il s'agira de la partie la plus importante de tout projet bas√© sur Docker, √† propos du Dockerfile. <br><br>  Un Dockerfile est un fichier texte qui contient des instructions pour cr√©er une image Docker pour une application.  Les instructions de ce fichier, si elles n'entrent pas dans les d√©tails, d√©crivent la cr√©ation de couches d'un syst√®me de fichiers √† plusieurs niveaux, qui a tout ce dont une application a besoin pour fonctionner.  La plate-forme Docker peut mettre en cache des couches d'images, ce qui, lors de la r√©utilisation de couches qui sont d√©j√† dans le cache, acc√©l√®re le processus de cr√©ation d'images. <br><br>  En programmation orient√©e objet, il existe une chose telle qu'une classe.  Les classes sont utilis√©es pour cr√©er des objets.  Dans Docker, les images peuvent √™tre compar√©es √† des classes et les conteneurs peuvent √™tre compar√©s √† des instances d'images, c'est-√†-dire √† des objets.  Consid√©rez le processus de g√©n√©ration d'un Dockerfile, qui nous aidera √† comprendre cela. <br><br>  Cr√©ez un Dockerfile vide: <br><br><pre> <code class="bash hljs">touch Dockerfile</code> </pre> <br>  Puisque nous allons cr√©er un conteneur pour l'application Node.js, la premi√®re chose que nous devons mettre dans le conteneur sera l'image de base du n≈ìud, qui peut √™tre trouv√©e sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Docker Hub</a> .  Nous utiliserons la version LTS de Node.js.  Par cons√©quent, la premi√®re d√©claration de notre Dockerfile sera la d√©claration suivante: <br><br><pre> <code class="bash hljs">FROM node:8</code> </pre> <br>  Apr√®s cela, cr√©ez un r√©pertoire pour notre code.  En m√™me temps, gr√¢ce √† l'instruction <code>ARG</code> utilis√©e ici, nous pouvons, si n√©cessaire, sp√©cifier le nom du r√©pertoire d'application autre que <code>/app</code> lors de l'assemblage du conteneur.  Vous trouverez des d√©tails sur ce manuel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   ARG APP_DIR=app RUN mkdir -p ${APP_DIR} WORKDIR ${APP_DIR}</span></span></code> </pre> <br>  Puisque nous utilisons l'image Node, les plates-formes Node.js et npm y seront d√©j√† install√©es.  En utilisant ce qui est d√©j√† dans l'image, vous pouvez organiser l'installation des d√©pendances du projet.  En utilisant l'indicateur <code>--production</code> (ou si la <code>NODE_ENV</code> environnement <code>NODE_ENV</code> d√©finie sur <code>production</code> ), npm n'installera pas les modules r√©pertori√©s dans la section <code>devDependencies</code> du fichier <code>devDependencies</code> . <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   COPY package*.json ./ RUN npm install #     # RUN npm install --production</span></span></code> </pre> <br>  Ici, nous <code>package*.json</code> fichier <code>package*.json</code> dans l'image, au lieu, par exemple, de copier tous les fichiers du projet.  Nous le faisons pr√©cis√©ment parce que les instructions Dockerfile <code>RUN</code> , <code>COPY</code> et <code>ADD</code> cr√©ent des couches d'image suppl√©mentaires, vous pouvez donc utiliser les fonctionnalit√©s de mise en cache des couches de la plateforme Docker.  Avec cette approche, la prochaine fois que nous collecterons une image similaire, Docker cherchera s'il est possible de r√©utiliser des couches d'images qui sont d√©j√† dans le cache, et si c'est le cas, il tirera parti de ce qui est d√©j√† l√†, au lieu d'en cr√©er de nouvelles couches.  Cela vous permet de gagner s√©rieusement du temps lors de l'assemblage de couches au cours de travaux sur de grands projets, qui incluent de nombreux modules npm. <br><br>  Copiez maintenant les fichiers du projet dans le r√©pertoire de travail actuel.  Ici, nous n'utiliserons pas l'instruction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ADD</a> , mais l'instruction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">COPY</a> .  En fait, dans la plupart des cas, il est recommand√© de privil√©gier l'instruction <code>COPY</code> . <br><br>  L'instruction <code>ADD</code> , par rapport √† <code>COPY</code> , a certaines fonctionnalit√©s qui, cependant, ne sont pas toujours n√©cessaires.  Par exemple, nous parlons d'options pour d√©compresser les archives .tar et t√©l√©charger des fichiers par URL. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#    COPY . .</span></span></code> </pre> <br>  Les conteneurs Docker sont des environnements isol√©s.  Cela signifie que lorsque nous lancerons l'application dans le conteneur, nous ne pourrons pas interagir directement avec elle sans ouvrir le port sur lequel cette application √©coute.  Afin d'informer Docker qu'il existe une application dans un certain conteneur √©coutant sur un certain port, vous pouvez utiliser l'instruction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">EXPOSE</a> . <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   ,      EXPOSE 3000</span></span></code> </pre> <br>  √Ä ce jour, nous, en utilisant le Dockerfile, avons d√©crit l'image que l'application contiendra et tout ce dont elle a besoin pour r√©ussir le lancement.  Ajoutez maintenant l'instruction au fichier qui vous permet de d√©marrer l'application.  Il s'agit d'une instruction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CMD</a> .  Il vous permet de sp√©cifier une certaine commande avec des param√®tres qui seront ex√©cut√©s au d√©marrage du conteneur et, si n√©cessaire, peuvent √™tre remplac√©s par des outils de ligne de commande. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   CMD ["npm", "start"]</span></span></code> </pre> <br>  Voici √† quoi ressemblera le Dockerfile fini: <br><br><pre> <code class="bash hljs">FROM node:8 <span class="hljs-comment"><span class="hljs-comment">#   ARG APP_DIR=app RUN mkdir -p ${APP_DIR} WORKDIR ${APP_DIR} #   COPY package*.json ./ RUN npm install #     # RUN npm install --production #    COPY . . #   ,      EXPOSE 3000 #   CMD ["npm", "start"]</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Assemblage d'images</font> </h2><br>  Nous avons pr√©par√© un fichier Dockerfile contenant des instructions pour la construction de l'image, sur la base duquel un conteneur avec une application en cours d'ex√©cution sera cr√©√©.  Assemblez l'image en ex√©cutant une commande de la forme suivante: <br><br><pre> <code class="bash hljs">docker build --build-arg &lt;build arguments&gt; -t &lt;user-name&gt;/&lt;image-name&gt;:&lt;tag-name&gt; /path/to/Dockerfile</code> </pre> <br>  Dans notre cas, cela ressemblera √† ceci: <br><br><pre> <code class="bash hljs">docker build --build-arg APP_DIR=var/app -t ankitjain28may/node-app:V1 .</code> </pre> <br>  Dockerfile a une instruction <code>ARG</code> qui d√©crit l'argument <code>APP_DIR</code> .  Ici, nous d√©finissons sa signification.  Si cela n'est pas fait, il prendra alors la valeur qui lui est affect√©e dans le fichier, c'est-√†-dire <code>app</code> . <br><br>  Apr√®s avoir assembl√© l'image, v√©rifiez si Docker la voit.  Pour ce faire, ex√©cutez la commande suivante: <br><br><pre> <code class="bash hljs">docker images</code> </pre> <br>  En r√©ponse √† cette commande, approximativement les √©l√©ments suivants devraient √™tre sortis. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51d/c22/3e0/51dc223e0030bb0275c3d61fa01562e5.png"></div><br>  <i><font color="#999999">Images Docker</font></i> <br><br><h2>  <font color="#3AC1EF">Lancement d'image</font> </h2><br>  Apr√®s avoir assembl√© l'image Docker, nous pouvons l'ex√©cuter, c'est-√†-dire en cr√©er une instance, repr√©sent√©e par un conteneur de travail.  Pour ce faire, utilisez une commande de ce type: <br><br><pre> <code class="bash hljs">docker run -p &lt;External-port:exposed-port&gt; -d --name &lt;name of the container&gt; &lt;user-name&gt;/&lt;image-name&gt;:&lt;tag-name&gt;</code> </pre> <br>  Dans notre cas, cela ressemblera √† ceci: <br><br><pre> <code class="bash hljs">docker run -p 8000:3000 -d --name node-app ankitjain28may/node-app:V1</code> </pre> <br>  Nous demanderons au syst√®me des informations sur le fonctionnement des conteneurs √† l'aide de cette commande: <br><br><pre> <code class="bash hljs">docker ps</code> </pre> <br>  En r√©ponse √† cela, le syst√®me doit produire quelque chose comme ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87f/bc0/fcf/87fbc0fcf1bdeecef051e2874d48d91e.png"></div><br>  <i><font color="#999999">Conteneurs Docker</font></i> <br><br>  Jusqu'√† pr√©sent, tout se passe comme pr√©vu, bien que nous n'ayons pas encore essay√© d'acc√©der √† l'application en cours d'ex√©cution dans le conteneur.  √Ä savoir, notre conteneur, nomm√© <code>node-app</code> , √©coute sur le port <code>8000</code> .  Afin d'essayer d'y acc√©der, vous pouvez ouvrir un navigateur et y acc√©der √† <code>localhost:8000</code> .  De plus, afin de v√©rifier l'int√©grit√© du conteneur, vous pouvez utiliser la commande suivante: <br><br><pre> <code class="bash hljs">curl -i localhost:8000</code> </pre> <br>  Si le conteneur fonctionne vraiment, quelque chose comme celui illustr√© dans la figure suivante sera retourn√© en r√©ponse √† cette commande. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea4/407/9ba/ea44079bab09d56c402af3c58eb6a638.png"></div><br>  <i><font color="#999999">R√©sultat de la v√©rification de l'√©tat du conteneur</font></i> <br><br>  Sur la base de la m√™me image, par exemple, sur la base de tout juste cr√©√©, il est possible de cr√©er de nombreux conteneurs.  De plus, vous pouvez envoyer notre image au registre Docker Hub, ce qui permettra √† d'autres d√©veloppeurs de t√©l√©charger notre image et de lancer les conteneurs appropri√©s √† la maison.  Cette approche simplifie le travail avec les projets. <br><br><h2>  <font color="#3AC1EF">Recommandations</font> </h2><br>  Voici quelques suggestions qui m√©ritent d'√™tre examin√©es afin de tirer parti de la puissance de Docker et de cr√©er des images aussi compactes que possible. <br><br><h3>  <font color="#3AC1EF">‚ñç1.</font>  <font color="#3AC1EF">Cr√©ez toujours un fichier .dockerignore</font> </h3><br>  Dans le dossier de projet que vous pr√©voyez de placer dans le conteneur, vous devez toujours cr√©er un fichier <code>.dockerignore</code> .  Il vous permet d'ignorer les fichiers et dossiers qui ne sont pas n√©cessaires lors de la cr√©ation de l'image.  Avec cette approche, nous pouvons r√©duire le soi-disant contexte de construction, ce qui nous permettra d'assembler rapidement l'image et de r√©duire sa taille.  Ce fichier prend en charge les mod√®les de nom de fichier, en cela il est similaire √† un fichier <code>.gitignore</code> .  Il est recommand√© d'ajouter une commande √† <code>.dockerignore</code> raison de laquelle Docker ignorera le dossier <code>/.git</code> , car ce dossier contient g√©n√©ralement de gros mat√©riaux (en particulier pendant le d√©veloppement d'un projet) et l'ajouter √† l'image entra√Æne une augmentation de sa taille.  De plus, copier ce dossier dans une image n'a pas beaucoup de sens. <br><br><h3>  <font color="#3AC1EF">‚ñç2.</font>  <font color="#3AC1EF">Utilisez le processus d'assemblage d'images en plusieurs √©tapes</font> </h3><br>  Prenons l'exemple lorsque nous collectons un projet pour une certaine organisation.  Ce projet utilise de nombreux packages npm, et chacun de ces packages peut installer des packages suppl√©mentaires dont il d√©pend.  L'ex√©cution de toutes ces op√©rations entra√Æne une augmentation du temps pass√© dans le processus d'assemblage de l'image (bien que cela, gr√¢ce aux capacit√©s de mise en cache de Docker, ne soit pas si grave).  Pire, l'image r√©sultante contenant les d√©pendances d'un certain projet est assez grande.  Ici, si nous parlons de projets frontaux, nous pouvons rappeler que ces projets sont g√©n√©ralement trait√©s √† l'aide de bundlers comme webpack, qui permettent de regrouper facilement tout ce dont une application a besoin dans un package de vente.  Par cons√©quent, les fichiers de package npm pour un tel projet ne sont pas n√©cessaires.  Et cela signifie que nous pouvons nous d√©barrasser de ces fichiers apr√®s avoir construit le projet en utilisant le m√™me webpack. <br><br>  Arm√© de cette id√©e, essayez de faire ceci: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   COPY package*.json ./ RUN npm install --production # - COPY . . RUN npm run build:production #    npm- RUN rm -rf node_modules</span></span></code> </pre> <br>  Une telle approche, cependant, ne nous conviendra pas.  Comme nous l'avons d√©j√† dit, les instructions <code>RUN</code> , <code>ADD</code> et <code>COPY</code> cr√©ent des couches mises en cache par Docker, nous devons donc trouver un moyen de g√©rer l'installation des d√©pendances, de construire le projet, puis de supprimer les fichiers inutiles avec une seule commande.  Par exemple, cela pourrait ressembler √† ceci: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#      COPY . . #  ,      RUN npm install --production &amp;&amp; npm run build:production &amp;&amp; rm -rf node_module</span></span></code> </pre> <br>  Dans cet exemple, il n'y a qu'une seule instruction <code>RUN</code> qui installe les d√©pendances, <code>node_modules</code> projet et supprime le dossier <code>node_modules</code> .  Cela conduit au fait que la taille de l'image ne sera pas aussi grande que la taille de l'image qui inclut le dossier <code>node_modules</code> .  Nous utilisons les fichiers de ce dossier uniquement pendant le processus de g√©n√©ration du projet, puis nous le supprimons.  Certes, cette approche est mauvaise en ce sens que l'installation des d√©pendances npm prend beaucoup de temps.  Vous pouvez √©liminer cet inconv√©nient en utilisant la technologie d'assemblage d'images en plusieurs √©tapes. <br><br>  Imaginez que nous travaillons sur un projet frontal qui a de nombreuses d√©pendances, et que nous utilisons webpack pour construire ce projet.  Avec cette approche, nous pouvons, dans le but de r√©duire la taille de l'image, profiter des capacit√©s de Docker pour l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">assemblage d'images en plusieurs √©tapes</a> . <br><br><pre> <code class="bash hljs">FROM node:8 As build <span class="hljs-comment"><span class="hljs-comment">#  RUN mkdir /app &amp;&amp; mkdir /src WORKDIR /src #   COPY package*.json ./ RUN npm install #     # RUN npm install --production #       COPY . . RUN npm run build:production #    ,     FROM node:alpine #      build   app COPY --from=build ./src/build/* /app/ ENTRYPOINT ["/app"] CMD ["--help"]</span></span></code> </pre> <br>  Avec cette approche, l'image r√©sultante est beaucoup plus petite que l'image pr√©c√©dente, et nous utilisons √©galement le <code>node:alpine</code> image <code>node:alpine</code> , qui est elle-m√™me tr√®s petite.  Et voici une comparaison d'une paire d'images, au cours de laquelle on peut voir que l'image de <code>node:alpine</code> beaucoup plus petite que l'image de <code>node:8</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/565/c80/c3b/565c80c3bb0498e0ebcdf53022bdab6e.png"></div><br>  <i><font color="#999999">Comparaison des images du r√©f√©rentiel Node</font></i> <br><br><h3>  <font color="#3AC1EF">‚ñç3.</font>  <font color="#3AC1EF">Utiliser Docker Cache</font> </h3><br>  Efforcez-vous d'utiliser les capacit√©s de mise en cache de Docker pour cr√©er vos images.  Nous avons d√©j√† pr√™t√© attention √† cette fonctionnalit√© lorsque nous travaillions avec un fichier auquel on acc√©dait par le <code>package*.json</code> noms <code>package*.json</code> .  Cela r√©duit le temps de construction de l'image.  Mais cette opportunit√© ne doit pas √™tre utilis√©e √† la l√©g√®re. <br><br>  Supposons que nous d√©crivions dans Dockerfile l'installation de packages dans une image cr√©√©e √† partir de l'image <code>Ubuntu:16.04</code> base <code>Ubuntu:16.04</code> : <br><br><pre> <code class="bash hljs">FROM ubuntu:16.04 RUN apt-get update &amp;&amp; apt-get install -y \   curl \   package-1 \   .   .</code> </pre> <br>  Lorsque le syst√®me traitera ce fichier, s'il y a beaucoup de packages install√©s, les op√©rations de mise √† jour et d'installation prendront beaucoup de temps.  Afin d'am√©liorer la situation, nous avons d√©cid√© de tirer parti des capacit√©s de mise en cache des couches de Docker et de r√©√©crire le Dockerfile comme suit: <br><br><pre> <code class="bash hljs">FROM ubuntu:16.04 RUN apt-get update RUN apt-get install -y \   curl \   package-1 \   .   .</code> </pre> <br>  Maintenant, lors de l'assemblage de l'image pour la premi√®re fois, tout se passe comme pr√©vu, car le cache n'a pas encore √©t√© form√©.  Imaginez maintenant que nous devons installer un autre package, <code>package-2</code> .  Pour ce faire, nous r√©√©crivons le fichier: <br><br><pre> <code class="bash hljs">FROM ubuntu:16.04 RUN apt-get update RUN apt-get install -y \   curl \   package-1 \   package-2 \   .   .</code> </pre> <br>  √Ä la suite d'une telle commande, le <code>package-2</code> ne sera ni install√© ni mis √† jour.  Pourquoi?  Le fait est que lors de l'ex√©cution de l'instruction de <code>RUN apt-get update</code> , Docker ne voit aucune diff√©rence entre cette instruction et l'instruction ex√©cut√©e pr√©c√©demment, par cons√©quent, il prend les donn√©es du cache.  Et ces donn√©es sont d√©j√† d√©pass√©es.  Lors du traitement de l'instruction <code>RUN apt-get install</code> syst√®me l'ex√©cute, car elle ne ressemble pas √† une instruction similaire dans le Dockerfile pr√©c√©dent, mais pendant l'installation, des erreurs peuvent se produire ou l'ancienne version des packages sera install√©e.  En cons√©quence, il s'av√®re que les commandes de <code>update</code> et d' <code>install</code> doivent √™tre ex√©cut√©es dans la m√™me instruction <code>RUN</code> , comme cela est fait dans le premier exemple.  La mise en cache est une fonctionnalit√© int√©ressante, mais une utilisation imprudente de cette fonctionnalit√© peut entra√Æner des probl√®mes. <br><br><h3>  <font color="#3AC1EF">‚ñç4.</font>  <font color="#3AC1EF">Minimisez le nombre de couches d'image</font> </h3><br>  Il est recommand√©, dans la mesure du possible, de s'efforcer de minimiser le nombre de couches d'image, car chaque couche est le syst√®me de fichiers de l'image Docker, ce qui signifie que plus les couches de l'image sont petites, plus elles seront compactes.  Lors de l'utilisation du processus √† plusieurs √©tapes d'assemblage d'image, une r√©duction du nombre de couches dans l'image et une r√©duction de la taille de l'image sont obtenues. <br><br><h2>  <font color="#3AC1EF">R√©sum√©</font> </h2><br>  Dans cet article, nous avons examin√© le processus de conditionnement des applications Node.js dans des conteneurs Docker et l'utilisation de ces conteneurs.  De plus, nous avons fait quelques recommandations qui, soit dit en passant, peuvent √™tre utilis√©es non seulement lors de la cr√©ation de conteneurs pour les projets Node.js. <br><br>  <b>Chers lecteurs!</b>  Si vous utilisez professionnellement Docker lorsque vous travaillez avec des projets Node.js, veuillez partager des recommandations sur l'utilisation efficace de ce syst√®me avec les d√©butants. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr440656/">https://habr.com/ru/post/fr440656/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr440646/index.html">Frontend Weekly Digest (11-17 f√©vr.2019)</a></li>
<li><a href="../fr440648/index.html">Aper√ßu de la l√©gislation russe dans le domaine de l'accessibilit√© du Web</a></li>
<li><a href="../fr440650/index.html">Comment fonctionne la conscience: conclusions du livre d'Alexandre Nevzorov</a></li>
<li><a href="../fr440652/index.html">Vid√©o calcul√©e en 755 m√©gapixels: pl√©noptique hier, aujourd'hui et demain</a></li>
<li><a href="../fr440654/index.html">Apprendre Python: module argparse</a></li>
<li><a href="../fr440658/index.html">Exploration de Docker, partie 4: r√©duction de la taille des images et acc√©l√©ration de leur assemblage</a></li>
<li><a href="../fr440660/index.html">Learning Docker, Partie 5: Commandes</a></li>
<li><a href="../fr440662/index.html">Tutoriel React Partie 18: La sixi√®me phase de travail sur une application TODO</a></li>
<li><a href="../fr440666/index.html">Classification des dessins manuscrits. Signaler dans Yandex</a></li>
<li><a href="../fr440670/index.html">La Banque centrale a publi√© des recommandations sur la protection cryptographique d'EBS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>