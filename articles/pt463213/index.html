<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôåüèº üí∂ üé™ Conceitos errados para desenvolvedores iniciantes em C #. Tentando responder a perguntas padr√£o üèçÔ∏è ü•© üôÖüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recentemente, tive a oportunidade de conversar com um n√∫mero bastante grande de desenvolvedores iniciantes em C #. Muitos deles est√£o interessados ‚Äã‚Äãe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Conceitos errados para desenvolvedores iniciantes em C #. Tentando responder a perguntas padr√£o</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463213/">  Recentemente, tive a oportunidade de conversar com um n√∫mero bastante grande de desenvolvedores iniciantes em C #.  Muitos deles est√£o interessados ‚Äã‚Äãem linguagem e plataforma, e isso √© muito legal.  Entre os juniores verdes, o obscurantismo √© generalizado sobre as coisas √≥bvias (basta ler um livro sobre mem√≥ria).  E isso tamb√©m me levou a criar este artigo.  O artigo √© voltado principalmente para desenvolvedores iniciantes, mas acho que muitos fatos ser√£o √∫teis para a pr√°tica de engenheiros.  Bem, os erros mais √≥bvios e desinteressantes, √© claro, s√£o omitidos.  Aqui est√£o os mais interessantes e significativos, especialmente do ponto de vista da aprova√ß√£o na entrevista. <br><br><div style="text-align:center;"><img width="300" src="https://habrastorage.org/webt/_q/a5/nc/_qa5ncp0f-7ydqssgacmzqevk30.png"></div><br><a name="habracut"></a><br><h3>  # 1  Mantra cerca de 3 gera√ß√µes em qualquer situa√ß√£o </h3><br>  Isso √© mais uma imprecis√£o do que um erro.  A pergunta sobre o "coletor de lixo em C #" para o desenvolvedor tornou-se um cl√°ssico e poucas pessoas come√ßar√£o a responder de maneira inteligente sobre o conceito de gera√ß√µes.  No entanto, por alguma raz√£o, poucas pessoas prestam aten√ß√£o ao fato de que o grande e terr√≠vel coletor de lixo faz parte do tempo de execu√ß√£o.  Assim, eu teria deixado claro que n√£o era um dedo e teria perguntado que tipo de ambiente de tempo de execu√ß√£o estava envolvido.  Para a consulta "coletor de lixo em c #" na Internet, voc√™ pode encontrar mais do que muitas informa√ß√µes semelhantes.  No entanto, poucas pessoas mencionam que essas informa√ß√µes se referem ao <i>CLR / CoreCLR</i> (como regra).  Mas n√£o se esque√ßa do Mono, um tempo de execu√ß√£o leve, flex√≠vel e incorporado que ocupou seu nicho no desenvolvimento m√≥vel (Unity, Xamarin) e √© usado no Blazor.  E para os respectivos desenvolvedores, aconselho que voc√™ indague sobre os detalhes do dispositivo de montagem em Mono.  Por exemplo, na consulta ‚Äúgera√ß√µes mono-coletor de lixo‚Äù, √© poss√≠vel ver que existem apenas duas gera√ß√µes - <b>ber√ß√°rio</b> e <b>gera√ß√£o antiga</b> (no novo e elegante coletor de lixo - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SGen</a> ). <br><br><h3>  # 2  Mantra cerca de 2 etapas da coleta de lixo em qualquer situa√ß√£o </h3><br>  N√£o faz muito tempo, as fontes do coletor de lixo estavam escondidas de todos.  No entanto, o interesse na estrutura interna da plataforma sempre foi.  Portanto, as informa√ß√µes foram extra√≠das de diferentes maneiras.  E algumas imprecis√µes na engenharia reversa do coletor levaram ao mito de que o coletor trabalha em duas etapas: marca√ß√£o e limpeza.  Ou pior, 3 etapas - marca√ß√£o, limpeza, compress√£o. <br><br>  No entanto, tudo mudou <s>quando o pessoal do fogo desencadeou uma guerra</s> com o advento do <i>CoreCLR</i> e o c√≥digo-fonte do coletor.  O c√≥digo do compilador para CoreCLR foi obtido inteiramente da vers√£o do CLR.  Ningu√©m o escreveu do zero, respectivamente, quase tudo que pode ser aprendido com o c√≥digo-fonte CoreCLR tamb√©m ser√° v√°lido para o CLR.  Agora, para entender como algo funciona, basta ir ao github e encontr√°-lo no c√≥digo-fonte ou leia o leia- <a href="">me</a> .  L√° voc√™ pode ver que existem 5 fases: marca√ß√£o, planejamento, atualiza√ß√£o de links, compacta√ß√£o (exclus√£o com realoca√ß√£o) e exclus√£o sem realoca√ß√£o (isso √© dif√≠cil de traduzir).  Mas formalmente pode ser dividido em 3 etapas - marca√ß√£o, planejamento, limpeza. <br><br>  No <b>est√°gio da marca√ß√£o,</b> verifica-se quais objetos n√£o devem ser coletados pelo coletor. <br>  No <b>est√°gio de planejamento,</b> v√°rios indicadores do estado atual da mem√≥ria s√£o calculados e os dados necess√°rios no est√°gio de limpeza s√£o coletados.  Gra√ßas √†s informa√ß√µes recebidas nesta etapa, √© tomada uma decis√£o sobre a necessidade de compacta√ß√£o (desfragmenta√ß√£o), que tamb√©m calcula quanto voc√™ precisa mover objetos, etc. <br><br>  E na <b>fase de limpeza</b> , dependendo da necessidade de compacta√ß√£o, os links podem ser atualizados e compactados ou exclu√≠dos sem se mover. <br><br><h3>  # 3  Alocar mem√≥ria no heap √© t√£o r√°pido quanto na pilha </h3><br>  Novamente, imprecis√£o, em vez de mentira absoluta.  No caso geral, √© claro, a diferen√ßa na velocidade de aloca√ß√£o de mem√≥ria √© m√≠nima.  De fato, na melhor das hip√≥teses, com <i>aloca√ß√£o de ponteiro de retorno</i> , a aloca√ß√£o de mem√≥ria √© apenas uma mudan√ßa de ponteiro, como na pilha.  No entanto, fatores como atribuir um novo objeto ao campo antigo (que afetar√° a <i>barreira de grava√ß√£o</i> , atualizar a <i>tabela de cart√µes</i> - um mecanismo que permite rastrear links da gera√ß√£o mais antiga para a mais recente), a presen√ßa de um finalizador (voc√™ deve adicionar o tipo √† fila apropriada) pode afetar a aloca√ß√£o de mem√≥ria na pilha. Tamb√©m √© poss√≠vel que o objeto seja registrado em um dos furos livres na pilha (ap√≥s a montagem sem desfragmenta√ß√£o).  E encontrar um buraco assim, embora r√°pido, √© obviamente mais lento que um simples deslocamento de ponteiro.  Bem, √© claro, cada objeto criado aproxima a pr√≥xima coleta de lixo.  E no pr√≥ximo procedimento para alocar mem√≥ria, isso pode acontecer.  O que, naturalmente, levar√° algum tempo. <br><br><h3>  # 4  Defini√ß√£o de refer√™ncia, tipos significativos e embalagens atrav√©s dos conceitos de pilha e pilha </h3><br>  Cl√°ssico certo, que, felizmente, n√£o √© t√£o comum. <br><br>  O tipo de refer√™ncia est√° localizado na pilha.  Significativo na pilha.  Certamente muitos j√° ouviram essas defini√ß√µes com muita frequ√™ncia.  Mas essa n√£o √© apenas uma verdade parcial, portanto, definir conceitos por meio de abstra√ß√£o vazada n√£o √© uma boa id√©ia.  Para todas as defini√ß√µes, sugiro que voc√™ consulte o padr√£o CLI - <b>ECMA 335</b> .  Primeiro, vale esclarecer que os tipos descrevem valores.  Portanto, o tipo de refer√™ncia √© definido da seguinte forma - o valor descrito pelo tipo de refer√™ncia (link) indica a <b>localiza√ß√£o de</b> outro valor.  Para um tipo significativo, o valor descrito por ele √© aut√¥nomo (independente).  Sobre onde esses ou esses tipos de palavras est√£o localizados.  Esta √© uma abstra√ß√£o vazada que voc√™ ainda deve saber. <br><br>  Um tipo significativo pode estar localizado: <br><br><ol><li>  Na mem√≥ria din√¢mica (pilha), se faz parte de um objeto localizado na pilha ou no caso de empacotamento; </li><li>  Na pilha, se for um valor local vari√°vel / argumento / retorno do m√©todo; </li><li>  Nos registros, se permite o tamanho de um tipo significativo e outras condi√ß√µes. </li></ol><br>  O tipo de refer√™ncia, ou seja, o valor para o qual o link aponta, est√° atualmente localizado no heap. <br><br>  O link em si pode estar localizado no mesmo local que o tipo significativo. <br><br>  A embalagem tamb√©m n√£o √© determinada pelos locais de armazenamento.  Considere um breve exemplo. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo C #</b> <div class="spoiler_text"><pre><code class="plaintext hljs">public struct MyStruct { public int justField; } public class MyClass { public MyStruct justStruct; } public static void Main() { MyClass instance = new MyClass(); object boxed = instance.justStruct; }</code> </pre> <br></div></div><br>  E o c√≥digo IL correspondente para o m√©todo Main <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo IL</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> 1: nop 2: newobj instance void C/MyClass::.ctor() 3: stloc.0 4: ldloc.0 5: ldfld valuetype C/MyStruct C/MyClass::justStruct 6: box C/MyStruct 7: stloc.1 8: ret</code> </pre><br></div></div><br>  Como o tipo significativo faz parte da refer√™ncia, √© √≥bvio que ele estar√° localizado no heap.  E a sexta linha deixa claro que estamos lidando com embalagens.  Consequentemente, a defini√ß√£o t√≠pica de "copiar da pilha para a pilha" falha. <br><br>  Para determinar o que √© um pacote, para iniciantes, vale dizer que, para cada tipo significativo, o CTS (sistema de tipos comuns) define um tipo de refer√™ncia, chamado de tipo empacotado.  Portanto, <b>empacotar</b> √© uma opera√ß√£o em um tipo significativo que cria o valor do tipo empacotado correspondente contendo uma c√≥pia bit a bit do valor original. <br><br><h3>  # 4  Eventos - um mecanismo separado </h3><br>  Os eventos existem a partir da primeira vers√£o do idioma e as perguntas sobre eles s√£o muito mais comuns do que os pr√≥prios eventos.  No entanto, vale a pena entender e saber o que √©, porque esse mecanismo permite que voc√™ escreva um c√≥digo muito pouco acoplado, o que √†s vezes √© √∫til. <br><br>  Infelizmente, muitas vezes um evento √© entendido como um instrumento, tipo, mecanismo separado.  Isso √© especialmente facilitado pelo tipo do BCL <i>EventHandler</i> , cujo nome sugere que √© algo separado. <br><br>  A defini√ß√£o de um evento deve come√ßar definindo as propriedades.  H√° muito tempo eu desenhei essa analogia para mim e vi recentemente que ela foi desenhada na especifica√ß√£o da CLI. <br><br>  A propriedade define o valor nomeado e os m√©todos que o acessam.  Isso parece bastante √≥bvio.  Passamos para eventos.  O CTS suporta eventos e propriedades, mas os m√©todos de acesso s√£o diferentes e incluem m√©todos para inscri√ß√£o e cancelamento de inscri√ß√£o em um evento.  Na especifica√ß√£o da linguagem C #, a classe define um evento ... que lembra uma declara√ß√£o de campo com a adi√ß√£o da palavra-chave event.  O tipo desta declara√ß√£o deve ser o tipo de delegado.  Gra√ßas ao padr√£o CLI para as defini√ß√µes. <br><br>  Portanto, isso significa que o evento nada mais √© do que um delegado que exp√µe apenas parte da funcionalidade dos delegados - adicionando outro delegado √† lista para execu√ß√£o, removendo-o desta lista.  Dentro da classe, o evento n√£o √© diferente de um campo simples do tipo delegado. <br><br><h3>  # 5  Recursos gerenciados e n√£o gerenciados.  Finalizadores e IDisposable </h3><br>  Existe uma confus√£o absoluta ao lidar com esses recursos.  Isso √© amplamente facilitado pela Internet com milhares de artigos sobre a implementa√ß√£o correta do padr√£o Dispose.  Na verdade, n√£o h√° nada de criminoso nesse padr√£o - um m√©todo de modelo modificado para um caso espec√≠fico.  Mas a quest√£o √© se √© necess√°rio.  Por alguma raz√£o, algumas pessoas t√™m um desejo irresist√≠vel de implementar um finalizador para cada espirro.  Muito provavelmente, a raz√£o para isso n√£o √© uma compreens√£o completa do que √© um "recurso n√£o gerenciado".  E as linhas sobre o fato de que nos finalizadores, via de regra, os recursos n√£o gerenciados s√£o liberados devido a esse entendimento incompleto, passam e n√£o permanecem na cabe√ßa. <br><br>  <b>Um recurso n√£o gerenciado</b> √© um recurso que n√£o √© gerenciado (por mais estranho que seja).  Um <b>recurso gerenciado</b> , por sua vez, √© aquele que √© alocado e liberado pela CLI automaticamente por meio de um processo chamado coleta de lixo.  Eu descaradamente descartei essa defini√ß√£o do padr√£o CLI.  Mas se voc√™ tentar explicar de maneira mais simples, os recursos n√£o gerenciados s√£o aqueles que o coletor de lixo n√£o conhece.  (A rigor, podemos fornecer ao coletor algumas informa√ß√µes sobre esses recursos usando GC.AddMemoryPressure e GC.RemoveMemoryPressure, isso pode afetar o ajuste interno do coletor).  Consequentemente, ele n√£o ser√° capaz de cuidar da liberta√ß√£o deles, e, portanto, devemos fazer isso por ele.  E pode haver muitas abordagens para isso.  E para que o c√≥digo n√£o fique deslumbrado com a diversidade da imagina√ß√£o dos desenvolvedores, s√£o utilizadas 2 abordagens geralmente aceitas. <br><br><ol><li>  A interface IDisposable (e sua vers√£o ass√≠ncrona de IAsyncDisposable).  Ele √© monitorado por todos os analisadores de c√≥digo, por isso √© dif√≠cil esquecer sua chamada.  Fornece um √∫nico m√©todo - Dispose.  E o suporte ao compilador √© a instru√ß√£o using.  Um excelente candidato para o corpo do m√©todo Dispose √© chamar um m√©todo semelhante de um dos campos da classe ou liberar um recurso n√£o gerenciado.  Chamado explicitamente pelo usu√°rio da classe.  A presen√ßa dessa interface na classe implica que, ap√≥s a conclus√£o do trabalho com a inst√¢ncia, voc√™ precisa chamar esse m√©todo. <br></li><li>  Finalizador  Na sua ess√™ncia, o seguro.  Chamado implicitamente, em um tempo indefinido, durante a coleta de lixo.  Retarda a aloca√ß√£o de mem√≥ria, o trabalho do coletor de lixo, prolonga a vida √∫til dos objetos pelo menos at√© a pr√≥xima montagem, ou at√© mais, mas √© chamado por si s√≥, mesmo que ningu√©m o tenha chamado.  Devido √† sua natureza n√£o determin√≠stica, somente recursos n√£o gerenciados devem ser liberados.  Voc√™ tamb√©m pode encontrar exemplos nos quais o finalizador foi usado para ressuscitar o objeto e organizar o pool de objetos dessa maneira.  No entanto, essa implementa√ß√£o de um conjunto de objetos √© definitivamente uma m√° ideia.  Como tentar fazer login, lan√ßar exce√ß√µes, acessar o banco de dados e milhares de a√ß√µes semelhantes. <br></li></ol><br>  E voc√™ pode facilmente imaginar a situa√ß√£o ao escrever uma biblioteca cr√≠tica para o desempenho, que usa recursos n√£o gerenciados internamente, que pode ser manipulada simplesmente pelo manuseio competente desse recurso, liberando a mem√≥ria com cuidado manualmente.  Ao escrever essas bibliotecas de alto desempenho, o OOP, o suporte e outros semelhantes v√£o al√©m. <br><br>  E, contrariamente √† afirma√ß√£o de que Dispose viola o conceito em que o CLR far√° tudo por n√≥s, nos for√ßar√° a fazer algo por conta pr√≥pria, a se lembrar de algo etc., direi o seguinte.  Ao trabalhar com recursos n√£o gerenciados, voc√™ deve estar preparado para que eles n√£o sejam gerenciados por ningu√©m al√©m de voc√™.  E, em geral, as situa√ß√µes em que esses recursos ser√£o usados ‚Äã‚Äãnos empreendimentos quase nunca s√£o encontradas.  E, na maioria dos casos, voc√™ pode conviver com maravilhosas classes de wrapper, como o SafeHandle, que fornece finaliza√ß√£o cr√≠tica de recursos, impedindo a montagem prematura. <br><br>  Se, por um motivo ou outro, houver muitos recursos em seu aplicativo que exijam etapas adicionais para liberar, verifique o excelente padr√£o do JetBrains, Lifetime.  Mas voc√™ n√£o deve us√°-lo quando vir o primeiro objeto IDisposable. <br><br><h3>  # 6  Pilha de fluxo, pilha de chamadas, pilha de computa√ß√£o e <pre>  Pilha &lt;T&gt; </pre></h3><br>  O √∫ltimo par√°grafo acrescentou risadas por isso; n√£o creio que haja quem atribua o √∫ltimo aos dois anteriores.  No entanto, h√° muita confus√£o sobre o que s√£o uma pilha de fluxo, pilha de chamada e pilha computacional. <br><br>  <b>A pilha de chamadas</b> √© uma estrutura de dados, ou seja, uma pilha, para armazenar endere√ßos de retorno, para retornar de fun√ß√µes.  A pilha de chamadas √© um conceito mais l√≥gico.  Ele n√£o regula onde e como as informa√ß√µes devem ser armazenadas para retorno.  Acontece que a pilha de chamadas √© a pilha mais comum e nativa, ou seja,  Pilha (piada).  As vari√°veis ‚Äã‚Äãlocais s√£o armazenadas nele, os par√¢metros s√£o passados ‚Äã‚Äãpor ele e os endere√ßos de retorno s√£o armazenados quando a instru√ß√£o CALL e as interrup√ß√µes s√£o chamadas, que s√£o subsequentemente usadas pela instru√ß√£o RET para retornar da fun√ß√£o / interrup√ß√£o.  V√° em frente.  Uma das principais piadas do fluxo √© um ponteiro para a instru√ß√£o, que √© executada posteriormente.  Um thread, por sua vez, executa instru√ß√µes que se combinam em fun√ß√µes.  Por conseguinte, cada segmento tem uma pilha de chamadas.  Assim, verifica-se que a pilha de fluxo √© a pilha de chamadas.  Ou seja, a pilha de chamadas desse fluxo.  Em geral, tamb√©m √© referido sob outros nomes: pilha de software, pilha de m√°quinas. <br><br>  Foi considerado em detalhes no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo anterior</a> . <br>  Al√©m disso, a defini√ß√£o da pilha de chamadas √© usada para indicar a cadeia de chamadas de m√©todos espec√≠ficos em um idioma espec√≠fico. <br><br>  <b>Pilha de computa√ß√£o (pilha de avalia√ß√£o)</b> .  Como voc√™ sabe, o c√≥digo C # √© compilado no c√≥digo IL, que faz parte das DLLs resultantes (no caso mais geral).  E no cora√ß√£o do tempo de execu√ß√£o que absorve nossas DLLs e executa o c√≥digo IL est√° a m√°quina de empilhar.  Quase todas as instru√ß√µes de IL operam com uma certa pilha.  Por exemplo, o <i>ldloc</i> carrega uma vari√°vel local em um √≠ndice espec√≠fico na pilha.  Aqui, a pilha se refere a uma certa pilha virtual, porque no final essa vari√°vel pode com alta probabilidade estar em registros.  Instru√ß√µes aritm√©ticas, l√≥gicas e outras instru√ß√µes de IL operam nas vari√°veis ‚Äã‚Äãda pilha e colocam o resultado l√°.  Ou seja, os c√°lculos s√£o feitos atrav√©s dessa pilha.  Assim, verifica-se que a pilha de computa√ß√£o √© uma abstra√ß√£o em tempo de execu√ß√£o.  A prop√≥sito, muitas m√°quinas virtuais s√£o baseadas em pilha. <br><br><h3>  # 7  Mais threads - c√≥digo mais r√°pido </h3><br>  Parece intuitivamente que o processamento de dados em paralelo ser√° mais r√°pido do que alternadamente.  Portanto, munidos de conhecimento sobre o trabalho com encadeamentos, muitos tentam paralelizar qualquer ciclo e computa√ß√£o.  Quase todo mundo j√° sabe sobre a sobrecarga, o que contribui para a cria√ß√£o do encadeamento, ent√£o eles usam os encadeamentos do <i>ThreadPool</i> e <i>Task de maneira</i> famosa.  Mas a sobrecarga de cria√ß√£o de um fluxo est√° longe do fim.  Aqui estamos lidando com outra abstra√ß√£o vazada, o mecanismo que o processador usa para melhorar o desempenho - o cache.  E, como costuma acontecer, o cache √© uma l√¢mina de dois gumes.  Por um lado, acelera significativamente o trabalho com acesso seq√ºencial aos dados de um fluxo.  Mas, por outro lado, quando v√°rios threads funcionam, mesmo sem a necessidade de sincroniz√°-los, o cache n√£o apenas ajuda, mas tamb√©m torna o trabalho mais lento.  √â gasto tempo adicional na invalida√ß√£o do cache, ou seja,  manuten√ß√£o de dados relevantes.  E n√£o subestime esse problema, que a princ√≠pio parece um pouco.  Um algoritmo eficiente em cache executar√° um encadeamento mais rapidamente que um algoritmo multithread, no qual o cache √© usado ineficientemente. <br><br>  Tamb√©m tentar trabalhar com uma unidade de v√°rios threads √© suic√≠dio.  O disco j√° √© um fator inibidor em muitos programas que trabalham com ele.  Se voc√™ tentar trabalhar com ele a partir de v√°rios threads, precisar√° esquecer a velocidade. <br><br>  Para todas as defini√ß√µes, recomendo entrar em contato aqui: <br><br>  Especifica√ß√£o da linguagem C # - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ECMA-334</a> <br>  Apenas boas fontes: <br>  Konrad Kokosa - Gerenciamento de mem√≥ria Pro .NET <br>  Especifica√ß√£o CLI - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ECMA-335</a> <br>  Desenvolvedores CoreCLR sobre tempo de execu√ß√£o - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Book Of The Runtime</a> <br>  De Stanislav Sidristy sobre finaliza√ß√£o e muito mais - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">.NET Platform Architecture</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt463213/">https://habr.com/ru/post/pt463213/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt463195/index.html">O que est√° acontecendo com a Internet Tele2</a></li>
<li><a href="../pt463197/index.html">Blazor + MVVM = Silverlight ataca porque o mal antigo √© invenc√≠vel</a></li>
<li><a href="../pt463203/index.html">O pesado fardo do tempo. Relat√≥rio Yandex sobre erros comuns no trabalho com o tempo</a></li>
<li><a href="../pt463205/index.html">Inicialmente inoperante: como sobreviver com um laptop no Windows 10 e uma unidade de 32 gigabytes</a></li>
<li><a href="../pt463207/index.html">Desenvolvimento Chatbot (telegrama + youtube)</a></li>
<li><a href="../pt463215/index.html">Engenheiros e arquitetos j√° est√£o projetando assentamentos lunares</a></li>
<li><a href="../pt463221/index.html">Watching the Sun: 5 tipos de gadgets, de US $ 5 a US $ 5.000</a></li>
<li><a href="../pt463223/index.html">O resumo de materiais interessantes para o desenvolvedor m√≥vel n¬∫ 310 (de 5 a 11 de agosto)</a></li>
<li><a href="../pt463225/index.html">Empresa WiFi. FreeRadius + FreeIPA + Ubiquiti</a></li>
<li><a href="../pt463227/index.html">Solu√ß√£o de problemas com pwnable.kr 19 - desvincular. Estouro de buffer de pilha</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>