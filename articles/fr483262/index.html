<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌈 👉🏾 🙍🏿 Disjoncteur Istio: déconnectez les conteneurs cassés 🈷️ 🐿️ 👶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les vacances sont terminées et nous revenons avec notre deuxième article de la série Istio Service Mesh. 



 Le sujet d'aujourd'hui est Circuit Break...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Disjoncteur Istio: déconnectez les conteneurs cassés</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/483262/">  Les vacances sont terminées et nous revenons avec notre deuxième article de la série Istio Service Mesh. <br><br><img src="https://habrastorage.org/webt/vb/9o/rl/vb9orlnb9lwiilx0aknfy1ikqs0.png" width="100%"><br><br>  Le sujet d'aujourd'hui est Circuit Breaker, qui, traduit en russe par électrotechnique, signifie «disjoncteur», familièrement - «disjoncteur».  Ce n'est qu'à Istio que cette machine déconnecte non pas les circuits court-circuités ou surchargés, mais les conteneurs défectueux. <br><a name="habracut"></a><br><h3>  Comment cela devrait fonctionner idéalement </h3><br>  Lorsque les microservices sont gérés par Kubernetes, par exemple, dans le cadre de la plate-forme OpenShift, ils évoluent automatiquement vers le haut et vers le bas en fonction de la charge.  Étant donné que les microservices fonctionnent dans des modules, il peut y avoir plusieurs instances de microservices conteneurisés à un point de terminaison, et Kubernetes acheminera les demandes et équilibrera la charge entre elles.  Et - idéalement - tout cela devrait fonctionner parfaitement. <br><br>  Nous nous souvenons que les microservices sont petits et éphémères.  L'éphéméralité, qui signifie ici la simplicité d'émergence et de disparition, est souvent sous-estimée.  La naissance et la mort de la prochaine instance de microservice dans pod sont très attendues, OpenShift et Kubernetes le font bien, et tout fonctionne très bien - mais encore une fois en théorie. <br><br><h3>  Comment ça marche vraiment </h3><br>  Imaginons maintenant qu'une instance particulière du microservice, c'est-à-dire le conteneur, soit devenue inutilisable: soit elle ne répond pas (erreur 503) ou, ce qui est plus désagréable, elle réagit, mais trop lentement.  En d'autres termes, il coupe le son ou ne répond pas aux demandes, mais il ne le supprime pas automatiquement du pool.  Que faut-il faire dans ce cas?  Essayez encore?  Le supprimer du schéma de routage?  Et que signifie «trop lent» - combien est-ce en nombre et qui les détermine?  Peut-être juste lui donner une pause et essayer plus tard?  Si oui, combien plus tard? <br><br><h3>  Qu'est-ce que l'éjection de piscine à Istio </h3><br>  Et ici, Istio vient à la rescousse avec ses disjoncteurs, qui éliminent temporairement les conteneurs défectueux du pool de ressources de routage et d'équilibrage de charge, mettant en œuvre la procédure d'éjection du pool. <br><br>  À l'aide d'une stratégie de détection des valeurs aberrantes, Istio détecte les courbes de pod qui sont éliminées de la ligne générale et les supprime du pool de ressources pendant un temps donné, appelé «fenêtre de sommeil». <br><br>  Pour montrer comment cela fonctionne dans Kubernetes sur la plate-forme OpenShift, nous commençons par une capture d'écran des microservices fonctionnant normalement à partir de l'exemple dans le référentiel de <a href="https://github.com/redhat-developer-demos/istio-tutorial">démos de développeurs Red Hat</a> .  Ici, nous avons deux pods, v1 et v2, dans chacun desquels un conteneur fonctionne.  Lorsque les règles de routage d'Istio ne sont pas utilisées, Kubernetes applique par défaut un routage à tour de rôle uniformément équilibré: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bh/b0/dr/bhb0drqlbvo9j0ataogejcgpwue.png"></div><br><h3>  Se préparer pour un crash </h3><br>  Avant de procéder à l'éjection de pool, vous devez créer une règle de routage Istio.  Supposons que nous voulons répartir les demandes entre les pods par rapport à 50/50.  De plus, nous augmenterons le nombre de conteneurs v2 de un à deux, comme ceci: <br><br><pre><code class="plaintext hljs">oc scale deployment recommendation-v2 --replicas=2 -n tutorial</code> </pre> <br>  Nous définissons maintenant une règle de routage pour que le trafic soit réparti entre les pods dans un rapport 50/50. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w2/51/pz/w251pzvoaokm49bpul5ehfwsewm.png"></div><br>  Et voici le résultat de cette règle: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wy/22/ww/wy22wwbkg2vync-id4jbhv22ftk.png"></div><br>  Il est possible de se plaindre que sur cet écran ce n'est pas 50/50, mais 14: 9, mais avec le temps la situation s'améliorera. <br><br><h3>  Nous organisons un échec </h3><br>  Et maintenant, nous allons désactiver l'un des deux conteneurs v2 afin d'avoir un conteneur sain v1, un conteneur sain v2 et un conteneur défectueux v2: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/or/0x/w1/or0xw1jvinlrjkmz3lnttvdh0zo.png"></div><br><h3>  Résoudre le crash </h3><br>  Nous avons donc un conteneur défectueux, et il est temps pour Pool Ejection.  En utilisant une configuration très simple, nous exclurons ce conteneur défaillant de tout schéma de routage pendant 15 secondes dans l'espoir qu'il reviendra à un état sain (soit il redémarrera, soit il restaurera les performances).  Voici à quoi ressemble cette config et les résultats de son travail: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xz/6u/7e/xz6u7emeucpeqn6ozq7rnsibtxy.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yk/m6/3t/ykm63tdppq-qphkyhikilfcwkai.png"></div><br>  Comme vous pouvez le voir, le conteneur défectueux v2 n'est plus utilisé lors du routage des demandes, car il a été supprimé du pool.  Mais après 15 secondes, il retournera automatiquement à la piscine.  En fait, nous venons de montrer comment fonctionne Pool Ejection. <br><br><h3>  Commencez à construire l'architecture </h3><br>  Pool Ejection, combiné aux capacités de surveillance d'Istio, vous permet de commencer à créer un cadre pour remplacer automatiquement les conteneurs défectueux afin de réduire, voire d'éliminer les temps d'arrêt et les plantages. <br><br>  La NASA a une devise de haut niveau - l'échec n'est pas une option, écrit par le directeur de vol <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D0%25B0%25D0%25BD%25D1%2586,_%25D0%2594%25D0%25B6%25D0%25B8%25D0%25BD">Gene Krantz</a> .  Il peut être traduit en russe par «la défaite n'est pas une option», et le fait est que tout peut être fait pour fonctionner avec suffisamment de volonté.  Cependant, dans la vraie vie, les échecs ne se produisent pas simplement, ils sont inévitables, partout et en tout.  Et comment y faire face dans le cas des microservices?  À notre avis, il vaut mieux ne pas compter sur la volonté, mais sur les capacités des conteneurs, <a href="https://developers.redhat.com/topics/kubernetes/">Kubernetes</a> , <a href="https://developers.redhat.com/products/openshift/overview/">Red Hat OpenShift</a> et <a href="https://developers.redhat.com/topics/service-mesh/">Istio</a> . <br><br>  Istio, comme nous l'avons écrit ci-dessus, met en œuvre le concept de disjoncteurs, qui a fait ses preuves dans le monde physique.  Et tout comme une machine automatique déconnecte une partie problématique d'un circuit, le logiciel Circuit Breaker dans Istio déconnecte la connexion entre le flux de demandes et le conteneur de problèmes lorsque quelque chose ne va pas avec le point de terminaison, par exemple, lorsque le serveur tombe en panne ou commence à ralentir. <br><br>  De plus, dans le deuxième cas, il n'y a que plus de problèmes, car les freins d'un conteneur non seulement provoquent une cascade de retards dans les services qui y accèdent et, par conséquent, réduisent les performances du système dans son ensemble, mais provoquent également des demandes répétées au service déjà lent, ce qui ne fait qu'exacerber la situation. . <br><br><h3>  Disjoncteur en théorie </h3><br>  Le disjoncteur est un proxy qui contrôle le flux des demandes vers le point de terminaison.  Lorsque ce point cesse de fonctionner ou, selon les paramètres, il commence à ralentir, le proxy se déconnecte du conteneur.  Le trafic est ensuite redirigé vers d'autres conteneurs, juste à cause de l'équilibrage de charge.  La connexion reste ouverte (ouverte) pendant une fenêtre de sommeil donnée, disons deux minutes, puis est considérée comme semi-ouverte (semi-ouverte).  Tenter d'envoyer la demande suivante détermine l'état de communication supplémentaire.  Si tout va bien avec le service, la connexion revient à l'état opérationnel et se ferme à nouveau.  S'il y a toujours un problème avec le service, la connexion s'ouvre et la fenêtre de veille est réactivée.  Voici à quoi ressemble le diagramme d'état simplifié du disjoncteur: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qg/0g/z4/qg0gz47wjymiayq4bgshfsrceyy.png"></div><br>  Il est important de noter ici que tout cela se passe au niveau, pour ainsi dire, de l'architecture système.  Par conséquent, à un moment donné, vous devrez apprendre à vos applications à travailler avec le disjoncteur, par exemple, fournir une valeur par défaut en réponse ou, si possible, ignorer l'existence du service.  Un modèle de cloison est utilisé pour cela, mais il dépasse le cadre de cet article. <br><br><h3>  Disjoncteur en pratique </h3><br>  Par exemple, nous lancerons sur OpenShift deux versions de notre microservice de recommandations.  La version 1 fonctionnera bien, mais dans la v2, nous intégrerons un délai pour simuler les freins sur le serveur.  Pour afficher les résultats, utilisez l'outil de <a href="https://github.com/JoeDog/siege">siège</a> : <br><br><pre> <code class="plaintext hljs">siege -r 2 -c 20 -v customer-tutorial.$(minishift ip).nip.io</code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kn/qa/e_/knqae_n13cpibc7tc9lk7fc5lqq.png"></div><br>  Tout semble fonctionner, mais à quel prix?  À première vue, nous avons une disponibilité à 100%, mais regardons de plus près - la durée maximale des transactions peut atteindre 12 secondes.  Il s'agit clairement d'un goulot d'étranglement et doit être brodé. <br><br>  Pour ce faire, nous utiliserons Istio pour éliminer l'accès aux conteneurs lents.  Voici à quoi ressemble la configuration correspondante en utilisant le disjoncteur: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/eh/ld/f4/ehldf4gh5qxkwqckn3naufhfs2a.png"></div><br>  La dernière ligne avec le paramètre httpMaxRequestsPerConnection signale que la connexion avec doit s'ouvrir lorsque vous essayez de créer une connexion de plus - la seconde - en plus de la connexion existante.  Étant donné que notre conteneur imite un service de freinage, de telles situations se produisent périodiquement, puis Istio retournera une erreur 503, et voici ce que le siège montrera: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vv/9h/g5/vv9hg56bzoliqjb6tay19as6mn0.png"></div><br><h3>  OK, nous avons un disjoncteur, quelle est la prochaine étape? </h3><br>  Nous avons donc implémenté un arrêt automatique, sans toucher au code source des services eux-mêmes.  En utilisant le disjoncteur et la procédure d'éjection de piscine décrits ci-dessus, nous pouvons retirer les conteneurs de frein du pool de ressources jusqu'à ce qu'ils reviennent à la normale et vérifier leur état à une fréquence donnée - dans notre exemple, cela fait deux minutes (paramètre sleepWindow). <br><br>  Veuillez noter que la capacité de l'application à répondre à l'erreur 503 est toujours définie au niveau de son code source.  Il existe de nombreuses stratégies pour travailler avec un disjoncteur, qui sont appliquées en fonction de la situation. <br><br>  <b>Dans le prochain article: nous</b> parlerons du traçage et de la surveillance, qui sont déjà intégrés ou facilement ajoutés à Istio, ainsi que de la manière d'introduire intentionnellement des erreurs dans le système. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr483262/">https://habr.com/ru/post/fr483262/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr483252/index.html">Maximalisme juvénile et esprit de contradiction chez les adolescents du point de vue de la neurologie</a></li>
<li><a href="../fr483254/index.html">Dans les coulisses de la vie d'un modérateur de débordement de pile</a></li>
<li><a href="../fr483256/index.html">Une compilation de faits statistiques amusants # 3</a></li>
<li><a href="../fr483258/index.html">Les plateformes low-code: une panacée ou un pari risqué?</a></li>
<li><a href="../fr483260/index.html">Comment prendre des décisions et hiérarchiser les tâches lors de la création d'un produit</a></li>
<li><a href="../fr483264/index.html">Dijkstra: La plus grande victoire de l'Occident dans la guerre froide sur l'URSS a été la transition vers IBM - le mythe éclaté</a></li>
<li><a href="../fr483266/index.html">Indépendance financière. Ce qui a changé au cours de l'année</a></li>
<li><a href="../fr483268/index.html">Le livre "Fashion, Faith, Fantasy and the New Physics of the Universe"</a></li>
<li><a href="../fr483270/index.html">L'évolution des applications HighLoad sur l'exemple d'un portail régional de services publics</a></li>
<li><a href="../fr483272/index.html">Le chemin de la restauration à l'entreprise informatique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>