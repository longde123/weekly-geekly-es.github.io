<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ÄºÔ∏è ü§òüèæ üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø S√©rialisation binaire .Net sans r√©f√©rence √† l'assembly avec le type source ou comment n√©gocier avec BinaryFormatter üêÆ üë¥üèæ üêÜ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, je partagerai l'exp√©rience de la s√©rialisation de type binaire entre assemblys, sans r√©f√©rence les uns aux autres. Il s'est av√©r√© qu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>S√©rialisation binaire .Net sans r√©f√©rence √† l'assembly avec le type source ou comment n√©gocier avec BinaryFormatter</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430646/">  Dans cet article, je partagerai l'exp√©rience de la s√©rialisation de type binaire entre assemblys, sans r√©f√©rence les uns aux autres.  Il s'est av√©r√© qu'il existe des cas r√©els et ¬´l√©gitimes¬ª o√π vous devez d√©s√©rialiser des donn√©es sans avoir de lien vers l'assembly o√π elles sont d√©clar√©es.  Dans l'article, je parlerai du sc√©nario dans lequel il a √©t√© n√©cessaire, je d√©crirai la m√©thode de solution, et je parlerai √©galement des erreurs interm√©diaires faites dans le processus de recherche <br><br><h3>  Pr√©sentation  √ânonc√© du probl√®me </h3><br>  Nous coop√©rons avec une grande entreprise travaillant dans le domaine de la g√©ologie.  Historiquement, la soci√©t√© a √©crit des logiciels tr√®s diff√©rents pour travailler avec des donn√©es provenant de diff√©rents types d'√©quipements + analyse de donn√©es + pr√©visions.  H√©las, tous ces logiciels sont loin d'√™tre toujours ¬´amicaux¬ª entre eux, et le plus souvent du tout amicaux.  Afin de consolider en quelque sorte les informations, un portail web est en cours de cr√©ation, o√π diff√©rents programmes t√©l√©chargent leurs donn√©es sous forme de xml.  Et le portail essaie de cr√©er une vue plus-moins-compl√®te.  Une nuance importante: comme les d√©veloppeurs du portail ne sont pas forts dans les domaines de chaque application, chaque √©quipe a fourni un module analyseur / convertisseur de donn√©es de son xml aux structures de donn√©es du portail. <br><a name="habracut"></a><br>  Je travaille dans une √©quipe d√©veloppant l'une des applications et nous avons assez facilement √©crit un m√©canisme d'exportation pour notre partie des donn√©es.  Mais ici, l'analyste commercial a d√©cid√© que le portail central avait besoin de l'un des rapports que notre programme √©tait en train de cr√©er.  C'est l√† que le premier probl√®me est apparu: le rapport est reconstruit √† chaque fois et les r√©sultats ne sont enregistr√©s nulle part. <br>  "Alors enregistrez-le!"  Le lecteur y r√©fl√©chira probablement.  Je le pensais aussi, mais j'ai √©t√© s√©rieusement d√©√ßu de l'exigence que le rapport soit d√©j√† construit pour les donn√©es t√©l√©charg√©es.  Rien √† faire - vous devez transf√©rer la logique. <br><br><h2>  √âtape 0. Refactorisation.  Rien de grave </h2><br>  Il a √©t√© d√©cid√© de s√©parer la logique de construction du rapport (en fait, il s'agit d'une √©tiquette √† 4 colonnes, mais la logique est un wagon et un grand chariot) dans une classe distincte, et d'inclure le fichier avec cette classe par r√©f√©rence dans l'assemblage de l'analyseur.  Par cela, nous: <br><br><ol><li>  √âvitez la copie directe </li><li>  Protection contre les √©carts de version </li></ol><br>  S√©parer la logique en une classe distincte n'est pas une t√¢che difficile.  Mais alors tout n'√©tait pas si rose: l'algorithme √©tait bas√© sur des objets m√©tier, dont le transfert ne correspondait pas √† notre concept.  J'ai d√ª r√©√©crire les m√©thodes pour qu'elles n'acceptent que des types simples et qu'elles fonctionnent.  Ce n'√©tait pas toujours simple et par endroits, il fallait des solutions, dont la beaut√© restait en cause, mais dans l'ensemble, une solution fiable a √©t√© obtenue sans b√©quilles √©videntes. <br><br>  Il y avait un d√©tail qui, comme vous le savez, sert souvent de refuge confortable au diable: nous avons h√©rit√© d'une approche √©trange des g√©n√©rations pr√©c√©dentes de d√©veloppeurs, selon laquelle certaines des donn√©es requises pour cr√©er un rapport sont stock√©es dans la base de donn√©es en tant qu'objets .Net s√©rialis√©s en binaire ( questions "pourquoi?", "kaaak?", etc. h√©las, resteront sans r√©ponse en raison du manque de destinataires).  Et dans la saisie des calculs, nous devons bien s√ªr les d√©s√©rialiser. <br><br>  Ces types, dont il √©tait impossible de se d√©barrasser, nous avons √©galement inclus "par r√©f√©rence", d'autant plus qu'ils n'√©taient pas assez compliqu√©s. <br><br><h3>  √âtape 1. D√©s√©rialisation.  Rappelez-vous le nom complet du type </h3><br>  Apr√®s avoir effectu√© les manipulations ci-dessus et effectu√© un test, j'ai re√ßu de mani√®re inattendue une erreur d'ex√©cution qui <br><blockquote>  [A] Namespace.TypeA ne peut pas √™tre converti en [B] Namespace.TypeA.  Le type A provient de 'Assembley.Application, Version = 1.0.0.0, Culture = neutral, PublicKeyToken = null' dans le contexte 'Default' √† l'emplacement '...'.  Le type B provient de 'Assmbley.Portal, Version = 1.0.0.0, Culture = neutral, PublicKeyToken = null' dans le contexte 'Default' √† l'emplacement ''. </blockquote>  Les tout premiers liens Google m'ont dit que le fait est que BinaryFormatter √©crit non seulement des donn√©es, mais √©galement des informations de type dans le flux de sortie, ce qui est logique.  Et √©tant donn√© que le nom complet du type contient l'assembly dans lequel il est d√©clar√©, l'image de ce que j'ai essay√© de d√©s√©rialiser un type est compl√®tement diff√©rente du point de vue de .Net <br><br>  Apr√®s m'√™tre gratt√© la t√™te, j'ai, en l'occurrence, pris une d√©cision √©vidente mais, h√©las, vicieuse, de remplacer un type sp√©cifique de TypeA pendant <b>la</b> d√©s√©rialisation <b>dynamique</b> .  Tout fonctionnait.  Les r√©sultats du rapport ont converg√© de haut en bas, les tests sur le serveur de build ont r√©ussi.  Avec un sentiment d'accomplissement, nous envoyons la t√¢che aux testeurs. <br><br><h3>  √âtape 2. Le principal.  S√©rialisation entre les assemblages </h3><br>  Le calcul est venu rapidement sous la forme de bogues enregistr√©s par les testeurs, qui ont d√©clar√© que l'analyseur c√¥t√© portail √©tait tomb√© √† l'exception qu'il ne pouvait pas charger l'assembly Assembley.Application (assemblage de notre application).  Premi√®re pens√©e - je n'ai pas nettoy√© les r√©f√©rences.  Mais - non, tout va bien, personne ne se r√©f√®re.  J'essaye de l'ex√©cuter √† nouveau dans le bac √† sable - tout fonctionne.  Je commence √† soup√ßonner une erreur de construction, mais ici une id√©e me vient √† l‚Äôesprit qui ne me pla√Æt pas: je change le chemin de sortie de l‚Äôanalyseur dans un dossier s√©par√©, et non dans le r√©pertoire bin partag√© de l‚Äôapplication.  Et le tour est jou√© - je re√ßois l'exception d√©crite.  L'analyse de Stectrace confirme de vagues suppositions - la d√©s√©rialisation est en baisse. <br><br>  La prise de conscience a √©t√© rapide et douloureuse: le remplacement d'un type sp√©cifique par dynamique n'a rien chang√©, BinaryFormatter a toujours cr√©√© un type √† partir d'un assembly externe, uniquement lorsque l'assembly avec le type √©tait √† proximit√©, que le runtime l'a charg√© naturellement et lorsque l'assembly a disparu - nous obtenons une erreur. <br><br>  Il y avait une raison d'√™tre triste.  Mais googler a donn√© de l'espoir sous la forme de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la classe SerializationBinder</a> .  Il s'est av√©r√© que cela vous permet de d√©terminer le type de d√©s√©rialisation de nos donn√©es.  Pour ce faire, cr√©ez un h√©ritier et d√©finissez-y la m√©thode suivante. <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> Type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BindToType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">String assemblyName, String typeName</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br>  dans lequel vous pouvez retourner n'importe quel type pour des conditions donn√©es. <br>  La classe BinaryFormatter a une propri√©t√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Binder</a> o√π vous pouvez injecter votre impl√©mentation. <br><br>  Il semblerait qu'il n'y ait pas de probl√®me.  Mais encore une fois, les d√©tails restent (voir ci-dessus). <br><br>  Tout d'abord, vous devez traiter les demandes pour <b>tous les</b> types (et standard √©galement). <br><blockquote>  Une option d'impl√©mentation int√©ressante a √©t√© trouv√©e sur Internet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , mais ils essaient d'utiliser le classeur par d√©faut de BinaryFormatter, sous la forme d'une construction <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> defaultBinder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryFormatter().Binder</code> </pre> <br>  Mais en fait, la propri√©t√© Binder est nulle par d√©faut.  Une analyse du code source a montr√© qu'√† l'int√©rieur du BinaryFormatter, si Binder est v√©rifi√©, si c'est le cas, ses m√©thodes sont appel√©es, sinon, une logique interne est utilis√©e, ce qui se r√©sume finalement √† <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> assembly = Assembly.Load(assemblyName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FormatterServices.GetTypeFromAssembly(assembly, typeName);</code> </pre><br></blockquote>  Sans plus tarder, j'ai r√©p√©t√© la m√™me logique en moi. <br><br>  Voici ce qui s'est pass√© dans la premi√®re impl√©mentation <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyBinder</span></span> : <span class="hljs-title"><span class="hljs-title">SerializationBinder</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> Type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BindToType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> assemblyName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> typeName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (assemblyName.Contains(<span class="hljs-string"><span class="hljs-string">"&lt;ObligatoryPartOfNamespace&gt;"</span></span>) ) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bindToType = Type.GetType(typeName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bindToType; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bindToType = LoadTypeFromAssembly(assemblyName, typeName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bindToType; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadTypeFromAssembly</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> assemblyName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> typeName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(assemblyName) || <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(typeName)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> assembly = Assembly.Load(assemblyName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FormatterServices.GetTypeFromAssembly(assembly, typeName); } }</code> </pre><br>  C'est-√†-dire  on v√©rifie si l'espace de noms appartient au projet - on retourne le type du domaine courant, si le type de syst√®me - on charge depuis l'assembly correspondant <br><br>  Cela semble logique.  Nous commen√ßons les tests: notre type vient - nous rempla√ßons, il est cr√©√©.  Hourra!  La cha√Æne vient - nous suivons la branche avec le chargement de l'assemblage.  √áa marche!  Champagne virtuel ouvert ... <br><br>  Mais ici ... Un dictionnaire est livr√© avec des √©l√©ments de types d'utilisateurs: puisqu'il s'agit d'un type de syst√®me, alors ... √©videmment, nous essayons de le charger √† partir de l'assemblage, mais puisque les √©l√©ments qu'il contient sont nos types, d'ailleurs, avec une qualification compl√®te (assemblage, version, cl√© ), puis nous retombons.  (il devrait y avoir un sourire triste). <br><br>  De toute √©vidence, vous devez modifier le nom d'entr√©e du type, en rempla√ßant les liens vers l'assemblage souhait√©.  J'esp√©rais vraiment que pour le nom du type, il y avait un analogue de la classe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AssemblyName</a> , mais je n'ai rien trouv√© de similaire.  √âcrire un analyseur universel avec remplacement n'est pas une t√¢che facile.  Apr√®s une s√©rie d'exp√©riences, je suis parvenu √† la solution suivante: dans le constructeur statique, je soustrais les types √† remplacer, puis je cherche leurs noms dans la ligne avec le nom du type cr√©√©, et quand je le trouve, je remplace le nom de l'assembly <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> The types that may be changed to local </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> protected static IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type&gt;</span></span></span><span class="hljs-comment"> _changedTypes; static MyBinder() { var executingAssembly = Assembly.GetCallingAssembly(); var name = executingAssembly.GetName().Name; _changedTypes = executingAssembly.GetTypes().Where(t =&gt; t.Namespace != null &amp;&amp; !t.Namespace.Contains(name) &amp;&amp; !t.Name.StartsWith("</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;")); //!t.Namespace.Contains(name) - .     ,         // "&lt;'      -     } private static string CorrectTypeName(string name) { foreach (var changedType in _changedTypes) { var ind = name.IndexOf(changedType.FullName); if (ind != -1) { var endIndex = name.IndexOf("PublicKeyToken", ind) ; if (endIndex != -1) { endIndex += +"PublicKeyToken".Length + 1; while (char.IsLetterOrDigit(name[endIndex++])) { } var sb = new StringBuilder(); sb.Append(name.Substring(0, ind)); sb.Append(changedType.AssemblyQualifiedName); sb.Append(name.Substring(endIndex-1)); name = sb.ToString(); } } } return name; } /// &lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> look up the type locally if the assembly-name is "NA" </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="assemblyName"&gt;</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="typeName"&gt;</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> public override Type BindToType(string assemblyName, string typeName) { typeName = CorrectTypeName(typeName); if (assemblyName.Contains("</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;ObligatoryPartOfNamespace&gt;</span></span></span><span class="hljs-comment">") || assemblyName.Equals("NA")) { var bindToType = Type.GetType(typeName); return bindToType; } else { var bindToType = LoadTypeFromAssembly(assemblyName, typeName); return bindToType; } }</span></span></code> </pre><br>  Comme vous pouvez le voir, je suis parti du fait que PublicKeyToken est le dernier dans la description du type.  Ce n'est peut-√™tre pas fiable √† 100%, mais dans mes tests, je n'ai pas trouv√© de cas o√π ce n'est pas le cas. <br><br>  Ainsi, une ligne du formulaire <br><blockquote>  "System.Collections.Generic.Dictionary`2 [[SomeNamespace.CustomType, Assembley.Application, Version = 1.0.0.0, Culture = neutral, PublicKeyToken = null], [System.Byte [], mscorlib, Version = 4.0.0.0, Culture = neutre, PublicKeyToken = b77a5c561934e089]] ¬ª </blockquote><br>  se transforme en <br><blockquote>  "System.Collections.Generic.Dictionary`2 [[SomeNamespace.CustomType, Assembley.Portal, Version = 1.0.0.0, Culture = neutral, PublicKeyToken = null], [System.Byte [], mscorlib, Version = 4.0.0.0, Culture = neutre, PublicKeyToken = b77a5c561934e089]] ¬ª </blockquote><br>  Maintenant, tout fonctionnait enfin "comme une horloge".  Il y avait des subtilit√©s techniques mineures: si vous vous en souvenez, les fichiers que nous avons inclus √©taient inclus dans le lien de l'application principale.  Mais dans l'application principale, toutes ces danses ne sont pas n√©cessaires.  Par cons√©quent, un m√©canisme de compilation conditionnelle du formulaire <br><br><pre> <code class="cs hljs">BinaryFormatter binForm = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryFormatter(); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> EXTERNAL_LIB binForm.Binder = new MyBinder(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  En cons√©quence, dans l'assemblage de portail, nous d√©finissons la macro EXTERNAL_LIB, mais dans l'application principale - non <br><blockquote><h4>  "Digression non lyrique" </h4><br>  En fait, dans le processus de codage, afin de v√©rifier rapidement la solution, j'ai fait une erreur de calcul, qui m'a probablement co√ªt√© un certain nombre de cellules nerveuses: pour commencer, je viens de coder en dur la substitution de type pour Dicitionary.  En cons√©quence, apr√®s la d√©s√©rialisation, il s'est av√©r√© √™tre un dictionnaire vide, qui s'est √©galement ¬´√©cras√©¬ª lors de la tentative d'ex√©cution de certaines op√©rations avec lui.  Je commen√ßais d√©j√† √† penser que vous <i>ne pouviez pas tromper BinaryFormatter</i> , et j'ai commenc√© des exp√©riences d√©sesp√©r√©es avec une tentative d'√©crire l'h√©ritier du Dictionnaire.  Heureusement, je me suis arr√™t√© presque √† temps et suis retourn√© √† l'√©criture d'un m√©canisme de substitution universel et, le mettant en ≈ìuvre, j'ai r√©alis√© que pour cr√©er un dictionnaire, il ne suffit pas de red√©finir son type: vous devez toujours prendre soin des types de KeyValuePair &lt;TKey, TValue&gt;, Comparer, qui sont √©galement demand√©s √† Liant <br><br><br>  Ce sont les aventures de s√©rialisation binaire.  Je serais reconnaissant pour la r√©troaction. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430646/">https://habr.com/ru/post/fr430646/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430634/index.html">Cr√©ation d'un module logiciel pour le programmateur XELTEK SuperPro 6100</a></li>
<li><a href="../fr430636/index.html">Cervelet et noyaux basaux au lieu de la boule de cristal: comment le cerveau pr√©dit l'avenir</a></li>
<li><a href="../fr430640/index.html">Mer Rouge: pourquoi les actions d'Apple et d'autres soci√©t√©s technologiques baissent</a></li>
<li><a href="../fr430642/index.html">Direction "Photonique" aux JO "Je suis un professionnel", ou comment s'inscrire dans une magistrature sans examens</a></li>
<li><a href="../fr430644/index.html">Une nouvelle vuln√©rabilit√© dans Facebook entra√Æne la fuite des donn√©es personnelles des utilisateurs</a></li>
<li><a href="../fr430648/index.html">Histoire de Pac-Man</a></li>
<li><a href="../fr430650/index.html">Sex est un vendeur de jeux d'arcade classiques. Et qui est l'acheteur?</a></li>
<li><a href="../fr430654/index.html">Devleads Meetup: nous r√©unissons une √©quipe efficace, optimisons le d√©veloppement, discutons des probl√®mes actuels</a></li>
<li><a href="../fr430656/index.html">Programme SAFe¬Æ certifi√©</a></li>
<li><a href="../fr430658/index.html">Comment √ßa a commenc√© - La naissance des jeux vid√©o</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>