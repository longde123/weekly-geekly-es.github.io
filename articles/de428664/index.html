<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ò¶Ô∏è üö´ üåÖ Linux-Kernel-Boot. Teil 1 üë©üèª‚Äçüç≥ üçä üå≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vom Bootloader zum Kernel 

 Wenn Sie die vorherigen Artikel lesen, kennen Sie mein neues Hobby f√ºr Low-Level-Programmierung. Ich schrieb mehrere Arti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Linux-Kernel-Boot. Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428664/"> <b>Vom Bootloader zum Kernel</b> <br><br>  Wenn Sie die vorherigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> lesen, kennen Sie mein neues Hobby f√ºr Low-Level-Programmierung.  Ich schrieb mehrere Artikel √ºber Assembler-Programmierung f√ºr <code>x86_64</code> Linux und begann gleichzeitig, in den Quellcode des Linux-Kernels einzutauchen. <br><br>  Ich bin sehr daran interessiert zu verstehen, wie Dinge auf niedriger Ebene funktionieren: wie Programme auf meinem Computer ausgef√ºhrt werden, wie sie sich im Speicher befinden, wie der Kernel Prozesse und Speicher verwaltet, wie der Netzwerkstapel auf niedriger Ebene funktioniert und vieles mehr.  Deshalb habe ich beschlossen, eine weitere Artikelserie √ºber den Linux-Kernel f√ºr die <b>x86_64-Architektur</b> zu schreiben. <br><br>  Bitte beachten Sie, dass ich kein professioneller Kernel-Entwickler bin und bei der Arbeit keinen Kernel-Code schreibe.  Dies ist nur ein Hobby.  Ich mag nur Dinge auf niedriger Ebene und es ist interessant, mich mit ihnen zu besch√§ftigen.  Wenn Sie also Verwirrung oder Fragen / Kommentare bemerken, kontaktieren Sie mich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf Twitter</a> , per <a href="">E-Mail</a> oder erstellen Sie einfach ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ticket</a> .  Ich w√§re dankbar. <br><a name="habracut"></a><br>  Alle Artikel werden im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub-Repository</a> ver√∂ffentlicht. Wenn etwas mit meinem Englisch oder dem Inhalt des Artikels nicht stimmt, z√∂gern Sie nicht, eine Pull-Anfrage zu senden. <br><br>  <i>Bitte beachten Sie, dass dies keine offizielle Dokumentation ist, sondern lediglich Schulung und Wissensaustausch.</i> <br><br>  <b>Erforderliche Kenntnisse</b> <br><br><ul><li>  C-Code verstehen </li><li>  Grundlegendes zum Assembler-Code (AT &amp; T-Syntax) </li></ul><br>  In jedem Fall werde ich versuchen, in diesem und den folgenden Artikeln etwas zu erkl√§ren, wenn Sie gerade erst anfangen, solche Werkzeuge zu lernen.  Okay, wenn die Einf√ºhrung abgeschlossen ist, ist es Zeit, sich mit dem Linux-Kernel und den Dingen auf niedriger Ebene zu besch√§ftigen. <br><br>  Ich habe in den Tagen des Linux 3.18-Kernels angefangen, dieses Buch zu schreiben, und seitdem hat sich viel ge√§ndert.  Bei √Ñnderungen werde ich die Artikel entsprechend aktualisieren. <br><br><h1>  Magischer Netzschalter, wie geht es weiter? </h1><br>  Obwohl dies Artikel √ºber den Linux-Kernel sind, haben wir ihn - zumindest in diesem Abschnitt - noch nicht erreicht.  Sobald Sie den magischen Netzschalter auf Ihrem Laptop oder Desktop-Computer dr√ºcken, funktioniert es.  Das Motherboard sendet ein Signal an die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stromversorgung</a> .  Nach dem Empfang des Signals versorgt es den Computer mit der erforderlichen Strommenge.  Sobald das Motherboard ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Power OK" -Signal</a> empf√§ngt, versucht es, die CPU zu starten.  Er speichert alle verbleibenden Daten in seinen Registern und legt f√ºr jeden von ihnen vordefinierte Werte fest. <br><br>  Prozessoren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">80386</a> und sp√§tere Versionen sollten nach einem Neustart die folgenden Werte in den CPU-Registern haben: <br><br><pre>  IP 0xfff0
 CS-Selektor 0xf000
 CS-Basis 0xffff0000 </pre><br>  Der Prozessor beginnt im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Real-Modus zu arbeiten</a> .  Gehen wir etwas zur√ºck und versuchen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Speichersegmentierung</a> in diesem Modus zu verstehen.  Der Real-Modus wird von allen x86-kompatiblen Prozessoren unterst√ºtzt: von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8086</a> bis zu modernen 64-Bit-Intel-Prozessoren.  Der 8086-Prozessor verwendet einen 20-Bit-Adressbus, <code>0-0xFFFFF</code> er kann mit einem Adressraum von <code>0-0xFFFFF</code> oder <code>1 </code> .  Es gibt jedoch nur 16-Bit-Register mit einer maximalen Adresse von <code>2^16-1</code> oder <code>0xffff</code> (64 Kilobyte). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eine Speichersegmentierung ist</a> erforderlich, um den gesamten verf√ºgbaren Adressraum zu nutzen.  Der gesamte Speicher ist in kleine Segmente mit einer festen Gr√∂√üe von <code>65536</code> Byte (64 KB) unterteilt.  Da wir mit 16-Bit-Registern nicht auf Speicher √ºber 64 KB zugreifen k√∂nnen, wurde eine alternative Methode entwickelt. <br><br>  Die Adresse besteht aus zwei Teilen: 1) einem Segmentw√§hler mit einer Basisadresse;  2) Versatz von der Basisadresse.  Im Real-Modus ist die Basisadresse des Segmentw√§hlers <code>  * 16</code> .  Um die physikalische Adresse im Speicher zu erhalten, m√ºssen Sie einen Teil des Segmentw√§hlers mit 16 multiplizieren und den Offset hinzuf√ºgen: <br><br><pre> <code class="hljs">  =   * 16 + </code> </pre> <br>  Wenn das <code>CS:IP</code> Register beispielsweise den Wert <code>0x2000:0x0010</code> , <code>0x2000:0x0010</code> die entsprechende physikalische Adresse wie folgt: <br><br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>&gt; hex((<span class="hljs-number"><span class="hljs-number">0x2000</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) + <span class="hljs-number"><span class="hljs-number">0x0010</span></span>) <span class="hljs-string"><span class="hljs-string">'0x20010'</span></span></code> </pre> <br>  Wenn Sie jedoch den Selektor des gr√∂√üten Segments und den Offset <code>0xffff:0xffff</code> , erhalten Sie die Adresse: <br><br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>&gt; hex((<span class="hljs-number"><span class="hljs-number">0xffff</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) + <span class="hljs-number"><span class="hljs-number">0xffff</span></span>) <span class="hljs-string"><span class="hljs-string">'0x10ffef'</span></span></code> </pre> <br>  das sind <code>65520</code> Bytes nach dem ersten Megabyte.  Da im Real-Modus nur ein Megabyte verf√ºgbar ist, wird <code>0x00ffef</code> bei deaktivierter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">A20-Leitung</a> zu <code>0x00ffef</code> . <br><br>  Nun wissen wir etwas √ºber den Real-Modus und die Speicheradressierung in diesem Modus.  Kehren wir zur Diskussion der Registerwerte nach dem Zur√ºcksetzen zur√ºck. <br><br>  Das <code>CS</code> Register besteht aus zwei Teilen: einem sichtbaren Segmentw√§hler und einer versteckten Basisadresse.  Obwohl die Basisadresse normalerweise durch Multiplizieren des Werts des Segmentw√§hlers mit 16 gebildet wird, ist w√§hrend eines Hardware-Resets der Segmentw√§hler im CS-Register <code>0xf000</code> und die Basisadresse <code>0xffff0000</code> .  Der Prozessor verwendet diese spezielle Basisadresse, bis sich die CS √§ndert. <br><br>  Die Startadresse wird durch Hinzuf√ºgen der Basisadresse zum Wert im EIP-Register gebildet: <br><br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>&gt; <span class="hljs-number"><span class="hljs-number">0xffff0000</span></span> + <span class="hljs-number"><span class="hljs-number">0xfff0</span></span> <span class="hljs-string"><span class="hljs-string">'0xfffffff0'</span></span></code> </pre> <br>  Wir erhalten <code>0xfffffff0</code> , was 16 Bytes unter 4 GB liegt.  Dieser Punkt wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">R√ºcksetzvektor bezeichnet</a> .  Dies ist die Stelle im Speicher, an der die CPU nach einem Zur√ºcksetzen auf die Ausf√ºhrung des ersten Befehls wartet: eine Sprungoperation ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jmp</a> ), die normalerweise den BIOS-Einstiegspunkt angibt.  Wenn Sie sich beispielsweise den Quellcode von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">coreboot</a> ( <code>src/cpu/x86/16bit/reset16.inc</code> ) <code>src/cpu/x86/16bit/reset16.inc</code> , werden wir sehen: <br><br><pre> <code class="hljs css"> <span class="hljs-selector-class"><span class="hljs-selector-class">.section</span></span> "<span class="hljs-selector-class"><span class="hljs-selector-class">.reset</span></span>", "<span class="hljs-selector-tag"><span class="hljs-selector-tag">ax</span></span>", %<span class="hljs-selector-tag"><span class="hljs-selector-tag">progbits</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.code16</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.globl</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">start</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">start</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.byte</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">xe9</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.int</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">start16bit</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> ( . + 2 ) ...</code> </pre> <br>  Hier sehen wir den Operationscode ( <code>jmp</code> ) <code>jmp</code> , n√§mlich <code>0xe9</code> , und die Zieladresse <code>_start16bit - ( . + 2)</code> . <br><br>  Wir sehen auch, dass der <code>reset</code> Abschnitt 16 Bytes umfasst und kompiliert wird, um von der Adresse <code>0xfffff0</code> ( <code>src/cpu/x86/16bit/reset16.ld</code> ) ausgef√ºhrt zu werden: <br><br><pre> <code class="hljs pgsql">SECTIONS { <span class="hljs-comment"><span class="hljs-comment">/* Trigger an error if I have an unuseable start address */</span></span> _bogus = <span class="hljs-keyword"><span class="hljs-keyword">ASSERT</span></span>(_start16bit &gt;= <span class="hljs-number"><span class="hljs-number">0xffff0000</span></span>, "_start16bit too low. Please report."); _ROMTOP = <span class="hljs-number"><span class="hljs-number">0xfffffff0</span></span>; . = _ROMTOP; .<span class="hljs-keyword"><span class="hljs-keyword">reset</span></span> . : { *(.<span class="hljs-keyword"><span class="hljs-keyword">reset</span></span>); . = <span class="hljs-number"><span class="hljs-number">15</span></span>; BYTE(<span class="hljs-number"><span class="hljs-number">0x00</span></span>); } }</code> </pre> <br>  Das BIOS wird jetzt gestartet.  Nach dem Initialisieren und √úberpr√ºfen der BIOS-Hardware m√ºssen Sie das Startger√§t finden.  Die Startreihenfolge wird in der BIOS-Konfiguration gespeichert.  Beim Versuch, von der Festplatte zu booten, versucht das BIOS, den Bootsektor zu finden.  Auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MBR-partitionierten</a> Festplatten wird der Startsektor in den ersten 446 Bytes des ersten Sektors gespeichert, wobei jeder Sektor 512 Bytes umfasst.  Die letzten beiden Bytes des ersten Sektors sind <code>0x55</code> und <code>0xaa</code> .  Sie zeigen dem BIOS, dass es sich um ein Startger√§t handelt. <br><br>  Zum Beispiel: <br><br><pre> <code class="hljs powershell">; ; :       Intel x86 ; [<span class="hljs-type"><span class="hljs-type">BITS</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>] boot: mov al, <span class="hljs-string"><span class="hljs-string">'!'</span></span> mov ah, <span class="hljs-number"><span class="hljs-number">0</span></span>x0e mov bh, <span class="hljs-number"><span class="hljs-number">0</span></span>x00 mov bl, <span class="hljs-number"><span class="hljs-number">0</span></span>x07 int <span class="hljs-number"><span class="hljs-number">0</span></span>x10 jmp <span class="hljs-variable"><span class="hljs-variable">$</span></span> times <span class="hljs-number"><span class="hljs-number">510</span></span>-(<span class="hljs-variable"><span class="hljs-variable">$</span></span>-<span class="hljs-variable"><span class="hljs-variable">$</span></span><span class="hljs-variable"><span class="hljs-variable">$</span></span>) db <span class="hljs-number"><span class="hljs-number">0</span></span> db <span class="hljs-number"><span class="hljs-number">0</span></span>x55 db <span class="hljs-number"><span class="hljs-number">0</span></span>xaa</code> </pre> <br>  Wir sammeln und betreiben: <br><br> <code>nasm -f bin boot.nasm &amp;&amp; qemu-system-x86_64 boot</code> <br> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">QEMU</a> erh√§lt den Befehl, die soeben erstellte <code>boot</code> Bin√§rdatei als Disk-Image zu verwenden.  Da die oben generierte Bin√§rdatei die Anforderungen des Bootsektors erf√ºllt (beginnend bei <code>0x7c00</code> und endend mit einer magischen Sequenz), betrachtet QEMU die Bin√§rdatei als Master Boot Record (MBR) des Disk-Images. <br><br>  Sie werden sehen: <br><br><img src="https://habrastorage.org/webt/e1/rk/nw/e1rknwgwcuouazuhzrmco1b8szg.png"><br><br>  In diesem Beispiel sehen wir, dass der Code im 16-Bit-Real-Modus ausgef√ºhrt wird und an der Adresse <code>0x7c00</code> im Speicher beginnt.  Nach dem Start wird ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">0x10-</a> Interrupt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ausgel√∂st</a> , der einfach ein Zeichen druckt <code>!</code>  ;;  F√ºllt die verbleibenden 510 Bytes mit Nullen und endet mit zwei magischen Bytes <code>0xaa</code> und <code>0x55</code> . <br><br>  Sie k√∂nnen den bin√§ren Speicherauszug mit dem Dienstprogramm <code>objdump</code> anzeigen: <br><br> <code>nasm -f bin boot.nasm <br> objdump -D -b binary -mi386 -Maddr16,data16,intel boot</code> <br> <br>  Nat√ºrlich gibt es im realen Bootsektor Code, um den Bootvorgang fortzusetzen, und eine Partitionstabelle anstelle einer Reihe von Nullen und einem Ausrufezeichen :).  Ab diesem Moment √ºbertr√§gt das BIOS die Kontrolle an den Bootloader. <br><br>  <i>Hinweis</i> : Wie oben erl√§utert, befindet sich die CPU im Real-Modus.  wobei die Berechnung der physikalischen Adresse im Speicher wie folgt ist: <br><br><pre> <code class="hljs">  =   * 16 + </code> </pre> <br>  Wir haben nur 16-Bit-Allzweckregister, und der Maximalwert des 16-Bit-Registers ist <code>0xffff</code> . Bei den gr√∂√üten Werten ist das Ergebnis also: <br><br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>&gt; hex((<span class="hljs-number"><span class="hljs-number">0xffff</span></span> * <span class="hljs-number"><span class="hljs-number">16</span></span>) + <span class="hljs-number"><span class="hljs-number">0xffff</span></span>) <span class="hljs-string"><span class="hljs-string">'0x10ffef'</span></span></code> </pre> <br>  Dabei ist <code>0x10ffef</code> <code>1  + 64  - 16 </code> .  Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8086-Prozessor</a> (der erste Prozessor mit Real-Modus) verf√ºgt √ºber eine 20-Bit-Adressleitung.  Da <code>2^20 = 1048576</code> , betr√§gt der tats√§chlich verf√ºgbare Speicher 1 MB. <br><br>  Im Allgemeinen lautet die Speicheradressierung im Real-Modus wie folgt: <br><br><pre>  0x00000000 - 0x000003FF - Tabelle der Interruptvektoren des Realmodus
 0x00000400 - 0x000004FF - BIOS-Datenbereich
 0x00000500 - 0x00007BFF - wird nicht verwendet
 0x00007C00 - 0x00007DFF - unser Bootloader
 0x00007E00 - 0x0009FFFF - wird nicht verwendet
 0x000A0000 - 0x000BFFFF - Video-RAM (VRAM) 
 0x000B0000 - 0x000B7777 - monochromer Videospeicher
 0x000B8000 - 0x000BFFFF - Videospeicher im Farbmodus
 0x000C0000 - 0x000C7FFF - Video-ROM-BIOS
 0x000C8000 - 0x000EFFFF - Schattenbereich (BIOS Shadow)
 0x000F0000 - 0x000FFFFF - System-BIOS </pre><br>  Am Anfang des Artikels steht, dass sich der erste Befehl f√ºr den Prozessor bei <code>0xFFFFFFF0</code> , was viel mehr als <code>0xFFFFF</code> (1 MB) ist.  Wie kann die CPU im Real-Modus auf diese Adresse zugreifen?  Antwort in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Coreboot-</a> Dokumentation: <br><br> <code>0xFFFE_0000 - 0xFFFF_FFFF: 128  ROM    </code> <br> <br>  Zu Beginn der Ausf√ºhrung befindet sich das BIOS nicht im RAM, sondern im ROM. <br><br><h1>  Bootloader </h1><br>  Der Linux-Kernel kann mit verschiedenen Bootloadern wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GRUB 2</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Syslinux geladen werden</a> .  Der Kernel verf√ºgt √ºber ein Boot-Protokoll, das die Bootloader-Anforderungen f√ºr die Implementierung der Linux-Unterst√ºtzung definiert.  In diesem Beispiel arbeiten wir mit GRUB 2. <br><br>  Das BIOS setzte den Startvorgang fort, w√§hlte das Startger√§t aus und √ºbertrug die Kontrolle auf den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Startsektor</a> . Die Ausf√ºhrung beginnt mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">boot.img</a> .  Aufgrund seiner begrenzten Gr√∂√üe ist dies ein sehr einfacher Code.  Es enth√§lt einen Zeiger, um zum Haupt-GRUB 2-Image zu gelangen. Es beginnt mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diskboot.img</a> und wird normalerweise unmittelbar nach dem ersten Sektor in nicht verwendetem Speicherplatz vor der ersten Partition gespeichert.  Der obige Code l√§dt den Rest des Images in den Speicher, der den GRUB 2-Kernel und Treiber f√ºr die Verarbeitung von Dateisystemen enth√§lt.  Danach wird die Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">grub_main ausgef√ºhrt</a> . <br><br>  Die Funktion <code>grub_main</code> initialisiert die Konsole, gibt die Basisadresse f√ºr die Module zur√ºck, legt das Root-Ger√§t fest, l√§dt / analysiert die Grub-Konfigurationsdatei, l√§dt die Module usw.  Am Ende der Ausf√ºhrung wird grub in den normalen Modus versetzt.  Die Funktion <code>grub_normal_execute</code> (aus der <code>grub_normal_execute</code> <code>grub-core/normal/main.c</code> ) schlie√üt die letzten Vorbereitungen ab und zeigt ein Men√º zur Auswahl des Betriebssystems an.  Wenn wir einen der Grub-Men√ºpunkte ausw√§hlen, wird die Funktion <code>grub_menu_execute_entry</code> , die den Befehl grub <code>boot</code> ausf√ºhrt und das ausgew√§hlte Betriebssystem l√§dt. <br><br>  Wie im Kernel-Boot-Protokoll angegeben, muss der Bootloader einige Felder des Kernel-Installations-Headers lesen und ausf√ºllen, der mit dem Offset <code>0x01f1</code> vom Kernel-Installationscode beginnt.  Dieser Offset wird im <a href="">Linker-Skript angegeben</a> .  Der Kernel-Header <a href="">arch / x86 / boot / header.S</a> beginnt mit: <br><br><pre> <code class="hljs css"> <span class="hljs-selector-class"><span class="hljs-selector-class">.globl</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hdr</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hdr</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">setup_sects</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.byte</span></span> 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">root_flags</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ROOT_RDONLY</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">syssize</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.long</span></span> 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">ram_size</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">vid_mode</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SVGA_MODE</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">root_dev</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">boot_flag</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">xAA55</span></span></code> </pre> <br>  Der Bootloader sollte diesen und andere Header (die im Linux-Bootprotokoll wie in diesem Beispiel nur als Typ <code>write</code> gekennzeichnet sind) mit Werten f√ºllen, die von der Befehlszeile empfangen oder beim Boot berechnet werden.  Jetzt werden wir nicht auf die Beschreibungen und Erkl√§rungen f√ºr alle Headerfelder eingehen.  Wir werden sp√§ter diskutieren, wie der Kernel sie verwendet.  Eine Beschreibung aller Felder finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Download-Protokoll</a> . <br><br>  Wie Sie im Kernel-Boot-Protokoll sehen k√∂nnen, wird der Speicher wie folgt angezeigt: <br><br><pre>  |  Gesch√ºtzter Kernel-Modus |
 100000 + ------------------------ +
          |  E / A-Zuordnung |
 0A0000 + ------------------------ +
          |  Reserve  f√ºr BIOS |  Lass so viel wie m√∂glich frei
          ~ ~
          |  Befehlszeile |  (kann auch unter X + 10000 liegen)
 X + 10000 + ------------------------ +
          |  Stapel / Haufen |  Um echten Kernel-Modus-Code zu verwenden
 X + 08000 + ------------------------ +
          |  Kernel-Installation |  Kernel Real Mode Code
          |  Kernel Boot Sektor |  Legacy-Kernel-Bootsektor
        X + ------------------------ +
          |  Lader |  &lt;- Einstiegspunkt 0x7C00 Bootsektor
 001000 + ------------------------ +
          |  Reserve  f√ºr MBR / BIOS |
 000800 + ------------------------ +
          |  Normalerweise verwenden  MBR |
 000600 + ------------------------ +
          |  Gebraucht  Nur BIOS |
 000000 + ------------------------ +
</pre><br>  Wenn der Loader die Kontrolle an den Kernel √ºbertr√§gt, beginnt er mit der Adresse: <br><br><pre> <code class="hljs lisp">X + sizeof (<span class="hljs-name"><span class="hljs-name">KernelBootSector</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Dabei ist <code>X</code> die Adresse des Kernel-Bootsektors.  In unserem Fall ist <code>X</code> <code>0x10000</code> , wie im Speicherauszug zu sehen ist: <br><br><img src="https://habrastorage.org/webt/ot/1u/ep/ot1uepwbgvghzktwcbwwskwwjbs.png"><br><br>  Der Bootloader hat den Linux-Kernel in den Speicher verschoben, die Header-Felder ausgef√ºllt und dann an die entsprechende Speicheradresse verschoben.  Jetzt k√∂nnen wir direkt zum Kernel-Installationscode gehen. <br><br><h1>  Beginn der Kernel-Installationsphase </h1><br>  Endlich sind wir im Kern!  Obwohl technisch l√§uft es noch nicht.  Zun√§chst muss der Kernel-Installationsteil etwas konfigurieren, einschlie√ülich eines Dekomprimierers und einiger Dinge mit Speicherverwaltung.  Nach all dem wird sie den wahren Kern auspacken und dorthin gehen.  Die Installation beginnt in <a href="">arch / x86 / boot / header.S</a> mit dem Zeichen <a href="">_start</a> . <br><br>  Auf den ersten Blick mag dies etwas seltsam erscheinen, da mehrere Anweisungen vor ihm liegen.  Vor langer Zeit hatte der Linux-Kernel einen eigenen Bootloader.  Wenn Sie jetzt zum Beispiel ausf√ºhren, <br><br> <code>qemu-system-x86_64 vmlinuz-3.18-generic</code> <br> <br>  Sie werden sehen: <br><br><img src="https://habrastorage.org/webt/4r/5f/xg/4r5fxgpwl4l2vwlw9muscl3ygie.png"><br><br>  Tats√§chlich beginnt die Datei <code>header.S</code> mit der magischen Nummer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MZ</a> (siehe Screenshot des Dumps oben), dem Text der Fehlermeldung und dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PE-</a> Header: <br><br><pre> <code class="hljs css"><span class="hljs-selector-id"><span class="hljs-selector-id">#ifdef</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">CONFIG_EFI_STUB</span></span> # "<span class="hljs-selector-tag"><span class="hljs-selector-tag">MZ</span></span>", <span class="hljs-selector-tag"><span class="hljs-selector-tag">MS-DOS</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">header</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.byte</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x4d</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.byte</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x5a</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#endif</span></span> ... ... ... <span class="hljs-selector-tag"><span class="hljs-selector-tag">pe_header</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.ascii</span></span> "<span class="hljs-selector-tag"><span class="hljs-selector-tag">PE</span></span>" <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> 0</code> </pre> <br>  Es wird ben√∂tigt, um ein Betriebssystem mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UEFI-</a> Unterst√ºtzung zu laden.  Wir werden das Ger√§t in den folgenden Kapiteln betrachten. <br><br>  Tats√§chlicher Einstiegspunkt f√ºr die Installation des Kernels: <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// header.S line 292 .globl _start _start:</span></span></code> </pre> <br>  Der Bootloader (grub2 und andere) kennt diesen Punkt (Offset <code>0x200</code> von <code>MZ</code> ) und geht direkt zu diesem Punkt, obwohl <code>header.S</code> vom Abschnitt <code>.bstext</code> , in dem sich der Text der Fehlermeldung befindet: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ arch/x</span></span>86/boot/setup.ld /<span class="hljs-regexp"><span class="hljs-regexp">/ . = 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ current position .bstext : { *(.bstext) } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ put .bstext section to position 0 .bsdata : { *(.bsdata) }</span></span></code> </pre> <br>  Einstiegspunkt f√ºr die Kernelinstallation: <br><br><pre> <code class="hljs go"> .globl _start _start: .<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-number"><span class="hljs-number">0xeb</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> start_of_setup<span class="hljs-number"><span class="hljs-number">-1f</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-comment"><span class="hljs-comment">// // rest of the header //</span></span></code> </pre> <br>  Hier sehen wir den Operationscode <code>jmp</code> ( <code>0xeb</code> ), der zum Punkt <code>start_of_setup-1f</code> .  In der <code>Nf</code> Notation bezieht sich <code>2f</code> beispielsweise auf das lokale Label <code>2:</code>  In unserem Fall ist dies die Bezeichnung <code>1</code> , die unmittelbar nach dem √úbergang vorhanden ist und den Rest des Setup-Headers enth√§lt.  Unmittelbar nach dem Installationsheader sehen wir den Abschnitt <code>.entrytext</code> , der mit der Bezeichnung <code>start_of_setup</code> beginnt. <br><br>  Dies ist der erste tats√§chlich ausgef√ºhrte Code (au√üer nat√ºrlich den vorherigen Sprunganweisungen).  Nachdem ein Teil der <code>jmp</code> die Kontrolle vom Loader erhalten hat, befindet sich der erste <code>jmp</code> Befehl am Offset <code>0x200</code> ab dem Beginn des realen Kernelmodus, <code>0x200</code> nach den ersten 512 Bytes.  Dies ist sowohl im Linux-Kernel-Boot-Protokoll als auch im grub2-Quellcode zu sehen: <br><br><pre> <code class="hljs ruby">segment = grub_linux_real_target <span class="hljs-meta"><span class="hljs-meta">&gt;&gt; </span></span><span class="hljs-number"><span class="hljs-number">4</span></span>; state.gs = state.fs = state.es = state.ds = state.ss = segment; state.cs = segment + <span class="hljs-number"><span class="hljs-number">0x20</span></span>;</code> </pre> <br>  In unserem Fall <code>0x10000</code> der Kernel unter der Adresse <code>0x10000</code> .  Dies bedeutet, dass die Segmentregister nach dem Start der Kernelinstallation die folgenden Werte haben: <br><br> <code>gs = fs = es = ds = ss = 0x10000 <br> cs = 0x10200</code> <br> <br>  Nach dem <code>start_of_setup</code> von <code>start_of_setup</code> Kernel Folgendes tun: <br><br><ul><li>  Stellen Sie sicher, dass alle Segmentregisterwerte gleich sind </li><li>  Konfigurieren Sie gegebenenfalls den richtigen Stapel </li><li>  Konfigurieren Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bss</a> </li><li>  <a href="">Wechseln</a> Sie zu C-Code in <a href="">arch / x86 / boot / main.c.</a> </li></ul><br>  Mal sehen, wie das umgesetzt wird. <br><br><h1>  Segmentfallausrichtung </h1><br>  Zun√§chst pr√ºft der Kernel, ob die Segmentregister <code>ds</code> und <code>es</code> auf dieselbe Adresse verweisen.  Anschlie√üend wird das Richtungsflag mit der <code>cld</code> : <br><br><pre> <code class="hljs perl"> movw %ds, %ax movw %ax, %es cld</code> </pre> <br>  Wie ich bereits geschrieben habe, l√§dt grub2 standardm√§√üig den Kernel-Installationscode bei <code>0x10000</code> und <code>cs</code> bei <code>0x10200</code> , da die Ausf√ºhrung nicht am Anfang der Datei beginnt, sondern beim √úbergang hier: <br><br><pre> <code class="hljs go">_start: .<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-number"><span class="hljs-number">0xeb</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> start_of_setup<span class="hljs-number"><span class="hljs-number">-1f</span></span></code> </pre> <br>  Dies ist ein Versatz von <code>512</code> Byte von <a href="">4d 5a</a> .  Wie bei allen anderen Segmentregistern ist es auch erforderlich, <code>cs</code> von <code>0x10200</code> bis <code>0x10000</code> auszurichten.  Danach installieren Sie den Stack: <br><br><pre> <code class="hljs perl"> pushw %ds pushw $6f lretw</code> </pre> <br>  Dieser Befehl schiebt den <code>ds</code> Wert auf den Stapel, gefolgt von der Adresse des Etiketts <a href="">6</a> und dem <code>lretw</code> , der die Adresse des Etiketts <code>6</code> in das Register des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Befehlsz√§hlers</a> l√§dt und <code>cs</code> mit dem Wert <code>ds</code> l√§dt.  Danach haben <code>ds</code> und <code>cs</code> die gleichen Werte. <br><br><h1>  Stack-Setup </h1><br>  Fast der gesamte Code ist Teil des Prozesses zur Vorbereitung der C-Umgebung im Real-Modus.  Der n√§chste Schritt besteht darin, den <code>ss</code> Registerwert zu √ºberpr√ºfen und den richtigen Stapel zu erstellen, wenn der <code>ss</code> Wert falsch ist: <br><br><pre> <code class="hljs perl"> movw %ss, %dx cmpw %ax, %dx movw %sp, %dx je <span class="hljs-number"><span class="hljs-number">2</span></span>f</code> </pre> <br>  Dies kann drei verschiedene Szenarien ausl√∂sen: <br><br><ul><li>  <code>ss</code> g√ºltigen Wert von <code>0x1000</code> (wie bei allen anderen Registern au√üer <code>cs</code> ) </li><li>  <code>ss</code> ung√ºltigen Wert und das <code>CAN_USE_HEAP</code> Flag <code>CAN_USE_HEAP</code> gesetzt (siehe unten) </li><li>  <code>ss</code> ung√ºltigen Wert und das <code>CAN_USE_HEAP</code> Flag <code>CAN_USE_HEAP</code> nicht gesetzt (siehe unten) </li></ul><br>  Betrachten Sie alle Szenarien der Reihe nach: <br><br><ul><li>  <code>ss</code> g√ºltigen Wert ( <code>0x1000</code> ).  In diesem Fall gehen wir zu Label 2: </li></ul><br><pre> <code class="hljs mel"><span class="hljs-number"><span class="hljs-number">2</span></span>: andw $~<span class="hljs-number"><span class="hljs-number">3</span></span>, %dx jnz <span class="hljs-number"><span class="hljs-number">3</span></span>f movw $0xfffc, %dx <span class="hljs-number"><span class="hljs-number">3</span></span>: movw %ax, %ss movzwl %dx, %esp sti</code> </pre> <br>  Hier setzen wir die Ausrichtung des <code>dx</code> Registers (das den vom Bootloader angegebenen <code>sp</code> Wert enth√§lt) auf <code>4</code> Bytes und pr√ºfen auf Null.  Wenn es Null ist, geben wir den Wert <code>0xfffc</code> <code>dx</code> ( <code>4</code> Byte-ausgerichtete Adresse vor der maximalen Segmentgr√∂√üe von 64 KB).  Wenn es nicht gleich Null ist, verwenden wir weiterhin den vom Bootloader angegebenen <code>sp</code> Wert (in unserem Fall <code>0xf7f4</code> ).  Dann setzen wir den <code>ax</code> Wert in <code>ss</code> , wodurch die richtige Segmentadresse <code>0x1000</code> und der richtige <code>sp</code> .  Jetzt haben wir den richtigen Stapel: <br><br><img src="https://habrastorage.org/webt/wf/dp/bl/wfdpblqpiltzdrprytvnoj3kygo.png"><br><br><ul><li>  Im zweiten Szenario ist <code>ss != ds</code> .  Zuerst setzen wir den Wert <a href="">_end</a> (die Adresse des Endes des Installationscodes) in <code>dx</code> und √ºberpr√ºfen die <code>loadflags</code> des Headerfelds. Verwenden Sie die Anweisung <code>testb</code> um zu √ºberpr√ºfen, ob der Heap verwendet werden kann.  <a href="">loadflags</a> ist ein Bitmasken-Header, der wie folgt definiert ist: </li></ul><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LOADED_HIGH (1&lt;&lt;0) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> QUIET_FLAG (1&lt;&lt;5) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> KEEP_SEGMENTS (1&lt;&lt;6) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CAN_USE_HEAP (1&lt;&lt;7)</span></span></code> </pre> <br>  und wie im Boot-Protokoll angegeben: <br><br> <code> : loadflags <br> <br>     . <br> <br>  7 (): CAN_USE_HEAP <br>     1,  ,   <br> heap_end_ptr .    ,   <br>   .</code> <br> <br>  Wenn das <code>CAN_USE_HEAP</code> Bit gesetzt ist, <code>CAN_USE_HEAP</code> wir in <code>dx</code> den Wert <code>heap_end_ptr</code> (der auf <code>_end</code> ) und f√ºgen <code>STACK_SIZE</code> (die minimale <code>STACK_SIZE</code> betr√§gt <code>1024</code> Bytes).  Gehen Sie danach zu Etikett <code>2</code> (wie im vorherigen Fall) und erstellen Sie den richtigen Stapel. <br><br><img src="https://habrastorage.org/webt/1n/be/nw/1nbenww3ncnipvbi1g-jqdvsmok.png"><br><br><ul><li>  Wenn <code>CAN_USE_HEAP</code> nicht festgelegt ist, verwenden Sie einfach den Mindeststapel von <code>_end</code> bis <code>_end + STACK_SIZE</code> : </li></ul><br><img src="https://habrastorage.org/webt/5x/xg/fi/5xxgfikk1iskr_6pgjzvmcwhpjy.png"><br><br><h1>  BSS-Setup </h1><br>  Bevor Sie mit dem Haupt-C-Code fortfahren, sind zwei weitere Schritte erforderlich: Hiermit wird der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BSS-Bereich eingerichtet</a> und die ‚Äûmagische‚Äú Signatur √ºberpr√ºft.  √úberpr√ºfung der Unterschrift zuerst: <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">cmpl</span></span> <span class="hljs-variable"><span class="hljs-variable">$0</span></span>x5a5aaa55, setup_sig jne setup_bad</code> </pre> <br>  Die Anweisung vergleicht <a href="">setup_sig</a> einfach mit der magischen Zahl 0x5a5aaa55.  Wenn sie nicht gleich sind, wird ein schwerwiegender Fehler gemeldet. <br><br>  Wenn die magische Zahl √ºbereinstimmt und wir einen Satz korrekter Segmentregister und einen Stapel haben, m√ºssen Sie nur noch den BSS-Abschnitt konfigurieren, bevor Sie mit dem C-Code fortfahren. <br><br>  Der BSS-Abschnitt wird zum Speichern statisch zugeordneter nicht initialisierter Daten verwendet.  Linux pr√ºft sorgf√§ltig, ob dieser Speicherbereich zur√ºckgesetzt wird: <br><br><pre> <code class="hljs perl"> movw $__bss_start, %di movw $_end+<span class="hljs-number"><span class="hljs-number">3</span></span>, %cx xorl %eax, %eax subw %di, %cx shrw $2, %cx rep; stosl</code> </pre> <br>  Zun√§chst wird die Startadresse von <a href="">__bss_start</a> nach <code>di</code> verschoben.  Dann wird die Adresse <code>_end + 3</code> (+3 f√ºr die Ausrichtung um 4 Bytes) nach <code>cx</code> verschoben.  Das <code>eax</code> Register wird gel√∂scht (unter Verwendung des <code>xor</code> Befehls), die Gr√∂√üe der bss-Partition ( <code>cx-di</code> ) wird berechnet und in <code>cx</code> platziert.  Dann wird <code>cx</code> in vier geteilt (die Gr√∂√üe des ‚ÄûWortes‚Äú) und der <code>stosl</code> wird <code>stosl</code> , wobei der Wert <code></code> (Null) in der auf <code>di</code> zeigenden Adresse gespeichert wird, <code>di</code> automatisch um vier erh√∂ht wird und dies wiederholt wird, bis <code></code> Null erreicht).  Der Nettoeffekt dieses Codes besteht darin, dass Nullen in alle W√∂rter im Speicher von <code>__bss_start</code> bis <code>_end</code> : <br><br><img src="https://habrastorage.org/webt/2s/bw/ym/2sbwymhai1qislpkru0btkrolcy.png"><br><br><h1>  Gehe zur Hauptstra√üe </h1><br>  Das war's: Wir haben einen Stack und BSS, also k√∂nnen Sie zur <code>main()</code> C-Funktion gehen: <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">calll</span></span> main</code> </pre> <br>  Die Funktion <code>main()</code> befindet sich in <a href="">arch / x86 / boot / main.c.</a>  Wir werden im n√§chsten Teil √ºber sie sprechen. <br><br><h1>  Fazit </h1><br>  Dies ist das Ende des ersten Teils √ºber das Linux-Kernelger√§t.       ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ,  <a href=""></a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> .         C,      Linux,   ,   <code>memset</code> , <code>memcpy</code> , <code>earlyprintk</code> ,        . <br><br><h1>  Referenzen </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intel 80386,  , 1986 .</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">    Intel</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8086</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">80386</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   Linux</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Coreboot,  </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> ¬´  ¬ª</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428664/">https://habr.com/ru/post/de428664/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428654/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 15: Medizinische Software, Teil 2</a></li>
<li><a href="../de428656/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 15: Medizinische Software, Teil 3</a></li>
<li><a href="../de428658/index.html">Kostenlose Bildungsworkshops im B√ºro der Mail.Ru Group</a></li>
<li><a href="../de428660/index.html">Aktivieren von Richtlinien f√ºr erweiterbare Pull-Anforderungen in VSTS zur Unterst√ºtzung des Entwicklungsprozesses</a></li>
<li><a href="../de428662/index.html">Programmieraufgabe f√ºr den Einzelhandel</a></li>
<li><a href="../de428666/index.html">Wie ich mit CSS-Masken stimmungsver√§ndernde Animationen erstellt habe</a></li>
<li><a href="../de428668/index.html">Blizzard k√ºndigte die Ver√∂ffentlichung der Neuver√∂ffentlichung von WarCraft III im Jahr 2019 an. Vorbestellung √∂ffnen</a></li>
<li><a href="../de428672/index.html">QuietOn Active Squelch √úbersicht</a></li>
<li><a href="../de428674/index.html">Erstellen von Client-Routing / semantischer Suche bei Profi.ru.</a></li>
<li><a href="../de428676/index.html">Grundlegendes zu C #: Zuweisen von Speicher f√ºr einen Referenztyp auf dem Stapel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>