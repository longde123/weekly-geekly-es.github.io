<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>  革 Aprendizaje autom谩tico en an谩lisis est谩tico del c贸digo fuente del programa お  </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El aprendizaje autom谩tico se ha arraigado firmemente en una variedad de campos humanos, desde el reconocimiento del habla hasta el diagn贸stico m茅dico....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aprendizaje autom谩tico en an谩lisis est谩tico del c贸digo fuente del programa</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/484202/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38e/0e0/738/38e0e0738ea8b928bdecb77040a207c1.png" alt="Aprendizaje autom谩tico en an谩lisis est谩tico del c贸digo fuente del programa"></div><br>  El aprendizaje autom谩tico se ha arraigado firmemente en una variedad de campos humanos, desde el reconocimiento del habla hasta el diagn贸stico m茅dico.  La popularidad de este enfoque es tan grande que las personas intentan usarlo siempre que pueden.  Algunos intentos de reemplazar los enfoques cl谩sicos con redes neuronales resultan infructuosos.  Esta vez consideraremos el aprendizaje autom谩tico en t茅rminos de crear analizadores de c贸digo est谩tico efectivos para encontrar errores y vulnerabilidades potenciales. <br><a name="habracut"></a><br>  A menudo se pregunta al equipo de PVS-Studio si queremos comenzar a utilizar el aprendizaje autom谩tico para encontrar errores en el c贸digo fuente del software.  La respuesta corta es s铆, pero hasta cierto punto.  Creemos que con el aprendizaje autom谩tico, existen muchas dificultades al acecho en las tareas de an谩lisis de c贸digo.  En la segunda parte del art铆culo, hablaremos sobre ellos.  Comencemos con una revisi贸n de nuevas soluciones e ideas. <br><br><h2>  Nuevos enfoques </h2><br>  Hoy en d铆a hay muchos analizadores est谩ticos basados en el aprendizaje autom谩tico o que lo utilizan, incluido el aprendizaje profundo y la PNL para la detecci贸n de errores.  Los entusiastas no solo duplicaron el potencial de aprendizaje autom谩tico, sino tambi茅n las grandes empresas, por ejemplo, Facebook, Amazon o Mozilla.  Algunos proyectos no son analizadores est谩ticos completos, ya que solo encuentran algunos errores determinados en las confirmaciones. <br><br>  Curiosamente, casi todos ellos se posicionan como productos que cambian el juego que har谩n un gran avance en el proceso de desarrollo debido a la inteligencia artificial. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28c/cde/532/28ccde53241d54d5b927234ff729a19d.png"></div><br><br>  Veamos algunos de los ejemplos conocidos: <br><br><ol><li>  Deepcode </li><li>  Inferir, Sapienz, SapFix </li><li>  Embold </li><li>  Fuente {d} </li><li>  Compromiso inteligente, asistente de compromiso </li><li>  CodeGuru </li></ol><br><h3>  Deepcode </h3><br>  Deep Code es una herramienta de b煤squeda de vulnerabilidades para el c贸digo de software Java, JavaScript, TypeScript y Python que presenta el aprendizaje autom谩tico como un componente.  Seg煤n Boris Paskalev, ya se han implementado m谩s de 250,000 reglas.  Esta herramienta aprende de los cambios realizados por los desarrolladores en el c贸digo fuente de proyectos de c贸digo abierto (un mill贸n de repositorios).  La propia empresa dice que su proyecto es una especie de gram谩tica para los desarrolladores. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c0/f09/8df/0c0f098dfabd07a95df228b434ab3bfb.png"></div><br><br>  De hecho, este analizador compara su soluci贸n con su base de proyectos y le ofrece la mejor soluci贸n prevista de la experiencia de otros desarrolladores. <br><br>  En mayo de 2018, los desarrolladores dijeron que el soporte de C ++ est谩 en camino, pero hasta ahora, este lenguaje no es compatible.  Aunque, como se indica en el sitio, el nuevo soporte de idioma se puede agregar en cuesti贸n de semanas debido al hecho de que el idioma depende solo de una etapa, que es el an谩lisis. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a38/68e/7e5/a3868e7e5efa50016e7a7858054da47a.png"></div><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/111/984/4f5/1119844f5406645778271c64f12d0df9.png"></div><br><br>  Una serie de publicaciones sobre m茅todos b谩sicos del analizador tambi茅n est谩 disponible en el sitio. <br><br><h3>  Inferir </h3><br>  Facebook es bastante celoso en sus intentos de introducir nuevos enfoques integrales en sus productos.  El aprendizaje autom谩tico tampoco se mantuvo al margen.  En 2013, compraron una startup que desarroll贸 un analizador est谩tico basado en aprendizaje autom谩tico.  Y en 2015, el c贸digo fuente del proyecto <a href="https://github.com/facebook/infer">se abri贸</a> . <br><br>  Infer es un analizador est谩tico para proyectos en Java, C, C ++ y Objective-C, desarrollado por Facebook.  Seg煤n el sitio, tambi茅n se usa en Amazon Web Services, Oculus, Uber y otros proyectos populares. <br><br>  Actualmente, Infer puede encontrar errores relacionados con la desreferencia de puntero nulo y p茅rdidas de memoria.  Infer se basa en la l贸gica de Hoare, la l贸gica de separaci贸n y la bi-abducci贸n, as铆 como en la teor铆a de la interpretaci贸n abstracta.  El uso de estos enfoques permite al analizador dividir el programa en fragmentos y analizarlos de forma independiente. <br><br>  Puede intentar usar Infer en sus proyectos, pero los desarrolladores advierten que si bien con los proyectos de Facebook genera aproximadamente el 80% de las advertencias 煤tiles, un bajo n煤mero de falsos positivos no est谩 garantizado en otros proyectos.  Aqu铆 hay algunos errores que Infer no puede detectar hasta ahora, pero los desarrolladores est谩n trabajando en implementar estas advertencias: <br><br><ul><li>  铆ndice de matriz fuera de l铆mites; </li><li>  excepciones de fundici贸n de tipos; </li><li>  fugas de datos no verificadas; </li><li>  condici贸n de carrera </li></ul><br><h3>  Sapfix </h3><br>  SapFix es una herramienta de edici贸n automatizada.  Recibe informaci贸n de Sapienz, una herramienta de automatizaci贸n de pruebas, y el analizador est谩tico Infer.  Seg煤n los cambios y mensajes recientes, Infer selecciona una de varias estrategias para corregir errores. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/547/de6/baa/547de6baa2d74f4e3be984a78c704d45.png"></div><br><br>  En algunos casos, SapFix revierte todos los cambios o partes de ellos.  En otros casos, intenta resolver el problema generando un parche a partir de su conjunto de patrones de fijaci贸n.  Este conjunto se forma a partir de patrones de arreglos recopilados por los propios programadores a partir de un conjunto de arreglos que ya se hicieron.  Si dicho patr贸n no soluciona un error, SapFix intenta ajustarlo a la situaci贸n haciendo peque帽as modificaciones en un 谩rbol de sintaxis abstracta hasta que se encuentre la posible soluci贸n. <br><br>  Pero una soluci贸n potencial no es suficiente, por lo que SapFix recopila varias soluciones 'sobre la base de un par de puntos: si hay errores de compilaci贸n, si falla o si introduce nuevos bloqueos.  Una vez que las ediciones se prueban completamente, los parches son revisados por un programador, quien decidir谩 cu谩l de las ediciones resuelve mejor el problema. <br><br><h3>  Embold </h3><br>  Embold es una plataforma de inicio para el an谩lisis est谩tico del c贸digo fuente del software que se llam贸 Gamma antes del cambio de nombre.  El analizador est谩tico funciona en funci贸n de los diagn贸sticos propios de la herramienta, as铆 como el uso de analizadores integrados, como Cppcheck, SpotBugs, SQL Check y otros. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f40/406/bd8/f40406bd824b5eeb1815de357d95565b.png"></div><br><br>  Adem谩s de los diagn贸sticos en s铆, la plataforma se centra en infograf铆as v铆vidas sobre la carga de la base de c贸digo y la visualizaci贸n conveniente de los errores encontrados, as铆 como en la b煤squeda de una posible refactorizaci贸n.  Adem谩s, este analizador tiene un conjunto de antipatrones que le permiten detectar problemas en la estructura del c贸digo a nivel de clase y m茅todo, y varias m茅tricas para calcular la calidad de un sistema. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/220/74f/abb/22074fabb8b67de2ce5d5427729387f7.png"></div><br><br>  Una de las principales ventajas es el sistema inteligente de ofrecer soluciones y ediciones, que, adem谩s de los diagn贸sticos convencionales, verifica las ediciones en funci贸n de la informaci贸n sobre cambios anteriores. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e5/122/c46/6e5122c462cd33320eafecd4deac2a49.png"></div><br><br>  Con NLP, Embold separa el c贸digo y busca interconexiones y dependencias entre funciones y m茅todos, ahorrando tiempo de refactorizaci贸n. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/94e/129/3fe/94e1293fe9e031d4065beb9ea1b21932.png"></div><br><br>  De esta manera, Embold b谩sicamente ofrece una visualizaci贸n conveniente de los resultados de su an谩lisis de c贸digo fuente por varios analizadores, as铆 como por sus propios diagn贸sticos, algunos de los cuales se basan en el aprendizaje autom谩tico. <br><br><h3>  Fuente {d} </h3><br>  Source {d} es la herramienta m谩s abierta en t茅rminos de las formas de su implementaci贸n en comparaci贸n con los analizadores que hemos revisado.  Tambi茅n es una <a href="https://github.com/src-d/sourced-ce">soluci贸n de c贸digo fuente abierto</a> .  En su sitio web, a cambio de su direcci贸n de correo electr贸nico, puede obtener un folleto del producto que describe las tecnolog铆as que utilizan.  Adem谩s, el sitio web proporciona un <a href="https://github.com/src-d/awesome-machine-learning-on-source-code">enlace</a> a la base de datos de publicaciones relacionadas con el uso del aprendizaje autom谩tico para el an谩lisis de c贸digo, as铆 como el <a href="https://github.com/src-d/datasets/tree/master/PublicGitArchive">repositorio</a> con el conjunto de datos para el aprendizaje basado en c贸digo.  El producto en s铆 es una plataforma completa para analizar el c贸digo fuente y el producto de software, y no se centra en los desarrolladores, sino en los gerentes.  Entre sus capacidades est谩 el c谩lculo del tama帽o de la deuda t茅cnica, los cuellos de botella en el proceso de desarrollo y otras estad铆sticas globales sobre el proyecto. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af2/b8c/425/af2b8c42537b1a2628c95773165ed190.png"></div><br><br>  Su enfoque para el an谩lisis de c贸digo a trav茅s del aprendizaje autom谩tico se basa en la hip贸tesis natural, como se describe en el art铆culo " <a href="https://people.inf.ethz.ch/suz/publications/natural.pdf">Sobre la naturalidad del software</a> ". <br><br>  <i>"Los lenguajes de programaci贸n, en teor铆a, son complejos, flexibles y potentes, pero los programas que las personas reales escriben son en su mayor铆a simples y bastante repetitivos, y por lo tanto tienen propiedades estad铆sticas predecibles que pueden capturarse en modelos de lenguaje estad铆stico y aprovecharse para la ingenier铆a de software tareas ".</i> <br><br>  Seg煤n esta hip贸tesis, cuanto m谩s grande sea la base del c贸digo, mayores ser谩n las propiedades estad铆sticas y m谩s precisas ser谩n las m茅tricas obtenidas mediante el aprendizaje. <br><br>  Para analizar el c贸digo en la fuente {d}, se utiliza el servicio Babelfish, que puede analizar el archivo de c贸digo en cualquiera de los idiomas disponibles, obtener un 谩rbol de sintaxis abstracta y convertirlo en un 谩rbol de sintaxis universal. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39e/bbd/c4d/39ebbdc4d561895c1f7b9e251d44e17c.png"></div><br><br>  Sin embargo, la fuente {d} no busca errores en el c贸digo.  Basado en el 谩rbol que usa ML en todo el proyecto, la fuente {d} detecta el formato del c贸digo, el estilo aplicado en el proyecto y en una confirmaci贸n.  Si el nuevo c贸digo no se corresponde con el estilo del c贸digo del proyecto, realiza algunas modificaciones. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7f/196/c0a/e7f196c0a742ba8f68436b157708c109.png"></div><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/deb/f51/7bd/debf517bd5d74c2553a9b7fbd112a1b2.png"></div><br><br>  El aprendizaje se centra en varios elementos b谩sicos: espacios, tabulaci贸n, saltos de l铆nea, etc. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39a/ade/8c5/39aade8c5ea77cb3bf89d4a0e999c5f7.png"></div><br><br>  Lea m谩s sobre esto en su publicaci贸n: " <a href="https://arxiv.org/abs/1904.00935">STYLE-ANALYZER: arreglando inconsistencias de estilo de c贸digo con algoritmos interpretables no supervisados</a> ". <br><br>  En general, source {d} es una plataforma amplia para recopilar estad铆sticas diversas sobre el c贸digo fuente y el proceso de desarrollo del proyecto: desde los c谩lculos de eficiencia de los desarrolladores hasta los costos de tiempo para la revisi贸n del c贸digo. <br><br><h3>  Compromiso inteligente </h3><br>  Clever-Commit es un analizador creado por Mozilla en colaboraci贸n con Ubisoft.  Se basa en un estudio <a href="https://static-wordpress.akamaized.net/montreal.ubisoft.com/wp-content/uploads/2018/03/03172129/clever-commit-msr18.pdf">CLEVER</a> (Combinaci贸n de niveles de prevenci贸n de errores y t茅cnicas de resoluci贸n) realizado por Ubisoft y su asistente de compromiso de producto secundario, que detecta confirmaciones sospechosas que pueden contener un error.  Dado que CLEVER se basa en la comparaci贸n de c贸digos, puede apuntar a c贸digos peligrosos y hacer sugerencias para posibles ediciones.  Seg煤n la descripci贸n, en 60-70% de los casos, Clever-Commit encuentra lugares problem谩ticos y ofrece ediciones correctas con la misma probabilidad.  En general, hay poca informaci贸n sobre este proyecto y sobre los errores que puede encontrar. <br><br><h3>  CodeGuru </h3><br>  Recientemente CodeGuru, que es un producto de Amazon, se ha alineado con los analizadores que utilizan el aprendizaje autom谩tico.  Es un servicio de aprendizaje autom谩tico que le permite encontrar errores en el c贸digo, as铆 como identificar 谩reas costosas en 茅l.  El an谩lisis solo est谩 disponible para el c贸digo Java hasta ahora, pero los autores prometen admitir otros idiomas en el futuro.  Aunque se anunci贸 recientemente, Andy Jassy, CEO de AWS (Amazon Web Services) dice que se ha utilizado en Amazon durante mucho tiempo. <br><br>  El sitio web dice que CodeGuru estaba aprendiendo en la base de c贸digo de Amazon, as铆 como en m谩s de 10,000 proyectos de c贸digo abierto. <br><br>  B谩sicamente, el servicio se divide en dos partes: CodeGuru Reviewer, que se ense帽a utilizando la b煤squeda de reglas asociativas y busca errores en el c贸digo, y CodeGuru Profiler, que supervisa el rendimiento de las aplicaciones. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee0/662/3a6/ee06623a61ab3f1345d05f169f3325ac.png"></div><br><br>  En general, no hay mucha informaci贸n disponible sobre este proyecto.  Como dice el sitio web, el Revisor analiza las bases de c贸digos de Amazon y busca solicitudes de extracci贸n, que contienen las llamadas a la API de AWS para aprender c贸mo detectar las desviaciones de las "mejores pr谩cticas".  A continuaci贸n, analiza los cambios realizados y los compara con los datos de la documentaci贸n, que se analiza al mismo tiempo.  El resultado es un modelo de "mejores pr谩cticas". <br><br>  Tambi茅n se dice que las recomendaciones para el c贸digo del usuario tienden a mejorar despu茅s de recibir comentarios sobre ellas. <br><br>  La lista de errores a los que responde Reviewer es bastante borrosa, ya que no se ha publicado documentaci贸n espec铆fica de errores: <br><br><ul><li>  Mejores pr谩cticas AWS </li><li>  Concurrencia </li><li>  Fugas de recursos </li><li>  Fuga de informaci贸n confidencial. </li><li>  "Mejores pr谩cticas" generales de codificaci贸n </li></ul><br><h2>  Nuestro escepticismo </h2><br>  Ahora consideremos la b煤squeda de errores desde el punto de vista de nuestro equipo, que ha estado desarrollando analizadores est谩ticos durante muchos a帽os.  Vemos una serie de problemas de alto nivel de la aplicaci贸n de m茅todos de aprendizaje, que nos gustar铆a cubrir.  Para comenzar, dividiremos todos los enfoques de ML en dos tipos: <br><br><ol><li>  Los que ense帽an manualmente un analizador est谩tico para buscar diversos problemas, utilizando ejemplos de c贸digo sint茅tico y real; </li><li>  Aquellos que ense帽an algoritmos en una gran cantidad de c贸digo abierto e historial de revisi贸n (GitHub), despu茅s de lo cual el analizador comenzar谩 a detectar errores e incluso ofrecer谩 ediciones. </li></ol><br>  Hablaremos de cada direcci贸n por separado, ya que tienen diferentes inconvenientes.  Despu茅s de eso, creo que los lectores entender谩n por qu茅 no negamos las posibilidades del aprendizaje autom谩tico, pero a煤n as铆 no compartimos el entusiasmo. <br><br>  <b>Nota</b>  Miramos desde la perspectiva del desarrollo de un analizador universal est谩tico de prop贸sito general.  Estamos enfocados en desarrollar el analizador, que cualquier equipo podr谩 usar, no el enfocado en una base de c贸digo espec铆fica. <br><br><h3>  Ense帽anza manual de un analizador est谩tico </h3><br>  Digamos que queremos usar ML para comenzar a buscar los siguientes tipos de fallas en el c贸digo: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A == A)</code> </pre> <br>  Es extra帽o comparar una variable consigo misma.  Podemos escribir muchos ejemplos de c贸digo correcto e incorrecto y ense帽arle al analizador a buscar tales errores.  Adem谩s, puede agregar ejemplos reales de errores ya encontrados a las pruebas.  Bueno, la pregunta es d贸nde encontrar esos ejemplos.  Ok, supongamos que es posible.  Por ejemplo, tenemos varios ejemplos de tales errores: <a href="https://www.viva64.com/en/examples/v501/">V501</a> , <a href="https://www.viva64.com/en/examples/v3001/">V3001</a> , <a href="https://www.viva64.com/en/examples/v6001/">V6001</a> . <br><br>  Entonces, 驴es posible identificar tales defectos en el c贸digo utilizando los algoritmos ML?  Si lo es.  La cuesti贸n es: 驴por qu茅 lo necesitamos? <br><br>  Vea, para ense帽ar al analizador necesitaremos dedicar muchos esfuerzos a preparar los ejemplos para la ense帽anza.  Otra opci贸n es marcar el c贸digo de las aplicaciones reales, indicando los fragmentos donde el analizador debe emitir una advertencia.  En cualquier caso, habr谩 que trabajar mucho, ya que debe haber miles de ejemplos para aprender.  O decenas de miles. <br><br>  Despu茅s de todo, queremos detectar no solo los casos (A == A), sino tambi茅n: <br><br><ul><li>  si (X &amp;&amp; A == A) </li><li>  si (A + 1 == A + 1) </li><li>  si (A [i] == A [i]) </li><li>  si ((A) == (A)) </li><li>  Y as铆 sucesivamente. </li></ul><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19e/a51/95d/19ea5195d9075802dbdcd3feda3c4aad.png"></div><br>  Veamos la posible implementaci贸n de un diagn贸stico tan simple en PVS-Studio: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RulePrototype_V501</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VivaWalker &amp;walker, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *right, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *operation)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SafeEq(operation, <span class="hljs-string"><span class="hljs-string">"=="</span></span>) &amp;&amp; SafeEqual(left, right)) { walker.AddError(<span class="hljs-string"><span class="hljs-string">"Oh boy! Holy cow!"</span></span>, left, <span class="hljs-number"><span class="hljs-number">501</span></span>, Level_1, <span class="hljs-string"><span class="hljs-string">"CWE-571"</span></span>); } }</code> </pre> <br>  Y eso es todo!  隆No necesitas ninguna base de ejemplos para ML! <br><br>  En el futuro, el diagn贸stico debe aprender a tener en cuenta una serie de excepciones y emitir advertencias para (A [0] == A [1-1]).  Como sabemos, se puede programar f谩cilmente.  Por el contrario, en este caso, las cosas van a ser malas con la base de los ejemplos. <br><br>  Tenga en cuenta que en ambos casos necesitaremos un sistema de pruebas, documentaci贸n, etc.  En cuanto a la contribuci贸n laboral en la creaci贸n de un nuevo diagn贸stico, el enfoque cl谩sico, donde la regla est谩 r铆gidamente programada en el c贸digo, toma la delantera. <br><br>  Ok, es hora de otra regla.  Por ejemplo, aquella en la que se debe utilizar el resultado de algunas funciones.  No tiene sentido llamarlos y no usar su resultado.  Estas son algunas de esas funciones: <br><br><ul><li>  malloc </li><li>  memcmp </li><li>  cadena :: vac铆o </li></ul><br>  Esto es lo que hace el diagn贸stico PVS-Studio <a href="https://www.viva64.com/en/w/v530/">V530</a> . <br><br>  Entonces, lo que queremos es detectar llamadas a tales funciones, cuyo resultado no se utiliza.  Para hacer esto, puede generar muchas pruebas.  Y creemos que todo funcionar谩 bien.  Pero, de nuevo, no est谩 claro por qu茅 es necesario. <br><br>  La implementaci贸n de diagn贸stico V530 con todas las excepciones tom贸 258 l铆neas de c贸digo en el analizador PVS-Studio, 64 de los cuales son comentarios.  Tambi茅n hay una tabla con anotaciones de funciones, donde se observa que se debe usar su resultado.  Es mucho m谩s f谩cil completar esta tabla que crear ejemplos sint茅ticos. <br><br>  Las cosas empeorar谩n a煤n m谩s con los diagn贸sticos que usan an谩lisis de flujo de datos.  Por ejemplo, el analizador PVS-Studio puede rastrear el valor de los punteros, lo que le permite encontrar una p茅rdida de memoria: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* BnNew() { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>[kBigIntSize]; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(result, <span class="hljs-number"><span class="hljs-number">0</span></span>, kBigIntSize * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AndroidRSAPublicKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(crypto::RSAPrivateKey* key)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* n = BnNew(); .... RSAPublicKey pkey; pkey.len = kRSANumWords; pkey.exponent = <span class="hljs-number"><span class="hljs-number">65537</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Fixed public exponent pkey.n0inv = 0 - ModInverse(n0, 0x100000000LL); if (pkey.n0inv == 0) return kDummyRSAPublicKey; // &lt;= .... }</span></span></code> </pre> <br>  El ejemplo est谩 tomado del art铆culo " <a href="https://www.viva64.com/en/b/0555/">Cromo: Fugas de memoria</a> ".  Si la condici贸n <i>(pkey.n0inv == 0)</i> es verdadera, la funci贸n sale sin liberar el b煤fer, cuyo puntero se almacena en la variable <i>n</i> . <br><br>  Desde el punto de vista del PVS-Studio, aqu铆 no hay nada complicado.  El analizador ha estudiado la funci贸n <i>BnNew</i> y record贸 que devolvi贸 un puntero al bloque de memoria asignado.  En otra funci贸n, not贸 que el b煤fer podr铆a no liberarse y el puntero hacia 茅l se pierde al momento de salir de la funci贸n. <br><br>  Es un algoritmo com煤n de seguimiento de valores de trabajo.  No importa c贸mo se escriba el c贸digo.  No importa qu茅 m谩s hay en la funci贸n que no se relacione con el trabajo del puntero.  El algoritmo es universal y el diagn贸stico V773 encuentra muchos errores en varios proyectos.  隆Vea cu谩n diferentes son los <a href="https://www.viva64.com/en/examples/v773/">fragmentos de c贸digo</a> con errores detectados! <br><br>  No somos expertos en ML, pero tenemos la sensaci贸n de que aqu铆 hay grandes problemas a la vuelta de la esquina.  Hay una incre铆ble cantidad de formas en que puede escribir c贸digo con p茅rdidas de memoria.  Incluso si la m谩quina aprendiera bien c贸mo rastrear valores de variables, necesitar铆a comprender que tambi茅n hay llamadas a funciones. <br><br>  Sospechamos que requerir铆a tantos ejemplos para aprender que la tarea se vuelve indescifrable.  No estamos diciendo que no sea realista.  Dudamos de que el costo de crear el analizador valga la pena. <br><br>  <b>Analog铆a</b>  Lo que viene a mi mente es la analog铆a con una calculadora, donde en lugar de diagn贸sticos, uno tiene que programar acciones aritm茅ticas.  Estamos seguros de que puede ense帽arle a una calculadora basada en ML a resumir bien los n煤meros aliment谩ndolos con los resultados de las operaciones 1 + 1 = 2, 1 + 2 = 3, 2 + 1 = 3, 100 + 200 = 300, etc. .  Como comprender谩, la viabilidad de desarrollar una calculadora de este tipo es una gran pregunta (a menos que se le asigne una subvenci贸n :).  Se puede escribir una calculadora mucho m谩s simple, m谩s r谩pida, m谩s precisa y confiable usando la operaci贸n simple "+" en el c贸digo. <br><br>  <b>Conclusi贸n</b> Bueno, de esta manera funcionar谩.  Pero usarlo, en nuestra opini贸n, no tiene sentido pr谩ctico.  El desarrollo requerir谩 m谩s tiempo, pero el resultado ser谩 menos confiable y preciso, especialmente cuando se trata de implementar diagn贸sticos complejos basados en an谩lisis de flujo de datos. <br><br><h3>  Aprender sobre una gran cantidad de c贸digo fuente abierto </h3><br>  Bien, hemos resuelto con ejemplos sint茅ticos manuales, pero tambi茅n est谩 GitHub.  Puede realizar un seguimiento del historial de confirmaciones y deducir el cambio de c贸digo / patrones de fijaci贸n.  Entonces puede se帽alar no solo fragmentos de c贸digo sospechoso, sino incluso sugerir una forma de arreglar el c贸digo. <br><br>  Si se detiene en este nivel de detalle, todo se ve bien.  El diablo, como siempre, est谩 en los detalles.  As铆 que hablemos bien de estos detalles. <br><br>  <b>El primer matiz.</b>  <b>Fuente de datos</b> <br><br>  Las ediciones de GitHub son bastante aleatorias y diversas.  Las personas a menudo son flojas para realizar confirmaciones at贸micas y realizar varias ediciones en el c贸digo al mismo tiempo.  Ya sabes c贸mo sucede: corregir铆as el error y al mismo tiempo lo refactorizar铆as un poco ("Y aqu铆 agregar茅 el manejo de tal caso ...").  Incluso una persona puede ser incomprensible, ya sea que estos arreglos est茅n relacionados entre s铆 o no. <br><br>  El desaf铆o es c贸mo distinguir los errores reales de agregar nueva funcionalidad u otra cosa.  Por supuesto, puede obtener 1000 personas que marcar谩n manualmente las confirmaciones.  La gente tendr谩 que se帽alar: aqu铆 se corrigi贸 un error, aqu铆 se est谩 refactorizando, aqu铆 hay alguna funcionalidad nueva, aqu铆 los requisitos han cambiado, etc. <br><br>  驴Es posible tal marcado?  Si!  Pero observe qu茅 tan r谩pido ocurre la suplantaci贸n de identidad.  En lugar de "el algoritmo se aprende sobre la base de GitHub", ya estamos discutiendo c贸mo confundir a cientos de personas durante mucho tiempo.  El trabajo y el costo de crear la herramienta est谩 aumentando dram谩ticamente. <br><br>  Puede intentar identificar autom谩ticamente d贸nde se solucionaron los errores.  Para hacer esto, debe analizar los comentarios a los commits, prestar atenci贸n a las peque帽as ediciones locales, que probablemente sean esas correcciones de errores.  Es dif铆cil saber qu茅 tan bien puede buscar autom谩ticamente las correcciones de errores.  En cualquier caso, esta es una gran tarea que requiere investigaci贸n y programaci贸n por separado. <br><br>  Entonces, a煤n no hemos llegado a aprender, y ya hay matices :). <br><br>  <b>El segundo matiz.</b>  <b>Un retraso en el desarrollo.</b> <br><br>  Analizadores que aprender谩n en base a tales plataformas, ya que GitHub siempre estar谩 sujeto a dicho s铆ndrome, como "retraso por retraso mental".  Esto se debe a que los lenguajes de programaci贸n cambian con el tiempo. <br><br>  Desde C # 8.0 <a href="https://www.viva64.com/en/b/0631/">ha</a> habido tipos de referencia anulables, lo que ayuda a luchar contra las excepciones de referencia nula (NRE).  En JDK 12, apareci贸 un nuevo operador de conmutador ( <a href="https://openjdk.java.net/jeps/325">JEP 325</a> ).  En C ++ 17, existe la posibilidad de realizar construcciones condicionales en tiempo de compilaci贸n ( <a href="https://www.bfilipek.com/2018/03/ifconstexpr.html">constexpr si</a> ).  Y as铆 sucesivamente. <br><br>  Los lenguajes de programaci贸n est谩n evolucionando.  Adem谩s, los que, como C ++, se desarrollan muy r谩pido.  Aparecen nuevas construcciones, se agregan nuevas funciones est谩ndar y as铆 sucesivamente.  Junto con las nuevas caracter铆sticas, hay nuevos patrones de error que tambi茅n nos gustar铆a identificar con el an谩lisis de c贸digo est谩tico. <br><br>  En este punto, el m茅todo ML enfrenta un problema: el patr贸n de error ya est谩 claro, nos gustar铆a detectarlo, pero no hay una base de c贸digo para el aprendizaje. <br><br>  Miremos este problema usando un ejemplo particular.  El rango basado en el rango apareci贸 en C ++ 11.  Puede escribir el siguiente c贸digo, atravesando todos los elementos en el contenedor: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; numbers; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num : numbers) foo(num);</code> </pre> <br>  El nuevo bucle ha tra铆do consigo el nuevo patr贸n de error.  Si cambiamos el contenedor dentro del bucle, esto conducir谩 a la invalidaci贸n de los iteradores "sombra". <br><br>  Echemos un vistazo al siguiente c贸digo incorrecto: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num : numbers) { numbers.push_back(num * <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br>  El compilador lo convertir谩 en algo como esto: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> __begin = begin(numbers), __end = end(numbers); __begin != __end; ++__begin) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = *__begin; numbers.push_back(num * <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br>  Durante <i>push_back</i> , los iteradores <i>__begin</i> y <i>__end</i> pueden ser invalidados, si la memoria se reubica dentro del vector.  El resultado ser谩 el comportamiento indefinido del programa. <br><br>  Por lo tanto, el patr贸n de error se conoce y describe desde hace tiempo en la literatura.  El analizador PVS-Studio lo diagnostica con el diagn贸stico <a href="https://www.viva64.com/en/w/v789/">V789</a> y ya ha encontrado <a href="https://www.viva64.com/en/examples/v789/">errores reales</a> en proyectos de c贸digo abierto. <br><br>  驴Qu茅 tan pronto GitHub obtendr谩 suficiente c贸digo nuevo para notar este patr贸n?  Buena pregunta ... Es importante tener en cuenta que si hay un bucle for basado en rango, no significa que todos los programadores comenzar谩n a usarlo de inmediato.  Pueden pasar a帽os antes de que haya mucho c贸digo usando el nuevo bucle.  Adem谩s, se deben cometer muchos errores, y luego se deben corregir para que el algoritmo pueda notar el patr贸n en las ediciones. <br><br>  驴Cu谩ntos a帽os llevar谩?  Cinco?  Diez? <br><br>  Diez es demasiado, 驴o es una predicci贸n pesimista?  Lejos de eso.  Cuando se escribi贸 el art铆culo, hab铆an pasado ocho a帽os desde que apareci贸 un bucle basado en rango para C ++ 11.  Pero hasta ahora en nuestra base de datos solo hay <a href="https://www.viva64.com/en/examples/v789/">tres casos</a> de tal error.  Tres errores no son muchos ni pocos.  Uno no deber铆a sacar ninguna conclusi贸n de este n煤mero.  Lo principal es confirmar que dicho patr贸n de error es real y tiene sentido detectarlo. <br><br>  Ahora compare este n煤mero, por ejemplo, con este patr贸n de error: el <a href="https://www.viva64.com/en/examples/v595/">puntero se desreferencia antes de la verificaci贸n</a> .  En total, ya hemos identificado 1.716 casos de este tipo al verificar proyectos de c贸digo abierto. <br><br>  驴Quiz谩s no deber铆amos buscar errores en los bucles basados en rangos?  No  Es solo que los programadores son inerciales, y este operador se est谩 volviendo popular muy lentamente.  Gradualmente, habr谩 m谩s c贸digo y errores, respectivamente. <br><br>  Es probable que esto suceda solo 10-15 a帽os despu茅s de la aparici贸n de C ++ 11.  Esto lleva a una pregunta filos贸fica.  Supongamos que ya conocemos el patr贸n de error, solo esperaremos muchos a帽os hasta que tengamos muchos errores en proyectos de c贸digo abierto.  驴Ser谩 as铆? <br><br>  En caso afirmativo, es seguro diagnosticar el "retraso del desarrollo mental" para todos los analizadores basados en ML. <br><br>  Si "no", 驴qu茅 debemos hacer?  No hay ejemplos  驴Escribirlos manualmente?  Pero de esta manera, volvemos al cap铆tulo anterior, donde hemos dado una descripci贸n detallada de la opci贸n cuando la gente escribir铆a un paquete completo de ejemplos para aprender. <br><br>  Esto se puede hacer, pero la cuesti贸n de la conveniencia surge nuevamente.  La implementaci贸n del diagn贸stico V789 con todas las excepciones en el analizador PVS-Studio toma solo 118 l铆neas de c贸digo, de las cuales 13 l铆neas son comentarios.  Es decir, es un diagn贸stico muy simple, que se puede programar f谩cilmente de una manera cl谩sica. <br><br>  La situaci贸n ser谩 similar a cualquier otra innovaci贸n que aparezca en otros idiomas.  Como dicen, hay algo en qu茅 pensar. <br><br>  <b>El tercer matiz.</b>  <b>Documentaci贸n</b> <br><br>  Un componente importante de cualquier analizador est谩tico es la documentaci贸n que describe cada diagn贸stico.  Sin 茅l, ser谩 extremadamente dif铆cil o imposible usar el analizador.  En la <a href="https://www.viva64.com/en/w/">documentaci贸n de</a> PVS-Studio, tenemos una descripci贸n de cada diagn贸stico, que ofrece un ejemplo de c贸digo err贸neo y c贸mo solucionarlo.  Tambi茅n damos el enlace a <a href="https://cwe.mitre.org/">CWE</a> , donde se puede leer una descripci贸n alternativa del problema.  Y a煤n as铆, a veces los usuarios no entienden algo y nos hacen preguntas aclaratorias. <br><br>  En el caso de los analizadores est谩ticos basados en ML, el problema de la documentaci贸n se oculta de alguna manera.  Se supone que el analizador simplemente se帽alar谩 un lugar que le parece sospechoso e incluso puede sugerir c贸mo solucionarlo.  La decisi贸n de hacer una edici贸n o no depende de la persona.  Ah铆 es donde comienza el problema ... No es f谩cil tomar una decisi贸n sin poder leer, lo que hace que el analizador parezca sospechoso de un lugar particular en el c贸digo. <br><br>  Por supuesto, en algunos casos, todo ser谩 obvio.  Supongamos que el analizador apunta a este c贸digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(src + <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(p, src);</code> </pre> <br>  Y sugiera que lo reemplacemos con: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(src) + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(p, src);</code> </pre> <br>  Est谩 claro de inmediato que el programador cometi贸 un error tipogr谩fico y agreg贸 1 en el lugar equivocado.  Como resultado, se asignar谩 menos memoria de la necesaria. <br><br>  Aqu铆 est谩 todo claro, incluso sin documentaci贸n.  Sin embargo, este no siempre ser谩 el caso. <br><br>  Imagine que el analizador "silenciosamente" se帽ala este c贸digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint8 *hash_stage2)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE); }</code> </pre> <br>  Y sugiere que cambiemos el tipo char del valor de retorno para int: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint8 *hash_stage2)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE); }</code> </pre> <br>  No hay documentaci贸n para la advertencia.  Aparentemente, tampoco habr谩 texto en el mensaje de advertencia si hablamos de un analizador completamente independiente. <br><br>  Que haremos  Cual es la diferencia  驴Vale la pena hacer tal reemplazo? <br><br>  En realidad, podr铆a arriesgarme y aceptar arreglar el c贸digo.  Aunque aceptar arreglos sin entenderlos es una pr谩ctica poco convincente ... :) Puede consultar la descripci贸n de la funci贸n <a href="http://www.cplusplus.com/reference/cstring/memcmp/"><i>memcmp</i></a> y descubrir que la funci贸n realmente devuelve valores como <i>int</i> : 0, m谩s de cero y menos de cero.  Pero a煤n no est谩 claro por qu茅 hacer ediciones, si el c贸digo ya est谩 funcionando bien. <br><br>  Ahora, si no sabe cu谩l es la edici贸n, consulte la descripci贸n del diagn贸stico <a href="https://www.viva64.com/en/w/v642/">V642</a> .  De inmediato queda claro que este es un error real.  Adem谩s, puede causar una vulnerabilidad. <br><br>  Quiz谩s, el ejemplo parec铆a poco convincente.  Despu茅s de todo, el analizador sugiri贸 un c贸digo que probablemente sea mejor.  Ok  Veamos otro ejemplo de pseudoc贸digo, esta vez, para variar, en Java. <br><br><pre> <code class="cpp hljs">ObjectOutputStream out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectOutputStream(....); SerializedObject obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializedObject(); obj.state = <span class="hljs-number"><span class="hljs-number">100</span></span>; out.writeObject(obj); obj.state = <span class="hljs-number"><span class="hljs-number">200</span></span>; out.writeObject(obj); out.close();</code> </pre> <br>  Hay un objeto  Est谩 serializando.  Luego, el estado del objeto cambia y se vuelve a serializar.  Se ve bien  Ahora imagine que, de repente, al analizador no le gusta el c贸digo y quiere reemplazarlo con lo siguiente: <br><br><pre> <code class="cpp hljs">ObjectOutputStream out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectOutputStream(....); SerializedObject obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializedObject(); obj.state = <span class="hljs-number"><span class="hljs-number">100</span></span>; out.writeObject(obj); obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializedObject(); <span class="hljs-comment"><span class="hljs-comment">// The line is added obj.state = 200; out.writeObject(obj); out.close();</span></span></code> </pre> <br>  En lugar de cambiar el objeto y reescribirlo, se crea un nuevo objeto y se serializar谩. <br><br>  No hay una descripci贸n del problema.  Sin documentaci贸n  El c贸digo se ha vuelto m谩s largo.  Por alguna raz贸n, se crea un nuevo objeto.  驴Est谩s listo para hacer tal edici贸n en tu c贸digo? <br><br>  Dir谩s que no est谩 claro.  De hecho, es incomprensible.  Y as铆 ser谩 todo el tiempo.  Trabajar con un analizador tan "silencioso" ser谩 un estudio interminable en un intento por comprender por qu茅 al analizador no le gusta nada. <br><br>  Si hay documentaci贸n, todo se vuelve transparente.  La clase <i>java.io.ObjectOuputStream</i> que se utiliza para la serializaci贸n almacena en cach茅 los objetos escritos.  Esto significa que el mismo objeto no se serializar谩 dos veces.  La clase serializa el objeto una vez, y la segunda solo escribe en la secuencia una referencia al mismo primer objeto.  Leer m谩s: <a href="https://www.viva64.com/en/w/v6076/">V6076</a> : la serializaci贸n recurrente utilizar谩 el estado del objeto en cach茅 desde la primera serializaci贸n. <br><br>  Esperamos haber logrado explicar la importancia de la documentaci贸n.  Aqu铆 viene la pregunta.  驴C贸mo aparecer谩 la documentaci贸n para el analizador basado en ML? <br><br>  Cuando se desarrolla un analizador de c贸digo cl谩sico, todo es simple y claro.  Hay un patr贸n de errores.  Lo describimos en la documentaci贸n e implementamos el diagn贸stico. <br><br>  En el caso de ML, el proceso es inverso.  S铆, el analizador puede notar una anomal铆a en el c贸digo y se帽alarlo.  Pero no sabe nada sobre la esencia del defecto.  No entiende y no le dir谩 por qu茅 no puede escribir c贸digo como ese.  Estas son abstracciones de alto nivel.  De esta manera, el analizador tambi茅n debe aprender a leer y <b>comprender la</b> documentaci贸n de las funciones. <br><br>  Como dije, dado que el problema de la documentaci贸n se evita en los art铆culos sobre aprendizaje autom谩tico, no estamos listos para profundizar m谩s en 茅l.  Solo otro gran matiz que hemos hablado. <br><br>  <b>Nota</b>  Se podr铆a argumentar que la documentaci贸n es opcional.  El analizador puede referirse a muchos ejemplos de correcciones en GitHub y la persona, mirando a trav茅s de las confirmaciones y comentarios a ellos, comprender谩 qu茅 es qu茅.  Si es asi.  Pero la idea no parece atractiva.  Aqu铆, el analizador es el tipo malo, que m谩s bien desconcertar谩 a un programador que lo ayudar谩. <br><br>  <b>Cuarto matiz.</b>  <b>Idiomas altamente especializados.</b> <br><br>  El enfoque descrito no es aplicable a lenguajes altamente especializados, para los cuales el an谩lisis est谩tico tambi茅n puede ser extremadamente 煤til.  La raz贸n es que GitHub y otras fuentes simplemente no tienen una base de c贸digo fuente lo suficientemente grande como para proporcionar un aprendizaje efectivo. <br><br>  Miremos esto usando un ejemplo concreto.  Primero, vayamos a GitHub y busquemos repositorios para el popular lenguaje Java. <br><br>  Resultado: lenguaje: "Java": <b>3.128.884</b> resultados de repositorio disponibles <br><br>  Ahora tome el lenguaje especializado "1C Enterprise" utilizado en aplicaciones de contabilidad producidas por la compa帽铆a rusa <a href="https://ru.wikipedia.org/wiki/1%25D0%25A1">1C</a> . <br><br>  Resultado: idioma: "1C Enterprise": <b>551</b> resultados de repositorio disponibles <br><br>  驴Quiz谩s no se necesitan analizadores para este idioma?  No lo son.  Existe una necesidad pr谩ctica de analizar dichos programas y ya hay analizadores apropiados.  Por ejemplo, hay SonarQube 1C (BSL) Plugin, producido por la compa帽铆a " <a href="https://silverbulleters.org/">Silver Bullet</a> ". <br><br>  Creo que no se necesitan explicaciones espec铆ficas de por qu茅 el enfoque ML ser谩 dif铆cil para los idiomas especializados. <br><br>  <b>El quinto matiz.</b>  <b>C, C ++, #include</b> . <br><br>  Los art铆culos sobre an谩lisis de c贸digo est谩tico basados en ML tratan principalmente de lenguajes como Java, JavaScript y Python.  Esto se explica por su extrema popularidad.  En cuanto a C y C ++, se ignoran, aunque no se les puede llamar impopulares. <br><br>  Sugerimos que no se trata de su popularidad / perspectiva prometedora, sino de los problemas con los lenguajes C y C ++.  Y ahora vamos a sacar a la luz un problema inc贸modo. <br><br>  Un archivo c / cpp abstracto puede ser muy dif铆cil de compilar.  Al menos no puede cargar un proyecto desde GitHub, elija un archivo cpp aleatorio y simplemente comp铆lelo.  Ahora explicaremos qu茅 tiene que ver todo esto con ML. <br><br>  Por eso queremos ense帽arle al analizador.  Descargamos un proyecto de GitHub.  Conocemos el parche y asumimos que corrige el error.  Queremos que esta edici贸n sea un ejemplo para aprender.  En otras palabras, tenemos un archivo .cpp antes y despu茅s de editarlo. <br><br>  Ah铆 es donde comienza el problema.  No es suficiente solo estudiar las soluciones.  Tambi茅n se requiere un contexto completo.  Debe conocer la declaraci贸n de las clases utilizadas, debe conocer los prototipos de las funciones utilizadas, debe saber c贸mo se expanden las macros, etc.  Y para hacer esto, debe realizar el <a href="https://en.wikipedia.org/wiki/C_preprocessor">preprocesamiento</a> completo de los archivos. <br><br>  Veamos el ejemplo.  Al principio, el c贸digo se ve铆a as铆: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Class::IsMagicWord() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_name == <span class="hljs-string"><span class="hljs-string">"ML"</span></span>; }</code> </pre> <br>  Se solucion贸 de esta manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Class::IsMagicWord() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(m_name, <span class="hljs-string"><span class="hljs-string">"ML"</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  驴Deber铆a el analizador comenzar a aprender para sugerir <i>(x == "y")</i> reemplazo de strtrmp (x, "y")? <br><br>  No puede responder esa pregunta sin saber c贸mo se <i>declara el</i> miembro <i>m_name</i> en la clase.  Puede haber, por ejemplo, tales opciones: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Class</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *m_name; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Class</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_name; };</code> </pre> <br>  Se realizar谩n ediciones en caso de que estemos hablando de un puntero ordinario.  Si no tenemos en cuenta el tipo de variable, el analizador podr铆a aprender a emitir advertencias buenas y malas (para el caso de <i>std :: string</i> ). <br><br>  Las declaraciones de clase generalmente se encuentran en archivos de encabezado.  Aqu铆 se enfrentan a la necesidad de realizar un preprocesamiento para tener toda la informaci贸n necesaria.  Es extremadamente importante para C y C ++. <br><br>  Si alguien dice que es posible hacerlo sin preprocesamiento, es un fraude o simplemente no est谩 familiarizado con los lenguajes C o C ++. <br><br>  Para recopilar toda la informaci贸n necesaria, necesita un preprocesamiento correcto.  Para hacer esto, necesita saber d贸nde y qu茅 archivos de encabezado se encuentran, qu茅 macros se configuran durante el proceso de compilaci贸n.  Tambi茅n necesita saber c贸mo se compila un archivo cpp en particular. <br><br>  Ese es el problema  Uno no solo compila el archivo (o, m谩s bien, especifica la clave del compilador para que genere un archivo de preproceso).  Necesitamos descubrir c贸mo se compila este archivo.  Esta informaci贸n est谩 en los scripts de compilaci贸n, pero la pregunta es c贸mo obtenerla desde all铆.  En general, la tarea es complicada. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91b/aaf/95a/91baaf95a62415697b40f23298d115c2.png"></div><br><br>  Adem谩s, muchos proyectos en GitHub son un desastre.  Si tomas un proyecto abstracto desde all铆, a menudo tienes que jugar para compilarlo.  Un d铆a te falta una biblioteca y necesitas encontrarla y descargarla manualmente.  Otro d铆a, se utiliza alg煤n tipo de sistema de construcci贸n autoescrito, que debe tratarse.  Podr铆a ser cualquier cosa.  A veces, el proyecto descargado simplemente se niega a compilar y debe modificarse de alguna manera.  No puede simplemente tomar y obtener autom谩ticamente la representaci贸n preprocesada (.i) para los archivos .cpp.  Puede ser complicado incluso cuando lo haces manualmente. <br><br>  Podemos decir, bueno, el problema con los proyectos que no son de construcci贸n es comprensible, pero no crucial.  Solo trabajemos con proyectos que se puedan construir.  Todav铆a existe la tarea de preprocesar un archivo en particular.  Sin mencionar los casos en que tratamos con algunos compiladores especializados, por ejemplo, para sistemas embebidos. <br><br>  Despu茅s de todo, el problema descrito no es insuperable.  Sin embargo, todo esto es muy dif铆cil y requiere mucha mano de obra.  En el caso de C y C ++, el c贸digo fuente ubicado en GitHub no hace nada.  Hay mucho trabajo por hacer para aprender a ejecutar compiladores autom谩ticamente. <br><br>  <b>Nota</b>  Si el lector a煤n no entiende la profundidad del problema, lo invitamos a participar en el siguiente experimento.  Tome diez proyectos aleatorios de tama帽o medio de GitHub e intente compilarlos y luego obtenga su versi贸n preprocesada para archivos .cpp.  Despu茅s de eso, la pregunta sobre la laboriosidad de esta tarea desaparecer谩 :). <br><br>  Puede haber problemas similares con otros lenguajes, pero son particularmente obvios en C y C ++. <br><br>  <b>Sexto matiz.</b>  <b>El precio de eliminar los falsos positivos.</b> <br><br>  Los analizadores est谩ticos son propensos a generar falsos positivos y tenemos que refinar constantemente los diagn贸sticos para reducir el n煤mero de falsas advertencias. <br><br>  Ahora volveremos al diagn贸stico <a href="https://www.viva64.com/en/w/v789/">V789</a> previamente considerado, detectando cambios de contenedor dentro del bucle for basado en rango.  Digamos que no fuimos lo suficientemente cuidadosos al escribirlo, y el cliente informa un falso positivo.  l escribe que el analizador no tiene en cuenta el escenario cuando el ciclo termina despu茅s de que se cambia el contenedor, y por lo tanto no hay problema.  Luego da el siguiente ejemplo de c贸digo donde el analizador da un falso positivo: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; numbers; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num : numbers) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) { numbers.push_back(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">// or, for example, return } }</span></span></code> </pre> <br>  S铆, es un defecto.  En un analizador cl谩sico, su eliminaci贸n es extremadamente r谩pida y econ贸mica.  En PVS-Studio, la implementaci贸n de esta excepci贸n consta de 26 l铆neas de c贸digo. <br><br>  Esta falla tambi茅n se puede corregir cuando el analizador se basa en algoritmos de aprendizaje.  Por supuesto, se puede ense帽ar recolectando docenas o cientos de ejemplos de c贸digo que se deben considerar correctos. <br><br>  Nuevamente, la pregunta no est谩 en la viabilidad, sino en el enfoque pr谩ctico.  Sospechamos que luchar contra falsos positivos espec铆ficos, que molestan a los clientes, es mucho m谩s costoso en caso de LD.  Es decir, la atenci贸n al cliente en t茅rminos de eliminaci贸n de falsos positivos costar谩 m谩s dinero. <br><br>  <b>S茅ptimo matiz.</b>  <b>Caracter铆sticas raramente utilizadas y cola larga.</b> <br><br>  Anteriormente, hemos lidiado con el problema de los lenguajes altamente especializados, para los cuales puede no haber suficiente c贸digo fuente para el aprendizaje.  Un problema similar tiene lugar con funciones raramente utilizadas (sistema, WinAPI, de bibliotecas populares, etc.). <br><br>  Si estamos hablando de tales funciones del lenguaje C, como <i>strcmp</i> , entonces en realidad hay una base para aprender.  GitHub, resultados de c贸digo disponibles: <br><br><ul><li>  strcmp - 40,462,158 </li><li>  stricmp - 1,256,053 </li></ul><br>  S铆, hay muchos ejemplos de uso.  Quiz谩s el analizador aprenda a notar, por ejemplo, los siguientes patrones: <br><br><ul><li>  Es extra帽o si la cadena se compara con s铆 misma.  Se arregla. </li><li>  Es extra帽o si uno de los punteros es NULL.  Se arregla. </li><li>  Es extra帽o que el resultado de esta funci贸n no se use.  Se arregla. </li><li>  Y as铆 sucesivamente. </li></ul><br>  驴No es genial?  No  Aqu铆 nos enfrentamos al problema de la "cola larga".  Muy brevemente el punto de la "cola larga" en el siguiente.  No es pr谩ctico vender solo el Top50 de los libros m谩s populares y le铆dos en una librer铆a.  S铆, cada libro se comprar谩, digamos, 100 veces m谩s a menudo que los libros que no est谩n en esta lista.  Sin embargo, la mayor铆a de las ganancias se compondr谩n de otros libros que, como dicen, encuentran a su lector.  Por ejemplo, una tienda en l铆nea Amazon.com recibe m谩s de la mitad de las ganancias de lo que est谩 fuera de 130,000 "art铆culos m谩s populares". <br><br>  Hay funciones populares y hay pocas de ellas.  Hay impopulares, pero hay muchos de ellos.  Por ejemplo, existen las siguientes variaciones de la funci贸n de comparaci贸n de cadenas: <br><br><ul><li>  g_ascii_strncasecmp - 35,695 </li><li>  lstrcmpiA - 27,512 </li><li>  _wcsicmp_l - 5,737 </li><li>  _strnicmp_l - 5,848 </li><li>  _mbscmp_l - 2,458 </li><li>  y otros </li></ul><br>  Como puede ver, se usan con mucha menos frecuencia, pero cuando los usa, puede cometer los mismos errores.  Hay muy pocos ejemplos para identificar patrones.  Sin embargo, estas funciones no pueden ser ignoradas.  Individualmente, rara vez se usan, pero se escribe mucho c贸digo con su uso, lo que es mejor verificar.  Ah铆 es donde se muestra la "cola larga". <br><br>  En PVS-Studio, anotamos manualmente las caracter铆sticas.  Por ejemplo, por el momento se hab铆an anotado alrededor de 7.200 funciones para C y C ++.  Esto es lo que marcamos: <br><br><ul><li>  Winapi </li><li>  Biblioteca est谩ndar de C, </li><li>  Biblioteca de plantillas est谩ndar (STL), </li><li>  glibc (biblioteca GNU C) </li><li>  Qt </li><li>  MFC </li><li>  zlib </li><li>  libpng </li><li>  Openssl </li><li>  y otros </li></ul><br>  Por un lado, parece un camino sin salida.  No puedes anotar todo.  Por otro lado, funciona. <br><br>  Ahora aqu铆 est谩 la pregunta.  驴Qu茅 beneficios puede tener ML?  Las ventajas significativas no son tan obvias, pero puedes ver la complejidad. <br><br>  Se podr铆a argumentar que los algoritmos creados sobre ML encontrar谩n patrones con funciones de uso frecuente y no tienen que ser anotados.  Si es verdad.  Sin embargo, no hay problema para anotar independientemente funciones populares como <i>strcmp</i> o <i>malloc</i> . <br><br>  Sin embargo, la larga cola causa problemas.  Puedes ense帽ar haciendo ejemplos sint茅ticos.  Sin embargo, aqu铆 volvemos a la parte del art铆culo, donde dec铆amos que era m谩s f谩cil y r谩pido escribir diagn贸sticos cl谩sicos, en lugar de generar muchos ejemplos. <br><br>  Tomemos, por ejemplo, una funci贸n, como <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/fread-nolock"><i>_fread_nolock</i></a> .  Por supuesto, se usa con menos frecuencia que <i>fread</i> .  Pero cuando lo usa, puede cometer los mismos errores.  Por ejemplo, el b煤fer debe ser lo suficientemente grande.  Este tama帽o no debe ser menor que el resultado de multiplicar el segundo y el tercer argumento.  Es decir, desea encontrar un c贸digo incorrecto: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> buffer[<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> n = _fread_nolock(buffer, size_of(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), <span class="hljs-number"><span class="hljs-number">100</span></span>, stream);</code> </pre> <br>  As铆 es como se ve la anotaci贸n de esta funci贸n en PVS-Studio: <br><br><pre> <code class="cpp hljs">C_<span class="hljs-string"><span class="hljs-string">"size_t _fread_nolock"</span></span> <span class="hljs-string"><span class="hljs-string">"(void * _DstBuf, size_t _ElementSize, size_t _Count, FILE * _File);"</span></span> ADD(HAVE_STATE | RET_SKIP | F_MODIFY_PTR_1, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-string"><span class="hljs-string">"_fread_nolock"</span></span>, POINTER_1, BYTE_COUNT, COUNT, POINTER_2). Add_Read(from_2_3, to_return, buf_1). Add_DataSafetyStatusRelations(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>  A primera vista, tal anotaci贸n puede parecer dif铆cil, pero de hecho, cuando comienza a escribirlas, se vuelve simple.  Adem谩s, es c贸digo de solo escritura.  Escribi贸 y olvid贸.  Las anotaciones cambian raramente. <br><br>  Ahora hablemos de esta funci贸n desde el punto de vista de ML.  GitHub no nos ayudar谩.  Hay alrededor de 15,000 menciones de esta funci贸n.  Incluso hay menos c贸digo bueno.  Una parte importante de los resultados de b煤squeda abarca lo siguiente: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> fread_unlocked _fread_nolock</span></span></code> </pre> <br>  Cuales son las opciones? <ol><li>  No hagas nada  Es un camino a ninguna parte. </li><li>  Imag铆nese, ense帽e al analizador escribiendo cientos de ejemplos solo para una funci贸n para que el analizador comprenda la interconexi贸n entre el b煤fer y otros argumentos.  S铆, puedes hacer eso, pero es econ贸micamente irracional.  Es una calle sin salida. </li><li>  Puede llegar a una forma similar a la nuestra cuando las anotaciones a las funciones se configurar谩n manualmente.  Es una forma buena y sensata.  Eso es solo ML, que no tiene nada que ver con eso :).  Esto es un retroceso a la forma cl谩sica de escribir analizadores est谩ticos. </li></ol><br>  Como puede ver, ML y la larga cola de las funciones raramente utilizadas no van juntas. <br><br>  En este punto, hab铆a personas relacionadas con ML que se opusieron y dijeron que no hab铆amos tenido en cuenta la opci贸n cuando el analizador aprender铆a todas las funciones y sacar铆a conclusiones de lo que estaban haciendo.  Aqu铆, aparentemente, no entendemos a los expertos o no entienden nuestro punto. <br><br>  Los cuerpos de funciones pueden ser desconocidos.  Por ejemplo, podr铆a ser una funci贸n relacionada con WinAPI.  Si esta es una funci贸n raramente utilizada, 驴c贸mo comprender谩 el analizador lo que est谩 haciendo?  Podemos fantasear con que el analizador usar谩 Google mismo, encontrar谩 una descripci贸n de la funci贸n, la leer谩 y la <b>comprender谩</b> .  Adem谩s, tendr铆a que sacar conclusiones de alto nivel de la documentaci贸n.  La descripci贸n <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/fread-nolock"><i>_fread_nolock</i></a> no dice nada sobre la interconexi贸n entre el b煤fer, el segundo y el tercer argumento.  Esta comparaci贸n debe deducirse por inteligencia artificial por s铆 sola, basada en una comprensi贸n de los principios generales de programaci贸n y c贸mo funciona el lenguaje C ++.  Creo que deber铆amos pensar en todo esto seriamente en 20 a帽os. <br><br>  Los cuerpos de funciones pueden estar disponibles, pero puede que esto no sirva de nada.  Veamos una funci贸n, como <i>memmove</i> .  A menudo se implementa en algo como esto: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memmove</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *dest, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> __builtin___memmove_chk(dest, src, len, __builtin_object_size(dest, <span class="hljs-number"><span class="hljs-number">0</span></span>)); }</code> </pre> <br>  驴Qu茅 es <i>__builtin___memmove_chk</i> ?  Esta es una funci贸n intr铆nseca que el compilador ya est谩 implementando.  Esta funci贸n no tiene el c贸digo fuente. <br><br>  O <i>memmove</i> podr铆a verse as铆: <a href="">la primera versi贸n de ensamblaje</a> .  Puede ense帽arle al analizador a comprender las diferentes opciones de ensamblaje, pero este enfoque parece incorrecto. <br><br>  Ok, a veces los cuerpos de funciones son realmente conocidos.  Adem谩s, tambi茅n conocemos cuerpos de funciones en el c贸digo del usuario.  Parecer铆a que en este caso ML obtiene enormes ventajas al leer y comprender lo que hacen todas estas funciones. <br><br>  Sin embargo, incluso en este caso estamos llenos de pesimismo.  Esta tarea es demasiado compleja.  Es complicado incluso para un humano.  Piensa en lo dif铆cil que es para ti entender el c贸digo que no escribiste.  Si es dif铆cil para una persona, 驴por qu茅 esta tarea deber铆a ser f谩cil para una IA?  En realidad, la IA tiene un gran problema para comprender conceptos de alto nivel.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si estamos hablando de comprender el c贸digo, no podemos prescindir de la capacidad de abstraernos de los detalles de implementaci贸n y considerar el algoritmo a un alto nivel. Parece que esta discusi贸n tambi茅n puede posponerse durante 20 a帽os. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otros matices</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hay otros puntos que tambi茅n deben tenerse en cuenta, pero no hemos profundizado en ellos. Por cierto, el art铆culo resulta ser bastante largo. Por lo tanto, enumeraremos brevemente algunos otros matices, dej谩ndolos para la reflexi贸n del lector.</font></font><br><br><ul><li> <b>Outdated recommendations.</b> As mentioned, languages change, and recommendations for their use change, respectively. If the analyzer learns on old source code, it might start issuing outdated recommendations at some point. Example. Formerly, C++ programmers have been recommended using <a href="http://www.cplusplus.com/reference/memory/auto_ptr/"><i>auto_ptr</i></a> instead of half-done pointers. This smart pointer is now considered obsolete and it is recommended that you use <i>unique_ptr</i> . </li><li> <b>Data models.</b> At the very least, C and C++ languages have such a thing as a <a href="https://www.viva64.com/en/t/0012/">data model</a> . This means that data types have different number of bits across platforms. If you don't take this into account, you can incorrectly teach the analyzer. For example, in Windows 32/64 the <i>long</i> type always has 32 bits. But in Linux, its size will vary and take 32/64 bits depending on the platform's number of bits. Without taking all this into account, the analyzer can learn to miscalculate the size of the types and structures it forms. But the types also align in different ways. All this, of course, can be taken into account. You can teach the analyzer to know about the size of the types, their alignment and mark the projects (indicate how they are building). However, all this is an additional complexity, which is not mentioned in the research articles. </li><li> <b>Behavioral unambiguousness.</b> Since we're talking about ML, the analysis result is more likely to have probabilistic nature. That is, sometimes the erroneous pattern will be recognized, and sometimes not, depending on how the code is written. From our experience, we know that the user is extremely irritated by the ambiguity of the analyzer's behavior. He wants to know exactly which pattern will be considered erroneous and which will not, and why. In the case of the classical analyzer developing approach, this problem is poorly expressed. Only sometimes we need to explain our clients why there is a/there is no analyzer warning and how the algorithm works, what exceptions are handled in it. Algorithms are clear and everything can always be easily explained. An example of this kind of communication: " <a href="https://www.viva64.com/en/b/0612/">False Positives in PVS-Studio: How Deep the Rabbit Hole Goes</a> ". It's not clear how the described problem will be solved in the analyzers built on ML. </li></ul><br><h2> Conclusions </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No negamos las perspectivas de la direcci贸n ML, incluida su aplicaci贸n en t茅rminos de an谩lisis de c贸digo est谩tico. ML puede utilizarse potencialmente en tareas de b煤squeda de errores tipogr谩ficos, al filtrar falsos positivos, al buscar nuevos patrones de error (a煤n no descritos), etc. Sin embargo, no compartimos el optimismo que impregna los art铆culos dedicados a ML en t茅rminos de an谩lisis de c贸digo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este art铆culo, hemos esbozado algunos problemas en los que uno tendr谩 que trabajar si va a usar ML. Los matices descritos niegan en gran medida los beneficios del nuevo enfoque. Adem谩s, los viejos enfoques cl谩sicos de implementaci贸n de analizadores son m谩s rentables y econ贸micamente m谩s factibles.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curiosamente, los art铆culos de los adherentes de la metodolog铆a ML no mencionan estas trampas. </font><font style="vertical-align: inherit;">Pues nada nuevo. </font><font style="vertical-align: inherit;">ML provoca ciertas exageraciones y probablemente no deber铆amos esperar una evaluaci贸n equilibrada de sus apologistas con respecto a la aplicabilidad de ML en las tareas de an谩lisis de c贸digo est谩tico. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desde nuestro punto de vista, el aprendizaje autom谩tico llenar谩 un nicho en tecnolog铆as, utilizadas en analizadores est谩ticos junto con an谩lisis de flujo de control, ejecuciones simb贸licas y otros. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La metodolog铆a del an谩lisis est谩tico puede beneficiarse de la introducci贸n de ML, pero no exagere las posibilidades de esta tecnolog铆a.</font></font><br><br><h2>  PS </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como el art铆culo es generalmente cr铆tico, algunos podr铆an pensar que tememos lo nuevo y que </font></font><a href="https://en.wikipedia.org/wiki/Luddite"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luddites se</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> volvi贸 contra ML por temor a perder el mercado de herramientas de an谩lisis est谩tico.</font></font><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/659/1f4/7fa/6591f47faa384c2ac9472bc1f5eeacb9.png" alt="Luditas"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No, no tenemos miedo. Simplemente no vemos el punto de gastar dinero en enfoques ineficientes en el desarrollo del analizador de c贸digo PVS-Studio. De una forma u otra, adoptaremos ML. Adem谩s, algunos diagn贸sticos ya contienen elementos de algoritmos de autoaprendizaje. Sin embargo, definitivamente seremos muy conservadores y tomaremos solo lo que claramente tendr谩 un mayor efecto que los enfoques cl谩sicos, construidos en bucles e ifs :). Despu茅s de todo, necesitamos crear una herramienta efectiva, no trabajar con una subvenci贸n :). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El art铆culo est谩 escrito porque cada vez se hacen m谩s preguntas sobre el tema y quer铆amos tener un art铆culo expositivo que pusiera todo en su lugar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gracias por su atencion Te invitamos a leer el art铆culo "</font></font><a href="https://www.viva64.com/en/b/0687/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por qu茅 deber铆a elegir el analizador est谩tico PVS-Studio para integrarlo en su proceso de desarrollo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ".</font></font></div></div><p>Source: <a href="https://habr.com/ru/post/484202/">https://habr.com/ru/post/484202/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../484192/index.html">Aplicaciones f谩ciles y f谩ciles de implementar en el cartucho de Tarantool (parte 2)</a></li>
<li><a href="../484194/index.html">Kubernetes traducido a ni帽os</a></li>
<li><a href="../484196/index.html">Grabar sonido JS desde un micr贸fono o comentarios de voz</a></li>
<li><a href="../484198/index.html">Reverso de la moneda: qui茅n gan贸 y perdi贸 con el crecimiento de las acciones de Tesla</a></li>
<li><a href="../484200/index.html">C贸mo establecer objetivos para alcanzarlos</a></li>
<li><a href="../484204/index.html">El ransomware sin archivos FTCODE ahora roba cuentas</a></li>
<li><a href="../484206/index.html">Uso de mixins en Dart</a></li>
<li><a href="../484208/index.html">Uso del aprendizaje autom谩tico en el an谩lisis est谩tico del c贸digo fuente del programa</a></li>
<li><a href="../484212/index.html">Cosas gratis para el karma: la historia de una startup bielorrusa que cambia el principio de consumo</a></li>
<li><a href="../484214/index.html">Tensores en TensorFlow</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>