<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÜüèø ü§î üìô Wir schreiben einen einfachen √úbersetzer in Lisp - III üîπ üë©üèæ‚Äçü§ù‚Äçüë®üèª üßíüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vorheriger Artikel 

 Fehler, Fehler, Fehler ... 
 Ein gutes Programm sollte vor Benutzerfehlern gesch√ºtzt werden. Das ist absolut sicher. Fehler m√ºss...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir schreiben einen einfachen √úbersetzer in Lisp - III</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423663/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vorheriger Artikel</a> <br><br><h3>  Fehler, Fehler, Fehler ... </h3><br>  Ein gutes Programm sollte vor Benutzerfehlern gesch√ºtzt werden.  Das ist absolut sicher.  Fehler m√ºssen behandelt und noch besser gewarnt werden (Vorbeugen ist immer besser als Heilen!).  Kunstflug - Bauen Sie also einen Dialog mit dem Benutzer auf, damit dieser einfach keinen Fehler machen kann. <br><a name="habracut"></a><br>  Wenn der Benutzer beispielsweise eine positive Ganzzahl in das Eingabefeld eingeben muss, k√∂nnen Sie nat√ºrlich die Antwort analysieren. Wenn Sie nicht numerische Zeichen finden, geben Sie eine Warnung aus und bitten Sie den Benutzer, die Eingabe zu wiederholen.  Es ist jedoch viel besser, die Eingabe nicht numerischer Zeichen einfach zu verbieten! <br><br>  Leider kann eine solche Technik nicht immer angewendet werden.  Insbesondere ist die Vielfalt der Designs, die an die Eingabe des √úbersetzers gelangen, zu gro√ü, um durch Einstellen der Eingabemaske einfach ‚Äûdie falschen abzuschneiden‚Äú. <br><br>  Eine Person hat das Privileg, Fehler zu machen, und der √úbersetzer sollte im Falle der Eingabe falscher Sprachkonstrukte eine eindeutige Diagnose stellen und den Quelltext nach M√∂glichkeit weiter analysieren, um alle Fehler zu identifizieren.  Dem Benutzer wird es wahrscheinlich nicht wirklich gefallen, wenn der √úbersetzer "nacheinander" Fehler entdeckt.  Und es ist absolut inakzeptabel, eine Situation zu erkennen, in der ein Programm mit einer Systemfehlermeldung "abst√ºrzt". <br>  In diesem Artikel werden wir den zuvor entwickelten Code kritisch durchgehen und versuchen, m√∂gliche Fehler zu verhindern (zu verarbeiten). <br><br>  Beginnen wir mit der ersten Startfunktion.  Was macht sie?  Sie nimmt den Namen der Eingabedatei, √∂ffnet sie und verarbeitet sie zeilenweise.  F√ºr solche Programme hat sich das Benutzerinteraktionsszenario bereits ‚Äûberuhigt‚Äú - es kann als kanonisch angesehen werden: <br><br><ul><li>  Wenn der Dateiname nicht angegeben ist, rufen Sie das Standarddialogfeld "√ñffnen" auf. </li><li>  Wenn der Benutzer im Dialogfeld "√ñffnen" auf die Schaltfl√§che "Ablehnen" geklickt hat - Herunterfahren; </li><li>  √úberpr√ºfen Sie, ob die Datei mit dem angegebenen / eingegebenen Namen vorhanden ist.  Wenn es nicht vorhanden ist, geben Sie eine Nachricht aus und beenden Sie das Programm. </li><li>  Wenn die angegebene Datei vorhanden ist, verarbeiten Sie sie. </li></ul><br>  Unsere Version des Startvorgangs erf√ºllt dieses Szenario nicht.  Schauen Sie sich den folgenden Code an: <br><br><pre><code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> start (<span class="hljs-name"><span class="hljs-name">&amp;optional</span></span> (<span class="hljs-name"><span class="hljs-name">fname</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *numline* <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *oplist* ‚Ä¶) <span class="hljs-comment"><span class="hljs-comment">;;      (when (zerop (strLen fname)) (setq fname (sysGetOpenName (sysHome) "-|*.mbs"))) (let ((fi (gensym 'fi))) (filOpen fi fname _INPUT) (loop (let ((curr-proc (action-proc fi))) (when *flagerr* (return t)) (when (filEOF fi) (return t)) (eval curr-proc))) (filClose fi)) (when *flagerr* (printsline "****   ")))</span></span></code> </pre> <br>  Die negative Reaktion des Benutzers wird nicht analysiert. Wenn also die Schaltfl√§che "Ablehnen" gedr√ºckt wird, st√ºrzt das Programm ab.  Das Vorhandensein der Datei wird ebenfalls nicht analysiert.  Leider ist dieser Fehler nicht auf M√§ngel beschr√§nkt.  Wenn die Mini-Basic-Prozedur die letzte in der Eingabedatei ist, f√ºhrt die Analyse des Dateiende offensichtlich dazu, dass der Zyklus unterbrochen wird, bevor die generierte Funktion in die Lisp-Umgebung geladen wird. <br><br>  Korrigieren Sie diese Fehler: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> start (<span class="hljs-name"><span class="hljs-name">&amp;optional</span></span> (<span class="hljs-name"><span class="hljs-name">fname</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *numline* <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *oplist* ‚Ä¶ ) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">zerop</span></span> (<span class="hljs-name"><span class="hljs-name">strLen</span></span> fname)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> fname (<span class="hljs-name"><span class="hljs-name">sysGetOpenName</span></span> (<span class="hljs-name"><span class="hljs-name">sysHome</span></span>) <span class="hljs-string"><span class="hljs-string">"-|*.mbs"</span></span>))) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> fname (<span class="hljs-name"><span class="hljs-name">filExistp</span></span> fname)) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">fi</span></span> (<span class="hljs-name"><span class="hljs-name">gensym</span></span> 'fi))) (<span class="hljs-name"><span class="hljs-name">filOpen</span></span> fi fname _INPUT) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">curr-proc</span></span> (<span class="hljs-name"><span class="hljs-name">action-proc</span></span> fi))) (<span class="hljs-name"><span class="hljs-name">when</span></span> *flagerr* (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) (<span class="hljs-name"><span class="hljs-name">when</span></span> curr-proc (<span class="hljs-name"><span class="hljs-name">eval</span></span> curr-proc)) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">filEOF</span></span> fi) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)))) (<span class="hljs-name"><span class="hljs-name">filClose</span></span> fi) (<span class="hljs-name"><span class="hljs-name">when</span></span> *flagerr* (<span class="hljs-name"><span class="hljs-name">printsline</span></span> <span class="hljs-string"><span class="hljs-string">"****   "</span></span>))) (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">if</span></span> fname (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"****  "</span></span> fname <span class="hljs-string"><span class="hljs-string">"  "</span></span>) <span class="hljs-string"><span class="hljs-string">"****   "</span></span>))) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*numline*) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*flagerr*) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*oplist*))</code> </pre><br>  Wenn der Dateiname angegeben ist und die Datei vorhanden ist, wird die Verarbeitung durchgef√ºhrt.  Andernfalls wird eine der Meldungen gedruckt: "Datei existiert nicht" oder "Dateiname weggelassen". <br>  Die folgenden Aktionen werden nacheinander im Hauptteil der Hauptschleife ausgef√ºhrt: <br><br><ul><li>  Funktion action-proc ist erf√ºllt.  Das Ergebnis seiner Arbeit wird in der lokalen Variablen curr-proc gespeichert; </li><li>  Wenn das Flag * flagerr * gesetzt ist, wird die Schleife unterbrochen. </li><li>  Wenn die action-proc-Funktion ein nicht leeres Ergebnis zur√ºckgegeben hat, wird die generierte Funktion in die Lisp-Umgebung geladen. </li><li>  Wenn das Ende der Datei erreicht ist, wird auch die Schleife unterbrochen. </li></ul><br>  Der Code schien besser zu sein ... Ein weiterer schwerwiegender Fehler blieb jedoch ungel√∂st. Nachdem die Verarbeitung der Prozedur mit einem oder mehreren Fehlern abgeschlossen ist, wird die Hauptschleife unterbrochen und das Programm wird beendet, ohne den Teil des urspr√ºnglichen Jahres zu betrachten, der sich hinter der Prozedur mit Fehlern befindet.  Das ist schlecht - ich m√∂chte, dass der √úbersetzer alle Fehler erzeugt, die bei jedem Start erkannt werden k√∂nnen. <br><br>  Um diesen Fehler zu beheben, f√ºhren wir die globale Variable "Fehlerz√§hler" ein. W√§hrend wir die Prozedur mit Fehlern verarbeiten, erh√∂hen wir diesen Z√§hler.  Und das Fehlerflag wird nach jeder Prozedur zur√ºckgesetzt: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> start (<span class="hljs-name"><span class="hljs-name">&amp;optional</span></span> (<span class="hljs-name"><span class="hljs-name">fname</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *numline* <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *errcount* <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *oplist* ‚Ä¶) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">zerop</span></span> (<span class="hljs-name"><span class="hljs-name">strLen</span></span> fname)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> fname (<span class="hljs-name"><span class="hljs-name">sysGetOpenName</span></span> (<span class="hljs-name"><span class="hljs-name">sysHome</span></span>) <span class="hljs-string"><span class="hljs-string">"-|*.mbs"</span></span>))) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> fname (<span class="hljs-name"><span class="hljs-name">filExistp</span></span> fname)) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">fi</span></span> (<span class="hljs-name"><span class="hljs-name">gensym</span></span> 'fi))) (<span class="hljs-name"><span class="hljs-name">filCloseAll</span></span>) (<span class="hljs-name"><span class="hljs-name">filOpen</span></span> fi fname _INPUT) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">curr-proc</span></span> (<span class="hljs-name"><span class="hljs-name">action-proc</span></span> fi))) (<span class="hljs-name"><span class="hljs-name">when</span></span> *flagerr* (<span class="hljs-name"><span class="hljs-name">setq</span></span> *errcount* (<span class="hljs-name"><span class="hljs-name">add1</span></span> *errcount*))) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> curr-proc (<span class="hljs-name"><span class="hljs-name">not</span></span> *flagerr*)) (<span class="hljs-name"><span class="hljs-name">eval</span></span> curr-proc)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">filEOF</span></span> fi) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)))) (<span class="hljs-name"><span class="hljs-name">filClose</span></span> fi) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> *errcount* <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">printsline</span></span> <span class="hljs-string"><span class="hljs-string">"****   "</span></span>))) (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">if</span></span> fname (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"****  "</span></span> fname <span class="hljs-string"><span class="hljs-string">"  "</span></span>) <span class="hljs-string"><span class="hljs-string">"****   "</span></span>))) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*numline*) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*flagerr*) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*oplist*) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*errcount*))</code> </pre><br>  Jetzt funktioniert die Startfunktion akzeptabel.  Stellen wir das sicher.  Erstellen Sie die folgende Quelldatei: <br><br><pre> <code class="hljs 1c">* * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test1</span></span></span><span class="hljs-function">(x)</span></span> local y y=x^<span class="hljs-number"><span class="hljs-number">2</span></span> bla-bla end_proc * * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test2</span></span></span><span class="hljs-function">()</span></span> local x,y input x y=test1(x) print y end_proc * * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test3</span></span></span><span class="hljs-function">(x)</span></span> bla-bla-bla print x end_proc</code> </pre><br>  Und lassen Sie es durch unseren √úbersetzer gehen.  Wir bekommen: <br><br><pre> <code class="hljs 1c"><span class="hljs-number"><span class="hljs-number">0001</span></span> * <span class="hljs-number"><span class="hljs-number">0002</span></span> * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> 0003 * 0004 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test1</span></span></span><span class="hljs-function">(x)</span></span> <span class="hljs-number"><span class="hljs-number">0005</span></span> local y <span class="hljs-number"><span class="hljs-number">0006</span></span> y=x^<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">0007</span></span> bla-bla ****  (BLA - BLA) <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  <span class="hljs-number"><span class="hljs-number">0008</span></span> end_proc <span class="hljs-number"><span class="hljs-number">0009</span></span> * <span class="hljs-number"><span class="hljs-number">0010</span></span> * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> 0011 * 0012 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test2</span></span></span><span class="hljs-function">()</span></span> <span class="hljs-number"><span class="hljs-number">0013</span></span> local x,y <span class="hljs-number"><span class="hljs-number">0014</span></span> input x <span class="hljs-number"><span class="hljs-number">0015</span></span> y=test1(x) <span class="hljs-number"><span class="hljs-number">0016</span></span> print y <span class="hljs-number"><span class="hljs-number">0017</span></span> end_proc <span class="hljs-number"><span class="hljs-number">0018</span></span> * <span class="hljs-number"><span class="hljs-number">0019</span></span> * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> 0020 * 0021 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test3</span></span></span><span class="hljs-function">(x)</span></span> <span class="hljs-number"><span class="hljs-number">0022</span></span> bla-bla-bla ****  (BLA - BLA - BLA) <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  <span class="hljs-number"><span class="hljs-number">0023</span></span> print x <span class="hljs-number"><span class="hljs-number">0024</span></span> end_proc <span class="hljs-number"><span class="hljs-number">0025</span></span> ****   </code> </pre><br>  Wir gehen davon aus, dass wir mit der Startfunktion fertig geworden sind.  Aber die ‚ÄûArbeit an den Fehlern‚Äú hat gerade erst begonnen.  Schauen wir uns die Syntax des Teils der Sprache an, den wir bereits implementiert haben. <br><br>  Der wahrscheinlich h√§ufigste Syntaxfehler, den Menschen am h√§ufigsten machen, ist eine falsche Klammerstruktur (unausgeglichen oder in Klammern in falscher Reihenfolge).  Erinnern Sie sich daran, was mit einer Zeile Quellcode f√ºr ein Mini-Basisprogramm passiert, nachdem es gelesen wurde.  Die Zeichenfolge wird analysiert (in Token unterteilt), und dann wird die Liste der Token in eine interne Listenform √ºbersetzt.  In der Liste der Token sind Klammern separate Token, und wir √ºberpr√ºfen nicht ihren Kontostand.  Dies k√∂nnte als separate Funktion erfolgen, aber die Liste der Token wird an die Eingabe der Eingabefunktion √ºbertragen, die die Liste der Zeilen in die Lisp-Liste √ºbersetzt.  Wenn ein falscher Zeichenfolgenausdruck an die Eingabe der Eingabefunktion √ºbergeben wird, gibt die Funktion einen Fehler zur√ºck. <br><br>  Lassen Sie uns diesen Fehler behandeln. <br><br>  In HomeLisp wird ein Konstrukt verwendet, um Fehler zu behandeln (versuchen Sie es mit Ausdruck-1 au√üer Ausdruck-1).  Es funktioniert wie folgt: <br><br><ul><li>  Es wird versucht, Ausdruck 1 zu berechnen.  Wenn der Versuch erfolgreich ist, wird das Berechnungsergebnis als Ergebnis des gesamten Versuchsformulars zur√ºckgegeben. </li><li>  Wenn ein Fehler auftritt, wird Ausdruck 2 berechnet.  In diesem Fall steht eine Systemfunktion ohne Parameter (Fehlermeldung) zur Verf√ºgung, die den Text der Fehlermeldung zur√ºckgibt. </li></ul><br>  Auf der Grundlage des Vorstehenden kann die √úbertragung auf das Listenformular wie folgt erfolgen: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> mk-intf (<span class="hljs-name"><span class="hljs-name">txt</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">lex</span></span> (<span class="hljs-name"><span class="hljs-name">parser</span></span> txt <span class="hljs-string"><span class="hljs-string">" ,"</span></span> <span class="hljs-string"><span class="hljs-string">"()+-*/\^=&lt;&gt;%"</span></span>)) (<span class="hljs-name"><span class="hljs-name">intf</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">iter</span></span> (<span class="hljs-name"><span class="hljs-name">for</span></span> a in lex) (<span class="hljs-name"><span class="hljs-name">setq</span></span> intf (<span class="hljs-name"><span class="hljs-name">strCat</span></span> intf a <span class="hljs-string"><span class="hljs-string">" "</span></span>))) (<span class="hljs-name"><span class="hljs-name">try</span></span> (<span class="hljs-name"><span class="hljs-name">input</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"("</span></span> intf <span class="hljs-string"><span class="hljs-string">")"</span></span>)) except (<span class="hljs-name"><span class="hljs-name">progn</span></span> (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"**** "</span></span> (<span class="hljs-name"><span class="hljs-name">errormessage</span></span>))) `(,txt) ))))</code> </pre><br>  Im Falle eines Konvertierungsfehlers wird eine Systemnachricht ausgegeben, und als Ergebnis wird eine Liste eines Elements zur√ºckgegeben - die urspr√ºngliche Codezeile.  Ferner wird diese Liste (als n√§chste Aussage) in das action-proc-Verfahren fallen.  Und nat√ºrlich wird es nicht erkannt.  Dies erzeugt eine weitere Fehlermeldung und der Compiler arbeitet weiter.  Wir werden den folgenden Quellcode vorbereiten und versuchen, ihn zu √ºbersetzen: <br><br><pre> <code class="hljs 1c">* * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test1</span></span></span><span class="hljs-function">(x)</span></span> local y y=(x^<span class="hljs-number"><span class="hljs-number">2</span></span>)) end_proc * * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test2</span></span></span><span class="hljs-function">()</span></span> local x,y input x y=test1(x) print y end_proc * * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test3</span></span></span><span class="hljs-function">(x)</span></span> x=<span class="hljs-number"><span class="hljs-number">3</span></span>+)x^<span class="hljs-number"><span class="hljs-number">2</span></span> print x end_proc</code> </pre><br>  Wir erhalten das erwartete Ergebnis: <br><br><pre> <code class="hljs 1c"><span class="hljs-number"><span class="hljs-number">0001</span></span> * <span class="hljs-number"><span class="hljs-number">0002</span></span> * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> 0003 * 0004 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test1</span></span></span><span class="hljs-function">(x)</span></span> <span class="hljs-number"><span class="hljs-number">0005</span></span> local y <span class="hljs-number"><span class="hljs-number">0006</span></span> y=(x^<span class="hljs-number"><span class="hljs-number">2</span></span>)) ****    <span class="hljs-keyword"><span class="hljs-keyword"></span></span>   <span class="hljs-type"><span class="hljs-type"></span></span> ****  (<span class="hljs-string"><span class="hljs-string">"y=(x^2))"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  <span class="hljs-number"><span class="hljs-number">0007</span></span> end_proc <span class="hljs-number"><span class="hljs-number">0008</span></span> * <span class="hljs-number"><span class="hljs-number">0009</span></span> * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> 0010 * 0011 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test2</span></span></span><span class="hljs-function">()</span></span> <span class="hljs-number"><span class="hljs-number">0012</span></span> local x,y <span class="hljs-number"><span class="hljs-number">0013</span></span> input x <span class="hljs-number"><span class="hljs-number">0014</span></span> y=test1(x) <span class="hljs-number"><span class="hljs-number">0015</span></span> print y <span class="hljs-number"><span class="hljs-number">0016</span></span> end_proc <span class="hljs-number"><span class="hljs-number">0017</span></span> * <span class="hljs-number"><span class="hljs-number">0018</span></span> * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> 0019 * 0020 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test3</span></span></span><span class="hljs-function">(x)</span></span> <span class="hljs-number"><span class="hljs-number">0021</span></span> x=<span class="hljs-number"><span class="hljs-number">3</span></span>+)x^<span class="hljs-number"><span class="hljs-number">2</span></span> ****    <span class="hljs-keyword"><span class="hljs-keyword"></span></span>   <span class="hljs-type"><span class="hljs-type"></span></span> ****  (<span class="hljs-string"><span class="hljs-string">"x=3+)x^2"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  <span class="hljs-number"><span class="hljs-number">0022</span></span> print x <span class="hljs-number"><span class="hljs-number">0023</span></span> end_proc ****   </code> </pre><br>  Schauen wir uns nun den Code an, der arithmetische Ausdr√ºcke in eine Pr√§fixnotation konvertiert.  Dieser Code enth√§lt keine Mittel zur Behebung von Benutzerfehlern.  Leider k√∂nnen diese Fehler ziemlich viel sein.  Beheben wir diesen Fehler.  Versuchen wir zun√§chst, einen v√∂llig unschuldigen Code (in Erscheinung) zu √ºbersetzen: <br><br><pre> <code class="hljs bash">proc <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>() <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> x,y x=6 y=-x <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> y end_proc</code> </pre><br>  Die Sendung endet mit dem ‚ÄûSturz‚Äú des √úbersetzers!  Ein Sturz f√ºhrt zum Operator y = -x.  Was ist los?  In einem un√§ren Minus!  Beim Konvertieren einer Formel von einer Infixform in eine Pr√§fixformel dachten wir irgendwie nicht, dass Minus ‚Äûzweiseitig‚Äú ist - es gibt ein bin√§res Minus (ein Operationszeichen) und ein un√§res Minus (ein Zeichen einer Zahl).  Unser Parser kennt diesen Unterschied nicht - er betrachtet alle Nachteile als bin√§r ... Was ist jetzt zu tun?  Um den bereits funktionierenden Code nicht zu zerst√∂ren, verwandeln wir alle un√§ren Nachteile in bin√§re.  Wie?  Aber sehr einfach.  Es ist ziemlich offensichtlich, dass das un√§re Minus nur in solchen Konstruktionen ‚Äûlebt‚Äú: <br><br>  "(-Etwas" <br>  "&gt; - Etwas" <br>  "&lt;-Something" <br>  "= Etwas" <br>  Nun, ganz am Anfang der Formel kann er sich auch treffen.  Wenn wir daher vor dem Aufbrechen in Token die folgenden Ersetzungen durchf√ºhren: <br><br>  "(-Etwas" =&gt; "(0-etwas") <br>  "&gt; -Something" =&gt; "&gt; 0-etwas" <br>  "&lt;-Something" =&gt; "&lt;0-etwas" <br>  "= Etwas" =&gt; "= 0 etwas" <br><br>  und wenn die Formel mit einem Minus beginnt, weisen wir dem Anfang der Formel Null zu, dann werden alle Minuspunkte bin√§r und der Fehler wird radikal beseitigt.  Rufen wir die Funktion auf, die die Konvertierung √ºber dem Namen prepro durchf√ºhrt.  So k√∂nnte es aussehen: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> prepro (<span class="hljs-name"><span class="hljs-name">s</span></span>) (<span class="hljs-name"><span class="hljs-name">let*</span></span> ((<span class="hljs-name"><span class="hljs-name">s0</span></span> (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> <span class="hljs-string"><span class="hljs-string">"-"</span></span> (<span class="hljs-name"><span class="hljs-name">strLeft</span></span> s <span class="hljs-number"><span class="hljs-number">1</span></span>)) (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"0"</span></span> s) s)) (<span class="hljs-name"><span class="hljs-name">s1</span></span> (<span class="hljs-name"><span class="hljs-name">strRep</span></span> s0 <span class="hljs-string"><span class="hljs-string">"(-"</span></span> <span class="hljs-string"><span class="hljs-string">"(0-"</span></span>)) (<span class="hljs-name"><span class="hljs-name">s2</span></span> (<span class="hljs-name"><span class="hljs-name">strRep</span></span> s1 <span class="hljs-string"><span class="hljs-string">"=-"</span></span> <span class="hljs-string"><span class="hljs-string">"=0-"</span></span>)) (<span class="hljs-name"><span class="hljs-name">s3</span></span> (<span class="hljs-name"><span class="hljs-name">strRep</span></span> s2 <span class="hljs-string"><span class="hljs-string">"&gt;-"</span></span> <span class="hljs-string"><span class="hljs-string">"&gt;0-"</span></span>)) (<span class="hljs-name"><span class="hljs-name">s4</span></span> (<span class="hljs-name"><span class="hljs-name">strRep</span></span> s3 <span class="hljs-string"><span class="hljs-string">"&lt;-"</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;0-"</span></span>))) s4))</code> </pre><br>  Hier sind keine besonderen Kommentare erforderlich.  Unser einfacher Parser hat jedoch ein anderes Problem, das auf den ersten Blick nicht ganz offensichtlich ist - doppelte Anzeichen von Operationen.  Bei der Arbeit mit Formeln bedeuten die nebeneinander stehenden Zeichen ‚Äû&gt;‚Äú und ‚Äû=‚Äú eine Operation ‚Äû&gt; =‚Äú (und m√ºssen ein Token sein!).  Der Parser m√∂chte dies nicht wissen - er macht jedes der Zeichen zu einem separaten Token.  Sie k√∂nnen dieses Problem l√∂sen, indem Sie sich die Liste der empfangenen Token ansehen und durch Kombinieren die entsprechenden Zeichen nebeneinander anzeigen.  Wir benennen die Funktion, die die Vereinigung ausf√ºhrt, mit dem Namen "postpro".  Hier ist der Code f√ºr eine m√∂gliche Implementierung: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> postpro (<span class="hljs-name"><span class="hljs-name">lex-list</span></span>) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">null</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> lex-list)) lex-list) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">c1</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> lex-list)) (<span class="hljs-name"><span class="hljs-name">c2</span></span> (<span class="hljs-name"><span class="hljs-name">cadr</span></span> lex-list))) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> c1 <span class="hljs-string"><span class="hljs-string">"&gt;"</span></span>) (<span class="hljs-name"><span class="hljs-name">eq</span></span> c2 <span class="hljs-string"><span class="hljs-string">"="</span></span>)) (<span class="hljs-name"><span class="hljs-name">cons</span></span> <span class="hljs-string"><span class="hljs-string">"&gt;="</span></span> (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">cddr</span></span> lex-list)))) ((<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> c1 <span class="hljs-string"><span class="hljs-string">"&lt;"</span></span>) (<span class="hljs-name"><span class="hljs-name">eq</span></span> c2 <span class="hljs-string"><span class="hljs-string">"="</span></span>)) (<span class="hljs-name"><span class="hljs-name">cons</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;="</span></span> (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">cddr</span></span> lex-list)))) ((<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> c1 <span class="hljs-string"><span class="hljs-string">"="</span></span>) (<span class="hljs-name"><span class="hljs-name">eq</span></span> c2 <span class="hljs-string"><span class="hljs-string">"="</span></span>)) (<span class="hljs-name"><span class="hljs-name">cons</span></span> <span class="hljs-string"><span class="hljs-string">"=="</span></span> (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">cddr</span></span> lex-list)))) ((<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> c1 <span class="hljs-string"><span class="hljs-string">"&lt;"</span></span>) (<span class="hljs-name"><span class="hljs-name">eq</span></span> c2 <span class="hljs-string"><span class="hljs-string">"&gt;"</span></span>)) (<span class="hljs-name"><span class="hljs-name">cons</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;&gt;"</span></span> (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">cddr</span></span> lex-list)))) ((<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> c1 <span class="hljs-string"><span class="hljs-string">"&gt;"</span></span>) (<span class="hljs-name"><span class="hljs-name">eq</span></span> c2 <span class="hljs-string"><span class="hljs-string">"&lt;"</span></span>)) (<span class="hljs-name"><span class="hljs-name">cons</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;&gt;"</span></span> (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">cddr</span></span> lex-list)))) ((<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> c1 <span class="hljs-string"><span class="hljs-string">"!"</span></span>) (<span class="hljs-name"><span class="hljs-name">eq</span></span> c2 <span class="hljs-string"><span class="hljs-string">"="</span></span>)) (<span class="hljs-name"><span class="hljs-name">cons</span></span> <span class="hljs-string"><span class="hljs-string">"/="</span></span> (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">cddr</span></span> lex-list)))) ((<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> c1 <span class="hljs-string"><span class="hljs-string">"/"</span></span>) (<span class="hljs-name"><span class="hljs-name">eq</span></span> c2 <span class="hljs-string"><span class="hljs-string">"="</span></span>)) (<span class="hljs-name"><span class="hljs-name">cons</span></span> <span class="hljs-string"><span class="hljs-string">"/="</span></span> (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">cddr</span></span> lex-list)))) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> c1 (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> lex-list)))))))))</code> </pre><br>  Auch, wie wir sehen, nichts Besonderes.  Die endg√ºltige Funktion zum √úbersetzen des Operators in das interne Listenformular sieht nun folgenderma√üen aus: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> mk-intf (<span class="hljs-name"><span class="hljs-name">txt</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">lex</span></span> (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">parser</span></span> (<span class="hljs-name"><span class="hljs-name">prepro</span></span> txt) <span class="hljs-string"><span class="hljs-string">" ,"</span></span> <span class="hljs-string"><span class="hljs-string">"()+-*/\^=&lt;&gt;%"</span></span>))) (<span class="hljs-name"><span class="hljs-name">intf</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">iter</span></span> (<span class="hljs-name"><span class="hljs-name">for</span></span> a in lex) (<span class="hljs-name"><span class="hljs-name">setq</span></span> intf (<span class="hljs-name"><span class="hljs-name">strCat</span></span> intf a <span class="hljs-string"><span class="hljs-string">" "</span></span>))) (<span class="hljs-name"><span class="hljs-name">try</span></span> (<span class="hljs-name"><span class="hljs-name">input</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"("</span></span> intf <span class="hljs-string"><span class="hljs-string">")"</span></span>)) except (<span class="hljs-name"><span class="hljs-name">progn</span></span> (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"**** "</span></span> (<span class="hljs-name"><span class="hljs-name">errormessage</span></span>))) `(,txt) ))))</code> </pre><br>  Schauen wir uns nun die inf2ipn-Funktion kritisch an.  Welche Benutzerfehler k√∂nnen es "beschuldigen"?  Wir haben das Ungleichgewicht der obigen Klammern bereits beseitigt.  Was k√∂nnte mehr sein?  Zwei Zeichen der Operation oder zwei Operanden, die in einer Reihe stehen.  Man k√∂nnte dies im inf2ipn-Code analysieren (und diejenigen, die dies w√ºnschen, k√∂nnen dies selbst tun).  Diese Fehler werden jedoch bereits beim Konvertieren der Formel vom SCR in das Pr√§fix "erfasst".  Und lassen Sie uns (nur f√ºr den Fall) alle Fehler abfangen, die bei der Konvertierung der Formel vom Infix zum Pr√§fix auftreten k√∂nnen.  Der beste Ort daf√ºr ist die i2p-Wrapper-Funktion.  Jetzt k√∂nnte es so aussehen: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> i2p (<span class="hljs-name"><span class="hljs-name">f</span></span>) (<span class="hljs-name"><span class="hljs-name">try</span></span> (<span class="hljs-name"><span class="hljs-name">ipn2pref</span></span> (<span class="hljs-name"><span class="hljs-name">inf2ipn</span></span> f)) except (<span class="hljs-name"><span class="hljs-name">progn</span></span> (<span class="hljs-name"><span class="hljs-name">printsline</span></span> <span class="hljs-string"><span class="hljs-string">"****    "</span></span>) (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"**** "</span></span> (<span class="hljs-name"><span class="hljs-name">errormessage</span></span>))) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">t</span></span>) <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)))</code> </pre><br>  Und jetzt verhindern wir das Auftreten von zwei Operationszeichen oder zwei Operanden hintereinander in Formeln.  Im vorherigen Artikel wurde ein Algorithmus zum √úbersetzen einer Formel aus einem SCR in ein Pr√§fixformular beschrieben.  Ein Zeichen f√ºr die korrekte Vervollst√§ndigung dieses Algorithmus ist, dass der Stapel im letzten Schritt einen einzelnen Wert enthalten sollte.  Ist dies nicht der Fall, wurde ein Fehler gemacht.  Eine weitere fehlerhafte Situation tritt auf, wenn die Funktion mit der falschen (mehr oder weniger) Anzahl von Parametern aufgerufen wird.  Diese Situationen sollten "gefangen" werden: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> ipn2pref (<span class="hljs-name"><span class="hljs-name">f</span></span> <span class="hljs-symbol"><span class="hljs-symbol">&amp;optional</span></span> (<span class="hljs-name"><span class="hljs-name">s</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">null</span></span> f) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">null</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> s)) (<span class="hljs-name"><span class="hljs-name">car</span></span> s) (<span class="hljs-name"><span class="hljs-name">progn</span></span> (<span class="hljs-name"><span class="hljs-name">printsline</span></span> <span class="hljs-string"><span class="hljs-string">"****    "</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">t</span></span>) <span class="hljs-literal"><span class="hljs-literal">nil</span></span>))) ((<span class="hljs-name"><span class="hljs-name">numberp</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f)) (<span class="hljs-name"><span class="hljs-name">ipn2pref</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> f) (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f) s))) ((<span class="hljs-name"><span class="hljs-name">is-op</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f)) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">ar</span></span> (<span class="hljs-name"><span class="hljs-name">arity</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f)))) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">&lt;</span></span> (<span class="hljs-name"><span class="hljs-name">length</span></span> s) ar) (<span class="hljs-name"><span class="hljs-name">progn</span></span> (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">t</span></span>) (<span class="hljs-name"><span class="hljs-name">printsline</span></span> <span class="hljs-string"><span class="hljs-string">"****    "</span></span>) <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">ipn2pref</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> f) (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f) (<span class="hljs-name"><span class="hljs-name">reverse</span></span> (<span class="hljs-name"><span class="hljs-name">subseq</span></span> s <span class="hljs-number"><span class="hljs-number">0</span></span> ar))) (<span class="hljs-name"><span class="hljs-name">subseq</span></span> s ar)))))) ((<span class="hljs-name"><span class="hljs-name">atom</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f)) (<span class="hljs-name"><span class="hljs-name">ipn2pref</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> f) (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f) s))) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">ipn2pref</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> f) (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f) (<span class="hljs-name"><span class="hljs-name">car</span></span> s)) (<span class="hljs-name"><span class="hljs-name">cdr</span></span> s))))))</code> </pre><br>  Schauen wir uns nun den proc-Anweisungshandler kritisch an.  Wir haben zwei Punkte deutlich verpasst.  Das erste, was Sie tun m√ºssen, ist, bei der Verarbeitung der Prozedur zur Berechnung ihrer Arit√§t (Anzahl der Argumente) nicht zu vergessen und die globale Variable * oplist * entsprechend zu √§ndern.  Und das zweite ist, dass die von uns generierten Funktionen nicht den richtigen Wert zur√ºckgeben!  Genauer gesagt wird aufgrund der von unserem √úbersetzer generierten Funktionen der Wert des zuletzt vor der R√ºckgabe berechneten Formulars zur√ºckgegeben.  Um die R√ºckgabe des gew√ºnschten Wertes zu gew√§hrleisten, schlage ich vor, die Ergebnisvariable von Pascal zu √ºbertragen.  Geben Sie nun bei Bedarf den gew√ºnschten Wert zur√ºck. Es reicht aus, wenn der Benutzer dieser Variablen vor dem Beenden der Funktion den gew√ºnschten Wert zuweist. Wenn Sie den Hauptteil der Funktion generieren, m√ºssen Sie den Namen result in den Funktionsk√∂rper mit dem letzten Ausdruck einf√ºgen.  All dies bringt die Action-Proc-Funktion zu: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> action-proc (<span class="hljs-name"><span class="hljs-name">fi</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">stmt</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">proc-name</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">proc-parm</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">loc-var</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">lv</span></span> '((result <span class="hljs-number"><span class="hljs-number">0</span></span>))) (<span class="hljs-name"><span class="hljs-name">body</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">setq</span></span> stmt (<span class="hljs-name"><span class="hljs-name">mk-intf</span></span> (<span class="hljs-name"><span class="hljs-name">getLine</span></span> fi))) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">null</span></span> stmt) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'proc) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-name (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> stmt)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-parm (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> stmt)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *oplist* (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">list</span></span> proc-name (<span class="hljs-name"><span class="hljs-name">length</span></span> proc-parm)) *oplist*))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'end_proc) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'print) (<span class="hljs-name"><span class="hljs-name">setq</span></span> body (<span class="hljs-name"><span class="hljs-name">append</span></span> body (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> 'printline (<span class="hljs-name"><span class="hljs-name">cdr</span></span> stmt)))))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'input) (<span class="hljs-name"><span class="hljs-name">setq</span></span> body (<span class="hljs-name"><span class="hljs-name">append</span></span> body (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">list</span></span> 'setq (<span class="hljs-name"><span class="hljs-name">cadr</span></span> stmt) (<span class="hljs-name"><span class="hljs-name">list</span></span> 'read) ))))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'local) (<span class="hljs-name"><span class="hljs-name">setq</span></span> loc-var (<span class="hljs-name"><span class="hljs-name">append</span></span> loc-var (<span class="hljs-name"><span class="hljs-name">cdr</span></span> stmt)))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">cadr</span></span> stmt) '=) (<span class="hljs-name"><span class="hljs-name">setq</span></span> body (<span class="hljs-name"><span class="hljs-name">append</span></span> body (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">action-set</span></span> stmt))))) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"****  "</span></span> (<span class="hljs-name"><span class="hljs-name">output</span></span> stmt) <span class="hljs-string"><span class="hljs-string">"  "</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">t</span></span>)))) (<span class="hljs-name"><span class="hljs-name">iter</span></span> (<span class="hljs-name"><span class="hljs-name">for</span></span> a in (<span class="hljs-name"><span class="hljs-name">setof</span></span> loc-var)) (<span class="hljs-name"><span class="hljs-name">collecting</span></span> (<span class="hljs-name"><span class="hljs-name">list</span></span> a <span class="hljs-number"><span class="hljs-number">0</span></span>) into lv)) (<span class="hljs-name"><span class="hljs-name">if</span></span> proc-name `(defun ,proc-name ,proc-parm (let ,lv ,@body result)) <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)))</code> </pre><br>  Wir werden hier vorerst aufh√∂ren (obwohl wir immer noch auf Probleme sto√üen werden und der Code finalisiert werden muss; aber das ist das Los des Programmierers ...) Und jetzt werden wir zwei Verbesserungen unserer Sprache in Betracht ziehen, die angemessen sind, um sie jetzt vorzunehmen. <br><br><h3>  Kleinere Verbesserungen ... </h3><br>  In einem fr√ºheren Artikel habe ich geschrieben, dass es f√ºr einen Programmierer unpraktisch ist, wenn in einer Sprache ein Operator genau eine Zeile belegt.  Es ist erforderlich, die M√∂glichkeit bereitzustellen, sperrige Anweisungen in mehrere Zeilen zu schreiben.  Lassen Sie uns dies implementieren.  Dies ist √ºberhaupt nicht schwer zu tun.  In der getLine-Prozedur erstellen wir eine lokale Variable, in der wir den gelesenen Text akkumulieren (vorausgesetzt, dies ist kein Kommentar und endet mit ein paar "_" -Zeichen. Sobald eine signifikante Zeile mit einer anderen Endung festgelegt ist, geben wir den akkumulierten Wert als Wert zur√ºck. Hier ist der Code: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> getLine (<span class="hljs-name"><span class="hljs-name">fil</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">stri</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>) (<span class="hljs-name"><span class="hljs-name">res</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">filEof</span></span> fil) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *numline* (<span class="hljs-name"><span class="hljs-name">add1</span></span> *numline*)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> stri (<span class="hljs-name"><span class="hljs-name">filGetline</span></span> fil)) (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> (<span class="hljs-name"><span class="hljs-name">format</span></span> *numline* <span class="hljs-string"><span class="hljs-string">"0000"</span></span>) <span class="hljs-string"><span class="hljs-string">" "</span></span> (<span class="hljs-name"><span class="hljs-name">strRTrim</span></span> stri))) (<span class="hljs-name"><span class="hljs-name">unless</span></span> (<span class="hljs-name"><span class="hljs-name">or</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> stri) (<span class="hljs-name"><span class="hljs-name">eq</span></span> <span class="hljs-string"><span class="hljs-string">"*"</span></span> (<span class="hljs-name"><span class="hljs-name">strLeft</span></span> stri <span class="hljs-number"><span class="hljs-number">1</span></span>))) (<span class="hljs-name"><span class="hljs-name">setq</span></span> stri (<span class="hljs-name"><span class="hljs-name">strATrim</span></span> stri)) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> <span class="hljs-string"><span class="hljs-string">" _"</span></span>(<span class="hljs-name"><span class="hljs-name">strRight</span></span> stri <span class="hljs-number"><span class="hljs-number">2</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> res (<span class="hljs-name"><span class="hljs-name">strCat</span></span> res (<span class="hljs-name"><span class="hljs-name">strLeft</span></span> stri (<span class="hljs-name"><span class="hljs-name">-</span></span> (<span class="hljs-name"><span class="hljs-name">strLen</span></span> stri) <span class="hljs-number"><span class="hljs-number">2</span></span>)))) (<span class="hljs-name"><span class="hljs-name">setq</span></span> res (<span class="hljs-name"><span class="hljs-name">strCat</span></span> res stri))) (<span class="hljs-name"><span class="hljs-name">unless</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> <span class="hljs-string"><span class="hljs-string">" _"</span></span>(<span class="hljs-name"><span class="hljs-name">strRight</span></span> stri <span class="hljs-number"><span class="hljs-number">2</span></span>)) (<span class="hljs-name"><span class="hljs-name">return</span></span> res))))))</code> </pre><br>  Und die letzte Verbesserung.  In vielen Programmiersprachen k√∂nnen Sie logische Operanden in arithmetischen Ausdr√ºcken verwenden (die in diesem Fall auf Null oder Eins berechnet werden).  Dies verleiht der Sprache zus√§tzliche Ausdruckskraft und entspricht im √úbrigen durchaus dem Grundgeist.  In unserem Mini-BASIC lautet der Versuch, diesen Ausdruck zu berechnen, beispielsweise: <br><br><pre> <code class="hljs lisp">z=(<span class="hljs-name"><span class="hljs-name">x&gt;y</span></span>)*5+(<span class="hljs-name"><span class="hljs-name">x&lt;=y</span></span>)*10</code> </pre><br>  verursacht einen Laufzeitfehler.  Und das ist verst√§ndlich: In Lisp wird der Ausdruck (&gt; xy) zu Nil oder T berechnet. Aber Nil / T kann nicht mit 5 multipliziert werden ... Dieses Problem ist jedoch leicht zu beheben.  Schreiben wir einige einfache Makros, die das Ergebnis von Vergleichsausdr√ºcken durch 0/1 (anstelle von Nil / T) ersetzen: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defmacro</span></span> $= (<span class="hljs-name"><span class="hljs-name">xy</span></span>) `(if (= ,x ,y) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">defmacro</span></span> $== (<span class="hljs-name"><span class="hljs-name">xy</span></span>) `(if (= ,x ,y) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">defmacro</span></span> $&gt; (<span class="hljs-name"><span class="hljs-name">xy</span></span>) `(if (&gt; ,x ,y) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">defmacro</span></span> $&lt; (<span class="hljs-name"><span class="hljs-name">xy</span></span>) `(if (&lt; ,x ,y) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">defmacro</span></span> $/= (<span class="hljs-name"><span class="hljs-name">xy</span></span>) `(if (/= ,x ,y) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">defmacro</span></span> $&lt;&gt; (<span class="hljs-name"><span class="hljs-name">xy</span></span>) `(if (/= ,x ,y) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">defmacro</span></span> $&lt;= (<span class="hljs-name"><span class="hljs-name">xy</span></span>) `(if (&lt;= ,x ,y) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">defmacro</span></span> $&gt;= (<span class="hljs-name"><span class="hljs-name">xy</span></span>) `(if (&gt;= ,x ,y) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>))</code> </pre><br>  Schauen Sie sich nun die Zeile in der Funktion ipn2pref an, die die Verarbeitung der Operation ausf√ºhrt.  Hier ist die Zeile: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">ipn2pref</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> f) (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f) (<span class="hljs-name"><span class="hljs-name">reverse</span></span> (<span class="hljs-name"><span class="hljs-name">subseq</span></span> s <span class="hljs-number"><span class="hljs-number">0</span></span> ar))) (<span class="hljs-name"><span class="hljs-name">subseq</span></span> s ar)))</code> </pre><br>  Hier (Auto f) ist der Name der Operation.  Schreiben wir eine winzige Funktion, um Vergleichscodes zu ersetzen: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> chng-comp (<span class="hljs-name"><span class="hljs-name">op</span></span>) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">member</span></span> op '(= == /= &lt;&gt; &gt; &lt; &gt;= &lt;=)) (<span class="hljs-name"><span class="hljs-name">implode</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> '$ (<span class="hljs-name"><span class="hljs-name">explode</span></span> op))) op))</code> </pre><br>  Die Funktion pr√ºft, ob es sich bei ihrem Argument um eine Vergleichsoperation handelt, und h√§ngt bei Bedarf das Zeichen "$" an den Anfang an.  Rufen Sie es nun an der richtigen Stelle der ipn2pref-Funktion auf: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">ipn2pref</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> f) (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">chng-comp</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f)) (<span class="hljs-name"><span class="hljs-name">reverse</span></span> (<span class="hljs-name"><span class="hljs-name">subseq</span></span> s <span class="hljs-number"><span class="hljs-number">0</span></span> ar))) (<span class="hljs-name"><span class="hljs-name">subseq</span></span> s ar)))</code> </pre><br>  Was wird das Ergebnis sein?  Vergleichsoperationen werden durch Aufrufe des entsprechenden Makros ersetzt, und alle anderen Operationen werden nicht ge√§ndert.  Wenn Sie diese Funktion √ºbersetzen: <br><br><pre> <code class="hljs bash">proc <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>() <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> x,y x=1 y=2 result=(x&gt;y)*5+(x&lt;=y)*10 end_proc</code> </pre><br>  und dann nennen wir es, wir bekommen das erwartete Ergebnis. <br><br>  Das ist alles f√ºr heute. <br><br>  Der Code f√ºr diesen Artikel befindet sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>hier.</b></a> <br>  Fortsetzung folgt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de423663/">https://habr.com/ru/post/de423663/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de423645/index.html">Wie wir der Luzhniki-IT-Infrastruktur w√§hrend der Weltmeisterschaft gedient haben</a></li>
<li><a href="../de423647/index.html">Erstellen Sie ein einfaches neuronales Netzwerk</a></li>
<li><a href="../de423651/index.html">Wir laden alle zum Hackathon SmartMail Hack: About Welcome ein</a></li>
<li><a href="../de423655/index.html">Generika + Fr√ºhling: M√∂ge die Macht mit dir sein</a></li>
<li><a href="../de423657/index.html">Ich respektiere die Kapselung nicht oder verwende keine andere Art von Methodentabelle, um schnell private Methoden aufzurufen</a></li>
<li><a href="../de423677/index.html">Jetpack-Piloten: Frankie West</a></li>
<li><a href="../de423679/index.html">Eine Aufgabe mit Wolkenkratzer und Eiern - nicht Newtons M√ºlleimer?</a></li>
<li><a href="../de423683/index.html">Basierend auf gesundem Menschenverstand: DevOps von Grund auf neu entwickeln</a></li>
<li><a href="../de423685/index.html">PostgreSQL-Parallelit√§t: nicht kugelf√∂rmig, kein Pferd, nicht im Vakuum</a></li>
<li><a href="../de423687/index.html">HyperX Pulsefire FPS Pro - schneller, gemeiner, erschwinglicher</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>