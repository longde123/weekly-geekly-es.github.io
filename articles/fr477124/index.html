<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🍳 😾 👨‍⚖️ Bitcoin dans une cage? 👨‍👧‍👦 👰 👤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il se trouve que je suis un administrateur professionnel de systèmes informatiques et de réseaux (en bref: sysadmin), et il m'est arrivé de dire au pr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bitcoin dans une cage?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477124/"><p> Il se trouve que je suis un administrateur professionnel de systèmes informatiques et de réseaux (en bref: sysadmin), et il m'est arrivé de dire au prof.  l'activité d'une grande variété de systèmes, y compris ceux qui nécessitent [en raison de] les mesures de sécurité ci-dessus.  Et il s'est avéré qu'il y a quelque temps, j'ai trouvé le <a href="https://www.lopp.net/bitcoin-information.html">Bitcoin</a> intéressant pour moi, et non seulement l'ai utilisé, mais j'ai également lancé plusieurs microservices afin d'apprendre à travailler de manière indépendante avec le réseau Bitcoin (c'est du p2p après tout) du point de vue du développement. (Je suis, bien sûr, un tel développeur, donc, passé).  Mais je ne parle pas de développement, je parle d'un environnement sûr et efficace pour les applications. </p><a name="habracut"></a><br><p>  Les technologies financières ( <em>fintech</em> ) vont de pair avec la sécurité de l'information ( <em>infosec</em> ) et les premières peuvent fonctionner sans les secondes, mais pas pour longtemps.  C'est pourquoi je veux partager mon expérience et l'ensemble d'outils que j'utilise, qui comprend à la fois la <em>fintech</em> et <em>infosec</em> , et en même temps, il peut également être utilisé dans un but plus large ou complètement différent.  Dans cet article, je ne vous dirai pas tant sur Bitcoin, mais sur le modèle d'infrastructure pour le développement et le fonctionnement des services financiers (et pas seulement) - en un mot, les services où «B» compte.  Cela s'applique à la fois à l'échange Bitcoin et au zoo d'entreprise le plus typique des services d'une petite entreprise sans aucun bitcoin. </p><br><p>  Je tiens à noter que je suis un partisan des principes de <em>«garder les choses stupides simples»</em> et <em>«moins c'est plus»</em> , de sorte que l'article et celui qui y est décrit auront les propriétés sur lesquelles reposent ces principes. </p><br><p>  <em>Scénario imaginaire:</em> examinons un exemple d'échangeur de bitcoins.  Nous avons décidé de commencer à échanger des roubles, des dollars, des euros contre des bitcoins et vice versa, et nous avons déjà une solution de travail, mais pour d'autres monnaies numériques comme le kiwi et le webmoney, c'est-à-dire  nous avons fermé tous les problèmes juridiques, il existe une application prête à l'emploi qui sert de passerelle de paiement pour les roubles, les dollars et les euros et d'autres systèmes de paiement.  Il est lié à nos comptes bancaires et possède une sorte d'API pour nos applications finales.  Nous avons également une application Web qui agit comme un échangeur pour les utilisateurs, comme un compte kiwi ou webmoney typique - créez un compte, ajoutez une carte, etc.  Il communique avec notre application de passerelle, bien qu'en utilisant l'API REST en LAN.  Et nous avons donc décidé de connecter des bitcoins et en même temps de mettre à niveau l'infrastructure, car  au début, tout était précipité sur des boîtes virtuelles dans le bureau sous la table ... ils ont commencé à utiliser le site, et nous avons commencé à nous soucier de la disponibilité et des performances. </p><br><p>  Commençons donc par la sélection principale - un serveur.  Parce que  l'entreprise dans notre exemple est petite et nous faisons confiance à l'hébergeur (OVH), nous choisirons une <a href="https://www.kimsufi.com/">option budgétaire</a> dans laquelle vous ne pouvez pas installer le système à partir de l'image .iso d'origine, mais cela n'a pas d'importance, le service de sécurité informatique analysera certainement l'image installée.  Et quand nous serons grands, nous louerons généralement notre placard sous clé avec un accès physique limité, ou peut-être nous construirons notre propre DC.  Dans tous les cas, il convient de se rappeler que lors de la location de fer et de l'installation d'images prêtes à l'emploi, il est possible que votre système ait un «cheval de Troie de l'hôte», qui dans la plupart des cas n'est pas destiné à vous suivre, mais à offrir des outils de gestion plus pratiques. serveur. </p><br><p>  <strong>Installation du serveur</strong> </p><br><p>  Ici, tout est simple.  Nous choisissons du fer adapté à nos besoins.  Sélectionnez ensuite l'image FreeBSD.  Eh bien, soit nous nous connectons (dans le cas d'un autre hébergeur et de notre propre matériel) via IPMI ou avec un moniteur et alimentons l'image .iso FreeBSD au téléchargement.  Pour les installations orchestrales, j'utilise <a href="https://github.com/ansible/ansible">Ansible</a> et <a href="https://mfsbsd.vx.sk/">mfsbsd</a> .  La seule chose, dans notre cas avec kimsufi, nous avons choisi <em>une installation personnalisée</em> pour que les deux disques dans le miroir n'aient que des partitions «boot» et / home «ouvertes», le reste de l'espace disque sera crypté, mais plus à ce sujet plus tard. </p><br><p><img src="https://habrastorage.org/webt/-m/ve/av/-mveavdklaybhokh5sznmisf7be.png"></p><br><p>  Le système est installé de manière standard, je ne m'arrêterai pas là, je note juste qu'avant de commencer l'opération, faites attention aux options de <em>durcissement</em> , que <code>bsdinstaller</code> propose à la fin de l'installation (si vous installez le système vous-même): </p><br><p><img src="https://habrastorage.org/webt/pj/6w/no/pj6wnohhskxkw6vqigcucollot0.png"></p><br><p>  Il y a du <a href="http://bsdadventures.com/harden-freebsd/">bon matériel</a> sur ce sujet, bref je vais le répéter ici. </p><br><p>  Il est possible d'activer les paramètres ci-dessus de la même manière sur un système déjà installé.  Pour ce faire, modifiez le fichier du chargeur de démarrage et activez les paramètres du noyau.  * <em>ee est un éditeur comme celui-ci dans BSD</em> </p><br><p> <code># ee /etc/rc.conf</code> </p> <br><pre> <code class="plaintext hljs">... #sec hard clear_tmp_enable="YES" syslogd_flags="-ss" sendmail_enable="NONE"</code> </pre><br><p> <code># ee /etc/sysctl.conf</code> </p> <br><pre> <code class="plaintext hljs">... #sec hard security.bsd.see_other_uids=0 security.bsd.see_other_gids=0 security.bsd.unprivileged_read_msgbuf=0 security.bsd.unprivileged_proc_debug=0 kern.randompid=$(jot -r 1 9999) security.bsd.stack_guard_page=1</code> </pre> <br><p>  Il convient également de vous assurer que la dernière version du système est installée et d' <a href="https://www.freebsd.org/doc/handbook/updating-upgrading-freebsdupdate.html">effectuer toutes les mises à jour et mises à niveau</a> .  Dans notre cas, par exemple, une mise à niveau vers la dernière version est requise, car  les images de pré-installation accusent un retard de six mois à un an.  Eh bien, nous changeons le port SSH par un autre par défaut, ajoutons l'authentification par clé et désactivons-le avec un mot de passe. </p><br><p>  Ensuite, nous configurons l' <code>aide</code> , en surveillant l'état des fichiers de configuration du système.  Plus mâché peut être lu <a href="https://www.digitalocean.com/community/tutorials/how-to-install-aide-on-a-digitalocean-vps">ici</a> . </p><br><p> <code>pkg install aide</code> </p> <br><p>  et éditez notre crontab </p><br><p> <code>crontab -e</code> </p> <br><p> <code>06 01 * * 0-6 /root/chkaide.sh</code> </p> <br><pre> <code class="plaintext hljs">#! /bin/sh #chkaide.sh MYDATE=`date +%Y-%m-%d` MYFILENAME="Aide-"$MYDATE.txt /bin/echo "Aide check !! `date`" &gt; /tmp/$MYFILENAME /usr/local/bin/aide --check &gt; /tmp/myAide.txt /bin/cat /tmp/myAide.txt|/usr/bin/grep -v failed &gt;&gt; /tmp/$MYFILENAME /bin/echo "**************************************" &gt;&gt; /tmp/$MYFILENAME /usr/bin/tail -20 /tmp/myAide.txt &gt;&gt; /tmp/$MYFILENAME /bin/echo "****************DONE******************" &gt;&gt; /tmp/$MYFILENAME</code> </pre> <br><p>  Activer l' <a href="https://www.freebsd.org/doc/handbook/audit-config.html">audit du système</a> </p><br><p> <code>sysrc auditd_enable=YES</code> </p> <br><p> <code># service auditd start</code> </p> <br><p>  La façon d'administrer cette entreprise est bien décrite dans le <a href="https://www.freebsd.org/doc/handbook/audit-administration.html">manuel</a> . </p><br><p>  Maintenant, nous redémarrons et continuons avec le logiciel sur le serveur.  Chaque serveur est un hyperviseur pour les conteneurs ou les machines virtuelles complètes.  Par conséquent, il est important que le processeur prenne en charge VT-x et EPT si nous prévoyons d'utiliser la virtualisation complète. </p><br><p>  En tant que gestionnaire de conteneurs et de machines virtuelles, j'utilise <a href="https://bsdstore.ru/">clevd</a> de <a href="https://github.com/olevole">olevole</a> , je lui souhaite plus de santé et d'avantages pour ce merveilleux utilitaire! </p><br><p>  <strong>Des conteneurs?</strong>  <strong>Encore une fois docker ou quoi?</strong> </p><br><p>  Mais non.  <a href="https://www.freebsd.org/doc/handbook/jails.html">FreeBSD Jails</a> est un excellent outil de conteneurisation, mais le <code>cbsd</code> mentionné <code>cbsd</code> pour orchestrer ces conteneurs, dont le nom est des cellules. </p><br><p>  Une cellule est une solution extrêmement efficace pour construire une infrastructure à des fins diverses, ce qui nécessite en fin de compte l'isolement complet des services ou des processus individuels.  Il s'agit essentiellement d'un clone du système hôte, mais il ne nécessite pas de virtualisation complète du matériel.  Et les ressources dues à cela ne sont pas dépensées sur un "OS invité", mais uniquement sur le travail effectué.  Lorsque les cellules sont utilisées pour des besoins internes, il s'agit d'une solution très pratique pour une utilisation optimale de la ressource - un groupe de cellules sur un serveur de fer peut utiliser individuellement chacune des ressources du serveur si nécessaire.  Étant donné que des sous-services généralement différents nécessitent des frais supplémentaires.  à différents moments, vous pouvez extraire les performances maximales d'un serveur, si vous planifiez et déséquilibrez correctement les cellules entre les serveurs.  Si nécessaire, les cellules peuvent également définir des limites sur la ressource utilisée. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/95c/817/901/95c8179015447a58c383f4a4a81a510d.gif" alt="image"></p><br><p>  <strong>Et la virtualisation complète?</strong> </p><br><p>  Pour autant que je sache, <code>cbsd</code> prend en charge le travail des hyperviseurs <code>bhyve</code> et XEN.  Je n'ai jamais utilisé le second, mais le premier est un <a href="https://www.freebsd.org/doc/handbook/virtualization-host-bhyve.html">hyperviseur</a> relativement jeune <a href="https://www.freebsd.org/doc/handbook/virtualization-host-bhyve.html">de FreeBSD</a> .  Nous allons voir un exemple d'utilisation de <code>bhyve</code> dans l'exemple ci-dessous. </p><br><p>  <strong>Installer et configurer l'environnement hôte</strong> </p><br><p>  Nous utilisons FS <a href="https://www.freebsd.org/doc/handbook/zfs.html">ZFS</a> .  Il s'agit d'un outil extrêmement puissant pour gérer l'espace serveur.  Grâce à ZFS, vous pouvez créer directement des tableaux de différentes configurations directement à partir de disques, étendre dynamiquement l'espace «à chaud», changer les disques morts, gérer les instantanés et bien plus encore qui peuvent être décrits dans une série d'articles.  Revenons à notre serveur et à ses disques.  Au début de l'installation sur les disques, nous avons laissé de l'espace libre pour les partitions chiffrées.  Pourquoi  C'est ainsi que le système augmenterait automatiquement et écouterait sur SSH. </p><br><p> <code>gpart add -t freebsd-zfs /dev/ada0</code> </p> <br><p> <code>/dev/ada0p4 added!</code> </p> <br><p>  ajoutez la partition de disque à l'espace restant </p><br><p> <code>geli init /dev/ada0p4</code> </p> <br><p>  conduire notre mot de passe de cryptage </p><br><p> <code>geli attach /dev/ada0p4</code> </p> <br><p>  entrez à nouveau le mot de passe et nous avons l'appareil /dev/ada0p4.eli - c'est notre espace crypté.  Ensuite, nous répétons la même chose pour / dev / ada1 et les autres disques du tableau.  Et créez un nouveau <a href="https://www.freebsd.org/doc/handbook/zfs-zpool.html">pool ZFS</a> . </p><br><p>  <code>zpool create vms mirror /dev/ada0p4.eli /dev/ada1p4.eli /dev/ada3p4.eli</code> - eh bien, nous avons maintenant le jeu de combat minimum prêt.  Une matrice de disques en miroir en cas de défaillance de l'un des trois. </p><br><p>  Créer un jeu de données sur le nouveau "pool" </p><br><p> <code>zfs create vms/jails</code> </p> <br><p>  <code>pkg install cbsd</code> - exécutez la commande et installez la gestion de nos cellules. </p><br><p>  Une fois <code>cbsd</code> installé, il doit être initialisé: </p><br><p> <code># env workdir="/vms/jails" /usr/local/cbsd/sudoexec/initenv</code> </p> <br><p>  Eh bien, nous répondons à un tas de questions, principalement des réponses par défaut. </p><br><p>  * Si vous utilisez le chiffrement, il est important que le démon <code>cbsdd</code> démarre pas automatiquement tant que vous ne déchiffrez pas les disques manuellement ou automatiquement (dans notre exemple, zabbix le fait) </p><br><p>  ** De plus, je n'utilise pas NAT de <code>cbsd</code> , mais le configure moi-même en <code>pf</code> . </p><br><p> <code># sysrc pf_enable=YES</code> </p> <br><p> <code># ee /etc/pf.conf</code> </p> <br><pre> <code class="plaintext hljs">IF_PUBLIC="em0" IP_PUBLIC="1.23.34.56" JAIL_IP_POOL="192.168.0.0/24" #WHITE_CL="{ 127.0.0.1 }" icmp_types="echoreq" set limit { states 20000, frags 20000, src-nodes 20000 } set skip on lo0 scrub in all #NAT for jails nat pass on $IF_PUBLIC from $JAIL_IP_POOL to any -&gt; $IP_PUBLIC ## Bitcoin network port forward IP_JAIL="192.168.0.1" PORT_JAIL="{8333}" rdr pass on $IF_PUBLIC proto tcp from any to $IP_PUBLIC port $PORT_JAIL -&gt; $IP_JAIL</code> </pre><br><p> <code># service pf start</code> </p> <br><p> <code># pfctl -f /etc/pf.conf</code> </p> <br><p>  La configuration des politiques de pare-feu est également un sujet distinct, donc je ne vais pas approfondir la configuration de BLOCER TOUTES les politiques et définir des listes blanches; vous pouvez le faire en lisant la <a href="https://www.freebsd.org/doc/handbook/firewalls-pf.html">documentation officielle</a> ou l'un des nombreux articles disponibles sur Google. </p><br><p>  Eh bien ... nous avons installé cbsd, il est temps de créer notre premier cheval de bataille - un démon bitcoin dans une cage! </p><br><p> <code>cbsd jconstruct-tui</code> </p> <br><p><img src="https://habrastorage.org/webt/jf/yn/l5/jfynl5o0yozaua314r4e65yxy0y.png"></p><br><p>  Ici, nous voyons le dialogue de création de cellules.  Une fois toutes les valeurs définies, créez! </p><br><p>  Lors de la création de la première cellule, vous devez choisir quoi utiliser comme base pour les cellules.  Je sélectionne le kit de distribution dans le référentiel FreeBSD avec la commande <code>repo</code> .  Ce choix est effectué uniquement lors de la création de la première cellule d'une version spécifique (vous pouvez héberger des cellules de toutes les versions antérieures à la version hôte). </p><br><p>  Une fois que tout est installé - exécutez la cellule! </p><br><p> <code># cbsd jstart bitcoind</code> </p> <br><p>  Mais nous devons installer un logiciel dans la cage. </p><br><p> <code># jls</code> </p> <br><pre> <code class="plaintext hljs"> JID IP Address Hostname Path 1 192.168.0.1 bitcoind.space.com /zroot/jails/jails/bitcoind</code> </pre> <br><p>  <code>jexec bitcoind</code> pour entrer dans la console cellulaire </p><br><p>  et déjà à l'intérieur de la cellule nous installons le logiciel avec ses dépendances (notre système hôte reste propre) </p><br><p> <code>bitcoind:/@[15:25] # pkg install bitcoin-daemon bitcoin-utils</code> </p> <br><p> <code>bitcoind:/@[15:30] # sysrc bitcoind_enable=YES</code> </p> <br><p> <code>bitcoind:/@[15:30] # service bitcoind start</code> </p> <br><p>  Il y a du bitcoin dans la cellule, mais nous avons besoin d'anonymat, car nous voulons nous connecter à certaines cellules via le réseau TOP.  En général, nous prévoyons de transformer la plupart des cellules contenant des logiciels suspects uniquement via un proxy.  Grâce à <code>pf</code> vous pouvez désactiver NAT pour une plage spécifique d'adresses IP sur le réseau local, et autoriser NAT uniquement pour notre nœud TOR.  Ainsi, même si un logiciel malveillant pénètre dans la cellule, il ne contactera probablement pas le monde extérieur et s'il le fait, il ne révélera pas l'IP de notre serveur.  par conséquent, nous créons une cellule de plus, pour les services de "transfert" en tant que service ".onion" et en tant que proxy pour accéder à Internet à des cellules individuelles. </p><br><p> <code># cbsd jsconstruct-tui</code> </p> <br><p> <code># cbsd jstart tor</code> </p> <br><p> <code># jexec tor</code> </p> <br><p> <code>tor:/@[15:38] # pkg install tor</code> </p> <br><p> <code>tor:/@[15:38] # sysrc tor_enable=YES</code> </p> <br><p> <code>tor:/@[15:38] # ee /usr/local/etc/tor/torrc</code> </p> <br><p>  Nous mettons l'écoute sur l'adresse locale (disponible pour toutes les cellules) </p><br><p> <code>SOCKSPort 192.168.0.2:9050</code> </p> <br><p>  Qu'est-ce qui nous manque encore pour un bonheur complet.  Oui, nous avons besoin d'un service pour notre site Web, peut-être pas un.  Exécutez nginx, qui agira comme proxy inverse et se chargera de renouveler les certificats Let's Encrypt </p><br><p> <code># cbsd jsconstruct-tui</code> </p> <br><p> <code># cbsd jstart nginx-rev</code> </p> <br><p> <code># jexec nginx-rev</code> </p> <br><p> <code>nginx-rev:/@[15:47] # pkg install nginx py36-certbot</code> </p> <br><p>  <em>Et maintenant, nous mettons 150 Mo de dépendances dans une cage.</em>  <em>Et l'hôte est toujours propre.</em> </p><br><p>  Revenons à la configuration de nginx plus tard, nous devons augmenter deux cellules supplémentaires pour notre passerelle de paiement vers nodejs et rust et une application Web, qui pour une raison quelconque est sur apache et pkhp, et la base de données MySQL est également nécessaire pour ce dernier. </p><br><p> <code># cbsd jsconstruct-tui</code> </p> <br><p> <code># cbsd jstart paygw</code> </p> <br><p> <code># jexec paygw</code> </p> <br><p> <code>paygw:/@[15:55] # pkg install git node npm</code> </p> <br><p> <code>paygw:/@[15:55] # curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh</code> </p> <br><p>  <em>... et 380 Mo de packages en plus</em> </p><br><p>  Ensuite, nous pompons notre application avec git et l'exécutons. </p><br><p> <code># cbsd jsconstruct-tui</code> </p> <br><p> <code># cbsd jstart webapp</code> </p> <br><p> <code># jexec webapp</code> </p> <br><p> <code>webapp:/@[16:02] # pkg install mariadb104-server apache24 php74 mod_php74 php74-pdo_mysql</code> </p> <br><p>  <em>Packages de 450 Mo.</em>  <em>dans la cage.</em> </p><br><p>  ici, nous donnons au développeur un accès via SSH directement à la cellule, ils feront tout eux-mêmes là-bas: </p><br><p> <code>webapp:/@[16:02] # ee /etc/ssh/sshd_config</code> </p> <br><p>  <code>Port 2267</code> - changez le port de la cellule SSH en n'importe quel arbitraire </p><br><p> <code>webapp:/@[16:02] # sysrc sshd_enable=YES</code> </p> <br><p> <code>webapp:/@[16:02] # service sshd start</code> </p> <br><p>  Eh bien, le service est en cours d'exécution, il reste à ajouter une règle dans le pare-feu <code>pf</code> </p><br><p>  Voyons quelle IP nous avons dans les cellules et à quoi ressemble notre "lokalka" </p><br><p> <code># jls</code> </p> <br><pre> <code class="plaintext hljs"> JID IP Address Hostname Path 1 192.168.0.1 bitcoind.space.com /zroot/jails/jails/bitcoind 2 192.168.0.2 tor.space.com /zroot/jails/jails/tor 3 192.168.0.3 nginx-rev.space.com /zroot/jails/jails/nginx-rev 4 192.168.0.4 paygw.space.com /zroot/jails/jails/paygw 5 192.168.0.5 webapp.my.domain /zroot/jails/jails/webapp</code> </pre> <br><p>  et ajouter une règle </p><br><p> <code># ee /etc/pf.conf</code> </p> <br><pre> <code class="plaintext hljs">## SSH for web-Devs IP_JAIL="192.168.0.5" PORT_JAIL="{ 2267 }" rdr pass on $IF_PUBLIC proto tcp from any to $IP_PUBLIC port $PORT_JAIL -&gt; $IP_JAIL</code> </pre><br><p>  Eh bien, puisque nous sommes ici, nous ajouterons la même règle sur le proxy inverse: </p><br><pre> <code class="plaintext hljs">## web-ports for nginx-rev IP_JAIL="192.168.0.3" PORT_JAIL="{ 80, 443 }" rdr pass on $IF_PUBLIC proto tcp from any to $IP_PUBLIC port $PORT_JAIL -&gt; $IP_JAIL</code> </pre> <br><p> <code># pfctl -f /etc/pf.conf</code> </p> <br><p>  <strong>Eh bien, maintenant un peu sur les bitcoins</strong> </p><br><p>  Ce que nous avons - nous avons une application web accessible de l'extérieur et qui communique localement avec notre passerelle de paiement.  Nous devons maintenant préparer un environnement de travail pour l'interaction avec le réseau bitcoin lui-même - le nœud <code>bitcoind</code> n'est qu'un démon qui prend en charge une copie locale de la blockchain actuelle.  Ce démon a des fonctionnalités RPC et de portefeuille, mais il existe des «wrappers» plus pratiques pour développer des applications.  Pour commencer, nous avons décidé de mettre <code>electrum</code> - c'est un portefeuille CLI.  Nous utiliserons <a href="https://electrum.org/">ce portefeuille</a> comme un "stockage à froid" pour nos bitcoins - en général, ces bitcoins qui devront être stockés "en dehors" du système accessibles aux utilisateurs et généralement loin de tout le monde.  Il a également une interface graphique, nous allons donc utiliser le même portefeuille sur notre <br>  ordinateurs portables.  Alors que nous utiliserons l'électrum avec des serveurs publics, et plus tard dans une autre cellule, nous élèverons <a href="https://github.com/kyuupichan/electrumx">ElectrumX</a> , afin qu'il ne dépende de personne du tout. </p><br><p> <code># cbsd jsconstruct-tui</code> </p> <br><p> <code># cbsd jstart electrum</code> </p> <br><p> <code># jexec electrum</code> </p> <br><p> <code>electrum:/@[8:45] # pkg install py36-electrum</code> </p> <br><p>  <em>encore 700 Mo de logiciels dans notre cage</em> </p><br><p> <code>electrum:/@[8:53] # adduser</code> </p> <br><pre> <code class="plaintext hljs">Username: wallet Full name: Uid (Leave empty for default): Login group [wallet]: Login group is wallet. Invite wallet into other groups? []: Login class [default]: Shell (sh csh tcsh nologin) [sh]: tcsh Home directory [/home/wallet]: Home directory permissions (Leave empty for default): Use password-based authentication? [yes]: no Lock out the account after creation? [no]: Username : wallet Password : &lt;disabled&gt; Full Name : Uid : 1001 Class : Groups : wallet Home : /home/wallet Home Mode : Shell : /bin/tcsh Locked : no OK? (yes/no): yes adduser: INFO: Successfully added (wallet) to the user database. Add another user? (yes/no): no Goodbye! electrum:/@[8:53] # su wallet</code> </pre> <br><p> <code>electrum:/@[8:53] # su wallet</code> </p> <br><p> <code>wallet@electrum:/ % electrum-3.6 create</code> </p> <br><pre> <code class="plaintext hljs">{ "msg": "Please keep your seed in a safe place; if you lose it, you will not be able to restore your wallet.", "path": "/usr/home/wallet/.electrum/wallets/default_wallet", "seed": "jealous win pig material ribbon young punch visual okay cactus random bird" }</code> </pre> <br><p>  Maintenant, nous avons créé un portefeuille. </p><br><p> <code>wallet@electrum:/ % electrum-3.6 listaddresses</code> </p> <br><pre> <code class="plaintext hljs">[ "18WEhbjvMLGRMfwudzUrUd25U5C7uZYkzE", "14XHSejhxsZNDRtk4eFbqAX3L8rftzwQQU", "1KQXaN8RXiCN1ne9iYngUWAr6KJ6d4pPas", ... "1KeVcAwEYhk29qEyAfPwcBgF5mMMoy4qjw", "18VaUuSeBr6T2GwpSHYF3XyNgLyLCt1SWk" ]</code> </pre> <br><p> <code>wallet@electrum:/ % electrum-3.6 help</code> </p> <br><p>  Désormais, seul un cercle restreint de personnes pourra se connecter à notre portefeuille en <em>chaîne</em> .  Afin de ne pas ouvrir l'accès de l'extérieur à cette cellule, les connexions SSH se feront via TOR (une telle version décentralisée de VPN).  Nous démarrons SSH dans la cellule, mais ne touchons pas notre pf.conf sur l'hôte. </p><br><p> <code>electrum:/@[9:00] # sysrc sshd_enable=YES</code> </p> <br><p> <code>electrum:/@[9:00] # service sshd start</code> </p> <br><p>  Désactivez maintenant l'accès Internet à la cellule avec le portefeuille.  Nous lui donnerons une adresse IP d'un autre espace de sous-réseau qui n'est pas basé sur NAT.  Tout d'abord, changez <code>/etc/pf.conf</code> sur l'hôte </p><br><p> <code># ee /etc/pf.conf</code> </p> <br><p>  <code>JAIL_IP_POOL="192.168.0.0/24"</code> <code>JAIL_IP_POOL="192.168.0.0/25"</code> par <code>JAIL_IP_POOL="192.168.0.0/25"</code> , de sorte que toutes les adresses 192.168.0.126-255 n'auront pas d'accès direct à Internet.  Une sorte de réseau "air-gap" logiciel.  Et la règle NAT reste telle qu'elle était </p><br><p> <code>nat pass on $IF_PUBLIC from $JAIL_IP_POOL to any -&gt; $IP_PUBLIC</code> </p> <br><p>  Surcharger les règles </p><br><p> <code># pfctl -f /etc/pf.conf</code> </p> <br><p>  Maintenant, prends notre cage </p><br><p> <code># cbsd jconfig jname=electrum</code> </p> <br><p><img src="https://habrastorage.org/webt/mj/zo/ui/mjzouia2v_lhuzln_o9inimlwca.png"></p><br><p><img src="https://habrastorage.org/webt/_x/7-/c9/_x7-c9zdmlojjeqrpzfmv2j5fpc.png"></p><br><pre> <code class="plaintext hljs">jset mode=quiet jname=electrum ip4_addr="192.168.0.200" Remove old IP: /sbin/ifconfig em0 inet 192.168.0.6 -alias Setup new IP: /sbin/ifconfig em0 inet 192.168.0.200 alias ip4_addr: 192.168.0.200</code> </pre> <br><p>  Hmm, mais maintenant le système lui-même cessera de fonctionner pour nous.  Cependant, nous pouvons spécifier un proxy système.  Mais il y a une chose mais, sur TOR, c'est un proxy SOCKS5, et pour plus de commodité, nous aurions également un proxy HTTP. </p><br><p> <code># cbsd jsconstruct-tui</code> </p> <br><p> <code># cbsd jstart polipo</code> </p> <br><p> <code># jexec polipo</code> </p> <br><p> <code>polipo:/@[9:28] # pkg install polipo</code> </p> <br><p> <code>polipo:/@[9:28] # ee /usr/local/etc/polipo/config</code> </p> <br><pre> <code class="plaintext hljs">socksParentProxy = "192.168.0.2:9050" socksProxyType = socks5</code> </pre> <br><p> <code>polipo:/@[9:42] # sysrc polipo_enable=YES</code> </p> <br><p> <code>polipo:/@[9:43] # service polipo start</code> </p> <br><p>  Eh bien, maintenant dans notre système, il y a deux proxys, et les deux sortent via TOR: socks5: //192.168.0.2: 9050 et <a href="http://192.168.0.6:8123/">http://192.168.0.6:8123</a> </p><br><p>  Vous pouvez maintenant personnaliser l'environnement de notre portefeuille </p><br><p> <code># jexec electrum</code> </p> <br><p> <code>electrum:/@[9:45] # su wallet</code> </p> <br><p> <code>wallet@electrum:/ % ee ~/.cshrc</code> </p> <br><pre> <code class="plaintext hljs">#in the end of file proxy config setenv http_proxy http://192.168.0.6:8123 setenv https_proxy http://192.168.0.6:8123</code> </pre> <br><p>  Eh bien, maintenant le shell fonctionnera sous un proxy.  Si vous souhaitez installer des packages, il convient d'ajouter à <code>/usr/local/etc/pkg.conf</code> sous la racine de la cellule </p><br><pre> <code class="plaintext hljs">pkg_env: { http_proxy: "http://my_proxy_ip:8123", }</code> </pre> <br><p>  Eh bien, il est maintenant temps d'ajouter le service caché TOR comme adresse de notre service SSH dans la cellule du portefeuille. </p><br><p> <code># jexec tor</code> </p> <br><p> <code>tor:/@[9:59] # ee /usr/local/etc/tor/torrc</code> </p> <br><pre> <code class="plaintext hljs">HiddenServiceDir /var/db/tor/electrum/ HiddenServicePort 22 192.168.0.200:22</code> </pre> <br><p> <code>tor:/@[10:01] # mkdir /var/db/tor/electrum</code> </p> <br><p> <code>tor:/@[10:01] # chown -R _tor:_tor /var/db/tor/electrum</code> </p> <br><p> <code>tor:/@[10:01] # chmod 700 /var/db/tor/electrum</code> </p> <br><p> <code>tor:/@[10:03] # service tor restart</code> </p> <br><p> <code>tor:/@[10:04] # cat /var/db/tor/electrum/hostname</code> </p> <br><pre> <code class="plaintext hljs">mdjus4gmduhofwcso57b3zl3ufoitguh2knitjco5cmgrokpreuxumad.onion</code> </pre> <br><p>  Ici, c'est notre adresse de connexion.  Vérifions à partir de la machine locale.  Mais vous devez d'abord ajouter notre clé SSH: </p><br><p> <code>wallet@electrum:/ % mkdir ~/.ssh</code> </p> <br><p> <code>wallet@electrum:/ % ee ~/.ssh/authorized_keys</code> </p> <br><pre> <code class="plaintext hljs">ecdsa-sha2-nistp521 AAAAE2VjZHNhLXNoYTItbmlzdHA1MjEAAAAIbmlzdHA1MjEAAACFBAG9Fk2Lqi4GQ8EXZrsH3EgSrVIQPQaAlS38MmJLBabihv9KHIDGXH7r018hxqLNNGbaJWO/wrWk7sG4T0yLHAbdQAFsMYof9kjoyuG56z0XZ8qaD/X/AjrhLMsIoBbUNj0AzxjKNlPJL4NbHsFwbmxGulKS0PdAD5oLcTQi/VnNdU7iFw== user@local</code> </pre> <br><p>  Eh bien, à partir de la machine Linux cliente </p><br><p> <code>user@local ~$ nano ~/.ssh/config</code> </p> <br><pre> <code class="plaintext hljs">#remote electrum wallet Host remotebtc User wallet Port 22 Hostname mdjus4gmduhofwcso57b3zl3ufoitguh2knitjco5cmgrokpreuxumad.onion ProxyCommand /bin/ncat --proxy localhost:9050 --proxy-type socks5 %h %p</code> </pre><br><p>  Se connecter <em>(pour que cela fonctionne, vous avez besoin d'un démon TOR local qui écoute sur le 9050)</em> </p><br><p> <code>user@local ~$ ssh remotebtc</code> </p> <br><pre> <code class="plaintext hljs">The authenticity of host 'mdjus4gmduhofwcso57b3zl3ufoitguh2knitjco5cmgrokpreuxumad.onion (&lt;no hostip for proxy command&gt;)' can't be established. ECDSA key fingerprint is SHA256:iW8FKjhVF4yyOZB1z4sBkzyvCM+evQ9cCL/EuWm0Du4. Are you sure you want to continue connecting (yes/no/[fingerprint])? yes Warning: Permanently added 'mdjus4gmduhofwcso57b3zl3ufoitguh2knitjco5cmgrokpreuxumad.onion' (ECDSA) to the list of known hosts. FreeBSD 12.1-RELEASE-p1 GENERIC To save disk space in your home directory, compress files you rarely use with "gzip filename". -- Dru &lt;genesis@istar.ca&gt; wallet@electrum:~ % logout</code> </pre><br><p>  Succès! </p><br><p>  Pour travailler avec des micro-paiements instantanés, nous avons également besoin du nœud <a href="https://www.lopp.net/lightning-information.html">Lightning Network</a> , en fait, ce sera notre principal outil de travail avec le bitcoin.  * <a href="https://github.com/ElementsProject/lightning">C-lightning</a> , que nous allons utiliser comme démon, a <a href="https://github.com/fiatjaf/sparko">un plugin Sparko</a> , qui est une interface HTTP (REST) ​​à part entière et permet de travailler à la fois avec les transactions hors chaîne et les transactions en chaîne.  <code>c-lightning</code> nécessite un nœud <code>bitcoind</code> pour fonctionner. </p><br><p>  * <em>Il existe différentes implémentations sur différents PL du protocole Lightning Network.</em>  <em>Parmi ceux que nous avons testés, c-lightning (écrit en C) semble être le plus stable et le plus économe en ressources</em> </p><br><p> <code># cbsd jsconstruct-tui</code> </p> <br><p> <code># cbsd jstart cln</code> </p> <br><p> <code># jexec cln</code> </p> <br><p> <code>lightning:/@[10:23] # adduser</code> </p> <br><pre> <code class="plaintext hljs">Username: lightning ...</code> </pre> <br><p> <code>lightning:/@[10:24] # pkg install git</code> </p> <br><p> <code>lightning:/@[10:23] # su lightning</code> </p> <br><p> <code>cd ~ &amp;&amp; git clone https://github.com/ElementsProject/lightning</code> </p> <br><p> <code>lightning@lightning:~ % exit</code> </p> <br><p> <code>lightning:/@[10:30] # cd /home/lightning/lightning/</code> </p> <br><p> <code>lightning:/home/lightning/lightning@[10:31] # pkg install autoconf automake gettext git gmp gmake libtool python python3 sqlite3 libsodium py36-mako bash bitcoin-utils</code> </p> <br><p> <code>lightning:/home/lightning/lightning@[10:34] # ./configure &amp;&amp; gmake &amp;&amp; gmake install</code> </p> <br><p>  Alors que tout ce dont vous avez besoin est compilé et installé, créez l'utilisateur RPC pour <code>lightningd</code> dans <code>bitcoind</code> </p><br><p> <code># jexec bitcoind</code> </p> <br><p> <code>bitcoind:/@[10:36] # ee /usr/local/etc/bitcoin.conf</code> </p> <br><pre> <code class="plaintext hljs">rpcbind=192.168.0.1 rpcuser=test rpcpassword=test #allow only c-lightning rpcallowip=192.168.0.7/32</code> </pre> <br><p> <code>bitcoind:/@[10:39] # service bitcoind restart</code> </p> <br><p>  <em>Ma commutation chaotique entre les cellules n'est pas si chaotique si vous notez l'utilitaire <code>tmux</code> , qui vous permet de créer de nombreuses sous-sessions de terminaux au sein d'une session.</em>  <em>Analogique: <code>screen</code></em> </p><br><p><img src="https://habrastorage.org/webt/xu/cz/14/xucz14wosjbbeme4iis8ws4nxq8.png"></p><br><p>  Teckels, nous ne voulons pas faire briller la véritable IP de notre nœud, et nous voulons effectuer toutes les transactions financières via le TOP.  Par conséquent, vous avez besoin d'un .onion de plus. </p><br><p> <code># jexec tor</code> </p> <br><p> <code>tor:/@[9:59] # ee /usr/local/etc/tor/torrc</code> </p> <br><pre> <code class="plaintext hljs">HiddenServiceDir /var/db/tor/cln/ HiddenServicePort 9735 192.168.0.7:9735</code> </pre> <br><p> <code>tor:/@[10:01] # mkdir /var/db/tor/cln</code> </p> <br><p> <code>tor:/@[10:01] # chown -R _tor:_tor /var/db/tor/cln</code> </p> <br><p> <code>tor:/@[10:01] # chmod 700 /var/db/tor/cln</code> </p> <br><p> <code>tor:/@[10:03] # service tor restart</code> </p> <br><p> <code>tor:/@[10:04] # cat /var/db/tor/cln/hostname</code> </p> <br><pre> <code class="plaintext hljs">en5wbkavnytti334jc5uzaudkansypfs6aguv6kech4hbzpcz2ove3yd.onion</code> </pre> <br><p>  créez maintenant une config pour c-lightning </p><br><p> <code>lightning:/home/lightning/lightning@[10:31] # su lightning</code> </p> <br><p> <code>lightning@lightning:~ % mkdir .lightning</code> </p> <br><p> <code>lightning@lightning:~ % ee .lightning/config</code> </p> <br><pre> <code class="plaintext hljs">alias=My-LN-Node bind-addr=192.168.0.7:9735 rgb=ff0000 announce-addr=en5wbkavnytti334jc5uzaudkansypfs6aguv6kech4hbzpcz2ove3yd.onion:9735 network=bitcoin log-level=info fee-base=0 fee-per-satoshi=1 proxy=192.168.0.2:9050 log-file=/home/lightning/.lightning/c-lightning.log min-capacity-sat=200000 # sparko plugin # https://github.com/fiatjaf/lightningd-gjson-rpc/tree/master/cmd/sparko sparko-host=192.168.0.7 sparko-port=9737 sparko-tls-path=sparko-tls #sparko-login=mywalletusername:mywalletpassword #sparko-keys=masterkey;secretread:+listchannels,+listnodes;secretwrite:+invoice,+listinvoices,+delinvoice,+decodepay,+waitpay,+waitinvoice sparko-keys=masterkey;secretread:+listchannels,+listnodes;ultrawrite:+invoice,+listinvoices,+delinvoice,+decodepay,+waitpay,+waitinvoice # for the example above the initialization logs (mixed with lightningd logs) should print something like</code> </pre> <br><p> <code>lightning@lightning:~ % mkdir .lightning/plugins</code> </p> <br><p> <code>lightning@lightning:~ % cd .lightning/plugins/</code> </p> <br><p> <code>lightning@lightning:~/.lightning/plugins:% fetch https://github.com/fiatjaf/sparko/releases/download/v0.2.1/sparko_full_freebsd_amd64</code> </p> <br><p> <code>lightning@lightning:~/.lightning/plugins % mkdir ~/.lightning/sparko-tls</code> </p> <br><p> <code>lightning@lightning:~/.lightning/sparko-tls % cd ~/.lightning/sparko-tls</code> </p> <br><p> <code>lightning@lightning:~/.lightning/sparko-tls % openssl genrsa -out key.pem 2048</code> </p> <br><p> <code>lightning@lightning:~/.lightning/sparko-tls % openssl req -new -x509 -sha256 -key key.pem -out cert.pem -days 3650</code> </p> <br><p> <code>lightning@lightning:~/.lightning/plugins % chmod +x sparko_full_freebsd_amd64</code> </p> <br><p> <code>lightning@lightning:~/.lightning/plugins % mv sparko_full_freebsd_amd64 sparko</code> </p> <br><p> <code>lightning@lightning:~/.lightning/plugins % cd ~</code> </p> <br><p>  vous devez également créer un fichier de configuration pour bitcoin-cli, un utilitaire qui communique avec <code>bitcoind</code> </p><br><p> <code>lightning@lightning:~ % mkdir .bitcoin</code> </p> <br><p> <code>lightning@lightning:~ % ee .bitcoin/bitcoin.conf</code> </p> <br><pre> <code class="plaintext hljs">rpcconnect=192.168.0.1 rpcuser=test rpcpassword=test</code> </pre> <br><p>  vérifier </p><br><p> <code>lightning@lightning:~ % bitcoin-cli echo "test"</code> </p> <br><pre> <code class="plaintext hljs">[ "test" ]</code> </pre> <br><p>  exécuter <code>lightningd</code> </p><br><p> <code>lightning@lightning:~ % lightningd --daemon</code> </p> <br><p>  <code>lightning-cli</code> lui-même peut être contrôlé par l' <code>lightning-cli</code> , par exemple: </p><br><p>  <code>lightning-cli newaddr</code> <em>obtient l'adresse pour le nouveau paiement entrant</em> </p><br><pre> <code class="plaintext hljs">{ "address": "bc1q2n2ffq3lplhme8jufcxahfrnfhruwjgx3c78pv", "bech32": "bc1q2n2ffq3lplhme8jufcxahfrnfhruwjgx3c78pv" }</code> </pre> <br><p>  <code>lightning-cli withdraw bc1jufcxahfrnfhruwjgx3cq2n2ffq3lplhme878pv all</code> <em>envoyer à l'adresse tout l'argent du portefeuille (toutes les adresses en chaîne)</em> </p><br><p>  En outre, les commandes pour les opérations hors chaîne de la <code>lightning-cli invoice</code> <code>lightning-cli listinvoices</code> <code>lightning-cli pay</code> etc. </p><br><p>  Eh bien, pour la communication avec l'application, nous avons REST Api </p><br><p> <code>curl -k https://192.168.0.7:9737/rpc -d '{"method": "pay", "params": ["lnbc..."]}' -H 'X-Access masterkey'</code> </p> <br><p>  <strong>Pour résumer</strong> </p><br><p> <code># jls</code> </p> <br><pre> <code class="plaintext hljs"> JID IP Address Hostname Path 1 192.168.0.1 bitcoind.space.com /zroot/jails/jails/bitcoind 2 192.168.0.2 tor.space.com /zroot/jails/jails/tor 3 192.168.0.3 nginx-rev.space.com /zroot/jails/jails/nginx-rev 4 192.168.0.4 paygw.space.com /zroot/jails/jails/paygw 5 192.168.0.5 webapp.my.domain /zroot/jails/jails/webapp 7 192.168.0.200 electrum.space.com /zroot/jails/jails/electrum 8 192.168.0.6 polipo.space.com /zroot/jails/jails/polipo 9 192.168.0.7 lightning.space.com /zroot/jails/jails/cln</code> </pre> <br><p><img src="https://habrastorage.org/webt/nt/0k/ew/nt0kewrhuin48nj-lbfk1jpa4rc.png"></p><br><p>     ,            . </p><br><p> <code># zfs list</code> </p> <br><pre> <code class="plaintext hljs">NAME USED AVAIL REFER MOUNTPOINT zroot 279G 1.48T 88K /zroot zroot/ROOT 1.89G 1.48T 88K none zroot/ROOT/default 1.89G 17.6G 1.89G / zroot/home 88K 1.48T 88K /home zroot/jails 277G 1.48T 404M /zroot/jails zroot/jails/bitcoind 190G 1.48T 190G /zroot/jails/jails-data/bitcoind-data zroot/jails/cln 653M 1.48T 653M /zroot/jails/jails-data/cln-data zroot/jails/electrum 703M 1.48T 703M /zroot/jails/jails-data/electrum-data zroot/jails/nginx-rev 190M 1.48T 190M /zroot/jails/jails-data/nginx-rev-data zroot/jails/paygw 82.4G 1.48T 82.4G /zroot/jails/jails-data/paygw-data zroot/jails/polipo 57.6M 1.48T 57.6M /zroot/jails/jails-data/polipo-data zroot/jails/tor 81.5M 1.48T 81.5M /zroot/jails/jails-data/tor-data zroot/jails/webapp 360M 1.48T 360M /zroot/jails/jails-data/webapp-data</code> </pre> <br><p>  , bitcoind   190  .          ?  ZFS   .   <code>cbsd jclone old=bitcoind new=bitcoind-clone host_hostname=clonedbtc.space.com</code>          .        ,               (   190 ) </p><br><p>       ZFS,    . <a href="https://www.freebsd.org/doc/handbook/zfs-zfs.html">ZFS   </a>     ,     SSH.    ,   . </p><br><p>        ,      <a href="https://zabbix.org/wiki/Main_Page">Zabbix</a> . </p><br><p> <strong> — </strong> </p><br><p>   ,        : </p><br><p> <em></em> —   UNIX-     .           — .          .           .                   .       -,             . </p><br><p> <em></em> —        . -       , ECC , ZFS  " "        .            .   -     . </p><br><p> <em></em> —   .           .           .                (     ).           ,         . </p><br><p> <em> </em> —            ,  .          ,               . </p><br><p>            ,     ,    ,         . </p><br><p> <strong>    ?</strong> </p><br><p>     cbsd  <a href="https://www.bsdstore.ru/en/11.2.x/wf_bcreate_ssi.html"> </a> .   ,    <code>bhyve</code>     . </p><br><p> <code># cat /etc/rc.conf</code> </p> <br><pre> <code class="plaintext hljs">... kld_list="vmm if_tap if_bridge nmdm" ...</code> </pre> <br><p> <code># cat /boot/loader.conf</code> </p> <br><pre> <code class="plaintext hljs">... vmm_load="YES" ...</code> </pre> <br><p>        ,   - debian  ! </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ffd/cb6/219/ffdcb6219c701e2e114100d9601e9fea.gif"></p><br><p> <strong>  </strong> </p><br><p>       .          — <a href="https://sochain.com/address/BTC/bc1qu7lhf45xw83ddll5mnzte6ahju8ktkeu6qhttc">bc1qu7lhf45xw83ddll5mnzte6ahju8ktkeu6qhttc</a> .          ,      <a href="https://bitclouds.sh/">pet-project</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr477124/">https://habr.com/ru/post/fr477124/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr477110/index.html">Planification divertissante</a></li>
<li><a href="../fr477114/index.html">Implémentation de l'interpréteur MSH</a></li>
<li><a href="../fr477118/index.html">MIRO est une plate-forme de robot intérieure ouverte. Partie 5 - Composant logiciel: ARDUINO (AVR), on grimpe "sous le capot"</a></li>
<li><a href="../fr477120/index.html">Logiciel de surveillance de la glycémie en continu pour Windows</a></li>
<li><a href="../fr477122/index.html">Le cerveau de l'entreprise. 3e partie</a></li>
<li><a href="../fr477126/index.html">Admin en 5 minutes. Frontend - react-admin, backend - Flask-RESTful</a></li>
<li><a href="../fr477128/index.html">Détective Habra le week-end</a></li>
<li><a href="../fr477130/index.html">"Eugene Onegin": inversion (histoire N.-F.)</a></li>
<li><a href="../fr477132/index.html">Données personnelles en Fédération de Russie: qui sommes-nous tous? Où allons-nous?</a></li>
<li><a href="../fr477136/index.html">Comment FL.ru trompe les utilisateurs en vendant deux fois un service, en enfreignant leurs propres règles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>