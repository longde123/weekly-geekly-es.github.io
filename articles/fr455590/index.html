<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍⚕️ ❗️ 👳 MVCC dans PostgreSQL-8. Congélation 👌🏽 👩‍❤️‍👩 🖼️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous avons commencé par des problèmes liés à l' isolement , avons fait une digression sur l' organisation des données à un bas niveau et avons parlé e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC dans PostgreSQL-8. Congélation</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/455590/">  Nous avons commencé par des problèmes liés à l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">isolement</a> , avons fait une digression sur l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">organisation des données à un bas niveau</a> et avons parlé en détail des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">versions de ligne</a> et de la façon dont les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">instantanés</a> sont obtenus à partir des versions. <br><br>  Ensuite, nous avons examiné différents types de nettoyage: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">intra-page</a> (avec mises à jour HOT), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">régulier</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">automatique</a> . <br><br>  Et je suis arrivé au dernier sujet de ce cycle.  Aujourd'hui, nous allons parler du problème de l'habillage et du gel des ID de transaction. <br><a name="habracut"></a><br><h1>  Débordement du compteur de transactions </h1><br>  PostgreSQL a 32 bits alloués pour le numéro de transaction.  C'est un nombre assez important (environ 4 milliards), mais avec le fonctionnement actif du serveur, il pourrait bien être épuisé.  Par exemple, à une charge de 1000 transactions par seconde, cela se produira après seulement un mois et demi de fonctionnement continu. <br><br>  Mais nous avons parlé du fait que le mécanisme de multi-versions repose sur la séquence de numérotation - alors sur deux transactions, une transaction avec un nombre inférieur peut être considérée comme ayant commencé plus tôt.  Par conséquent, il est clair que vous ne pouvez pas simplement réinitialiser le compteur et continuer à nouveau la numérotation. <br><br><img src="https://habrastorage.org/webt/cn/om/rg/cnomrgflv1bnkqme9k68bit4ad0.png"><br><br>  Pourquoi est-ce que 64 bits ne sont pas alloués pour le numéro de transaction - car cela éliminerait complètement le problème?  Le fait est que (comme discuté <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">précédemment</a> ) dans l'en-tête de chaque version de la ligne sont stockés deux numéros de transaction - xmin et xmax.  L'en-tête est déjà assez volumineux, au moins 23 octets, et une augmentation de la profondeur de bits entraînerait son augmentation de 8 octets supplémentaires.  Ce n'est absolument pas possible. <br><br><blockquote>  Les numéros de transaction 64 bits sont implémentés dans le produit de notre société, Postgres Pro Enterprise, mais ils ne sont pas tout à fait honnêtes non plus: xmin et xmax restent 32 bits, et l'en-tête de la page contient un "début d'une ère" commun à l'échelle de la page. <br></blockquote><br>  Que faire?  Au lieu d'un diagramme linéaire, tous les numéros de transaction sont bouclés.  Pour toute transaction, la moitié des chiffres «dans le sens antihoraire» sont considérés comme appartenant au passé, et la moitié «dans le sens horaire» à l'avenir. <br><br>  L'âge d'une transaction est le nombre de transactions passées depuis son apparition dans le système (que le compteur soit passé par zéro ou non).  Lorsque nous voulons comprendre si une transaction est plus ancienne qu'une autre ou non, nous comparons leur âge, pas leurs chiffres.  (Par conséquent, soit dit en passant, les opérations «supérieur» et «moins» ne sont pas définies pour le type de données xid.) <br><br><img src="https://habrastorage.org/webt/8f/rk/ft/8frkftw38-c0-yfbjaz7m-au3va.png"><br><br>  Mais dans un tel circuit en boucle, une situation désagréable se présente.  Une transaction qui était dans un passé lointain (transaction 1 sur la figure), après un certain temps sera dans la moitié du cercle qui se rapporte à l'avenir.  Cela, bien sûr, viole les règles de visibilité et entraînerait des problèmes - les modifications apportées par la transaction 1 disparaîtraient tout simplement de la vue. <br><br><img src="https://habrastorage.org/webt/qp/vy/ag/qpvyagxruu4gik-rof6eqoxk1e4.png"><br><br><h1>  Règles de gel et de visibilité des versions </h1><br>  Afin d'éviter de tels «voyages» du passé vers le futur, le processus de nettoyage (en plus de libérer de l'espace dans les pages) effectue une autre tâche.  Il trouve des versions assez anciennes et «froides» des lignes (qui sont visibles dans toutes les images et dont le changement est déjà peu probable) et les marque d'une manière spéciale - les «gèle».  La version figée de la ligne est considérée comme plus ancienne que toutes les données normales et est toujours visible dans tous les instantanés de données.  De plus, il n'est plus nécessaire de regarder le numéro de transaction xmin, et ce numéro peut être réutilisé en toute sécurité.  Ainsi, les versions figées des chaînes restent toujours dans le passé. <br><br><img src="https://habrastorage.org/webt/2c/vn/yp/2cvnypkp70pikgco9rzjjiccob0.png"><br><br>  Afin de marquer le numéro de transaction xmin comme figé, les deux bits de conseil sont définis en même temps - le bit de validation et le bit d'annulation. <br><br>  Notez que la transaction xmax n'a pas besoin d'être gelée.  Sa présence signifie que cette version de la chaîne n'est plus pertinente.  Une fois qu'elle ne sera plus visible dans les instantanés de données, cette version de la ligne sera effacée. <br><br>  Pour les expériences, créez un tableau.  Nous avons défini le facteur de remplissage minimum pour que seules deux lignes tiennent sur chaque page - il sera donc plus pratique pour nous d'observer ce qui se passe.  Et désactivez l'automatisation pour contrôler vous-même le temps de nettoyage. <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tfreeze( id <span class="hljs-type"><span class="hljs-type">integer</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">300</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (fillfactor = <span class="hljs-number"><span class="hljs-number">10</span></span>, autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>);</code> </pre> <br>  Nous avons déjà créé plusieurs variantes de la fonction, qui, en utilisant l'extension pageinspect, a montré la version des lignes qui sont sur la page.  Nous allons maintenant créer une autre version de la même fonction: maintenant, elle affichera plusieurs pages à la fois et affichera l'âge de la transaction xmin (l'âge de la fonction système est utilisé pour cela): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> heap_page(relname <span class="hljs-type"><span class="hljs-type">text</span></span>, pageno_from <span class="hljs-type"><span class="hljs-type">integer</span></span>, pageno_to <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span>(ctid tid, state <span class="hljs-type"><span class="hljs-type">text</span></span>, xmin <span class="hljs-type"><span class="hljs-type">text</span></span>, xmin_age <span class="hljs-type"><span class="hljs-type">integer</span></span>, xmax <span class="hljs-type"><span class="hljs-type">text</span></span>, t_ctid tid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> (pageno,lp)::</span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">text</span></span></span><span class="pgsql">::tid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> ctid, </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> lp_flags </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'unused'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'normal'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'redirect to '</span></span></span><span class="pgsql">||lp_off </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">3</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'dead'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> state, t_xmin || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">256</span></span></span><span class="pgsql">+</span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">512</span></span></span><span class="pgsql">) = </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">256</span></span></span><span class="pgsql">+</span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">512</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (f)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">256</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">512</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmin, age(t_xmin) xmin_age, t_xmax || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1024</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2048</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmax, t_ctid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> generate_series(pageno_from, pageno_to) p(pageno), heap_page_items(get_raw_page(relname, pageno)) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ORDER</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BY</span></span></span><span class="pgsql"> pageno, lp; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>;</code> </pre><br>  Veuillez noter que le signe de gel (que nous montrons avec la lettre f entre parenthèses) est déterminé par l'installation simultanée d'invites validées et abandonnées.  De nombreuses sources (y compris la documentation) mentionnent le nombre spécial FrozenTransactionId = 2, qui marque les transactions gelées.  Un tel système fonctionnait jusqu'à la version 9.4, mais il a maintenant été remplacé par des bits d'info-bulle - cela vous permet d'enregistrer le numéro de transaction d'origine dans la version en ligne, ce qui est pratique à des fins de support et de débogage.  Cependant, les transactions avec le numéro 2 peuvent toujours se produire dans les anciens systèmes, même mis à niveau vers les dernières versions. <br><br>  Nous avons également besoin de l'extension pg_visibility, qui vous permet de consulter la carte de visibilité: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pg_visibility;</code> </pre><br>  Avant PostgreSQL 9.6, la carte de visibilité contenait un bit par page;  il a marqué des pages contenant uniquement des versions "assez anciennes" de chaînes qui sont déjà garanties d'être visibles sur toutes les images.  L'idée ici est que si la page est marquée dans la carte de visibilité, alors pour sa version des lignes, vous n'avez pas besoin de vérifier les règles de visibilité. <br><br>  À partir de la version 9.6, une carte figée a été ajoutée à la même couche - un bit de plus par page.  La carte de gel marque les pages sur lesquelles toutes les versions des lignes sont figées. <br><br>  Nous insérons plusieurs lignes dans le tableau et effectuons immédiatement le nettoyage pour créer une carte de visibilité: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> tfreeze(id, s) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> g.id, <span class="hljs-string"><span class="hljs-string">'FOO'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span>) g(id); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> tfreeze;</code> </pre><br>  Et nous voyons que les deux pages sont maintenant marquées dans la carte de visibilité (all_visible), mais pas encore figées (all_frozen): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) g(blkno), pg_visibility_map(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,g.blkno) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> g.blkno;</code> </pre><pre> <code class="plaintext hljs"> blkno | all_visible | all_frozen -------+-------------+------------ 0 | t | f 1 | t | f (2 rows)</code> </pre><br>  L'âge de la transaction qui a créé les lignes (xmin_age) est 1 - il s'agit de la dernière transaction effectuée sur le système: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmin_age | xmax | t_ctid -------+--------+---------+----------+-------+-------- (0,1) | normal | 697 (c) | 1 | 0 (a) | (0,1) (0,2) | normal | 697 (c) | 1 | 0 (a) | (0,2) (1,1) | normal | 697 (c) | 1 | 0 (a) | (1,1) (1,2) | normal | 697 (c) | 1 | 0 (a) | (1,2) (4 rows)</code> </pre><br><h1>  Âge minimum pour congeler </h1><br>  Trois paramètres principaux contrôlent le gel, et nous les examinerons tour à tour. <br><br>  Commençons par <em>vacuum_freeze_min_age</em> , qui définit l'âge minimum de transaction xmin auquel la version de chaîne peut être gelée.  Plus cette valeur est faible, plus les frais généraux inutiles peuvent s'avérer être: si nous avons affaire à des données «chaudes» et en changement actif, le gel de plus en plus de nouvelles versions sera inutile.  Dans ce cas, il vaut mieux attendre. <br><br>  La valeur par défaut de ce paramètre définit que les transactions commencent à geler après que 50 millions d'autres transactions se soient écoulées depuis leur apparition: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> vacuum_freeze_min_age;</code> </pre><pre> <code class="plaintext hljs"> vacuum_freeze_min_age ----------------------- 50000000 (1 row)</code> </pre><br>  Afin de voir comment le gel se produit, nous réduisons la valeur de ce paramètre à l'unité. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> vacuum_freeze_min_age = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Et nous mettrons à jour une ligne sur la page zéro.  La nouvelle version arrivera à la même page en raison de la petite valeur fillfactor. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> tfreeze <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'BAR'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Voici ce que nous voyons maintenant dans les pages de données: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmin_age | xmax | t_ctid -------+--------+---------+----------+-------+-------- (0,1) | normal | 697 (c) | 2 | 698 | (0,3) (0,2) | normal | 697 (c) | 2 | 0 (a) | (0,2) (0,3) | normal | 698 | 1 | 0 (a) | (0,3) (1,1) | normal | 697 (c) | 2 | 0 (a) | (1,1) (1,2) | normal | 697 (c) | 2 | 0 (a) | (1,2) (5 rows)</code> </pre><br>  Maintenant, les lignes plus anciennes que <em>vacuum_freeze_min_age</em> = 1 doivent être gelées.  Mais notez que la ligne zéro n'est pas marquée dans la carte de visibilité (le bit a été réinitialisé par la commande UPDATE, qui a changé la page), et la première reste vérifiée: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) g(blkno), pg_visibility_map(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,g.blkno) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> g.blkno;</code> </pre><pre> <code class="plaintext hljs"> blkno | all_visible | all_frozen -------+-------------+------------ 0 | f | f 1 | t | f (2 rows)</code> </pre><br>  Nous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">avons déjà dit</a> que le nettoyage ne numérise que les pages qui ne sont pas marquées dans la carte de visibilité.  Et il s'avère donc: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> tfreeze; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmin_age | xmax | t_ctid -------+---------------+---------+----------+-------+-------- (0,1) | redirect to 3 | | | | (0,2) | normal | 697 (f) | 2 | 0 (a) | (0,2) (0,3) | normal | 698 (c) | 1 | 0 (a) | (0,3) (1,1) | normal | 697 (c) | 2 | 0 (a) | (1,1) (1,2) | normal | 697 (c) | 2 | 0 (a) | (1,2) (5 rows)</code> </pre><br>  Sur la page zéro, une version est figée, mais la première page ne considérait pas du tout le nettoyage.  Ainsi, si seules les versions actuelles sont laissées sur la page, le nettoyage ne viendra pas sur une telle page et ne les gèlera pas. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) g(blkno), pg_visibility_map(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,g.blkno) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> g.blkno;</code> </pre><pre> <code class="plaintext hljs"> blkno | all_visible | all_frozen -------+-------------+------------ 0 | t | f 1 | t | f (2 rows)</code> </pre><br><h1>  Âge pour geler toute la table </h1><br>  Pour figer toujours la version des lignes laissées dans les pages que le nettoyage ne regarde tout simplement pas, un deuxième paramètre est fourni: <em>vacuum_freeze_table_age</em> .  Il détermine l'âge de la transaction, auquel le nettoyage ignore la carte de visibilité et parcourt toutes les pages de la table pour se figer. <br><br>  Chaque table stocke un numéro de transaction, pour lequel il est connu que toutes les transactions plus anciennes sont garanties d'être gelées (pg_class.relfrozenxid).  Avec l'âge de cette transaction mémorisée, la valeur du paramètre <em>vacuum_freeze_table_age</em> est <em>comparée</em> . <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfrozenxid, age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfrozenxid | age --------------+----- 694 | 5 (1 row)</code> </pre><br>  Avant PostgreSQL 9.6, le nettoyage effectuait une analyse complète de la table pour s'assurer que toutes les pages étaient analysées.  Pour les grandes tables, cette opération a été longue et triste.  L'affaire était aggravée par le fait que si le nettoyage n'arrivait pas à son terme (par exemple, un administrateur impatient interrompait l'exécution d'une commande), il fallait recommencer depuis le début. <br><br>  À partir de la version 9.6, grâce à la carte figée (que nous voyons dans la colonne all_frozen de la sortie pg_visibility_map), la suppression contourne uniquement les pages qui ne sont pas déjà marquées dans la carte.  Ce n'est pas seulement une quantité de travail beaucoup plus petite, mais aussi une résistance aux interruptions: si le processus de nettoyage est arrêté et recommencé, il n'aura pas à revoir les pages qu'il a déjà réussi à marquer dans la carte de congélation la dernière fois. <br><br>  D'une manière ou d'une autre, toutes les pages du tableau sont figées une fois dans les <em>transactions</em> ( <em>vacuum_freeze_table_age</em> - <em>vacuum_freeze_min_age</em> ).  Avec les valeurs par défaut, cela se produit une fois par million de transactions: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> vacuum_freeze_table_age;</code> </pre><pre> <code class="plaintext hljs"> vacuum_freeze_table_age ------------------------- 150000000 (1 row)</code> </pre><br>  Ainsi, il est clair que trop de <em>vacuum_freeze_min_age</em> ne doit pas être défini, car au lieu de réduire les frais généraux, cela commencera à les augmenter. <br><br>  Voyons comment la table entière est gelée, et pour ce faire, réduisez <em>vacuum_freeze_table_age</em> à 5 afin que la condition de gel soit remplie. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> vacuum_freeze_table_age = <span class="hljs-number"><span class="hljs-number">5</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Nettoyons: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> tfreeze;</code> </pre><br>  Maintenant, étant donné que la table entière a été garantie pour être vérifiée, le nombre de la transaction gelée peut être augmenté - nous sommes sûrs que les pages n'ont pas une transaction plus ancienne et non gelée. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfrozenxid, age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfrozenxid | age --------------+----- 698 | 1 (1 row)</code> </pre><br>  Maintenant, toutes les versions des lignes de la première page sont figées: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmin_age | xmax | t_ctid -------+---------------+---------+----------+-------+-------- (0,1) | redirect to 3 | | | | (0,2) | normal | 697 (f) | 2 | 0 (a) | (0,2) (0,3) | normal | 698 (c) | 1 | 0 (a) | (0,3) (1,1) | normal | 697 (f) | 2 | 0 (a) | (1,1) (1,2) | normal | 697 (f) | 2 | 0 (a) | (1,2) (5 rows)</code> </pre><br>  De plus, la première page est marquée dans la carte de gel: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) g(blkno), pg_visibility_map(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,g.blkno) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> g.blkno;</code> </pre><pre> <code class="plaintext hljs"> blkno | all_visible | all_frozen -------+-------------+------------ 0 | t | f 1 | t | t (2 rows)</code> </pre><br><h1>  Âge pour une réponse «agressive» </h1><br>  Il est important que les versions de ligne se figent à temps.  Si une situation se présente où une transaction qui n'a pas encore été gelée risque d'entrer dans le futur, PostgreSQL se bloquera pour éviter des problèmes potentiels. <br><br>  Quelle pourrait en être la raison?  Il y a plusieurs raisons. <br><br><ul><li>  Le nettoyage automatique peut être désactivé et le nettoyage régulier ne démarre pas non plus.  Nous avons déjà dit que ce n'est pas nécessaire, mais techniquement c'est possible. </li><li>  Même le nettoyage automatique inclus ne vient pas aux bases de données qui ne sont pas utilisées (rappelez-vous le paramètre <em>track_counts</em> et la base de données template0). </li><li>  Comme nous l'avons vu la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dernière fois</a> , le nettoyage ignore les tables dans lesquelles les données sont uniquement ajoutées, mais pas supprimées ou modifiées. </li></ul><br>  Dans de tels cas, une opération de <em>nettoyage automatique</em> «agressif» est fournie, et elle est régulée par le paramètre <em>autovacuum_freeze_max_age</em> .  Si dans n'importe quelle table d'une base de données, il est possible qu'une transaction non gelée soit plus ancienne que l'âge spécifié dans le paramètre, le nettoyage automatique démarre de force (même s'il est désactivé) et tôt ou tard, il atteindra la table des problèmes (malgré les critères habituels). <br><br>  La valeur par défaut est assez conservatrice: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> autovacuum_freeze_max_age;</code> </pre><pre> <code class="plaintext hljs"> autovacuum_freeze_max_age --------------------------- 200000000 (1 row)</code> </pre><br>  La limite pour <em>autovacuum_freeze_max_age</em> est de 2 milliards de transactions, et une valeur 10 fois plus petite est utilisée.  Cela a du sens: en augmentant la valeur, nous augmentons le risque que l'auto-nettoyage n'ait tout simplement pas le temps de geler toutes les versions nécessaires des lignes. <br><br>  De plus, la valeur de ce paramètre détermine la taille de la structure XACT: comme il ne devrait pas y avoir de transactions plus anciennes dans le système dont vous pourriez avoir besoin de connaître l'état, le nettoyage automatique supprime les fichiers de segments XACT inutiles, libérant ainsi de l'espace. <br><br>  Voyons comment le nettoyage gère les tables avec ajout uniquement, en utilisant tfreeze comme exemple.  Pour ce tableau, l'autonettoyage est généralement désactivé, mais ce ne sera pas un obstacle. <br><br>  La modification du paramètre <em>autovacuum_freeze_max_age</em> nécessite un redémarrage du serveur.  Mais tous les paramètres décrits ci-dessus peuvent également être définis au niveau des tables individuelles à l'aide des paramètres de stockage.  Habituellement, cela n'a de sens que dans des cas particuliers, lorsque la table nécessite vraiment un soin particulier. <br><br>  Donc, nous allons définir <em>autovacuum_freeze_max_age</em> au niveau de la table (et en même temps retourner le <em>facteur</em> de <em>remplissage</em> normal également).  Malheureusement, la valeur minimale possible est de 100 000: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tfreeze <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_freeze_max_age = <span class="hljs-number"><span class="hljs-number">100000</span></span>, fillfactor = <span class="hljs-number"><span class="hljs-number">100</span></span>);</code> </pre><br>  Malheureusement, car nous devons effectuer 100 000 transactions afin de reproduire la situation qui nous intéresse.  Mais, bien sûr, à des fins pratiques, il s'agit d'une valeur très, très faible. <br><br>  Puisque nous allons ajouter des données, nous allons insérer 100 000 lignes dans le tableau - chacune dans notre transaction.  Et encore une fois, je dois faire une réserve que, dans la pratique, cela ne devrait pas être fait.  Mais maintenant, nous explorons, nous le pouvons. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> foo(id <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BEGIN</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">INSERT</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">INTO</span></span></span><span class="pgsql"> tfreeze </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">VALUES</span></span></span><span class="pgsql"> (id, </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'FOO'</span></span></span><span class="pgsql">); </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">COMMIT</span></span></span><span class="pgsql">; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql">; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> plpgsql; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DO</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BEGIN</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FOR</span></span></span><span class="pgsql"> i </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">IN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">101</span></span></span><span class="pgsql"> .. </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">100100</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">LOOP</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CALL</span></span></span><span class="pgsql"> foo(i); </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">LOOP</span></span></span><span class="pgsql">; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql">; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span>;</code> </pre><br>  Comme nous pouvons le voir, l'âge de la dernière transaction gelée dans le tableau a dépassé la valeur seuil: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfrozenxid, age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfrozenxid | age --------------+-------- 698 | 100006 (1 row)</code> </pre><br>  Mais si vous attendez un peu maintenant, dans le journal des messages du serveur, il y aura une entrée sur le vide agressif automatique de la table "test.public.tfreeze", le numéro de la transaction gelée changera et son âge reviendra à la décence: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfrozenxid, age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfrozenxid | age --------------+----- 100703 | 3 (1 row)</code> </pre><br><blockquote>  Il y a aussi le gel des transactions multiples, mais nous n'en parlerons pas encore - nous le reporterons jusqu'à ce que nous parlions de verrous afin de ne pas prendre de l'avance sur nous-mêmes. <br></blockquote><br><h1>  Congélation manuelle </h1><br>  Parfois, il est pratique de contrôler manuellement le gel plutôt que d'attendre l'arrivée de l'auto-nettoyage. <br><br>  Vous pouvez figer manuellement une commande à l'aide de la commande VACUUM FREEZE - toutes les versions de ligne seront gelées, quel que soit l'âge des transactions (comme si le paramètre <em>autovacuum_freeze_min_age</em> = 0).  Lorsqu'une table est reconstruite avec les commandes VACUUM FULL ou CLUSTER, toutes les lignes sont également figées. <br><br>  Pour figer toutes les bases de données, vous pouvez utiliser l'utilitaire: <br><br><pre> <code class="plaintext hljs">vacuumdb --all --freeze</code> </pre><br>  Les données peuvent également être gelées lors du chargement initial à l'aide de la commande COPY en spécifiant le paramètre FREEZE.  Pour ce faire, la table doit être créée (ou vidée avec la commande TRUNCATE) dans le même <br>  transactions comme COPY. <br><br>  Étant donné qu'il existe des règles de visibilité distinctes pour les lignes figées, ces lignes seront visibles dans les instantanés des données d'autres transactions en violation des règles d'isolement habituelles (cela s'applique aux transactions avec le niveau Lecture répétable ou Sérialisable). <br><br>  Pour vérifier cela, dans une autre session, démarrez une transaction avec le niveau d'isolement Lecture répétable: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><br>  Notez que cette transaction a généré un instantané des données, mais n'a pas accédé à la table tfreeze.  Nous allons maintenant vider la table tfreeze et y charger de nouvelles lignes en une seule transaction.  Si une transaction parallèle lit le contenu de tfreeze, la commande TRUNCATE sera verrouillée jusqu'à la fin de la transaction. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> tfreeze; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COPY</span></span> tfreeze <span class="hljs-keyword"><span class="hljs-keyword">FROM stdin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FREEZE</span></span>;</code> </pre><pre> <code class="plaintext hljs">1 FOO 2 BAR 3 BAZ \.</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Maintenant, une transaction parallèle voit de nouvelles données, bien que cela brise l'isolement: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tfreeze;</code> </pre><pre> <code class="plaintext hljs">| count | ------- | 3 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Mais, comme il est peu probable qu'un tel chargement de données se produise régulièrement, ce n'est généralement pas un problème. <br><br>  Pire encore, COPY WITH FREEZE ne fonctionne pas avec la carte de visibilité - les pages chargées ne sont pas marquées comme ne contenant que les versions des lignes visibles par tout le monde.  Par conséquent, lorsque vous accédez pour la première fois à la table, le nettoyage est obligé de tout retraiter et de créer une carte de visibilité.  Pour aggraver les choses, les pages de données ont un signe de pleine visibilité dans leur propre en-tête, donc le nettoyage non seulement lit la table entière, mais aussi la réécrit complètement, en posant le bit souhaité.  Malheureusement, la solution à ce problème ne doit pas attendre plus tôt que la version 13 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">discussion</a> ). <br><br><h1>  Conclusion </h1><br>  Ceci conclut ma série d'articles sur l'isolement et le multiversion de PostgreSQL.  Merci pour votre attention et surtout pour les commentaires - ils améliorent le matériel et soulignent souvent des domaines qui nécessitent une attention plus attentive de ma part. <br><br>  Restez avec nous, pour continuer! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr455590/">https://habr.com/ru/post/fr455590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr455580/index.html">Animations d'applications mobiles incontournables</a></li>
<li><a href="../fr455582/index.html">Navigation dans le magasin: de la réalité augmentée à l'étagère souhaitée</a></li>
<li><a href="../fr455584/index.html">Entretiens personnalisés avec les forces internes de l'entreprise: des erreurs aux découvertes</a></li>
<li><a href="../fr455586/index.html">Série de conférences sur la robotique par le professeur Gregor Schöner, directeur de l'Institut de neuroinformatique (INI) Bochum, Allemagne</a></li>
<li><a href="../fr455588/index.html">Comment éduquer votre communauté pour ne pas danser avec un tambourin</a></li>
<li><a href="../fr455592/index.html">Les virus attaquant les entreprises industrielles comme une menace pour la sécurité physique</a></li>
<li><a href="../fr455594/index.html">Microsoft Edge de CVE à RCE sur Windows 10</a></li>
<li><a href="../fr455596/index.html">DevConfX :: Management - rapports des managers en mots simples</a></li>
<li><a href="../fr455598/index.html">Mettre à jour Exim à 4.92 de toute urgence - il y a une infection active</a></li>
<li><a href="../fr455600/index.html">La plateforme 3DEXPERIENCE aide à créer les transports publics du futur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>