<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äç‚öïÔ∏è ‚ùóÔ∏è üë≥ MVCC dans PostgreSQL-8. Cong√©lation üëåüèΩ üë©‚Äç‚ù§Ô∏è‚Äçüë© üñºÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous avons commenc√© par des probl√®mes li√©s √† l' isolement , avons fait une digression sur l' organisation des donn√©es √† un bas niveau et avons parl√© e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC dans PostgreSQL-8. Cong√©lation</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/455590/">  Nous avons commenc√© par des probl√®mes li√©s √† l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">isolement</a> , avons fait une digression sur l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">organisation des donn√©es √† un bas niveau</a> et avons parl√© en d√©tail des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">versions de ligne</a> et de la fa√ßon dont les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">instantan√©s</a> sont obtenus √† partir des versions. <br><br>  Ensuite, nous avons examin√© diff√©rents types de nettoyage: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">intra-page</a> (avec mises √† jour HOT), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©gulier</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">automatique</a> . <br><br>  Et je suis arriv√© au dernier sujet de ce cycle.  Aujourd'hui, nous allons parler du probl√®me de l'habillage et du gel des ID de transaction. <br><a name="habracut"></a><br><h1>  D√©bordement du compteur de transactions </h1><br>  PostgreSQL a 32 bits allou√©s pour le num√©ro de transaction.  C'est un nombre assez important (environ 4 milliards), mais avec le fonctionnement actif du serveur, il pourrait bien √™tre √©puis√©.  Par exemple, √† une charge de 1000 transactions par seconde, cela se produira apr√®s seulement un mois et demi de fonctionnement continu. <br><br>  Mais nous avons parl√© du fait que le m√©canisme de multi-versions repose sur la s√©quence de num√©rotation - alors sur deux transactions, une transaction avec un nombre inf√©rieur peut √™tre consid√©r√©e comme ayant commenc√© plus t√¥t.  Par cons√©quent, il est clair que vous ne pouvez pas simplement r√©initialiser le compteur et continuer √† nouveau la num√©rotation. <br><br><img src="https://habrastorage.org/webt/cn/om/rg/cnomrgflv1bnkqme9k68bit4ad0.png"><br><br>  Pourquoi est-ce que 64 bits ne sont pas allou√©s pour le num√©ro de transaction - car cela √©liminerait compl√®tement le probl√®me?  Le fait est que (comme discut√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pr√©c√©demment</a> ) dans l'en-t√™te de chaque version de la ligne sont stock√©s deux num√©ros de transaction - xmin et xmax.  L'en-t√™te est d√©j√† assez volumineux, au moins 23 octets, et une augmentation de la profondeur de bits entra√Ænerait son augmentation de 8 octets suppl√©mentaires.  Ce n'est absolument pas possible. <br><br><blockquote>  Les num√©ros de transaction 64 bits sont impl√©ment√©s dans le produit de notre soci√©t√©, Postgres Pro Enterprise, mais ils ne sont pas tout √† fait honn√™tes non plus: xmin et xmax restent 32 bits, et l'en-t√™te de la page contient un "d√©but d'une √®re" commun √† l'√©chelle de la page. <br></blockquote><br>  Que faire?  Au lieu d'un diagramme lin√©aire, tous les num√©ros de transaction sont boucl√©s.  Pour toute transaction, la moiti√© des chiffres ¬´dans le sens antihoraire¬ª sont consid√©r√©s comme appartenant au pass√©, et la moiti√© ¬´dans le sens horaire¬ª √† l'avenir. <br><br>  L'√¢ge d'une transaction est le nombre de transactions pass√©es depuis son apparition dans le syst√®me (que le compteur soit pass√© par z√©ro ou non).  Lorsque nous voulons comprendre si une transaction est plus ancienne qu'une autre ou non, nous comparons leur √¢ge, pas leurs chiffres.  (Par cons√©quent, soit dit en passant, les op√©rations ¬´sup√©rieur¬ª et ¬´moins¬ª ne sont pas d√©finies pour le type de donn√©es xid.) <br><br><img src="https://habrastorage.org/webt/8f/rk/ft/8frkftw38-c0-yfbjaz7m-au3va.png"><br><br>  Mais dans un tel circuit en boucle, une situation d√©sagr√©able se pr√©sente.  Une transaction qui √©tait dans un pass√© lointain (transaction 1 sur la figure), apr√®s un certain temps sera dans la moiti√© du cercle qui se rapporte √† l'avenir.  Cela, bien s√ªr, viole les r√®gles de visibilit√© et entra√Ænerait des probl√®mes - les modifications apport√©es par la transaction 1 dispara√Ætraient tout simplement de la vue. <br><br><img src="https://habrastorage.org/webt/qp/vy/ag/qpvyagxruu4gik-rof6eqoxk1e4.png"><br><br><h1>  R√®gles de gel et de visibilit√© des versions </h1><br>  Afin d'√©viter de tels ¬´voyages¬ª du pass√© vers le futur, le processus de nettoyage (en plus de lib√©rer de l'espace dans les pages) effectue une autre t√¢che.  Il trouve des versions assez anciennes et ¬´froides¬ª des lignes (qui sont visibles dans toutes les images et dont le changement est d√©j√† peu probable) et les marque d'une mani√®re sp√©ciale - les ¬´g√®le¬ª.  La version fig√©e de la ligne est consid√©r√©e comme plus ancienne que toutes les donn√©es normales et est toujours visible dans tous les instantan√©s de donn√©es.  De plus, il n'est plus n√©cessaire de regarder le num√©ro de transaction xmin, et ce num√©ro peut √™tre r√©utilis√© en toute s√©curit√©.  Ainsi, les versions fig√©es des cha√Ænes restent toujours dans le pass√©. <br><br><img src="https://habrastorage.org/webt/2c/vn/yp/2cvnypkp70pikgco9rzjjiccob0.png"><br><br>  Afin de marquer le num√©ro de transaction xmin comme fig√©, les deux bits de conseil sont d√©finis en m√™me temps - le bit de validation et le bit d'annulation. <br><br>  Notez que la transaction xmax n'a pas besoin d'√™tre gel√©e.  Sa pr√©sence signifie que cette version de la cha√Æne n'est plus pertinente.  Une fois qu'elle ne sera plus visible dans les instantan√©s de donn√©es, cette version de la ligne sera effac√©e. <br><br>  Pour les exp√©riences, cr√©ez un tableau.  Nous avons d√©fini le facteur de remplissage minimum pour que seules deux lignes tiennent sur chaque page - il sera donc plus pratique pour nous d'observer ce qui se passe.  Et d√©sactivez l'automatisation pour contr√¥ler vous-m√™me le temps de nettoyage. <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tfreeze( id <span class="hljs-type"><span class="hljs-type">integer</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">300</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (fillfactor = <span class="hljs-number"><span class="hljs-number">10</span></span>, autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>);</code> </pre> <br>  Nous avons d√©j√† cr√©√© plusieurs variantes de la fonction, qui, en utilisant l'extension pageinspect, a montr√© la version des lignes qui sont sur la page.  Nous allons maintenant cr√©er une autre version de la m√™me fonction: maintenant, elle affichera plusieurs pages √† la fois et affichera l'√¢ge de la transaction xmin (l'√¢ge de la fonction syst√®me est utilis√© pour cela): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> heap_page(relname <span class="hljs-type"><span class="hljs-type">text</span></span>, pageno_from <span class="hljs-type"><span class="hljs-type">integer</span></span>, pageno_to <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span>(ctid tid, state <span class="hljs-type"><span class="hljs-type">text</span></span>, xmin <span class="hljs-type"><span class="hljs-type">text</span></span>, xmin_age <span class="hljs-type"><span class="hljs-type">integer</span></span>, xmax <span class="hljs-type"><span class="hljs-type">text</span></span>, t_ctid tid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> (pageno,lp)::</span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">text</span></span></span><span class="pgsql">::tid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> ctid, </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> lp_flags </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'unused'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'normal'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'redirect to '</span></span></span><span class="pgsql">||lp_off </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">3</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'dead'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> state, t_xmin || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">256</span></span></span><span class="pgsql">+</span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">512</span></span></span><span class="pgsql">) = </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">256</span></span></span><span class="pgsql">+</span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">512</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (f)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">256</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">512</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmin, age(t_xmin) xmin_age, t_xmax || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1024</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2048</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmax, t_ctid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> generate_series(pageno_from, pageno_to) p(pageno), heap_page_items(get_raw_page(relname, pageno)) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ORDER</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BY</span></span></span><span class="pgsql"> pageno, lp; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>;</code> </pre><br>  Veuillez noter que le signe de gel (que nous montrons avec la lettre f entre parenth√®ses) est d√©termin√© par l'installation simultan√©e d'invites valid√©es et abandonn√©es.  De nombreuses sources (y compris la documentation) mentionnent le nombre sp√©cial FrozenTransactionId = 2, qui marque les transactions gel√©es.  Un tel syst√®me fonctionnait jusqu'√† la version 9.4, mais il a maintenant √©t√© remplac√© par des bits d'info-bulle - cela vous permet d'enregistrer le num√©ro de transaction d'origine dans la version en ligne, ce qui est pratique √† des fins de support et de d√©bogage.  Cependant, les transactions avec le num√©ro 2 peuvent toujours se produire dans les anciens syst√®mes, m√™me mis √† niveau vers les derni√®res versions. <br><br>  Nous avons √©galement besoin de l'extension pg_visibility, qui vous permet de consulter la carte de visibilit√©: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pg_visibility;</code> </pre><br>  Avant PostgreSQL 9.6, la carte de visibilit√© contenait un bit par page;  il a marqu√© des pages contenant uniquement des versions "assez anciennes" de cha√Ænes qui sont d√©j√† garanties d'√™tre visibles sur toutes les images.  L'id√©e ici est que si la page est marqu√©e dans la carte de visibilit√©, alors pour sa version des lignes, vous n'avez pas besoin de v√©rifier les r√®gles de visibilit√©. <br><br>  √Ä partir de la version 9.6, une carte fig√©e a √©t√© ajout√©e √† la m√™me couche - un bit de plus par page.  La carte de gel marque les pages sur lesquelles toutes les versions des lignes sont fig√©es. <br><br>  Nous ins√©rons plusieurs lignes dans le tableau et effectuons imm√©diatement le nettoyage pour cr√©er une carte de visibilit√©: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> tfreeze(id, s) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> g.id, <span class="hljs-string"><span class="hljs-string">'FOO'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span>) g(id); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> tfreeze;</code> </pre><br>  Et nous voyons que les deux pages sont maintenant marqu√©es dans la carte de visibilit√© (all_visible), mais pas encore fig√©es (all_frozen): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) g(blkno), pg_visibility_map(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,g.blkno) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> g.blkno;</code> </pre><pre> <code class="plaintext hljs"> blkno | all_visible | all_frozen -------+-------------+------------ 0 | t | f 1 | t | f (2 rows)</code> </pre><br>  L'√¢ge de la transaction qui a cr√©√© les lignes (xmin_age) est 1 - il s'agit de la derni√®re transaction effectu√©e sur le syst√®me: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmin_age | xmax | t_ctid -------+--------+---------+----------+-------+-------- (0,1) | normal | 697 (c) | 1 | 0 (a) | (0,1) (0,2) | normal | 697 (c) | 1 | 0 (a) | (0,2) (1,1) | normal | 697 (c) | 1 | 0 (a) | (1,1) (1,2) | normal | 697 (c) | 1 | 0 (a) | (1,2) (4 rows)</code> </pre><br><h1>  √Çge minimum pour congeler </h1><br>  Trois param√®tres principaux contr√¥lent le gel, et nous les examinerons tour √† tour. <br><br>  Commen√ßons par <em>vacuum_freeze_min_age</em> , qui d√©finit l'√¢ge minimum de transaction xmin auquel la version de cha√Æne peut √™tre gel√©e.  Plus cette valeur est faible, plus les frais g√©n√©raux inutiles peuvent s'av√©rer √™tre: si nous avons affaire √† des donn√©es ¬´chaudes¬ª et en changement actif, le gel de plus en plus de nouvelles versions sera inutile.  Dans ce cas, il vaut mieux attendre. <br><br>  La valeur par d√©faut de ce param√®tre d√©finit que les transactions commencent √† geler apr√®s que 50 millions d'autres transactions se soient √©coul√©es depuis leur apparition: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> vacuum_freeze_min_age;</code> </pre><pre> <code class="plaintext hljs"> vacuum_freeze_min_age ----------------------- 50000000 (1 row)</code> </pre><br>  Afin de voir comment le gel se produit, nous r√©duisons la valeur de ce param√®tre √† l'unit√©. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> vacuum_freeze_min_age = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Et nous mettrons √† jour une ligne sur la page z√©ro.  La nouvelle version arrivera √† la m√™me page en raison de la petite valeur fillfactor. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> tfreeze <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'BAR'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Voici ce que nous voyons maintenant dans les pages de donn√©es: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmin_age | xmax | t_ctid -------+--------+---------+----------+-------+-------- (0,1) | normal | 697 (c) | 2 | 698 | (0,3) (0,2) | normal | 697 (c) | 2 | 0 (a) | (0,2) (0,3) | normal | 698 | 1 | 0 (a) | (0,3) (1,1) | normal | 697 (c) | 2 | 0 (a) | (1,1) (1,2) | normal | 697 (c) | 2 | 0 (a) | (1,2) (5 rows)</code> </pre><br>  Maintenant, les lignes plus anciennes que <em>vacuum_freeze_min_age</em> = 1 doivent √™tre gel√©es.  Mais notez que la ligne z√©ro n'est pas marqu√©e dans la carte de visibilit√© (le bit a √©t√© r√©initialis√© par la commande UPDATE, qui a chang√© la page), et la premi√®re reste v√©rifi√©e: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) g(blkno), pg_visibility_map(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,g.blkno) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> g.blkno;</code> </pre><pre> <code class="plaintext hljs"> blkno | all_visible | all_frozen -------+-------------+------------ 0 | f | f 1 | t | f (2 rows)</code> </pre><br>  Nous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">avons d√©j√† dit</a> que le nettoyage ne num√©rise que les pages qui ne sont pas marqu√©es dans la carte de visibilit√©.  Et il s'av√®re donc: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> tfreeze; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmin_age | xmax | t_ctid -------+---------------+---------+----------+-------+-------- (0,1) | redirect to 3 | | | | (0,2) | normal | 697 (f) | 2 | 0 (a) | (0,2) (0,3) | normal | 698 (c) | 1 | 0 (a) | (0,3) (1,1) | normal | 697 (c) | 2 | 0 (a) | (1,1) (1,2) | normal | 697 (c) | 2 | 0 (a) | (1,2) (5 rows)</code> </pre><br>  Sur la page z√©ro, une version est fig√©e, mais la premi√®re page ne consid√©rait pas du tout le nettoyage.  Ainsi, si seules les versions actuelles sont laiss√©es sur la page, le nettoyage ne viendra pas sur une telle page et ne les g√®lera pas. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) g(blkno), pg_visibility_map(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,g.blkno) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> g.blkno;</code> </pre><pre> <code class="plaintext hljs"> blkno | all_visible | all_frozen -------+-------------+------------ 0 | t | f 1 | t | f (2 rows)</code> </pre><br><h1>  √Çge pour geler toute la table </h1><br>  Pour figer toujours la version des lignes laiss√©es dans les pages que le nettoyage ne regarde tout simplement pas, un deuxi√®me param√®tre est fourni: <em>vacuum_freeze_table_age</em> .  Il d√©termine l'√¢ge de la transaction, auquel le nettoyage ignore la carte de visibilit√© et parcourt toutes les pages de la table pour se figer. <br><br>  Chaque table stocke un num√©ro de transaction, pour lequel il est connu que toutes les transactions plus anciennes sont garanties d'√™tre gel√©es (pg_class.relfrozenxid).  Avec l'√¢ge de cette transaction m√©moris√©e, la valeur du param√®tre <em>vacuum_freeze_table_age</em> est <em>compar√©e</em> . <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfrozenxid, age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfrozenxid | age --------------+----- 694 | 5 (1 row)</code> </pre><br>  Avant PostgreSQL 9.6, le nettoyage effectuait une analyse compl√®te de la table pour s'assurer que toutes les pages √©taient analys√©es.  Pour les grandes tables, cette op√©ration a √©t√© longue et triste.  L'affaire √©tait aggrav√©e par le fait que si le nettoyage n'arrivait pas √† son terme (par exemple, un administrateur impatient interrompait l'ex√©cution d'une commande), il fallait recommencer depuis le d√©but. <br><br>  √Ä partir de la version 9.6, gr√¢ce √† la carte fig√©e (que nous voyons dans la colonne all_frozen de la sortie pg_visibility_map), la suppression contourne uniquement les pages qui ne sont pas d√©j√† marqu√©es dans la carte.  Ce n'est pas seulement une quantit√© de travail beaucoup plus petite, mais aussi une r√©sistance aux interruptions: si le processus de nettoyage est arr√™t√© et recommenc√©, il n'aura pas √† revoir les pages qu'il a d√©j√† r√©ussi √† marquer dans la carte de cong√©lation la derni√®re fois. <br><br>  D'une mani√®re ou d'une autre, toutes les pages du tableau sont fig√©es une fois dans les <em>transactions</em> ( <em>vacuum_freeze_table_age</em> - <em>vacuum_freeze_min_age</em> ).  Avec les valeurs par d√©faut, cela se produit une fois par million de transactions: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> vacuum_freeze_table_age;</code> </pre><pre> <code class="plaintext hljs"> vacuum_freeze_table_age ------------------------- 150000000 (1 row)</code> </pre><br>  Ainsi, il est clair que trop de <em>vacuum_freeze_min_age</em> ne doit pas √™tre d√©fini, car au lieu de r√©duire les frais g√©n√©raux, cela commencera √† les augmenter. <br><br>  Voyons comment la table enti√®re est gel√©e, et pour ce faire, r√©duisez <em>vacuum_freeze_table_age</em> √† 5 afin que la condition de gel soit remplie. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> vacuum_freeze_table_age = <span class="hljs-number"><span class="hljs-number">5</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Nettoyons: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> tfreeze;</code> </pre><br>  Maintenant, √©tant donn√© que la table enti√®re a √©t√© garantie pour √™tre v√©rifi√©e, le nombre de la transaction gel√©e peut √™tre augment√© - nous sommes s√ªrs que les pages n'ont pas une transaction plus ancienne et non gel√©e. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfrozenxid, age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfrozenxid | age --------------+----- 698 | 1 (1 row)</code> </pre><br>  Maintenant, toutes les versions des lignes de la premi√®re page sont fig√©es: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmin_age | xmax | t_ctid -------+---------------+---------+----------+-------+-------- (0,1) | redirect to 3 | | | | (0,2) | normal | 697 (f) | 2 | 0 (a) | (0,2) (0,3) | normal | 698 (c) | 1 | 0 (a) | (0,3) (1,1) | normal | 697 (f) | 2 | 0 (a) | (1,1) (1,2) | normal | 697 (f) | 2 | 0 (a) | (1,2) (5 rows)</code> </pre><br>  De plus, la premi√®re page est marqu√©e dans la carte de gel: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) g(blkno), pg_visibility_map(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,g.blkno) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> g.blkno;</code> </pre><pre> <code class="plaintext hljs"> blkno | all_visible | all_frozen -------+-------------+------------ 0 | t | f 1 | t | t (2 rows)</code> </pre><br><h1>  √Çge pour une r√©ponse ¬´agressive¬ª </h1><br>  Il est important que les versions de ligne se figent √† temps.  Si une situation se pr√©sente o√π une transaction qui n'a pas encore √©t√© gel√©e risque d'entrer dans le futur, PostgreSQL se bloquera pour √©viter des probl√®mes potentiels. <br><br>  Quelle pourrait en √™tre la raison?  Il y a plusieurs raisons. <br><br><ul><li>  Le nettoyage automatique peut √™tre d√©sactiv√© et le nettoyage r√©gulier ne d√©marre pas non plus.  Nous avons d√©j√† dit que ce n'est pas n√©cessaire, mais techniquement c'est possible. </li><li>  M√™me le nettoyage automatique inclus ne vient pas aux bases de donn√©es qui ne sont pas utilis√©es (rappelez-vous le param√®tre <em>track_counts</em> et la base de donn√©es template0). </li><li>  Comme nous l'avons vu la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">derni√®re fois</a> , le nettoyage ignore les tables dans lesquelles les donn√©es sont uniquement ajout√©es, mais pas supprim√©es ou modifi√©es. </li></ul><br>  Dans de tels cas, une op√©ration de <em>nettoyage automatique</em> ¬´agressif¬ª est fournie, et elle est r√©gul√©e par le param√®tre <em>autovacuum_freeze_max_age</em> .  Si dans n'importe quelle table d'une base de donn√©es, il est possible qu'une transaction non gel√©e soit plus ancienne que l'√¢ge sp√©cifi√© dans le param√®tre, le nettoyage automatique d√©marre de force (m√™me s'il est d√©sactiv√©) et t√¥t ou tard, il atteindra la table des probl√®mes (malgr√© les crit√®res habituels). <br><br>  La valeur par d√©faut est assez conservatrice: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> autovacuum_freeze_max_age;</code> </pre><pre> <code class="plaintext hljs"> autovacuum_freeze_max_age --------------------------- 200000000 (1 row)</code> </pre><br>  La limite pour <em>autovacuum_freeze_max_age</em> est de 2 milliards de transactions, et une valeur 10 fois plus petite est utilis√©e.  Cela a du sens: en augmentant la valeur, nous augmentons le risque que l'auto-nettoyage n'ait tout simplement pas le temps de geler toutes les versions n√©cessaires des lignes. <br><br>  De plus, la valeur de ce param√®tre d√©termine la taille de la structure XACT: comme il ne devrait pas y avoir de transactions plus anciennes dans le syst√®me dont vous pourriez avoir besoin de conna√Ætre l'√©tat, le nettoyage automatique supprime les fichiers de segments XACT inutiles, lib√©rant ainsi de l'espace. <br><br>  Voyons comment le nettoyage g√®re les tables avec ajout uniquement, en utilisant tfreeze comme exemple.  Pour ce tableau, l'autonettoyage est g√©n√©ralement d√©sactiv√©, mais ce ne sera pas un obstacle. <br><br>  La modification du param√®tre <em>autovacuum_freeze_max_age</em> n√©cessite un red√©marrage du serveur.  Mais tous les param√®tres d√©crits ci-dessus peuvent √©galement √™tre d√©finis au niveau des tables individuelles √† l'aide des param√®tres de stockage.  Habituellement, cela n'a de sens que dans des cas particuliers, lorsque la table n√©cessite vraiment un soin particulier. <br><br>  Donc, nous allons d√©finir <em>autovacuum_freeze_max_age</em> au niveau de la table (et en m√™me temps retourner le <em>facteur</em> de <em>remplissage</em> normal √©galement).  Malheureusement, la valeur minimale possible est de 100 000: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tfreeze <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_freeze_max_age = <span class="hljs-number"><span class="hljs-number">100000</span></span>, fillfactor = <span class="hljs-number"><span class="hljs-number">100</span></span>);</code> </pre><br>  Malheureusement, car nous devons effectuer 100 000 transactions afin de reproduire la situation qui nous int√©resse.  Mais, bien s√ªr, √† des fins pratiques, il s'agit d'une valeur tr√®s, tr√®s faible. <br><br>  Puisque nous allons ajouter des donn√©es, nous allons ins√©rer 100 000 lignes dans le tableau - chacune dans notre transaction.  Et encore une fois, je dois faire une r√©serve que, dans la pratique, cela ne devrait pas √™tre fait.  Mais maintenant, nous explorons, nous le pouvons. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> foo(id <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BEGIN</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">INSERT</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">INTO</span></span></span><span class="pgsql"> tfreeze </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">VALUES</span></span></span><span class="pgsql"> (id, </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'FOO'</span></span></span><span class="pgsql">); </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">COMMIT</span></span></span><span class="pgsql">; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql">; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> plpgsql; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DO</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BEGIN</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FOR</span></span></span><span class="pgsql"> i </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">IN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">101</span></span></span><span class="pgsql"> .. </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">100100</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">LOOP</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CALL</span></span></span><span class="pgsql"> foo(i); </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">LOOP</span></span></span><span class="pgsql">; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql">; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span>;</code> </pre><br>  Comme nous pouvons le voir, l'√¢ge de la derni√®re transaction gel√©e dans le tableau a d√©pass√© la valeur seuil: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfrozenxid, age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfrozenxid | age --------------+-------- 698 | 100006 (1 row)</code> </pre><br>  Mais si vous attendez un peu maintenant, dans le journal des messages du serveur, il y aura une entr√©e sur le vide agressif automatique de la table "test.public.tfreeze", le num√©ro de la transaction gel√©e changera et son √¢ge reviendra √† la d√©cence: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfrozenxid, age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfrozenxid | age --------------+----- 100703 | 3 (1 row)</code> </pre><br><blockquote>  Il y a aussi le gel des transactions multiples, mais nous n'en parlerons pas encore - nous le reporterons jusqu'√† ce que nous parlions de verrous afin de ne pas prendre de l'avance sur nous-m√™mes. <br></blockquote><br><h1>  Cong√©lation manuelle </h1><br>  Parfois, il est pratique de contr√¥ler manuellement le gel plut√¥t que d'attendre l'arriv√©e de l'auto-nettoyage. <br><br>  Vous pouvez figer manuellement une commande √† l'aide de la commande VACUUM FREEZE - toutes les versions de ligne seront gel√©es, quel que soit l'√¢ge des transactions (comme si le param√®tre <em>autovacuum_freeze_min_age</em> = 0).  Lorsqu'une table est reconstruite avec les commandes VACUUM FULL ou CLUSTER, toutes les lignes sont √©galement fig√©es. <br><br>  Pour figer toutes les bases de donn√©es, vous pouvez utiliser l'utilitaire: <br><br><pre> <code class="plaintext hljs">vacuumdb --all --freeze</code> </pre><br>  Les donn√©es peuvent √©galement √™tre gel√©es lors du chargement initial √† l'aide de la commande COPY en sp√©cifiant le param√®tre FREEZE.  Pour ce faire, la table doit √™tre cr√©√©e (ou vid√©e avec la commande TRUNCATE) dans le m√™me <br>  transactions comme COPY. <br><br>  √âtant donn√© qu'il existe des r√®gles de visibilit√© distinctes pour les lignes fig√©es, ces lignes seront visibles dans les instantan√©s des donn√©es d'autres transactions en violation des r√®gles d'isolement habituelles (cela s'applique aux transactions avec le niveau Lecture r√©p√©table ou S√©rialisable). <br><br>  Pour v√©rifier cela, dans une autre session, d√©marrez une transaction avec le niveau d'isolement Lecture r√©p√©table: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><br>  Notez que cette transaction a g√©n√©r√© un instantan√© des donn√©es, mais n'a pas acc√©d√© √† la table tfreeze.  Nous allons maintenant vider la table tfreeze et y charger de nouvelles lignes en une seule transaction.  Si une transaction parall√®le lit le contenu de tfreeze, la commande TRUNCATE sera verrouill√©e jusqu'√† la fin de la transaction. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> tfreeze; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COPY</span></span> tfreeze <span class="hljs-keyword"><span class="hljs-keyword">FROM stdin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FREEZE</span></span>;</code> </pre><pre> <code class="plaintext hljs">1 FOO 2 BAR 3 BAZ \.</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Maintenant, une transaction parall√®le voit de nouvelles donn√©es, bien que cela brise l'isolement: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tfreeze;</code> </pre><pre> <code class="plaintext hljs">| count | ------- | 3 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Mais, comme il est peu probable qu'un tel chargement de donn√©es se produise r√©guli√®rement, ce n'est g√©n√©ralement pas un probl√®me. <br><br>  Pire encore, COPY WITH FREEZE ne fonctionne pas avec la carte de visibilit√© - les pages charg√©es ne sont pas marqu√©es comme ne contenant que les versions des lignes visibles par tout le monde.  Par cons√©quent, lorsque vous acc√©dez pour la premi√®re fois √† la table, le nettoyage est oblig√© de tout retraiter et de cr√©er une carte de visibilit√©.  Pour aggraver les choses, les pages de donn√©es ont un signe de pleine visibilit√© dans leur propre en-t√™te, donc le nettoyage non seulement lit la table enti√®re, mais aussi la r√©√©crit compl√®tement, en posant le bit souhait√©.  Malheureusement, la solution √† ce probl√®me ne doit pas attendre plus t√¥t que la version 13 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">discussion</a> ). <br><br><h1>  Conclusion </h1><br>  Ceci conclut ma s√©rie d'articles sur l'isolement et le multiversion de PostgreSQL.  Merci pour votre attention et surtout pour les commentaires - ils am√©liorent le mat√©riel et soulignent souvent des domaines qui n√©cessitent une attention plus attentive de ma part. <br><br>  Restez avec nous, pour continuer! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr455590/">https://habr.com/ru/post/fr455590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr455580/index.html">Animations d'applications mobiles incontournables</a></li>
<li><a href="../fr455582/index.html">Navigation dans le magasin: de la r√©alit√© augment√©e √† l'√©tag√®re souhait√©e</a></li>
<li><a href="../fr455584/index.html">Entretiens personnalis√©s avec les forces internes de l'entreprise: des erreurs aux d√©couvertes</a></li>
<li><a href="../fr455586/index.html">S√©rie de conf√©rences sur la robotique par le professeur Gregor Sch√∂ner, directeur de l'Institut de neuroinformatique (INI) Bochum, Allemagne</a></li>
<li><a href="../fr455588/index.html">Comment √©duquer votre communaut√© pour ne pas danser avec un tambourin</a></li>
<li><a href="../fr455592/index.html">Les virus attaquant les entreprises industrielles comme une menace pour la s√©curit√© physique</a></li>
<li><a href="../fr455594/index.html">Microsoft Edge de CVE √† RCE sur Windows 10</a></li>
<li><a href="../fr455596/index.html">DevConfX :: Management - rapports des managers en mots simples</a></li>
<li><a href="../fr455598/index.html">Mettre √† jour Exim √† 4.92 de toute urgence - il y a une infection active</a></li>
<li><a href="../fr455600/index.html">La plateforme 3DEXPERIENCE aide √† cr√©er les transports publics du futur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>