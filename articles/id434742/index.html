<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📝 🕍 🈷️ Bagian 2: Menggunakan pengontrol PSBC UDB Cypress untuk mengurangi jumlah interupsi dalam printer 3D 🦅 👨🏼‍💼 🤷🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Terakhir kali, kami mempertimbangkan opsi untuk menghasilkan pulsa untuk motor stepper, sebagian dihapus dari perangkat lunak ke tingkat firmware. Dal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagian 2: Menggunakan pengontrol PSBC UDB Cypress untuk mengurangi jumlah interupsi dalam printer 3D</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434742/"><img src="https://habrastorage.org/webt/vx/mr/gy/vxmrgyrhaaffninezudmxyiex9c.jpeg"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Terakhir kali,</a> kami mempertimbangkan opsi untuk menghasilkan pulsa untuk motor stepper, sebagian dihapus dari perangkat lunak ke tingkat firmware.  Dalam hal kesuksesan penuh, ini menjanjikan tidak adanya kebutuhan untuk memproses interupsi tiba dengan frekuensi hingga 40 KHz.  Tetapi opsi itu memiliki sejumlah kelemahan yang jelas.  Pertama, akselerasi tidak didukung di sana.  Kedua, rincian frekuensi langkah yang diizinkan dalam solusi itu adalah ratusan hertz (misalnya, dimungkinkan untuk menghasilkan frekuensi 40.000 Hz dan 39966 Hz, tetapi tidak mungkin untuk menghasilkan frekuensi dengan besarnya antara dua nilai ini). <br><a name="habracut"></a><br><h2>  Implementasi Akselerasi </h2><br>  Apakah mungkin untuk menghilangkan kerugian yang ditunjukkan dengan menggunakan alat UDB yang sama tanpa menyulitkan sistem?  Mari kita perbaiki.  Mari kita mulai dengan yang paling sulit - dengan akselerasi.  Akselerasi ditambahkan di awal dan akhir jalan.  Pertama, jika pulsa frekuensi tinggi diterapkan segera ke motor stepper, itu akan membutuhkan arus yang lebih besar untuk memulai operasi.  Arus yang diizinkan tinggi adalah pemanasan dan kebisingan, jadi lebih baik untuk membatasinya.  Tapi kemudian mesin bisa melompati langkah di awal.  Jadi lebih baik mempercepat mesin dengan lancar.  Kedua, jika kepala yang berat berhenti tiba-tiba, maka ia mengalami transien yang terkait dengan inersia.  Gelombang terlihat di plastik.  Oleh karena itu, lancar diperlukan tidak hanya untuk membubarkan, tetapi juga untuk menghentikan kepala.  Secara klasik, grafik kecepatan mesin disajikan dalam bentuk trapesium.  Ini adalah bagian dari kode sumber firmware Marlin: <br><br><img src="https://habrastorage.org/webt/wm/gg/ce/wmggcetcc0vy5tfgs3xsr2ewwoc.png"><br><br>  Saya bahkan tidak akan mencoba mencari tahu apakah mungkin untuk mengimplementasikan ini menggunakan UDB.  Ini disebabkan oleh fakta bahwa jenis akselerasi lain sekarang sedang populer: bukan trapesium, tetapi S-Curve.  Jadwal mereka terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/rs/hy/q9/rshyq94_sz6et-lgsbrpprdmyks.png"><br><br>  Ini jelas bukan untuk UDB.  Menyerah?  Tidak semuanya!  Saya sudah mencatat bahwa UDB tidak mengimplementasikan antarmuka perangkat keras, tetapi hanya memungkinkan Anda untuk mentransfer sebagian kode dari perangkat lunak ke tingkat firmware.  Biarkan profil menghitung prosesor pusat, dan pembentukan pulsa langkah masih melakukan UDB.  Prosesor pusat memiliki banyak waktu untuk perhitungan.  Tugas menghilangkan interupsi yang sering akan terus diselesaikan dengan cukup elegan, dan tidak ada yang berencana untuk membawa proses sepenuhnya ke level firmware. <br><br>  Tentu saja, profil perlu disiapkan dalam memori, dan UDB akan mengambil data dari sana menggunakan DMA.  Tetapi berapa banyak memori yang dibutuhkan?  Satu milimeter membutuhkan 200 langkah.  Sekarang dengan penyandian 24-bit, ini adalah 600 byte per 1 mm pergerakan head!  Sekali lagi, ingat tentang tidak begitu sering, tetapi masih gangguan konstan untuk mengirimkan semuanya dalam fragmen?  Tidak juga!  Faktanya adalah bahwa mekanisme DMA PSoC didasarkan pada deskriptor.  Setelah menjalankan tugas dari satu deskriptor, pengontrol DMA melanjutkan ke yang berikutnya.  Jadi, di sepanjang rantai, Anda dapat menggunakan banyak deskriptor.  Kami menggambarkan ini dengan beberapa gambar dari dokumentasi resmi: <br><br><img src="https://habrastorage.org/webt/ju/hv/6b/juhv6bqptp3uagog5bfgxlmxw0q.png"><br><br>  Sebenarnya, mekanisme ini juga dapat digunakan dengan membangun rantai tiga deskriptor: <br><br><table><tbody><tr><th>  Tidak. </th><th>  Penjelasan </th></tr><tr><td>  1 </td><td>  Dari memori ke FIFO dengan penambahan alamat.  Mengindikasikan bagian dengan profil percepatan. </td></tr><tr><td>  2 </td><td>  Dari memori ke FIFO tanpa penambahan alamat.  Mengirim semua waktu ke kata yang sama dalam memori untuk kecepatan konstan. </td></tr><tr><td>  3 </td><td>  Dari memori ke FIFO dengan penambahan alamat.  Mengindikasikan bagian dengan profil pengereman. <br></td></tr></tbody></table><br>  Ternyata jalur utama dijelaskan pada langkah 2, dan di sana kata yang sama digunakan secara fisik, yang menetapkan kecepatan konstan.  Konsumsi memori tidak besar.  Pada kenyataannya, deskriptor kedua dapat secara fisik diwakili oleh dua atau tiga deskriptor.  Ini disebabkan oleh fakta bahwa panjang pemompaan maksimum, menurut TRM, bisa 64 kilobyte (amandemen akan lebih rendah).  Artinya, 32.767 kata.  Bahwa pada 200 langkah per milimeter akan sesuai dengan jalur 163 milimeter.  Anda mungkin harus membuat segmen dua atau tiga bagian, tergantung pada jarak maksimum yang dapat ditempuh mesin pada satu waktu. <br><br>  Namun demikian, untuk menghemat memori (dan biaya blok UDB), saya mengusulkan untuk meninggalkan blok DatapPath 24-bit, beralih ke yang 16-bit lebih ekonomis. <br><br>  <b>Jadi</b>  <b>Proposal pertama untuk revisi.</b> <b><br><br></b>  <b>Array disiapkan dalam memori yang mengkodekan durasi langkah-langkah.</b>  <b>Selanjutnya, informasi ini pergi ke UDB menggunakan DMA.</b>  <b>Bagian bujursangkar dikodekan oleh array dari satu elemen, blok DMA tidak meningkatkan alamat, memilih elemen yang sama sepanjang waktu.</b>  <b>Bagian akselerasi, bujursangkar, dan pengereman terhubung dengan sarana yang tersedia di pengontrol DMA.</b> <br><br><h2>  Rune midrange yang bagus </h2><br>  Sekarang kita akan mempertimbangkan bagaimana mengatasi masalah granularity frekuensi.  Tentu saja, tidak mungkin untuk mengaturnya dengan tepat.  Tetapi, pada kenyataannya, "firmware" asli juga tidak bisa melakukan ini.  Sebagai gantinya, mereka menggunakan algoritma Bresenham.  Penundaan satu ukuran ditambahkan ke beberapa langkah.  Akibatnya, frekuensi rata-rata menjadi menengah, antara nilai yang lebih kecil dan lebih besar.  Dengan menyesuaikan rasio periode reguler dan jangka panjang, Anda dapat dengan lancar mengubah frekuensi rata-rata.  Jika kecepatan kita sekarang ditetapkan bukan melalui register data, tetapi ditransmisikan melalui FIFO, dan jumlah pulsa umumnya ditetapkan melalui jumlah kata yang dikirimkan melalui DMA, kedua register data di UDB dibebaskan.  Selain itu, salah satu baterai, yang menghitung jumlah pulsa, juga dirilis.  Di sini kita akan membangun PWM tertentu pada mereka. <br><br>  Biasanya, ALU membandingkan dan menetapkan register dengan indeks yang sama.  Ketika satu register memiliki indeks 0 dan yang lainnya memiliki 1, tidak setiap versi operasi dapat diimplementasikan.  Tapi saya berhasil mengumpulkan solitaire dari register di mana PWM dapat dilakukan.  Ternyata seperti yang ditunjukkan pada gambar. <br><br><img src="https://habrastorage.org/webt/nc/yv/vq/ncyvvqcqptj3lm4an82idlrrl-c.png"><br><br>  Ketika kondisi A0 &lt;D1 terpenuhi, kami akan menambahkan detak ekstra pada panjang pulsa yang diberikan.  Ketika kondisinya tidak terpenuhi, kita tidak akan. <br><br><h2>  Kuda bulat dalam kondisi normal </h2><br>  Jadi, kami mulai memodifikasi blok yang dikembangkan untuk UDB, dengan mempertimbangkan arsitektur baru.  Ganti kedalaman bit Datapath: <br><br><img src="https://habrastorage.org/webt/cj/-m/ae/cj-mae3coaxgzro0er5mkraun4q.png"><br><br>  Kami akan membutuhkan lebih banyak keluar dari Datapath daripada terakhir kali. <br><br><img src="https://habrastorage.org/webt/ua/td/hn/uatdhnswe_uzmqinll0wyhsyifg.png"><br><br>  Mengklik dua kali pada mereka, kami melihat detailnya: <br><br><img src="https://habrastorage.org/webt/vq/3p/24/vq3p24frqv0uiumytbvn-ewhi1w.png"><br><br>  Ada lebih banyak digit untuk variabel <b>State</b> , jangan lupa untuk menghubungkan yang lebih lama !!!  Di versi lama, ada konstanta 0. <br><br><img src="https://habrastorage.org/webt/0l/dm/fy/0ldmfyci2byicjdsksvkdkg8k04.png"><br><br>  Grafik transisi automaton yang saya dapatkan seperti ini: <br><br><img src="https://habrastorage.org/webt/hb/5u/nq/hb5unqu_fmfc6sd9k7m3_x0wr7s.png"><br><br>  Kami dalam kondisi <b>Idle</b> saat FIFO1 kosong.  By the way, bekerja dengan FIFO1 dan bukan FIFO0 adalah hasil dari pembentukan solitaire.  Register A0 digunakan untuk mengimplementasikan PWM, sehingga lebar pulsa ditentukan oleh register A1.  Dan saya dapat mengunduhnya hanya dari FIFO1 (mungkin ada metode rahasia lainnya, tetapi mereka tidak diketahui oleh saya).  Oleh karena itu, DMA mengunggah data dengan tepat ke FIFO1, dan justru keadaan <b>"Tidak kosong"</b> untuk FIFO1 yang keluar dari keadaan <b>menganggur</b> . <br><br>  ALU dalam status <b>IDLE</b> membatalkan register A0: <br><br><img src="https://habrastorage.org/webt/1r/i5/-i/1ri5-iydlu00cfobufepmiaqucg.png"><br><br>  Ini diperlukan agar pada awal operasi PWM, selalu mulai bekerja dari awal. <br>  Namun data masuk ke FIFO.  Mesin masuk ke status <b>LoadData</b> : <br><br><img src="https://habrastorage.org/webt/3v/rf/dx/3vrfdxwme_jw6m69bwrpybhiots.png"><br><br>  Dalam keadaan ini, ALU memuat kata berikutnya dari FIFO ke register A1.  Sepanjang jalan, agar tidak membuat keadaan yang tidak perlu, nilai counter A0, yang digunakan untuk bekerja dengan PWM, meningkat: <br><br><img src="https://habrastorage.org/webt/t4/ki/je/t4kijee95z-kbmn1n3ikcgtc9qk.png"><br><br>  Jika penghitung A0 belum mencapai nilai D0 (yaitu, kondisi A0 &lt;D0 dipicu, memiringkan bendera NoNeedReloadA0), kami pergi ke keadaan <b>Satu</b> .  Kalau tidak, negara adalah <b>ClearA0</b> . <br><br>  Dalam keadaan <b>ClearA0,</b> ALU hanya nol nilai A0, memulai siklus PWM baru: <br><br><img src="https://habrastorage.org/webt/0_/pj/ah/0_pjahunjhl34izkpv5k9lplxem.png"><br><br>  setelah itu mesin juga masuk ke <b>Satu</b> keadaan, hanya satu ketukan kemudian. <br><br>  <b>Salah satu</b> yang kami kenal dari versi lama mesin.  ALU di dalamnya tidak melakukan fungsi apa pun. <br><br>  Jadi - dalam kondisi ini, sebuah unit dihasilkan pada output <b>Out_Step</b> (di sini optimizer bekerja lebih baik ketika unit diproduksi oleh kondisi, ini terdeteksi secara empiris). <br><br><img src="https://habrastorage.org/webt/aq/mj/ml/aqmjmluzxutxzq_caddtls15hfc.png"><br><br>  Kita berada dalam keadaan ini sampai penghitung tujuh-bit yang sudah kita ketahui diatur ulang ke nol.  Tetapi jika sebelumnya kita keluar dari keadaan ini di sepanjang satu jalan, sekarang bisa ada dua jalan: langsung dan tertunda. <br><br><img src="https://habrastorage.org/webt/53/fk/qc/53fkqcxnlvsf52sxzb8e1ijnpkk.png"><br><br>  Kami akan masuk ke kondisi ExtraTick jika flag <b>AddCycle diset</b> , yang ditugaskan untuk memenuhi kondisi A0 &lt;D1.  Dalam kondisi ini, ALU tidak melakukan tindakan yang menguntungkan.  Hanya saja siklusnya membutuhkan 1 ketukan lebih lama.  Lebih lanjut, semua jalur bertemu dalam kondisi <b>Delay</b> . <br><br>  Kondisi ini mengukur durasi denyut nadi.  Daftar A1 (dimuat saat masih dalam kondisi <b>Muat</b> ) dikurangi hingga mencapai nol. <br><br><img src="https://habrastorage.org/webt/bi/ct/jt/bictjtwgqikkvuz4pqmp7owacii.png"><br><br>  Selanjutnya, tergantung pada apakah ada data tambahan di FIFO atau tidak, mesin akan pergi ke batch berikutnya untuk <b>memuat</b> atau ke <b>Idle</b> .  Mari kita lihat ini bukan pada gambar (ada panah panjang, semuanya akan kecil), tetapi dalam bentuk tabel, klik dua kali pada status <b>Delay</b> : <br><br><img src="https://habrastorage.org/webt/bb/cr/dq/bbcrdq1jfhxret5vbaoexfsr-iq.png"><br><br>  Sekarang keluar dari UDB.  Saya mengonversi tanda sedang dalam kondisi <b>Idle</b> ke perbandingan asinkron (dalam versi sebelumnya ada pemicu yang dipasang dan diatur ulang di berbagai negara), karena untuk itu pengoptimal menunjukkan hasil terbaik.  Ditambah lagi, bendera <b>Hungry</b> ditambahkan, memberi sinyal ke unit DMA bahwa ia siap menerima data.  Itu berakhir pada bendera <b>"FIFO1 tidak ramai"</b> .  Karena tidak ramai, DMA dapat memuat kata data lain di sana. <br><br><img src="https://habrastorage.org/webt/w8/ea/b-/w8eab-2dwdxvtvyr3hfukjrev9w.png"><br><br>  Pada bagian otomatis - itu saja. <br><br>  Tambahkan blok DMA ke diagram proyek utama.  Untuk saat ini, saya mulai mengganggu bendera terminasi DMA, tetapi bukan fakta bahwa ini benar.  Ketika proses akses langsung ke memori selesai, Anda dapat memulai proses baru terkait dengan segmen yang sama, tetapi Anda tidak dapat mulai mengisi informasi tentang segmen baru.  FIFO masih memiliki tiga hingga empat elemen.  Pada saat ini, masih tidak mungkin untuk memprogram ulang register D0 dan D1 dari blok berdasarkan UDB, mereka masih diperlukan untuk operasi.  Oleh karena itu, ada kemungkinan bahwa interupsi berdasarkan output <b>Out_Idle</b> akan ditambahkan <b>nanti</b> .  Tetapi dapur itu tidak lagi berhubungan dengan pemrograman blok UDB, jadi kami hanya akan menyebutkannya secara sepintas. <br><br><img src="https://habrastorage.org/webt/4o/g7/y2/4og7y21diqgqr6qn7_iehukiqho.png"><br><br><h2>  Eksperimen perangkat lunak </h2><br>  Karena sekarang semuanya tidak diketahui, kami tidak akan menulis fungsi khusus.  Semua cek akan dilakukan "Di dahi."  Kemudian, berdasarkan percobaan yang berhasil, fungsi API dapat ditulis.  Jadi  Kami membuat fungsi <b>utama ()</b> minimal.  Ini hanya mengatur sistem dan menjalankan tes yang dipilih. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ CyGlobalIntEnable; <span class="hljs-comment"><span class="hljs-comment">/* Enable global interrupts. */</span></span> <span class="hljs-comment"><span class="hljs-comment">// isr_1_StartEx(StepperFinished); StepperController_X_Start(); StepperController_Y_Start(); StepperController_Z_Start(); StepperController_E0_Start(); StepperController_E1_Start(); // TestShortSteps(); TestWithPacking (); for(;;) { }</span></span></code> </pre> <br>  Mari kita coba mengirim paket pulsa dengan memanggil fungsi, memeriksa fakta memasukkan pulsa tambahan.  Panggilan fungsi itu sederhana: <br><br><pre> <code class="plaintext hljs">TestShortSteps();</code> </pre><br>  Tetapi tubuh membutuhkan penjelasan. <div class="spoiler">  <b class="spoiler_title">Saya akan memberikan seluruh fungsi terlebih dahulu</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void TestShortSteps() { //   ,   //      //   ,  DMA    !!! //    ,   !!! StepperController_X_SingleVibrator_WritePeriod (6); //     //    —   CY_SET_REG16(StepperController_X_Datapath_1_D0_PTR, 4); CY_SET_REG16(StepperController_X_Datapath_1_D1_PTR, 2); //         . //         static const uint16 steps[] = { 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001, 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001 }; //  DMA  ,      uint8 channel = DMA_X_DmaInitialize (sizeof(steps[0]),1,HI16(steps),HI16(StepperController_X_Datapath_1_F1_PTR)); CyDmaChRoundRobin (channel,true); //       ,       uint8 td = CyDmaTdAllocate(); //       .  ,    . CyDmaTdSetConfiguration(td, sizeof(steps), CY_DMA_DISABLE_TD, TD_INC_SRC_ADR | TD_AUTO_EXEC_NEXT); //       CyDmaTdSetAddress(td, LO16((uint32)steps), LO16((uint32)StepperController_X_Datapath_1_F1_PTR)); //      CyDmaChSetInitialTd(channel, td); //         CyDmaChEnable(channel, 1); }</code> </pre><br></div></div><br>  Sekarang pertimbangkan bagian-bagian pentingnya. <br><br>  Jika panjang bagian positif dari pulsa sama dengan 92 clock cycle, maka osiloskop tidak akan dapat melihat apakah ada satu siklus masuk di bagian negatif atau tidak.  Skalanya tidak akan sama.  Hal ini diperlukan untuk membuat bagian positif sesingkat mungkin sehingga total pulsa akan sebanding dalam skala dengan beat yang dimasukkan.  Karena itu, saya dengan paksa mengubah periode penghitung yang menetapkan durasi bagian positif dari pulsa: <br><br><pre> <code class="plaintext hljs"> //   ,   //      //   ,  DMA    !!! //    ,   !!! StepperController_X_SingleVibrator_WritePeriod (6);</code> </pre><br>  Tapi mengapa enam ukuran keseluruhan?  Kenapa tidak tiga?  Kenapa tidak dua?  Lagi pula, mengapa tidak?  Ini adalah kisah sedih.  Jika pulsa positif lebih pendek dari 6 siklus, maka sistem tidak berfungsi.  Debugging lama pada osiloskop dengan output dari garis uji ke luar menunjukkan bahwa DMA bukanlah hal yang cepat.  Jika mesin berjalan kurang dari durasi tertentu, maka pada saat ia <b>meninggalkan</b> negara <b>Delay</b> , FIFO paling sering masih kosong.  Itu mungkin belum menempatkan satu kata data baru!  Dan hanya ketika bagian positif dari pulsa memiliki durasi 6 siklus, FIFO dijamin punya waktu untuk memuat ... <br><br><h2>  Penyimpangan latensi </h2><br>  Ide perbaikan lain yang ada di kepala saya adalah akselerasi perangkat keras dari fungsi-fungsi tertentu dari kernel RTOS MAX kami.  Tapi sayang sekali, semua ide terbaik saya rusak tentang latensi yang sama. <br><br>  Ada suatu kasus, saya mempelajari pengembangan aplikasi Bare Metal untuk Cyclone V SoC.  Tetapi ternyata bekerja dengan register FPGA tunggal (ketika secara bergantian menulis kepada mereka, kemudian membaca dari mereka) mengurangi operasi inti ratusan (!!!) kali.  Kamu dengar benar.  Ada ratusan.  Selain itu, semua ini tidak terdokumentasi dengan baik, tetapi pada awalnya saya merasakan ke dalam, dan kemudian membuktikan dari potongan-potongan frasa dari dokumentasi bahwa latensi bersalah ketika menyampaikan permintaan melalui banyak jembatan.  Jika Anda perlu mengusir array besar, juga akan ada latensi, tetapi dalam hal satu kata yang dipompa, itu tidak akan signifikan.  Ketika permintaan tunggal (dan akselerasi perangkat keras dari kernel OS menyiratkan hanya mereka), pelambatan berjalan tepat ratusan kali.  Akan jauh lebih cepat untuk melakukan semuanya dengan cara yang sepenuhnya terprogram, ketika program bekerja dengan memori utama melalui cache dengan kecepatan panik. <br><br>  Di PSoC, saya juga punya rencana tertentu.  Secara tampilan, Anda dapat dengan luar biasa mencari data dalam array menggunakan DMA dan UDB.  Apa yang sebenarnya ada di sana!  Karena struktur deskriptor DMA, pengontrol ini dapat melakukan pencarian perangkat keras sepenuhnya dalam daftar tertaut!  Tetapi setelah menerima colokan yang dijelaskan di atas, saya menyadari bahwa itu juga terkait dengan latensi.  Di sini, latensi ini dijelaskan dengan indah dalam dokumentasi.  Baik dalam keluarga TRM dan dalam dokumen terpisah <b>AN84810 - PSoC 3 dan PSoC 5LP Advanced DMA Topics</b> .  Di sana bagian 3.2 dikhususkan untuk ini.  Jadi akselerasi perangkat keras berikutnya dibatalkan.  Sayang sekali.  Tapi, seperti kata Semyon Semyonovich Gorbunkov: "Kami akan mencari." <br><br><h2>  Eksperimen perangkat lunak yang berkelanjutan </h2><br>  Selanjutnya, saya mengatur parameter algoritma Bresenham: <br><br><pre> <code class="plaintext hljs"> //     //    —   CY_SET_REG16(StepperController_X_Datapath_1_D0_PTR, 4); CY_SET_REG16(StepperController_X_Datapath_1_D1_PTR, 2);</code> </pre><br>  Nah, kemudian muncul kode biasa yang mentransfer berbagai kata melalui DMA ke FIFO1 dari unit kontrol mesin X. <br><br>  Hasilnya memerlukan beberapa penjelasan.  Ini dia: <br><br><img src="https://habrastorage.org/webt/bi/hg/ie/bihgiepg_iskg-wor_g4iqnv1ti.png"><br><br>  Nilai penghitung A0 ditunjukkan dengan warna merah ketika mesin berada dalam kondisi <b>Satu</b> .  Tanda bintang hijau menunjukkan kasus ketika penundaan dimasukkan karena mesin dalam keadaan <b>ExtraTick</b> .  Ada juga bar di mana penundaan itu karena berada dalam keadaan <b>ClearA0</b> , mereka ditandai dengan kotak biru. <br><br>  Seperti yang Anda lihat, ketika Anda pertama kali memasukkan penundaan pertama hilang.  Ini disebabkan oleh fakta bahwa A0 diatur ulang ketika sedang dalam kondisi <b>idle</b> , tetapi meningkat ketika memasuki <b>LoadData</b> .  Oleh karena itu, ke titik analisis (keluar dari negara <b>One</b> ), sudah sama dengan kesatuan.  Akun dimulai dengan dia.  Tetapi secara umum, ini tidak akan mempengaruhi frekuensi tengah.  Itu hanya perlu diingat.  Karena harus diingat bahwa ketika mengatur ulang A0, jam juga akan dimasukkan.  Itu harus diperhitungkan ketika menghitung frekuensi rata-rata. <br><br>  Namun secara umum, jumlah pulsa sudah benar.  Durasi mereka juga bisa dipercaya. <br>  Mari kita coba program rantai deskriptor yang lebih nyata, <br><br><div class="spoiler">  <b class="spoiler_title">terdiri dari fase akselerasi, gerak linier dan pengereman.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void TestWithPacking(int countOnLinearStage) { //   ,   //     . //   ,  DMA    !!! //    ,   !!! StepperController_X_SingleVibrator_WritePeriod (6); //     //    —   CY_SET_REG16(StepperController_X_Datapath_1_D0_PTR, 4); CY_SET_REG16(StepperController_X_Datapath_1_D1_PTR, 2); //    static const uint16 accelerate[] = {0x0010,0x0008,0x0004}; //    static const uint16 deccelerate[] = {0x004,0x0008,0x0010}; //  .    . static const uint16 steps[] = {0x0001}; //  DMA  ,      uint8 channel = DMA_X_DmaInitialize (sizeof(steps[0]),1,HI16(steps),HI16(StepperController_X_Datapath_1_F1_PTR)); CyDmaChRoundRobin (channel,true); //   uint8 tdDeccelerate = CyDmaTdAllocate(); CyDmaTdSetConfiguration(tdDeccelerate, sizeof(deccelerate), CY_DMA_DISABLE_TD, TD_INC_SRC_ADR | TD_AUTO_EXEC_NEXT); CyDmaTdSetAddress(tdDeccelerate, LO16((uint32)deccelerate), LO16((uint32)StepperController_X_Datapath_1_F1_PTR)); //       uint8 tdSteps = CyDmaTdAllocate(); //   !!! //     !!! CyDmaTdSetConfiguration(tdSteps, countOnLinearStage, tdDeccelerate, /*TD_INC_SRC_ADR |*/ TD_AUTO_EXEC_NEXT); CyDmaTdSetAddress(tdSteps, LO16((uint32)steps), LO16((uint32)StepperController_X_Datapath_1_F1_PTR)); //   //     !!! uint8 tdAccelerate = CyDmaTdAllocate(); CyDmaTdSetConfiguration(tdAccelerate, sizeof(accelerate), tdSteps, TD_INC_SRC_ADR | TD_AUTO_EXEC_NEXT); CyDmaTdSetAddress(tdAccelerate, LO16((uint32)accelerate), LO16((uint32)StepperController_X_Datapath_1_F1_PTR)); //      CyDmaChSetInitialTd(channel, tdAccelerate); //         CyDmaChEnable(channel, 1); }</code> </pre><br></div></div><br>  Pertama, panggilan untuk sepuluh langkah yang sama (dalam DMA, 20 byte benar-benar berjalan): <br><br><pre> <code class="plaintext hljs">TestWithPacking (20);</code> </pre><br>  Hasilnya seperti yang diharapkan.  Pada awalnya, akselerasi terlihat.  Dan jalan keluar ke <b>IDLE</b> (sinar biru) terjadi dengan penundaan besar dari pulsa terakhir, saat itulah langkah terakhir selesai sepenuhnya, nilainya kira-kira sama dengan nilai yang pertama. <br><br><img src="https://habrastorage.org/webt/5y/tb/na/5ytbna9ixcuxv5-i35tinzixy0e.png"><br><br><h2>  Kuda sungguhan dalam kondisi normal </h2><br>  Saat merenovasi peralatan, saya entah bagaimana terkenal melompat dari lebar pulsa 24-bit ke pekerjaan 16-bit.  Tetapi kami menemukan bahwa ini tidak dapat dilakukan: frekuensi pulsa minimum akan terlalu tinggi.  Saya melakukannya dengan sengaja.  Faktanya adalah bahwa teknik untuk memperluas kapasitas bit dari penghitung 16-bit ternyata sangat rumit sehingga jika saya mulai menggambarkannya bersama-sama dengan mesin utama, itu akan mengalihkan semua perhatian.  Karena itu, kami mempertimbangkannya secara terpisah. <br><br>  Kami memiliki baterai 16-bit.  Saya memutuskan untuk menambahkan entitas konter standar tujuh-bit ke bit-bit tinggi.  Apakah penghitung tujuh bit ini?  Ini adalah desain yang tersedia di setiap blok UDB (blok UDB dasar memiliki lebar bit semua register 8-bit, peningkatan kedalaman bit ditentukan oleh kombinasi blok dalam kelompok).  Dari sumber daya yang sama, register <b>Kontrol / Status</b> dapat diimplementasikan.  Sekarang kami memiliki satu penghitung dan bukan pasangan <b>Kontrol / Status</b> tunggal untuk 16 bit data.  Jadi, menambahkan penghitung lain ke sistem, kami tidak akan menunda sumber daya tambahan.  Kami hanya mengambil apa yang sudah dialokasikan untuk kami.  Itu bagus!  Kami membuat byte tinggi penghitung lebar pulsa melalui mekanisme ini dan mendapatkan total lebar penghitung lebar pulsa sama dengan 23 bit. <br><br><img src="https://habrastorage.org/webt/_k/nc/-h/_knc-hzlxwos6a8jdzopy3pj2ww.png"><br><br>  Pertama saya akan mengatakan apa yang saya pikirkan.  Saya pikir setelah keluar dari negara <b>Delay</b> , saya akan memeriksa penyelesaian penghitungan penghitung tambahan ini.  Jika dia belum selesai menghitung, saya akan mengurangi nilainya dan kembali beralih ke negara <b>Delay</b> .  Jika Anda menghitung, logikanya akan tetap sama, tanpa menambahkan siklus tambahan. <br><br>  Selain itu, dokumentasi untuk penghitung ini mengatakan bahwa saya benar.  Secara harfiah dikatakan: <br><blockquote>  Periode <br>  Menentukan nilai register periode awal.  Untuk periode N clock, nilai periode harus ditetapkan ke nilai N-1.  Penghitung akan dihitung dari N-1 hingga 0 yang menghasilkan periode siklus N clock.  <b><i>Nilai register periode 0 tidak didukung dan akan menghasilkan output penghitungan terminal yang diadakan pada kondisi tinggi konstan.</i></b> </blockquote>  Hidup telah menunjukkan bahwa semuanya berbeda.  Saya menyimpulkan keadaan garis <b>hitung terminal</b> pada osiloskop dan menyaksikan nilainya pada nol dimuat dalam <b>Periode</b> dan selama pemuatan program.  Alas dan ah.  Tidak ada <b>keadaan tinggi yang konstan</b> ! <br><br>  Dengan coba-coba, saya berhasil membuat sistem bekerja dengan benar, tetapi agar ini terjadi, setidaknya satu pengurangan dari penghitung harus terjadi!  Keadaan baru <b>"pengurangan"</b> tidak di samping.  Itu harus dimasukkan ke jalan yang diperlukan.  Itu terletak di depan negara <b>Delay</b> dan disebut <b>Next65536</b> . <br><br><img src="https://habrastorage.org/webt/cp/6f/oz/cp6fozy_kflvs6eu6w-ho9ebmcu.png"><br><br>  ALU dalam kondisi ini tidak melakukan tindakan yang bermanfaat.  Sebenarnya, hanya counter baru yang bereaksi terhadap kenyataan berada di negara ini.  Ini dia dalam diagram: <br><br><img src="https://habrastorage.org/webt/mh/tb/br/mhtbbr8strxue23n6jmg_giocjc.png"><br><br>  Berikut adalah propertinya secara lebih rinci: <br><br><img src="https://habrastorage.org/webt/oo/t5/rs/oot5rs3_cdplwr94gno3poavzkq.png"><br><br>  Secara umum, dengan mempertimbangkan artikel-artikel sebelumnya, esensi dari counter ini jelas.  Hanya <b>Enable</b> line yang menderita.  Sekali lagi, saya tidak sepenuhnya mengerti mengapa itu harus dihidupkan ketika mesin dalam keadaan <b>LoadData</b> (kemudian penghitung memuat ulang nilai periode).  Saya meminjam trik ini dari properti penghitung yang mengontrol LED, diambil dari penulis bahasa Inggris dari unit kontrol untuk LED tersebut.  Tanpanya, nilai nol periode tidak berfungsi.  Dia bekerja dengannya. <br><br>  Dalam kode API, kami menambahkan inisialisasi penghitung baru.  Sekarang fungsi mulai terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">void `$INSTANCE_NAME`_Start() { `$INSTANCE_NAME`_SingleVibrator_Start(); //"One" Generator start `$INSTANCE_NAME`_Plus65536_Start(); }</code> </pre><br>  Mari kita periksa sistem yang baru.  Berikut adalah kode fungsi untuk pengujian <br><br><div class="spoiler">  <b class="spoiler_title">(di dalamnya, hanya baris pertama yang berbeda dari yang sudah dikenal):</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void JustTest(int extra65536s) { //      65536  StepperController_X_Plus65536_WritePeriod((uint8) extra65536s); //     //    —   CY_SET_REG16(StepperController_X_Datapath_1_D0_PTR, 4); CY_SET_REG16(StepperController_X_Datapath_1_D1_PTR, 2); //         . //         static const uint16 steps[] = { 0x1000,0x1000,0x1000,0x1000 }; //  DMA  ,      uint8 channel = DMA_X_DmaInitialize (sizeof(steps[0]),1,HI16(steps),HI16(StepperController_X_Datapath_1_F1_PTR)); CyDmaChRoundRobin (channel,true); //       ,       uint8 td = CyDmaTdAllocate(); //       .  ,    . CyDmaTdSetConfiguration(td, sizeof(steps), CY_DMA_DISABLE_TD, TD_INC_SRC_ADR | TD_AUTO_EXEC_NEXT); //       CyDmaTdSetAddress(td, LO16((uint32)steps), LO16((uint32)StepperController_X_Datapath_1_F1_PTR)); //      CyDmaChSetInitialTd(channel, td); //         CyDmaChEnable(channel, 1); }</code> </pre><br></div></div><br>  Kami menyebutnya seperti ini: <br><br><pre> <code class="plaintext hljs"> JustTest(0);</code> </pre><br>  Pada osiloskop kita melihat yang berikut (sinar kuning - output STEP, nilai biru dari counter counter TC untuk kontrol proses).  Durasi pulsa diatur oleh array <b>langkah</b> .  Pada setiap langkah, durasinya adalah 0x1000 tindakan. <br><br><img src="https://habrastorage.org/webt/ap/q7/df/apq7dfk6t5kns3qtzjmkuzzw-44.png"><br><br>  Beralih ke pemindaian lain sehingga ada kompatibilitas antara hasil yang berbeda: <br><br><img src="https://habrastorage.org/webt/zl/6s/2o/zl6s2oop2bft0ndatbawfdrtacw.png"><br><br>  Ubah panggilan fungsi menjadi ini: <br><br><pre> <code class="plaintext hljs"> JustTest(1);</code> </pre><br>  Hasilnya seperti yang diharapkan.  Pertama, output TC adalah nol untuk siklus 0x1000, lalu - unit untuk siklus 0x10000 (65536d).  Frekuensinya kira-kira sama dengan 700 hertz, kami menemukan di bagian terakhir artikel, jadi semuanya benar. <br><br><img src="https://habrastorage.org/webt/nm/5q/6s/nm5q6s73zb7yqxtvuxzrxis4f5i.png"><br><br>  Baiklah, mari kita coba deuce: <br><br><pre> <code class="plaintext hljs"> JustTest(2);</code> </pre><br>  Kami mendapatkan: <br><br><img src="https://habrastorage.org/webt/ah/sp/7y/ahsp7ymdefdyl04acuefc3ufct8.png"><br><br>  Benar juga.  Output TC dibalik menjadi satu pada siklus clock 65536 terakhir.  Sebelumnya, dia nol untuk 0x1000 + 0x10000 siklus. <br><br>  Tentu saja, dengan pendekatan ini, semua pulsa harus memiliki nilai yang sama dengan penghitung baru.  Tidak mungkin untuk membuat satu pulsa dengan byte tertinggi selama akselerasi, katakan 3, lalu 1, lalu 0. Tetapi pada kenyataannya, pada frekuensi rendah (kurang dari tujuh ratus hertz) akselerasi tidak memiliki makna fisik, oleh karena itu masalah ini dapat diabaikan.  Pada frekuensi ini, Anda dapat bekerja dengan mesin secara linear. <br><br><h2>  Terbang di salep </h2><br>  Dokumen TRM untuk keluarga PSoC5LP menyatakan: <br><blockquote>  Setiap transaksi dapat dari 1 hingga 64 KB </blockquote>  Tetapi dalam AN84810 yang sudah disebutkan ada ungkapan seperti itu: <br><blockquote>  1. Bagaimana Anda bisa melakukan buffer lebih dari 4095 byte menggunakan DMA? <br>  Jumlah transfer maksimum TD dibatasi hingga 4.095 byte.  Jika Anda perlu mentransfer lebih dari 4095 byte menggunakan saluran DMA tunggal, gunakan beberapa TDs dan rantai seperti yang ditunjukkan pada Contoh 5. </blockquote>  Siapa yang benar  Jika Anda melakukan percobaan, hasilnya akan cenderung mendukung yang terburuk dari pernyataan tersebut, tetapi perilaku tersebut akan sepenuhnya tidak dapat dipahami.  Seluruh kesalahannya adalah pemeriksaan ini di API: <br><br><img src="https://habrastorage.org/webt/ib/5s/i2/ib5si2yxxn4e_idcohactjo2j-u.png"><br><br><div class="spoiler">  <b class="spoiler_title">Teks yang sama.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">cystatus CyDmaTdSetConfiguration(uint8 tdHandle, uint16 transferCount, uint8 nextTd, uint8 configuration) \ { cystatus status = CYRET_BAD_PARAM; if((tdHandle &lt; CY_DMA_NUMBEROF_TDS) &amp;&amp; (0u == (0xF000u &amp; transferCount))) { /* Set 12 bits transfer count. */ reg16 *convert = (reg16 *) &amp;CY_DMA_TDMEM_STRUCT_PTR[tdHandle].TD0[0u]; CY_SET_REG16(convert, transferCount); /* Set Next TD pointer. */ CY_DMA_TDMEM_STRUCT_PTR[tdHandle].TD0[2u] = nextTd; /* Configure the TD */ CY_DMA_TDMEM_STRUCT_PTR[tdHandle].TD0[3u] = configuration; status = CYRET_SUCCESS; } return(status); }</code> </pre><br></div></div><br>  Jika transaksi ditentukan lebih dari 4095 byte, pengaturan sebelumnya akan digunakan.  Ya, saya tidak berpikir untuk memeriksa kode kesalahan ... <br><br>  Eksperimen menunjukkan bahwa jika Anda menghapus cek ini, panjang sebenarnya akan terpotong menggunakan mask 0xfff (4096 = 0x1000).  Alas dan ah.  Semua harapan untuk pekerjaan yang menyenangkan runtuh.  Anda tentu saja dapat membuat rantai deskriptor terkait dalam 4K.  Tapi, katakanlah, 64K adalah 16 rantai.  Tiga mesin aktif (ekstruder akan memiliki langkah lebih sedikit) - 48 rantai.  Sebegitu banyak yang harus diisi dalam kasus terburuk, sebelum setiap segmen.  Mungkin tepat waktu.  Minimal, 127 deskriptor tersedia, jadi pasti akan ada cukup memori. <br><br>  Anda dapat mengirim data yang hilang sesuai kebutuhan.  Gangguan datang bahwa saluran DMA telah menyelesaikan pekerjaan, kami mentransfer segmen lain ke sana.  Dalam hal ini, tidak ada perhitungan yang diperlukan, segmen sudah terbentuk, semuanya akan cepat.  Dan tidak ada persyaratan kinerja: ketika permintaan interupsi dikeluarkan, akan ada 4 elemen lagi di FIFO yang akan dilayani masing-masing selama beberapa ratus atau bahkan ribuan siklus clock.  Yaitu, semuanya nyata.  Strategi khusus akan lebih mudah untuk dipilih selama pekerjaan nyata.  Tetapi kesalahan dalam dokumentasi (TRM) merusak seluruh suasana hati.  Jika ini diketahui sebelumnya, mungkin saya tidak akan memeriksa metodologi. <br><br><h2>  Kesimpulan </h2><br>  Secara tampilan, alat bantu firmware yang dikembangkan menjadi dapat diterima sehingga pada dasarnya dimungkinkan untuk membuat versi "Firmware", katakanlah, Marlin, yang tidak terus-menerus dalam pengendali interupsi untuk motor stepper.  Sejauh yang saya tahu, ini terutama berlaku untuk printer Delta, di mana permintaan untuk sumber daya komputasi cukup tinggi.  Mungkin ini akan menghilangkan masuknya yang terjadi di Delta saya di tempat-tempat di mana kepala berhenti.  Pada MZ3D di tempat yang sama tidak ada gelombang masuk yang diamati.  Benar atau tidak, waktu akan memberi tahu, dan laporan tentang ini perlu diposting di cabang yang sama sekali berbeda. <br><br>  Sementara itu, kita telah melihat bahwa pada blok UDB, untuk semua kesederhanaannya, sangat mungkin untuk mengimplementasikan coprocessor yang bekerja bersama-sama dengan prosesor utama dan membiarkannya diturunkan.  Dan ketika ada banyak unit ini, koprosesor dapat bekerja secara paralel. <br><br>  Kesalahan dalam dokumentasi untuk pengontrol DMA mengaburkan hasilnya.  Meskipun demikian interupsi diperlukan, tetapi tidak pada frekuensi yang sama dan tidak dengan kekritisan waktu yang ada dalam versi aslinya.  Jadi suasananya rusak, tetapi penggunaan "coprocessor" berbasis UDB masih memberikan keuntungan yang cukup besar dibandingkan dengan pekerjaan perangkat lunak murni. <br><br>  Sepanjang jalan, terungkap bahwa DMA bekerja pada kecepatan yang cukup rendah.  Sebagai akibatnya, beberapa pengukuran dilakukan baik pada PSoC5LP dan pada STM32.  Hasilnya menarik artikel lain.  Mungkin suatu hari nanti saya akan melakukannya jika topiknya ternyata menarik. <br><br>  Sebagai hasil dari percobaan, dua proyek uji diperoleh sekaligus.  Yang pertama lebih mudah dipahami.  Anda bisa membawanya ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Yang kedua diwarisi dari yang pertama, tetapi bingung ketika menambahkan penghitung tujuh-bit dan logika yang terkait.  Anda bisa membawanya ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Tentu saja, contoh-contoh ini hanya yang uji.  Tidak ada waktu luang untuk menanamkan ke dalam "firmware" nyata.  Tetapi dalam kerangka artikel ini, lebih penting untuk berlatih bekerja dengan UDB. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id434742/">https://habr.com/ru/post/id434742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id434732/index.html">Hidup di 6200 DPI. Ulasan Inti HyperX Pulsefire</a></li>
<li><a href="../id434734/index.html">Transformasi Fourier. Cepat dan geram</a></li>
<li><a href="../id434736/index.html">Menggunakan database log Mikrotik untuk menekan kekerasan</a></li>
<li><a href="../id434738/index.html">Penguatan Pembelajaran dengan Python</a></li>
<li><a href="../id434740/index.html">Jaringan saraf diajarkan untuk mendeteksi panel surya dalam gambar satelit dan memprediksi tingkat distribusinya</a></li>
<li><a href="../id434744/index.html">Samsung SSD 860 QVO 1 TB dan 4 TB: konsumen pertama SATA QLC (2 bagian)</a></li>
<li><a href="../id434746/index.html">BLE di bawah mikroskop 4</a></li>
<li><a href="../id434750/index.html">Bagaimana mengendalikan infrastruktur jaringan Anda. Bab Dua Pembersihan dan dokumentasi</a></li>
<li><a href="../id434752/index.html">Robomoroz: masa depan karakter utama Tahun Baru</a></li>
<li><a href="../id434756/index.html">Masa depan Kubernetes adalah dengan mesin virtual</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>