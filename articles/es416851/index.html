<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêó üåè ‚úåüèº Hibernate: sobre lo que los tutoriales guardan silencio üßï üåΩ üë©üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este art√≠culo no cubrir√° los conceptos b√°sicos de hibernaci√≥n (c√≥mo definir una entidad o escribir una consulta de criterios). Aqu√≠ tratar√© de hablar ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hibernate: sobre lo que los tutoriales guardan silencio</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416851/">  Este art√≠culo no cubrir√° los conceptos b√°sicos de hibernaci√≥n (c√≥mo definir una entidad o escribir una consulta de criterios).  Aqu√≠ tratar√© de hablar sobre puntos m√°s interesantes que son realmente √∫tiles en el trabajo.  Informaci√≥n sobre la cual no me he reunido en un solo lugar. <br><img src="https://habrastorage.org/webt/fi/bk/xl/fibkxlt7g2xcrfqbd7crf-bdlpq.png" alt="imagen"><br><a name="habracut"></a><br>  Har√© una reserva de inmediato.  Todo lo siguiente es cierto para Hibernate 5.2.  Los errores tambi√©n son posibles debido al hecho de que entend√≠ mal algo.  Si lo encuentra, escriba. <br><br><h2>  Problemas para mapear un modelo de objetos en un modelo relacional </h2><br>  Pero comencemos con los conceptos b√°sicos de ORM.  ORM - mapeo objeto-relacional - en consecuencia tenemos modelos relacionales y de objeto.  Y cuando se muestran uno a otro, hay problemas que debemos resolver por nuestra cuenta.  Vamos a desarmarlos. <br><br>  Para ilustrar, tomemos el siguiente ejemplo: tenemos la entidad "Usuario", que puede ser un Jedi o un avi√≥n de ataque.  Los Jedi deben tener fuerza, y la especializaci√≥n del avi√≥n de ataque.  A continuaci√≥n se muestra un diagrama de clase. <br><br><img src="https://habrastorage.org/webt/9d/pr/49/9dpr49fuefbbzbw1zva43phn5qk.png" alt="imagen"><br><br><h3>  Problema 1. Herencia y consultas polim√≥rficas. </h3><br>  Hay herencia en el modelo de objetos, pero no en el modelo relacional.  En consecuencia, este es el primer problema: c√≥mo asignar correctamente la herencia al modelo relacional. <br><br>  Hibernate ofrece 3 opciones para mostrar dicho modelo de objeto: <br><br><ol><li>  Todos los herederos est√°n en la misma mesa: <br>  <b>@Inheritance (estrategia = InheritanceType.SINGLE_TABLE)</b> <br><br><img src="https://habrastorage.org/webt/dr/qm/ql/drqmqltrkcv65eyrn-wpqtkq3gg.png" alt="imagen"><br><br>  En este caso, los campos comunes y los campos de los herederos se encuentran en una tabla.  Con esta estrategia, evitamos las uniones al seleccionar entidades.  De los inconvenientes, vale la pena se√±alar que, en primer lugar, no podemos establecer la restricci√≥n "NO NULO" para la columna "fuerza" en el modelo relacional, y en segundo lugar, perdemos la tercera forma normal.  (aparece una dependencia transitiva de atributos no clave: fuerza y ‚Äã‚Äãdisco). <br><br>  Por cierto, incluso por esta raz√≥n, hay 2 formas de especificar una restricci√≥n de campo no nula: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">NotNull</a> es responsable de la validaci√≥n;  @Column (nullable = true): responsable de la restricci√≥n no nula en la base de datos. <br><br>  En mi opini√≥n, esta es la mejor manera de asignar un modelo de objeto a un modelo relacional. <br></li><li>  Los campos espec√≠ficos de la entidad est√°n en una tabla separada. <br><br>  <b>@Inheritance (estrategia = InheritanceType.JOINED)</b> <br><br><img src="https://habrastorage.org/webt/05/wi/yt/05wiyttu0wnbvceub8udxmxtrn0.png" alt="imagen"><br><br>  En este caso, los campos comunes se almacenan en una tabla com√∫n, y los espec√≠ficos para entidades secundarias se almacenan en otros.  Al usar esta estrategia, obtenemos un JOIN al elegir una entidad, pero ahora guardamos la tercera forma normal, y tambi√©n podemos especificar una restricci√≥n NOT NULL en la base de datos. </li><li>  Cada entidad tiene su propia tabla. <br><br>  <b>@ InheritanceType.TABLE_PER_CLASS</b> <br><br><img src="https://habrastorage.org/webt/0t/ni/jw/0tnijwm5ykxrpufkcaoblj5dfzq.png" alt="imagen"><br><br>  En este caso, no tenemos una tabla com√∫n.  Usando esta estrategia, usamos UNION para consultas polim√≥rficas.  Estamos teniendo problemas con los generadores de claves primarias y otras restricciones de integridad.  Este tipo de mapeo de herencia es altamente desaconsejado. </li></ol><br>  Por si acaso, mencionar√© la anotaci√≥n: @MappedSuperclass.  Se utiliza cuando desea "ocultar" campos comunes para varias entidades del modelo de objetos.  Adem√°s, la clase anotada en s√≠ misma no se considera como una entidad separada. <br><br><h3>  Problema 2. Relaci√≥n de composici√≥n en POO </h3><br>  Volviendo a nuestro ejemplo, observamos que en el modelo de objetos tomamos el perfil del usuario en una entidad separada: Perfil.  Pero en el modelo relacional, no seleccionamos una tabla separada para ello. <br><br>  La actitud OneToOne es a menudo una mala pr√°ctica porque  en select tenemos un JOIN injustificado (incluso especificando fetchType = LAZY en la mayor√≠a de los casos tendremos JOIN - discutiremos este problema m√°s adelante). <br><br>  Hay anotaciones @Embedable y @Embeded para mostrar una composici√≥n en una tabla com√∫n.  El primero se coloca sobre el campo y el segundo sobre la clase.  Son intercambiables <br><br><h2>  Gerente de la entidad </h2><br>  Cada instancia de EntityManager (EM) define una sesi√≥n de interacci√≥n con la base de datos.  Dentro de una instancia de EM, hay un cach√© de primer nivel.  Aqu√≠ destacar√© los siguientes puntos significativos: <br><br><ol><li>  <b>Capturando la conexi√≥n de la base de datos</b> <br><br>  Este es solo un punto interesante.  Hibernate no captura Connection al momento de recibir el EM, sino al primer acceso a la base de datos o al abrir la transacci√≥n (aunque este problema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">puede resolverse</a> ).  Esto se hace para reducir el tiempo de conexi√≥n ocupada.  Durante la recepci√≥n de EM-a, se verifica la presencia de una transacci√≥n JTA. </li><li>  <b>Las entidades persistentes siempre tienen id.</b> </li><li>  <b>Las entidades que describen una l√≠nea en la base de datos son equivalentes por referencia</b> <br>  Como se mencion√≥ anteriormente, EM tiene un cach√© de primer nivel, los objetos en √©l se comparan por referencia.  En consecuencia, surge la pregunta: ¬øqu√© campos deber√≠an usarse para anular equals y hashcode?  Considere las siguientes opciones: <br><br><ul><li>  Utiliza todos los campos.  Mala idea  iguales puede afectar a los campos LAZY.  Por cierto, esto tambi√©n es cierto para el m√©todo toString. </li><li>  Usar solo ID.  Una idea normal, pero tambi√©n hay matices.  Dado que la mayor√≠a de las veces para nuevas entidades, id coloca un generador al momento de persistir.  La siguiente situaci√≥n es posible: <br><br><pre><code class="java hljs">Entity foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Entity(); <span class="hljs-comment"><span class="hljs-comment">//   (id = null) set.put(foo); //   hashset em.persist(foo); // persist  (id = some value) set.contains(foo) == false // .. hashCode   </span></span></code> </pre> <br></li><li>  Use una clave comercial (en t√©rminos generales, campos que son √∫nicos y NO NULOS).  Pero esta opci√≥n no siempre es conveniente. <br><br>  Por cierto, dado que estamos hablando de NOT NULL y UNIQUE, a veces es conveniente hacer un constructor p√∫blico con argumentos NOT NULL, y el constructor sin argumentos est√° protegido. </li><li>  No anule equals y hashcode en absoluto. </li></ul></li><li>  <b>C√≥mo funciona la descarga</b> <br>  Flush - ejecuta insert-s, update-s y delete-s acumulados en la base de datos.  Por defecto, el vaciado se ejecuta en casos: <br><br><ul><li>  Antes de ejecutar la consulta (con la excepci√≥n de em.get), esto es necesario para cumplir con el principio ACID.  Por ejemplo: cambiamos la fecha de nacimiento del avi√≥n de ataque, y luego quer√≠amos obtener el n√∫mero de aviones de ataque para adultos. <br><br>  Si estamos hablando de CriteriaQuery o JPQL, se ejecutar√° flush si la consulta afecta a una tabla cuyas entidades est√°n en la cach√© del primer nivel. </li><li>  Al cometer una transacci√≥n; </li><li>  A veces, cuando persiste una nueva entidad, en el caso de que podamos obtener su identificaci√≥n solo a trav√©s de la inserci√≥n. </li></ul><br>  Y ahora una peque√±a prueba.  ¬øCu√°ntas operaciones de ACTUALIZACI√ìN se realizar√°n en este caso? <br><br><pre> <code class="java hljs">val spaceCraft = em.find(SpaceCraft.class, <span class="hljs-number"><span class="hljs-number">1L</span></span>); spaceCraft.setCoords(...); spaceCraft.setCompanion( findNearestSpaceCraft(spacecraft) );</code> </pre> <br>  Una caracter√≠stica interesante de hibernaci√≥n est√° oculta bajo la operaci√≥n de vaciado: est√° tratando de reducir el tiempo que lleva bloquear las filas en la base de datos. <br><br>  Tambi√©n tenga en cuenta que existen diferentes estrategias para la operaci√≥n de descarga.  Por ejemplo, puede prohibir los cambios de "fusi√≥n" en la base de datos: se llama MANUAL (tambi√©n deshabilita el mecanismo de verificaci√≥n sucio). <br></li><li>  <b>Comprobaci√≥n sucia</b> <br><br>  La verificaci√≥n sucia es un mecanismo ejecutado durante una operaci√≥n de descarga.  Su prop√≥sito es encontrar entidades que las hayan cambiado y actualizarlas.  Para implementar dicho mecanismo, hibernate debe almacenar la copia original del objeto (con qu√© se comparar√° el objeto real).  Para ser m√°s precisos, hibernate almacena una copia de los campos del objeto, no del objeto en s√≠. <br><br>  Vale la pena se√±alar que si el gr√°fico de entidades es grande, entonces la operaci√≥n de verificaci√≥n sucia puede ser costosa.  No olvide que hibernate almacena 2 copias de entidades (m√°s o menos). <br>  Para "reducir el costo" de este proceso, use las siguientes caracter√≠sticas: <br><br><ul><li>  em.detach / em.clear: separa entidades de EntityManager </li><li>  FlushMode = MANUAL- √∫til en operaciones de lectura </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Inmutable</a> : tambi√©n evita operaciones de verificaci√≥n sucias </li></ul><br></li><li>  <b>Transacciones</b> <br><br>  Como sabe, hibernate le permite actualizar entidades solo dentro de una transacci√≥n.  Las operaciones de lectura ofrecen m√°s libertad: podemos ejecutarlas sin abrir expl√≠citamente una transacci√≥n.  Pero esta es precisamente la pregunta: ¬øvale la pena abrir una transacci√≥n expl√≠citamente para operaciones de lectura? <br><br>  Citar√© algunos hechos: <br><br><ul><li>  Cualquier declaraci√≥n se ejecuta en la base de datos dentro de la transacci√≥n.  Incluso si obviamente no lo abrimos.  (modo de confirmaci√≥n autom√°tica). </li><li>  Como regla, no estamos limitados a una consulta a la base de datos.  Por ejemplo: para obtener los primeros 10 registros, probablemente desee devolver el n√∫mero total de registros.  Y esto es casi siempre 2 solicitudes. </li><li>  Si hablamos de datos de primavera, los m√©todos de repositorio son transaccionales <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">por defecto</a> , mientras que los m√©todos de lectura son de solo lectura. </li><li>  La anotaci√≥n de resorte @Transactional (readOnly = true) tambi√©n afecta a FlushMode, m√°s precisamente, Spring lo pone en estado MANUAL, por lo que la hibernaci√≥n no realizar√° una verificaci√≥n sucia. </li><li>  Las pruebas sint√©ticas con una o dos consultas a la base de datos mostrar√°n que la confirmaci√≥n autom√°tica es m√°s r√°pida.  Pero en el modo de combate, esto puede no ser as√≠.  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">excelente art√≠culo sobre este tema</a> , + ver comentarios) </li></ul><br>  En pocas palabras: es una buena pr√°ctica llevar a cabo cualquier comunicaci√≥n con la base de datos en una transacci√≥n. <br></li></ol><br><h2>  Generadores </h2><br>  Se necesitan generadores para describir c√≥mo las claves primarias de nuestras entidades recibir√°n valores.  Repasemos r√°pidamente las opciones: <br><br><ul><li>  <b>GenerationType.AUTO</b> : la selecci√≥n del generador se basa en el dialecto.  No es la mejor opci√≥n, ya que la regla "expl√≠cito es mejor que lo impl√≠cito" solo se aplica aqu√≠. </li><li>  <b>GenerationType.IDENTITY</b> es la forma m√°s f√°cil de configurar un generador.  Se basa en la columna de incremento autom√°tico de la tabla.  Por lo tanto, para obtener id con persistir necesitamos insertar.  Es por eso que elimina la posibilidad de persistencia diferida y, por lo tanto, de procesamiento por lotes. </li><li>  <b>GenerationType.SEQUENCE</b> es el caso m√°s conveniente cuando obtenemos id de la secuencia. </li><li>  <b>GenerationType.TABLE</b> : en este caso, hibernate emula una secuencia a trav√©s de una tabla adicional.  No es la mejor opci√≥n, porque  en tal soluci√≥n, hibernate tiene que usar una transacci√≥n separada y bloqueo por l√≠nea. </li></ul><br>  Hablemos un poco m√°s sobre la secuencia.  Para aumentar la velocidad de operaci√≥n, hibernate utiliza diferentes algoritmos de optimizaci√≥n.  Todos ellos est√°n destinados a reducir el n√∫mero de conversaciones con la base de datos (el n√∫mero de viajes de ida y vuelta).  Miremos con m√°s detalle: <br><br><ul><li>  <b>ninguno</b> : sin optimizaciones.  para cada id sacamos secuencia. </li><li>  <b>agrupado y agrupado-lo</b> - en este caso, nuestra secuencia deber√≠a aumentar en un cierto intervalo - N en la base de datos (SequenceGenerator.allocationSize).  Y en la aplicaci√≥n, tenemos un cierto grupo, los valores desde los cuales podemos asignar a nuevas entidades sin acceder a la base de datos. </li><li>  <b>hilo</b> : para generar una ID, el algoritmo hilo usa 2 n√∫meros: hi (almacenado en la base de datos: el valor obtenido de la secuencia de llamadas) y lo (almacenado solo en la aplicaci√≥n: SequenceGenerator.allocationSize).  En base a estos n√∫meros, el intervalo para generar la identificaci√≥n se calcula de la siguiente manera: [(hi - 1) * lo + 1, hi * lo + 1).  Por razones obvias, este algoritmo se considera obsoleto y no se recomienda su uso. </li></ul><br>  Ahora veamos c√≥mo se selecciona el optimizador.  Hibernate tiene varios generadores de secuencia.  Estaremos interesados ‚Äã‚Äãen 2 de ellos: <br><br><ul><li>  <b>SequenceHiLoGenerator</b> es un generador antiguo que utiliza el optimizador de hilo.  Seleccionado por defecto si tenemos la propiedad hibernate.id.new_generator_mappings == false. </li><li>  <b>SequenceStyleGenerator</b> : se utiliza de forma predeterminada (si hibernate.id.new_generator_mappings == propiedad verdadera).  Este generador admite varios optimizadores, pero el valor predeterminado se agrupa. </li></ul><br>  Tambi√©n puede configurar la anotaci√≥n del generador @GenericGenerator. <br><br><h2>  Punto muerto </h2><br>  Veamos un ejemplo de una situaci√≥n de pseudoc√≥digo que puede conducir a un punto muerto: <br><br><pre> <code class="hljs pgsql">Thread #<span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">1</span></span>) Thread #<span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br>  Para evitar tales problemas, hibernate tiene un mecanismo que evita bloqueos de este tipo: el par√°metro hibernate.order_updates.  En este caso, todas las actualizaciones se ordenar√°n por id y se ejecutar√°n.  Tambi√©n mencionar√© una vez m√°s que hibernate est√° tratando de "retrasar" la captura de la conexi√≥n y la ejecuci√≥n de insert-s y update-s. <br><br><h2>  Conjunto, Bolsa, Lista </h2><br>  Hibernate tiene 3 formas principales de presentar la colecci√≥n de comunicaci√≥n OneToMany. <br><br><ul><li>  Conjunto: un conjunto desordenado de entidades sin repeticiones; </li><li>  Bolsa: un conjunto desordenado de entidades; </li><li>  La lista es un conjunto ordenado de entidades. </li></ul><br>  No existe una clase para Bag in java core que describa dicha estructura.  Por lo tanto, todas las listas y colecciones son bolsas a menos que especifique una columna por la cual se ordenar√° nuestra colecci√≥n (anotaci√≥n OrderColumn. No debe confundirse con SortBy).  Recomiendo encarecidamente no usar la anotaci√≥n OrderColumn debido a la mala implementaci√≥n (en mi opini√≥n) de las caracter√≠sticas: no consultas SQL √≥ptimas, posibles NULL en la hoja. <br><br>  Surge la pregunta, pero ¬øqu√© es mejor usar bolsa o set?  Para empezar, cuando se usa una bolsa, son posibles los siguientes problemas: <br><br><ul><li>  Si su versi√≥n de hibernate es inferior a 5.0.8, entonces hay un error bastante serio, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HHH-5855</a> , es posible la duplicaci√≥n al insertar una entidad secundaria (en el caso de cascadType = MERGE y PERSIST); </li><li>  Si usa bag para la relaci√≥n ManyToMany, hibernate genera consultas extremadamente inapropiadas al eliminar una entidad de la colecci√≥n: primero elimina todas las filas de la tabla de uni√≥n y luego realiza la inserci√≥n; </li><li>  Hibernate no puede buscar varias bolsas para la misma entidad al mismo tiempo. </li></ul><br>  En el caso de que desee agregar otra entidad a la conexi√≥n @OneToMany, es m√°s rentable usar Bag, porque  no requiere cargar todas las entidades relacionadas para esta operaci√≥n.  Veamos un ejemplo: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  bag spaceCraft.getCrew().add( luke ); //       //  set spaceCraft.getCrew().put( luke ); //      //        .     ManyToOne   : luke.setCurrentSpaceCraft( spaceCraft );</span></span></code> </pre><br><h2>  Referencias de fuerza </h2><br>  La referencia es una referencia a un objeto, que decidimos posponer la carga.  En el caso de la relaci√≥n de ManyToOne con fetchType = LAZY, obtenemos dicha referencia.  La inicializaci√≥n del objeto ocurre al momento de acceder a los campos de la entidad, con la excepci√≥n de id (ya que conocemos el valor de este campo). <br><br>  Vale la pena se√±alar que en el caso de Lazy Loading, la referencia siempre se refiere a una fila existente en la base de datos.  Por esta raz√≥n, la mayor√≠a de los casos de carga diferida no funcionan en las relaciones OneToOne: hibernate debe hacerse JOIN para verificar si la conexi√≥n existe y si ya exist√≠a JOIN, luego hibernate la carga en el modelo de objetos.  Si indicamos nullable = true en OneToOne, entonces LazyLoad deber√≠a funcionar. <br><br>  Podemos crear nuestra propia referencia utilizando el m√©todo em.getReference.  Es cierto que en este caso no hay garant√≠a de que la referencia se refiera a una fila existente en la base de datos. <br><br>  Pongamos un ejemplo del uso de dicho enlace: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  bag spaceCraft.getCrew().add( em.getReference( User.class, 1L ) ); //      ,     </span></span></code> </pre> <br>  Por si acaso, le recuerdo que obtendremos una LazyInitializationException en el caso de un EM cerrado o un enlace separado. <br><br><h2>  Fecha y hora </h2><br>  A pesar de que Java 8 tiene una API excelente para trabajar con fecha y hora, la API JDBC todav√≠a le permite trabajar solo con la API de fecha anterior.  Por lo tanto, analizaremos algunos puntos interesantes. <br><br>  Primero, debe comprender claramente las diferencias entre LocalDateTime e Instant y ZonedDateTime.  (No voy a estirar, pero dar√© excelentes art√≠culos sobre este tema: el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primero</a> y el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">segundo</a> ) <br><br><div class="spoiler">  <b class="spoiler_title">Si brevemente</b> <div class="spoiler_text">  LocalDateTime y LocalDate representan una tupla regular de n√∫meros.  No est√°n vinculados a un tiempo espec√≠fico.  Es decir  el tiempo de aterrizaje del avi√≥n no se puede almacenar en LocalDateTime.  Y la fecha de nacimiento a trav√©s de LocalDate es bastante normal.  Instant√°neo representa un punto en el tiempo, relativo al cual podemos obtener la hora local en cualquier punto del planeta. <br></div></div><br>  Un punto m√°s interesante e importante es c√≥mo se almacenan las fechas en la base de datos.  Si tenemos el tipo TIMESTAMP WITH TIMEZONE fijado, entonces no deber√≠a haber problemas, pero si TIMESTAMP (SIN TIMEZONE) se mantiene, existe la posibilidad de que la fecha se escriba / lea incorrectamente.  (excluyendo LocalDate y LocalDateTime) <br><br>  Veamos por qu√©: <br><br>  Cuando guardamos la fecha, se utiliza un m√©todo con la siguiente firma: <br><br><pre> <code class="java hljs">setTimestamp(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, Timestamp t, java.util.Calendar cal)</code> </pre> <br>  Como puede ver, la antigua API se usa aqu√≠.  El argumento opcional Calendario es necesario para convertir la marca de tiempo en una representaci√≥n de cadena.  Es decir, almacena la zona horaria en s√≠ misma.  Si no se transmite el calendario, entonces el calendario se usa por defecto con la zona horaria JVM. <br><br>  Hay 3 formas de resolver este problema: <br><br><ul><li>  Establezca la zona horaria deseada JVM </li><li>  Use el par√°metro hibernate - hibernate.jdbc.time_zone (agregado en 5.2) - solo arreglar√° ZonedDateTime y OffsetDateTime </li><li>  Utilice el tipo TIMESTAMP WITH TIMEZONE </li></ul><br>  Una pregunta interesante, ¬øpor qu√© LocalDate y LocalDateTime no se encuentran bajo este problema? <br><br><div class="spoiler">  <b class="spoiler_title">La respuesta</b> <div class="spoiler_text">  Para responder a esta pregunta, debe comprender la estructura de la clase java.util.Date (java.sql.Date y java.sql.Timestamp, sus herederos y sus diferencias en este caso no nos molestan).  Fecha almacena la fecha en milisegundos desde 1970, aproximadamente en UTC, pero el m√©todo toString convierte la fecha de acuerdo con la zona horaria del sistema. <br><br>  En consecuencia, cuando obtenemos una fecha sin zona horaria de la base de datos, se asigna a un objeto Timestamp para que el m√©todo toString muestre el valor deseado.  Al mismo tiempo, el n√∫mero de milisegundos desde 1970 puede diferir (dependiendo de la zona horaria).  Es por eso que solo la hora local siempre se muestra correctamente. <br><br>  Tambi√©n doy un ejemplo del c√≥digo responsable de convertir Timesamp a LocalDateTime e Instant: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// LocalDateTime LocalDateTime.ofInstant( ts.toInstant(), ZoneId.systemDefault() ); // Instant ts.toInstant();</span></span></code> </pre> <br></div></div><br><h2>  Procesamiento por lotes </h2><br>  Por defecto, las consultas se env√≠an a la base de datos de una en una.  Cuando se habilita el procesamiento por lotes, hibernate podr√° enviar varias declaraciones en una consulta a la base de datos.  (es decir, el procesamiento por lotes reduce la cantidad de viajes de ida y vuelta a la base de datos) <br><br>  Para hacer esto, debes: <br><br><ul><li>  Habilite el procesamiento por lotes y establezca el n√∫mero m√°ximo de declaraciones: <br>  hibernate.jdbc.batch_size (se recomiendan de 5 a 30) </li><li>  Habilite la clasificaci√≥n de inserci√≥n y actualizaci√≥n de s: <br>  hibernate.order_inserts <br>  hibernate.order_updates <br></li><li>  Si usamos versiones, tambi√©n debemos habilitar <br>  hibernate.jdbc.batch_versioned_data: tenga cuidado aqu√≠, necesita el controlador jdbc para poder proporcionar el n√∫mero de l√≠neas afectadas durante la actualizaci√≥n. </li></ul><br>  Tambi√©n le recordar√© sobre la efectividad de la operaci√≥n em.clear (): libera entidades de em, liberando as√≠ memoria y reduciendo el tiempo de la operaci√≥n de verificaci√≥n sucia. <br>  Si usamos postgres, entonces tambi√©n podemos decir hibernar para usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">inserci√≥n multi-raw</a> . <br><br><h2>  Problema N + 1 </h2><br>  Este es un tema bastante omnipresente, as√≠ que rep√≠talo r√°pidamente. <br><br>  Un problema de N + 1 es una situaci√≥n en la que, en lugar de una sola solicitud para seleccionar N libros, se producen al menos N + 1 solicitudes. <br><br>  La forma m√°s f√°cil de resolver el problema N + 1 es buscar tablas relacionadas.  En este caso, podemos experimentar varios otros problemas: <br><br><ul><li>  <b>Paginaci√≥n</b>  en el caso de las relaciones OneToMany, hibernate no podr√° especificar el desplazamiento y el l√≠mite.  Por lo tanto, la paginaci√≥n ocurrir√° en la memoria. </li><li>  <b>El problema de un producto cartesiano</b> es una situaci√≥n en la que una base de datos devuelve N * M * K filas para elegir N libros con M cap√≠tulos y K autores. </li></ul><br>  Hay otras formas de resolver el problema N + 1. <br><br><ul><li>  <b>FetchMode</b> : le permite cambiar el algoritmo de carga de entidades secundarias.  En nuestro caso, estamos interesados ‚Äã‚Äãen lo siguiente: <ul><li>  <b>FetchType.SUBSELECT</b> : carga registros secundarios en una solicitud separada.  La desventaja es que toda la complejidad de la solicitud principal se repite en la subselecci√≥n. </li><li>  <b>BATCH (FetchType.SELECT + BatchSize annotation)</b> : tambi√©n carga registros como una solicitud por separado, pero junto con la subconsulta crea una condici√≥n como WHERE parent_id IN (?,?,?, ..., N) </li></ul>  Vale la pena se√±alar que cuando se usa fetch en Criteria API, FetchType se ignora: JOIN siempre se usa </li><li>  <b>JPA EntityGraph e Hibernate FetchProfile</b> , le permiten convertir las reglas de carga de la entidad en una abstracci√≥n separada, en mi opini√≥n, ambas implementaciones son inconvenientes. </li></ul><br><h2>  Prueba </h2><br>  Idealmente, el entorno de desarrollo deber√≠a proporcionar tanta informaci√≥n √∫til como sea posible sobre la operaci√≥n de hibernaci√≥n y sobre la interacci√≥n con la base de datos.  A saber: <br><br><ul><li>  Registro <ul><li>  org.hibernate.SQL: depuraci√≥n </li><li>  org.hibernate.type.descriptor.sql: trace </li></ul></li><li>  Estad√≠sticas <ul><li>  hibernate.generate_statistics </li></ul></li></ul><br>  De las utilidades √∫tiles, se pueden distinguir las siguientes: <br><ul><li>  <b>DBUnit</b> : le permite describir el estado de la base de datos en formato XML.  A veces es conveniente.  Pero mejor piensa de nuevo si lo necesitas. </li><li>  DataSource-proxy <ul><li>  <b>p6spy</b> es una de las soluciones m√°s antiguas.  ofrece registro avanzado de consultas, tiempo de ejecuci√≥n, etc. </li><li>  <b>com.vladmihalcea: db-util: 0.0.1</b> es una √∫til utilidad para encontrar problemas de N + 1.  Tambi√©n le permite registrar consultas.  La composici√≥n incluye una interesante anotaci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Reintento</a> , que reintenta la transacci√≥n en el caso de una OptimisticLockException. </li><li>  <b>Sniffy</b> : le permite hacer una afirmaci√≥n sobre el n√∫mero de solicitudes a trav√©s de la anotaci√≥n.  De alguna manera, m√°s elegante que la decisi√≥n de Vlad. </li></ul></li></ul><br>  Pero una vez m√°s, repito que esto es solo para el desarrollo, esto no deber√≠a incluirse en la producci√≥n. <br><br><h2>  Literatura </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Informe de Nikolai Alimenkov - Hagamos que Hibernate vuelva a ser r√°pido</a> - fue este informe el que me inspir√≥ a estudiar hibernate m√°s profundamente.  A continuaci√≥n se encuentran los recursos que utilic√©. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El libro "Java Persistence API and Hibernate"</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Documentaci√≥n oficial</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Vlad M. Blog</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Java Weakly Digest</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">resumen</a> diario (relacionado indirectamente con el tema) </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es416851/">https://habr.com/ru/post/es416851/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es416841/index.html">C√≥mo probar hip√≥tesis y ganar dinero en Swift usando pruebas divididas</a></li>
<li><a href="../es416843/index.html">Motores de cohetes nucleares y sistemas de propulsi√≥n el√©ctrica de cohetes nucleares.</a></li>
<li><a href="../es416845/index.html">10 razones para usar rastrearlo o abandonarlo para siempre</a></li>
<li><a href="../es416847/index.html">El sitio de administraci√≥n de Ammyy nuevamente comprometido</a></li>
<li><a href="../es416849/index.html">Oh mi c√≥digo C√≥mo convertirse en administrador del sistema</a></li>
<li><a href="../es416855/index.html">Bachiller de la Universidad Estatal de San Petersburgo</a></li>
<li><a href="../es416857/index.html">Construimos templos, en c√≥digo y en la vida. Mi experiencia desarrollando mi segunda aplicaci√≥n de Android</a></li>
<li><a href="../es416859/index.html">Meet All at Once React Boilerplate por Maximilian Stoiber v3.6.0</a></li>
<li><a href="../es416863/index.html">Una nueva forma de presentar expositores</a></li>
<li><a href="../es416865/index.html">Dise√±o retro para la primera consola port√°til del lejano 1979</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>