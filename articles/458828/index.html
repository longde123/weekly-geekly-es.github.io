<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº üåª üë©üèø‚Äçüé§ Por qu√©, por qu√© y cu√°ndo usar ValueTask üë®üèæ‚Äçüç≥ üíáüèø üöè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta traducci√≥n surgi√≥ gracias al buen comentario 0x1000000 . 
 




 .NET Framework 4 introdujo el espacio System.Threading.Tasks, y con √©l la clase ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Por qu√©, por qu√© y cu√°ndo usar ValueTask</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458828/"><p>  <sup>Esta traducci√≥n surgi√≥ gracias al buen comentario <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">0x1000000</a> .</sup> <sup><br></sup> </p><p><img src="https://habrastorage.org/webt/4t/kr/wh/4tkrwhp_br-sobqvgwwyimflsjq.jpeg" alt="imagen"></p><br><p>  .NET Framework 4 introdujo el espacio System.Threading.Tasks, y con √©l la clase Task.  Este tipo y la Tarea &lt;Resultado&gt; generada a partir de √©l han estado esperando mucho tiempo hasta que los est√°ndares en .NET los reconozcan como los aspectos clave del modelo de programaci√≥n asincr√≥nico que se introdujo en C # 5 con sus declaraciones as√≠ncronas / en espera.  En este art√≠culo, hablar√© sobre los nuevos tipos de ValueTask / ValueTask &lt;TResult&gt;, dise√±ados para mejorar el rendimiento de los m√©todos asincr√≥nicos en los casos en que se debe tener en cuenta la sobrecarga de la asignaci√≥n de memoria. </p><a name="habracut"></a><br><h3 id="task">  Tarea </h3><br><p> La tarea act√∫a en diferentes roles, pero el principal es la "promesa" (promesa), un objeto que representa la posible finalizaci√≥n de alguna operaci√≥n.  Inicia una operaci√≥n y obtiene un objeto Tarea para √©l, que se ejecutar√° cuando se complete la operaci√≥n, lo que puede suceder en modo s√≠ncrono como parte de la inicializaci√≥n de la operaci√≥n (por ejemplo, recibir datos que ya est√°n en el b√∫fer), en modo as√≠ncrono con ejecuci√≥n en el momento en que obtienes Task (que recibe datos no del b√∫fer, pero muy r√°pidamente), o en modo as√≠ncrono, pero despu√©s de que ya tienes Task (que recibe datos de un recurso remoto).  Dado que la operaci√≥n puede finalizar de forma asincr√≥nica, puede bloquear el flujo de ejecuci√≥n, esperar el resultado (que a menudo hace que la asincron√≠a de la llamada no tenga sentido) o crear una funci√≥n de devoluci√≥n de llamada que se activar√° despu√©s de que se complete la operaci√≥n.  En .Net 4, la creaci√≥n de una devoluci√≥n de llamada se implementa mediante los m√©todos ContinueWith del objeto Task, que demuestran expl√≠citamente este modelo al aceptar una funci√≥n delegada para ejecutarlo despu√©s de ejecutar la tarea: </p><br><pre><code class="plaintext hljs">SomeOperationAsync().ContinueWith(task =&gt; { try { TResult result = task.Result; UseResult(result); } catch (Exception e) { HandleException(e); } });</code> </pre> <br><p>  Pero en .NET Framework 4.5 y C # 5, el operador de espera simplemente puede llamar a los objetos de tarea, lo que facilita obtener el resultado de una operaci√≥n asincr√≥nica, y el c√≥digo generado que est√° optimizado para las opciones anteriores funcionar√° correctamente en todos los casos cuando la operaci√≥n se complete en modo s√≠ncrono, as√≠ncrono r√°pido o as√≠ncrono al hacer callbacka: </p><br><pre> <code class="plaintext hljs">TResult result = await SomeOperationAsync(); UseResult(result);</code> </pre> <br><p>  La tarea es una clase muy flexible y tiene varias ventajas.  Por ejemplo, puede realizar la espera varias veces para cualquier n√∫mero de consumidores a la vez.  Puede ponerlo en una colecci√≥n (diccionario) para la espera repetida en el futuro, para usarlo como un cach√© de los resultados de las llamadas asincr√≥nicas.  Puede bloquear la ejecuci√≥n mientras espera que se complete la tarea si es necesario.  Y puede escribir y aplicar varias operaciones en objetos de Tarea (a veces llamados "combinadores"), por ejemplo, "cuando exista" para esperar asincr√≥nicamente la primera finalizaci√≥n de varias Tareas. <br>  Pero esta flexibilidad se vuelve superflua en el caso m√°s com√∫n: simplemente llame a la operaci√≥n asincr√≥nica y espere a que se complete la tarea: </p><br><pre> <code class="plaintext hljs">TResult result = await SomeOperationAsync(); UseResult(result);</code> </pre> <br><p>  Aqu√≠ no necesitamos esperar la ejecuci√≥n varias veces.  No necesitamos asegurarnos de que las expectativas sean competitivas.  No necesitamos realizar un bloqueo sincr√≥nico.  No escribiremos combinadores.  Estamos a la espera de que se complete la promesa de una operaci√≥n asincr√≥nica.  Al final, esta es la forma en que escribimos c√≥digo s√≠ncrono (por ejemplo, TResult result = SomeOperation ();), y esto normalmente se traduce en async / await. </p><br><p>  Adem√°s, la tarea tiene una debilidad potencial, especialmente cuando se crea una gran cantidad de instancias, y un alto rendimiento y rendimiento son requisitos clave: la tarea es una clase.  Esto significa que cualquier operaci√≥n que necesita una tarea se ve obligada a crear y colocar un objeto, y cuantos m√°s objetos se crean, m√°s trabajo se requiere para el recolector de basura (GC), y este trabajo consume recursos que podr√≠amos gastar en algo m√°s √∫til </p><br><p>  Las bibliotecas de tiempo de ejecuci√≥n y del sistema ayudan a mitigar este problema en muchas situaciones.  Por ejemplo, si escribimos un m√©todo como este: </p><br><pre> <code class="plaintext hljs">public async Task WriteAsync(byte value) { if (_bufferedCount == _buffer.Length) { await FlushAsync(); } _buffer[_bufferedCount++] = value; }</code> </pre> <br><p>  como regla general, habr√° suficiente espacio libre en el b√∫fer y la operaci√≥n se ejecutar√° sincr√≥nicamente.  Cuando esto sucede, no hay necesidad de hacer nada con la Tarea, que debe devolverse, ya que no hay un valor de retorno, esto est√° usando la Tarea como el equivalente de un m√©todo sincr√≥nico que devuelve un valor vac√≠o (nulo).  Por lo tanto, el entorno puede simplemente almacenar en cach√© una Tarea no gen√©rica y usarla una y otra vez como resultado de la ejecuci√≥n de cualquier m√©todo as√≠ncrono que finalice de forma sincr√≥nica (este singleton en cach√© se puede obtener a trav√©s de Task.CompletedTask).  O, por ejemplo, escribes: </p><br><pre> <code class="plaintext hljs">public async Task&lt;bool&gt; MoveNextAsync() { if (_bufferedCount == 0) { await FillBuffer(); } return _bufferedCount &gt; 0; }</code> </pre> <br><p>  y en general, espere que los datos ya est√©n en el b√∫fer, por lo que el m√©todo simplemente verifica el valor de _bufferedCount, ve que es mayor que 0 y devuelve verdadero;  y solo si todav√≠a no hay datos en el b√∫fer, debe realizar una operaci√≥n asincr√≥nica.  Y dado que solo hay dos resultados posibles de tipo booleano (verdadero y falso), solo se necesitan dos objetos de tarea posibles para representar estos resultados, el entorno puede almacenar en cach√© estos objetos y devolverlos con el valor correspondiente sin asignar memoria.  Solo en caso de finalizaci√≥n asincr√≥nica, el m√©todo deber√° crear una nueva Tarea, ya que deber√° devolverse antes de que se conozca el resultado de la operaci√≥n. <br></p><p>  El entorno proporciona almacenamiento en cach√© para algunos otros tipos, pero no es realista almacenar en cach√© todos los tipos posibles.  Por ejemplo, el siguiente m√©todo: </p><br><pre> <code class="plaintext hljs">public async Task&lt;int&gt; ReadNextByteAsync() { if (_bufferedCount == 0) { await FillBuffer(); } if (_bufferedCount == 0) { return -1; } _bufferedCount--; return _buffer[_position++]; }</code> </pre> <br><p>  a menudo tambi√©n se ejecutar√° sincr√≥nicamente.  Pero a diferencia de una variante con un resultado de tipo booleano, este m√©todo devuelve Int32, que tiene aproximadamente 4 mil millones de valores, y el almacenamiento en cach√© de todas las variantes de la tarea &lt;int&gt; requerir√° cientos de gigabytes de memoria.  El entorno proporciona una peque√±a memoria cach√© para la tarea &lt;int&gt;, pero un conjunto muy limitado de valores, por ejemplo, si este m√©todo finaliza de forma sincr√≥nica (los datos ya est√°n en el b√∫fer) con el valor de retorno de 4, ser√° una tarea almacenada en cach√©, pero si se devuelve el valor 42, deber√° crear uno nuevo Tarea &lt;int&gt;, similar a llamar a Task.FromResult (42). </p><br><p>  Muchos m√©todos de biblioteca intentan suavizar esto proporcionando su propia cach√©.  Por ejemplo, una sobrecarga en .NET Framework 4.5 del m√©todo MemoryStream.ReadAsync siempre finaliza sincr√≥nicamente, ya que lee datos de la memoria.  ReadAsync devuelve una tarea &lt;int&gt;, donde un resultado Int32 indica cu√°ntos bytes se han le√≠do.  Este m√©todo a menudo se usa en un bucle, a menudo con el mismo n√∫mero requerido de bytes para cada llamada, y a menudo esta necesidad se satisface por completo.  Entonces, para llamadas repetidas a ReadAsync, es razonable esperar que la Tarea &lt;int&gt; regrese sincr√≥nicamente con el mismo valor que en la llamada anterior.  Por lo tanto, un MemoryStream crea un cach√© para un objeto que regres√≥ en la √∫ltima llamada exitosa.  Y en la pr√≥xima llamada, si el resultado se repite, devolver√° el objeto almacenado en cach√©, y si no, crear√° uno nuevo con Task.FromResult, gu√°rdelo en la cach√© y devu√©lvalo. </p><br><p>  Sin embargo, hay muchos otros casos en los que la operaci√≥n se realiza de forma sincr√≥nica, pero el objeto Tarea &lt;resultado&gt; se ve obligado a crearse. </p><br><h4 id="valuetasktresult-i-sinhronnoe-vypolnenie">  ValueTask &lt;TResult&gt; y ejecuci√≥n s√≠ncrona </h4><br><p>  Todo esto requer√≠a la implementaci√≥n de un nuevo tipo en .NET Core 2.0, que estaba disponible en versiones anteriores de .NET en el paquete NuGet System.Threading.Tasks.Extensions: ValueTask &lt;TResult&gt;. <br>  ValueTask &lt;TResult&gt; se cre√≥ en .NET Core 2.0 como una estructura capaz de ajustar TResult y Task &lt;TResult&gt;.  Esto significa que se puede devolver desde el m√©todo as√≠ncrono, y si este m√©todo se ejecuta sincr√≥nicamente y con √©xito, no necesita colocar ning√∫n objeto en el mont√≥n: simplemente puede inicializar esta estructura ValueTask &lt;TResult&gt; con el valor TResult y devolverlo.  Solo en el caso de ejecuci√≥n asincr√≥nica, se colocar√° el objeto Task &lt;TResult&gt; y ValueTask &lt;TResult&gt; lo envolver√° (para minimizar el tama√±o de la estructura y optimizar el caso de ejecuci√≥n exitosa, el m√©todo as√≠ncrono, que termina con una excepci√≥n no admitida, tambi√©n colocar√° la tarea &lt;TResult&gt;, por lo que ValueTask &lt;TResult&gt; tambi√©n simplemente envuelve la tarea &lt;TResult&gt;, y no llevar√° consigo un campo adicional para almacenar Excepci√≥n). </p><br><p>  En base a esto, un m√©todo como MemoryStream.ReadAsync, pero que devuelve una ValueTask &lt;int&gt;, no deber√≠a ocuparse del almacenamiento en cach√©, sino que puede escribirse as√≠: </p><br><pre> <code class="plaintext hljs">public override ValueTask&lt;int&gt; ReadAsync(byte[] buffer, int offset, int count) { try { int bytesRead = Read(buffer, offset, count); return new ValueTask&lt;int&gt;(bytesRead); } catch (Exception e) { return new ValueTask&lt;int&gt;(Task.FromException&lt;int&gt;(e)); } }</code> </pre> <br><h4 id="valuetasktresult-i-asinhronnoe-vypolnenie">  ValueTask &lt;TResult&gt; y ejecuci√≥n asincr√≥nica </h4><br><p>  La capacidad de escribir un m√©todo as√≠ncrono que puede completarse sincr√≥nicamente sin la necesidad de una ubicaci√≥n adicional para el resultado es una gran victoria.  Es por eso que ValueTask &lt;TResult&gt; se agreg√≥ en .NET Core 2.0, y los nuevos m√©todos que probablemente se usar√°n en aplicaciones que requieren rendimiento ahora se anuncian con el retorno de ValueTask &lt;TResult&gt; en lugar de la Tarea &lt;TResult&gt;.  Por ejemplo, cuando agregamos una nueva sobrecarga de ReadAsync de la clase Stream a .NET Core 2.1, para poder pasar la Memoria en lugar del byte [], devolvemos el tipo ValueTask &lt;int&gt;.  De esta forma, los objetos Stream (en los que el m√©todo ReadAsync a menudo se ejecuta sincr√≥nicamente, como en el ejemplo anterior para MemoryStream) se pueden usar con mucha menos asignaci√≥n de memoria. <br></p><p>  Sin embargo, cuando trabajamos con servicios con un ancho de banda muy alto, a√∫n queremos evitar la asignaci√≥n de memoria tanto como sea posible, lo que significa reducir y eliminar la asignaci√≥n de memoria a lo largo de la ruta de ejecuci√≥n asincr√≥nica tambi√©n. <br>  En el modelo de espera, para cualquier operaci√≥n que se complete de forma as√≠ncrona, necesitamos la capacidad de devolver un objeto que represente la posible finalizaci√≥n de la operaci√≥n: la persona que llama debe redirigir la devoluci√≥n de llamada que se iniciar√° al final de la operaci√≥n, y esto requiere un objeto √∫nico en el mont√≥n, que puede servir como un canal de transmisi√≥n para Esta operaci√≥n particular.  Esto, al mismo tiempo, no significa nada si este objeto se reutilizar√° despu√©s de que se complete la operaci√≥n.  Si este objeto se puede reutilizar, la API puede organizar un cach√© para uno o m√°s de estos objetos, y usarlo para operaciones secuenciales, en el sentido de no usar el mismo objeto para varias operaciones as√≠ncronas intermedias, sino usarlo para acceso no competitivo. <br>  En .NET Core 2.1, la clase ValueTask &lt;TResult&gt; se ha mejorado para admitir una agrupaci√≥n y reutilizaci√≥n similares.  En lugar de simplemente ajustar TResult o Task &lt;TResult&gt;, una clase revisada puede ajustar una nueva interfaz IValueTaskSource &lt;TResult&gt;.  Esta interfaz proporciona la funcionalidad b√°sica que se requiere para acompa√±ar una operaci√≥n asincr√≥nica con un objeto ValueTask &lt;TResult&gt; de la misma manera que lo hace la tarea &lt;TResult&gt;: </p><br><pre> <code class="plaintext hljs">public interface IValueTaskSource&lt;out TResult&gt; { ValueTaskSourceStatus GetStatus(short token); void OnCompleted(Action&lt;object&gt; continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags); TResult GetResult(short token); }</code> </pre> <br><p>  El m√©todo GetStatus se usa para implementar propiedades como ValueTask &lt;TResult&gt; .IsCompleted, que devuelve informaci√≥n sobre si una operaci√≥n asincr√≥nica se realiza o se completa, y c√≥mo se completa (exitosa o no).  El objeto de espera utiliza el m√©todo OnCompleted para adjuntar una devoluci√≥n de llamada para continuar la ejecuci√≥n desde el punto de espera cuando finaliza la operaci√≥n.  Y el m√©todo GetResult es necesario para obtener el resultado de la operaci√≥n, por lo que una vez que se completa la operaci√≥n, la persona que llama puede obtener el objeto TResult o pasar cualquier excepci√≥n que se haya producido. </p><br><p>  La mayor√≠a de los desarrolladores no necesitan esta interfaz: los m√©todos simplemente devuelven un objeto ValueTask &lt;TResult&gt;, que se puede crear como un contenedor para un objeto que implementa esta interfaz, y el m√©todo de llamada permanecer√° en la oscuridad.  Esta interfaz es para desarrolladores que necesitan evitar la asignaci√≥n de memoria cuando usan una API de rendimiento cr√≠tico. </p><br><p>  Hay varios ejemplos de dicha API en .NET Core 2.1.  Los m√©todos m√°s famosos son Socket.ReceiveAsync y Socket.SendAsync con nuevas sobrecargas agregadas en 2.1, por ejemplo </p><br><pre> <code class="plaintext hljs">public ValueTask&lt;int&gt; ReceiveAsync(Memory&lt;byte&gt; buffer, SocketFlags socketFlags, CancellationToken cancellationToken = default);</code> </pre> <br><p>  Esta sobrecarga devuelve una ValueTask &lt;int&gt;.  Si la operaci√≥n se completa sincr√≥nicamente, simplemente puede devolver una ValueTask &lt;int&gt; con el valor correspondiente: </p><br><pre> <code class="plaintext hljs">int result = ‚Ä¶; return new ValueTask&lt;int&gt;(result);</code> </pre> <br><p>  Cuando finaliza de forma as√≠ncrona, puede usar un objeto del grupo que implementa la interfaz: </p><br><pre> <code class="plaintext hljs">IValueTaskSource&lt;int&gt; vts = ‚Ä¶; return new ValueTask&lt;int&gt;(vts);</code> </pre> <br><p>  La implementaci√≥n de Socket admite uno de esos objetos en el grupo para la recepci√≥n y uno para la transmisi√≥n, ya que no puede haber m√°s de un objeto para cada direcci√≥n esperando ser ejecutado a la vez.  Estas sobrecargas no asignan memoria, incluso en el caso de una operaci√≥n asincr√≥nica.  Este comportamiento es m√°s evidente en la clase NetworkStream. <br>  Por ejemplo, en .NET Core 2.1 Stream proporciona: </p><br><pre> <code class="plaintext hljs">public virtual ValueTask&lt;int&gt; ReadAsync(Memory&lt;byte&gt; buffer, CancellationToken cancellationToken);</code> </pre> <br><p>  que se redefine en NetworkStream.  El m√©todo NetworkStream.ReadAsync simplemente usa el m√©todo Socket.ReceiveAsync, de modo que las ganancias en Socket se transmiten a NetworkStream, y NetworkStream.ReadAsync tampoco asigna memoria. </p><br><h4 id="neobobschyonnyy-valuetask">  ValueTask no compartido </h4><br><p>  Cuando ValueTask &lt;TResult&gt; apareci√≥ en .NET Core 2.0, solo el caso de ejecuci√≥n s√≠ncrona se optimiz√≥ para excluir la ubicaci√≥n del objeto Task &lt;TResult&gt; si el valor TResult ya est√° listo.  Esto significaba que la clase ValueTask no gen√©rica no era necesaria: para el caso de ejecuci√≥n s√≠ncrona, la tarea Singleton.CompletedTask simplemente pod√≠a devolverse del m√©todo, y esto lo hac√≠a el entorno impl√≠citamente en los m√©todos as√≠ncronos que devolv√≠an la tarea. </p><br><p>  Sin embargo, al obtener operaciones asincr√≥nicas sin asignar memoria, el uso de ValueTask no compartido ha vuelto a ser relevante.  En .NET Core 2.1, presentamos el ValueTask gen√©rico y IValueTaskSource.  Proporcionan equivalentes directos para versiones gen√©ricas, para uso similar, con solo un valor de retorno vac√≠o. </p><br><h4 id="realizaciya-ivaluetasksourceivaluetasksourcet">  Implemente IValueTaskSource / IValueTaskSource &lt;T&gt; </h4><br><p>  La mayor√≠a de los desarrolladores no deber√≠an implementar estas interfaces.  Adem√°s, no es tan f√°cil.  Si decide hacer esto, varias implementaciones en .NET Core 2.1 pueden servir como punto de partida, por ejemplo: </p><br><ul><li>  AwaitableSocketAsyncEventArgs </li><li>  AsyncOperation &lt;TResult&gt; </li><li>  DefaultPipeReader </li></ul><br><p>  Para facilitar esto, en .NET Core 3.0 planeamos presentar toda la l√≥gica necesaria incluida en el tipo ManualResetValueTaskSourceCore &lt;TResult&gt;, una estructura que se puede incrustar en otro objeto que implementa IValueTaskSource &lt;TResult&gt; y / o IValueTaskSource, para que pueda delegarse en Esta estructura es la mayor parte de la funcionalidad.  Puede obtener m√°s informaci√≥n sobre esto en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/dotnet/corefx/issues/32664</a> en el repositorio dotnet / corefx. </p><br><h4 id="patterny-primeneniya-valuetasks">  Patrones de aplicaci√≥n de ValueTasks </h4><br><p>  A primera vista, el alcance de ValueTask y ValueTask &lt;TResult&gt; es mucho m√°s limitado que Task y Task &lt;TResult&gt;.  Esto es bueno e incluso esperado, ya que la forma principal de usarlos es simplemente usando el operador de espera. </p><br><p>  Sin embargo, dado que pueden envolver objetos que se reutilizan, existen restricciones significativas en su uso en comparaci√≥n con la Tarea y la Tarea &lt;Resultado&gt;, si se desv√≠a de la forma habitual de espera simple.  En casos generales, las siguientes operaciones nunca deben realizarse con ValueTask / ValueTask &lt;TResult&gt;: </p><br><ul><li>  <strong>Espera repetida ValueTask / ValueTask &lt;TResult&gt;</strong> El objeto resultante ya puede eliminarse y utilizarse en otra operaci√≥n.  Por el contrario, Tarea / Tarea &lt;Resultado&gt; nunca pasa de un estado completado a uno incompleto, por lo que puede volver a esperarlo tantas veces como sea necesario y obtener el mismo resultado cada vez. </li><li>  <strong>Espera paralela ValueTask / ValueTask &lt;TResult&gt;</strong> El objeto de resultado espera el procesamiento con solo una devoluci√≥n de llamada de un consumidor a la vez, e intentar esperar de diferentes flujos al mismo tiempo puede conducir f√°cilmente a carreras y errores sutiles del programa.  Adem√°s, tambi√©n es un caso m√°s espec√≠fico de la operaci√≥n inv√°lida anterior de "re-espera".  En comparaci√≥n, Task / Task &lt;TResult&gt; proporciona cualquier cantidad de espera paralela. </li><li>  <strong>Usando .GetAwaiter (). GetResult () cuando la operaci√≥n a√∫n no se ha completado. La</strong> implementaci√≥n de IValueTaskSource / IValueTaskSource &lt;TResult&gt; no necesita soporte de bloqueo hasta que se complete la operaci√≥n, y lo m√°s probable es que no lo haga, por lo que dicha operaci√≥n definitivamente conducir√° a carreras y probablemente no se ejecutar√° como lo espera el m√©todo de llamada.  Task / Task &lt;TResult&gt; bloquea el hilo de llamada hasta que se complete la tarea. </li></ul><br><p>  Si recibi√≥ un ValueTask o ValueTask &lt;TResult&gt;, pero necesita realizar una de estas tres operaciones, puede usar .AsTask (), obtener Task / Task &lt;TResult&gt; y luego trabajar con el objeto recibido.  Despu√©s de eso, ya no puede usar esa ValueTask / ValueTask &lt;TResult&gt;. </p><br><p>  En resumen, la regla es la siguiente: cuando use ValueTask / ValueTask &lt;TResult&gt; debe esperarlo directamente (posiblemente con .ConfigureAwait (false)) o llamar a AsTask () y no usarlo m√°s: </p><br><pre> <code class="plaintext hljs">//   ,  ValueTask&lt;int&gt; public ValueTask&lt;int\&gt; SomeValueTaskReturningMethodAsync(); ... // GOOD int result = await SomeValueTaskReturningMethodAsync(); // GOOD int result = await SomeValueTaskReturningMethodAsync().ConfigureAwait(false); // GOOD Task&lt;int&gt; t = SomeValueTaskReturningMethodAsync().AsTask(); // WARNING ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); //       , //     // BAD: await   ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); int result = await vt; int result2 = await vt; // BAD: await  (    ) ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); Task.Run(async () =&gt; await vt); Task.Run(async () =&gt; await vt); // BAD:  GetAwaiter().GetResult(),     ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); int result = vt.GetAwaiter().GetResult();</code> </pre> <br><p>  Hay un patr√≥n m√°s avanzado que los programadores pueden aplicar, espero, solo despu√©s de una medici√≥n cuidadosa y de obtener ventajas significativas.  Las clases ValueTask / ValueTask &lt;TResult&gt; tienen varias propiedades que informan el estado actual de la operaci√≥n, por ejemplo, la propiedad IsCompleted devuelve verdadero si la operaci√≥n se complet√≥ (es decir, ya no se ejecuta y completa con √©xito o no con √©xito), y la propiedad IsCompletedSuccessfully devuelve verdadero, solo si se complet√≥ con √©xito (mientras esperaba y recib√≠a el resultado, no arroj√≥ una excepci√≥n).  Para los subprocesos de ejecuci√≥n m√°s exigentes, donde el desarrollador desea evitar los costos que surgen en modo as√≠ncrono, estas propiedades se pueden verificar antes de una operaci√≥n que realmente destruya el objeto ValueTask / ValueTask &lt;TResult&gt;, por ejemplo aguarde, .AsTask ().  Por ejemplo, en la implementaci√≥n de SocketsHttpHandler en .NET Core 2.1, el c√≥digo se lee desde la conexi√≥n y recibe un ValueTask &lt;int&gt;.  Si esta operaci√≥n se realiza sincr√≥nicamente, no tenemos que preocuparnos por la terminaci√≥n anticipada de la operaci√≥n.  Pero si se ejecuta de forma as√≠ncrona, debemos conectar el proceso de interrupci√≥n para que la solicitud de interrupci√≥n rompa la conexi√≥n.  Dado que este es un c√≥digo muy estresante, si la elaboraci√≥n de perfiles muestra la necesidad del siguiente peque√±o cambio, puede estructurarse as√≠: </p><br><pre> <code class="plaintext hljs">int bytesRead; { ValueTask&lt;int&gt; readTask = _connection.ReadAsync(buffer); if (readTask.IsCompletedSuccessfully) { bytesRead = readTask.Result; } else { using (_connection.RegisterCancellation()) { bytesRead = await readTask; } } }</code> </pre> <br><h4 id="dolzhen-li-kazhdyy-novyy-metod-asinhronnogo-api-vozvraschat-valuetaskvaluetasktresult">  ¬øDeber√≠a cada nuevo m√©todo API as√≠ncrono devolver un ValueTask / ValueTask &lt;TResult&gt;? </h4><br><p>  Para responder brevemente: no, de forma predeterminada todav√≠a vale la pena elegir Tarea / Tarea &lt;Resultado&gt;. <br>  Como se destac√≥ anteriormente, Tarea y Tarea &lt;Tresult&gt; son m√°s f√°ciles de usar correctamente que ValueTask y ValueTask &lt;TResult&gt;, y siempre que los requisitos de rendimiento no superen los requisitos pr√°cticos, se prefieren Tarea y Tarea &lt;TResult&gt;.  Adem√°s, hay peque√±os costos asociados con la devoluci√≥n de ValueTask &lt;TResult&gt; en lugar de una Task &lt;TResult&gt;, es decir, los micro puntos de referencia muestran que esperar Task &lt;TResult&gt; es m√°s r√°pido que aguardar ValueTask &lt;TResult&gt;.  Por lo tanto, si utiliza el almacenamiento en cach√© de tareas, por ejemplo, su m√©todo devuelve Tarea o Tarea, por rendimiento, vale la pena quedarse con Tarea o Tarea.  Los objetos ValueTask / ValueTask &lt;TResult&gt; ocupan varias palabras en la memoria, por lo tanto, cuando se esperan y sus campos est√°n reservados en la m√°quina de estado que llama al m√©todo as√≠ncrono, ocupar√°n m√°s memoria en √©l. <br></p><p>  - ValueTask/ValueTask&lt;TResult&gt;    : )  ,        await, )        , )     ,          .   ,                /  . </p><br><h4 id="chto-dalshe-s-valuetask-i-valuetasktresult">    ValueTask  ValueTask&lt;TResult&gt;? </h4><br><p>    .NET      ,  Task/Task&lt;TResult&gt;,  ,  ValueTask/ValueTask&lt;TResult&gt;,     ,   .      ‚Äì   IAsyncEnumerator&lt;T&gt;,     .NET Core 3.0. IEnumerator&lt;T&gt;   MoveNext,   bool,     IAsyncEnumerator&lt;T&gt;   MoveNextAsync.     , ,     Task,             . ,   ,       ,        (           ),        await   foreach,      ValueTask.        ,         .      C#   ,    ,     ,   . </p><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/458828/">https://habr.com/ru/post/458828/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458812/index.html">JVM TI: c√≥mo hacer un complemento para una m√°quina virtual</a></li>
<li><a href="../458814/index.html">Lanzar un sitio para un producto con una demanda sin forma</a></li>
<li><a href="../458818/index.html">Destacados contempor√°neos</a></li>
<li><a href="../458820/index.html">Sobre la implementaci√≥n del famoso g√©nero en la plataforma Minecraft</a></li>
<li><a href="../458826/index.html">C√≥mo eliminar los art√≠culos viejos para que crezcan bruscamente en lo org√°nico: + 104% del tr√°fico durante seis meses</a></li>
<li><a href="../458830/index.html">Seminarios web de Dell Technologies: todos los detalles de nuestro tutorial</a></li>
<li><a href="../458832/index.html">Cinco estudiantes y tres tiendas distribuidas de valor clave</a></li>
<li><a href="../458834/index.html">Lado de la personalidad de Paul Allen, sobre el cual no tanta gente sab√≠a como me gustar√≠a</a></li>
<li><a href="../458836/index.html">√çndice de Borsch. Un enfoque sistem√°tico para evaluar, comparar y determinar la relaci√≥n calidad / precio.</a></li>
<li><a href="../458840/index.html">C√≥mo atravesamos el Gran Firewall chino (parte 2)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>