<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•Ä üëã ‚óÄÔ∏è Versi√≥n de texto del informe "Actores vs CSP vs Tareas ..." con C ++ CoreHard Oto√±o 2018 üà∏ üë®üèΩ‚Äçüé® üóæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A principios de noviembre, Minsk organiz√≥ la pr√≥xima conferencia C ++ C ++ CoreHard Oto√±o 2018 conferencia. Entreg√≥ un informe del capit√°n "Actores vs...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Versi√≥n de texto del informe "Actores vs CSP vs Tareas ..." con C ++ CoreHard Oto√±o 2018</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430672/">  A principios de noviembre, Minsk organiz√≥ la pr√≥xima conferencia C ++ C ++ CoreHard Oto√±o 2018 conferencia. Entreg√≥ un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informe del capit√°n "Actores vs CSP vs Tareas ..."</a> , que habl√≥ sobre c√≥mo las aplicaciones de nivel superior que "pueden verse en C ++" multihilo desnudo ‚Äù, modelos de programaci√≥n competitivos.  Bajo la versi√≥n cortada de este informe, transformado en un art√≠culo.  Peinado, recortado en lugares, complementado en lugares. <br><br>  Me gustar√≠a aprovechar esta oportunidad para agradecer a la comunidad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CoreHard</a> por organizar la pr√≥xima gran conferencia en Minsk y por la oportunidad de hablar.  Y tambi√©n para la pronta publicaci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informes en video de informes en YouTube</a> . <br><br>  Entonces, pasemos al tema principal de la conversaci√≥n.  Es decir, qu√© enfoques podemos usar para simplificar la programaci√≥n de subprocesos m√∫ltiples en C ++, c√≥mo se ver√°n algunos de estos enfoques en el c√≥digo, qu√© caracter√≠sticas son inherentes a los enfoques espec√≠ficos, qu√© es com√∫n entre ellos, etc. <br><br>  Nota: se encontraron errores y errores tipogr√°ficos en la presentaci√≥n original del informe, por lo que el art√≠culo utilizar√° diapositivas de la versi√≥n actualizada y editada, que se pueden encontrar en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Google Slides</a> o en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SlideShare</a> . <br><br><h1>  ¬°El subprocesamiento m√∫ltiple desnudo es malo! </h1><br>  Debe comenzar con la banalidad repetida, que, sin embargo, sigue siendo relevante: <br><blockquote>  La programaci√≥n de C ++ multiproceso a trav√©s de hilos desnudos, mutex y variables de condici√≥n es <b>sudor</b> , <b>dolor</b> y <b>sangre</b> . </blockquote><a name="habracut"></a><br>  Un buen ejemplo se describi√≥ recientemente aqu√≠ en este art√≠culo aqu√≠ en Habr√©: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Arquitectura del meta-servidor del tirador en l√≠nea m√≥vil Tacticool</a> ".  En √©l, los chicos hablaron sobre c√≥mo lograron recolectar, aparentemente, una gama completa de rastrillos relacionados con el desarrollo de c√≥digo multiproceso en C y C ++.  Hubo "pases de memoria" como resultado de las carreras y bajo rendimiento debido a la paralelizaci√≥n fallida. <br><br>  Como resultado, todo termin√≥ de forma bastante natural: <br><blockquote>  Despu√©s de pasar un par de semanas buscando y reparando los errores m√°s cr√≠ticos, decidimos que era <u>m√°s f√°cil reescribir todo desde cero</u> que tratar de corregir todas las deficiencias de la soluci√≥n actual. </blockquote><br>  Las personas comieron C / C ++ mientras trabajaban en la primera versi√≥n de su servidor y reescribieron el servidor en otro idioma. <br><br>  Una gran demostraci√≥n de c√≥mo, en el mundo real, fuera de nuestra acogedora comunidad de C ++, los desarrolladores se niegan a usar C ++ incluso cuando el uso de C ++ sigue siendo apropiado y justificado. <br><br><h2>  Pero por que? </h2><br>  Pero, ¬øpor qu√©, si se dice repetidamente que "subprocesamiento m√∫ltiple desnudo" en C ++ es malo, las personas contin√∫an us√°ndolo con perseverancia digna de una mejor aplicaci√≥n?  ¬øCu√°l es la culpa? <br><br><ul><li>  ignorancia? </li><li>  pereza? </li><li>  S√≠ndrome de NIH? </li></ul><br>  Despu√©s de todo, hay mucho de un enfoque probado por el tiempo y muchos proyectos.  En particular: <br><br><ul><li>  actores </li><li>  Comunicar procesos secuenciales (CSP) </li><li>  tareas (as√≠ncronas, promesas, futuros, ...) </li><li>  flujos de datos </li><li>  programaci√≥n reactiva </li><li>  ... </li></ul><br>  Se espera que la raz√≥n principal sea la ignorancia.  Es poco probable que esto se ense√±e en las universidades.  Entonces, los j√≥venes profesionales que ingresan a la profesi√≥n usan lo poco que ya saben.  Y si luego el almac√©n de conocimiento no se repone, la gente contin√∫a usando hilos desnudos, mutexes y condici√≥n_variables. <br><br>  Hoy hablaremos sobre los primeros tres enfoques de esta lista.  Y hablaremos no de manera abstracta, sino sobre el ejemplo de una tarea simple.  Intentemos mostrar c√≥mo se ver√° el c√≥digo que resuelve este problema usando Actor, procesos y canales CSP, as√≠ como tambi√©n usando Task. <br><br><h1>  Desaf√≠o para experimentos </h1><br>  Se requiere implementar un servidor HTTP que: <br><br><ul><li>  acepta la solicitud (identificaci√≥n con foto, identificaci√≥n del usuario); </li><li>  da una imagen con "marcas de agua" exclusivas de este usuario. </li></ul><br>  Por ejemplo, tal servidor puede ser requerido por alg√∫n servicio pago que distribuya contenido por suscripci√≥n.  Si la imagen de este servicio "aparece" en alg√∫n lugar, entonces por las "marcas de agua" en ella ser√° posible entender qui√©n necesita "bloquear el ox√≠geno". <br><br>  La tarea es abstracta, se formul√≥ espec√≠ficamente para este informe bajo la influencia de nuestro proyecto demo Shrimp (ya hablamos de ello: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">No. 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">No. 2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">No. 3</a> ). <br><br>  Este nuestro servidor HTTP funcionar√° de la siguiente manera: <br><table border="1"><tbody><tr><td><img src="https://habrastorage.org/webt/bq/qo/zk/bqqozkulonydk1ccnzog-kzv610.jpeg"></td></tr></tbody></table><br>  Habiendo recibido una solicitud de un cliente, pasamos a dos servicios externos: <br><br><ul><li>  el primero nos devuelve la informaci√≥n del usuario.  Incluyendo a partir de ah√≠ obtenemos una imagen con "marcas de agua"; </li><li>  el segundo nos devuelve la imagen original </li></ul><br>  Ambos servicios funcionan de forma independiente y podemos acceder a ambos simult√°neamente. <br><br>  Dado que el procesamiento de las solicitudes se puede realizar de forma independiente, e incluso algunas acciones al procesar una sola solicitud se pueden realizar en paralelo, el uso de la competitividad se sugiere.  Lo m√°s simple que viene a la mente es crear un hilo separado para cada solicitud entrante: <br><table border="1"><tbody><tr><td><img src="https://habrastorage.org/webt/g0/f9/ps/g0f9ps3vmq-osh-hy0i71ut_kfw.jpeg"></td></tr></tbody></table><br>  Pero el modelo one-request = one-workflow es demasiado costoso y no escala bien.  No necesitamos esto. <br><br>  Incluso si nos acercamos al n√∫mero de flujos de trabajo de manera in√∫til, todav√≠a necesitamos un peque√±o n√∫mero de ellos: <br><table border="1"><tbody><tr><td><img src="https://habrastorage.org/webt/ve/yl/vv/veylvvoaisqxod1-0nsp4vhh80e.jpeg"></td></tr></tbody></table><br>  Aqu√≠ necesitamos una secuencia separada para recibir solicitudes HTTP entrantes, una secuencia separada para nuestras propias solicitudes HTTP salientes, una secuencia separada para coordinar el procesamiento de las solicitudes HTTP recibidas.  Adem√°s de un conjunto de flujos de trabajo para realizar operaciones en im√°genes (dado que las manipulaciones en im√°genes son muy paralelas, el procesamiento de una imagen por varias secuencias a la vez reducir√° su tiempo de procesamiento). <br><br>  Por lo tanto, nuestro objetivo es manejar una gran cantidad de solicitudes entrantes concurrentes en una peque√±a cantidad de subprocesos de trabajo.  Veamos c√≥mo logramos esto a trav√©s de varios enfoques. <br><br><h2>  Algunas renuncias importantes </h2><br>  Antes de pasar a la historia principal y los ejemplos de c√≥digo de an√°lisis, se deben tomar algunas notas. <br><br>  En primer lugar, todos los siguientes ejemplos no est√°n vinculados a ning√∫n marco o biblioteca en particular.  Las coincidencias en los nombres de las llamadas a la API son aleatorias y no intencionadas. <br><br>  En segundo lugar, no hay manejo de errores en los ejemplos a continuaci√≥n.  Esto se hace deliberadamente, para que las diapositivas sean compactas y visibles.  Y tambi√©n para que el material encaje en el tiempo asignado para el informe. <br><br>  En tercer lugar, los ejemplos usan una determinada entidad execute_context, que contiene informaci√≥n sobre qu√© m√°s existe dentro del programa.  Llenar esta entidad depende del enfoque.  En el caso de los actores, execute_context tendr√° enlaces a otros actores.  En el caso de CSP, en el contexto de ejecuci√≥n habr√° canales CSP para la comunicaci√≥n con otros procesos CSP.  Etc. <br><br><h1>  Enfoque n. ¬∞ 1: actores </h1><br><h2>  Modelo de actores en pocas palabras </h2><br>  Cuando se utiliza el Modelo de actores, la soluci√≥n se construir√° con objetos-actores separados, cada uno de los cuales tiene su propio estado privado y este estado es inaccesible para cualquier persona, excepto el propio actor. <br><br>  Los actores interact√∫an entre s√≠ a trav√©s de mensajes asincr√≥nicos.  Cada actor tiene su propio buz√≥n √∫nico (cola de mensajes), en el que se guardan los mensajes enviados al actor y desde donde se recuperan para su posterior procesamiento. <br><br>  Los actores trabajan sobre principios muy simples: <br><br><ul><li>  un actor es una entidad con comportamiento; </li><li>  los actores responden a los mensajes entrantes; </li><li>  Una vez recibido el mensaje, el actor puede: <br><ul><li>  enviar un n√∫mero (final) de mensajes a otros actores; </li><li>  crear un n√∫mero (final) de nuevos actores; </li><li>  Defina un nuevo comportamiento para procesar mensajes posteriores. </li></ul></li></ul><br>  Dentro de una aplicaci√≥n, los actores se pueden implementar de diferentes maneras: <br><br><ul><li>  cada actor puede representarse como un flujo de sistema operativo separado (esto sucede, por ejemplo, en la biblioteca C :: Just :: Thread Pro Actor Edition); </li><li>  cada actor puede ser representado como una corutina apilada; </li><li>  cada actor puede representarse como un objeto en el que alguien llama a m√©todos de devoluci√≥n de llamada. </li></ul><br>  En nuestra decisi√≥n, utilizaremos actores en forma de objetos con devoluciones de llamada, y dejaremos las rutinas para el enfoque CSP. <br><br><h2>  Esquema de decisi√≥n basado en el modelo de actores </h2><br>  Seg√∫n los actores, el esquema general para resolver nuestro problema se ver√° as√≠: <br><table border="1"><tbody><tr><td><img src="https://habrastorage.org/webt/di/f7/pn/dif7pngijjde8aizja_skqy58oo.jpeg"></td></tr></tbody></table><br>  Tendremos actores que se crean al comienzo del servidor HTTP y existen todo el tiempo mientras el servidor HTTP est√° funcionando.  Estos son actores como: HttpSrv, UserChecker, ImageDownloader, ImageMixer. <br><br>  Al recibir una nueva solicitud HTTP entrante, creamos una nueva instancia del actor RequestHandler, que se destruir√° despu√©s de emitir una respuesta a la solicitud HTTP entrante. <br><br><h2>  RequestHandler Actor Code </h2><br>  La implementaci√≥n del actor request_handler, que coordina el procesamiento de una solicitud HTTP entrante, puede verse as√≠: <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request_handler</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> some_basic_type { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> execution_context context_; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> request request_; optional&lt;user_info&gt; user_info_; optional&lt;image_loaded&gt; image_; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_user_info</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user_info info)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_image_loaded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image_loaded image)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_mixed_image</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mixed_image image)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_mix_images_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; ... <span class="hljs-comment"><span class="hljs-comment">//     . }; void request_handler::on_start() { send(context_.user_checker(), check_user{request_.user_id(), self()}); send(context_.image_downloader(), download_image{request_.image_id(), self()}); } void request_handler::on_user_info(user_info info) { user_info_ = std::move(info); if(image_) send_mix_images_request(); } void request_handler::on_image_loaded(image_loaded image) { image_ = std::move(image); if(user_info_) send_mix_images_request(); } void request_handler::send_mix_images_request() { send(context_.image_mixer(), mix_images{user_info-&gt;watermark_image(), *image_, self()}); } void request_handler::on_mixed_image(mixed_image image) { send(context_.http_srv(), reply{..., std::move(image), ...}); }</span></span></code> </pre> <br>  Analicemos este c√≥digo. <br><br>  Tenemos una clase en los atributos de los cuales almacenamos o vamos a almacenar lo que necesitamos para procesar la solicitud.  Tambi√©n en esta clase hay un conjunto de devoluciones de llamada que se llamar√°n en un momento u otro. <br><br>  Primero, cuando se acaba de crear un actor, se llama a la devoluci√≥n de llamada on_start ().  En √©l, enviamos dos mensajes a otros actores.  Primero, este es un mensaje check_user para verificar la ID del cliente.  En segundo lugar, este es un mensaje download_image para descargar la imagen original. <br><br>  En cada uno de los mensajes enviados, pasamos un enlace a nosotros mismos (una llamada al m√©todo self () devuelve un enlace al actor para el que se llam√≥ self ()).  Esto es necesario para que nuestro actor pueda enviar un mensaje en respuesta.  Si no enviamos un enlace a nuestro actor, por ejemplo, en el mensaje check_user, el actor UserChecker no sabr√° a qui√©n enviar la informaci√≥n del usuario. <br><br>  Cuando se nos env√≠a un mensaje user_info con informaci√≥n del usuario en respuesta, se llama a la devoluci√≥n de llamada on_user_info ().  Y cuando se nos env√≠a el mensaje image_loaded, la devoluci√≥n de llamada on_image_loaded () se llama a nuestro actor.  Y ahora, dentro de estas dos devoluciones de llamada, vemos una caracter√≠stica inherente al Modelo de actores: no sabemos exactamente en qu√© orden recibiremos los mensajes de respuesta.  Por lo tanto, debemos escribir nuestro c√≥digo para que no dependa del orden en que llegan los mensajes.  Por lo tanto, en cada uno de los procesadores, primero almacenamos la informaci√≥n recibida en el atributo correspondiente y luego verificamos si ya hemos recopilado toda la informaci√≥n que necesitamos.  Si es as√≠, entonces podemos seguir adelante.  Si no, entonces esperaremos m√°s. <br><br>  Es por eso que tenemos complementos en on_user_info () y on_image_loaded () si se llama a send_mix_images_request (). <br><br><blockquote>  En principio, en las implementaciones del Modelo de actores puede haber mecanismos como la recepci√≥n selectiva de Erlang o el escondite de Akka, a trav√©s del cual puede manipular el orden de procesamiento de los mensajes entrantes, pero no hablaremos de esto hoy, para no profundizar en la jungla de detalles de diversas implementaciones del Modelo Actores </blockquote><br>  Entonces, si se recibe toda la informaci√≥n que necesitamos de UserChecker e ImageDownloader, se llama al m√©todo send_mix_images_request (), en el que se env√≠a el mensaje mix_images al actor ImageMixer.  La devoluci√≥n de llamada on_mixed_image () se llama cuando recibimos un mensaje de respuesta con la imagen resultante.  Aqu√≠ enviamos esta imagen al actor HttpSrv y esperamos hasta que HttpSrv forme una respuesta HTTP y destruya el RequestHandler que se ha vuelto innecesario (aunque, en principio, nada impide que el actor RequestHandler se autodestruya en la devoluci√≥n de llamada on_mixed_image ()). <br><br>  Eso es todo <br><br>  La implementaci√≥n del actor RequestHandler result√≥ ser bastante voluminosa.  Pero esto se debe al hecho de que necesit√°bamos describir una clase con atributos y devoluciones de llamada, y luego tambi√©n implementar devoluciones de llamada.  Pero la l√≥gica del trabajo de RequestHandler es muy trivial, y comprenderlo, a pesar de la cantidad de c√≥digo en la clase request_handler, es f√°cil. <br><br><h2>  Caracter√≠sticas inherentes a los actores. </h2><br>  Ahora podemos decir algunas palabras sobre las caracter√≠sticas del Modelo de actores. <br><br><h3>  Reactores </h3><br>  Como regla general, los actores solo responden a los mensajes entrantes.  Hay mensajes: el actor los procesa.  Sin mensajes: el actor no hace nada. <br><br>  Esto es especialmente cierto para aquellas implementaciones del Modelo de actores en el que los actores se representan como objetos con devoluciones de llamada.  El marco tira la devoluci√≥n de llamada del actor y si el actor no devuelve el control de la devoluci√≥n de llamada, el marco no puede servir a otros actores en el mismo contexto. <br><br><h3>  Los actores est√°n sobrecargados </h3><br>  En el caso de los actores, podemos hacer que actor-productor genere mensajes para el consumidor-actor a un ritmo mucho m√°s r√°pido de lo que el actor-consumidor podr√° procesar. <br><br>  Esto conducir√° al hecho de que la cola de mensajes entrantes para el actor-consumidor crecer√° constantemente.  Crecimiento de la cola, es decir  El mayor consumo de memoria en la aplicaci√≥n reducir√° la velocidad de la aplicaci√≥n.  Esto conducir√° a un crecimiento a√∫n m√°s r√°pido de la cola y, como resultado, la aplicaci√≥n puede degradarse para completar la inoperancia. <br><br>  Todo esto es una consecuencia directa de la interacci√≥n asincr√≥nica de los actores.  Debido a que la operaci√≥n de env√≠o generalmente no es de bloqueo.  Y bloquearlo no es f√°cil, porque  Un actor puede enviarse a s√≠ mismo.  Y si la cola para el actor est√° llena, entonces, en el env√≠o a s√≠ mismo, el actor ser√° bloqueado y esto detendr√° su trabajo. <br><br>  Entonces, cuando se trabaja con actores, se debe prestar mucha atenci√≥n al problema de la sobrecarga. <br><br><h3>  Muchos actores no siempre son la soluci√≥n. </h3><br>  Como regla general, los actores son entidades ligeras y existe la tentaci√≥n de crearlos en su aplicaci√≥n en grandes cantidades.  Puedes crear diez mil actores, cien mil y un mill√≥n.  E incluso cien millones de actores, si el hierro te lo permite. <br><br>  Pero el problema es que el comportamiento de un gran n√∫mero de actores es dif√≠cil de rastrear.  Es decir  Es posible que tenga algunos actores que claramente funcionan correctamente.  Algunos actores que obviamente trabajan incorrectamente o no trabajan en absoluto, y usted lo sabe con certeza.  Pero puede haber una gran cantidad de actores de los que no sabes nada: ¬øfuncionan en absoluto, funcionan de manera correcta o incorrecta?  Y todo porque cuando tienes cien millones de entidades aut√≥nomas con tu propia l√≥gica de comportamiento en tu programa, entonces monitorear esto es muy dif√≠cil para todos. <br><br>  Por lo tanto, puede resultar que cuando creamos una gran cantidad de actores en la aplicaci√≥n, no resolvemos nuestro problema aplicado, sino que obtenemos otro problema.  Y, por lo tanto, puede ser beneficioso para nosotros abandonar actores simples que resuelven una sola tarea, a favor de actores m√°s complejos y pesados ‚Äã‚Äãque realizan varias tareas.  Pero entonces habr√° menos actores "pesados" en la aplicaci√≥n y ser√° m√°s f√°cil para nosotros seguirlos. <br><br><h2>  ¬øD√≥nde mirar, qu√© llevar? </h2><br>  Si alguien quiere intentar trabajar con actores en C ++, entonces no tiene sentido construir sus propias bicicletas, hay varias soluciones preparadas, en particular: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SObjectizer</a> (¬°ayuda al fabricante nacional!) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C ++ Actor Framework (CAF)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">QP / C ++</a> </li></ul><br>  Estas tres opciones son animadas, evolutivas, multiplataforma, documentadas.  Tambi√©n puedes probarlos gratis.  Adem√°s, se pueden encontrar varias opciones m√°s de diversos grados de [no] frescura <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en la lista de Wikipedia</a> . <br><br>  SObjectizer y CAF est√°n dise√±ados para su uso en tareas de alto nivel donde se pueden aplicar excepciones y memoria din√°mica.  Y el marco QP / C ++ puede ser de inter√©s para aquellos involucrados en el desarrollo integrado, como  Es bajo este nicho donde est√° "encarcelado". <br><br><h1>  Enfoque n. ¬∞ 2: CSP (comunicaci√≥n de procesos secuenciales) </h1><br><h2>  CSP en dedos y sin matan </h2><br>  El modelo CSP es muy similar al modelo de actores.  Tambi√©n construimos nuestra soluci√≥n a partir de un conjunto de entidades aut√≥nomas, cada una de las cuales tiene su propio estado privado e interact√∫a con otras entidades solo a trav√©s de mensajes asincr√≥nicos. <br><br>  Solo estas entidades en el modelo CSP se denominan "procesos". <br><br>  Los procesos en CSP son ligeros, sin ninguna paralelizaci√≥n de su trabajo en el interior.  Si necesitamos paralelizar algo, entonces simplemente iniciamos varios procesos CSP, dentro de los cuales ya no hay paralelizaci√≥n. <br><br>  Los procesos CSP interact√∫an entre s√≠ a trav√©s de mensajes asincr√≥nicos, pero los mensajes no se env√≠an a los buzones, como en el Modelo de actores, sino a los canales.  Los canales pueden considerarse colas de mensajes, generalmente de un tama√±o fijo. <br><br>  A diferencia del Modelo de actores, donde se crea autom√°ticamente un buz√≥n para cada actor, los canales en el CSP deben crearse expl√≠citamente.  Y si necesitamos que los dos procesos interact√∫en entre s√≠, entonces debemos crear el canal nosotros mismos, y luego decirle al primer proceso "escribir√°s aqu√≠", y el segundo proceso deber√≠a decir: "leer√°s aqu√≠ desde aqu√≠". <br><br>  Al mismo tiempo, los canales tienen al menos dos operaciones que deben llamarse expl√≠citamente.  La primera es la operaci√≥n de escritura (env√≠o) para escribir un mensaje en el canal. <br><br>  En segundo lugar, es una operaci√≥n de lectura (recepci√≥n) leer un mensaje de un canal.  Y la necesidad de llamar expl√≠citamente a leer / recibir distingue a CSP del Modelo de actores, porque  en el caso de los actores, la operaci√≥n de lectura / recepci√≥n generalmente se puede ocultar al actor.  Es decir  Actor Framework puede recuperar mensajes de la cola del actor y llamar a un controlador (devoluci√≥n de llamada) para el mensaje recuperado. <br><br>  Mientras que el proceso CSP en s√≠ mismo debe elegir el momento para la llamada de lectura / recepci√≥n, entonces el proceso CSP debe determinar qu√© mensaje recibi√≥ y procesar el mensaje extra√≠do. <br><br>  Dentro de nuestra aplicaci√≥n "grande", los procesos CSP se pueden implementar de diferentes maneras: <br><br><ul><li>  El proceso CSP-shny se puede implementar como un sistema operativo de hilo separado.  Resulta una soluci√≥n costosa, pero con multitarea preventiva; </li><li>  El proceso de CSP puede implementarse mediante corutina (rutina de pila, fibra, hilo verde, ...).  Es mucho m√°s barato, pero la multitarea solo es cooperativa. </li></ul><br>  Adem√°s, suponemos que los procesos de CSP se presentan en forma de rutinas apiladas (aunque el c√≥digo que se muestra a continuaci√≥n puede implementarse en subprocesos del sistema operativo). <br><br><h2>  Diagrama de soluciones basadas en CSP </h2><br>  El esquema de soluci√≥n basado en el modelo CSP se parecer√° mucho a un esquema similar para el Modelo de actores (y esto no es accidental): <br><table border="1"><tbody><tr><td><img src="https://habrastorage.org/webt/96/oy/uu/96oyuu6mwhj4ot6fqpsiiv-f1h8.jpeg"></td></tr></tbody></table><br>  Tambi√©n habr√° entidades que se inicien cuando el servidor HTTP se inicie y trabaje todo el tiempo: estos son los procesos CSP HttpSrv, UserChecker, ImageDownloader e ImageMixer.  Para cada nueva solicitud entrante, se crear√° un nuevo proceso CSP RequestHandler.  Este proceso env√≠a y recibe los mismos mensajes que cuando se usa el Modelo de actores. <br><br><h2>  RequestHandler CSP Process Code </h2><br>  Esto puede parecerse al c√≥digo de una funci√≥n que implementa el proceso t√≠mido CSP de RequestHandler: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> execution_context ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request req)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user_info_ch = make_chain&lt;user_info&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> image_loaded_ch = make_chain&lt;image_loaded&gt;(); ctx.user_checker_ch().write(check_user{req.user_id(), user_info_ch}); ctx.image_downloader_ch().write(download_image{req.image_id(), image_loaded_ch}); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user = user_info_ch.read(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> original_image = image_loaded_ch.read(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> image_mix_ch = make_chain&lt;mixed_image&gt;(); ctx.image_mixer_ch().write( mix_image{user.watermark_image(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(original_image), image_mix_ch}); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result_image = image_mix_ch.read(); ctx.http_srv_ch().write(reply{..., <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(result_image), ...}); }</code> </pre> <br>  Aqu√≠ todo es bastante trivial y repite regularmente el mismo patr√≥n: <br><br><ul><li>  Primero, creamos un canal para recibir mensajes de respuesta.  Esto es necesario porque  El proceso CSP no tiene su propio buz√≥n predeterminado, como los actores.  Por lo tanto, si el proceso CSP-shny quiere recibir algo, entonces deber√≠a estar desconcertado por la creaci√≥n del canal donde se escribir√° este "algo"; </li><li>  luego enviamos nuestro mensaje al proceso maestro CSP.  Y en este mensaje indicamos el canal para el mensaje de respuesta; </li><li>  luego realizamos la operaci√≥n de lectura desde el canal donde se nos debe enviar un mensaje de respuesta. </li></ul><br>  Esto se ve muy claramente en el ejemplo de comunicaci√≥n con el proceso de ImageSPixer CSP: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> image_mix_ch = make_chain&lt;mixed_image&gt;(); <span class="hljs-comment"><span class="hljs-comment">//  . ctx.image_mixer_ch().write( //  . mix_image{..., image_mix_ch}); //     . auto result_image = image_mix_ch.read(); //  .</span></span></code> </pre> <br>  Pero por separado vale la pena centrarse en este fragmento: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user = user_info_ch.read(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> original_image = image_loaded_ch.read();</code> </pre> <br>  Aqu√≠ vemos otra gran diferencia con el Modelo de actores.  En el caso de CSP, podemos recibir mensajes de respuesta en el orden que m√°s nos convenga. <br><br>  ¬øQuieres esperar a user_info primero?  No hay problema, vaya a dormir en lectura hasta que aparezca user_info.  Si ya se nos ha enviado image_loaded en este momento, simplemente esperar√° en su canal hasta que lo leamos. <br><br>  Eso, de hecho, es todo lo que puede acompa√±ar al c√≥digo que se muestra arriba.  El c√≥digo basado en CSP era m√°s compacto que su hom√≥logo basado en actores.  Lo cual no es sorprendente ya que  aqu√≠ no tuvimos que describir una clase separada con m√©todos de devoluci√≥n de llamada.  Y parte del estado de nuestro proceso t√≠mido CSP RequestHandler est√° presente impl√≠citamente en forma de argumentos ctx y req. <br><br><h2>  Caracter√≠sticas de CSP </h2><br><h3>  Reactividad y proactividad de procesos CSP </h3><br>  A diferencia de los actores, los procesos de CSP pueden ser reactivos, proactivos o ambos.  Digamos que el proceso CSP verific√≥ sus mensajes entrantes; si hubo alguno, los proces√≥.  Y luego, al ver que no hab√≠a mensajes entrantes, se comprometi√≥ a multiplicar las matrices. <br><br>  Despu√©s de un tiempo, el proceso CSP de la matriz estaba cansado de multiplicarse, y una vez m√°s verific√≥ los mensajes entrantes.  No hay nuevos?  Bueno, ok, multipliquemos las matrices a√∫n m√°s. <br><br>  Y esta capacidad de los procesos de CSP para hacer un trabajo incluso en ausencia de mensajes entrantes hace que el modelo de CSP sea muy diferente del modelo de actores. <br><br><h3>  Mecanismos de protecci√≥n de sobrecarga nativos </h3><br>  Dado que, como regla, los canales son colas de mensajes de un tama√±o limitado y un intento de escribir un mensaje en un canal lleno detiene al remitente, entonces en CSP tenemos un mecanismo incorporado de protecci√≥n contra sobrecarga. <br><br>  De hecho, si tenemos un proceso de producci√≥n √°gil y un proceso de consumo lento, entonces el proceso de producci√≥n llenar√° r√°pidamente el canal y se suspender√° para la pr√≥xima operaci√≥n de env√≠o.  Y el proceso del productor se suspender√° hasta que el proceso del consumidor libere espacio en el canal para nuevos mensajes.  Tan pronto como aparece el lugar, el proceso del productor se despierta y arroja nuevos mensajes al canal. <br><br>  Por lo tanto, cuando usamos CSP, podemos preocuparnos menos por el problema de la sobrecarga que en el caso del Modelo de Actores.  Es cierto, aqu√≠ hay una trampa, de la que hablaremos un poco m√°s adelante. <br><br><h3>  ¬øC√≥mo se implementan los procesos CSP? </h3><br>  Debemos decidir c√≥mo se implementar√°n nuestros procesos CSP. <br><br>  Se puede hacer para que cada proceso de CSP-shny est√© representado por un hilo separado del sistema operativo.  Resulta una soluci√≥n costosa y no escalable.  Pero, por otro lado, obtenemos la multitarea preventiva: si nuestro proceso CSP comienza a multiplicar matrices o hace alg√∫n tipo de llamada de bloqueo, el sistema operativo eventualmente lo expulsar√° del n√∫cleo computacional y har√° posible que otros procesos CSP funcionen. <br><br>  Es posible hacer que cada proceso de CSP est√© representado por una corutina (rutina de pila).  Esta es una soluci√≥n mucho m√°s barata y escalable.  Pero aqu√≠ solo tendremos multitarea cooperativa.  Por lo tanto, si de repente el proceso CSP toma la multiplicaci√≥n de la matriz, el hilo de trabajo con este proceso CSP y otros procesos CSP que est√°n unidos a √©l se bloquear√°. <br><br>  Puede haber otro truco.  Supongamos que usamos una biblioteca de terceros, en cuyo interior no podemos influir.  Y dentro de la biblioteca, se utilizan variables TLS (es decir, almacenamiento local de subprocesos).  Hacemos una llamada a la funci√≥n de biblioteca y la biblioteca establece el valor de alguna variable TLS.  Entonces nuestra rutina "se mueve" a otro hilo de trabajo, y esto es posible, porque  en principio, las corutinas pueden migrar de un hilo de trabajo a otro.  Realizamos la siguiente llamada a la funci√≥n de biblioteca y la biblioteca intenta leer el valor de la variable TLS.  ¬°Pero puede que ya haya un significado diferente!  Y buscar ese error ser√° muy dif√≠cil. <br><br>  Por lo tanto, debe considerar cuidadosamente la elecci√≥n del m√©todo para implementar procesos CSP-shnyh.  Cada una de las opciones tiene sus propias fortalezas y debilidades. <br><br><h3>  Muchos procesos no siempre son la soluci√≥n. </h3><br>  Al igual que con los actores, la capacidad de crear muchos procesos CSP en su programa no siempre es una soluci√≥n a un problema aplicado, sino que crea problemas adicionales para usted. <br><br>  Adem√°s, la poca visibilidad de lo que sucede dentro del programa es solo una parte del problema.  Me gustar√≠a centrarme en otra trampa. <br><br>  El hecho es que en los canales CSP-shnyh puedes obtener f√°cilmente un an√°logo de punto muerto.  El proceso A intenta escribir un mensaje en el canal C1 completo y el proceso A se detiene.  Desde el canal C1, se debe leer el proceso B, que intent√≥ escribir en el canal C2, que est√° lleno, y, por lo tanto, se suspendi√≥ el proceso B.  Y desde el canal C2, el proceso A era leer. Eso es todo, tenemos un punto muerto. <br><br>  Si solo tenemos dos procesos CSP, entonces podemos encontrar ese punto muerto durante la depuraci√≥n o incluso con el procedimiento de revisi√≥n del c√≥digo.  Pero si tenemos millones de procesos en el programa, se comunican activamente entre ellos, entonces la probabilidad de tales puntos muertos aumenta significativamente. <br><br><h2>  ¬øD√≥nde mirar, qu√© llevar? </h2><br>  Si alguien quiere trabajar con CSP en C ++, entonces la elecci√≥n aqu√≠, desafortunadamente, no es tan grande como para los actores.  Bueno, o no s√© d√≥nde mirar y c√≥mo mirar.  En este caso, espero que los comentarios compartan otros enlaces. <br><br>  Pero, si queremos usar CSP, primero debemos mirar hacia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Boost.Fiber</a> .  Hay fibra (es decir, corutinas) y canales, e incluso primitivas de bajo nivel como mutex, condici√≥n_variable, barrera.  Todo esto puede ser tomado y usado. <br><br>  Si est√° satisfecho con los procesos CSP en forma de subprocesos, puede consultar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SObjectizer</a> .  Tambi√©n hay an√°logos de canales CSP y se pueden escribir complejas aplicaciones multiproceso en SObjectizer sin ning√∫n actor. <br><br><h1>  Actores vs CSP </h1><br>  Los actores y los CSP son muy similares entre s√≠.  Repetidamente me encontr√© con la afirmaci√≥n de que estos dos modelos son equivalentes entre s√≠.  Es decir  lo que se puede hacer con los actores puede repetirse casi 1 en 1 en los procesos de CSP y viceversa.  Dicen que incluso se demuestra matem√°ticamente.  Pero aqu√≠ no entiendo nada, as√≠ que no puedo decir nada.  Pero desde mis propios pensamientos en alg√∫n lugar al nivel del sentido com√∫n cotidiano, todo esto parece bastante plausible.  En algunos casos, de hecho, los actores pueden ser reemplazados por procesos CSP, y los procesos CSP por actores. <br><br>  Sin embargo, existen varias diferencias entre los actores y los CSP que pueden ayudar a determinar d√≥nde cada uno de estos modelos es beneficioso o desventajoso. <br><br><h2>  Canales vs buz√≥n </h2><br>  Un actor tiene un solo "canal" para recibir mensajes entrantes: este es su buz√≥n, que se crea autom√°ticamente para cada actor.  Y el actor recupera los mensajes de all√≠ secuencialmente, exactamente en el orden en que estaban en el buz√≥n. <br><br>  Y esta es una pregunta bastante seria.  Digamos que hay tres mensajes en el buz√≥n del actor: M1, M2 y M3.  El actor actualmente solo est√° interesado en M3.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero antes de llegar a M3, el actor primero extraer√° M1, luego M2. </font><font style="vertical-align: inherit;">¬øY qu√© har√° √©l con ellos?</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nuevamente, como parte de esta conversaci√≥n, no tocaremos los mecanismos de recepci√≥n selectiva de Erlang y el escondite de Akka. </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mientras que el proceso CSP-shny tiene la capacidad de seleccionar el canal del que actualmente quiere leer los mensajes. </font><font style="vertical-align: inherit;">Por lo tanto, un proceso CSP puede tener tres canales: C1, C2 y C3. </font><font style="vertical-align: inherit;">Actualmente, el proceso CSP solo est√° interesado en los mensajes de C3. </font><font style="vertical-align: inherit;">Es este canal el que lee el proceso. </font><font style="vertical-align: inherit;">Y volver√° a los contenidos de los canales C1 y C2 cuando est√© interesado en esto.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reactividad y proactividad </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como regla general, los actores son reactivos y solo funcionan cuando tienen mensajes entrantes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mientras que los procesos CSP pueden hacer algo de trabajo incluso en ausencia de mensajes entrantes. </font><font style="vertical-align: inherit;">En algunos escenarios, esta diferencia puede jugar un papel importante.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> M√°quinas de estado </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De hecho, los actores son m√°quinas de estado finito (KA). </font><font style="vertical-align: inherit;">Por lo tanto, si hay muchas m√°quinas de estado finito en su √°rea tem√°tica, e incluso si se trata de m√°quinas de estado finito jer√°rquicas complejas, puede ser mucho m√°s f√°cil implementarlas seg√∫n el modelo de actor que agregar una implementaci√≥n de nave espacial a un proceso CSP.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En C ++, todav√≠a no hay soporte nativo de CSP. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La experiencia del lenguaje Go muestra cu√°n f√°cil y conveniente es usar el modelo CSP cuando su soporte se implementa a nivel de un lenguaje de programaci√≥n y su biblioteca est√°ndar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En Go, es f√°cil crear "procesos CSP" (tambi√©n conocidos como gorutinas), es f√°cil crear y trabajar con canales, hay una sintaxis incorporada para trabajar con varios canales a la vez (Go-shny select, que funciona no solo para leer sino tambi√©n para escribir), la biblioteca est√°ndar sabe sobre goroutins y puede cambiarlos cuando goroutin realiza una llamada de bloqueo desde stdlib. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En C ++, hasta ahora no hay soporte para las rutinas apiladas (a nivel de lenguaje). </font><font style="vertical-align: inherit;">Por lo tanto, trabajar con CSP en C ++ puede parecer, en algunos lugares, si no una muleta, entonces ... Eso ciertamente requiere mucha m√°s atenci√≥n para s√≠ mismo que en el caso del mismo Go.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enfoque n. ¬∞ 3: Tareas (as√≠ncrono, futuro, esperar_todos, ...) </font></font></h1><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Acerca del enfoque basado en tareas en las palabras m√°s comunes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El significado del enfoque basado en tareas es que si tenemos una operaci√≥n compleja, dividimos esta operaci√≥n en pasos de tarea separados, donde cada tarea (es una tarea) realiza una sola sub-operaci√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comenzamos estas tareas con la operaci√≥n especial as√≠ncrona. </font><font style="vertical-align: inherit;">La operaci√≥n as√≠ncrona devuelve un objeto futuro en el que, una vez completada la tarea, se colocar√° el valor devuelto por la tarea. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de que lanzamos N tareas y recibimos N objetos en el futuro, necesitamos de alguna manera unir todo esto en una cadena. </font><font style="vertical-align: inherit;">Parece que cuando se completan las tareas No. 1 y No. 2, los valores devueltos por ellos deben caer en la tarea No. 3. </font><font style="vertical-align: inherit;">Y cuando se completa la tarea No. 3, el valor devuelto debe transferirse a las tareas No. 4, No. 5 y No. 6. </font><font style="vertical-align: inherit;">Etc., etc.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para tal "empate", se utilizan medios especiales. </font><font style="vertical-align: inherit;">Como, por ejemplo, el m√©todo .then () de un objeto futuro, as√≠ como las funciones wait_all (), wait_any (). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tal explicaci√≥n "en los dedos" puede no ser muy clara, as√≠ que pasemos al c√≥digo. </font><font style="vertical-align: inherit;">Tal vez en una conversaci√≥n sobre un c√≥digo espec√≠fico la situaci√≥n se aclare (pero no es un hecho).</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C√≥digo de request_handler para el enfoque basado en tareas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El c√≥digo para procesar una solicitud HTTP entrante basada en tareas puede verse as√≠: </font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> execution_context &amp; ctx, request req)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user_info_ft = async(ctx.http_client_ctx(), [req] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retrieve_user_info(req.user_id()); }); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> original_image_ft = async(ctx.http_client_ctx(), [req] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> download_image(req.image_id()); }); when_all(user_info_ft, original_image_ft).then( [&amp;ctx, req](tuple&lt;future&lt;user_info&gt;, future&lt;image_loaded&gt;&gt; data) { async(ctx.image_mixer_ctx(), [&amp;ctx, req, d=<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(data)] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mix_image(get&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(d).get().watermark_image(), get&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(d).get()); }) .then([req](future&lt;mixed_image&gt; mixed) { async(ctx.http_srv_ctx(), [req, im=<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(mixed)] { make_reply(...); }); }); }); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tratemos de descubrir qu√© est√° pasando aqu√≠. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primero, creamos una tarea que debe iniciarse en el contexto de nuestro propio cliente HTTP y que solicita informaci√≥n sobre el usuario. El objeto futuro devuelto se almacena en la variable user_info_ft. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A continuaci√≥n, creamos una tarea similar, que tambi√©n deber√≠a ejecutarse en el contexto de nuestro propio cliente HTTP y que carga la imagen original. El objeto futuro devuelto se almacena en la variable original_image_ft.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A continuaci√≥n, debemos esperar a que se completen las dos primeras tareas. </font><font style="vertical-align: inherit;">Lo que escribimos directamente: when_all (user_info_ft, original_image_ft). </font><font style="vertical-align: inherit;">Cuando ambos objetos futuros obtengan sus valores, ejecutaremos otra tarea. </font><font style="vertical-align: inherit;">Esta tarea tomar√° el mapa de bits con la marca de agua y la imagen original y ejecutar√° otra tarea en el contexto de ImageMixer. </font><font style="vertical-align: inherit;">Esta tarea mezclar√° im√°genes y cuando se complete, se iniciar√° otra tarea en el contexto del servidor HTTP, lo que generar√° una respuesta HTTP. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quiz√°s tal explicaci√≥n de lo que est√° sucediendo en el c√≥digo no est√° muy aclarada. </font><font style="vertical-align: inherit;">Por lo tanto, enumeremos nuestras tareas:</font></font><br><table><tbody><tr><td><img src="https://habrastorage.org/webt/5k/c0/mr/5kc0mrvqnxdf6lp4-p0wgn1nj7w.jpeg"></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y veamos las dependencias entre ellos (de donde fluye el orden de las tareas): </font></font><br><table><tbody><tr><td><img src="https://habrastorage.org/webt/zu/j4/g4/zuj4g4wwg0wxmhazj5k5rdb8pgu.jpeg"></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y si ahora superponemos esta imagen en nuestro c√≥digo fuente, entonces espero que se aclare: </font></font><br><table><tbody><tr><td><img src="https://habrastorage.org/webt/sw/at/uz/swatuzio1z33-ei16gquj-ss5mg.jpeg"></td></tr></tbody></table><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Caracter√≠sticas del enfoque basado en tareas </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visibilidad </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La primera caracter√≠stica que ya deber√≠a ser obvia es la visibilidad del c√≥digo en la Tarea. </font><font style="vertical-align: inherit;">No todo est√° bien con ella. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ puedes mencionar el infierno de devoluci√≥n de llamada. </font><font style="vertical-align: inherit;">Los programadores de Node.js est√°n muy familiarizados con √©l. </font><font style="vertical-align: inherit;">Pero los apodos de C ++ que trabajan en estrecha colaboraci√≥n con Task tambi√©n se sumergen en este infierno de devoluci√≥n de llamadas.</font></font><br><br><h3>  Manejo de errores </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otra caracter√≠stica interesante es el manejo de errores. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por un lado, en el caso de usar as√≠ncrono y futuro con la entrega de informaci√≥n de error a la parte interesada, puede ser a√∫n m√°s f√°cil que en el caso de actores o CSP. </font><font style="vertical-align: inherit;">Despu√©s de todo, si en el proceso CSP A env√≠a una solicitud para procesar B y espera un mensaje de respuesta, entonces cuando B encuentra un error mientras ejecuta la solicitud, debemos decidir c√≥mo entregar el error para procesar A:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o haremos un tipo de mensaje separado y un canal para recibirlo; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o devolvemos el resultado con un solo mensaje, que ser√° std :: variant para un resultado normal y err√≥neo. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y en el caso del futuro, todo es m√°s simple: extraemos del futuro un resultado normal o se nos lanza una excepci√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero, por otro lado, podemos encontrarnos f√°cilmente con una cascada de errores. </font><font style="vertical-align: inherit;">Por ejemplo, una excepci√≥n ocurri√≥ en la tarea No. 1, esta excepci√≥n cay√≥ en el objeto futuro, que se pas√≥ a la tarea No. 2. </font><font style="vertical-align: inherit;">En la tarea No. 2, tratamos de tomar el valor del futuro, pero recibimos una excepci√≥n. </font><font style="vertical-align: inherit;">Y, muy probablemente, descartaremos la misma excepci√≥n. </font><font style="vertical-align: inherit;">En consecuencia, caer√° en el pr√≥ximo futuro, que ir√° a la tarea No. 3. </font><font style="vertical-align: inherit;">Tambi√©n habr√° una excepci√≥n, que, posiblemente, tambi√©n se lanzar√°.</font></font> Etc. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si se registran nuestras excepciones, entonces en el registro podemos ver la repetici√≥n repetida de la misma excepci√≥n, que va de una tarea en la cadena a otra tarea. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cancelar tareas y temporizadores / tiempos de espera </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y otra caracter√≠stica muy interesante de la campa√±a basada en tareas es la cancelaci√≥n de tareas si algo sale mal. </font><font style="vertical-align: inherit;">De hecho, digamos que creamos 150 tareas, completamos las 10 primeras y nos dimos cuenta de que no ten√≠a sentido continuar el trabajo. </font><font style="vertical-align: inherit;">¬øC√≥mo cancelamos los 140 restantes? </font><font style="vertical-align: inherit;">Esta es una muy, muy buena pregunta :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otra pregunta similar es c√≥mo hacer que los amigos realicen tareas con temporizadores y tiempos de espera. </font><font style="vertical-align: inherit;">Supongamos que estamos accediendo a un sistema externo y queremos limitar el tiempo de espera a 50 milisegundos. </font><font style="vertical-align: inherit;">¬øC√≥mo podemos configurar el temporizador, c√≥mo reaccionar al vencimiento del tiempo de espera, c√≥mo interrumpir la cadena de tareas si el tiempo de espera ha expirado? </font><font style="vertical-align: inherit;">Nuevamente, preguntar es m√°s f√°cil que responder :)</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hacer trampa </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bueno, y para hablar sobre las caracter√≠sticas del enfoque basado en tareas. </font><font style="vertical-align: inherit;">En el ejemplo que se muestra, se aplic√≥ un poco de trampa:</font></font><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user_info_ft = async(ctx.http_client_ctx(), [req] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retrieve_user_info(req.user_id()); }); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> original_image_ft = async(ctx.http_client_ctx(), [req] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> download_image(req.image_id()); });</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ envi√© dos tareas al contexto de nuestro propio servidor HTTP, cada una de las cuales realiza una operaci√≥n de bloqueo en su interior. </font><font style="vertical-align: inherit;">De hecho, para poder procesar dos solicitudes a servicios de terceros en paralelo, aqu√≠ ten√≠a que crear sus propias cadenas de tareas asincr√≥nicas. </font><font style="vertical-align: inherit;">Pero no hice esto para que la soluci√≥n sea m√°s o menos visible y se ajuste a la diapositiva de presentaci√≥n.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Actores / CSP vs Tareas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Examinamos tres enfoques y vimos que si los actores y los procesos de CSP son similares entre s√≠, entonces el enfoque basado en tareas no es como ninguno de ellos. Y podr√≠a parecer que los Actores / CSP deber√≠an contrastarse con la Tarea. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero personalmente, me gusta un punto de vista diferente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando hablamos del Modelo de Actores y CSP, estamos hablando de la descomposici√≥n de nuestra tarea. En nuestra tarea, seleccionamos entidades independientes separadas y describimos las interfaces de estas entidades: qu√© mensajes env√≠an, cu√°les reciben, a trav√©s de qu√© canales van los mensajes.</font></font><br><br>  Es decir<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trabajando con actores y CSP estamos hablando de interfaces. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero supongamos que dividimos la tarea en actores separados y procesos de CSP. ¬øC√≥mo hacen exactamente su trabajo? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando adoptamos el enfoque basado en tareas, comenzamos a hablar sobre la implementaci√≥n. Acerca de c√≥mo se realiza un trabajo espec√≠fico, qu√© operaciones secundarias se realizan, en qu√© orden, c√≥mo se conectan estas operaciones secundarias seg√∫n los datos, etc.</font></font><br><br>  Es decir<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trabajando con Task estamos hablando de implementaci√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, los actores / CSP y las tareas no son tan opuestos entre s√≠, sino que se complementan entre s√≠. </font><font style="vertical-align: inherit;">Los actores / CSP se pueden utilizar para descomponer tareas y definir interfaces entre componentes. </font><font style="vertical-align: inherit;">Y las tareas se pueden usar para implementar componentes espec√≠ficos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por ejemplo, cuando usamos Actor, tenemos una entidad como ImageMixer, que debe manipularse con im√°genes en el grupo de subprocesos. </font><font style="vertical-align: inherit;">En general, nada nos impide usar el actor ImageMixer para usar el enfoque basado en tareas.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬øD√≥nde mirar, qu√© llevar? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si desea trabajar con Tareas en C ++, puede mirar hacia la biblioteca est√°ndar del pr√≥ximo C ++ 20. Ya han agregado el m√©todo .then () al futuro, as√≠ como las funciones gratuitas wait_all () y wait_any. Ver </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cppreference para m√°s detalles</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n ya est√° lejos de una nueva </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">biblioteca async ++</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . En el que, en principio, hay todo lo que necesita, solo un poco con una salsa diferente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y hay una biblioteca </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PPL de Microsoft</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a√∫n m√°s antigua </font><font style="vertical-align: inherit;">. Lo que tambi√©n te da todo lo que necesitas, pero con tu propia salsa.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adici√≥n separada sobre la biblioteca Intel TBB. </font><font style="vertical-align: inherit;">No se mencion√≥ en la historia sobre el enfoque basado en tareas porque, en mi opini√≥n, los gr√°ficos de tareas de TBB ya son un enfoque de flujo de datos. </font><font style="vertical-align: inherit;">Y, si este informe contin√∫a, la conversaci√≥n sobre Intel TBB ciertamente vendr√°, pero en el contexto de la historia sobre el flujo de datos.</font></font></blockquote><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mas interesante </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recientemente aqu√≠, en Habr√©, hab√≠a un art√≠culo de Anton Polukhin: "Nos estamos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">preparando para C ++ 20. Coroutines TS usando un ejemplo real</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habla de combinar un enfoque basado en tareas con corutinas sin pila de C ++ 20. </font><font style="vertical-align: inherit;">Y result√≥ que el c√≥digo basado en la legibilidad de la tarea se acercaba a la legibilidad del c√≥digo en los procesos CSP. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces, si alguien est√° interesado en el enfoque basado en tareas, entonces tiene sentido leer este art√≠culo.</font></font><br><br><h1>  Conclusi√≥n </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bueno, es hora de pasar a los resultados, ya que no hay tantos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo principal que quiero decir es que en el mundo moderno es posible que necesites m√∫ltiples subprocesos solo si est√°s desarrollando alg√∫n tipo de marco o resolviendo alguna tarea espec√≠fica y de bajo nivel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y si est√° escribiendo c√≥digo de aplicaci√≥n, entonces casi no necesita hilos desnudos, primitivas de sincronizaci√≥n de bajo nivel o alg√∫n tipo de algoritmo sin bloqueo junto con contenedores sin bloqueo. </font><font style="vertical-align: inherit;">Durante mucho tiempo hay enfoques que han sido probados y han demostrado su eficacia:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> actores </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comunicar procesos secuenciales (CSP) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tareas (as√≠ncronas, promesas, futuros, ...) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> flujos de datos </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> programaci√≥n reactiva </font></font></li><li>  ... </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y lo m√°s importante, hay herramientas listas para usar en C ++. </font><font style="vertical-align: inherit;">No necesita realizar ning√∫n ciclo, puede tomarlo, probarlo y, si lo desea, ponerlo en funcionamiento. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tan simple: tomar, probar y poner en funcionamiento.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es430672/">https://habr.com/ru/post/es430672/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es430660/index.html">Cambiar a Androidx o una emocionante aventura de rake</a></li>
<li><a href="../es430662/index.html">Monitoreo de servidores de Windows en MS SQL puro y c√≥mo lo implement√© en secreto</a></li>
<li><a href="../es430664/index.html">El papel del l√≠der del equipo en el reclutamiento</a></li>
<li><a href="../es430666/index.html">C√≥mo evaluar el desempe√±o del equipo</a></li>
<li><a href="../es430670/index.html">Gesti√≥n de arreglos</a></li>
<li><a href="../es430674/index.html">La l√≥gica de construir horarios de trabajo universales</a></li>
<li><a href="../es430676/index.html">Antig√ºedades: shshshsh, sssssss, VOIP, BBS y otros amigos del m√≥dem</a></li>
<li><a href="../es430678/index.html">Prueba de diez dimmers con l√°mparas LED.</a></li>
<li><a href="../es430680/index.html">Escribir un procesador simple y un entorno para ello</a></li>
<li><a href="../es430682/index.html">Tres a√±os del proyecto de microsat√©lites lunares: etapas de crecimiento</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>