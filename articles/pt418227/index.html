<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👍🏽 🕦 👯 Curso MIT "Segurança de sistemas de computadores". Palestra 7: A Sandbox do Cliente Nativo, Parte 3 💅🏽 🧔🏻 🌼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instituto de Tecnologia de Massachusetts. Curso de Aula nº 6.858. "Segurança de sistemas de computador". Nikolai Zeldovich, James Mickens. 2014 ano 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Curso MIT "Segurança de sistemas de computadores". Palestra 7: A Sandbox do Cliente Nativo, Parte 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/418227/"><h3>  Instituto de Tecnologia de Massachusetts.  Curso de Aula nº 6.858.  "Segurança de sistemas de computador".  Nikolai Zeldovich, James Mickens.  2014 ano </h3><br>  Computer Systems Security é um curso sobre o desenvolvimento e implementação de sistemas de computador seguros.  As palestras abrangem modelos de ameaças, ataques que comprometem a segurança e técnicas de segurança baseadas em trabalhos científicos recentes.  Os tópicos incluem segurança do sistema operacional (SO), recursos, gerenciamento de fluxo de informações, segurança de idiomas, protocolos de rede, segurança de hardware e segurança de aplicativos da web. <br><br>  Palestra 1: “Introdução: modelos de ameaças” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 2: “Controle de ataques de hackers” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Aula 3: “Estouros de Buffer: Explorações e Proteção” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 4: “Separação de Privilégios” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 5: “De onde vêm os sistemas de segurança?” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> <br>  Palestra 6: “Oportunidades” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 7: “Sandbox do Cliente Nativo” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <a name="habracut"></a><br><br>  Há uma ressalva na regra <b>C4</b> .  Você não pode "pular" no final de um programa.  A última coisa para a qual você pode pular é a última instrução.  Portanto, essa regra garante que, quando o programa for executado no processo "mecanismo", não haverá discrepância. <br><br>  A regra <b>C5</b> diz que não pode haver instruções maiores que 32 bytes.  Consideramos uma certa versão dessa regra quando falamos sobre a multiplicidade de tamanhos de instruções para 32 bytes; caso contrário, você pode pular para o meio da instrução e criar um problema com a chamada do sistema, que pode "ocultar" lá. <br><br>  A regra <b>C6</b> declara que todas as instruções disponíveis podem ser desmontadas desde o início.  Portanto, isso garante que vejamos cada instrução e possamos verificar todas as instruções que são executadas quando o programa é executado. <br><br>  A regra <b>C7</b> afirma que todos os saltos diretos estão corretos.  Por exemplo, você pula diretamente para a parte da instrução em que o destino está indicado e, embora não seja um múltiplo de 32, ainda é a instrução correta à qual a desmontagem é aplicada da esquerda para a direita. <br><br><img src="https://habrastorage.org/webt/1-/3i/vl/1-3ivlo26n7llpnkbkvzgzm-tci.jpeg"><br><br>  <b>Público:</b> qual é a diferença entre <b>C5</b> e <b>C3</b> ? <br><br>  <b>Professor:</b> Eu acho que o <b>C5</b> diz que se eu tiver uma instrução de vários bytes, ela não poderá atravessar as fronteiras dos endereços adjacentes.  Suponha que eu tenha um fluxo de instruções e que haja um endereço 32 e um endereço 64. Portanto, uma instrução não pode cruzar a borda múltipla de 32 bytes, ou seja, não deve começar com um endereço menor que 64 e terminar com um endereço maior que 64. <br><br><img src="https://habrastorage.org/webt/di/oc/l5/diocl5ztxk3kmc1ol0mmm_badik.jpeg"><br><br>  É isso que a regra <b>C5</b> diz.  Porque, caso contrário, tendo saltado a multiplicidade 32, você pode entrar no meio de outra instrução em que não se sabe o que está acontecendo. <br><br>  E a regra <b>C3</b> é um análogo dessa proibição ao lado do salto.  Ele afirma que sempre que você pula, o comprimento do seu pulo deve ser um múltiplo de 32. <br><br>  <b>C5</b> também afirma que qualquer coisa no intervalo de endereços que seja múltiplo de 32 é uma instrução segura. <br><br>  Depois de ler a lista dessas regras, tive um sentimento misto, pois não conseguia avaliar se essas regras são suficientes, ou seja, a lista é mínima ou completa. <br>  Então, vamos pensar na lição de casa que você precisa concluir.  Eu acho que, de fato, há um erro na operação do <b>Native Client</b> ao executar algumas instruções complicadas na sandbox.  Acredito que eles não tinham o código de tamanho correto, o que poderia levar a algo ruim, mas não me lembro exatamente qual foi o erro. <br><br>  Suponha que um validador de sandbox receba incorretamente o comprimento de algum tipo de instrução.  Que mal pode acontecer neste caso?  Como você usaria esse deslize? <br><br>  <b>Público-alvo:</b> por exemplo, você pode ocultar a chamada do sistema ou a declaração de retorno <b>ret</b> . <br><br>  <b>Professor:</b> sim.  Suponha que exista alguma versão sofisticada da instrução <b>AND</b> que você anotou.  É possível que o validador tenha se enganado e considerado que seu comprimento é de 6 bytes com o comprimento real de 5 bytes. <br><br><img src="https://habrastorage.org/webt/2z/ak/mg/2zakmgsficxcsi5tqkqnb-r_tj4.jpeg"><br><br>  O que vai acontecer?  O validador considera o comprimento desta instrução em 6 bytes e possui outra instrução válida por trás.  Mas o processador, ao iniciar o código, usa o comprimento real da instrução, ou seja, 5 bytes.  Como resultado, temos um byte livre no final da instrução <b>AND</b> , onde podemos inserir uma chamada do sistema e usá-la em nosso benefício.  E se inserirmos um <b>CD</b> byte aqui, será como o início de outra instrução.  Em seguida, colocaremos algo no próximo intervalo de 6 bytes, e será como uma instrução que começa com o byte do <b>CD</b> , embora na verdade faça parte da instrução <b>AND</b> .  Depois disso, podemos fazer uma chamada do sistema e "escapar" da caixa de areia. <br><br>  Assim, o validador <b>Native Client</b> deve sincronizar suas ações com as ações da <b>CPU</b> , ou seja, "adivinhar" exatamente como o processador interpretará cada instrução.  E isso deve estar em todos os níveis do sandbox, o que é bastante difícil de implementar. <br><br>  De fato, existem outros erros interessantes no <b>Native Client</b> .  Uma delas é a limpeza incorreta do ambiente do processador ao saltar para o <b>Trusted Service Runtime</b> .  Acho que falaremos sobre isso em um segundo.  Mas o <b>Trusted Service Runtime</b> funcionará basicamente com o mesmo conjunto de registradores de <b>CPU</b> projetados para executar módulos não confiáveis.  Portanto, se o processador esquecer de limpar alguma coisa ou reiniciar, o tempo de execução pode ser enganado, considerando o módulo não confiável como um aplicativo confiável e fazendo algo que não deveria ter sido feito ou que não era a intenção dos desenvolvedores. <br><br>  Então, onde estamos agora?  No momento, entendemos como desmontar todas as instruções e como impedir a execução de instruções proibidas.  Agora vamos ver como armazenamos memória e links para código e dados no módulo <b>Native Client</b> . <br><br>  Por motivos de desempenho, os <b>funcionários</b> do <b>Native Client</b> estão começando a usar o suporte de hardware para garantir que o armazenamento de memória e links não cause muita sobrecarga.  Mas antes de considerar o suporte de hardware que eles usam, quero ouvir sugestões, como eu poderia fazer o mesmo sem o suporte de hardware?  Podemos apenas fornecer acesso a todos os processos de memória dentro dos limites estabelecidos pela máquina anteriormente? <br><br>  <b>Público:</b> Você pode instruir instruções para limpar todos os bits altos. <br><br><img src="https://habrastorage.org/webt/h1/b7/yg/h1b7ygdlwrvvs7y7ywxitmabec8.jpeg"><br><br>  <b>Professor:</b> sim, está certo.  De fato, vemos que temos essa instrução <b>AND</b> aqui, e toda vez, por exemplo, pulamos em algum lugar, isso limpa os bits mais baixos.  Mas, se quisermos manter todo o código possível executado nos 256 MB baixos, podemos simplesmente substituir o primeiro atributo <b>f</b> por <b>0</b> e obter <b>$ 0x0fffffe0 em</b> vez de <b>$ 0xffffffe0</b> .  Isso limpa os bits baixos e define um limite superior de 256 MB. <br><br>  Assim, isso faz exatamente o que você oferece, certificando-se de que sempre que você pula, você está dentro de 256 MB.  E o fato de estarmos fazendo a desmontagem também permite verificar se todos os saltos diretos estão ao seu alcance. <br><br>  A razão pela qual eles não fazem isso por seu código é que, na plataforma <b>x86</b> , você pode codificar <b>AND de maneira</b> muito eficaz, onde todos os bits superiores são 1. Isso se transforma na existência de uma instrução de 3 bytes para <b>AND</b> e uma instrução de 2 bytes. para o salto.  Assim, temos uma despesa adicional de 3 bytes.  Mas se você precisar de um bit alto que não seja da unidade, como este <b>0 em</b> vez de <b>f</b> , de repente você terá uma instrução de 5 bytes.  Portanto, acho que, neste caso, eles estão preocupados com as despesas gerais. <br><br>  <b>Público:</b> Há algum problema com a existência de algumas instruções que incrementam a versão que você está tentando obter?  Ou seja, você pode dizer que sua instrução pode ter um viés constante ou algo assim? <br><br>  <b>Professor:</b> Eu acho que sim.  Provavelmente, você proibirá instruções que saltem para alguma fórmula complexa de endereço e suportará apenas instruções que saltam diretamente para esse valor, e esse valor sempre obtém <b>AND</b> . <br><br>  <b>Público:</b> é mais necessário acessar a memória do que ... <br><br>  <b>Professor:</b> sim, porque é apenas código.  E para acessar a memória na plataforma <b>x86</b> , existem muitas maneiras estranhas de acessar um local de memória específico.  Normalmente, você deve primeiro calcular a localização da memória, adicionar um <b>AND</b> adicional e somente então acessar.  Penso que esta é a verdadeira razão da sua preocupação com o declínio no desempenho devido ao uso deste kit de ferramentas. <br><br>  Na plataforma <b>x86</b> , ou pelo menos na plataforma de 32 bits descrita no artigo, eles usam suporte de hardware em vez de restringir os dados de código e endereço referentes aos módulos não confiáveis. <br><br>  Vamos ver como fica antes de descobrir como usar o módulo <b>NaCl</b> em uma sandbox.  Esse hardware é chamado de segmentação.  Ele surgiu antes mesmo da plataforma <b>x86</b> receber um arquivo de troca.  Na plataforma <b>x86</b> , existe uma tabela de hardware suportada durante o processo.  Chamamos isso de tabela de descritores de segmentos.  É um monte de segmentos numerados de 0 até o final de uma tabela de qualquer tamanho.  Isso é algo como um descritor de arquivo no <b>Unix</b> , exceto que cada entrada consiste em 2 valores: a base <b>base</b> e o <b>comprimento do</b> comprimento. <br><br>  Esta tabela nos diz que temos um par de segmentos e, sempre que nos referimos a um segmento específico, isso significa que estamos falando de um pedaço de memória que começa no endereço <b>base</b> da <b>base</b> e continua ao longo do <b>comprimento</b> . <br><br><img src="https://habrastorage.org/webt/bc/5z/ly/bc5zlyp2hzg0aa6nn9nfsbbzwoe.jpeg"><br><br>  Isso nos ajuda a manter os limites da memória na plataforma <b>x86</b> , porque cada instrução, acessando a memória, refere-se a um segmento específico nesta tabela. <br><br>  Por exemplo, quando executamos <b>mov (% eax), (% ebx)</b> , ou seja, movemos o valor da memória de um ponteiro armazenado no registro <b>EAX</b> para outro ponteiro armazenado no registro <b>EBX</b> , o programa sabe quais são os endereços inicial e final em vista de e salvará o valor no segundo endereço. <br><br>  Mas na verdade, na plataforma <b>x86</b> , quando falamos de memória, existe uma coisa implícita chamada descritor de segmento, semelhante a um descritor de arquivo no <b>Unix</b> .  Este é apenas um índice na tabela do descritor e, a menos que seja indicado de outra forma, cada código de operação contém um segmento padrão. <br><br>  Portanto, quando você executa <b>mov (% eax)</b> , refere-se a <b>% ds</b> ou ao registro do segmento de dados, que é um registro especial no seu processador.  Se bem me lembro, é um número inteiro de 16 bits que aponta para esta tabela de descritor. <br><br>  E o mesmo vale para <b>(% ebx)</b> - refere-se ao mesmo seletor de segmento <b>% ds</b> .  De fato, no <b>x86</b> , temos um grupo de 6 seletores de código: <b>CS, DS, ES, FS, GS</b> e <b>SS</b> .  O <b>seletor de chamadas CS é</b> usado implicitamente para receber instruções.  Portanto, se o ponteiro de sua instrução apontar para algo, ele se refere àquele que selecionou o seletor de segmentos <b>CS</b> . <br><br><img src="https://habrastorage.org/webt/li/vq/nz/livqnzyn6jk6muyb93siboedkik.jpeg"><br><br>  A maioria das referências de dados usa implicitamente <b>DS</b> ou <b>ES</b> , <b>FS</b> e <b>GS</b> indicam algumas coisas especiais, e o <b>SS é</b> sempre usado para operações de pilha.  E se você <b>pressiona e pop</b> , eles implicitamente vêm deste seletor de segmentos.  Essa é uma mecânica bastante arcaica, mas acaba sendo extremamente útil nesse caso específico. <br><br>  Se você obtiver acesso a algum endereço, por exemplo, no seletor <b>% ds: addr</b> , o hardware o redirecionará para a operação com a tabela <b>adrr + T [% ds] .base</b> .  Isso significa que o endereço do comprimento do módulo será retirado da mesma tabela.  Portanto, toda vez que você acessa a memória, ele possui um banco de dados de seletores de segmentos na forma de entradas da tabela de descritores e pega o endereço especificado e o combina com o comprimento do segmento correspondente. <br><br>  <b>Público:</b> então, por que não é usado, por exemplo, para proteger o buffer? <br><br>  <b>Professor:</b> sim, essa é uma boa pergunta!  Poderíamos usar isso para proteger contra estouros de buffer?  Por exemplo, para cada buffer que temos, você pode colocar a base do buffer aqui e o tamanho do buffer. <br><br>  <b>Público-alvo:</b> e se você não precisar colocá-lo em uma tabela antes de escrever?  Você não precisa estar lá constantemente. <br><br>  <b>Professor:</b> sim.  Portanto, acho que o motivo pelo qual essa abordagem geralmente não é usada para proteger contra estouros de buffer é porque o número de entradas nesta tabela não pode exceder 2 no 16º grau, porque os descritores têm 16 bits, mas na verdade de fato, mais alguns bits são usados ​​para outras coisas.  Portanto, na verdade, você só pode colocar 2 na 13ª potência dos registros nesta tabela.  Portanto, se você tiver no seu código uma matriz de dados maior que 2 <sup>13</sup> , poderá ocorrer um estouro dessa tabela. <br><br>  Além disso, seria estranho para o compilador gerenciar diretamente essa tabela, porque geralmente é manipulada usando chamadas do sistema.  Você não pode gravar diretamente nesta tabela; primeiro você precisa fazer uma chamada do sistema para o sistema operacional, após o qual o sistema operacional colocará o registro nessa tabela.  Portanto, acho que a maioria dos compiladores simplesmente não deseja lidar com um sistema de gerenciamento de buffer de memória tão complexo. <br><br><img src="https://habrastorage.org/webt/rp/sa/hb/rpsahbydh4eumva5z7st5cfuc2a.jpeg"><br><br>  A propósito, o <b>Multex</b> usa essa abordagem: possui 2 <sup>18</sup> registros para vários segmentos e 2 <sup>18</sup> registros para possíveis compensações.  E cada fragmento de biblioteca comum ou fragmento de memória são segmentos separados.  Todos são verificados quanto à faixa e, portanto, não podem ser usados ​​em um nível variável. <br><br>  <b>Audiência:</b> Presumivelmente, a necessidade constante de usar o kernel atrasará o processo. <br><br>  <b>Professor:</b> sim, está certo.  Portanto, teremos sobrecarga devido ao fato de que, quando um novo buffer é criado de repente na pilha, precisamos fazer uma chamada de sistema para adicioná-lo. <br><br>  Então, quantos desses elementos realmente usam o mecanismo de segmentação?  Você pode adivinhar como isso funciona.  Eu acho que, por padrão, todos esses segmentos em <b>x86</b> têm uma base igual a 0 e o comprimento é de 2 a 32. Assim, você pode acessar todo o intervalo de memória que deseja.  Portanto, para <b>NaCl,</b> eles codificam a base 0 e definem o comprimento para 256 megabytes.  Em seguida, apontam para todos os registros de 6 seletores de segmento nesse registro para a área de 256 MB.  Assim, sempre que o equipamento acessa a memória, ele a modifica com um deslocamento de 256 MB.  Portanto, a capacidade de alterar o módulo será limitada a 256 MB. <br><br>  Acho que agora você entende como esse hardware é suportado e como funciona, para que você possa acabar usando esses seletores de segmento. <br>  Então, o que pode dar errado se apenas implementarmos esse plano?  Podemos pular do seletor de segmentos em um módulo não confiável?  Penso que uma coisa a ter cuidado é que esses registros são como registros regulares e você pode mover valores para dentro e para fora deles.  Portanto, você deve garantir que o módulo não confiável não distorça esses registros do seletor de segmentos.  Porque em algum lugar da tabela do descritor pode muito bem haver um registro, que também é o descritor do segmento de origem para um processo que tem uma base de 0 e um comprimento de até <sup>32</sup> . <br><br><img src="https://habrastorage.org/webt/vg/k-/sv/vgk-svh5b3xlsnke_meuehgaira.jpeg"><br><br>  Portanto, se um módulo não confiável conseguir alterar <b>CS</b> , <b>DS</b> , <b>ES</b> ou qualquer um desses seletores para que eles comecem a apontar para esse sistema operacional original, que cobre todo o seu espaço de endereço, você poderá criar um link de memória para esse segmento e " pule para fora da caixa de areia. <br><br>  Assim, o <b>Native Client</b> teve que adicionar mais algumas instruções a esta lista proibida.  Eu acho que eles proíbem todas as instruções como <b>mov% ds, es</b> e assim por diante.  Portanto, uma vez na caixa de proteção, você não pode alterar o segmento ao qual se referem algumas coisas referentes a ela.  Na plataforma <b>x86, as</b> instruções para alterar a tabela do descritor de segmentos são privilegiadas, mas as próprias <b>ds, es</b> etc.  A tabela é completamente sem privilégios. <br><br>  <b>Público:</b> você pode inicializar a tabela para que o comprimento zero seja colocado em todos os slots não utilizados? <br><br>  <b>Professor:</b> sim.  Você pode definir o comprimento da tabela para algo em que não haja slots não utilizados.  Acontece que você realmente precisa desse slot adicional contendo 0 e 2 <sup>32</sup> , porque o ambiente de <b>tempo de execução confiável</b> deve iniciar nesse segmento e obter acesso a todo o intervalo de memória.  Portanto, essa entrada é necessária para o ambiente de <b>tempo</b> de <b>execução</b> confiável funcionar. <br><br>  Público: o que é necessário para alterar o comprimento da saída da tabela? <br>  Professor: você deve ter privilégios de root.  Na verdade, o <b>Linux</b> possui um sistema chamado <b>modify_ldt ()</b> para a tabela de descritores locais, que permite que qualquer processo modifique sua própria tabela, ou seja, na verdade há uma tabela para cada processo.  Mas na plataforma <b>x86</b> isso é mais complicado, há uma tabela global e uma tabela local.  Uma tabela local para um processo específico pode ser alterada. <br><br>  Agora vamos tentar descobrir como saltamos e saltamos do processo de execução do <b>Native Client</b> ou saímos da sandbox.  O que queremos dizer com isso? <br><br><img src="https://habrastorage.org/webt/8t/lb/yj/8tlbyjy5erf0s-x7stz29ca1qae.jpeg"><br><br>  Portanto, precisamos executar esse código confiável, e esse código confiável "vive" em algum lugar acima do limite de 256 MB.  Para pular lá, teremos que desfazer todas as proteções que o <b>Native Client</b> instalou.  Basicamente, eles se resumem a mudar esses seis seletores.  Eu acho que nosso validador não aplicará as mesmas regras para coisas localizadas acima do limite de 256 MB, então isso é bastante simples. <br><br>  Mas, então, precisamos de alguma forma entrar no <b>tempo de execução confiável</b> e reinstalar os seletores de segmento para os valores corretos para esse segmento gigante, cobrindo o espaço de endereço de todo o processo - esse intervalo é de 0 a 2 <sup>32</sup> .  Eles chamaram esses mecanismos existentes nos trampolins de <b>trampolim</b> e no <b>trampolim</b> do <b>Native Client</b> .  Eles vivem em um módulo baixo de 64k.  O mais legal é que esses "trampolins" e "saltos" são trechos de código localizados nos 64k mais baixos do espaço do processo.  Isso significa que esse módulo não confiável pode saltar para lá, porque é um endereço de código válido que está dentro dos limites de 32 bits e 256 MB.  Então você pode pular neste trampolim. <br><br>    <b>Native Client</b>    «» - .  ,  <b>Native Client</b>       «»,   trampoline      <b>trusted runtime</b> .         ,    <b>DS, CS</b>   ,       . <br><br>  ,        ,   -  <b>malo</b>   ,    «»,  «»  32-  . <br><br> ,     4096 + 32        ,     .   , ,   <b>mov %ds, 7</b> ,       <b>ds</b> ,   7         0  2 <sup>32</sup> .    <b>CS</b>       <b>trusted service runtime</b> ,     256 . <br><br><img src="https://habrastorage.org/webt/cr/fx/xj/crfxxjwdpg1tcflmflesmj_8obq.jpeg"><br><br>  ,     ,     ,         <b>trusted service runtime</b> ,    .            ,   .      DS ,   ,      ,     ,    -       . <br><br> ,        ? ,          «»? ,    ? <br><br> <b>:</b>    64. <br><br> <b>:</b> , ,          .         malo,       64,     32 .        ,       ,  ,     . <br><br>   ,        32-  ,       .  , ,        32 ,     32-    ,    .       «»    <b>trusted runtime</b>   32  . <br><br><img src="https://habrastorage.org/webt/hq/zy/tj/hqzytj99szvgxayslg6aqmwlmrk.jpeg"><br><br>      .     ,     ,     <b>DS, CS</b>   .    ,       256-  ,    <b>trusted runtime</b> ,      .                 . <br><br>         «»,      <b>trusted runtime</b>   256     <b>Native Client</b> . «»   <b>DS</b> , ,  <b>mov %ds, 7</b> ,        ,  <b>trusted runtime</b>    .     .     ,        «»,       - . <br><br>      <b>halt</b>    32-   «».        «»,   .      <b>trusted service runtime</b>      ,   1    . <br><br><img src="https://habrastorage.org/webt/50/am/cy/50amcyeulmago9zmrdvmjrsipvg.jpeg"><br><br>       <b>trusted service runtime</b> ,     ,        . <br><br> <b>:</b>   «»    ? <br><br> <b>:</b> «»     0  256   .        64-     ,    ,       «»,    - -.     <b>Native Client</b>       . <br><br> <b>:</b>          ? <br><br> <b>:</b> ,         ?  ,      «»?   ? <br><br> <b>:</b>    ,   ? <br><br> <b>:</b>  ,            -  <b>%eax</b> ,  <b>trusted runtime</b> : «,      »!      <b>EAX</b> ,    <b>mov</b> ,  «»      <b>EAX</b> ,        <b>trusted runtime</b> .   ,       «»? <br><br> <b>:</b> ,        ,         .   … <br><br> <b>:</b> ,   ,       —  ,       ,            0  2 <sup>32</sup> .   .         «»,                256 . <br><br>  ,      «»,          .  , «»    ,    .    ,   «»   . <br><br> <b>:</b>    «»   256 ? <br><br> <b>:</b>  ,      .    ,       <b>CS</b>         -  .     «»,       <b>halt</b> ,   mov,    <b>CS</b> ,        ,       256 . <br><br>  ,         ,    «».  ,       <b>DS</b> ,  ,  <b>CS</b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e pular em algum lugar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Provavelmente, se você tentar, poderá criar alguma sequência de instruções </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x86</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que possam fazer isso fora dos limites do espaço de endereço do módulo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Native Client</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Então, até a próxima semana e fale sobre segurança na web.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/I0Psvvky-44" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A versão completa do curso está disponível </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obrigado por ficar conosco.</font></font> Você gosta dos nossos artigos?  Deseja ver materiais mais interessantes?  Ajude-nos fazendo um pedido ou recomendando a seus amigos, um <b>desconto de 30% para os usuários da Habr em um análogo exclusivo de servidores básicos que inventamos para você:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Toda a verdade sobre o VPS (KVM) E5-2650 v4 (6 núcleos) 10GB DDR4 240GB SSD 1Gbps de US $ 20 ou como dividir o servidor?</a>  (as opções estão disponíveis com RAID1 e RAID10, até 24 núcleos e até 40GB DDR4). <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VPS (KVM) E5-2650 v4 (6 núcleos) 10 GB DDR4 240 GB SSD de 1 Gbps até dezembro de graça</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> quando pagar por um período de seis meses, você pode fazer o pedido </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br>  <b>Dell R730xd 2 vezes mais barato?</b>  Somente nós temos <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2 TVs Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 a partir de US $ 249</a> na Holanda e nos EUA!</b>  Leia sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como criar um prédio de infraestrutura.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">classe usando servidores Dell R730xd E5-2650 v4 custando 9.000 euros por um centavo?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt418227/">https://habr.com/ru/post/pt418227/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt418217/index.html">Curso MIT "Segurança de sistemas de computadores". Palestra 6: “Oportunidades”, parte 1</a></li>
<li><a href="../pt418219/index.html">Curso MIT "Segurança de sistemas de computadores". Palestra 6: Oportunidades, Parte 2</a></li>
<li><a href="../pt418221/index.html">Curso MIT "Segurança de sistemas de computadores". Palestra 6: “Oportunidades”, parte 3</a></li>
<li><a href="../pt418223/index.html">Curso MIT "Segurança de sistemas de computadores". Palestra 7: A Sandbox do Cliente Nativo, Parte 1</a></li>
<li><a href="../pt418225/index.html">Curso MIT "Segurança de sistemas de computadores". Palestra 7: Sandbox do Cliente Nativo Parte 2</a></li>
<li><a href="../pt418229/index.html">Curso MIT "Segurança de sistemas de computadores". Aula 8: Modelo de Segurança de Rede, Parte 1</a></li>
<li><a href="../pt418233/index.html">Mnemônicos da BMW para encontrar valores-limite</a></li>
<li><a href="../pt418235/index.html">Saga orquestrada ou como criar transações comerciais em serviços com o banco de dados por padrão de serviço</a></li>
<li><a href="../pt418237/index.html">Desenvolvimento de aplicativos multilocatários na plataforma em nuvem SAP na Neo, parte 2: autorização e autenticação</a></li>
<li><a href="../pt418239/index.html">48 megapixels para smartphone</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>