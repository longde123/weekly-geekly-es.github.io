<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘ğŸ½ ğŸ•¦ ğŸ‘¯ Curso MIT "SeguranÃ§a de sistemas de computadores". Palestra 7: A Sandbox do Cliente Nativo, Parte 3 ğŸ’…ğŸ½ ğŸ§”ğŸ» ğŸŒ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instituto de Tecnologia de Massachusetts. Curso de Aula nÂº 6.858. "SeguranÃ§a de sistemas de computador". Nikolai Zeldovich, James Mickens. 2014 ano 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Curso MIT "SeguranÃ§a de sistemas de computadores". Palestra 7: A Sandbox do Cliente Nativo, Parte 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/418227/"><h3>  Instituto de Tecnologia de Massachusetts.  Curso de Aula nÂº 6.858.  "SeguranÃ§a de sistemas de computador".  Nikolai Zeldovich, James Mickens.  2014 ano </h3><br>  Computer Systems Security Ã© um curso sobre o desenvolvimento e implementaÃ§Ã£o de sistemas de computador seguros.  As palestras abrangem modelos de ameaÃ§as, ataques que comprometem a seguranÃ§a e tÃ©cnicas de seguranÃ§a baseadas em trabalhos cientÃ­ficos recentes.  Os tÃ³picos incluem seguranÃ§a do sistema operacional (SO), recursos, gerenciamento de fluxo de informaÃ§Ãµes, seguranÃ§a de idiomas, protocolos de rede, seguranÃ§a de hardware e seguranÃ§a de aplicativos da web. <br><br>  Palestra 1: â€œIntroduÃ§Ã£o: modelos de ameaÃ§asâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 2: â€œControle de ataques de hackersâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Aula 3: â€œEstouros de Buffer: ExploraÃ§Ãµes e ProteÃ§Ã£oâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 4: â€œSeparaÃ§Ã£o de PrivilÃ©giosâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 5: â€œDe onde vÃªm os sistemas de seguranÃ§a?â€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> <br>  Palestra 6: â€œOportunidadesâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 7: â€œSandbox do Cliente Nativoâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <a name="habracut"></a><br><br>  HÃ¡ uma ressalva na regra <b>C4</b> .  VocÃª nÃ£o pode "pular" no final de um programa.  A Ãºltima coisa para a qual vocÃª pode pular Ã© a Ãºltima instruÃ§Ã£o.  Portanto, essa regra garante que, quando o programa for executado no processo "mecanismo", nÃ£o haverÃ¡ discrepÃ¢ncia. <br><br>  A regra <b>C5</b> diz que nÃ£o pode haver instruÃ§Ãµes maiores que 32 bytes.  Consideramos uma certa versÃ£o dessa regra quando falamos sobre a multiplicidade de tamanhos de instruÃ§Ãµes para 32 bytes; caso contrÃ¡rio, vocÃª pode pular para o meio da instruÃ§Ã£o e criar um problema com a chamada do sistema, que pode "ocultar" lÃ¡. <br><br>  A regra <b>C6</b> declara que todas as instruÃ§Ãµes disponÃ­veis podem ser desmontadas desde o inÃ­cio.  Portanto, isso garante que vejamos cada instruÃ§Ã£o e possamos verificar todas as instruÃ§Ãµes que sÃ£o executadas quando o programa Ã© executado. <br><br>  A regra <b>C7</b> afirma que todos os saltos diretos estÃ£o corretos.  Por exemplo, vocÃª pula diretamente para a parte da instruÃ§Ã£o em que o destino estÃ¡ indicado e, embora nÃ£o seja um mÃºltiplo de 32, ainda Ã© a instruÃ§Ã£o correta Ã  qual a desmontagem Ã© aplicada da esquerda para a direita. <br><br><img src="https://habrastorage.org/webt/1-/3i/vl/1-3ivlo26n7llpnkbkvzgzm-tci.jpeg"><br><br>  <b>PÃºblico:</b> qual Ã© a diferenÃ§a entre <b>C5</b> e <b>C3</b> ? <br><br>  <b>Professor:</b> Eu acho que o <b>C5</b> diz que se eu tiver uma instruÃ§Ã£o de vÃ¡rios bytes, ela nÃ£o poderÃ¡ atravessar as fronteiras dos endereÃ§os adjacentes.  Suponha que eu tenha um fluxo de instruÃ§Ãµes e que haja um endereÃ§o 32 e um endereÃ§o 64. Portanto, uma instruÃ§Ã£o nÃ£o pode cruzar a borda mÃºltipla de 32 bytes, ou seja, nÃ£o deve comeÃ§ar com um endereÃ§o menor que 64 e terminar com um endereÃ§o maior que 64. <br><br><img src="https://habrastorage.org/webt/di/oc/l5/diocl5ztxk3kmc1ol0mmm_badik.jpeg"><br><br>  Ã‰ isso que a regra <b>C5</b> diz.  Porque, caso contrÃ¡rio, tendo saltado a multiplicidade 32, vocÃª pode entrar no meio de outra instruÃ§Ã£o em que nÃ£o se sabe o que estÃ¡ acontecendo. <br><br>  E a regra <b>C3</b> Ã© um anÃ¡logo dessa proibiÃ§Ã£o ao lado do salto.  Ele afirma que sempre que vocÃª pula, o comprimento do seu pulo deve ser um mÃºltiplo de 32. <br><br>  <b>C5</b> tambÃ©m afirma que qualquer coisa no intervalo de endereÃ§os que seja mÃºltiplo de 32 Ã© uma instruÃ§Ã£o segura. <br><br>  Depois de ler a lista dessas regras, tive um sentimento misto, pois nÃ£o conseguia avaliar se essas regras sÃ£o suficientes, ou seja, a lista Ã© mÃ­nima ou completa. <br>  EntÃ£o, vamos pensar na liÃ§Ã£o de casa que vocÃª precisa concluir.  Eu acho que, de fato, hÃ¡ um erro na operaÃ§Ã£o do <b>Native Client</b> ao executar algumas instruÃ§Ãµes complicadas na sandbox.  Acredito que eles nÃ£o tinham o cÃ³digo de tamanho correto, o que poderia levar a algo ruim, mas nÃ£o me lembro exatamente qual foi o erro. <br><br>  Suponha que um validador de sandbox receba incorretamente o comprimento de algum tipo de instruÃ§Ã£o.  Que mal pode acontecer neste caso?  Como vocÃª usaria esse deslize? <br><br>  <b>PÃºblico-alvo:</b> por exemplo, vocÃª pode ocultar a chamada do sistema ou a declaraÃ§Ã£o de retorno <b>ret</b> . <br><br>  <b>Professor:</b> sim.  Suponha que exista alguma versÃ£o sofisticada da instruÃ§Ã£o <b>AND</b> que vocÃª anotou.  Ã‰ possÃ­vel que o validador tenha se enganado e considerado que seu comprimento Ã© de 6 bytes com o comprimento real de 5 bytes. <br><br><img src="https://habrastorage.org/webt/2z/ak/mg/2zakmgsficxcsi5tqkqnb-r_tj4.jpeg"><br><br>  O que vai acontecer?  O validador considera o comprimento desta instruÃ§Ã£o em 6 bytes e possui outra instruÃ§Ã£o vÃ¡lida por trÃ¡s.  Mas o processador, ao iniciar o cÃ³digo, usa o comprimento real da instruÃ§Ã£o, ou seja, 5 bytes.  Como resultado, temos um byte livre no final da instruÃ§Ã£o <b>AND</b> , onde podemos inserir uma chamada do sistema e usÃ¡-la em nosso benefÃ­cio.  E se inserirmos um <b>CD</b> byte aqui, serÃ¡ como o inÃ­cio de outra instruÃ§Ã£o.  Em seguida, colocaremos algo no prÃ³ximo intervalo de 6 bytes, e serÃ¡ como uma instruÃ§Ã£o que comeÃ§a com o byte do <b>CD</b> , embora na verdade faÃ§a parte da instruÃ§Ã£o <b>AND</b> .  Depois disso, podemos fazer uma chamada do sistema e "escapar" da caixa de areia. <br><br>  Assim, o validador <b>Native Client</b> deve sincronizar suas aÃ§Ãµes com as aÃ§Ãµes da <b>CPU</b> , ou seja, "adivinhar" exatamente como o processador interpretarÃ¡ cada instruÃ§Ã£o.  E isso deve estar em todos os nÃ­veis do sandbox, o que Ã© bastante difÃ­cil de implementar. <br><br>  De fato, existem outros erros interessantes no <b>Native Client</b> .  Uma delas Ã© a limpeza incorreta do ambiente do processador ao saltar para o <b>Trusted Service Runtime</b> .  Acho que falaremos sobre isso em um segundo.  Mas o <b>Trusted Service Runtime</b> funcionarÃ¡ basicamente com o mesmo conjunto de registradores de <b>CPU</b> projetados para executar mÃ³dulos nÃ£o confiÃ¡veis.  Portanto, se o processador esquecer de limpar alguma coisa ou reiniciar, o tempo de execuÃ§Ã£o pode ser enganado, considerando o mÃ³dulo nÃ£o confiÃ¡vel como um aplicativo confiÃ¡vel e fazendo algo que nÃ£o deveria ter sido feito ou que nÃ£o era a intenÃ§Ã£o dos desenvolvedores. <br><br>  EntÃ£o, onde estamos agora?  No momento, entendemos como desmontar todas as instruÃ§Ãµes e como impedir a execuÃ§Ã£o de instruÃ§Ãµes proibidas.  Agora vamos ver como armazenamos memÃ³ria e links para cÃ³digo e dados no mÃ³dulo <b>Native Client</b> . <br><br>  Por motivos de desempenho, os <b>funcionÃ¡rios</b> do <b>Native Client</b> estÃ£o comeÃ§ando a usar o suporte de hardware para garantir que o armazenamento de memÃ³ria e links nÃ£o cause muita sobrecarga.  Mas antes de considerar o suporte de hardware que eles usam, quero ouvir sugestÃµes, como eu poderia fazer o mesmo sem o suporte de hardware?  Podemos apenas fornecer acesso a todos os processos de memÃ³ria dentro dos limites estabelecidos pela mÃ¡quina anteriormente? <br><br>  <b>PÃºblico:</b> VocÃª pode instruir instruÃ§Ãµes para limpar todos os bits altos. <br><br><img src="https://habrastorage.org/webt/h1/b7/yg/h1b7ygdlwrvvs7y7ywxitmabec8.jpeg"><br><br>  <b>Professor:</b> sim, estÃ¡ certo.  De fato, vemos que temos essa instruÃ§Ã£o <b>AND</b> aqui, e toda vez, por exemplo, pulamos em algum lugar, isso limpa os bits mais baixos.  Mas, se quisermos manter todo o cÃ³digo possÃ­vel executado nos 256 MB baixos, podemos simplesmente substituir o primeiro atributo <b>f</b> por <b>0</b> e obter <b>$ 0x0fffffe0 em</b> vez de <b>$ 0xffffffe0</b> .  Isso limpa os bits baixos e define um limite superior de 256 MB. <br><br>  Assim, isso faz exatamente o que vocÃª oferece, certificando-se de que sempre que vocÃª pula, vocÃª estÃ¡ dentro de 256 MB.  E o fato de estarmos fazendo a desmontagem tambÃ©m permite verificar se todos os saltos diretos estÃ£o ao seu alcance. <br><br>  A razÃ£o pela qual eles nÃ£o fazem isso por seu cÃ³digo Ã© que, na plataforma <b>x86</b> , vocÃª pode codificar <b>AND de maneira</b> muito eficaz, onde todos os bits superiores sÃ£o 1. Isso se transforma na existÃªncia de uma instruÃ§Ã£o de 3 bytes para <b>AND</b> e uma instruÃ§Ã£o de 2 bytes. para o salto.  Assim, temos uma despesa adicional de 3 bytes.  Mas se vocÃª precisar de um bit alto que nÃ£o seja da unidade, como este <b>0 em</b> vez de <b>f</b> , de repente vocÃª terÃ¡ uma instruÃ§Ã£o de 5 bytes.  Portanto, acho que, neste caso, eles estÃ£o preocupados com as despesas gerais. <br><br>  <b>PÃºblico:</b> HÃ¡ algum problema com a existÃªncia de algumas instruÃ§Ãµes que incrementam a versÃ£o que vocÃª estÃ¡ tentando obter?  Ou seja, vocÃª pode dizer que sua instruÃ§Ã£o pode ter um viÃ©s constante ou algo assim? <br><br>  <b>Professor:</b> Eu acho que sim.  Provavelmente, vocÃª proibirÃ¡ instruÃ§Ãµes que saltem para alguma fÃ³rmula complexa de endereÃ§o e suportarÃ¡ apenas instruÃ§Ãµes que saltam diretamente para esse valor, e esse valor sempre obtÃ©m <b>AND</b> . <br><br>  <b>PÃºblico:</b> Ã© mais necessÃ¡rio acessar a memÃ³ria do que ... <br><br>  <b>Professor:</b> sim, porque Ã© apenas cÃ³digo.  E para acessar a memÃ³ria na plataforma <b>x86</b> , existem muitas maneiras estranhas de acessar um local de memÃ³ria especÃ­fico.  Normalmente, vocÃª deve primeiro calcular a localizaÃ§Ã£o da memÃ³ria, adicionar um <b>AND</b> adicional e somente entÃ£o acessar.  Penso que esta Ã© a verdadeira razÃ£o da sua preocupaÃ§Ã£o com o declÃ­nio no desempenho devido ao uso deste kit de ferramentas. <br><br>  Na plataforma <b>x86</b> , ou pelo menos na plataforma de 32 bits descrita no artigo, eles usam suporte de hardware em vez de restringir os dados de cÃ³digo e endereÃ§o referentes aos mÃ³dulos nÃ£o confiÃ¡veis. <br><br>  Vamos ver como fica antes de descobrir como usar o mÃ³dulo <b>NaCl</b> em uma sandbox.  Esse hardware Ã© chamado de segmentaÃ§Ã£o.  Ele surgiu antes mesmo da plataforma <b>x86</b> receber um arquivo de troca.  Na plataforma <b>x86</b> , existe uma tabela de hardware suportada durante o processo.  Chamamos isso de tabela de descritores de segmentos.  Ã‰ um monte de segmentos numerados de 0 atÃ© o final de uma tabela de qualquer tamanho.  Isso Ã© algo como um descritor de arquivo no <b>Unix</b> , exceto que cada entrada consiste em 2 valores: a base <b>base</b> e o <b>comprimento do</b> comprimento. <br><br>  Esta tabela nos diz que temos um par de segmentos e, sempre que nos referimos a um segmento especÃ­fico, isso significa que estamos falando de um pedaÃ§o de memÃ³ria que comeÃ§a no endereÃ§o <b>base</b> da <b>base</b> e continua ao longo do <b>comprimento</b> . <br><br><img src="https://habrastorage.org/webt/bc/5z/ly/bc5zlyp2hzg0aa6nn9nfsbbzwoe.jpeg"><br><br>  Isso nos ajuda a manter os limites da memÃ³ria na plataforma <b>x86</b> , porque cada instruÃ§Ã£o, acessando a memÃ³ria, refere-se a um segmento especÃ­fico nesta tabela. <br><br>  Por exemplo, quando executamos <b>mov (% eax), (% ebx)</b> , ou seja, movemos o valor da memÃ³ria de um ponteiro armazenado no registro <b>EAX</b> para outro ponteiro armazenado no registro <b>EBX</b> , o programa sabe quais sÃ£o os endereÃ§os inicial e final em vista de e salvarÃ¡ o valor no segundo endereÃ§o. <br><br>  Mas na verdade, na plataforma <b>x86</b> , quando falamos de memÃ³ria, existe uma coisa implÃ­cita chamada descritor de segmento, semelhante a um descritor de arquivo no <b>Unix</b> .  Este Ã© apenas um Ã­ndice na tabela do descritor e, a menos que seja indicado de outra forma, cada cÃ³digo de operaÃ§Ã£o contÃ©m um segmento padrÃ£o. <br><br>  Portanto, quando vocÃª executa <b>mov (% eax)</b> , refere-se a <b>% ds</b> ou ao registro do segmento de dados, que Ã© um registro especial no seu processador.  Se bem me lembro, Ã© um nÃºmero inteiro de 16 bits que aponta para esta tabela de descritor. <br><br>  E o mesmo vale para <b>(% ebx)</b> - refere-se ao mesmo seletor de segmento <b>% ds</b> .  De fato, no <b>x86</b> , temos um grupo de 6 seletores de cÃ³digo: <b>CS, DS, ES, FS, GS</b> e <b>SS</b> .  O <b>seletor de chamadas CS Ã©</b> usado implicitamente para receber instruÃ§Ãµes.  Portanto, se o ponteiro de sua instruÃ§Ã£o apontar para algo, ele se refere Ã quele que selecionou o seletor de segmentos <b>CS</b> . <br><br><img src="https://habrastorage.org/webt/li/vq/nz/livqnzyn6jk6muyb93siboedkik.jpeg"><br><br>  A maioria das referÃªncias de dados usa implicitamente <b>DS</b> ou <b>ES</b> , <b>FS</b> e <b>GS</b> indicam algumas coisas especiais, e o <b>SS Ã©</b> sempre usado para operaÃ§Ãµes de pilha.  E se vocÃª <b>pressiona e pop</b> , eles implicitamente vÃªm deste seletor de segmentos.  Essa Ã© uma mecÃ¢nica bastante arcaica, mas acaba sendo extremamente Ãºtil nesse caso especÃ­fico. <br><br>  Se vocÃª obtiver acesso a algum endereÃ§o, por exemplo, no seletor <b>% ds: addr</b> , o hardware o redirecionarÃ¡ para a operaÃ§Ã£o com a tabela <b>adrr + T [% ds] .base</b> .  Isso significa que o endereÃ§o do comprimento do mÃ³dulo serÃ¡ retirado da mesma tabela.  Portanto, toda vez que vocÃª acessa a memÃ³ria, ele possui um banco de dados de seletores de segmentos na forma de entradas da tabela de descritores e pega o endereÃ§o especificado e o combina com o comprimento do segmento correspondente. <br><br>  <b>PÃºblico:</b> entÃ£o, por que nÃ£o Ã© usado, por exemplo, para proteger o buffer? <br><br>  <b>Professor:</b> sim, essa Ã© uma boa pergunta!  PoderÃ­amos usar isso para proteger contra estouros de buffer?  Por exemplo, para cada buffer que temos, vocÃª pode colocar a base do buffer aqui e o tamanho do buffer. <br><br>  <b>PÃºblico-alvo:</b> e se vocÃª nÃ£o precisar colocÃ¡-lo em uma tabela antes de escrever?  VocÃª nÃ£o precisa estar lÃ¡ constantemente. <br><br>  <b>Professor:</b> sim.  Portanto, acho que o motivo pelo qual essa abordagem geralmente nÃ£o Ã© usada para proteger contra estouros de buffer Ã© porque o nÃºmero de entradas nesta tabela nÃ£o pode exceder 2 no 16Âº grau, porque os descritores tÃªm 16 bits, mas na verdade de fato, mais alguns bits sÃ£o usados â€‹â€‹para outras coisas.  Portanto, na verdade, vocÃª sÃ³ pode colocar 2 na 13Âª potÃªncia dos registros nesta tabela.  Portanto, se vocÃª tiver no seu cÃ³digo uma matriz de dados maior que 2 <sup>13</sup> , poderÃ¡ ocorrer um estouro dessa tabela. <br><br>  AlÃ©m disso, seria estranho para o compilador gerenciar diretamente essa tabela, porque geralmente Ã© manipulada usando chamadas do sistema.  VocÃª nÃ£o pode gravar diretamente nesta tabela; primeiro vocÃª precisa fazer uma chamada do sistema para o sistema operacional, apÃ³s o qual o sistema operacional colocarÃ¡ o registro nessa tabela.  Portanto, acho que a maioria dos compiladores simplesmente nÃ£o deseja lidar com um sistema de gerenciamento de buffer de memÃ³ria tÃ£o complexo. <br><br><img src="https://habrastorage.org/webt/rp/sa/hb/rpsahbydh4eumva5z7st5cfuc2a.jpeg"><br><br>  A propÃ³sito, o <b>Multex</b> usa essa abordagem: possui 2 <sup>18</sup> registros para vÃ¡rios segmentos e 2 <sup>18</sup> registros para possÃ­veis compensaÃ§Ãµes.  E cada fragmento de biblioteca comum ou fragmento de memÃ³ria sÃ£o segmentos separados.  Todos sÃ£o verificados quanto Ã  faixa e, portanto, nÃ£o podem ser usados â€‹â€‹em um nÃ­vel variÃ¡vel. <br><br>  <b>AudiÃªncia:</b> Presumivelmente, a necessidade constante de usar o kernel atrasarÃ¡ o processo. <br><br>  <b>Professor:</b> sim, estÃ¡ certo.  Portanto, teremos sobrecarga devido ao fato de que, quando um novo buffer Ã© criado de repente na pilha, precisamos fazer uma chamada de sistema para adicionÃ¡-lo. <br><br>  EntÃ£o, quantos desses elementos realmente usam o mecanismo de segmentaÃ§Ã£o?  VocÃª pode adivinhar como isso funciona.  Eu acho que, por padrÃ£o, todos esses segmentos em <b>x86</b> tÃªm uma base igual a 0 e o comprimento Ã© de 2 a 32. Assim, vocÃª pode acessar todo o intervalo de memÃ³ria que deseja.  Portanto, para <b>NaCl,</b> eles codificam a base 0 e definem o comprimento para 256 megabytes.  Em seguida, apontam para todos os registros de 6 seletores de segmento nesse registro para a Ã¡rea de 256 MB.  Assim, sempre que o equipamento acessa a memÃ³ria, ele a modifica com um deslocamento de 256 MB.  Portanto, a capacidade de alterar o mÃ³dulo serÃ¡ limitada a 256 MB. <br><br>  Acho que agora vocÃª entende como esse hardware Ã© suportado e como funciona, para que vocÃª possa acabar usando esses seletores de segmento. <br>  EntÃ£o, o que pode dar errado se apenas implementarmos esse plano?  Podemos pular do seletor de segmentos em um mÃ³dulo nÃ£o confiÃ¡vel?  Penso que uma coisa a ter cuidado Ã© que esses registros sÃ£o como registros regulares e vocÃª pode mover valores para dentro e para fora deles.  Portanto, vocÃª deve garantir que o mÃ³dulo nÃ£o confiÃ¡vel nÃ£o distorÃ§a esses registros do seletor de segmentos.  Porque em algum lugar da tabela do descritor pode muito bem haver um registro, que tambÃ©m Ã© o descritor do segmento de origem para um processo que tem uma base de 0 e um comprimento de atÃ© <sup>32</sup> . <br><br><img src="https://habrastorage.org/webt/vg/k-/sv/vgk-svh5b3xlsnke_meuehgaira.jpeg"><br><br>  Portanto, se um mÃ³dulo nÃ£o confiÃ¡vel conseguir alterar <b>CS</b> , <b>DS</b> , <b>ES</b> ou qualquer um desses seletores para que eles comecem a apontar para esse sistema operacional original, que cobre todo o seu espaÃ§o de endereÃ§o, vocÃª poderÃ¡ criar um link de memÃ³ria para esse segmento e " pule para fora da caixa de areia. <br><br>  Assim, o <b>Native Client</b> teve que adicionar mais algumas instruÃ§Ãµes a esta lista proibida.  Eu acho que eles proÃ­bem todas as instruÃ§Ãµes como <b>mov% ds, es</b> e assim por diante.  Portanto, uma vez na caixa de proteÃ§Ã£o, vocÃª nÃ£o pode alterar o segmento ao qual se referem algumas coisas referentes a ela.  Na plataforma <b>x86, as</b> instruÃ§Ãµes para alterar a tabela do descritor de segmentos sÃ£o privilegiadas, mas as prÃ³prias <b>ds, es</b> etc.  A tabela Ã© completamente sem privilÃ©gios. <br><br>  <b>PÃºblico:</b> vocÃª pode inicializar a tabela para que o comprimento zero seja colocado em todos os slots nÃ£o utilizados? <br><br>  <b>Professor:</b> sim.  VocÃª pode definir o comprimento da tabela para algo em que nÃ£o haja slots nÃ£o utilizados.  Acontece que vocÃª realmente precisa desse slot adicional contendo 0 e 2 <sup>32</sup> , porque o ambiente de <b>tempo de execuÃ§Ã£o confiÃ¡vel</b> deve iniciar nesse segmento e obter acesso a todo o intervalo de memÃ³ria.  Portanto, essa entrada Ã© necessÃ¡ria para o ambiente de <b>tempo</b> de <b>execuÃ§Ã£o</b> confiÃ¡vel funcionar. <br><br>  PÃºblico: o que Ã© necessÃ¡rio para alterar o comprimento da saÃ­da da tabela? <br>  Professor: vocÃª deve ter privilÃ©gios de root.  Na verdade, o <b>Linux</b> possui um sistema chamado <b>modify_ldt ()</b> para a tabela de descritores locais, que permite que qualquer processo modifique sua prÃ³pria tabela, ou seja, na verdade hÃ¡ uma tabela para cada processo.  Mas na plataforma <b>x86</b> isso Ã© mais complicado, hÃ¡ uma tabela global e uma tabela local.  Uma tabela local para um processo especÃ­fico pode ser alterada. <br><br>  Agora vamos tentar descobrir como saltamos e saltamos do processo de execuÃ§Ã£o do <b>Native Client</b> ou saÃ­mos da sandbox.  O que queremos dizer com isso? <br><br><img src="https://habrastorage.org/webt/8t/lb/yj/8tlbyjy5erf0s-x7stz29ca1qae.jpeg"><br><br>  Portanto, precisamos executar esse cÃ³digo confiÃ¡vel, e esse cÃ³digo confiÃ¡vel "vive" em algum lugar acima do limite de 256 MB.  Para pular lÃ¡, teremos que desfazer todas as proteÃ§Ãµes que o <b>Native Client</b> instalou.  Basicamente, eles se resumem a mudar esses seis seletores.  Eu acho que nosso validador nÃ£o aplicarÃ¡ as mesmas regras para coisas localizadas acima do limite de 256 MB, entÃ£o isso Ã© bastante simples. <br><br>  Mas, entÃ£o, precisamos de alguma forma entrar no <b>tempo de execuÃ§Ã£o confiÃ¡vel</b> e reinstalar os seletores de segmento para os valores corretos para esse segmento gigante, cobrindo o espaÃ§o de endereÃ§o de todo o processo - esse intervalo Ã© de 0 a 2 <sup>32</sup> .  Eles chamaram esses mecanismos existentes nos trampolins de <b>trampolim</b> e no <b>trampolim</b> do <b>Native Client</b> .  Eles vivem em um mÃ³dulo baixo de 64k.  O mais legal Ã© que esses "trampolins" e "saltos" sÃ£o trechos de cÃ³digo localizados nos 64k mais baixos do espaÃ§o do processo.  Isso significa que esse mÃ³dulo nÃ£o confiÃ¡vel pode saltar para lÃ¡, porque Ã© um endereÃ§o de cÃ³digo vÃ¡lido que estÃ¡ dentro dos limites de 32 bits e 256 MB.  EntÃ£o vocÃª pode pular neste trampolim. <br><br>    <b>Native Client</b>    Â«Â» - .  ,  <b>Native Client</b>       Â«Â»,   trampoline      <b>trusted runtime</b> .         ,    <b>DS, CS</b>   ,       . <br><br>  ,        ,   -  <b>malo</b>   ,    Â«Â»,  Â«Â»  32-  . <br><br> ,     4096 + 32        ,     .   , ,   <b>mov %ds, 7</b> ,       <b>ds</b> ,   7         0  2 <sup>32</sup> .    <b>CS</b>       <b>trusted service runtime</b> ,     256 . <br><br><img src="https://habrastorage.org/webt/cr/fx/xj/crfxxjwdpg1tcflmflesmj_8obq.jpeg"><br><br>  ,     ,     ,         <b>trusted service runtime</b> ,    .            ,   .      DS ,   ,      ,     ,    -       . <br><br> ,        ? ,          Â«Â»? ,    ? <br><br> <b>:</b>    64. <br><br> <b>:</b> , ,          .         malo,       64,     32 .        ,       ,  ,     . <br><br>   ,        32-  ,       .  , ,        32 ,     32-    ,    .       Â«Â»    <b>trusted runtime</b>   32  . <br><br><img src="https://habrastorage.org/webt/hq/zy/tj/hqzytj99szvgxayslg6aqmwlmrk.jpeg"><br><br>      .     ,     ,     <b>DS, CS</b>   .    ,       256-  ,    <b>trusted runtime</b> ,      .                 . <br><br>         Â«Â»,      <b>trusted runtime</b>   256     <b>Native Client</b> . Â«Â»   <b>DS</b> , ,  <b>mov %ds, 7</b> ,        ,  <b>trusted runtime</b>    .     .     ,        Â«Â»,       - . <br><br>      <b>halt</b>    32-   Â«Â».        Â«Â»,   .      <b>trusted service runtime</b>      ,   1    . <br><br><img src="https://habrastorage.org/webt/50/am/cy/50amcyeulmago9zmrdvmjrsipvg.jpeg"><br><br>       <b>trusted service runtime</b> ,     ,        . <br><br> <b>:</b>   Â«Â»    ? <br><br> <b>:</b> Â«Â»     0  256   .        64-     ,    ,       Â«Â»,    - -.     <b>Native Client</b>       . <br><br> <b>:</b>          ? <br><br> <b>:</b> ,         ?  ,      Â«Â»?   ? <br><br> <b>:</b>    ,   ? <br><br> <b>:</b>  ,            -  <b>%eax</b> ,  <b>trusted runtime</b> : Â«,      Â»!      <b>EAX</b> ,    <b>mov</b> ,  Â«Â»      <b>EAX</b> ,        <b>trusted runtime</b> .   ,       Â«Â»? <br><br> <b>:</b> ,        ,         .   â€¦ <br><br> <b>:</b> ,   ,       â€”  ,       ,            0  2 <sup>32</sup> .   .         Â«Â»,                256 . <br><br>  ,      Â«Â»,          .  , Â«Â»    ,    .    ,   Â«Â»   . <br><br> <b>:</b>    Â«Â»   256 ? <br><br> <b>:</b>  ,      .    ,       <b>CS</b>         -  .     Â«Â»,       <b>halt</b> ,   mov,    <b>CS</b> ,        ,       256 . <br><br>  ,         ,    Â«Â».  ,       <b>DS</b> ,  ,  <b>CS</b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e pular em algum lugar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Provavelmente, se vocÃª tentar, poderÃ¡ criar alguma sequÃªncia de instruÃ§Ãµes </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x86</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que possam fazer isso fora dos limites do espaÃ§o de endereÃ§o do mÃ³dulo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Native Client</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EntÃ£o, atÃ© a prÃ³xima semana e fale sobre seguranÃ§a na web.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/I0Psvvky-44" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A versÃ£o completa do curso estÃ¡ disponÃ­vel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obrigado por ficar conosco.</font></font> VocÃª gosta dos nossos artigos?  Deseja ver materiais mais interessantes?  Ajude-nos fazendo um pedido ou recomendando a seus amigos, um <b>desconto de 30% para os usuÃ¡rios da Habr em um anÃ¡logo exclusivo de servidores bÃ¡sicos que inventamos para vocÃª:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Toda a verdade sobre o VPS (KVM) E5-2650 v4 (6 nÃºcleos) 10GB DDR4 240GB SSD 1Gbps de US $ 20 ou como dividir o servidor?</a>  (as opÃ§Ãµes estÃ£o disponÃ­veis com RAID1 e RAID10, atÃ© 24 nÃºcleos e atÃ© 40GB DDR4). <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VPS (KVM) E5-2650 v4 (6 nÃºcleos) 10 GB DDR4 240 GB SSD de 1 Gbps atÃ© dezembro de graÃ§a</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> quando pagar por um perÃ­odo de seis meses, vocÃª pode fazer o pedido </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br>  <b>Dell R730xd 2 vezes mais barato?</b>  Somente nÃ³s temos <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2 TVs Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 a partir de US $ 249</a> na Holanda e nos EUA!</b>  Leia sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como criar um prÃ©dio de infraestrutura.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">classe usando servidores Dell R730xd E5-2650 v4 custando 9.000 euros por um centavo?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt418227/">https://habr.com/ru/post/pt418227/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt418217/index.html">Curso MIT "SeguranÃ§a de sistemas de computadores". Palestra 6: â€œOportunidadesâ€, parte 1</a></li>
<li><a href="../pt418219/index.html">Curso MIT "SeguranÃ§a de sistemas de computadores". Palestra 6: Oportunidades, Parte 2</a></li>
<li><a href="../pt418221/index.html">Curso MIT "SeguranÃ§a de sistemas de computadores". Palestra 6: â€œOportunidadesâ€, parte 3</a></li>
<li><a href="../pt418223/index.html">Curso MIT "SeguranÃ§a de sistemas de computadores". Palestra 7: A Sandbox do Cliente Nativo, Parte 1</a></li>
<li><a href="../pt418225/index.html">Curso MIT "SeguranÃ§a de sistemas de computadores". Palestra 7: Sandbox do Cliente Nativo Parte 2</a></li>
<li><a href="../pt418229/index.html">Curso MIT "SeguranÃ§a de sistemas de computadores". Aula 8: Modelo de SeguranÃ§a de Rede, Parte 1</a></li>
<li><a href="../pt418233/index.html">MnemÃ´nicos da BMW para encontrar valores-limite</a></li>
<li><a href="../pt418235/index.html">Saga orquestrada ou como criar transaÃ§Ãµes comerciais em serviÃ§os com o banco de dados por padrÃ£o de serviÃ§o</a></li>
<li><a href="../pt418237/index.html">Desenvolvimento de aplicativos multilocatÃ¡rios na plataforma em nuvem SAP na Neo, parte 2: autorizaÃ§Ã£o e autenticaÃ§Ã£o</a></li>
<li><a href="../pt418239/index.html">48 megapixels para smartphone</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>