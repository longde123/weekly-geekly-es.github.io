<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ½â€ğŸ³ ğŸ‘©ğŸ¿â€ğŸ¤â€ğŸ‘©ğŸ½ ğŸ‘²ğŸ¾ Kursus perkuliahan "Dasar-Dasar Pemrosesan Sinyal Digital" ğŸ•  ğŸ‘©ğŸ¾â€ğŸš€ ğŸ‘ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! 

 Seringkali orang menoleh kepada saya dengan pertanyaan tentang tugas-tugas dari bidang pemrosesan sinyal digital (DSP). Saya menceri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kursus perkuliahan "Dasar-Dasar Pemrosesan Sinyal Digital"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460445/">  Halo semuanya! <br><br>  Seringkali orang menoleh kepada saya dengan pertanyaan tentang tugas-tugas dari bidang pemrosesan sinyal digital (DSP).  Saya menceritakan secara rinci nuansa, menyarankan sumber informasi yang diperlukan.  Tetapi semua pendengar, seperti yang ditunjukkan waktu, tidak memiliki tugas dan contoh praktis dalam proses mempelajari bidang ini.  Dalam hal ini, saya memutuskan untuk menulis kursus interaktif singkat tentang pemrosesan sinyal digital dan memasukkannya ke dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">domain publik</a> . <br><br>  Sebagian besar materi pelatihan untuk presentasi visual dan interaktif diimplementasikan menggunakan <i>Jupyter Notebook</i> .  Diasumsikan bahwa pembaca memiliki pengetahuan dasar tentang bidang matematika yang lebih tinggi, serta sedikit perintah bahasa pemrograman Python. <br><br><img src="https://habrastorage.org/webt/vh/4z/ci/vh4zciifrdxclttqfvmpul0zv5a.png"><br><a name="habracut"></a><br><h2>  Daftar kuliah </h2><br>  Kursus ini berisi materi dalam bentuk kuliah jadi tentang berbagai topik dari bidang pemrosesan sinyal digital.  Materi disajikan menggunakan pustaka Python (numpy, scipy, paket matplotlib, dll.).  Informasi dasar untuk kursus ini diambil dari kuliah saya, yang saya, sebagai mahasiswa pascasarjana, berikan kepada mahasiswa Institut Energi Moskow (NRU MEI).  Sebagian informasi dari kuliah ini digunakan pada seminar pelatihan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pusat Elektronik Kontemporer</a> , di mana saya bertindak sebagai dosen.  Selain itu, materi ini mencakup terjemahan berbagai artikel ilmiah, kompilasi informasi dari sumber-sumber terpercaya dan literatur tentang pemrosesan sinyal digital, serta dokumentasi resmi tentang paket aplikasi dan fungsi built-in dari scipy dan numpy libraries di Python. <br><br>  Untuk pengguna MATLAB (GNU Octave), menguasai materi dari sudut pandang kode program tidak sulit, karena fungsi utama dan atributnya sebagian besar identik dan mirip dengan metode dari pustaka Python. <br><br>  Semua bahan dikelompokkan berdasarkan topik utama pemrosesan sinyal digital: <br><br><ol><li>  Sinyal: analog, diskrit, digital.  Konversi z </li><li>  Transformasi Fourier: amplitudo dan sinyal fase, DFT dan FFT, </li><li>  Konvolusi dan korelasi.  Konvolusi linier dan siklik.  Konvolusi cepat </li><li>  Proses acak.  Kebisingan putih.  Fungsi kepadatan probabilitas </li><li>  Sinyal deterministik.  Modulasi: AM, FM, FM, LFM.  Manipulasi </li><li>  Penyaringan Sinyal: filter IIR, FIR </li><li>  Fungsi jendela dalam tugas penyaringan.  Deteksi sinyal lemah. </li><li>  Resampling: penipisan dan interpolasi.  Filter CIC, filter rata-rata bergerak </li></ol><br><br>  Daftar kuliah sudah cukup <s>tetapi, tentu saja, tidak lengkap</s> untuk perkenalan dengan bidang DSP.  Dengan waktu luang, saya berencana untuk mendukung dan mengembangkan proyek ini. <br><br><h3>  Di mana menemukan? </h3><br>  Semua bahan <b>benar</b> - <b>benar gratis</b> dan tersedia sebagai gudang terbuka di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github saya sebagai proyek sumber terbuka</a> .  Materi disajikan dalam dua format - dalam bentuk Notebook Jupyter untuk pekerjaan interaktif, belajar dan mengedit, dan dalam bentuk file HTML yang dikompilasi dari notebook ini (setelah mengunduh dari github mereka memiliki format yang cukup cocok untuk membaca dan mencetak). <br><br>  Berikut ini adalah deskripsi yang sangat <u>singkat</u> dari bagian-bagian kursus dengan penjelasan singkat, istilah dan definisi.  Informasi dasar tersedia di kuliah awal, di sini hanya tinjauan singkat! <br><br><h3>  Sinyal.  Konversi z </h3><br>  Bagian pengantar, yang berisi informasi dasar tentang jenis sinyal.  Konsep urutan diskrit, fungsi delta, dan fungsi Heaviside (unit jump) diperkenalkan. <br><br>  Semua sinyal sesuai dengan metode presentasi pada set dapat dibagi menjadi empat kelompok: <br><ul><li>  analog - dijelaskan oleh fungsi terus menerus dalam waktu, </li><li>  diskrit - terputus dalam waktu dengan langkah yang ditentukan oleh pengambilan sampel, </li><li>  terkuantisasi - memiliki seperangkat level hingga (biasanya dalam amplitudo), </li><li>  digital - kombinasi sifat-sifat sinyal diskrit dan terkuantisasi. </li></ul><br><br><img src="https://habrastorage.org/webt/1f/l4/te/1fl4te_9ataaovtla-4morc9uwa.png" alt="Sinyal"><br><br>  Untuk rekonstruksi yang benar dari sinyal analog dari sinyal digital tanpa distorsi dan kehilangan, teorema pengambilan sampel yang dikenal sebagai teorema <b>Kotelnikov (Nyquist-Shannon)</b> digunakan. <br><blockquote>  Setiap sinyal kontinu dengan spektrum terbatas dapat dipulihkan secara unik dan tanpa kehilangan dari sampel terpisahnya yang diambil dengan frekuensi yang benar-benar lebih besar dari dua kali frekuensi atas spektrum sinyal kontinyu. </blockquote><br>  Interpretasi seperti itu valid asalkan fungsi waktu yang kontinyu menempati pita frekuensi dari 0 hingga nilai frekuensi atas.  Jika langkah kuantisasi dan diskritisasi dipilih secara salah, sinyal akan terdistorsi dari analog ke diskrit. <br><br>  Juga di bagian ini, <b>transformasi-Z</b> dan sifat-sifatnya dijelaskan, dan representasi dari sekuens diskrit dalam bentuk-Z ditampilkan. <br><br>  Contoh urutan diskrit terbatas: <br><pre><code class="python hljs">x(nT) = {<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}</code> </pre>  . <br>  Contoh dari urutan yang sama dalam bentuk-Z: <br><br>  X (z) = 2 + z <sup>-1</sup> - 2z <sup>-2</sup> + 2z <sup>-4</sup> + 3z <sup>-5</sup> + 1z <sup>-6</sup> <br><br><h3>  Transformasi Fourier.  Properti  DFT dan FFT </h3><br>  Bagian ini menjelaskan konsep domain waktu dan frekuensi dari suatu sinyal.  Definisi transformasi Fourier diskrit (DFT) diperkenalkan.  DFT langsung dan terbalik dan sifat utamanya dipertimbangkan.  Ditampilkan adalah transisi dari DFT ke algoritma Fourier transform (FFT) cepat dalam basis 2 (algoritma penipisan dalam frekuensi dan waktu).  Mencerminkan efektivitas FFT dibandingkan dengan DFT. <br><br>  Secara khusus, bagian ini menjelaskan paket Python scipy.ffpack untuk menghitung berbagai transformasi Fourier (sinus, cosinus, langsung, terbalik, multidimensi, nyata). <br><br>  Transformasi Fourier memungkinkan Anda untuk mewakili fungsi apa pun sebagai serangkaian sinyal harmonik!  Transformasi Fourier adalah dasar dari metode konvolusi dan desain korelator digital, secara aktif digunakan dalam analisis spektral, dan digunakan ketika bekerja dengan angka yang panjang. <br><br>  Fitur spektrum sinyal diskrit: <br>  1. Kepadatan spektral dari sinyal diskrit adalah fungsi periodik dengan periode yang sama dengan frekuensi sampling. <br>  2. Jika urutan diskrit adalah <i>nyata</i> , maka modulus kepadatan spektral dari urutan tersebut adalah fungsi <i>genap</i> , dan argumennya adalah fungsi frekuensi <i>ganjil</i> . <br><br>  Spektrum Sinyal Harmonik: <br><br><img src="https://habrastorage.org/webt/if/gy/k4/ifgyk4dlgjakj-zrkd3vpzq8c24.png" alt="FFT untuk cosinus"><br><br><h4>  Perbandingan kemanjuran DFT dan FFT </h4><br>  Efisiensi algoritma FFT dan jumlah operasi yang dilakukan secara linear tergantung pada panjang urutan N: <br><br><div class="scrollable-table"><table><thead><tr><th rowspan="2">  N </th><th colspan="2">  DFT </th><th colspan="2">  FFT </th><th rowspan="2">  Rasio jumlah penambahan kompleks </th><th rowspan="2">  Rasio jumlah perkalian kompleks </th></tr><tr><th>  Jumlah operasi multiplikasi </th><th>  Jumlah operasi penambahan </th><th>  Jumlah operasi multiplikasi </th><th>  Jumlah operasi penambahan </th></tr></thead><tbody><tr><td>  2 </td><td>  4 </td><td>  2 </td><td>  1 </td><td>  2 </td><td>  4 </td><td>  1 </td></tr><tr><td>  4 </td><td>  16 </td><td>  12 </td><td>  4 </td><td>  8 </td><td>  4 </td><td>  1.5 </td></tr><tr><td>  8 </td><td>  64 </td><td>  56 </td><td>  12 </td><td>  24 </td><td>  5.3 </td><td>  2.3 </td></tr><tr><td>  16 </td><td>  256 </td><td>  240 </td><td>  32 </td><td>  64 </td><td>  8 </td><td>  3,75 </td></tr><tr><td>  32 </td><td>  1024 </td><td>  992 </td><td>  80 </td><td>  160 </td><td>  12.8 </td><td>  6.2 </td></tr><tr><td>  64 </td><td>  4096 </td><td>  4032 </td><td>  192 </td><td>  384 </td><td>  21.3 </td><td>  10.5 </td></tr><tr><td>  128 </td><td>  16384 </td><td>  16256 </td><td>  448 </td><td>  896 </td><td>  36.6 </td><td>  18.1 </td></tr><tr><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td></tr><tr><td>  4096 </td><td>  16777216 </td><td>  16773120 </td><td>  24576 </td><td>  49152 </td><td>  683 </td><td>  341 </td></tr><tr><td>  8192 </td><td>  67108864 </td><td>  67100672 </td><td>  53248 </td><td>  106496 </td><td>  <b>1260</b> </td><td>  <b>630</b> </td></tr></tbody></table></div><br>  Seperti yang Anda lihat, semakin lama panjang konversi, semakin besar penghematan dalam sumber daya komputasi (dalam hal kecepatan pemrosesan atau jumlah unit perangkat keras)! <br><br>  Bentuk gelombang sembarang dapat direpresentasikan sebagai satu set sinyal harmonik dari frekuensi yang berbeda.  Dengan kata lain, sinyal bentuk kompleks dalam domain waktu memiliki satu set sampel kompleks dalam domain frekuensi, yang disebut * harmonik *.  Sampel-sampel ini mengekspresikan amplitudo dan fase efek harmonik pada frekuensi tertentu.  Semakin besar himpunan harmonik dalam domain frekuensi, semakin akurat bentuk gelombang kompleks muncul. <br><br><img src="https://habrastorage.org/webt/vj/i1/dg/vji1dgvf4ak0dsvjhlmx7mmhj6q.png" alt="FFT Gibbs"><br><br><h3>  Konvolusi dan korelasi </h3><br>  Bagian ini memperkenalkan konsep korelasi dan konvolusi untuk urutan acak dan deterministik diskrit.  Hubungan antara fungsi autokorelasi dan korelasi silang dengan konvolusi ditunjukkan.  Sifat-sifat konvolusi dijelaskan, khususnya, metode konvolusi linier dan siklik dari sinyal diskrit dengan analisis rinci pada contoh sekuens diskrit dipertimbangkan.  Selain itu, metode untuk menghitung konvolusi "cepat" menggunakan algoritma FFT ditampilkan. <br><br>  Dalam masalah nyata, pertanyaan sering diajukan tentang tingkat kesamaan dari satu proses ke proses lainnya atau tentang independensi dari satu proses dari proses lainnya.  Dengan kata lain, diperlukan untuk menentukan hubungan antara sinyal, yaitu, untuk menemukan <i>korelasi</i> .  Metode korelasi digunakan dalam berbagai tugas: pencarian sinyal, visi komputer dan pemrosesan gambar, dalam masalah radar untuk menentukan karakteristik target dan menentukan jarak ke objek.  Selain itu, korelasi digunakan untuk mencari sinyal lemah dalam noise. <br><br>  <b>Konvolusi</b> menggambarkan interaksi sinyal satu sama lain.  Jika salah satu sinyal adalah respons impuls dari filter, maka konvolusi urutan input dengan respons impuls tidak lain adalah reaksi rangkaian terhadap aksi input.  Dengan kata lain, sinyal yang dihasilkan mencerminkan bagian dari sinyal melalui filter. <br><br>  <i>Fungsi autokorelasi</i> (ACF) digunakan dalam pengkodean informasi.  Pilihan urutan pengkodean sesuai dengan parameter panjang, frekuensi dan bentuk sebagian besar disebabkan oleh sifat korelasi dari urutan ini.  Urutan kode terbaik memiliki probabilitas terendah untuk deteksi atau operasi palsu (untuk mendeteksi sinyal, untuk perangkat ambang) atau sinkronisasi palsu (untuk mentransmisikan dan menerima urutan kode). <br><br>  Bagian ini menyajikan tabel yang membandingkan efektivitas konvolusi cepat dan konvolusi yang dihitung dengan rumus langsung (dengan jumlah perkalian nyata). <br><br>  Seperti yang Anda lihat, untuk panjang FFT hingga 64, konvolusi cepat <u>hilang</u> ke metode langsung.  Namun, dengan peningkatan panjang FFT, hasilnya berubah ke arah yang berlawanan - konvolusi cepat mulai mengungguli metode langsung.  Jelas, semakin lama FFT, semakin baik gain dalam metode frekuensi. <br><br><div class="scrollable-table"><table><thead><tr><th>  N </th><th>  Konvolusi </th><th>  Konvolusi cepat </th><th>  Sikap </th></tr></thead><tbody><tr><td>  8 </td><td>  64 </td><td>  448 </td><td>  0,14 </td></tr><tr><td>  16 </td><td>  256 </td><td>  1088 </td><td>  0,24 </td></tr><tr><td>  32 </td><td>  1024 </td><td>  2560 </td><td>  0,4 </td></tr><tr><td>  64 </td><td>  4096 </td><td>  5888 </td><td>  0,7 </td></tr><tr><td>  128 </td><td>  16 rb </td><td>  13312 </td><td>  1.23 </td></tr><tr><td>  ... </td><td>  ... </td><td>  .. </td><td>  ... </td></tr><tr><td>  2048 </td><td>  4 jt </td><td>  311296 </td><td>  <b>13.5</b> </td></tr></tbody></table></div><br><h3>  Sinyal dan Kebisingan Acak </h3><br>  Pada bagian ini, konsep sinyal acak, kepadatan probabilitas, hukum distribusi acak diperkenalkan.  Momen matematika dianggap - mean (ekspektasi matematis) dan varians (atau akar dari kuantitas ini adalah standar deviasi).  Juga di bagian ini, distribusi normal dan konsep terkait <i>white noise</i> dianggap sebagai sumber utama noise (gangguan) selama pemrosesan sinyal. <br><br>  <i>Sinyal acak</i> adalah fungsi waktu yang nilainya tidak diketahui sebelumnya dan hanya dapat diprediksi dengan beberapa <i>probabilitas</i> .  Karakteristik utama dari sinyal acak meliputi: <br><br><ul><li>  hukum distribusi (waktu tinggal relatif dari nilai sinyal dalam interval tertentu), </li><li>  distribusi spektral daya sinyal. </li></ul><br><br><img src="https://habrastorage.org/webt/sh/02/ft/sh02ftx_0_ynupvdlzo7uvgmeds.png" alt="Kebisingan AWGN"><br><br>  Dalam tugas DSP, sinyal acak dibagi menjadi dua kelas: <br><br><ul><li>  noise - fluktuasi acak yang terdiri dari serangkaian frekuensi dan amplitudo yang berbeda, </li><li>  sinyal membawa informasi, untuk pemrosesan yang diperlukan untuk menggunakan metode probabilistik. </li></ul><br><br>  Dengan menggunakan variabel acak, kita dapat mensimulasikan efek medium nyata pada perpindahan sinyal dari sumber ke penerima data.  Ketika sebuah sinyal melewati beberapa tautan bising, yang disebut white noise ditambahkan ke sinyal.  Sebagai aturan, kerapatan spektral noise tersebut terdistribusi secara merata (merata) pada semua frekuensi, dan nilai noise dalam domain waktu terdistribusi normal (hukum distribusi Gaussian).  Karena white noise ditambahkan secara fisik ke amplitudo sinyal dalam sampel waktu yang dipilih, ini disebut Additive white Gaussian noise (AWGN). <br><br><h3>  Sinyal, Modulasi dan Manipulasi </h3><br>  Bagian ini menunjukkan metode dasar untuk mengubah satu atau lebih parameter sinyal harmonik.  Konsep amplitudo, frekuensi dan modulasi fase diperkenalkan.  Secara khusus, modulasi frekuensi linier yang digunakan dalam masalah radar disorot.  Karakteristik utama dari sinyal, spektrum sinyal termodulasi tergantung pada parameter modulasi ditampilkan. <br><br><img src="https://habrastorage.org/webt/b9/sw/c6/b9swc66eoj37yobhgypvjmwizni.png" alt="Modulasi Frekuensi"><br><br>  Untuk kenyamanan, serangkaian fungsi telah dibuat dengan Python yang mengimplementasikan jenis modulasi di atas.  Contoh implementasi sinyal kicauan: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">signal_chirp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(amp=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, freq=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, beta=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.25</span></span></span></span><span class="hljs-function"><span class="hljs-params">, period=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">100</span></span></span></span><span class="hljs-function"><span class="hljs-params">, **kwargs)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Create Chirp signal Parameters ---------- amp : float Signal magnitude beta : float Modulation bandwidth: beta &lt; N for complex, beta &lt; 0.5N for real freq : float or int Linear frequency of signal period : integer Number of points for signal (same as period) kwargs : bool Complex signal if is_complex = True Modulated by half-sine wave if is_modsine = True """</span></span> is_complex = kwargs.get(<span class="hljs-string"><span class="hljs-string">'is_complex'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) is_modsine = kwargs.get(<span class="hljs-string"><span class="hljs-string">'is_modsine'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) t = np.linspace(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, period) tt = np.pi * (freq * t + beta * t ** <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_complex <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: res = amp * (np.cos(tt) + <span class="hljs-number"><span class="hljs-number">1j</span></span> * np.sin(tt)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: res = amp * np.cos(tt) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_modsine <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res * np.sin(np.pi * t) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res</code> </pre><br><img src="https://habrastorage.org/webt/ug/ad/85/ugad85xkc0ml7p2e4kgv5niqnbs.png" alt="Modulasi kicauan"><br><br>  Juga di bagian ini dari teori transmisi jenis pesan diskrit dari modulasi digital - manipulasi dijelaskan.  Seperti dalam kasus sinyal analog, urutan harmonik digital dapat dimanipulasi dalam amplitudo, fase dan frekuensi (atau beberapa parameter sekaligus). <br><br><img src="https://habrastorage.org/webt/yl/w9/8q/ylw98qsdcnn3kaivfz2cdasrxry.png" alt="Manipulasi freq"><br><br><h3>  Filter Digital - IIR dan FIR </h3><br>  Bagian yang cukup besar yang didedikasikan untuk penyaringan digital dari urutan diskrit.  Dalam tugas pemrosesan sinyal digital, data mengalir melalui sirkuit yang disebut <b>filter</b> .  Filter digital, seperti yang analog, memiliki karakteristik berbeda - frekuensi: respons frekuensi, respons fase, waktu: respons impuls, serta karakteristik transfer filter.  Filter digital terutama digunakan untuk meningkatkan kualitas sinyal - untuk mengisolasi sinyal dari urutan data, atau untuk menurunkan sinyal yang tidak diinginkan - untuk menekan sinyal tertentu dalam urutan sampel yang masuk. <br><br><img src="https://habrastorage.org/webt/mp/2m/oy/mp2moyuibf5qgzlb19d8ne_gw-q.png" alt="Sinyal FIR IIR"><br><br>  Bagian ini mencantumkan keuntungan dan kerugian utama dari filter digital (dibandingkan dengan analog).  Konsep impuls dan karakteristik transfer filter diperkenalkan.  Dua kelas filter dipertimbangkan - dengan respon impuls tak terbatas (IIR) dan respon impuls terbatas (FIR).  Metode untuk merancang filter dalam bentuk <b>kanonik</b> dan <b>langsung</b> ditampilkan.  Untuk filter FIR, pertanyaan tentang cara beralih ke formulir rekursif dipertimbangkan. <br><br><img src="https://habrastorage.org/webt/qn/m5/x5/qnm5x5wguwanmzjfst2erf0orsa.png" alt="Skema FIR IIR"><br><br>  Untuk filter FIR, proses desain filter ditunjukkan dari tahap pengembangan spesifikasi teknis (dengan parameter utama yang ditunjukkan), hingga implementasi perangkat lunak dan perangkat keras - cari koefisien filter (dengan mempertimbangkan bentuk representasi dari angka, kedalaman bit, dll.).  Definisi filter FIR simetris, respons fase linier dan hubungannya dengan konsep keterlambatan grup diperkenalkan. <br><br><img src="https://habrastorage.org/webt/7d/ng/vy/7dngvygzcdsyc4dacklcae2ddsa.png" alt="Jalan penuh cemara"><br><br><h3>  Fungsi jendela dalam tugas penyaringan </h3><br>  Dalam tugas pemrosesan sinyal digital, fungsi jendela berbagai bentuk digunakan, yang, ketika ditumpangkan pada sinyal dalam domain waktu, secara kualitatif dapat meningkatkan karakteristik spektralnya.  Sejumlah besar berbagai jendela terutama disebabkan oleh salah satu fitur utama dari setiap hamparan jendela.  Fitur ini dinyatakan dalam hubungan antara tingkat lobus samping dan lebar lobus sentral.  Aturan: <br><blockquote>  Semakin kuat penekanan lobus samping spektrum, semakin luas lobus utama spektrum dan sebaliknya. </blockquote><br><img src="https://habrastorage.org/webt/lc/mx/em/lcmxemylmukc0mf5xtbwrudsbrm.png" alt="Menang (waktu)"><br><br>  Salah satu aplikasi fungsi jendela: deteksi sinyal lemah terhadap latar belakang sinyal yang lebih kuat dengan menekan level lobus samping.  Fungsi jendela utama dalam tugas DSP adalah ** triangular, sinusoidal, Lanczos, Hann, Hamming, Blackman, Harris, jendela Blackman-Harris, jendela flat-top, Natall, Gauss, jendela Kaiser ** dan banyak lainnya.  Sebagian besar dari mereka diekspresikan melalui seri terbatas dengan menjumlahkan sinyal harmonik dengan bobot tertentu.  Sinyal-sinyal semacam itu diimplementasikan dengan sempurna dalam praktik pada perangkat perangkat keras apa pun (sirkuit logika yang dapat diprogram atau pemroses sinyal). <br><br><img src="https://habrastorage.org/webt/qo/vo/qg/qovoqg__dcfm--hjd0ibos_m-fm.png" alt="Menang (freq)"><br><br><h3>  Resampling.  Penipisan dan interpolasi </h3><br>  Bagian ini membahas masalah pemrosesan sinyal multi-kecepatan - perubahan dalam frekuensi sampling.  Pemrosesan sinyal multi-kecepatan (pemrosesan multirate) menunjukkan bahwa dalam proses konversi linear dari sinyal digital, dimungkinkan untuk mengubah frekuensi sampling ke arah penurunan atau peningkatan, atau dalam jumlah fraksional kali.  Hal ini mengarah pada pemrosesan sinyal yang lebih efisien, karena membuka kemungkinan menggunakan frekuensi sampling minimum yang diijinkan dan, sebagai hasilnya, pengurangan yang signifikan dalam kinerja komputasi yang diperlukan dari sistem digital yang dirancang. <br><br>  <i>Penipisan</i> (penipisan) - downsampling.  <i>Interpolasi</i> - meningkatkan laju pengambilan sampel. <br><br>  Bagian ini juga mempertimbangkan kelas filter FIR homogen, yang disebut filter integral-sisir (CIC, Cascaded integrator - comb).  Implementasi, sifat dasar dan fitur filter CIC ditampilkan.  Karena linearitas operasi matematika yang terjadi dalam filter CIC, dimungkinkan untuk membuat beberapa filter berturut-turut, yang memberikan penurunan proporsional pada tingkat lobus samping, tetapi juga meningkatkan "penyumbatan" pada lobus utama dari karakteristik frekuensi amplitudo. <br><br><img src="https://habrastorage.org/webt/qg/ef/ye/qgefyerrdczmun9os1vetvxxdsy.png" alt="Filter cascade cascade"><br><br>  Grafik dari respons frekuensi filter tergantung pada koefisien penipisan: <br><br><img src="https://habrastorage.org/webt/b8/lh/qz/b8lhqzdsk-tcnqxkq9pimvteq4g.png" alt="Respon Frekuensi CIC"><br><br>  Juga di bagian ini kita membahas masalah peningkatan kedalaman bit data pada output filter CIC, tergantung pada parameternya.  Ini sangat penting dalam tugas implementasi perangkat lunak, khususnya pada FPGA. <br><br>  Untuk implementasi praktis filter CIC di Python, kelas <b>CicFilter yang</b> terpisah <b>telah dikembangkan</b> yang mengimplementasikan metode penipisan dan interpolasi.  Juga ditampilkan adalah perubahan laju sampel menggunakan metode bawaan dari paket Python yang cerdik. <br><br><div class="spoiler">  <b class="spoiler_title">Kelas Python CicFilter untuk Pemrosesan Sinyal Digital</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CicFilter</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Cascaded Integrator-Comb (CIC) filter is an optimized class of finite impulse response (FIR) filter. CIC filter combines an interpolator or decimator, so it has some parameters: R - decimation or interpolation ratio, N - number of stages in filter (or filter order) M - number of samples per stage (1 or 2)* * for this realisation of CIC filter just leave M = 1. CIC filter is used in multi-rate processing. In hardware applications CIC filter doesn't need multipliers, just only adders / subtractors and delay lines. Equation for 1st order CIC filter: y[n] = x[n] - x[n-RM] + y[n-1]. Parameters ---------- x : np.array input signal """</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, x)</span></span></span><span class="hljs-function">:</span></span> self.x = x <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decimator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, r, n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" CIC decimator: Integrator + Decimator + Comb Parameters ---------- r : int decimation rate n : int filter order """</span></span> <span class="hljs-comment"><span class="hljs-comment"># integrator y = self.x[:] for i in range(n): y = np.cumsum(y) # decimator y = y[::r] # comb stage return np.diff(y, n=n, prepend=np.zeros(n)) def interpolator(self, r, n, mode=False): """ CIC inteprolator: Comb + Decimator + Integrator Parameters ---------- r : int interpolation rate n : int filter order mode : bool False - zero padding, True - value padding. """ # comb stage y = np.diff(self.x, n=n, prepend=np.zeros(n), append=np.zeros(n)) # interpolation if mode: y = np.repeat(y, r) else: y = np.array([i if j == 0 else 0 for i in y for j in range(r)]) # integrator for i in range(n): y = np.cumsum(y) if mode: return y[1:1 - n * r] else: return y[r - 1:-n * r + r - 1]</span></span></code> </pre><br></div></div><br><br><img src="https://habrastorage.org/webt/mt/ri/b5/mtrib5pqroyzezup5m9ulqsklzg.png" alt="Decimation / Interpolasi CIC"><br><br>  Akhirnya, bagian ini menyediakan kelas filter khusus - rata-rata bergerak.  Tiga metode implementasi ditunjukkan: melalui konvolusi sinyal, menggunakan filter FIR dan filter IIR. <br><br><img src="https://habrastorage.org/webt/0m/b7/rf/0mb7rfvv_e6vuzt9xqsumvgs7eq.png" alt="MAF, filter Moving Average"><br><br><h3>  Kesimpulan </h3><br>  Saya harap kursus kuliah ini bersama dengan artikel saya sebelumnya tentang pemrosesan sinyal FPGA digital akan membawa manfaat praktis dan membantu pembaca lebih memahami dasar-dasar pemrosesan sinyal digital.  Proyek ini akan ditingkatkan dan dilengkapi dengan materi baru yang bermanfaat dan tidak kalah menarik.  Ikuti perkembangannya! <br><br>  Selain materi ini, saya mendukung dan mengembangkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek saya</a> pada modul DSP utama (dengan Python).  Ini berisi paket untuk menghasilkan berbagai sinyal, kelas filter CIC untuk masalah penipisan dan interpolasi, algoritma untuk menghitung koefisien filter FIR yang diperbaiki, filter rata-rata bergerak, algoritma untuk menghitung FFT yang sangat panjang melalui metode konversi dua dimensi (yang terakhir ini sangat berguna ketika bekerja dengan implementasi perangkat keras pada FPGA) . <br><br>  Terima kasih atas perhatian anda! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460445/">https://habr.com/ru/post/id460445/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460435/index.html">Petty little joy # 8: kesenangan kecil untuk bekerja dengan database</a></li>
<li><a href="../id460437/index.html">Bagaimana kami mengeluarkan sepeda dukungan teknis</a></li>
<li><a href="../id460439/index.html">Bahasa pemrograman P4</a></li>
<li><a href="../id460441/index.html">Gleb Nitzman: "Saya menemukan akhir zaman ketika orang belum mengejar emas yang terkandung dalam elemen radio"</a></li>
<li><a href="../id460443/index.html">Desainer vs pengembang: tentang sejarah pembuatan aplikasi "Kota pintar saya"</a></li>
<li><a href="../id460451/index.html">Manusia membuat telinga ketiga untuk digunakan seluruh dunia - demi seni</a></li>
<li><a href="../id460453/index.html">Printer pintar. Meningkatkan Octoprint</a></li>
<li><a href="../id460457/index.html">Pembangkit listrik tenaga surya DIY 200 m2</a></li>
<li><a href="../id460459/index.html">File konfigurasi htaccess</a></li>
<li><a href="../id460461/index.html">Simulasi serangan yang ditargetkan sebagai penilaian keamanan. Instruksi Cyber â€‹â€‹Teaming Merah</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>