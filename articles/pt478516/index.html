<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔪 🧘🏼 🌿 Estradas processuais em Houdini e Unity 🌂 ✊🏼 ✊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No meu jogo pós-apocalíptico de Frameshift, eu precisava preencher um mundo aberto muito grande com diversas cidades. Nossa equipe tem apenas 3 pessoa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Estradas processuais em Houdini e Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/478516/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/568/18c/687/56818c687d0b46587a12baae541c25aa.jpg" alt="imagem"></div><br>  No meu jogo pós-apocalíptico de <a href="http://www.frameshiftgame.com/">Frameshift,</a> eu precisava preencher um mundo aberto muito grande com diversas cidades.  Nossa equipe tem apenas 3 pessoas, então eu, é claro, usei o poder processual de Houdini! <br><br>  Antes, quando eu não conhecia o Houdini, escrevi em C # minhas próprias ferramentas para geração de malhas procedurais para o Unity.  A adição de novos recursos foi um processo muito longo, e quando ouvi dizer que o Houdini foi projetado para essas tarefas, mudei imediatamente para ele.  Eu experimentei diferentes maneiras de gerar cidades e ruas e, neste artigo, falarei brevemente sobre a técnica que finalmente usei para o jogo. <br><br>  Primeiro, criei uma ferramenta para gerar uma rede de ruas que poderia ser usada na cidade.  Minha decisão é baseada nos conceitos apresentados <a href="https://martindevans.me/game-development/2015/12/11/Procedural-Generation-For-Dummies-Roads/">aqui</a> , bem como no artigo usado por referência.  Fala-se muito em campos tensores e autovetores, e tudo é escrito muito tecnicamente, mas, em poucas palavras, pode ser explicado da seguinte forma: para o meu caso (gerar uma rede viária em relevo), eu precisava gerar linhas de alívio de contorno e linhas perpendiculares a eles. <br><a name="habracut"></a><br>  Comecei com o relevo e, graças a uma pequena ajuda do exemplo de Houdini Gubbins, gerei vetores em cada ponto do relevo direcionado para o caminho e linhas de gradiente usando o VEX: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dee/217/deb/dee217deb59d8113034a63982c548bec.jpg" alt="imagem"></div><br>  Vetores amarelos mostram linhas de contorno. <br><br>  Então precisamos criar uma grade de ruas da cidade e misturar seus vetores com vetores repetindo as curvas naturais do relevo.  Então, criaremos uma área que se assemelha a uma grade de ruas da cidade, combinando bem com o relevo.  Aqui, colocamos a grade no relevo e, em seguida, fazemos a polyframing para que os normais se alinhem ao longo das linhas da grade, adicionem uma queda para uma mistura suave e finalmente definam um novo vetor de caminho, que é uma mistura de dois vetores: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fe2/714/b7a/fe2714b7a36cfe05f10bbd7f40026c48.jpg" alt="imagem"></div><br>  Na imagem acima, você pode ver que dentro das bordas do retângulo, as linhas de contorno são mais como uma grade.  Também realizo um processo semelhante para adicionar ao jogo a influência de estradas criadas manualmente.  Eu introduzi um controle deslizante no Unity HDA para que a influência possa ser alterada criando ruas mais naturalmente localizadas ou mais "quadradas" dentro dos limites da cidade. <br><br>  Em seguida, converterei os campos vetoriais em VDB para que você possa fazer uma amostra deles para criar estradas prontas.  Com o rastreamento de volume SOP, você pode obter uma bela visualização: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/caa/e3f/a80/caae3fa80d45d81547bd39f517cf7aa8.jpg" alt="imagem"></div><br>  Já está começando a parecer uma grade de ruas!  Eles estão muito próximos um do outro, mas em geral já existem formas.  Em seguida, realizamos muitas operações de amostragem a partir de velocidades VDB e vex para criar linhas de estradas prontas.  O código vex essencialmente organiza as estradas para a distância certa e as termina se elas estiverem muito próximas de outras ou por muito tempo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca4/134/e49/ca4134e492093e6d009c242a3a0b9bbf.jpg" alt="imagem"></div><br>  Em seguida, realizamos o pós-processamento para facilitar tudo, remover pequenas peças, aumentar os becos sem saída para criar cruzamentos realistas e colocar estradas no terreno.  O resultado final é assim: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f63/5f0/676/f635f06766464e3972bd2f5bdef9fe8a.jpg" alt="imagem"></div><br>  Ainda existem algumas partes irreais, mas uma pequena limpeza manual no Unity é aceitável, dado o tempo que economizamos nisso. <br><br>  Assim, geramos processualmente uma rede de ruas da cidade, mas o resultado foi apenas um monte de curvas em Houdini.  Agora, mostrarei como gerar a geometria da estrada para cada uma dessas curvas para criar malhas que você pode usar no Unity.  Aqui estão nossos resultados anteriores portados para o Unity: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07f/f2b/f41/07ff2bf4179457571247eaa324dfab76.jpg" alt="imagem"></div><br>  Primeiro, você precisa dizer como é realizada a transferência de dados entre o Houdini e o Unity.  No caso de estradas, escrevo no arquivo JSON uma sequência de pontos, a largura da estrada e a predefinição da superfície da estrada.  No Unity, criei ferramentas de editor para editar estradas manualmente usando curvas de Bezier: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/427/4dc/dc2/4274dcdc22ad6ad06a14720a26db71dc.jpg" alt="imagem"></div><br>  Você pode encontrar muitos tutoriais nos mecanismos de pesquisa sobre a criação de um editor de curvas de Bezier no Unity.  Para transferir dados de volta para o Houdini, eu uso o nó Python para ler o arquivo JSON: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d31/1d9/3d6/d311d93d6179adbcf9e56c923a0ceb76.jpg" alt="imagem"></div><br>  Aqui você vê o resultado da criação de uma rede de ruas urbanas, obtida acima, mas desta vez é lida no arquivo JSON, porque agora é obtida no Unity com alterações manuais. <br><br>  Também importo um alívio do Unity, lendo seus dados brutos.  Provavelmente hoje em dia isso pode ser feito de forma nativa com a ajuda do HDA, porque o Houdini Engine melhorou o suporte ao terreno do Unity, mas quando eu fiz esse trabalho, ele ainda não era tão bom. <br><br>  Então criamos as interseções.  O trabalho principal aqui é realizado pelo SOP de ponto de interseção, mas também usei o VEX para alongar levemente as estradas, caso elas não se cruzassem completamente, e removi as extremidades curtas para que as interseções em T fossem criadas corretamente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a89/a67/6ba/a89a676bab14b697eae4bad76b7e0596.jpg" alt="imagem"></div><br>  Em seguida, crio um grupo de interseções usando falloff da interseção, em que a distância de atenuação é igual à maior na interseção da estrada.  Em seguida, expanda esse grupo de arestas nos casos em que o ângulo entre duas estradas é menor que 45 graus, para que haja espaço suficiente entre as duas extremidades da interseção para criar uma malha da largura desejada: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9d8/746/6ab/9d87466abdd52316e033d330e014e91a.jpg" alt="imagem"></div><br>  Os cálculos no nó VEX encontram a hipotenusa de um triângulo retângulo (podemos assumir que cada parte individual da interseção consiste em dois triângulos retos): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/46b/bd7/54e/46bbd754e96f47cb9c0a1900479d4d8f.jpg" alt="imagem"></div><br>  Como sabemos qual deve ser a largura das estradas do grupo de interseção (indicado na figura acima como A) e sabemos o ângulo a, podemos calcular C para encontrar a distância pela qual precisamos expandir o grupo de interseção para dividi-los pela largura desejada. <br><br>  Em seguida, criamos grupos de pontes, destacando trechos de estradas que estão acima de uma certa distância acima do solo.  Isso é feito usando o Ray SOP com "distância de interseção do ponto" ativada e "pontos de transformação" desativados.  Em seguida, para criar curvas prontas para a geometria de fechamento, usamos o Polycut para cortar os grupos de interseção e ponte para que apenas as estradas comuns permaneçam. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba6/f23/20e/ba6f2320ee5ef2d21ea175ffd165745d.jpg" alt="imagem"></div><br>  E agora estamos finalmente começando a criar malhas reais.  A sub-rede que cria as malhas de interseção é uma versão modificada do tutorial <a href="https://www.youtube.com/watch%3Fv%3DbTlY9ahThdQ">Solving Intersections</a> .  A sub-rede que cria a geometria da estrada também fecha a linha e cria UV.  Há outro <a href="https://www.youtube.com/watch%3Fv%3DPhz3BTwFWRg">ótimo tutorial</a> criado pelo HoudiniSimon.  Ele mostra como gerar UV para dobrar uma curva fechada, mas a primeira parte do tutorial pode ser aplicada para abrir curvas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9de/e86/dc7/9dee86dc7cebd4307bc8f1fb36788729.jpg" alt="imagem"></div><br>  Depois, criei alguns grupos para aplicar os materiais para usar o atributo roadPreset retirado das minhas curvas no Unity. <br><br>  Em seguida, criamos a geometria das pontes.  A rede mostrada abaixo iterativamente passa por todos os grupos de pontes criados anteriormente e, dependendo da altura acima do solo, comprimento e tortuosidade, insere uma ponte em massa ou em arco.  Considerarei a criação de uma ponte em arco em um tutorial separado, e a ponte em massa usa o excelente SOP Gamedev Sweep Geometry com grupos de início e término incluídos para fechar a geometria da ponte criada anteriormente ao longo da curva da ponte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecb/3a9/a4a/ecb3a9a4a4adc5850a5c9cd034e5a53d.jpg" alt="imagem"></div><br>  Resultado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ba/97d/2a2/3ba97d2a271417b4c9cc04770b582e82.jpg" alt="imagem"></div><br>  Essas malhas de ponte consistem em seções de início / fim / meio modeladas manualmente, deformáveis ​​e duplicadas ao longo de uma curva usando o SOP da Gamedev Sweep Geometry.  Veja como são a geometria e os grupos criados manualmente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/374/c63/31a/374c6331ab3ede724c1ee021e764b4af.jpg" alt="imagem"></div><br>  O grupo central é selecionado e as extremidades estão nos grupos bridgeStart e bridgeEnd, que são usados ​​pelo nó de fechamento da geometria. <br><br>  Concluímos a ponte extrudando-a um pouco para criar um aterro na estrada em que a textura do cascalho será aplicada;  Várias variáveis ​​booleanas também são definidas para cruzamentos de certos tipos de estradas.  Por exemplo, se uma estrada de terra cruzar com uma estrada, ela será truncada. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/757/b56/51f/757b5651fb3f61f8fdc2c599681f889a.jpg" alt="imagem"></div><br>  No final, economizamos toda a geometria para uso no Unity e em ferramentas adicionais do Houdini.  Dividimos as malhas da estrada em fragmentos menores e exportamos como FBX e também salvamos os dados em arquivos .bgeo para que possam ser usados ​​posteriormente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c14/25f/e51/c1425fe512c31cfd32bea68d374a9b08.jpg" alt="imagem"></div><br>  Na unidade: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b17/1ce/5b5/b171ce5b56dd71d8d3f548443516c6b6.jpg" alt="imagem"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ef/78f/21d/2ef78f21d1d1fd203549938d5e855cad.jpg" alt="imagem"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/568/18c/687/56818c687d0b46587a12baae541c25aa.jpg" alt="imagem"></div><br>  Espero que você tenha gostado desta breve descrição do nosso processo de criação de geometria de estradas Houdini.  No próximo post, falarei sobre a criação de marcações nas estradas e o nivelamento do terreno para que ele se aproxime mais das estradas. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt478516/">https://habr.com/ru/post/pt478516/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt478502/index.html">Tecnologia inteligente para todos</a></li>
<li><a href="../pt478504/index.html">Como o local de trabalho se transforma com a evolução do laptop</a></li>
<li><a href="../pt478508/index.html">Telegrama como serviço</a></li>
<li><a href="../pt478510/index.html">Convidamos você para o DINS QA EVENING 12/12/19: crie um pipeline Jenkins e aprenda a paralelizar o lançamento de testes com a ajuda deles</a></li>
<li><a href="../pt478514/index.html">Usando dados criptografados para aprendizado de máquina sem descriptografá-los</a></li>
<li><a href="../pt478518/index.html">Experiência na implantação da infraestrutura do escritório no Zextras / Zimbra OSE</a></li>
<li><a href="../pt478522/index.html">Admita, Watson, você está completamente perplexo?</a></li>
<li><a href="../pt478526/index.html">Um monte de OpenVPN no Windows Server e Mikrotik com a migração dessas coisas para o Linux</a></li>
<li><a href="../pt478528/index.html">Pet (uma história fantástica)</a></li>
<li><a href="../pt478530/index.html">TechnoText-2019: quem venceu no final e para que serve</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>