<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ—£ï¸ ğŸ‘©â€ğŸš’ ğŸš‚ Devops, JUnit5 dan pengujian layanan mikro: pandangan subyektif pada Moscow Heisenbag ğŸŒ¨ï¸ ğŸ‘™ ğŸ¤’</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada 6-7 Desember, konferensi Heisenbag kelima diadakan di Moskow. 
 Slogannya adalah "Menguji. Bukan hanya untuk penguji! â€, Dan selama dua tahun kun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Devops, JUnit5 dan pengujian layanan mikro: pandangan subyektif pada Moscow Heisenbag</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432736/"><img src="https://habrastorage.org/webt/yy/ey/ao/yyeyao2gdkf5rkv4vqbkhwdnic8.jpeg"><br><br>  Pada 6-7 Desember, konferensi Heisenbag kelima diadakan di Moskow. <br>  Slogannya adalah "Menguji.  Bukan hanya untuk penguji! â€, Dan selama dua tahun kunjungan rutin ke Heisenbags, saya (sebelumnya pengembang Java, sekarang menjadi pemimpin teknis di sebuah perusahaan kecil yang tidak pernah bekerja di QA) berhasil belajar banyak dalam pengujian dan mengimplementasikan banyak hal dalam tim kami.  Saya ingin berbagi ulasan subjektif dari laporan yang saya ingat saat ini. <br><a name="habracut"></a><br>  <b>Penafian.</b>  Tentu saja, ini hanya sebagian kecil (8 dari 30) laporan yang dipilih berdasarkan preferensi pribadi saya.  Hampir semua laporan ini entah bagaimana terkait dengan Java dan tidak ada satu pun tentang front-end dan pengembangan ponsel.  Di beberapa tempat saya akan membiarkan diri saya polemik dengan pembicara.  Jika Anda tertarik pada ulasan yang lebih lengkap dan netral, menurut tradisi itu akan muncul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di blog penyelenggara</a> .  Tetapi, mungkin, akan menarik bagi seseorang untuk mengetahui hanya tentang laporan-laporan yang tidak dapat mereka kunjungi. <br><br>  <i>Foto dalam artikel tersebut berasal dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter resmi</a> konferensi.</i> <br><br><h3>  Baruch Sadogursky.  Kami memiliki DevOps.  Mari kita memecat semua penguji </h3><br><img src="https://habrastorage.org/webt/ht/my/tt/htmyttor7b0ij-jr5dx4ydosj0w.jpeg"><br>  <i>(Dalam foto - hype ketika Baruch mendistribusikan buku <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Liquid Software</a> )</i> <br><br>  Mereka yang terlibat di Jawa dan menghadiri konferensi JUGRU Group, Baruch Sadogursky tidak perlu diperkenalkan.  Namun, ia tampil untuk pertama kalinya di Heisenbug. <br><br>  Singkatnya - itu adalah laporan ulasan tentang ide-ide utama DevOps.  Kebutuhan audiens akan laporan semacam itu tetap ada, karena ketika ditanya "Berikan definisi DevOps" kepada audiens, orang pertama-tama masih menjawab "ini orang yang seperti itu ..." <br><br>  Tetapi bahkan mereka yang telah mempelajari sesuatu tentang topik ini, akan sangat menarik untuk belajar tentang studi-studi dari asosiasi DORA <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">devops-research.com</a> , yang menerima persentase varietas pekerjaan manual dalam tim dengan kinerja yang berbeda.  Dan tentang kurva yang menghubungkan kecepatan dan kualitas pengiriman (pada titik tertentu, kecepatan menurun, karena kita perlu waktu untuk "tes yang lebih baik", tetapi ketika tim berkembang, korelasinya menjadi langsung): <br><br><img src="https://habrastorage.org/webt/fw/8v/8o/fw8v8ocre1tvccsgnwvihwc7eaw.png" width="400"><br><br>  Meskipun judul laporan itu provokatif, dan dalam jadwal laporan itu ditandai dengan kategori "akan terbakar", isinya, menurut saya, cukup umum.  Itu, tentu saja, bukan tentang pemecatan penguji di bawah kondisi transformasi Devops, tetapi tentang perubahan sifat pekerjaan penguji.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alan Page</a> dan Nikolai Alimenkov berbicara banyak tentang hal ini setahun yang lalu.  Baik peran yang berubah dan pengembangan "horisontal" keterampilan berbentuk T dibahas setahun lalu di meja bundar " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">apa yang harus diketahui oleh seorang penguji pada tahun 2018</a> ". <br><br>  â€œTentu saja, jika kamu tidak ingin berubah, ada pekerjaan untukmu, meskipun tidak begitu menarik.  Sejauh ini, masih ada pekerjaan untuk mereka yang ingin mendukung sistem yang ditulis dalam COBOL di tahun 70-an, â€kata Baruch. <br><br><h3>  Artyom Eroshenko.  Perlu merevisi proyek?  Punya IDEA! </h3><br><img src="https://habrastorage.org/webt/nz/i0/hm/nzi0hmxhws-r45ww43c8bl8lsr0.jpeg"><br><br>  Artyom akrab bagi peserta Heisenbag dengan laporan tentang sistem pelaporan Allure (misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">inilah laporannya</a> tentang peluang Allure yang muncul pada 2018 dari Heisenbug sebelumnya di St. Petersburg).  Allure sendiri lahir dalam konteks proyek dengan ribuan, puluhan ribu dan bahkan lebih dari ratusan ribu tes dan dirancang untuk menyederhanakan interaksi antara pengembang dan penguji.  Ini memiliki kemampuan untuk menghubungkan tes dengan sumber daya eksternal seperti sistem tiket dan melakukan dalam sistem kontrol versi.  Di tim mikro kami, sementara jumlah tes hanya mencapai puluhan, kami sepenuhnya mengatasi sarana standar.  Tetapi ketika jumlah tes di salah satu produk mencapai 700 dan tugas keseluruhannya adalah untuk membuat laporan berkualitas tinggi bagi pelanggan, saya mulai melihat ke arah Allure. <br><br>  Namun, laporan ini bukan tentang Allure, meskipun tentang dia juga. <br><br>  Artyom meyakinkan publik bahwa menulis plugin untuk IntelliJ IDEA adalah kegiatan yang sederhana dan menarik.  Mengapa ini diperlukan?  Untuk mengotomatisasi modifikasi kode massal.  Misalnya, untuk menerjemahkan sejumlah besar kode sumber dari JUnit4 ke JUnit5.  Atau dari penggunaan Allure 1 hingga Allure 2. Atau untuk mengotomatiskan penandaan tes dengan komunikasi dengan sistem detak. <br><br>  Mereka yang bekerja dengan IDEA tahu trik apa yang dapat dilakukan dengan kode (misalnya, menerjemahkan kode secara otomatis menggunakan for-loop ke dalam kode menggunakan Java Streaming dan sebaliknya, atau langsung menerjemahkan Java ke Kotlin).  Yang lebih menarik adalah melihat bagaimana tabir kerahasiaan atas transformasi kode di IDEA dibuka, kami diundang untuk mengambil bagian dalam hal ini dan membuat plugin sendiri untuk kebutuhan unik kami.  Lain kali, ketika saya perlu melakukan sesuatu dengan basis kode yang besar, saya akan mengingat laporan ini dan melihat bagaimana ini dapat diotomatisasi menggunakan plug-in generik di IDEA. <br><br><h3>  Kirill Merkushev.  Proyek Java dan Reactor - bagaimana dengan tes? </h3><br><img src="https://habrastorage.org/webt/35/u5/ze/35u5zepym4if2dyz-hwev3e0_mg.jpeg"><br><br>  Menurut saya, laporan ini bisa saja terjadi di konferensi Joker atau JPoint Java.  Kirill berbicara tentang bagaimana ia menggunakan kerangka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">projectreactor.io</a> dalam arsitektur layanan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">microsoft</a> dengan log peristiwa tunggal (Kafka), sedikit tentang esensi pengkodean pada "aliran reaktif", termasuk bagaimana aplikasi yang menggunakan kerangka kerja ini dapat di-debug dan diuji. <br><br>  Life juga mendorong tim kami untuk menggunakan arsitektur dengan satu event log, dan kami juga melihat Kafka.  Benar, untuk acara streaming, kami bereksperimen dengan Kafka Streams API (di mana, menurut saya, lebih banyak hal seperti pemrosesan stateful diimplementasikan di luar kotak secara transparan untuk pengembang), dan bukan Reactor.  Namun, seperti yang selalu terjadi dengan teknologi baru, "rake" dan "jebakan" tidak diketahui sebelumnya.  Karena itu, penting untuk mendengarkan kisah seorang spesialis yang sudah bekerja dengan teknologi. <br><br><h3>  Leonid Rudenko.  Mengelola Cluster Selenoid dengan Terraform </h3><br><img src="https://habrastorage.org/webt/6h/xu/s8/6hxus8uek7c3xoztsywkvfwlqlq.jpeg"><br><br>  Jika laporan sebelumnya mengingatkan pada konferensi JPoint, maka yang ini tentu tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DevOops</a> .  Leonid berbicara tentang cara menggunakan spesifikasi Terraform untuk menaikkan dan mengkonfigurasi cluster Selenoid.  Tentang apa itu Selenoid itu sendiri, ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan</a> tentang Heisenbug tahun lalu - ini adalah sistem terdistribusi yang kaya yang berfungsi sebagai layanan elastis dan memungkinkan Anda untuk menjalankan sejumlah besar tes Selenium di berbagai browser.  Seperti sistem apa pun yang membutuhkan penyebaran pada beberapa mesin, menginstal Selenoid secara manual sulit.  Di sini, sistem Konfigurasi-sebagai-Kode modern datang untuk menyelamatkan. <br><br>  Leonid membuat tinjauan yang cukup terperinci tentang kemampuan Terraform - sebuah sistem yang mungkin tidak dikenal oleh sebagian besar pemirsa, tetapi sebenarnya sudah terkenal dengan DevOps-automation (misalnya, pada konferensi Devoops-2018 ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan yang sangat baik oleh</a> Anton Babenko tentang praktik terbaik untuk membuat dan memelihara kode pada Terraform).  Lebih lanjut, diperlihatkan bagaimana menggunakan skrip Terraform untuk menggambarkan parameter kontainer buruh pelabuhan dengan Selenoid untuk masing-masing mesin di cluster dan parameter dari mesin virtual cluster itu sendiri. <br><br>  Meskipun kasus spesifik yang dipertimbangkan oleh Leonid tentu saja dapat memudahkan tugas penempatan Selenoid, saya tidak setuju dengan pembicara tentang segalanya.  Pada dasarnya, ia menggunakan Terraform untuk dua tugas berbeda: membuat sumber daya dan mengonfigurasinya.  Dan ini mengarah pada fakta bahwa Leonid terpaksa menjalankan Terraform sekali untuk membuat mesin virtual dan sekali lagi untuk masing-masing mesin virtual untuk menaikkan kontainer buruh pelabuhan.  Menurut pendapat saya, Terraform, yang memecahkan masalah membuat sumber daya dengan baik, tidak menyelesaikan masalah konfigurasi dengan sangat baik.  Adalah mungkin untuk menghindari penggandaan proyek terraform dan beberapa peluncurannya menggunakan sistem konfigurasi khusus, misalnya Ansible, atau solusi lain. <br><br>  Tetapi secara umum, sebagai "program pendidikan" untuk penguji di bidang Infrastruktur sebagai Kode, laporan ini sangat berguna. <br><br><h3>  Andrey Markelov.  Pengujian integrasi elegan kebun binatang microservice dengan TestContainers dan JUnit 5 menggunakan contoh platform SMS global </h3><br><img src="https://habrastorage.org/webt/rk/3d/mo/rk3dmodcrkabye2qc8mdl_vskws.jpeg"><br><br>  Dan lagi tentang layanan microser!  Kali ini, percakapannya adalah tentang bagaimana menjalankan tes yang memerlukan peluncuran dan interaksi beberapa layanan pada saat yang sama.  JUnit5 dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sistem Ekstensi</a> dan kerangka kerja TestContain yang terkenal (dan sangat bagus) diusulkan sebagai dasar solusi (lihat, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan tahun lalu oleh Sergey Egorov</a> ). <br><br>  Jika Anda menulis sesuatu di Java dan masih tidak tahu apa itu TestContainers, saya sangat menyarankan Anda mempelajarinya.  TestContainers memungkinkan, menggunakan teknologi Docker, langsung dalam kode uji untuk meningkatkan basis data nyata dan layanan lainnya, menghubungkannya melalui jaringan dan, sebagai hasilnya, melakukan pengujian integrasi di lingkungan yang dibuat pada saat pengujian diluncurkan dan dihancurkan segera setelah itu.  Pada saat yang sama, semuanya bekerja langsung dari kode Java, terhubung sebagai ketergantungan Maven dan tidak perlu menginstal apa pun selain Docker di server mesin / CI pengembang.  Kami telah menggunakan TestContainers selama lebih dari satu tahun sekarang. <br><br>  Andrey menunjukkan contoh yang cukup mengesankan tentang bagaimana Anda dapat meresepkan konfigurasi lingkungan pengujian untuk pengujian ujung-ke-ujung menggunakan JUnit5 Extensions, anotasi khusus, dan TestContainers.  Misalnya, menulis anotasi di atas pengujian Anda (kode kondisional) <br><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Billing</span></span> <span class="hljs-meta"><span class="hljs-meta">@Messaging</span></span></code> </pre> <br>  kita dapat, secara relatif, menulis <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">systemIsDoingRightThings</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BillingService b, MessagingService m)</span></span></span><span class="hljs-function"> </span></span>{...}</code> </pre><br>  ke dalam parameter yang antarmuka Java akan dilewati di mana Anda dapat berkomunikasi dengan layanan nyata yang diangkat (tanpa disadari oleh pengembang tes) dalam wadah. <br><br>  Contoh-contoh ini terlihat sangat elegan.  Bagi saya, sebagai pengguna aktif TestContainers dan JUnit 5, mereka dapat dimengerti dan relatif mudah diimplementasikan. <br><br>  Tetapi secara umum, dengan pendekatan ini, pertanyaan besar tetap tidak terselesaikan, terkait dengan fakta bahwa cara mengkonfigurasi sistem pengujian dan produksi pada dasarnya berbeda. <br><br>  Menerapkan rilis cepat dalam produksi tanpa takut merusak semuanya adalah mungkin hanya jika selama pengujian end-to-end tidak hanya seluruh sistem diuji, tetapi juga cara untuk mengkonfigurasinya.  Jika kami berulang kali menjalankan skrip penyebaran sistem selama proses pengembangan dan pengujian, kami tidak akan ragu bahwa skrip ini akan berfungsi bahkan ketika diluncurkan dalam produksi.  Peran kode yang mengonfigurasi lingkungan pengujian dalam contoh Andrey dilakukan oleh anotasi.  Tetapi dalam produksi kami membuat sistem menggunakan kode yang sama sekali berbeda - Kemungkinan, Kubernetes, apa pun - tidak terlibat dengan cara apa pun dengan pengujian sistem tersebut.  Dan ini membatasi tes ini, yang tidak sepenuhnya ujung ke ujung. <br><br><h3>  Andrey Glazkov.  Sistem pengujian dengan dependensi eksternal: masalah, solusi, Mountebank </h3><br><img src="https://habrastorage.org/webt/rc/u5/pm/rcu5pm2i_wcdfacaaglje5bcqmy.jpeg"><br><br>  Bagi mereka yang topik laporannya relevan, saya sangat menyarankan Anda untuk menonton <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">presentasi yang bagus oleh Andrei Solntsev</a> tentang pendekatan berprinsip pada sistem pengujian yang bergantung pada layanan eksternal.  Solntsev berbicara dengan sangat meyakinkan tentang perlunya menggunakan tiruan sistem eksternal untuk pengujian komprehensif.  Dan Andrei Glazkov dalam laporannya menggambarkan salah satu sistem untuk pembasahan seperti itu - Mountebank, ditulis dalam NodeJS. <br><br>  Anda dapat mengangkat Mountebank sebagai server dan "melatih" jawaban atas permintaan melalui jaringan dengan cara yang mirip dengan cara kami "melatih" antarmuka mengejek ketika menulis unit test.  Satu-satunya perbedaan adalah bahwa itu adalah tiruan dari layanan jaringan.  Kasus aneh menggunakan Mountebank adalah kemampuan untuk menggunakannya sebagai proxy - mengirim beberapa permintaan ke sistem eksternal nyata. <br><br>  Perlu dicatat di sini bahwa saya akan merekomendasikan bahwa pengembang Java (dan Andrei setuju di area diskusi) juga melihat ke perpustakaan WireMock, yang dibuat di Java dan dapat dijalankan dalam mode tertanam, yaitu langsung dari tes tanpa menginstal apapun Entah layanan ke mesin pengembang atau server CI (meskipun juga dapat berfungsi sebagai server mandiri).  Seperti halnya Mountebank, WireMock mendukung mode proxy.  Kami memiliki pengalaman positif dengan WireMock. <br><br>  Keuntungan Mountebank, bagaimanapun, adalah dukungan protokol tingkat rendah (WireMock hanya berfungsi untuk HTTP) dan kemampuan untuk bekerja di "kebun binatang" berbagai teknologi (ada perpustakaan untuk berbagai bahasa untuk Mountebank). <br><br><h3>  Kirill Tolkachev.  Menguji dan menangis dengan Uji Boot Spring </h3><br><img src="https://habrastorage.org/webt/k0/zu/tc/k0zutcg8ntbu0_a4suehr0lsqww.jpeg"><br><br>  Dan lagi Java, microservices dan JUnit 5. Kirill adalah pembicara lain dari konferensi Joker dan JPoint, yang terkenal di komunitas Jawa, yang berbicara untuk pertama kalinya di Heisenbug. <br><br>  Laporan ini adalah versi modifikasi dari laporan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Musim Semi Kutukan</a> tahun lalu, dengan contoh-contoh yang dimodifikasi untuk JUnit5 dan Spring Boot 2. Berbagai masalah praktis terkait dengan mengkonfigurasi tes Spring Boot dalam pengujian komponen / layanan mikro diperiksa secara mendalam.  Sebagai contoh, saya terkesan dengan contoh menggunakan <code>@SpringBootConfiguration StopConfiguration</code> kosong di tempat yang tepat di pohon sumber untuk menghentikan proses pemindaian konfigurasi, serta kemungkinan menggunakan <code>@MockBean</code> dan <code>@SpyBean</code> bukannya mengolok-olok.  Seperti laporan lain oleh Cyril dan Evgeny Borisov, ini adalah bahan yang masuk akal untuk kembali ke dalam proses penggunaan praktis dari Kerangka Kerja Pegas. <br><br><h3>  Andrey Karpov.  Apa yang dapat dilakukan oleh penganalisa statis, yang tidak dapat dilakukan oleh programmer dan penguji </h3><br><img src="https://habrastorage.org/webt/ze/xw/5b/zexw5bvquuivqfswlpzhocrx4pe.jpeg"><br><br>  Analisis kode statis adalah hal yang baik.  Menurut kanon Pengiriman Kontinu, itu harus menjadi fase pertama dari pipa pengiriman, menyaring kode dengan masalah yang dapat dideteksi dengan "membaca" kode tersebut.  Analisis statis baik karena cepat (jauh lebih cepat daripada tes) dan murah (tidak memerlukan upaya tambahan dari tim dalam bentuk tes menulis: semua cek telah ditulis oleh penulis penganalisis). <br><br>  Andrey Karpov, salah satu pendiri proyek PVS-Studio (yang akrab dengan pembaca Habr dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blognya</a> ) membuat laporan tentang contoh bug apa dalam analisis kode produk yang dikenal yang ditemukan menggunakan PVS-Studio.  PVS Studio sendiri adalah produk polyglot, mendukung C, C ++, C # dan, yang lebih baru, Java. <br><br>  Terlepas dari kenyataan bahwa contoh-contoh di atas menarik dan kegunaan analisis statis mereka jelas, menurut pendapat saya, laporan Andrey memiliki kekurangan. <br><br>  Pertama, laporan itu dibuat semata-mata berdasarkan pertimbangan produk PVS-Studio (yang menurut pembicara, "label harga rata-rata adalah $ 10.000").  Tetapi perlu disebutkan bahwa, pada kenyataannya, dalam banyak bahasa ada banyak sistem analisis statis OpenSource yang dikembangkan.  Di Jawa saja - Checkstyle dan SpotBugs gratis (penerus proyek FindBugs yang dibekukan), serta penganalisa IntelliJ IDEA, yang dapat dijalankan secara terpisah dari IDE dan menerima laporan, membuat kemajuan luar biasa. <br><br>  Kedua, berbicara tentang analisis statis, bagi saya tampaknya selalu menyebutkan keterbatasan mendasar dari metode ini.  Tidak semua orang melalui teori algoritma di universitas dan terbiasa dengan "masalah shutdown," misalnya. <br><br>  Dan akhirnya, masalah memperkenalkan analisis statis ke dalam basis kode yang ada tidak diangkat sama sekali, yang masih mencegah banyak dari penggunaan analisis yang rutin pada proyek.  Sebagai contoh, kami menjalankan analisa pada proyek warisan besar dan menemukan 100.500 vorings.  Tidak ada waktu dan upaya untuk memperbaikinya di tempat, dan secara besar-besaran mengubah sesuatu dalam kode adalah risiko.  Apa yang harus dilakukan dengan ini, bagaimana membuat analisis statis berfungsi sebagai gerbang kualitas?  Masalah ini dibahas di area diskusi dengan Andrei, tetapi masalah ini tidak dipertimbangkan dalam laporan itu sendiri. <br><br>  Secara umum, saya berharap Andrey dan timnya sukses.  Produk mereka menarik dan ide untuk menempati ceruknya di bidang ini sangat berani. <br><br><h3>  *** </h3><br>  Mungkin saya tidak akan mengatakan apa-apa tentang intisari akhir dari hari pertama dan kedua: keduanya merupakan pertunjukan hak cipta yang hanya perlu Anda tonton.  Berbicara tentang mereka seperti menceritakan kembali dengan kata-kata, misalnya, pertunjukan oleh band rock. <br><br>  Dalam laporan saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">setahun yang lalu,</a> saya sudah mencoba menyampaikan suasana umum konferensi dan berbicara tentang apa yang terjadi di area diskusi, saat makan siang dan di pesta, jadi saya tidak akan mengulangi lagi. <br><br>  Sebagai penutup, saya ingin mengucapkan terima kasih kepada penyelenggara atas konferensi yang diadakan dengan indahnya.  Seperti yang saya pahami, ketertarikan pada konferensi sedikit melebihi harapan, ada overbooking dan bahkan tidak semua orang punya cukup oleh-oleh.  Tetapi yang pasti, semua orang memiliki hal-hal yang lebih penting: laporan menarik, ruang diskusi, makanan dan minuman.  Saya menantikan pertemuan baru! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id432736/">https://habr.com/ru/post/id432736/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id432726/index.html">Mesin RAM</a></li>
<li><a href="../id432728/index.html">Kerentanan dalam Google+ API mengungkapkan data pribadi 52,5 juta pengguna</a></li>
<li><a href="../id432730/index.html">MQTT, Smart Home, ESP-8266 dan Plug & Play</a></li>
<li><a href="../id432732/index.html">Pengalaman saya menerapkan 1C (bagian 1. Pendahuluan)</a></li>
<li><a href="../id432734/index.html">Memutar di awan: prospek pengembangan dan sisi lain dari layanan cloud</a></li>
<li><a href="../id432740/index.html">"CMS" berdasarkan Google Spreadsheets untuk situs statis</a></li>
<li><a href="../id432742/index.html">Tekanan waktu perusahaan</a></li>
<li><a href="../id432744/index.html">DWDM: solusinya lebih murah daripada operator dengan 30-50% (kelas Perusahaan)</a></li>
<li><a href="../id432746/index.html">Selama tiga hari dalam perawatan intensif atau apa yang salah dengan bagian Work-Life Balance di Mobius'18?</a></li>
<li><a href="../id432748/index.html">Kiat & trik Kubernetes: alokasi simpul dan banyak aplikasi web</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>