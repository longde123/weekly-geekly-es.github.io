<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👦🏽 🚵🏿 🔁 Curso MIT "Segurança de sistemas de computadores". Aula 8: Modelo de Segurança de Rede, Parte 3 🏬 ⛰️ 🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instituto de Tecnologia de Massachusetts. Curso de Aula nº 6.858. "Segurança de sistemas de computador". Nikolai Zeldovich, James Mickens. 2014 ano 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Curso MIT "Segurança de sistemas de computadores". Aula 8: Modelo de Segurança de Rede, Parte 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/423423/"><h3>  Instituto de Tecnologia de Massachusetts.  Curso de Aula nº 6.858.  "Segurança de sistemas de computador".  Nikolai Zeldovich, James Mickens.  2014 ano </h3><br>  Computer Systems Security é um curso sobre o desenvolvimento e implementação de sistemas de computador seguros.  As palestras abrangem modelos de ameaças, ataques que comprometem a segurança e técnicas de segurança baseadas em trabalhos científicos recentes.  Os tópicos incluem segurança do sistema operacional (SO), recursos, gerenciamento de fluxo de informações, segurança de idiomas, protocolos de rede, segurança de hardware e segurança de aplicativos da web. <br><br>  Palestra 1: “Introdução: modelos de ameaças” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 2: “Controle de ataques de hackers” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Aula 3: “Estouros de Buffer: Explorações e Proteção” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 4: “Separação de Privilégios” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 5: “De onde vêm os sistemas de segurança?” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> <br>  Palestra 6: “Oportunidades” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 7: “Sandbox do Cliente Nativo” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Aula 8: “Modelo de Segurança de Rede” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <a name="habracut"></a><br><br>  <b>Público-alvo:</b> por que um token aleatório sempre é incluído no URL e não no corpo da solicitação? <br><br>  <b>Professor:</b> HTTPS é usado dessa maneira, mas não há um bom motivo para não incluir variáveis ​​aleatórias no corpo da solicitação.  Apenas algumas formas de herança funcionam dessa maneira através do URL.  Mas, na prática, você pode colocar essas informações em outro lugar na solicitação HTTPS, exceto no cabeçalho. <br><br>  No entanto, observe que simplesmente mover essas informações para o corpo da solicitação é potencialmente inseguro se houver algo que o invasor possa adivinhar.  Em seguida, o invasor ainda pode, de alguma forma, chamar os URLs de que precisa.  Por exemplo, quando faço uma solicitação XML XML e, em seguida, coloco explicitamente algum conteúdo no corpo que o invasor pode adivinhar. <br><br><img src="https://habrastorage.org/webt/k8/00/rl/k800rljxqskwap85v7jdymt3sb8.jpeg"><br><br>  Se você simplesmente definir o quadro no URL, o invasor poderá controlá-lo.  Mas se você usar uma solicitação XML HTTP HTTP e um invasor puder gerar uma delas, a interface HTTP XML permitirá que você defina o corpo da solicitação.  Uma solicitação XML XML é limitada à mesma origem.  No entanto, se um invasor puder fazer algo como: <br><br><pre><code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript"> </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">var</span></span></span><span class="actionscript"> x = “ntrusted”; </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Em seguida, ele poderá implementar a solicitação HTTP XML, que será executada com a autoridade da página incorporada. <br><br>  Tudo depende do que o atacante tem acesso.  Se forçar a página a executar um script não verificado, como mostrado acima, poderá usar a propriedade JavaScript chamada HTML interno e obter todo o conteúdo HTML da página.  Se um invasor pode ou não pode gerar uma solicitação AJAX, isso é uma coisa, se ele pode ou não pode ver o código HTML correto, isso é outra, e assim por diante.  Em resumo, esse token gerado aleatoriamente é capaz de impedir ataques de CSRF. <br><br>  Há mais uma coisa que você precisa prestar atenção nos endereços de rede.  Eles se relacionam com a parte da nossa conversa que disse quem o invasor não pôde se comunicar por meio de uma solicitação XML HTTP. <br><br>  Em relação aos endereços de rede, o quadro pode enviar solicitações HTTP e HTTPS para (host + porta) correspondentes à sua origem.  Observe que a segurança da mesma política da mesma fonte está intimamente relacionada à segurança da infraestrutura DNS, porque todas as políticas desse tipo são baseadas no que você chama. <br><br>  Portanto, se você pode controlar o que eles me chamam, pode fazer alguns ataques mal-intencionados, por exemplo, um ataque de re-ligação ao DNS.  O objetivo desse ataque é iniciar um JavaScript controlado por um invasor com a autoridade (ou em nome do) site da vítima, vamos chamá-lo de vítima.com.  Nesse caso, o invasor usa as regras da mesma política de origem e, de alguma forma, inicia o código que ele escreveu com a permissão de outro site. <br><br>  Isso é feito da seguinte maneira.  Primeiro, um invasor registra um nome de domínio, por exemplo, attacker.com.  É muito simples, basta pagar alguns dólares - e em movimento, você tem seu próprio nome de domínio.  O invasor também deve configurar o servidor DNS para responder a solicitações que vêm com o nome de objetos localizados em attacker.com. <br><br><img src="https://habrastorage.org/webt/wt/pf/jh/wtpfjh-yok0lfy5vp63pmv3t-ww.jpeg"><br><br>  A segunda coisa que deve acontecer é que o usuário deve visitar o attacker.com.  Em particular, ele deve visitar algum site que dependa desse nome de domínio.  Também não há nada complicado nessa parte do ataque. <br><br>  Veja se você pode criar uma campanha publicitária, por exemplo, oferecer um iPad grátis.  Todo mundo quer um iPad grátis, embora eu não conheça ninguém que já ganhou um iPad grátis.  Então, clicando nessa mensagem em um email de phishing, e você já está no site do invasor.  Nada de especial, esta parte não é complicada. <br><br>  Então, o que vai acontecer depois disso?  O navegador começará a gerar consultas DNS para o attacker.com porque a página que você visitou contém objetos vinculados a objetos localizados no attacker.com.  Mas o navegador dirá: "Eu nunca vi esse domínio antes, então deixe-me enviar uma solicitação de permissão de DNS para entrar em contato com attacker.com"! <br><br><img src="https://habrastorage.org/webt/cz/qf/mw/czqfmwdiinh1lxrjntllnrkrktw.jpeg"><br><br>  E o servidor DNS do invasor responde a essa solicitação, mas sua resposta contém uma vida útil TTL muito curta, o que impede que a resposta seja armazenada em cache.  Portanto, o navegador pensará que é válido apenas por um período muito curto antes de precisar sair e confirmar isso, o que realmente significa proibir o armazenamento em cache. <br><br>  Acontece que, assim que o usuário entra no domínio do hacker, o servidor DNS do invasor retorna primeiro o endereço IP real do servidor da Web que forneceu ao usuário código malicioso.  Esse código do lado do cliente acessa attacker.com porque a política de origem permite tais solicitações.  O usuário recebe uma resposta e agora o site malicioso é executado no lado do cliente. <br><br>  Enquanto isso, o invasor irá configurar o servidor DNS, que ele controla, para vincular o nome attacker.com e o endereço IP da vítima.com.  Isso significa que, se o navegador do usuário solicitar uma resolução de nome de domínio para algo dentro do attacker.com, ele realmente obterá algum tipo de endereço interno no site vítima.com. <br><br><img src="https://habrastorage.org/webt/df/tt/jd/dfttjdzqo2hzt6dsttw7ch-mz5o.jpeg"><br><br>  Por que um DNS atacante pode fazer isso?  Como o hacker o configura para isso, o servidor DNS do invasor não precisa consultar para se reconectar ao site vítima.com. <br><br>  Além disso, se nosso site quiser obter um novo objeto, digamos, AJAX, ele considerará que essa solicitação AJAX vai para o attacker.com em algum lugar externo, mas, na verdade, essa solicitação AJAX vai para a vítima.com.  Isso é ruim, porque agora temos esse código no lado em que está localizada a página do atacante.com, que na verdade obtém acesso aos dados do site vítima.com com uma fonte de origem diferente. <br><br><img src="https://habrastorage.org/webt/eo/tn/hr/eotnhr2eggyam1aggoimj-shebs.jpeg"><br><br>  Simplificando, quando um script é executado no navegador da vítima devido à obsolescência da resposta DNS anterior, é feita uma nova consulta DNS para esse domínio, que, devido à proibição de armazenamento em cache, é enviado ao servidor DNS do invasor.  Ele responde que agora o attacker.com parece ter um novo endereço IP de outro site, e a solicitação vai para outro servidor.  E então, para retornar as informações coletadas pelo código, o invasor fornece seu endereço IP correto em uma das seguintes consultas DNS. <br><br>  <b>Público:</b> não seria mais prudente fazer um ataque do contrário.com, para obter todos os cookies do invasor e coisas do gênero? <br><br>  <b>Professor:</b> sim, essa opção também funcionará.  Isso permitirá que você faça coisas boas como a verificação de portas.  Quero dizer, sua abordagem funcionará corretamente.  Como você pode, passo a passo, reatribuir constantemente o attacker.com a vários nomes de computadores e portas diferentes na rede vítima.com.  Em outras palavras, a página da web attacker.com sempre pensa que vai para o attacker.com e recebe uma solicitação AJAX de lá. <br><br>  De fato, toda vez que o servidor DNS se reconecta ao attacker.com, ele envia solicitações para outro endereço IP dentro da rede vítima.com.  Dessa forma, ele pode simplesmente "percorrer" os endereços IP um por um e ver se alguém está respondendo a essas solicitações. <br><br>  <b>Público-alvo:</b> mas o usuário que você está atacando não tem necessariamente acesso interno à rede vítima.com. <br><br>  <b>Professor:</b> como regra geral, este ataque é que existem certas regras de firewall que podem impedir o site externo attacker.com de exibir endereços IP dentro da rede vítima.com.  No entanto, se você estiver dentro de uma rede corporativa, como corp.net, atrás de um firewall corporativo, os computadores geralmente poderão se conectar a máquinas fora da rede. <br><br>  <b>Público-alvo:</b> esse método de ataque funciona via HTTPS? <br><br>  <b>Professor:</b> essa é uma pergunta interessante!  O fato é que o HTTPS usa chaves.  Se você usa HTTPS, ao enviar uma solicitação AJAX, a máquina da vítima não terá as chaves HTTPS do invasor e a verificação de criptografia no site vítima.com mostrará a incompatibilidade de chave.  Portanto, acho que o HTTPS descarta a possibilidade desse tipo de ataque. <br><br>  <b>Público:</b> e se a vítima usar apenas HTTPS? <br><br>  <b>Professor:</b> Eu acho que isso vai parar o atacante. <br><br>  <b>Público-alvo:</b> por que um invasor responde principalmente ao computador da vítima com seu endereço IP? <br><br>  <b>Professor:</b> porque o invasor deve, de alguma forma, executar seu próprio código na máquina da vítima antes de poder executar outras ações para encontrar algo dentro da rede da vítima.  Mas não vamos perder tempo, portanto, se você tiver dúvidas sobre a reatribuição do DNS, procure-me após a palestra. <br><br>  Então, como você pode consertar isso?  Uma maneira de corrigir essa vulnerabilidade é modificar o resolvedor de clientes DNS para que nomes de host externos nunca tenham permissão para acessar endereços IP internos. <br><br>  É meio estúpido que alguém fora da sua rede consiga criar um DNS vinculado a algo dentro da sua rede.  Esta é a solução mais simples. <br><br><img src="https://habrastorage.org/webt/9_/2g/3x/9_2g3xpmlwnrztz5386gzndondi.jpeg"><br><br>  Você pode imaginar que o navegador pode fazer algo chamado "fixação de DNS" ou fixação de DNS.  Como resultado, se o navegador receber um registro de DNS resolvido, ele sempre considerará esse registro válido, por exemplo, para interação em 30 minutos, independentemente de qual TTL o invasor atribuir e, dessa forma, possa resistir ao ataque. <br>  Essa solução é um pouco complicada, porque existem sites que usam intencionalmente DNS dinâmico para coisas como balancear a carga do servidor e similares.  Portanto, a primeira solução com fixação de DNS é a melhor opção. <br><br>  E agora veremos o que a mesma política de origem protege.  E os pixels?  Como a política de origem protege pixels? <br><br>  Como se viu, os pixels realmente não têm origem.  Assim, cada quadro recebe sua própria caixa delimitadora, basicamente apenas um quadrado, e o quadro pode desenhar em qualquer lugar dentro dessa área. <br><br>  Na verdade, isso é um problema, porque significa que o quadro pai pode desenhar sobre o quadro filho.  E isso, por sua vez, pode levar a ataques muito insidiosos. <br><br>  Digamos que um invasor crie uma página que diz: "clique aqui para ganhar um iPad".  O mesmo truque padrão.  Este é o quadro pai. <br><br><img src="https://habrastorage.org/webt/ow/ul/sd/owulsdkyx1yy_wz5uyaskopock0.jpeg"><br><br>  E esse quadro pai pode criar um quadro filho, que na verdade é o quadro do botão Curtir em um site do Facebook.  Assim, o Facebook permite que você execute esse pequeno pedaço de código do Facebook que você pode colocar em sua página. <br><br>  Você sabe que se um usuário clicar em "curtir", significa que ele irá ao Facebook e dirá: "Ei, eu gosto dessa página em particular"!  Portanto, agora temos esse quadro filho do botão Curtir. <br><br><img src="https://habrastorage.org/webt/sp/dm/xk/spdmxk6xeyd9f6vvpes71las3aq.jpeg"><br><br>  Agora, um invasor pode sobrepor esse quadro na área da tela em que o usuário deve clicar para obter um iPad grátis e também tornar esse quadro invisível, o CSS permite isso. <br><br>  Então o que vai acontecer?  Como já instalamos, todo mundo quer obter um iPad grátis.  O usuário acessará este site clicando nesta área da tela, certificando-se de que clica exatamente no que o iPad gratuito fornecerá a ele.  Mas, na verdade, ele clica no botão invisível Curtir.  É como colocar camadas no topo do índice C. <br><br>  Isso significa que agora, talvez, o usuário termine em um perfil no Facebook, onde observa que gostou do attacker.com.  Você sabe, ele nem se lembra como isso aconteceu.  Portanto, isso é chamado de ataque de click jacking - suporte para um ataque de clique.  Da mesma forma, você pode fazer muitas coisas ruins - roubar senhas, obter dados pessoais, enfim, isso é loucura.  Eu enfatizo - isso é possível devido ao fato de que o quadro pai é capaz de desenhar qualquer coisa dentro dessa caixa delimitadora. <br><br>  Portanto, o quadro pai é o que você vê na página, a chamada para obter um tablet gratuito e o quadro filho é o botão like, que é sobreposto de forma transparente ao quadro pai. <br><br>  Existem várias soluções para esse problema.  O primeiro é usar o código de interrupção de quadros.  Dessa forma, você pode usar expressões JavaScript para descobrir se alguém incorporou seu próprio quadro ao seu quadro.  Por exemplo, um desses testes é uma comparação do seguinte formato: if (self! = Top). <br><br>  Aqui, a declaração própria refere-se à parte superior do quadro superior, que é comparada com a hierarquia de todo o quadro.  Portanto, se você fizer esse teste e descobrir que o self não é igual à parte superior do quadro pai, entenderá que possui um quadro filho.  Nesse caso, você pode recusar o download. <br><br>  Isso acontece se você tentar criar um quadro, por exemplo, para o CNN.com.  Se você procurar o código-fonte em JavaScript, poderá ver que ele realiza esse teste porque o CNN.com não deseja que outras pessoas usem seu conteúdo.  Portanto, esse quadro sempre ocupa a posição mais alta.  Portanto, esta é uma das soluções que podem ser usadas aqui. <br><br>  A segunda solução é o servidor da Web enviar um cabeçalho HTTP chamado opções x-Frame em resposta.  Portanto, quando o servidor da web retorna uma resposta, ele pode definir esse cabeçalho, que dirá: “ei, navegador, não deixe ninguém colocar meu conteúdo dentro do quadro!”.  Esta solução permite que o navegador execute ações de imposição. <br><br>  Então é bem simples.  Mas ainda existem muitos outros ataques malucos que você pode organizar. <br><br>  Como mencionei anteriormente, o fato de agora vivermos na Internet internacional cria problemas usando um domínio ou nome de host. <br><br>  Suponha que tenhamos a letra C. Mas em que idioma?  De que alfabeto é esta letra do latim ASCII ou é C em cirílico?  Isso permite que você organize ataques que usam interpretações diferentes e usam letras diferentes, mas aparentemente semelhantes.  Por exemplo, um invasor registrará um nome de domínio cats.com.  E os usuários irão para esse domínio, pensando que visitarão o site "cats. Com", mas, na realidade, chegarão ao site do atacante "sats.com", porque a primeira letra aqui não é latina, mas cirílica. <br><br>  Um invasor pode registrar o domínio fcebook.com, mas as pessoas não prestam atenção, o adotam como facebook.com e vão para lá.  Portanto, se você controlar o Facebook.com, receberá muito tráfego de pessoas que pensam que estão conectadas ao Facebook. <br><br><img src="https://habrastorage.org/webt/1w/0f/z-/1w0fz-myyja-qcjtcfwzn5yebl4.jpeg"><br><br>  Existem vários tipos de ataques malucos que você pode iniciar através do sistema de registro de nomes de domínio difíceis de defender, porque como impedir que os usuários cometam erros de digitação?  Ou como o navegador indica ao usuário: "Ei, isso é cirílico, não latino"!? <br><br>  Se o navegador avisar o usuário toda vez que as fontes cirílicas forem ativadas, irritará as pessoas que realmente usam cirílico como fonte nativa.  Portanto, não está totalmente claro como esses problemas podem ser resolvidos do ponto de vista técnico, e é por isso que problemas de segurança muito sensíveis surgem aqui. <br><br>  Outra coisa interessante são os plugins.  Como os plug-ins interagem com as políticas de origem?  Os plug-ins geralmente têm incompatibilidade com o restante do navegador em relação à mesma fonte de origem.  Por exemplo, se você olhar para o plug-in Java, ele assume que diferentes nomes de host com o mesmo endereço IP também tenham a mesma origem. <br><br>  De fato, esse é um desvio bastante grande da interpretação padrão de políticas da mesma origem.  Essa abordagem significa que, se você tiver algo como xycom e zycom e eles forem projetados no mesmo endereço IP, o Java assumirá que eles têm a mesma fonte de origem.  Isso pode ser um problema, pois, na realidade, um site tem uma fonte de origem confiável e o outro não.  Existem muitas outras dificuldades associadas aos plug-ins, que você pode descobrir em fontes publicamente disponíveis na Internet ou nas notas da aula. <br><br>  A última coisa que quero discutir é um ataque de compartilhamento de tela ou ataque de compartilhamento de tela. <br><br>  O HTML5 realmente define uma nova API pela qual uma página da Web pode compartilhar todos os seus bits para compartilhar com outro navegador ou servidor.  Parece uma ideia muito interessante, porque possibilita a vários usuários trabalhar simultaneamente no mesmo documento.  Isso é ótimo porque vivemos no futuro. <br><br>  Mas o mais engraçado é que, quando eles desenvolveram essa nova API, eles não pensaram em uma política de origem comum! <br><br>  Suponha que você tenha uma página na qual vários quadros estejam localizados e cada um deles tenha o direito de capturar uma captura de tela de todo o monitor.  Ele pode tirar uma captura de tela de todos os quadros localizados na tela e de todo o conteúdo, independentemente das fontes de origem. <br><br><img src="https://habrastorage.org/webt/wz/ok/io/wzokioeio3vzffhinxhsdgau-ae.jpeg"><br><br>  Portanto, de fato, essa é uma falha bastante destrutiva na política da mesma fonte de origem, portanto, considere consertá-la.  Por exemplo, se uma pessoa do quadro direito tiver a capacidade de capturar capturas de tela, poderá capturar apenas o quadro certo, e não a tela inteira como um todo. <br><br>  Por que os desenvolvedores de navegadores não o implementaram dessa maneira?  Porque eles estão sofrendo pressão competitiva e são forçados a concentrar seus esforços no desenvolvimento de mais e mais novas funções, novos recursos, em vez de prestar atenção na melhoria de coisas já desenvolvidas. <br><br>  Muitas perguntas que os alunos fizeram na Internet sobre esta palestra foram: “por que os desenvolvedores não fizeram o que podiam?  Isso não está claro?  ou: “Parece que esse esquema em particular está morto.  O outro não seria melhor?  e assim por diante. <br><br>  Vou lhe dizer honestamente - sim, com certeza, quase tudo seria melhor se os desenvolvedores aceitassem isso com responsabilidade.  Então, eu tenho vergonha de estar conectado com isso. <br><br>  Mas o fato é que é isso que tínhamos antes.  Se você olhar para todos os elementos que existiam antes, verá que os navegadores da Web estão se desenvolvendo e as pessoas ficaram um pouco mais preocupadas com a segurança.  Mas não no caso do compartilhamento de tela, onde os desenvolvedores estavam tão preocupados com os recursos inovadores do navegador que se esqueceram completamente da possibilidade de um pequeno vazamento. <br><br><img src="https://habrastorage.org/webt/0w/pr/lj/0wprljlz8_-bdy5l852zllntduu.jpeg"><br><br>  Portanto, peço que você sempre preste atenção nas coisas que discutimos hoje.  Imagine se começássemos do zero, destruíssemos tudo o que estava à nossa frente e tentássemos criar uma política de segurança melhor, o que você acha, quantos sites funcionariam para nós?  Eu acho que não mais que 2%.  Portanto, os usuários provavelmente reclamariam de nós. <br><br>  Há outra propriedade interessante relacionada à segurança.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de atribuir uma função aos usuários, é muito difícil recuperá-la, mesmo que não seja seguro usá-la. </font><font style="vertical-align: inherit;">Portanto, hoje discutimos muitas coisas relacionadas à política de origem e continuaremos falando sobre isso na próxima palestra.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_1C62Twf0vs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> . <br><br> ,    .    ?     ?       , <b>30%        entry-level ,      :</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps  $20     ?</a> (   RAID1  RAID10,  24    40GB DDR4). <br><br> <b>VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps   </b>      ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> . <br><br> <b>Dell R730xd  2  ?</b>    <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2  Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100   $249</a>    !</b>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   .  c   Dell R730xd 5-2650 v4  9000   ?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt423423/">https://habr.com/ru/post/pt423423/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt423411/index.html">iOS CSS da morte</a></li>
<li><a href="../pt423415/index.html">Multicopter com o princípio de aninhar bonecas ou “apanhador de pomo”?</a></li>
<li><a href="../pt423417/index.html">Estamos escrevendo o primeiro aplicativo para Samsung Smart Watch e OS Tizen</a></li>
<li><a href="../pt423419/index.html">Cliente HTML5 para VMware vSphere lançado neste outono - O que você precisa saber</a></li>
<li><a href="../pt423421/index.html">Por que a grama era mais verde para indie</a></li>
<li><a href="../pt423425/index.html">Old school: quais foram os jogos lançados - discutimos mídia incomum</a></li>
<li><a href="../pt423427/index.html">IndieVisible é uma comunidade indie on-line de código aberto</a></li>
<li><a href="../pt423429/index.html">Atualização do banco de dados e implantação de tempo de inatividade zero</a></li>
<li><a href="../pt423431/index.html">Profundidades do SIEM: correlações prontas para uso. Parte 1: Marketing puro ou um problema insolúvel?</a></li>
<li><a href="../pt423437/index.html">O resumo de materiais interessantes para o desenvolvedor móvel nº 270 (de 10 a 16 de setembro)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>