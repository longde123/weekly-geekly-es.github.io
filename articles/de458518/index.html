<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äç‚öïÔ∏è üöµüèª ü§∑ Python verbraucht viel Speicher oder wie kann die Gr√∂√üe von Objekten reduziert werden? üöü ü•ë üõï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ein Speicherproblem kann auftreten, wenn w√§hrend der Ausf√ºhrung eines Programms eine gro√üe Anzahl von Objekten im RAM aktiv ist, insbesondere wenn die...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python verbraucht viel Speicher oder wie kann die Gr√∂√üe von Objekten reduziert werden?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458518/"><p>  Ein Speicherproblem kann auftreten, wenn w√§hrend der Ausf√ºhrung eines Programms eine gro√üe Anzahl von Objekten im RAM aktiv ist, insbesondere wenn die Gesamtmenge des verf√ºgbaren Speichers eingeschr√§nkt ist. </p><br><p>  Im Folgenden finden Sie eine √úbersicht √ºber einige Methoden zum Reduzieren der Gr√∂√üe von Objekten, wodurch der f√ºr Programme in reinem Python ben√∂tigte RAM-Speicher erheblich reduziert werden kann. </p><br><p>  <strong>Hinweis:</strong> <em>Dies ist die englische Version meines urspr√ºnglichen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beitrags</a> (auf Russisch).</em> </p><a name="habracut"></a><br><p> Der Einfachheit halber werden wir Strukturen in Python betrachten, um Punkte mit den Koordinaten <code>x</code> , <code>y</code> , <code>z</code> mit Zugriff auf die Koordinatenwerte nach Namen darzustellen. </p><br><h3 id="dict">  Dikt </h3><br><p>  In kleinen Programmen, insbesondere in Skripten, ist es recht einfach und bequem, das integrierte <code>dict</code> zur Darstellung von Strukturinformationen zu verwenden: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; ob = {'x':1, 'y':2, 'z':3} &gt;&gt;&gt; x = ob['x'] &gt;&gt;&gt; ob['y'] = y</code> </pre> <br><p>  Mit dem Aufkommen einer kompakteren Implementierung in Python 3.6 mit einem geordneten Schl√ºsselsatz ist das <code>dict</code> noch attraktiver geworden.  Schauen wir uns jedoch die Gr√∂√üe des Footprints im RAM an: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; print(sys.getsizeof(ob)) 240</code> </pre> <br><p>  Es ben√∂tigt viel Speicher, insbesondere wenn Sie pl√∂tzlich eine gro√üe Anzahl von Instanzen erstellen m√ºssen: </p><br><div class="scrollable-table"><table><thead><tr><th>  Anzahl der Instanzen </th><th>  Gr√∂√üe der Objekte </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  240 Mb </td></tr><tr><td>  10.000.000 </td><td>  2,40 GB </td></tr><tr><td>  100.000.000 </td><td>  24 gb </td></tr></tbody></table></div><br><h3 id="class-instance">  Klasseninstanz </h3><br><p>  F√ºr diejenigen, die alles in Klassen kleiden m√∂chten, ist es vorzuziehen, Strukturen als Klasse mit Zugriff √ºber den Attributnamen zu definieren: </p><br><pre> <code class="plaintext hljs">class Point: # def __init__(self, x, y, z): self.x = x self.y = y self.z = z &gt;&gt;&gt; ob = Point(1,2,3) &gt;&gt;&gt; x = ob.x &gt;&gt;&gt; ob.y = y</code> </pre> <br><p>  Die Struktur der Klasseninstanz ist interessant: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Feld </th><th>  Gr√∂√üe (Bytes) </th></tr><tr><td>  PyGC_Head </td><td>  24 </td></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  __weakref__ </td><td>  8 </td></tr><tr><td>  __dict__ </td><td>  8 </td></tr><tr><td>  <b>GESAMT:</b> </td><td>  <b>56</b> </td></tr></tbody></table></div><br><p>  Hier ist <code>__weakref__</code> ein Verweis auf die Liste der sogenannten schwachen Verweise auf dieses Objekt, das Feld <code>__dict__</code> ist ein Verweis auf das Klasseninstanzw√∂rterbuch, das die Werte von <code>__dict__</code> enth√§lt (beachten Sie, dass die 64-Bit-Referenzplattform 8 Bytes belegt).  Ab Python 3.3 werden im gemeinsam genutzten Bereich Schl√ºssel f√ºr alle Instanzen der Klasse im W√∂rterbuch gespeichert.  Dies reduziert die Gr√∂√üe der Instanzablaufverfolgung im RAM: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; print(sys.getsizeof(ob), sys.getsizeof(ob.__dict__)) 56 112</code> </pre> <br><p>  Infolgedessen hat eine gro√üe Anzahl von Klasseninstanzen einen geringeren Speicherbedarf als ein regul√§res W√∂rterbuch ( <code>dict</code> ): </p><br><div class="scrollable-table"><table><thead><tr><th>  Anzahl der Instanzen </th><th>  Gr√∂√üe </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  168 Mb </td></tr><tr><td>  10.000.000 </td><td>  1,68 GB </td></tr><tr><td>  100.000.000 </td><td>  16,8 Gb </td></tr></tbody></table></div><br><p>  Es ist leicht zu erkennen, dass die Gr√∂√üe der Instanz im RAM aufgrund der Gr√∂√üe des W√∂rterbuchs der Instanz immer noch gro√ü ist. </p><br><h3 id="instance-of-class-with--__slots__">  Instanz der Klasse mit __slots__ </h3><br><p>  Eine signifikante Reduzierung der Gr√∂√üe einer Klasseninstanz im RAM wird durch Eliminieren von <code>__dict__</code> und <code>__weakref__</code> .  Dies ist mit Hilfe eines "Tricks" mit <code>__slots__</code> : </p><br><pre> <code class="plaintext hljs">class Point: __slots__ = 'x', 'y', 'z' def __init__(self, x, y, z): self.x = x self.y = y self.z = z &gt;&gt;&gt; ob = Point(1,2,3) &gt;&gt;&gt; print(sys.getsizeof(ob)) 64</code> </pre> <br><p>  Die Objektgr√∂√üe im RAM ist deutlich kleiner geworden: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Feld </th><th>  Gr√∂√üe (Bytes) </th></tr><tr><td>  PyGC_Head </td><td>  24 </td></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  x </td><td>  8 </td></tr><tr><td>  y </td><td>  8 </td></tr><tr><td>  z </td><td>  8 </td></tr><tr><td>  <b>GESAMT:</b> </td><td>  <b>64</b> </td></tr></tbody></table></div><br><p>  Durch die Verwendung von <code>__slots__</code> in der Klassendefinition wird der Footprint einer gro√üen Anzahl von Instanzen im Speicher erheblich reduziert: </p><br><div class="scrollable-table"><table><thead><tr><th>  Anzahl der Instanzen </th><th>  Gr√∂√üe </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  64 Mb </td></tr><tr><td>  10.000.000 </td><td>  640 Mb </td></tr><tr><td>  100.000.000 </td><td>  6,4 GB </td></tr></tbody></table></div><br><p>  Derzeit ist dies die Hauptmethode, um den Speicherbedarf einer Instanz einer Klasse im RAM erheblich zu reduzieren. </p><br><p>  Diese Reduzierung wird durch die Tatsache erreicht, dass im Speicher nach dem Titel des Objekts Objektreferenzen gespeichert werden - die Attributwerte, und der Zugriff darauf erfolgt √ºber spezielle Deskriptoren, die sich im Klassenw√∂rterbuch befinden: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; pprint(Point.__dict__) mappingproxy( .................................... 'x': &lt;member 'x' of 'Point' objects&gt;, 'y': &lt;member 'y' of 'Point' objects&gt;, 'z': &lt;member 'z' of 'Point' objects&gt;})</code> </pre> <br><p>  Um das Erstellen einer Klasse mit <code>__slots__</code> zu automatisieren, gibt es eine Bibliothek [namedlist] ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://pypi.org/project/namedlist</a> ).  Die Funktion <code>namedlist.namedlist</code> erstellt eine Klasse mit <code>__slots__</code> : </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; Point = namedlist('Point', ('x', 'y', 'z'))</code> </pre> <br><p>  Mit einem anderen Paket [attrs] ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://pypi.org/project/attrs</a> ) k√∂nnen Sie das Erstellen von Klassen mit und ohne <code>__slots__</code> . </p><br><h3 id="tuple">  Tupel </h3><br><p>  Python verf√ºgt au√üerdem √ºber ein integriertes Typ- <code>tuple</code> zur Darstellung unver√§nderlicher Datenstrukturen.  Ein Tupel ist eine feste Struktur oder ein Datensatz, jedoch ohne Feldnamen.  F√ºr den Feldzugriff wird der Feldindex verwendet.  Die Tupelfelder sind zum Zeitpunkt der Erstellung der Tupelinstanz ein f√ºr alle Mal den Wertobjekten zugeordnet: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; ob = (1,2,3) &gt;&gt;&gt; x = ob[0] &gt;&gt;&gt; ob[1] = y # ERROR</code> </pre> <br><p>  Beispiele f√ºr Tupel sind recht kompakt: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; print(sys.getsizeof(ob)) 72</code> </pre> <br><p>  Sie belegen 8 Byte mehr Speicher als Instanzen von Klassen mit <code>__slots__</code> , da der Tupel-Trace im Speicher auch eine Reihe von Feldern enth√§lt: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Feld </th><th>  Gr√∂√üe (Bytes) </th></tr><tr><td>  PyGC_Head </td><td>  24 </td></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  ob_size </td><td>  8 </td></tr><tr><td>  [0] </td><td>  8 </td></tr><tr><td>  [1] </td><td>  8 </td></tr><tr><td>  [2] </td><td>  8 </td></tr><tr><td>  <b>GESAMT:</b> </td><td>  <b>72</b> </td></tr></tbody></table></div><br><h3 id="namedtuple">  Namedtuple </h3><br><p>  Da das Tupel sehr h√§ufig verwendet wird, gab es eines Tages die Anfrage, dass Sie weiterhin Zugriff auf die Felder und auch auf den Namen haben k√∂nnten.  Die Antwort auf diese Anfrage war das Modul <code>collections.namedtuple</code> . </p><br><p>  Die Funktion <code>namedtuple</code> soll den Prozess der Generierung solcher Klassen automatisieren: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; Point = namedtuple('Point', ('x', 'y', 'z'))</code> </pre> <br><p>  Es wird eine Unterklasse von Tupeln erstellt, in der Deskriptoren f√ºr den Zugriff auf Felder nach Namen definiert sind.  In unserem Beispiel w√ºrde es ungef√§hr so ‚Äã‚Äãaussehen: </p><br><pre> <code class="plaintext hljs"> class Point(tuple): # @property def _get_x(self): return self[0] @property def _get_y(self): return self[1] @property def _get_z(self): return self[2] # def __new__(cls, x, y, z): return tuple.__new__(cls, (x, y, z))</code> </pre> <br><p>  Alle Instanzen solcher Klassen haben einen Speicherbedarf, der mit dem eines Tupels identisch ist.  Eine gro√üe Anzahl von Instanzen hinterl√§sst einen etwas gr√∂√üeren Speicherbedarf: </p><br><div class="scrollable-table"><table><thead><tr><th>  Anzahl der Instanzen </th><th>  Gr√∂√üe </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  72 Mb </td></tr><tr><td>  10.000.000 </td><td>  720 Mb </td></tr><tr><td>  100.000.000 </td><td>  7,2 GB </td></tr></tbody></table></div><br><h3 id="recordclass-mutable-namedtuple-without-cyclic-gc">  Recordclass: ver√§nderbares Namedtupel ohne zyklische GC </h3><br><p>  Da die <code>namedtuple</code> und dementsprechend die <code>namedtuple</code> Tupelklassen unver√§nderliche Objekte in dem Sinne erzeugen, dass das Attribut <code>ob.x</code> keinem anderen Wertobjekt mehr zugeordnet werden kann, ist eine Anforderung f√ºr eine ver√§nderbare benannte Tupelvariante entstanden.  Da es in Python keinen integrierten Typ gibt, der mit dem Tupel identisch ist, das Zuweisungen unterst√ºtzt, wurden viele Optionen erstellt.  Wir werden uns auf [recordclass] ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://pypi.org/project/recordclass</a> ) konzentrieren, das mit [stackoverflow] bewertet wurde ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://stackoverflow.com/questions/29290359/existence-of-mutable-named- Tupel-in-</a> Python / 29419745).  Dar√ºber hinaus kann es verwendet werden, um die Gr√∂√üe von Objekten im RAM im Vergleich zur Gr√∂√üe von tupel√§hnlichen Objekten zu reduzieren. </p><br><p>  Das Paket <strong>recordclass</strong> f√ºhrt den Typ <code>recordclass.mutabletuple</code> , der fast identisch mit dem Tupel ist, aber auch Zuweisungen unterst√ºtzt.  Auf dieser Grundlage werden Unterklassen erstellt, die fast vollst√§ndig mit den Namenstupeln identisch sind, aber auch die Zuweisung neuer Werte zu Feldern unterst√ºtzen (ohne neue Instanzen zu erstellen).  Mit der Funktion <code>namedtuple</code> k√∂nnen Sie wie mit der Funktion <code>namedtuple</code> die Erstellung dieser Klassen automatisieren: </p><br><pre> <code class="plaintext hljs"> &gt;&gt;&gt; Point = recordclass('Point', ('x', 'y', 'z')) &gt;&gt;&gt; ob = Point(1, 2, 3)</code> </pre> <br><p>  <code>PyGC_Head</code> haben dieselbe Struktur wie <code>tuple</code> , jedoch nur ohne <code>PyGC_Head</code> : </p><br><div class="scrollable-table"><table><tbody><tr><th>  Feld </th><th>  Gr√∂√üe (Bytes) </th></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  ob_size </td><td>  8 </td></tr><tr><td>  x </td><td>  8 </td></tr><tr><td>  y </td><td>  8 </td></tr><tr><td>  y </td><td>  8 </td></tr><tr><td>  <b>GESAMT:</b> </td><td>  <b>48</b> </td></tr></tbody></table></div><br><p>  Standardm√§√üig erstellt die Funktion <code>recordclass</code> eine Klasse, die nicht am zyklischen <code>recordclass</code> teilnimmt.  In der Regel werden <code>namedtuple</code> und <code>recordclass</code> verwendet, um Klassen zu generieren, die Datens√§tze oder einfache (nicht rekursive) Datenstrukturen darstellen.  Wenn Sie sie in Python richtig verwenden, werden keine Zirkelverweise generiert.  Aus diesem Grund wird nach Instanzen von Klassen, die von <code>recordclass</code> generiert wurden, <code>default, the</code> PyGC_Head- <code>fragment is excluded, which is necessary for classes supporting the cyclic garbage collection mechanism (more precisely: in the</code> Speicherbereinigung <code>fragment is excluded, which is necessary for classes supporting the cyclic garbage collection mechanism (more precisely: in the</code> PyTypeObject- <code>structure, corresponding to the created class, in the</code> <code>field, by default, the flag</code> flags ist <code>field, by default, the flag</code> Py_TPFLAGS_HAVE_GC` nicht gesetzt. </p><br><p>  Die Gr√∂√üe des Speicherbedarfs einer gro√üen Anzahl von Instanzen ist kleiner als die von Instanzen der Klasse mit <code>__slots__</code> : </p><br><div class="scrollable-table"><table><thead><tr><th>  Anzahl der Instanzen </th><th>  Gr√∂√üe </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  48 Mb </td></tr><tr><td>  10.000.000 </td><td>  480 Mb </td></tr><tr><td>  100.000.000 </td><td>  4,8 GB </td></tr></tbody></table></div><br><h3 id="dataobject">  Datenobjekt </h3><br><p>  Eine andere in der Datensatzklassenbibliothek vorgeschlagene L√∂sung basiert auf der Idee: Verwenden Sie im Speicher dieselbe Speicherstruktur wie in Klasseninstanzen mit <code>__slots__</code> , nehmen Sie jedoch nicht am zyklischen Speicherbereinigungsmechanismus teil.  Solche Klassen werden mit der Funktion <code>recordclass.make_dataclass</code> generiert: </p><br><pre> <code class="plaintext hljs"> &gt;&gt;&gt; Point = make_dataclass('Point', ('x', 'y', 'z'))</code> </pre> <br><p>  Die auf diese Weise erstellte Klasse erstellt standardm√§√üig ver√§nderbare Instanzen. </p><br><p>  Eine andere M√∂glichkeit: Verwenden Sie die Klassendeklaration mit Vererbung von <code>recordclass.dataobject</code> : </p><br><pre> <code class="plaintext hljs">class Point(dataobject): x:int y:int z:int</code> </pre> <br><p>  Auf diese Weise erstellte Klassen erstellen Instanzen, die nicht am zyklischen Speicherbereinigungsmechanismus teilnehmen.  Die Struktur der Instanz im Speicher ist dieselbe wie im Fall von <code>__slots__</code> , jedoch ohne <code>PyGC_Head</code> : </p><br><div class="scrollable-table"><table><tbody><tr><th>  Feld </th><th>  Gr√∂√üe (Bytes) </th></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  x </td><td>  8 </td></tr><tr><td>  y </td><td>  8 </td></tr><tr><td>  y </td><td>  8 </td></tr><tr><td>  <b>GESAMT:</b> </td><td>  <b>40</b> </td></tr></tbody></table></div><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; ob = Point(1,2,3) &gt;&gt;&gt; print(sys.getsizeof(ob)) 40</code> </pre> <br><p>  Um auf die Felder zuzugreifen, werden spezielle Deskriptoren verwendet, um auf das Feld durch seinen Versatz vom Anfang des Objekts zuzugreifen, die sich im Klassenw√∂rterbuch befinden: </p><br><pre> <code class="plaintext hljs">mappingproxy({'__new__': &lt;staticmethod at 0x7f203c4e6be0&gt;, ....................................... 'x': &lt;recordclass.dataobject.dataslotgetset at 0x7f203c55c690&gt;, 'y': &lt;recordclass.dataobject.dataslotgetset at 0x7f203c55c670&gt;, 'z': &lt;recordclass.dataobject.dataslotgetset at 0x7f203c55c410&gt;})</code> </pre> <br><p>  Die Gr√∂√üe des Speicherbedarfs einer gro√üen Anzahl von Instanzen ist f√ºr CPython das minimal m√∂gliche: </p><br><div class="scrollable-table"><table><thead><tr><th>  Anzahl der Instanzen </th><th>  Gr√∂√üe </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  40 Mb </td></tr><tr><td>  10.000.000 </td><td>  400 Mb </td></tr><tr><td>  100.000.000 </td><td>  4,0 GB </td></tr></tbody></table></div><br><h3 id="cython">  Cython </h3><br><p>  Es gibt einen Ansatz, der auf der Verwendung von [Cython] basiert ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://cython.org</a> ).  Sein Vorteil ist, dass die Felder die Werte der Atomtypen der C-Sprache annehmen k√∂nnen.  Deskriptoren f√ºr den Zugriff auf Felder aus reinem Python werden automatisch erstellt.  Zum Beispiel: </p><br><pre> <code class="plaintext hljs">cdef class Python: cdef public int x, y, z def __init__(self, x, y, z): self.x = x self.y = y self.z = z</code> </pre> <br><p>  In diesem Fall haben die Instanzen eine noch kleinere Speichergr√∂√üe: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; ob = Point(1,2,3) &gt;&gt;&gt; print(sys.getsizeof(ob)) 32</code> </pre> <br><p>  Die Instanzablaufverfolgung im Speicher hat die folgende Struktur: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Feld </th><th>  Gr√∂√üe (Bytes) </th></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  x </td><td>  4 </td></tr><tr><td>  y </td><td>  4 </td></tr><tr><td>  y </td><td>  4 </td></tr><tr><td>  ist leer </td><td>  4 </td></tr><tr><td>  <b>GESAMT:</b> </td><td>  <b>32</b> </td></tr></tbody></table></div><br><p>  Die Gr√∂√üe des Footprints einer gro√üen Anzahl von Kopien ist geringer: </p><br><div class="scrollable-table"><table><thead><tr><th>  Nummer </th><th>  Gr√∂√üe </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  32 Mb </td></tr><tr><td>  10.000.000 </td><td>  320 Mb </td></tr><tr><td>  100.000.000 </td><td>  3,2 GB </td></tr></tbody></table></div><br><p>  Es ist jedoch zu beachten, dass beim Zugriff von Python-Code jedes Mal eine Konvertierung von <code>int</code> in ein Python-Objekt und umgekehrt durchgef√ºhrt wird. </p><br><h3 id="numpy">  Numpy </h3><br><p>  Die Verwendung mehrdimensionaler Arrays oder Arrays von Datens√§tzen f√ºr eine gro√üe Datenmenge f√ºhrt zu einem Speichergewinn.  F√ºr eine effiziente Verarbeitung in reinem Python sollten Sie jedoch Verarbeitungsmethoden verwenden, die sich auf die Verwendung von Funktionen aus dem <code>numpy</code> Paket konzentrieren. </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; Point = numpy.dtype(('x', numpy.int32), ('y', numpy.int32), ('z', numpy.int32)])</code> </pre> <br><p>  Ein Array von <code>N</code> Elementen, die mit Nullen initialisiert sind, wird mit der folgenden Funktion erstellt: </p><br><pre> <code class="plaintext hljs"> &gt;&gt;&gt; points = numpy.zeros(N, dtype=Point)</code> </pre> <br><p>  Die Gr√∂√üe des Arrays im Speicher ist so gering wie m√∂glich: </p><br><div class="scrollable-table"><table><thead><tr><th>  Anzahl der Objekte </th><th>  Gr√∂√üe </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  12 Mb </td></tr><tr><td>  10.000.000 </td><td>  120 Mb </td></tr><tr><td>  100.000.000 </td><td>  1,20 GB </td></tr></tbody></table></div><br><p>  Der normale Zugriff auf Array-Elemente und Zeilen erfordert die Konvertierung von einem Python-Objekt in einen C <code>int</code> -Wert und umgekehrt.  Das Extrahieren einer einzelnen Zeile f√ºhrt zur Erstellung eines Arrays, das ein einzelnes Element enth√§lt.  Seine Spur wird nicht mehr so ‚Äã‚Äãkompakt sein: </p><br><pre> <code class="plaintext hljs"> &gt;&gt;&gt; sys.getsizeof(points[0]) 68</code> </pre> <br><p>  Wie oben erw√§hnt, ist es daher im Python-Code erforderlich, Arrays mithilfe von Funktionen aus dem <code>numpy</code> Paket zu verarbeiten. </p><br><h3 id="conclusion">  Fazit </h3><br><p>  An einem klaren und einfachen Beispiel konnte √ºberpr√ºft werden, ob die Python-Programmiersprachen-Community (CPython) aus Entwicklern und Benutzern echte M√∂glichkeiten f√ºr eine signifikante Reduzierung des von Objekten verwendeten Arbeitsspeichers bietet. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458518/">https://habr.com/ru/post/de458518/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458504/index.html">13 npm Tricks, um Zeit zu sparen</a></li>
<li><a href="../de458506/index.html">Nicht Portal 3, sondern nah: Quantenteleportation von Informationen innerhalb eines Diamanten</a></li>
<li><a href="../de458508/index.html">Ein Einblick: Graduiertenschule an der EPFL. Teil 4.2: die finanzielle Seite</a></li>
<li><a href="../de458514/index.html">Verst√∂√üe gegen die DSGVO werden aktiver bestraft - neue Bu√ügelder und die Auswirkungen von Vorschriften au√üerhalb der EU</a></li>
<li><a href="../de458516/index.html">Holen Sie sich ein Arbeitsprotokoll von Jira</a></li>
<li><a href="../de458520/index.html">Das Buch "Hochleistungscode auf der .NET-Plattform. 2. Auflage</a></li>
<li><a href="../de458524/index.html">VC Wortwolke am Knie</a></li>
<li><a href="../de458530/index.html">Zabbix, Zeitreihen und TimescaleDB</a></li>
<li><a href="../de458532/index.html">Pioniere neuer Technologien: Vadim Artsev erz√§hlte, wie er aufh√∂rte, blind zu sein</a></li>
<li><a href="../de458536/index.html">Python + Pyside2 oder einfach "Rechner"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>