<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî• üëò üí™üèæ Hitachi stirbt hart, heftig und techno-nekrophil üöµüèø ‚úäüèΩ üë©üèæ‚Äçüåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Achtung: Die in diesem Artikel beschriebene L√∂sung ist nicht professionell. Sie wurde m√∂glicherweise aufgrund eines Missverst√§ndnisses der Struktur un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hitachi stirbt hart, heftig und techno-nekrophil</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481952/"><p>  Achtung: Die in diesem Artikel beschriebene L√∂sung ist nicht professionell. Sie wurde m√∂glicherweise aufgrund eines Missverst√§ndnisses der Struktur und der Funktionsweise von Festplatten erstellt.  Das Wiederholen der obigen Schritte kann das Ger√§t besch√§digen. </p><br><p>  K√ºrzlich bin ich auf einen <a href="https://habr.com/ru/post/443612/">Artikel</a> √ºber die Verwendung alter Festplatten mit defekten Bl√∂cken gesto√üen und dachte, dass meine Erfahrung auch f√ºr jemanden interessant sein k√∂nnte. </p><br><p>  Einmal baten mich Bekannte, mit einem Laptop fertig zu werden, auf dem sie Windows nicht neu installieren konnten.  Dem Aussehen nach hatte der Laptop ein hartes Leben: Risse im Geh√§use, verbeulte Ecken, zerbrochene Gestelle.  Es ist klar, dass das Problem eine Besch√§digung der Festplatte durch zahlreiche Anschl√§ge ist, was auch von smart best√§tigt wurde: Mehr als 200 G-Sensor-Vorg√§nge, 500 neu zugewiesene Sektorenanzahl und es steht immer noch Current Pending an.  Nun, Leute, nat√ºrlich habe ich die SSD installiert und die Informationen von ihrer Schraube mit dem folgenden Befehl in das Image kopiert: </p><br><pre><code class="bash hljs">dd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=/dev/sdb of=/media/hddimages/ht320.img bs=409600 conv=noerror,notrunc,sync</code> </pre> <br><p><a name="habracut"></a>  Die Parameter "conv = noerror, notrunc, sync" werden ben√∂tigt, damit bei Fehlern beim Lesen bestimmter Sektoren Nullen an diese Adressen in der Ausgabedatei geschrieben werden und die Daten ohne Vorspannung an ihre Stelle geschrieben werden. </p><br><p>  Es kommt vor, dass beim Einlesen gro√üer Bl√∂cke (400 KB) nicht der gesamte Block und bei kleineren Bl√∂cken nur ein Sektor gelesen wird.  Die Sektoren hier sind 4 KB gro√ü. Wenn nach dem ersten Durchlauf von dd Lesefehler aufgetreten sind, versuche ich, diese Abschnitte in 4-KB-Bl√∂cken erneut zu lesen: </p><br><pre> <code class="bash hljs">n=&lt;&gt;;dd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=/dev/sdb of=/media/hddimages/ht320.img bs=4096 conv=noerror,notrunc,sync skip=<span class="hljs-variable"><span class="hljs-variable">$n</span></span> seek=<span class="hljs-variable"><span class="hljs-variable">$n</span></span> count=100</code> </pre> <br><p>  Die Parameter "√úberspringen" und "Suchen" werden ben√∂tigt, damit das Lesen und Schreiben mit demselben Einzug am Anfang der Festplatte beginnt.  Der Einzug selbst wird aus der Ausgabe der ersten dd-Ausf√ºhrung genommen, nur um der Blockgr√∂√üe zu entsprechen, multiplizieren Sie die Zahl mit 100. </p><br><p>  Manchmal frieren Festplatten beim Zugriff auf fehlerhafte Sektoren f√ºr eine lange Zeit ein, so dass nur das erneute Anschlie√üen an die Stromversorgung hilft. Vor ungef√§hr 5 Jahren wurde ein Hardware-Software-Komplex (sogar mit einem Mikrocontroller) erstellt, um das Lesen fehlerhafter Festplatten mit automatischem erneutem Anschlie√üen an die Stromversorgung zu automatisieren ein langer Mangel an Antwort.  Es war interessant und erlaubt, nach 10 Tagen durch Verbinden der Festplatte und Eingeben des Befehls das vollst√§ndigste Bild zu erhalten.  Aber der experimentelle Held des Artikels hing nicht fest, so dass die beschriebene schwere Kr√ºcke nicht besorgt werden musste. </p><br><p>  Also, die Festplatte wurde in Betracht gezogen, ich habe alle Bereiche des Images durch Losetup mit Offsets des Anfangs der Partitionen von fdisk gemountet, multipliziert mit der logischen Blockgr√∂√üe in mbr - 512 Bytes, ich kopiere alle Daten auf Leute auf einer neuen SSD.  Wenn die Festplatte nicht gemountet wurde oder viele Dateien nicht gelesen werden konnten, w√ºrde ich das Image mit R-Studio √∂ffnen und es √ºber das Image selbst wiederherstellen. </p><br><p>  Aber das Schwierige, obwohl es besiegt ist, ist schade, es rauszuwerfen, also habe ich beschlossen, es irgendwie zu √ºberdenken.  Theoretisch markiert der Festplattencontroller Sektoren als besch√§digt und weist die Sicherungssektoren bei wiederholten erfolglosen Schreibversuchen oder nicht behebbaren Lesefehlern (unter Verwendung von ECC) ihren Adressen zu. </p><br><p>  Zun√§chst versuche ich, die Festplatte zu l√∂schen (dd if = / dev / zero ...) und danach zu lesen: Die Geschwindigkeit ist ebenfalls instabil, die Festplatte friert ein und manchmal treten Eingabe- / Ausgabefehler auf, aber im Smart steigt die Anzahl der Relocks und Pendings.  Nach mehreren Zyklen √§nderte sich der Smart nicht besonders stark, Pendings wurden nicht verschoben, und fehlerhafte H√§nge treten jedes Mal an denselben Orten oder in unmittelbarer N√§he auf.  Ich versuche, manuell mit dem Befehl "hdparm --make-bad-sector" eine zwangsweise Neuzuordnung durchzuf√ºhren, aber dies funktioniert bei diesem Modell nicht, und ich stelle fest, dass nur das L√∂schen, Lesen und Schreiben, nicht alle Problembereiche aufzeigen kann.  In der Tat, wenn ein besch√§digtes Bit, ungeachtet dessen, was es zu schreiben versucht hat, mit gr√∂√üerer Wahrscheinlichkeit als "1" gelesen wird, dann wird beim Schreiben auf "1" das anschlie√üende Lesen ohne Fehler stattfinden, aber beim Schreiben eines anderen Musters kann dies der Fall sein Es gibt gen√ºgend Inkonsistenzen, sodass der ECC ausf√§llt und ein irreparabler Lesefehler auftritt. Nach mehreren derartigen F√§llen hat der Sektor den Status "Bad" erhalten.  √úbrigens kann der aufgezeichnete Wert der Verteilung besch√§digter Bits so √ºberlagert werden, dass ein gelesener falscher Wert sogar die ECC erf√ºllt.  Um die Identifizierung aller fehlerhaften Sektoren zu maximieren, m√ºssen Sie daher ein relativ zuf√§lliges Muster generieren, es auf die Festplatte schreiben, den Wert lesen und vergleichen.  Es gibt auch instabile Sektoren, deren Werte sich im Laufe der Zeit oder nach der Verarbeitung ihrer Nachbarn allm√§hlich √§ndern. </p><br><p>  Aus all diesen Gr√ºnden habe ich beschlossen, die folgende Strategie in ein Bash-Skript umzusetzen: </p><br><ul><li>  wir erzeugen ein zuf√§lliges Muster und betrachten die Pr√ºfsumme daf√ºr; </li><li>  wir lesen klug; </li><li>  schreibe eine Platte in Nullen; </li><li>  Lies die CD. </li><li>  Wir schreiben eine Platte in einem zuf√§lligen Muster, indem wir den gerade aufgezeichneten Block lesen und dessen Pr√ºfsumme vergleichen. </li><li>  Wir lesen die Platte nach der vollst√§ndigen Aufzeichnung und √ºberpr√ºfen die Pr√ºfsummen jedes Blocks. </li><li>  wir lesen klug; </li><li>  Selbsttest; </li><li>  gehe zu 1 </li></ul><br><p>  Wir fahren auf diese Weise fort, bis die falsch gelesenen Sektoren und E / A-Fehler aufh√∂ren oder bis die Schraube vollst√§ndig abgedeckt ist.  √úbrigens kann ich mir nicht vorstellen, wie der Selbsttest f√ºr dieses Diskettenmodell funktioniert;  Ich wei√ü nicht, wie lange sich von short'a unterscheidet (obwohl long wahrscheinlich auf der gesamten Oberfl√§che und short funktioniert - mit Fokus auf den zuvor gesammelten Statistiken, wie bei der Formatierung: voll und schnell).  Ich hoffe, dass dies die Schraube ermutigt, die j√ºngsten Erfahrungen zu ber√ºcksichtigen und schlechte Sektoren neu zu kartieren. </p><br><p>  Als ich mit dem Schreiben des Bash-Skripts fertig war, habe ich es ausgef√ºhrt und die Ergebnisse am n√§chsten Tag √ºberpr√ºft. Dabei stellte ich fest, dass die √úberpr√ºfung sehr langsam funktioniert, w√§hrend die Prozessorauslastung auf keinem Kern 60% erreicht.  Ich habe mit der Blockgr√∂√üe gespielt, verschiedene Hash-Algorithmen auf Pr√ºfsummen getestet, eine direkte Diff-√úberpr√ºfung versucht und keine Pr√ºfsummen verglichen, konnte jedoch keine Verarbeitungsgeschwindigkeit von mehr als 12 Megabyte pro Sekunde erreichen.  Infolgedessen habe ich aufgeh√∂rt, 400-KB-Bl√∂cke mit diff zu vergleichen, und ich berechne die Pr√ºfsummen nur, wenn nur f√ºr die nachfolgende Analyse des Protokolls eine Nicht√ºbereinstimmung vorliegt. </p><br><div class="spoiler">  <b class="spoiler_title">Das Skript stellte sich wie folgt heraus:</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash #    hddtest.sh diskdev logfile [blocksize] diskdev="$1"; test_log="$2"; #"~/work/hdd/test.log" blsz="${409600:-$3}"; n="1"; sizebyte=`fdisk -l "$diskdev"|grep "Disk $diskdev:"|cut -d" " -f5`; let sizebl=$sizebyte/$blsz; #"781428" for 320GB while true;do echo "starting iteration $n"; dd if=/dev/urandom of=fil bs="$blsz" count=1; md5ok=`md5sum fil|cut -d" " -f1`; cp fil fil_"$n"; echo "random pattern md5sum $md5ok"&gt;&gt;"$test_log"; smartctl -A "$diskdev"&gt;&gt;"$test_log"; echo "filling disk with zeroes"&gt;&gt;"$test_log"; dd if=/dev/zero of="$diskdev" bs="$blsz"; #count="$sizebl"; echo "disk is wiped fully"&gt;&gt;"$test_log"; dd of=/dev/null if="$diskdev" bs="$blsz"; # count="$sizebl"; echo "writing disk with fil-pattern"&gt;&gt;"$test_log"; i="0"; while [ "$i" -le "$sizebl" ]; do #echo "writing fil: $i "&gt;&gt;"$test_log"; dd if=fil of="$diskdev" bs="$blsz" seek="$i"; dd if=/dev/null of=tst; dd if="$diskdev" bs="$blsz" of=tst skip="$i" count=1 conv=notrunc,noerror,sync; #md5tst=`md5sum tst|cut -d" " -f1`; verf=`diff -s fil tst|sed 's/.* //g'`; if [ "$verf" != "identical" ]; #if [ "$md5ok" != "$md5tst" ]; then md5tst=`md5sum tst|cut -d" " -f1`; echo "$i : md5 $md5tst is not ok"&gt;&gt;"$test_log"; cp tst tst_"$n"_"$i"; fi; let i="$i"+1; done; echo "test of full writed with fil-pattern disk"&gt;&gt;"$test_log"; i="0"; while [ "$i" -le "$sizebl" ]; do #echo "after writing test: $i"&gt;&gt;"$test_log"; dd if=/dev/null of=tst; dd if="$diskdev" bs="$blsz" of=tst skip="$i" count=1 conv=notrunc,noerror,sync; #md5tst=`md5sum tst|cut -d" " -f1`; verf=`diff -s fil tst|sed 's/.* //g'`; if [ "$verf" != "identical" ]; #if [ "$md5ok" != "$md5tst" ]; then md5tst=`md5sum tst|cut -d" " -f1`; echo "$i : md5 $md5tst is not ok"&gt;&gt;"$test_log"; cp tst tst_"$n"_"$i"; fi; let i="$i"+1; done; smartctl -A "$diskdev" &gt;&gt;"$test_log"; smartctl -t long "$diskdev"&gt;&gt;"$test_log"; sleep 5000; #smartctl -t short "$diskdev"&gt;&gt;"$test_log"; #sleep 240; let n="$n"+1; done</span></span></code> </pre></div></div><br><p>  Wie die Protokolle nach wiederholter Ausf√ºhrung des Skripts zeigten, befanden sich alle fehlerhaften Sektoren in den ersten 13 GB der Festplatte. Es gab mehrere "Fehlerherde" (wahrscheinlich war die Oberfl√§che beim Aufschlagen des Kopfes zerkratzt und zerkratzt).  In den letzten 15 L√§ufen hat die Festplatte keine ausstehenden Sektoren gesehen, alles wurde bereits neu zugeordnet, aber irgendwo in der Mitte des 13. Gigabyte wurden ein Block oder Bl√∂cke in der N√§he falsch an verschiedene Adressen gelesen.  Au√üerdem k√∂nnte ein Block f√ºr 2 Zyklen hintereinander als falsch angesehen werden, dann 2 Mal richtig und erneut falsch.  Die letzten 10 schlechten Sektoren zu erwischen war also eine lange Operation.  Insgesamt wurden 1268 Sektoren neu zugeordnet!  Und am Ende hatte ich eine √úberraschung: Als nach dem n√§chsten Selbsttest bereits alles stabil funktionierte, wurde der Parameter Anzahl neu zugeordneter Sektoren zu ‚Äû0‚Äú und nur die Anzahl neu zugeordneter Ereignisse und die Aufzeichnungen der letzten 5 Fehler (mit Adresse und Uhrzeit von Arbeit beginnen) im Tagebuch gespeichert. </p><br><p>  Trotz des stabilen Betriebs habe ich mich dennoch entschlossen, die Interaktion mit dem besch√§digten Bereich zu minimieren, um den Kopf nicht wegen m√∂glicher Unregelm√§√üigkeiten an Stellen mit besch√§digter Oberfl√§che der Platten zu verletzen, und ich wollte den lokalen Sektoren auf lange Sicht nicht vertrauen.  Ich habe mich gerade etwas zur√ºckgezogen und eine Partition erstellt, die mit dem 15. Gigabyte beginnt.  Und wie die Zeit gezeigt hat, f√ºhlt sich die CD ziemlich gut an und arbeitet seit 10 Monaten stabil in einem tragbaren Laptop. </p><br><p>  Obwohl es unm√∂glich ist, der restaurierten Platte uneingeschr√§nkt zu vertrauen und die wirtschaftliche Machbarkeit des Unternehmens zweifelhaft ist, ist das Ergebnis manchmal nur eine angenehme Erg√§nzung des guten Weges. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481952/">https://habr.com/ru/post/de481952/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481942/index.html">Zur√ºck in die Zukunft: Welche modernen Spiele wurden 2010 vorgestellt?</a></li>
<li><a href="../de481944/index.html">Was bestimmt die Position der Site auf der Suchseite?</a></li>
<li><a href="../de481946/index.html">Kommunikationsmethoden in Microsoft-Teams: Channels VS Chats</a></li>
<li><a href="../de481948/index.html">Wie erstelle ich einen virtuellen Roboter?</a></li>
<li><a href="../de481950/index.html">Tutorial: Reaktiver Spring Boot</a></li>
<li><a href="../de481954/index.html">Wie und warum kann ich VR hacken</a></li>
<li><a href="../de481956/index.html">Auf der Suche nach dem fehlenden Programmierer. Neujahrs-Quest</a></li>
<li><a href="../de481958/index.html">Wann bist du ein Unterzeichner in mail.ru oder wie man einen T-34 Panzer mit einer Mail-Schnittstelle √ºberquert?</a></li>
<li><a href="../de481960/index.html">2. Elastic Stack: Analyse von Sicherheitsprotokollen. Logstash</a></li>
<li><a href="../de481964/index.html">So organisieren Sie eine Ver√∂ffentlichung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>