<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title> 拣  Aleteo Keys! 驴Para que son? 锔  か</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El par谩metro key se puede encontrar en casi todos los constructores de widgets, pero este par谩metro rara vez se usa en el desarrollo. Keys retienen el...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aleteo Keys! 驴Para que son?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446050/"><p><img src="https://habrastorage.org/webt/bd/bp/o2/bdbpo2nvc1jntzhrnowfckpywh0.jpeg"></p><br><p> El par谩metro <code>key</code> se puede encontrar en casi todos los constructores de widgets, pero este par谩metro rara vez se usa en el desarrollo.  <code>Keys</code> retienen el estado al mover widgets en el 谩rbol de widgets.  En la pr谩ctica, esto significa que pueden ser 煤tiles para guardar la ubicaci贸n de desplazamiento del usuario o guardar el estado cuando cambia la colecci贸n. </p><br><p>  Este art铆culo est谩 adaptado del siguiente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">video</a> .  Si prefiere escuchar / mirar en lugar de leer, el video le proporcionar谩 el mismo material. </p><a name="habracut"></a><br><h2 id="sekretnaya-informaciya-o-keys">  Informaci贸n secreta sobre <code>keys</code> </h2><br><p>  La mayor铆a de las veces ... no necesitas <code>keys</code> .  En general, no es perjudicial agregarlos, pero esto tampoco es necesario, ya que simplemente tienen lugar como una nueva palabra clave o declaraci贸n de tipo en ambos lados de una nueva variable (estoy hablando de ti, <code>Map&lt;Foo, Bar&gt; aMap = Map&lt;Foo, Bar&gt;()</code> ). </p><br><blockquote>  Pero si descubre que est谩 agregando, eliminando o reorganizando widgets en la colecci贸n que contienen alg煤n estado y son del mismo tipo, 隆entonces debe prestar atenci贸n a las <code>keys</code> ! </blockquote><p>  Para demostrar por qu茅 necesita <code>keys</code> al cambiar una colecci贸n de widgets, escrib铆 una aplicaci贸n extremadamente simple con dos widgets coloridos que cambian de lugar cuando se hace clic en un bot贸n: </p><br><p><img src="https://habrastorage.org/webt/n3/qy/l1/n3qyl1ute2ckxrbmjoasonmttra.gif"></p><br><p>  En esta versi贸n de la aplicaci贸n, tengo dos widgets sin estado de color aleatorio ( <code>StatelessWidget</code> ) en el widget <code>Row</code> y PositionedTiles con estado ( <code>StatefulWidget</code> ) para almacenar el orden de los widgets de color.  Cuando hago clic en el bot贸n <code>FloatingActionButton</code> en la parte inferior, los widgets de color cambian correctamente su lugar en la lista: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; runApp(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MaterialApp(home: PositionedTiles())); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatefulWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">State&lt;StatefulWidget&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; PositionedTilesState(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTilesState</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class">&gt; </span></span>{ List&lt;Widget&gt; tiles = [ StatelessColorfulTile(), StatelessColorfulTile(), ]; <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Scaffold( body: Row(children: tiles), floatingActionButton: FloatingActionButton( child: Icon(Icons.sentiment_very_satisfied), onPressed: swapTiles), ); } swapTiles() { setState(() { tiles.insert(<span class="hljs-number"><span class="hljs-number">1</span></span>, tiles.removeAt(<span class="hljs-number"><span class="hljs-number">0</span></span>)); }); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessColorfulTile</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessWidget</span></span></span><span class="hljs-class"> </span></span>{ Color myColor = UniqueColorGenerator.getColor(); <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Container( color: myColor, child: Padding(padding: EdgeInsets.all(<span class="hljs-number"><span class="hljs-number">70.0</span></span>))); } }</code> </pre> <br><p>  Pero si agregamos estado a nuestros widgets de color (los hacemos <code>StatefulWidget</code> ) y almacenamos el color en ellos, entonces cuando hacemos clic en el bot贸n, parece que no sucede nada: </p><br><p><img src="https://habrastorage.org/webt/ou/xm/mh/ouxmmh4qaybwgmg3pezne9ocwwo.gif"></p><br><pre> <code class="java hljs">List&lt;Widget&gt; tiles = [ StatefulColorfulTile(), StatefulColorfulTile(), ]; ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatefulColorfulTile</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatefulWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">ColorfulTileState </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; ColorfulTileState(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ColorfulTileState</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ColorfulTile</span></span></span><span class="hljs-class">&gt; </span></span>{ Color myColor; <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.initState(); myColor = UniqueColorGenerator.getColor(); } <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Container( color: myColor, child: Padding( padding: EdgeInsets.all(<span class="hljs-number"><span class="hljs-number">70.0</span></span>), )); } }</code> </pre> <br><p>  Como explicaci贸n: el c贸digo anterior tiene errores porque no muestra el intercambio de color cuando el usuario hace clic en el bot贸n.  Para corregir este error, debe agregar el par谩metro <code>key</code> a los widgets <code>StatefulWidget</code> coloreados, y luego los widgets se intercambiar谩n como queramos: </p><br><p><img src="https://habrastorage.org/webt/se/zh/am/sezham9ms7u158mzemvce1wwlhu.gif"></p><br><pre> <code class="java hljs">List&lt;Widget&gt; tiles = [ StatefulColorfulTile(key: UniqueKey()), <span class="hljs-comment"><span class="hljs-comment">// Keys added here StatefulColorfulTile(key: UniqueKey()), ]; ... class StatefulColorfulTile extends StatefulWidget { StatefulColorfulTile({Key key}) : super(key: key); // NEW CONSTRUCTOR @override ColorfulTileState createState() =&gt; ColorfulTileState(); } class ColorfulTileState extends State&lt;ColorfulTile&gt; { Color myColor; @override void initState() { super.initState(); myColor = UniqueColorGenerator.getColor(); } @override Widget build(BuildContext context) { return Container( color: myColor, child: Padding( padding: EdgeInsets.all(70.0), )); } }</span></span></code> </pre> <br><p>  Pero esto solo es necesario si tiene widgets con estado en el sub谩rbol que est谩 cambiando.  Si todo el sub谩rbol del widget en su colecci贸n no tiene estado, no se necesitan claves. <br>  Ah铆 tienes!  Con todo, todo lo que necesita saber para usar las <code>keys</code> en <code>Flutter</code> .  Pero si quieres profundizar un poco m谩s en lo que est谩 sucediendo ... </p><br><hr><br><h2 id="razbiraemsya-pochemu-keys-inogda-neobhodimy">  Comprender por qu茅 las <code>keys</code> veces <code>keys</code> necesarias </h2><br><p>  Todav铆a est谩s aqu铆, 驴verdad?  隆Pues ac茅rcate para descubrir la verdadera naturaleza de los 谩rboles y widgets de elementos para convertirte en un mago revoloteador!  Wahahaha!  Jaja  Jaja  Lo siento. </p><br><p>  Como sabes, dentro de cada widget Flutter construye el elemento correspondiente.  As铆 como Flutter construye un 谩rbol de widgets, tambi茅n crea un 谩rbol de elementos (ElementTree).  ElementTree es extremadamente simple, contiene solo la informaci贸n de tipo de cada widget y un enlace a elementos secundarios.  Puede pensar en ElementTree como el esqueleto de su aplicaci贸n Flutter.  Muestra la estructura de su aplicaci贸n, pero toda la informaci贸n adicional se puede encontrar en el enlace al widget de origen. </p><br><p>  El widget de fila del ejemplo anterior contiene un conjunto de ranuras ordenadas para cada uno de sus elementos secundarios.  Cuando volvemos a ordenar los widgets de color en Row, Flutter recorre ElementTree para comprobar si la estructura esquel茅tica de la aplicaci贸n es la misma. </p><br><p><img src="https://habrastorage.org/webt/ha/dh/vy/hadhvybi_mhjvuwdiiucmmx2w6i.gif"></p><br><p>  La validaci贸n comienza con un RowElement y luego pasa a los elementos secundarios.  ElementTree verifica que el nuevo widget tenga el mismo tipo y <code>key</code> que el anterior, y si es as铆, el elemento actualiza su enlace al nuevo widget.  En la versi贸n sin estado del c贸digo, los widgets no tienen <code>key</code> , por lo que Flutter simplemente verifica solo el tipo.  (Si hay demasiada informaci贸n a la vez, consulte la tabla animada anterior). </p><br><p>  Debajo de ElementTree para widgets de estado se ve un poco diferente.  Hay widgets y elementos, como antes, pero tambi茅n hay un par de objetos de estado para widgets, y la informaci贸n de color se almacena en ellos, y no en los widgets. </p><br><p><img src="https://habrastorage.org/webt/dh/ay/sh/dhayshomjpkfv7b45fxmx1ecduw.gif"></p><br><p>  En el caso de los widgets de <code>StatefulWidget</code> coloreados sin <code>key</code> , cuando cambio el orden de dos widgets, Flutter recorre ElementTree, verifica el tipo de RowWidget y actualiza el enlace.  Luego, el elemento de widget de color verifica que el widget correspondiente sea del mismo tipo y actualiza el enlace.  Lo mismo sucede con el segundo widget.  Dado que Flutter usa ElementTree y su estado correspondiente para determinar qu茅 mostrar realmente en su dispositivo, desde nuestro punto de vista, 隆parece que los widgets no se han intercambiado! </p><br><p><img src="https://habrastorage.org/webt/nu/yw/ah/nuywahtbnrv2bfvrwb0osfj1fye.gif"></p><br><p>  En la versi贸n fija del c贸digo en widgets de colores con estado en el constructor, defin铆 la propiedad <code>key</code> .  Ahora, si cambiamos los widgets en <code>Row</code> , por tipo coincidir谩n como antes, pero los valores <code>key</code> del widget de color y el elemento correspondiente en ElementTree ser谩n diferentes.  Esto hace que Flutter desactive estos elementos de los widgets de color y elimine los enlaces a ellos en ElementTree, comenzando por el primero, que no coincide con la <code>key</code> . </p><br><p><img src="https://habrastorage.org/webt/iz/vw/os/izvwos_wwqsng-afywi2az2shsu.gif"></p><br><p>  Luego, Flutter busca los widgets en el elemento <code>Row</code> en ElementTree con la <code>key</code> correspondiente.  Si coincide, agrega un enlace al elemento del widget.  Flutter lo hace para cada ni帽o sin un enlace.  Ahora Flutter mostrar谩 lo que esperamos, los widgets de color cambiar谩n de lugar cuando haga clic en el bot贸n. </p><br><p>  Por lo tanto, las <code>keys</code> son 煤tiles si cambia el orden o el n煤mero de widgets con estado en la colecci贸n.  En este ejemplo, guard茅 el color.  Sin embargo, a menudo la condici贸n no es tan obvia.  Reproducir una animaci贸n, mostrar la entrada del usuario y desplazarse por una ubicaci贸n: todo tiene un estado. </p><br><hr><br><h2 id="kogda-mne-ispolzovat-keys">  驴Cu谩ndo debo usar las <code>keys</code> ? </h2><br><p>  Respuesta corta: si necesita agregar <code>keys</code> a la aplicaci贸n, debe agregarlas en la parte superior del sub谩rbol de widgets con el estado que desea guardar. </p><br><p>  Un error com煤n que vi es que las personas piensan que necesitan definir la <code>key</code> solo para el primer widget con estado, pero hay matices.  No me creas  Para mostrar en qu茅 problemas podr铆amos estar, envolv铆 mis widgets de color en widgets de <code>Padding</code> , mientras dejaba las teclas para los widgets de color. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; runApp(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MaterialApp(home: PositionedTiles())); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatefulWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">State&lt;StatefulWidget&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; PositionedTilesState(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTilesState</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Stateful tiles now wrapped in padding (a stateless widget) to increase height // of widget tree and show why keys are needed at the Padding level. List&lt;Widget&gt; tiles = [ Padding( padding: const EdgeInsets.all(8.0), child: StatefulColorfulTile(key: UniqueKey()), ), Padding( padding: const EdgeInsets.all(8.0), child: StatefulColorfulTile(key: UniqueKey()), ), ]; @override Widget build(BuildContext context) { return Scaffold( body: Row(children: tiles), floatingActionButton: FloatingActionButton( child: Icon(Icons.sentiment_very_satisfied), onPressed: swapTiles), ); } swapTiles() { setState(() { tiles.insert(1, tiles.removeAt(0)); }); } } class StatefulColorfulTile extends StatefulWidget { StatefulColorfulTile({Key key}) : super(key: key); @override ColorfulTileState createState() =&gt; ColorfulTileState(); } class ColorfulTileState extends State&lt;ColorfulTile&gt; { Color myColor; @override void initState() { super.initState(); myColor = UniqueColorGenerator.getColor(); } @override Widget build(BuildContext context) { return Container( color: myColor, child: Padding( padding: EdgeInsets.all(70.0), )); } }</span></span></code> </pre> <br><p>  隆Ahora, con solo tocar un bot贸n, los widgets obtienen colores completamente al azar! </p><br><p><img src="https://habrastorage.org/webt/w2/ge/lb/w2gelbrnaw_hlvftimjhe-vhhim.gif"></p><br><p>  As铆 es como se ven el 谩rbol de widgets y ElementTree con los widgets <code>Padding</code> agregados: </p><br><p><img src="https://habrastorage.org/webt/k-/br/0o/k-br0o5hmbvzwvjodwemswze0na.jpeg"></p><br><p>  Cuando cambiamos las posiciones de los widgets secundarios, el algoritmo de coincidencia entre elementos y widgets se ve un nivel en el 谩rbol de elementos.  En el diagrama, los hijos de los ni帽os se oscurecen para que nada distraiga del primer nivel.  En este nivel, todo coincide correctamente. </p><br><p><img src="https://habrastorage.org/webt/j6/tt/zp/j6ttzpgzdbpupkzqw4s1vlsyz6g.gif"></p><br><p>  En el segundo nivel, Flutter se da cuenta de que la <code>key</code> elemento de color no coincide con la <code>key</code> widget, por lo que desactiva este elemento, lo descarta y elimina todos los enlaces.  <code>keys</code> que usamos en este ejemplo son <code>LocalKeys</code> .  Esto significa que al hacer coincidir un widget con elementos, Flutter busca <code>keys</code> solo en un cierto nivel del 谩rbol. </p><br><p>  Como no puede encontrar el elemento de widget de color en este nivel con la <code>key</code> correspondiente, crea uno nuevo e inicializa un nuevo estado, 隆haciendo que el widget sea naranja en este caso! </p><br><p><img src="https://habrastorage.org/webt/2q/mn/xk/2qmnxkwb7xpxtyi3jgbefvg70mi.gif"></p><br><p>  Si definimos <code>keys</code> para widgets de <code>Padding</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; runApp(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MaterialApp(home: PositionedTiles())); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatefulWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">State&lt;StatefulWidget&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; PositionedTilesState(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTilesState</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class">&gt; </span></span>{ List&lt;Widget&gt; tiles = [ Padding( <span class="hljs-comment"><span class="hljs-comment">// Place the keys at the *top* of the tree of the items in the collection. key: UniqueKey(), padding: const EdgeInsets.all(8.0), child: StatefulColorfulTile(), ), Padding( key: UniqueKey(), padding: const EdgeInsets.all(8.0), child: StatefulColorfulTile(), ), ]; @override Widget build(BuildContext context) { return Scaffold( body: Row(children: tiles), floatingActionButton: FloatingActionButton( child: Icon(Icons.sentiment_very_satisfied), onPressed: swapTiles), ); } swapTiles() { setState(() { tiles.insert(1, tiles.removeAt(0)); }); } } class StatefulColorfulTile extends StatefulWidget { StatefulColorfulTile({Key key}) : super(key: key); @override ColorfulTileState createState() =&gt; ColorfulTileState(); } class ColorfulTileState extends State&lt;ColorfulTile&gt; { Color myColor; @override void initState() { super.initState(); myColor = UniqueColorGenerator.getColor(); } @override Widget build(BuildContext context) { return Container( color: myColor, child: Padding( padding: EdgeInsets.all(70.0), )); } }</span></span></code> </pre> <br><p>  Flutter nota el problema y actualiza los enlaces correctamente, como sucedi贸 en nuestro ejemplo anterior.  Se restaura el orden en el universo. </p><br><p><img src="https://habrastorage.org/webt/xp/4w/h0/xp4wh0wpzgd-5wxtxdkwu3jogps.gif"></p><br><hr><br><h2 id="kakoy-tip-key-mne-sleduet-ispolzovat">  驴Qu茅 tipo de <code>Key</code> debo usar? </h2><br><p>  Las API de Flutter nos dieron la opci贸n de varias clases <code>Key</code> .  El tipo de <code>key</code> que debe usar depende de cu谩l es la caracter铆stica distintiva de los elementos que necesitan <code>keys</code> .  Mire la informaci贸n que almacena en los widgets respectivos. </p><br><p>  Considere la siguiente aplicaci贸n Tareas pendientes [1], donde puede cambiar el orden de los elementos en la lista de tareas seg煤n la prioridad y, cuando haya terminado, puede eliminarlos. </p><br><p><img src="https://habrastorage.org/webt/nz/qb/8g/nzqb8g-8ywgycp0g_xe-6p7-xk0.gif"></p><br><p>  <strong>ValueKey</strong> <br>  En este caso, podemos esperar que el texto del p谩rrafo sobre la implementaci贸n sea permanente y 煤nico.  Si es as铆, entonces este es probablemente un buen candidato para <code>ValueKey</code> , donde el texto es "valor". </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TodoItem( key: ValueKey(todo.task), todo: todo, onDismissed: (direction) =&gt; _removeTodo(context, todo), );</code> </pre> <br><p>  <strong>Objectkey</strong> <br>  Alternativamente, puede tener la aplicaci贸n Libreta de direcciones, que enumera informaci贸n sobre cada usuario.  En este caso, cada widget secundario almacena una combinaci贸n m谩s compleja de datos.  Cualquiera de los campos individuales, por ejemplo, nombre o fecha de nacimiento, puede coincidir con otra entrada, pero la combinaci贸n es 煤nica.  En este caso, <code>ObjectKey</code> es probablemente el mejor ajuste. </p><br><p><img src="https://habrastorage.org/webt/jk/jz/av/jkjzavsw7v74t_dnnmb79mvukd0.png"></p><br><p>  <strong>Uniquekey</strong> <br>  Si tiene varios widgets en la colecci贸n con el mismo valor o si realmente quiere asegurarse de que cada widget sea diferente de todos los dem谩s, puede usar <code>UniqueKey</code> .  <code>UniqueKey</code> en la aplicaci贸n de ejemplo para cambiar los colores, porque no ten铆amos otros datos constantes que se almacenar铆an en nuestros widgets, y no sab铆amos qu茅 color tendr铆a el widget al crearlo. </p><br><p>  Sin embargo, una cosa que <strong>no desea</strong> utilizar como <code>key</code> es un n煤mero aleatorio.  Cada vez que se crea un widget, se generar谩 un nuevo n煤mero aleatorio y perder谩 la coherencia entre los marcos.  En este escenario, 隆no puede usar <code>keys</code> en absoluto! </p><br><p>  <strong>PageStorageKeys</strong> <br>  <code>PageStorageKeys</code> son <code>keys</code> especializadas que contienen el estado actual del desplazamiento para que la aplicaci贸n pueda guardarlo para su uso posterior. </p><br><p><img src="https://habrastorage.org/webt/dx/db/if/dxdbif6yn7hlszee_-hbzbaevn8.gif"></p><br><p>  <strong>Globalkeys</strong> <br>  Hay dos opciones para usar <code>GlobalKeys</code> : permiten que los widgets cambien a los padres en cualquier lugar de la aplicaci贸n sin perder el estado y se pueden usar para acceder a informaci贸n sobre otro widget en una parte completamente diferente del 谩rbol de widgets.  Como ejemplo del primer escenario, puede imaginar que desea mostrar el mismo widget en dos pantallas diferentes, pero con el mismo estado, para que se guarden los datos del widget, usar谩 <code>GlobalKey</code> .  En el segundo caso, puede surgir una situaci贸n en la que necesite verificar la contrase帽a, pero no desea compartir informaci贸n de estado con otros widgets en el 谩rbol.  <code>GlobalKeys</code> tambi茅n puede ser 煤til para las pruebas, utilizando la <code>key</code> para acceder a un widget espec铆fico y solicitar informaci贸n sobre su estado. </p><br><p><img src="https://habrastorage.org/webt/eh/rq/bl/ehrqble5pcoeqrh7ktl0j0_dm5s.gif"></p><br><p>  A menudo (隆pero no siempre!) <code>GlobalKeys</code> poco como las variables globales.  A menudo se pueden reemplazar con <code>InheritedWidgets</code> o algo as铆 como Redux, o la plantilla BLoC. </p><br><hr><br><h2 id="kratkoe-zaklyuchenie">  Breve conclusi贸n </h2><br><p>  En general, use <code>Keys</code> si desea mantener el estado entre los sub谩rboles de widgets.  Esto ocurre con mayor frecuencia cuando cambia la colecci贸n de widgets del mismo tipo.  Coloque la <code>key</code> en la parte superior del sub谩rbol de widgets que desea guardar y seleccione el tipo de <code>key</code> funci贸n de los datos almacenados en el widget. </p><br><p>  隆Felicitaciones, ahora est谩s en camino de convertirte en un mago revoloteador!  Oh dije un mago?  Me refer铆a al mago [2], como el que escribe el c贸digo fuente de la aplicaci贸n ... que es casi tan bueno.  ... casi. </p><br><p>  [1] Inspiraci贸n para escribir el c贸digo de la aplicaci贸n Tareas recibidas aqu铆 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/brianegan/flutter_architecture_samples/tree/master/vanilla</a> <br>  [2] El autor usa la palabra <code>sorcerer</code> y luego le agrega una carta adicional antes del <code>sourcerer</code> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/446050/">https://habr.com/ru/post/446050/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446038/index.html">Una breve gu铆a sobre la creaci贸n de or谩culos, dioses del autom贸vil y errores de segundo orden</a></li>
<li><a href="../446040/index.html">Full Stack Confession: profesi贸n, religi贸n, sue帽os</a></li>
<li><a href="../446042/index.html">DJI Mavic 2 Pro despu茅s de seis meses de uso</a></li>
<li><a href="../446046/index.html">La expansi贸n del universo es la mayor falacia en la historia de la ciencia.</a></li>
<li><a href="../446048/index.html">La uni贸n de Arduino y el procesador cl谩sico.</a></li>
<li><a href="../446052/index.html">Creando la voz y el tono de su producto</a></li>
<li><a href="../446054/index.html">Copia de seguridad lista: destruyendo mitos de vacaciones</a></li>
<li><a href="../446056/index.html">Una manera simple de hablar con su sitio web</a></li>
<li><a href="../446058/index.html">C贸mo construir SDN - Ocho herramientas de c贸digo abierto</a></li>
<li><a href="../446060/index.html">S铆ntesis de sue帽os de alto peso molecular.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>