<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏀 👼🏻 👗 Aleteo Keys! ¿Para que son? ↕️ 🙎🏽 🤫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El parámetro key se puede encontrar en casi todos los constructores de widgets, pero este parámetro rara vez se usa en el desarrollo. Keys retienen el...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aleteo Keys! ¿Para que son?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446050/"><p><img src="https://habrastorage.org/webt/bd/bp/o2/bdbpo2nvc1jntzhrnowfckpywh0.jpeg"></p><br><p> El parámetro <code>key</code> se puede encontrar en casi todos los constructores de widgets, pero este parámetro rara vez se usa en el desarrollo.  <code>Keys</code> retienen el estado al mover widgets en el árbol de widgets.  En la práctica, esto significa que pueden ser útiles para guardar la ubicación de desplazamiento del usuario o guardar el estado cuando cambia la colección. </p><br><p>  Este artículo está adaptado del siguiente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">video</a> .  Si prefiere escuchar / mirar en lugar de leer, el video le proporcionará el mismo material. </p><a name="habracut"></a><br><h2 id="sekretnaya-informaciya-o-keys">  Información secreta sobre <code>keys</code> </h2><br><p>  La mayoría de las veces ... no necesitas <code>keys</code> .  En general, no es perjudicial agregarlos, pero esto tampoco es necesario, ya que simplemente tienen lugar como una nueva palabra clave o declaración de tipo en ambos lados de una nueva variable (estoy hablando de ti, <code>Map&lt;Foo, Bar&gt; aMap = Map&lt;Foo, Bar&gt;()</code> ). </p><br><blockquote>  Pero si descubre que está agregando, eliminando o reorganizando widgets en la colección que contienen algún estado y son del mismo tipo, ¡entonces debe prestar atención a las <code>keys</code> ! </blockquote><p>  Para demostrar por qué necesita <code>keys</code> al cambiar una colección de widgets, escribí una aplicación extremadamente simple con dos widgets coloridos que cambian de lugar cuando se hace clic en un botón: </p><br><p><img src="https://habrastorage.org/webt/n3/qy/l1/n3qyl1ute2ckxrbmjoasonmttra.gif"></p><br><p>  En esta versión de la aplicación, tengo dos widgets sin estado de color aleatorio ( <code>StatelessWidget</code> ) en el widget <code>Row</code> y PositionedTiles con estado ( <code>StatefulWidget</code> ) para almacenar el orden de los widgets de color.  Cuando hago clic en el botón <code>FloatingActionButton</code> en la parte inferior, los widgets de color cambian correctamente su lugar en la lista: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; runApp(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MaterialApp(home: PositionedTiles())); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatefulWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">State&lt;StatefulWidget&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; PositionedTilesState(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTilesState</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class">&gt; </span></span>{ List&lt;Widget&gt; tiles = [ StatelessColorfulTile(), StatelessColorfulTile(), ]; <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Scaffold( body: Row(children: tiles), floatingActionButton: FloatingActionButton( child: Icon(Icons.sentiment_very_satisfied), onPressed: swapTiles), ); } swapTiles() { setState(() { tiles.insert(<span class="hljs-number"><span class="hljs-number">1</span></span>, tiles.removeAt(<span class="hljs-number"><span class="hljs-number">0</span></span>)); }); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessColorfulTile</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessWidget</span></span></span><span class="hljs-class"> </span></span>{ Color myColor = UniqueColorGenerator.getColor(); <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Container( color: myColor, child: Padding(padding: EdgeInsets.all(<span class="hljs-number"><span class="hljs-number">70.0</span></span>))); } }</code> </pre> <br><p>  Pero si agregamos estado a nuestros widgets de color (los hacemos <code>StatefulWidget</code> ) y almacenamos el color en ellos, entonces cuando hacemos clic en el botón, parece que no sucede nada: </p><br><p><img src="https://habrastorage.org/webt/ou/xm/mh/ouxmmh4qaybwgmg3pezne9ocwwo.gif"></p><br><pre> <code class="java hljs">List&lt;Widget&gt; tiles = [ StatefulColorfulTile(), StatefulColorfulTile(), ]; ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatefulColorfulTile</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatefulWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">ColorfulTileState </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; ColorfulTileState(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ColorfulTileState</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ColorfulTile</span></span></span><span class="hljs-class">&gt; </span></span>{ Color myColor; <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.initState(); myColor = UniqueColorGenerator.getColor(); } <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Container( color: myColor, child: Padding( padding: EdgeInsets.all(<span class="hljs-number"><span class="hljs-number">70.0</span></span>), )); } }</code> </pre> <br><p>  Como explicación: el código anterior tiene errores porque no muestra el intercambio de color cuando el usuario hace clic en el botón.  Para corregir este error, debe agregar el parámetro <code>key</code> a los widgets <code>StatefulWidget</code> coloreados, y luego los widgets se intercambiarán como queramos: </p><br><p><img src="https://habrastorage.org/webt/se/zh/am/sezham9ms7u158mzemvce1wwlhu.gif"></p><br><pre> <code class="java hljs">List&lt;Widget&gt; tiles = [ StatefulColorfulTile(key: UniqueKey()), <span class="hljs-comment"><span class="hljs-comment">// Keys added here StatefulColorfulTile(key: UniqueKey()), ]; ... class StatefulColorfulTile extends StatefulWidget { StatefulColorfulTile({Key key}) : super(key: key); // NEW CONSTRUCTOR @override ColorfulTileState createState() =&gt; ColorfulTileState(); } class ColorfulTileState extends State&lt;ColorfulTile&gt; { Color myColor; @override void initState() { super.initState(); myColor = UniqueColorGenerator.getColor(); } @override Widget build(BuildContext context) { return Container( color: myColor, child: Padding( padding: EdgeInsets.all(70.0), )); } }</span></span></code> </pre> <br><p>  Pero esto solo es necesario si tiene widgets con estado en el subárbol que está cambiando.  Si todo el subárbol del widget en su colección no tiene estado, no se necesitan claves. <br>  Ahí tienes!  Con todo, todo lo que necesita saber para usar las <code>keys</code> en <code>Flutter</code> .  Pero si quieres profundizar un poco más en lo que está sucediendo ... </p><br><hr><br><h2 id="razbiraemsya-pochemu-keys-inogda-neobhodimy">  Comprender por qué las <code>keys</code> veces <code>keys</code> necesarias </h2><br><p>  Todavía estás aquí, ¿verdad?  ¡Pues acércate para descubrir la verdadera naturaleza de los árboles y widgets de elementos para convertirte en un mago revoloteador!  Wahahaha!  Jaja  Jaja  Lo siento. </p><br><p>  Como sabes, dentro de cada widget Flutter construye el elemento correspondiente.  Así como Flutter construye un árbol de widgets, también crea un árbol de elementos (ElementTree).  ElementTree es extremadamente simple, contiene solo la información de tipo de cada widget y un enlace a elementos secundarios.  Puede pensar en ElementTree como el esqueleto de su aplicación Flutter.  Muestra la estructura de su aplicación, pero toda la información adicional se puede encontrar en el enlace al widget de origen. </p><br><p>  El widget de fila del ejemplo anterior contiene un conjunto de ranuras ordenadas para cada uno de sus elementos secundarios.  Cuando volvemos a ordenar los widgets de color en Row, Flutter recorre ElementTree para comprobar si la estructura esquelética de la aplicación es la misma. </p><br><p><img src="https://habrastorage.org/webt/ha/dh/vy/hadhvybi_mhjvuwdiiucmmx2w6i.gif"></p><br><p>  La validación comienza con un RowElement y luego pasa a los elementos secundarios.  ElementTree verifica que el nuevo widget tenga el mismo tipo y <code>key</code> que el anterior, y si es así, el elemento actualiza su enlace al nuevo widget.  En la versión sin estado del código, los widgets no tienen <code>key</code> , por lo que Flutter simplemente verifica solo el tipo.  (Si hay demasiada información a la vez, consulte la tabla animada anterior). </p><br><p>  Debajo de ElementTree para widgets de estado se ve un poco diferente.  Hay widgets y elementos, como antes, pero también hay un par de objetos de estado para widgets, y la información de color se almacena en ellos, y no en los widgets. </p><br><p><img src="https://habrastorage.org/webt/dh/ay/sh/dhayshomjpkfv7b45fxmx1ecduw.gif"></p><br><p>  En el caso de los widgets de <code>StatefulWidget</code> coloreados sin <code>key</code> , cuando cambio el orden de dos widgets, Flutter recorre ElementTree, verifica el tipo de RowWidget y actualiza el enlace.  Luego, el elemento de widget de color verifica que el widget correspondiente sea del mismo tipo y actualiza el enlace.  Lo mismo sucede con el segundo widget.  Dado que Flutter usa ElementTree y su estado correspondiente para determinar qué mostrar realmente en su dispositivo, desde nuestro punto de vista, ¡parece que los widgets no se han intercambiado! </p><br><p><img src="https://habrastorage.org/webt/nu/yw/ah/nuywahtbnrv2bfvrwb0osfj1fye.gif"></p><br><p>  En la versión fija del código en widgets de colores con estado en el constructor, definí la propiedad <code>key</code> .  Ahora, si cambiamos los widgets en <code>Row</code> , por tipo coincidirán como antes, pero los valores <code>key</code> del widget de color y el elemento correspondiente en ElementTree serán diferentes.  Esto hace que Flutter desactive estos elementos de los widgets de color y elimine los enlaces a ellos en ElementTree, comenzando por el primero, que no coincide con la <code>key</code> . </p><br><p><img src="https://habrastorage.org/webt/iz/vw/os/izvwos_wwqsng-afywi2az2shsu.gif"></p><br><p>  Luego, Flutter busca los widgets en el elemento <code>Row</code> en ElementTree con la <code>key</code> correspondiente.  Si coincide, agrega un enlace al elemento del widget.  Flutter lo hace para cada niño sin un enlace.  Ahora Flutter mostrará lo que esperamos, los widgets de color cambiarán de lugar cuando haga clic en el botón. </p><br><p>  Por lo tanto, las <code>keys</code> son útiles si cambia el orden o el número de widgets con estado en la colección.  En este ejemplo, guardé el color.  Sin embargo, a menudo la condición no es tan obvia.  Reproducir una animación, mostrar la entrada del usuario y desplazarse por una ubicación: todo tiene un estado. </p><br><hr><br><h2 id="kogda-mne-ispolzovat-keys">  ¿Cuándo debo usar las <code>keys</code> ? </h2><br><p>  Respuesta corta: si necesita agregar <code>keys</code> a la aplicación, debe agregarlas en la parte superior del subárbol de widgets con el estado que desea guardar. </p><br><p>  Un error común que vi es que las personas piensan que necesitan definir la <code>key</code> solo para el primer widget con estado, pero hay matices.  No me creas  Para mostrar en qué problemas podríamos estar, envolví mis widgets de color en widgets de <code>Padding</code> , mientras dejaba las teclas para los widgets de color. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; runApp(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MaterialApp(home: PositionedTiles())); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatefulWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">State&lt;StatefulWidget&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; PositionedTilesState(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTilesState</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Stateful tiles now wrapped in padding (a stateless widget) to increase height // of widget tree and show why keys are needed at the Padding level. List&lt;Widget&gt; tiles = [ Padding( padding: const EdgeInsets.all(8.0), child: StatefulColorfulTile(key: UniqueKey()), ), Padding( padding: const EdgeInsets.all(8.0), child: StatefulColorfulTile(key: UniqueKey()), ), ]; @override Widget build(BuildContext context) { return Scaffold( body: Row(children: tiles), floatingActionButton: FloatingActionButton( child: Icon(Icons.sentiment_very_satisfied), onPressed: swapTiles), ); } swapTiles() { setState(() { tiles.insert(1, tiles.removeAt(0)); }); } } class StatefulColorfulTile extends StatefulWidget { StatefulColorfulTile({Key key}) : super(key: key); @override ColorfulTileState createState() =&gt; ColorfulTileState(); } class ColorfulTileState extends State&lt;ColorfulTile&gt; { Color myColor; @override void initState() { super.initState(); myColor = UniqueColorGenerator.getColor(); } @override Widget build(BuildContext context) { return Container( color: myColor, child: Padding( padding: EdgeInsets.all(70.0), )); } }</span></span></code> </pre> <br><p>  ¡Ahora, con solo tocar un botón, los widgets obtienen colores completamente al azar! </p><br><p><img src="https://habrastorage.org/webt/w2/ge/lb/w2gelbrnaw_hlvftimjhe-vhhim.gif"></p><br><p>  Así es como se ven el árbol de widgets y ElementTree con los widgets <code>Padding</code> agregados: </p><br><p><img src="https://habrastorage.org/webt/k-/br/0o/k-br0o5hmbvzwvjodwemswze0na.jpeg"></p><br><p>  Cuando cambiamos las posiciones de los widgets secundarios, el algoritmo de coincidencia entre elementos y widgets se ve un nivel en el árbol de elementos.  En el diagrama, los hijos de los niños se oscurecen para que nada distraiga del primer nivel.  En este nivel, todo coincide correctamente. </p><br><p><img src="https://habrastorage.org/webt/j6/tt/zp/j6ttzpgzdbpupkzqw4s1vlsyz6g.gif"></p><br><p>  En el segundo nivel, Flutter se da cuenta de que la <code>key</code> elemento de color no coincide con la <code>key</code> widget, por lo que desactiva este elemento, lo descarta y elimina todos los enlaces.  <code>keys</code> que usamos en este ejemplo son <code>LocalKeys</code> .  Esto significa que al hacer coincidir un widget con elementos, Flutter busca <code>keys</code> solo en un cierto nivel del árbol. </p><br><p>  Como no puede encontrar el elemento de widget de color en este nivel con la <code>key</code> correspondiente, crea uno nuevo e inicializa un nuevo estado, ¡haciendo que el widget sea naranja en este caso! </p><br><p><img src="https://habrastorage.org/webt/2q/mn/xk/2qmnxkwb7xpxtyi3jgbefvg70mi.gif"></p><br><p>  Si definimos <code>keys</code> para widgets de <code>Padding</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; runApp(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MaterialApp(home: PositionedTiles())); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatefulWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">State&lt;StatefulWidget&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; PositionedTilesState(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTilesState</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class">&gt; </span></span>{ List&lt;Widget&gt; tiles = [ Padding( <span class="hljs-comment"><span class="hljs-comment">// Place the keys at the *top* of the tree of the items in the collection. key: UniqueKey(), padding: const EdgeInsets.all(8.0), child: StatefulColorfulTile(), ), Padding( key: UniqueKey(), padding: const EdgeInsets.all(8.0), child: StatefulColorfulTile(), ), ]; @override Widget build(BuildContext context) { return Scaffold( body: Row(children: tiles), floatingActionButton: FloatingActionButton( child: Icon(Icons.sentiment_very_satisfied), onPressed: swapTiles), ); } swapTiles() { setState(() { tiles.insert(1, tiles.removeAt(0)); }); } } class StatefulColorfulTile extends StatefulWidget { StatefulColorfulTile({Key key}) : super(key: key); @override ColorfulTileState createState() =&gt; ColorfulTileState(); } class ColorfulTileState extends State&lt;ColorfulTile&gt; { Color myColor; @override void initState() { super.initState(); myColor = UniqueColorGenerator.getColor(); } @override Widget build(BuildContext context) { return Container( color: myColor, child: Padding( padding: EdgeInsets.all(70.0), )); } }</span></span></code> </pre> <br><p>  Flutter nota el problema y actualiza los enlaces correctamente, como sucedió en nuestro ejemplo anterior.  Se restaura el orden en el universo. </p><br><p><img src="https://habrastorage.org/webt/xp/4w/h0/xp4wh0wpzgd-5wxtxdkwu3jogps.gif"></p><br><hr><br><h2 id="kakoy-tip-key-mne-sleduet-ispolzovat">  ¿Qué tipo de <code>Key</code> debo usar? </h2><br><p>  Las API de Flutter nos dieron la opción de varias clases <code>Key</code> .  El tipo de <code>key</code> que debe usar depende de cuál es la característica distintiva de los elementos que necesitan <code>keys</code> .  Mire la información que almacena en los widgets respectivos. </p><br><p>  Considere la siguiente aplicación Tareas pendientes [1], donde puede cambiar el orden de los elementos en la lista de tareas según la prioridad y, cuando haya terminado, puede eliminarlos. </p><br><p><img src="https://habrastorage.org/webt/nz/qb/8g/nzqb8g-8ywgycp0g_xe-6p7-xk0.gif"></p><br><p>  <strong>ValueKey</strong> <br>  En este caso, podemos esperar que el texto del párrafo sobre la implementación sea permanente y único.  Si es así, entonces este es probablemente un buen candidato para <code>ValueKey</code> , donde el texto es "valor". </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TodoItem( key: ValueKey(todo.task), todo: todo, onDismissed: (direction) =&gt; _removeTodo(context, todo), );</code> </pre> <br><p>  <strong>Objectkey</strong> <br>  Alternativamente, puede tener la aplicación Libreta de direcciones, que enumera información sobre cada usuario.  En este caso, cada widget secundario almacena una combinación más compleja de datos.  Cualquiera de los campos individuales, por ejemplo, nombre o fecha de nacimiento, puede coincidir con otra entrada, pero la combinación es única.  En este caso, <code>ObjectKey</code> es probablemente el mejor ajuste. </p><br><p><img src="https://habrastorage.org/webt/jk/jz/av/jkjzavsw7v74t_dnnmb79mvukd0.png"></p><br><p>  <strong>Uniquekey</strong> <br>  Si tiene varios widgets en la colección con el mismo valor o si realmente quiere asegurarse de que cada widget sea diferente de todos los demás, puede usar <code>UniqueKey</code> .  <code>UniqueKey</code> en la aplicación de ejemplo para cambiar los colores, porque no teníamos otros datos constantes que se almacenarían en nuestros widgets, y no sabíamos qué color tendría el widget al crearlo. </p><br><p>  Sin embargo, una cosa que <strong>no desea</strong> utilizar como <code>key</code> es un número aleatorio.  Cada vez que se crea un widget, se generará un nuevo número aleatorio y perderá la coherencia entre los marcos.  En este escenario, ¡no puede usar <code>keys</code> en absoluto! </p><br><p>  <strong>PageStorageKeys</strong> <br>  <code>PageStorageKeys</code> son <code>keys</code> especializadas que contienen el estado actual del desplazamiento para que la aplicación pueda guardarlo para su uso posterior. </p><br><p><img src="https://habrastorage.org/webt/dx/db/if/dxdbif6yn7hlszee_-hbzbaevn8.gif"></p><br><p>  <strong>Globalkeys</strong> <br>  Hay dos opciones para usar <code>GlobalKeys</code> : permiten que los widgets cambien a los padres en cualquier lugar de la aplicación sin perder el estado y se pueden usar para acceder a información sobre otro widget en una parte completamente diferente del árbol de widgets.  Como ejemplo del primer escenario, puede imaginar que desea mostrar el mismo widget en dos pantallas diferentes, pero con el mismo estado, para que se guarden los datos del widget, usará <code>GlobalKey</code> .  En el segundo caso, puede surgir una situación en la que necesite verificar la contraseña, pero no desea compartir información de estado con otros widgets en el árbol.  <code>GlobalKeys</code> también puede ser útil para las pruebas, utilizando la <code>key</code> para acceder a un widget específico y solicitar información sobre su estado. </p><br><p><img src="https://habrastorage.org/webt/eh/rq/bl/ehrqble5pcoeqrh7ktl0j0_dm5s.gif"></p><br><p>  A menudo (¡pero no siempre!) <code>GlobalKeys</code> poco como las variables globales.  A menudo se pueden reemplazar con <code>InheritedWidgets</code> o algo así como Redux, o la plantilla BLoC. </p><br><hr><br><h2 id="kratkoe-zaklyuchenie">  Breve conclusión </h2><br><p>  En general, use <code>Keys</code> si desea mantener el estado entre los subárboles de widgets.  Esto ocurre con mayor frecuencia cuando cambia la colección de widgets del mismo tipo.  Coloque la <code>key</code> en la parte superior del subárbol de widgets que desea guardar y seleccione el tipo de <code>key</code> función de los datos almacenados en el widget. </p><br><p>  ¡Felicitaciones, ahora estás en camino de convertirte en un mago revoloteador!  Oh dije un mago?  Me refería al mago [2], como el que escribe el código fuente de la aplicación ... que es casi tan bueno.  ... casi. </p><br><p>  [1] Inspiración para escribir el código de la aplicación Tareas recibidas aquí <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/brianegan/flutter_architecture_samples/tree/master/vanilla</a> <br>  [2] El autor usa la palabra <code>sorcerer</code> y luego le agrega una carta adicional antes del <code>sourcerer</code> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/446050/">https://habr.com/ru/post/446050/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446038/index.html">Una breve guía sobre la creación de oráculos, dioses del automóvil y errores de segundo orden</a></li>
<li><a href="../446040/index.html">Full Stack Confession: profesión, religión, sueños</a></li>
<li><a href="../446042/index.html">DJI Mavic 2 Pro después de seis meses de uso</a></li>
<li><a href="../446046/index.html">La expansión del universo es la mayor falacia en la historia de la ciencia.</a></li>
<li><a href="../446048/index.html">La unión de Arduino y el procesador clásico.</a></li>
<li><a href="../446052/index.html">Creando la voz y el tono de su producto</a></li>
<li><a href="../446054/index.html">Copia de seguridad lista: destruyendo mitos de vacaciones</a></li>
<li><a href="../446056/index.html">Una manera simple de hablar con su sitio web</a></li>
<li><a href="../446058/index.html">Cómo construir SDN - Ocho herramientas de código abierto</a></li>
<li><a href="../446060/index.html">Síntesis de sueños de alto peso molecular.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>