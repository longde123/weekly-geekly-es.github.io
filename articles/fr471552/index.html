<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚ÄçüöÄ üöû üë° √âcriture d'un clone de moteur Doom: lecture des informations cartographiques üßïüèª ‚ñ´Ô∏è üôé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©sentation 
 L'objectif de ce projet est de cr√©er un clone du moteur DOOM en utilisant les ressources publi√©es avec Ultimate DOOM ( version de Steam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√âcriture d'un clone de moteur Doom: lecture des informations cartographiques</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471552/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2f/423/35b/c2f42335b751d3bd9acec03251204977.png" alt="image"></div><br><h2>  Pr√©sentation </h2><br>  L'objectif de ce projet est de cr√©er un clone du moteur DOOM en utilisant les ressources publi√©es avec Ultimate DOOM ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">version de Steam</a> ). <br><br>  Il sera pr√©sent√© sous la forme d'un tutoriel - je ne veux pas atteindre des performances maximales dans le code, mais juste cr√©er une version de travail, et plus tard je commencerai √† l'am√©liorer et √† l'optimiser. <br><br>  Je n'ai aucune exp√©rience dans la cr√©ation de jeux ou de moteurs de jeu, et peu d'exp√©rience dans la r√©daction d'articles, vous pouvez donc sugg√©rer vos propres modifications ou m√™me r√©√©crire compl√®tement le code. <br><br>  Voici une liste de ressources et de liens. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Livre Game Engine Black Book: DOOM Fabien Sanglar</a> .  L'un des meilleurs livres sur les internes de DOOM. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Wiki Doom</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Code source DOOM</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Code source Chocolate Doom</a> <br><a name="habracut"></a><br><h3>  Pr√©requis </h3><br><ul><li>  Visual Studio: n'importe quel IDE fera l'affaire;  Je travaillerai dans Visual Studio 2017. </li><li>  SDL2: biblioth√®ques. </li><li>  DOOM: une copie de la version Steam de Ultimate DOOM, nous n'avons besoin que d'un fichier WAD. </li></ul><br><h3>  En option </h3><br><ul><li>  Slade3: un bon outil pour tester notre travail. </li></ul><br><h3>  R√©flexions </h3><br>  Je ne sais pas, je peux terminer ce projet, mais je ferai de mon mieux pour cela. <br><br>  Windows sera ma plate-forme cible, mais comme j'utilise SDL, cela fera simplement fonctionner le moteur sous n'importe quelle autre plate-forme. <br><br>  En attendant, installez Visual Studio! <br><br>  Le projet a √©t√© renomm√© de Handmade DOOM en Do It Yourself Doom avec SLD (DIY Doom) afin de ne pas √™tre confondu avec d'autres projets appel√©s ¬´Handmade¬ª.  Il y a quelques captures d'√©cran dans le tutoriel o√π il s'appelle toujours Handmade DOOM. <br><br><h2>  Fichiers WAD </h2><br>  Avant de nous lancer dans le codage, fixons des objectifs et r√©fl√©chissons √† ce que nous voulons r√©aliser. <br><br>  Tout d'abord, v√©rifions si nous pouvons lire les fichiers de ressources DOOM.  Toutes les ressources DOOM se trouvent dans le fichier WAD. <br><br><h2>  Qu'est-ce qu'un fichier WAD? </h2><br>  "O√π sont toutes mes donn√©es"?  ("O√π sont toutes mes donn√©es?") Elles sont dans WAD!  WAD est une archive de toutes les ressources DOOM (et des jeux bas√©s sur DOOM) situ√©es dans un seul fichier. <br><br>  Les d√©veloppeurs de Doom ont propos√© ce format pour simplifier la cr√©ation de modifications de jeu. <br><br><h2>  Anatomie du fichier WAD </h2><br>  Le fichier WAD se compose de trois parties principales: l'en-t√™te (en-t√™te), les ¬´pi√®ces¬ª (grumeaux) et les r√©pertoires (r√©pertoires). <br><br><ol><li>  En-t√™te - contient des informations de base sur le fichier WAD et le d√©calage de r√©pertoire. </li><li>  Montants - voici des ressources de jeu stock√©es, des donn√©es de cartes, de sprites, de musique, etc. </li><li>  R√©pertoires - La structure organisationnelle pour rechercher des donn√©es dans la section forfaitaire. </li></ol><br><br><pre> <code class="hljs erlang-repl"> &lt;---- <span class="hljs-number"><span class="hljs-number">32</span></span> bits ----&gt; /------------------\ ---&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>x00 | ASCII WAD Type | <span class="hljs-number"><span class="hljs-number">0</span></span>X03 | |------------------| Header -| <span class="hljs-number"><span class="hljs-number">0</span></span>x04 | # of directories | <span class="hljs-number"><span class="hljs-number">0</span></span>x07 | |------------------| ---&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>x08 | directory offset | <span class="hljs-number"><span class="hljs-number">0</span></span>x0B -- ---&gt; |------------------| &lt;-- | | <span class="hljs-number"><span class="hljs-number">0</span></span>x0C | Lump Data | | | | |------------------| | | Lumps - | | . | | | | | . | | | | | . | | | ---&gt; | . | | | ---&gt; |------------------| &lt;--|--- | | Lump offset | | | |------------------| | Directory -| | directory offset | --- List | |------------------| | | Lump Name | | |------------------| | | . | | | . | | | . | ---&gt; \------------------/</code> </pre><br><h3>  Format d'en-t√™te </h3><br><div class="scrollable-table"><table><thead><tr><th>  Taille du champ </th><th>  Type de donn√©es </th><th>  Le contenu </th></tr></thead><tbody><tr><td>  0x00-0x03 </td><td>  4 caract√®res ASCII </td><td>  Cha√Æne ASCII (avec les valeurs "IWAD" ou "PWAD"). </td></tr><tr><td>  0x04-0x07 </td><td>  entier non sign√© </td><td>  Num√©ro d'√©l√©ment du r√©pertoire. </td></tr><tr><td>  0x08-0x0b </td><td>  entier non sign√© </td><td>  Valeur de d√©calage du r√©pertoire dans le fichier WAD. </td></tr></tbody></table></div><br><h3>  Format d'annuaire </h3><br><div class="scrollable-table"><table><thead><tr><th>  Taille du champ </th><th>  Type de donn√©es </th><th>  Le contenu </th></tr></thead><tbody><tr><td>  0x00-0x03 </td><td>  entier non sign√© </td><td>  La valeur de d√©calage au d√©but des donn√©es forfaitaires dans le fichier WAD. </td></tr><tr><td>  0x04-0x07 </td><td>  entier non sign√© </td><td>  La taille de la "pi√®ce" (bloc) en octets. </td></tr><tr><td>  0x08-0x0f </td><td>  8 caract√®res ASCII </td><td>  ASCII contenant le nom "pi√®ce". </td></tr></tbody></table></div><br><h2>  Buts </h2><br><ol><li>  Cr√©ez un projet. </li><li>  Ouvrez le fichier WAD. </li><li>  Lisez le titre. </li><li>  Lisez tous les r√©pertoires et affichez-les. </li></ol><br><h2>  L'architecture </h2><br>  Ne compliquons rien encore.  Cr√©ez une classe qui ouvre et charge simplement WAD, et appelez-la WADLoader.  Ensuite, nous √©crivons une classe qui est responsable de la lecture des donn√©es en fonction de leur format, et nous l'appelons WADReader.  Nous avons √©galement besoin d'une fonction <code>main</code> simple qui appelle ces classes. <br><br>  Remarque: cette architecture peut ne pas √™tre optimale, et si n√©cessaire nous la changerons. <br><br><h2>  Acc√©der au code </h2><br>  Commen√ßons par cr√©er un projet C ++ vide.  Dans Visual Studio, cliquez sur Fichier-&gt; Nouveau -&gt; Projet.  Appelons cela DIYDoom. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdc/753/755/bdc7537557888a7ece9738204ecb457d.png"></div><br>  Ajoutons deux nouvelles classes: WADLoader et WADReader.  Commen√ßons par l'impl√©mentation de WADLoader. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WADLoader</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: WADLoader(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> sWADFilePath); <span class="hljs-comment"><span class="hljs-comment">// We always want to make sure a WAD file is passed bool LoadWAD(); // Will call other helper functions to open and load the WAD file ~WADLoader(); // Clean up! protected: bool OpenAndLoad(); // Open the file and load it to memory bool ReadDirectories(); // A function what will iterate though the directory section std::string m_sWADFilePath; // Sore the file name passed to the constructor std::ifstream m_WADFile; // The file stream that will pint to the WAD file. uint8_t *m_WADData; // let's load the file and keep it in memory! It is just a few MBs! std::vector&lt;Directory&gt; m_WADDirectories; //let's store all the directories in this vector. };</span></span></code> </pre> <br>  L'impl√©mentation du constructeur sera simple: initialisez le pointeur de donn√©es et stockez une copie du chemin transf√©r√© dans le fichier WAD. <br><br><pre> <code class="cpp hljs">WADLoader::WADLoader(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> sWADFilePath) : m_WADData(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>), m_sWADFilePath(sWADFilePath) { }</code> </pre> <br>  Passons maintenant √† l'impl√©mentation de la fonction auxiliaire de chargement d' <code>OpenAndLoad</code> : essayez simplement d'ouvrir le fichier en binaire et en cas d'√©chec nous afficherons une erreur. <br><br><pre> <code class="cpp hljs">m_WADFile.open(m_sWADFilePath, ifstream::binary); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_WADFile.is_open()) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Error: Failed to open WAD file"</span></span> &lt;&lt; m_sWADFilePath &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Si tout se passe bien et que nous pouvons trouver et ouvrir le fichier, nous devons conna√Ætre la taille du fichier afin d'allouer de la m√©moire pour y copier le fichier. <br><br><pre> <code class="cpp hljs">m_WADFile.seekg(<span class="hljs-number"><span class="hljs-number">0</span></span>, m_WADFile.end); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> length = m_WADFile.tellg();</code> </pre> <br>  Nous savons maintenant combien d'espace un WAD complet prend et nous allons allouer la quantit√© de m√©moire n√©cessaire. <br><br><pre> <code class="cpp hljs">m_WADData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>[length];</code> </pre> <br>  Copiez le contenu du fichier dans cette m√©moire. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// remember to know the file size we had to move the file pointer all the way to the end! We need to move it back to the beginning. m_WADFile.seekg(ifstream::beg); m_WADFile.read((char *)m_WADData, length); // read the file and place it in m_WADData m_WADFile.close();</span></span></code> </pre> <br>  Vous avez peut-√™tre remarqu√© que j'ai utilis√© le type <code>m_WADData</code> comme type de donn√©es pour <code>unint8_t</code> .  Cela signifie que j'ai besoin d'un tableau exact de 1 octet (1 octet * de longueur).  L'utilisation de unint8_t garantit que la taille est √©gale √† un octet (8 bits, ce qui peut √™tre compris √† partir du nom du type).  Si nous voulions allouer 2 octets (16 bits), nous utiliserions unint16_t, dont nous parlerons plus tard.  En utilisant ces types de code, le code devient ind√©pendant de la plateforme.  Je vais expliquer: si nous utilisons "int", alors la taille exacte de int en m√©moire d√©pendra du syst√®me.  Si nous compilons ¬´int¬ª dans une configuration 32 bits, nous obtenons une taille de m√©moire de 4 octets (32 bits), et lors de la compilation du m√™me code dans une configuration 64 bits, nous obtenons une taille de m√©moire de 8 octets (64 bits)!  Pire encore, la compilation du code sur une plate-forme 16 bits (vous pourriez √™tre un fan de DOS) nous donnera 2 octets (16 bits)! <br><br>  V√©rifions bri√®vement le code et v√©rifions que tout fonctionne.  Mais nous devons d'abord impl√©menter LoadWAD.  Alors que LoadWAD appellera "OpenAndLoad" <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> WADLoader::LoadWAD() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!OpenAndLoad()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Et ajoutons au code de fonction principal qui cr√©e une instance de la classe et essaie de charger WAD <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">WADLoader </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wadloader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"D:\\SDKs\\Assets\\Doom\\DOOM.WAD"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; wadloader.LoadWAD(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  <strong>Vous devrez entrer le chemin d'acc√®s correct √† votre fichier WAD.</strong>  Lan√ßons-le! <br><br>  A√Øe!  Nous avons une fen√™tre de console qui s'ouvre juste pendant quelques secondes!  Rien de particuli√®rement utile ... le programme fonctionne-t-il?  L'id√©e!  Jetons un coup d'≈ìil √† la m√©moire et voyons ce qu'elle contient!  Peut-√™tre y trouverons-nous quelque chose de sp√©cial!  Tout d'abord, placez un point d'arr√™t en double-cliquant √† gauche du num√©ro de ligne.  Vous devriez voir quelque chose comme ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44b/c5c/760/44bc5c7609610c9f8f1efd2c2e2046ef.png"></div><br>  J'ai plac√© un point d'arr√™t imm√©diatement apr√®s avoir lu toutes les donn√©es du fichier pour regarder le tableau de m√©moire et voir ce qui y √©tait charg√©.  Maintenant, ex√©cutez √† nouveau le code!  Dans la fen√™tre automatique, je vois les premiers octets.  Les 4 premiers octets disent "IWAD"!  G√©nial, √ßa marche!  Je n'ai jamais pens√© que ce jour viendrait!  Alors, d'accord, il faut se calmer, il y a encore beaucoup de travail √† faire! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c4/1a3/ddb/4c41a3ddb26bfa88f350435ca4792c31.png" alt="D√©boguer"></div><br><h2>  Lire l'en-t√™te </h2><br>  La taille totale de l'en-t√™te est de 12 octets (de 0x00 √† 0x0b), ces 12 octets sont divis√©s en 3 groupes.  Les 4 premiers octets sont un type de WAD, g√©n√©ralement ¬´IWAD¬ª ou ¬´PWAD¬ª.  IWAD devrait √™tre le WAD officiel publi√© par ID Software, "PWAD" devrait √™tre utilis√© pour les mods.  En d'autres termes, ce n'est qu'un moyen de d√©terminer si le fichier WAD est une version officielle ou s'il est publi√© par des moddeurs.  Notez que la cha√Æne n'est pas termin√©e par NULL, alors faites attention!  Les 4 octets suivants sont unsigned int, qui contient le nombre total de r√©pertoires √† la fin du fichier.  Les 4 octets suivants indiquent le d√©calage du premier r√©pertoire. <br><br>  Ajoutons une structure qui stockera les informations.  Je vais ajouter un nouveau fichier d'en-t√™te et le nommer "DataTypes.h".  Nous y d√©crirons toutes les structures dont nous avons besoin. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Header</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> WADType[<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// I added an extra character to add the NULL uint32_t DirectoryCount; //uint32_t is 4 bytes (32 bits) uint32_t DirectoryOffset; // The offset where the first directory is located. };</span></span></code> </pre> <br>  Nous devons maintenant impl√©menter la classe WADReader, qui lira les donn√©es du tableau d'octets WAD charg√©.  A√Øe!  Il y a une astuce ici - les fichiers WAD sont au format big-endian, c'est-√†-dire que nous devrons d√©placer les octets pour les rendre peu endian (aujourd'hui, la plupart des syst√®mes utilisent peu endian).  Pour ce faire, nous ajouterons deux fonctions, l'une pour le traitement de 2 octets (16 bits), l'autre pour le traitement de 4 octets (32 bits);  si nous devons lire seulement 1 octet, alors rien ne doit √™tre fait. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> WADReader::bytesToShort(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pWADData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (pWADData[offset + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | pWADData[offset]; } <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> WADReader::bytesToInteger(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pWADData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (pWADData[offset + <span class="hljs-number"><span class="hljs-number">3</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">24</span></span>) | (pWADData[offset + <span class="hljs-number"><span class="hljs-number">2</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) | (pWADData[offset + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | pWADData[offset]; }</code> </pre> <br>  Nous sommes maintenant pr√™ts √† lire l'en-t√™te: comptez les quatre premiers octets comme char, puis ajoutez NULL pour simplifier notre travail.  Dans le cas du nombre de r√©pertoires et de leur d√©calage, vous pouvez simplement utiliser des fonctions auxiliaires pour les convertir au format correct. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> WADReader::ReadHeaderData(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pWADData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset, Header &amp;header) { <span class="hljs-comment"><span class="hljs-comment">//0x00 to 0x03 header.WADType[0] = pWADData[offset]; header.WADType[1] = pWADData[offset + 1]; header.WADType[2] = pWADData[offset + 2]; header.WADType[3] = pWADData[offset + 3]; header.WADType[4] = '\0'; //0x04 to 0x07 header.DirectoryCount = bytesToInteger(pWADData, offset + 4); //0x08 to 0x0b header.DirectoryOffset = bytesToInteger(pWADData, offset + 8); }</span></span></code> </pre> <br>  Mettons tout cela ensemble, appelons ces fonctions et imprimons les r√©sultats <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> WADLoader::ReadDirectories() { WADReader reader; Header header; reader.ReadHeaderData(m_WADData, <span class="hljs-number"><span class="hljs-number">0</span></span>, header); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; header.WADType &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; header.DirectoryCount &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; header.DirectoryOffset &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Ex√©cutez le programme et voyez si tout fonctionne! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfa/693/d03/dfa693d039ab66df047768c209561ac2.png"></div><br>  Super!  La ligne IWAD est clairement visible, mais les deux autres chiffres sont-ils corrects?  Essayons de lire les r√©pertoires en utilisant ces d√©calages et voyons si cela fonctionne! <br><br>  Nous devons ajouter une nouvelle structure pour g√©rer le r√©pertoire correspondant aux options ci-dessus. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Directory</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> LumpOffset; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> LumpSize; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> LumpName[<span class="hljs-number"><span class="hljs-number">9</span></span>]; };</code> </pre> <br>  Ajoutons maintenant la fonction ReadDirectories: comptez l'offset et sortez-les! <br><br>  Dans chaque it√©ration, nous multiplions i * 16 pour passer √† l'incr√©ment de d√©calage du r√©pertoire suivant. <br><br><pre> <code class="cpp hljs">Directory directory; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; header.DirectoryCount; ++i) { reader.ReadDirectoryData(m_WADData, header.DirectoryOffset + i * <span class="hljs-number"><span class="hljs-number">16</span></span>, directory); m_WADDirectories.push_back(directory); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; directory.LumpOffset &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; directory.LumpSize &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; directory.LumpName &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br>  Ex√©cutez le code et voyez ce qui se passe.  Ouah!  Une grande liste de r√©pertoires. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fb/7b5/af6/8fb7b5af6df0d44303c11d5bd005e93d.png" alt="Ex√©cuter 2"></div><br>  √Ä en juger par le nom du morceau, nous pouvons supposer que nous avons r√©ussi √† lire les donn√©es correctement, mais il existe peut-√™tre une meilleure fa√ßon de v√©rifier cela.  Nous examinerons les entr√©es du r√©pertoire WAD √† l'aide de Slade3. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d1c/6b7/21c/d1c6b721c04575fe71785efe1f2bdbd3.png"></div><br>  Il semble que le nom et la taille du morceau correspondent aux donn√©es obtenues √† l'aide de notre code.  Aujourd'hui, nous avons fait un excellent travail! <br><br><h2>  Autres remarques </h2><br><ul><li>  √Ä un moment donn√©, j'ai pens√© qu'il serait bon d'utiliser vector pour stocker des r√©pertoires.  Pourquoi ne pas utiliser Map?  Ce sera plus rapide que d'obtenir des donn√©es par recherche vectorielle lin√©aire.  C'est une mauvaise id√©e.  Lors de l'utilisation de la carte, l'ordre des entr√©es du r√©pertoire ne sera pas suivi, mais nous avons besoin de ces informations pour obtenir les donn√©es correctes. <br><br>  Et une autre id√©e fausse: la carte en C ++ est impl√©ment√©e comme des arbres rouge-noir avec un temps de recherche O (log N), et les it√©rations sur la carte donnent toujours un ordre croissant de cl√©s.  Si vous avez besoin d'une structure de donn√©es qui donne le temps moyen O (1) et le pire moment O (N), alors vous devez utiliser une carte non ordonn√©e. </li><li>  <s>Le chargement de tous les fichiers WAD en m√©moire n'est pas une m√©thode d'impl√©mentation optimale.</s>  <s>Il serait plus logique de simplement lire les r√©pertoires dans l'en-t√™te de la m√©moire, puis de revenir au fichier WAD et de charger les ressources √† partir du disque.</s>  <s>J'esp√®re qu'un jour nous en apprendrons plus sur la mise en cache.</s> <br><br>  <strong>DOOMReboot</strong> : <em>compl√®tement en d√©saccord.</em>  <em>15 Mo de RAM de nos jours est une bagatelle compl√®te, et la lecture depuis la m√©moire sera beaucoup plus rapide que le volumineux fseek, qui devra √™tre utilis√© apr√®s avoir t√©l√©charg√© tout ce qui est n√©cessaire pour le niveau.</em>  <em>Cela augmentera le temps de t√©l√©chargement d'au moins une √† deux secondes (cela me prend moins de 20 ms pour t√©l√©charger tout le temps).</em>  <em>fseek utilise le syst√®me d'exploitation.</em>  <em>Quel fichier est le plus susceptible dans le cache RAM, mais il ne le peut pas.</em>  <em>Mais m√™me s'il est l√†, c'est un gros gaspillage de ressources et ces op√©rations vont confondre de nombreuses lectures WAD en termes de cache CPU.</em>  <em>La meilleure chose est que vous pouvez cr√©er des m√©thodes de d√©marrage hybrides et stocker des donn√©es WAD pour un niveau qui tient dans le cache L3 des processeurs modernes, o√π les √©conomies seront incroyables.</em> </li></ul><br><h2>  Code source </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Code source</a> <br><br><h2>  Donn√©es de base de la carte </h2><br>  Apr√®s avoir appris √† lire le fichier WAD, essayons d'utiliser les donn√©es lues.  Ce sera formidable d'apprendre √† lire les donn√©es de mission (monde / niveau) et √† les appliquer.  Les ¬´morceaux¬ª de ces missions (Mission Lumps) devraient √™tre quelque chose de complexe et d√©licat.  Par cons√©quent, nous devrons √©voluer et d√©velopper les connaissances progressivement.  Dans un premier temps, cr√©ons quelque chose comme une fonction Automap: un plan bidimensionnel d'une carte avec une vue de dessus.  Voyons d'abord ce qu'il y a √† l'int√©rieur du bloc de mission. <br><br><h2>  Anatomie de la carte </h2><br>  Reprenons: la description des niveaux DOOM est tr√®s similaire au dessin 2D, sur lequel les murs sont marqu√©s de lignes.  Cependant, pour obtenir des coordonn√©es 3D, chaque mur prend la hauteur du sol et du plafond (XY est le plan le long duquel nous nous d√©pla√ßons horizontalement, et Z est la hauteur qui nous permet de monter et descendre, par exemple, en montant dans un ascenseur ou en sautant d'une plate-forme. Ces trois les composants de coordonn√©es sont utilis√©s pour rendre la mission comme un monde 3D, cependant, pour assurer de bonnes performances, le moteur a certaines limites: il n'y a pas de pi√®ces situ√©es les unes au-dessus des autres √† des niveaux et le joueur ne peut pas regarder vers le haut et vers le bas.  Les roches, par exemple, les roquettes, montent verticalement pour toucher une cible situ√©e sur une plate-forme plus √©lev√©e. <br><br>  Ces caract√©ristiques curieuses ont provoqu√© des holivars sans fin pour savoir si le DOOM est un moteur 2D ou 3D.  Progressivement, un compromis diplomatique a √©t√© trouv√©, qui a sauv√© de nombreuses vies: les parties se sont mises d'accord sur la d√©signation ¬´2.5D¬ª acceptable par les deux. <br><br>  Pour simplifier la t√¢che et revenir au sujet, essayons simplement de lire ces donn√©es 2D et de voir si elles peuvent √™tre utilis√©es d'une mani√®re ou d'une autre.  Plus tard, nous essaierons de les rendre en 3D, mais pour l'instant, nous devons comprendre comment les diff√©rentes parties du moteur fonctionnent ensemble. <br><br>  Apr√®s avoir men√© des recherches, j'ai d√©couvert que chaque mission est compos√©e d'un ensemble de "pi√®ces".  Ces ¬´morceaux¬ª sont toujours repr√©sent√©s dans le fichier WAD d'un jeu DOOM dans le m√™me ordre. <br><br><ol><li>  <strong>Vertexes: les</strong> extr√©mit√©s des murs en 2D.  Deux VERTEX connect√©s forment un LINEDEF.  Trois VERTEX connect√©s forment deux murs / LINEDEF, et ainsi de suite.  Ils peuvent √™tre simplement per√ßus comme les points de connexion de deux ou plusieurs murs.  (Oui, la plupart des gens pr√©f√®rent le pluriel ¬´Vertices¬ª, mais John Carmack ne l'aimait pas. Selon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">merriam-webster</a> , les deux options s'appliquent. </li><li>  <strong>LINEDEFS:</strong> lignes formant des joints entre des sommets et formant des murs.  Toutes les lignes (murs) ne se comportent pas de la m√™me mani√®re, il existe des indicateurs qui sp√©cifient le comportement de ces lignes. </li><li>  <strong>SIDEDDEFS:</strong> dans la vraie vie, les murs ont deux c√¥t√©s - nous en regardons un, le second est de l'autre c√¥t√©.  Les deux c√¥t√©s peuvent avoir des textures diff√©rentes, et SIDEDEFS est le bloc contenant les informations de texture pour le mur (LINEDEF). </li><li>  <strong>SECTEURS: les</strong> secteurs sont des ¬´chambres¬ª obtenues par la jointure LINEDEF.  Chaque secteur contient des informations telles que les hauteurs de plancher et de plafond, les textures, les valeurs d'√©clairage, les actions sp√©ciales, telles que les planchers / plates-formes / ascenseurs mobiles.  Certains de ces param√®tres affectent √©galement le rendu des murs, par exemple, le niveau d'√©clairage et le calcul des coordonn√©es de mappage de texture. </li><li>  <strong>SSECTORS:</strong> (sous-secteurs) forment des zones convexes dans un secteur qui sont utilis√©es dans le rendu en conjonction avec un contournement BSP, et aident √©galement √† d√©terminer o√π un joueur est √† un niveau particulier.  Ils sont tr√®s utiles et sont souvent utilis√©s pour d√©terminer la position verticale d'un joueur.  Chaque SSECTOR est constitu√© de parties connect√©es d'un secteur, par exemple des murs formant un angle.  Ces parties des murs, ou ¬´segments¬ª, sont stock√©es dans leur propre bloc appel√© ... </li><li>  <strong>SEGS:</strong> parties murales / LINEDEF;  en d'autres termes, ce sont les ¬´segments¬ª du mur / LINEDEF.  Le monde est rendu en contournant l'arbre BSP pour d√©terminer les murs √† dessiner en premier (les tous premiers sont les plus proches).  Bien que le syst√®me fonctionne tr√®s bien, il entra√Æne souvent des linedefs en deux SEG ou plus.  Ces SEG sont ensuite utilis√©s pour rendre les murs au lieu de LINEDEF.  La g√©om√©trie de chaque SSECTOR est d√©termin√©e par les segments qu'il contient. </li><li>  <strong>N≈íUDS:</strong> Un n≈ìud BSP est un n≈ìud d'une structure arborescente binaire qui stocke des donn√©es de sous-secteur.  Il est utilis√© pour d√©terminer rapidement quels SSECTOR (et SEG) sont devant le joueur.  L'√©limination des SEG situ√©s derri√®re le lecteur, et donc invisibles, permet au moteur de se concentrer sur les SEG potentiellement visibles, ce qui r√©duit consid√©rablement le temps de rendu. </li><li>  <strong>THINGS:</strong> Lump appel√© THINGS est une liste d'acteurs de d√©cors et de missions (ennemis, armes, etc.).  Chaque √©l√©ment de ce bloc contient des informations sur une instance de l'acteur / ensemble, par exemple, le type d'objet, le point de cr√©ation, la direction, etc. </li><li>  <strong>REJETER:</strong> ce bloc contient des donn√©es sur les secteurs visibles des autres secteurs.  Il est utilis√© pour d√©terminer quand un monstre apprend la pr√©sence d'un joueur.  Il est √©galement utilis√© pour d√©terminer la plage de distribution des sons cr√©√©s par le joueur, par exemple, les tirs.  Lorsqu'un tel son peut √™tre transmis au secteur du monstre, il peut en apprendre davantage sur le joueur.  La table REJECT peut √©galement √™tre utilis√©e pour acc√©l√©rer la reconnaissance des collisions d'obus d'armes. </li><li>  <strong>BLOCKMAP:</strong> informations sur la reconnaissance des collisions des joueurs et le mouvement THING.  Se compose d'une grille couvrant la g√©om√©trie de l'ensemble de la mission.  Chaque cellule de la grille contient une liste de LINEDEF qui se trouvent √† l'int√©rieur ou se croisent.  Il est utilis√© pour acc√©l√©rer consid√©rablement la reconnaissance des collisions: les v√©rifications de collision ne sont n√©cessaires que pour quelques LINEDEF par joueur / CHOSE, ce qui √©conomise consid√©rablement la puissance de calcul. </li></ol><br>  Lors de la g√©n√©ration de notre carte 2D, nous nous concentrerons sur les VERTEXES et LINEDEFS.  Si nous pouvons dessiner les sommets et les relier aux lignes donn√©es par linedef, alors nous devons g√©n√©rer un mod√®le 2D de la carte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f4/dd4/a3b/3f4dd4a3b79fab0d47e7f1212a73df83.png" alt="Carte de d√©monstration"></div><br>  La carte de d√©monstration illustr√©e ci-dessus pr√©sente les caract√©ristiques suivantes: <br><br><ul><li>  4 pics <ul><li>  sommet 1 po (10.10) </li><li>  top 2 √† (10,100) </li><li>  top 3 √† (100, 10) </li><li>  pic 4 po (100,100) </li></ul></li><li>  4 lignes <ul><li>  ligne du haut 1 au 2 </li><li>  ligne du haut 1 au 3 </li><li>  ligne du haut 2 au 4 </li><li>  ligne du haut 3 au 4 </li></ul></li></ul><br><h3>  Format de sommet </h3><br>  Comme vous pouvez vous y attendre, les donn√©es de sommet sont tr√®s simples - juste x et y (point) de certaines coordonn√©es. <br><br><div class="scrollable-table"><table><thead><tr><th>  Taille du champ </th><th>  Type de donn√©es </th><th>  Le contenu </th></tr></thead><tbody><tr><td>  0x00-0x01 </td><td>  Sign√© court </td><td>  Position X </td></tr><tr><td>  0x02-0x03 </td><td>  Sign√© court </td><td>  Position Y </td></tr></tbody></table></div><br><h3>  Format Linedef </h3><br>  Linedef contient plus d'informations; il d√©crit la ligne reliant les deux sommets et les propri√©t√©s de cette ligne (qui deviendra plus tard un mur). <br><br><div class="scrollable-table"><table><thead><tr><th>  Taille du champ </th><th>  Type de donn√©es </th><th>  Le contenu </th></tr></thead><tbody><tr><td>  0x00-0x01 </td><td>  Court non sign√© </td><td>  Pic de d√©part </td></tr><tr><td>  0x02-0x03 </td><td>  Court non sign√© </td><td>  Pic ultime </td></tr><tr><td>  0x04-0x05 </td><td>  Court non sign√© </td><td>  Drapeaux (voir ci-dessous pour plus de d√©tails) </td></tr><tr><td>  0x06-0x07 </td><td>  Court non sign√© </td><td>  Type de ligne / Action </td></tr><tr><td>  0x08-0x09 </td><td>  Court non sign√© </td><td>  Label de secteur </td></tr><tr><td>  0x10-0x11 </td><td>  Court non sign√© </td><td>  Front sidedef (0xFFFF - pas de c√¥t√©) </td></tr><tr><td>  0x12-0x13 </td><td>  Court non sign√© </td><td>  Side sidedef (0xFFFF - pas de c√¥t√©) </td></tr></tbody></table></div><br><h3>  Valeurs du drapeau de Linedef </h3><br>  Toutes les lignes (murs) ne sont pas dessin√©es.  Certains d'entre eux ont un comportement sp√©cial. <br><br><div class="scrollable-table"><table><thead><tr><th>  Bit </th><th>  La description </th></tr></thead><tbody><tr><td>  0 </td><td>  Bloque la voie pour les joueurs et les monstres </td></tr><tr><td>  1 </td><td>  Bloquer les monstres </td></tr><tr><td>  2 </td><td>  Double face </td></tr><tr><td>  3 </td><td>  La texture sup√©rieure est d√©sactiv√©e (nous en reparlerons plus tard) </td></tr><tr><td>  4 </td><td>  La texture du bas est d√©sactiv√©e (nous en reparlerons plus tard) </td></tr><tr><td>  5 </td><td>  Secret (montr√© sur la carte comme un mur unilat√©ral) </td></tr><tr><td>  6 </td><td>  Obstrue le son </td></tr><tr><td>  7 </td><td>  Jamais montr√© sur la carte automatique </td></tr><tr><td>  8 </td><td>  Toujours affich√© sur la carte automatique </td></tr></tbody></table></div><br><h2>  Buts </h2><br><ol><li>  Cr√©ez une classe Map. </li><li>  Lire les donn√©es des sommets. </li><li>  Lisez les donn√©es de linedef. </li></ol><br><h2>  L'architecture </h2><br>  Tout d'abord, cr√©ons une classe et appelons-la map.  Nous y stockons toutes les donn√©es associ√©es √† la carte. <br><br>  Pour l'instant, je pr√©vois de ne stocker que les sommets et les lignes en tant que vecteur, afin de pouvoir les appliquer plus tard. <br><br>  Compl√©tons √©galement WADLoader et WADReader afin de pouvoir lire ces deux nouvelles informations. <br><br><h2>  Codage </h2><br>  Le code sera similaire au code de lecture WAD, nous n'ajouterons que quelques structures suppl√©mentaires, puis les remplirons de donn√©es WAD.  Commen√ßons par ajouter une nouvelle classe et en passant le nom de la carte. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Map(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> sName); ~Map(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// Incase someone need to know the map name void AddVertex(Vertex &amp;v); // Wrapper class to append to the vertexes vector void AddLinedef(Linedef &amp;l); // Wrapper class to append to the linedef vector protected: std::string m_sName; std::vector&lt;Vertex&gt; m_Vertexes; std::vector&lt;Linedef&gt; m_Linedef; };</span></span></code> </pre> <br>  Ajoutez maintenant des structures pour lire ces nouveaux champs.  Comme nous l'avons d√©j√† fait plusieurs fois, ajoutez-les tous en m√™me temps. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vertex</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> XPosition; <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> YPosition; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Linedef</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> StartVertex; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> EndVertex; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> Flags; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> LineType; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> SectorTag; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> FrontSidedef; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> BackSidedef; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ensuite, nous avons besoin d'une fonction pour les lire √† partir de WADReader, elle sera proche de ce que nous avons fait plus t√¥t. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> WADReader::ReadVertexData(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pWADData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset, Vertex &amp;vertex) { vertex.XPosition = Read2Bytes(pWADData, offset); vertex.YPosition = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> WADReader::ReadLinedefData(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pWADData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset, Linedef &amp;linedef) { linedef.StartVertex = Read2Bytes(pWADData, offset); linedef.EndVertex = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">2</span></span>); linedef.Flags = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">4</span></span>); linedef.LineType = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">6</span></span>); linedef.SectorTag = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">8</span></span>); linedef.FrontSidedef = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">10</span></span>); linedef.BackSidedef = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">12</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je pense qu'il n'y a rien de nouveau pour vous ici. </font><font style="vertical-align: inherit;">Et maintenant, nous devons appeler ces fonctions √† partir de la classe WADLoader. </font><font style="vertical-align: inherit;">Permettez-moi de dire les faits: la s√©quence de blocs est importante ici, nous trouverons le nom de la carte dans le r√©pertoire des blocs, suivi de tous les blocs associ√©s aux cartes dans l'ordre donn√©. </font><font style="vertical-align: inherit;">Pour simplifier notre t√¢che et ne pas suivre les indices de grumeaux s√©par√©ment, nous allons ajouter une √©num√©ration qui nous permet de nous d√©barrasser des nombres magiques.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> EMAPLUMPSINDEX { eTHINGS = <span class="hljs-number"><span class="hljs-number">1</span></span>, eLINEDEFS, eSIDEDDEFS, eVERTEXES, eSEAGS, eSSECTORS, eNODES, eSECTORS, eREJECT, eBLOCKMAP, eCOUNT };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ajouterai √©galement une fonction pour rechercher une carte par son nom dans la liste des r√©pertoires. </font><font style="vertical-align: inherit;">Plus tard, nous allons probablement augmenter les performances de cette √©tape en utilisant la structure des donn√©es de la carte, car il y a un nombre important d'enregistrements ici, et nous devrons les parcourir assez souvent, en particulier au d√©but du chargement des ressources telles que les textures, les sprites, les sons, etc.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> WADLoader::FindMapIndex(Map &amp;<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; m_WADDirectories.size(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_WADDirectories[i].LumpName == <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>.GetName()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wow, nous avons presque fini! </font><font style="vertical-align: inherit;">Maintenant, comptons juste les VERTEXES! </font><font style="vertical-align: inherit;">Je le r√©p√®te, nous l'avons d√©j√† fait auparavant, maintenant vous devez comprendre cela.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> WADLoader::ReadMapVertex(Map &amp;<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iMapIndex = FindMapIndex(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iMapIndex == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } iMapIndex += EMAPLUMPSINDEX::eVERTEXES; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(m_WADDirectories[iMapIndex].LumpName, <span class="hljs-string"><span class="hljs-string">"VERTEXES"</span></span>) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iVertexSizeInBytes = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Vertex); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iVertexesCount = m_WADDirectories[iMapIndex].LumpSize / iVertexSizeInBytes; Vertex vertex; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; iVertexesCount; ++i) { m_Reader.ReadVertexData(m_WADData, m_WADDirectories[iMapIndex].LumpOffset + i * iVertexSizeInBytes, vertex); <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>.AddVertex(vertex); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; vertex.XPosition &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; vertex.YPosition &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hmm, il semble que nous copions constamment le m√™me code; </font><font style="vertical-align: inherit;">vous devrez peut-√™tre l'optimiser √† l'avenir, mais pour l'instant, vous allez impl√©menter ReadMapLinedef vous-m√™me (ou regarder le code source √† partir du lien). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Touche finale - nous devons appeler cette fonction et lui passer l'objet cartographique.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> WADLoader::LoadMapData(Map &amp;<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ReadMapVertex(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Error: Failed to load map vertex data MAP: "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>.GetName() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ReadMapLinedef(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Error: Failed to load map linedef data MAP: "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>.GetName() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifions maintenant la fonction principale et voyons si tout fonctionne. </font><font style="vertical-align: inherit;">Je souhaite charger la carte ¬´E1M1¬ª, que je transf√©rerai sur l'objet carte.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">Map </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"E1M1"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; wadloader.LoadMapData(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, ex√©cutons tout cela. </font><font style="vertical-align: inherit;">Wow, un tas de chiffres int√©ressants, mais sont-ils vrais? </font><font style="vertical-align: inherit;">Voyons √ßa! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voyons si Slade peut nous aider. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons trouver la carte dans le menu slade et regarder les d√©tails des morceaux. </font><font style="vertical-align: inherit;">Comparons les chiffres.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48b/3ec/439/48b3ec43988e25260d45a4abd1999c91.png" alt="Vertex"></div><br>  Super! <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et Linedef? </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/96f/93d/ecd/96f93decd409dad0b8b6836726345a08.png" alt="Linedef"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> J'ai √©galement ajout√© cette √©num√©ration, que nous essaierons d'utiliser lors du rendu de la carte. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ELINEDEFFLAGS { eBLOCKING = <span class="hljs-number"><span class="hljs-number">0</span></span>, eBLOCKMONSTERS = <span class="hljs-number"><span class="hljs-number">1</span></span>, eTWOSIDED = <span class="hljs-number"><span class="hljs-number">2</span></span>, eDONTPEGTOP = <span class="hljs-number"><span class="hljs-number">4</span></span>, eDONTPEGBOTTOM = <span class="hljs-number"><span class="hljs-number">8</span></span>, eSECRET = <span class="hljs-number"><span class="hljs-number">16</span></span>, eSOUNDBLOCK = <span class="hljs-number"><span class="hljs-number">32</span></span>, eDONTDRAW = <span class="hljs-number"><span class="hljs-number">64</span></span>, eDRAW = <span class="hljs-number"><span class="hljs-number">128</span></span> };</code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Autres remarques </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de l'√©criture du code, j'ai lu par erreur plus d'octets que n√©cessaire et j'ai re√ßu des valeurs incorrectes. </font><font style="vertical-align: inherit;">Pour le d√©bogage, j'ai commenc√© √† regarder le d√©calage WAD en m√©moire pour voir si j'√©tais au bon d√©calage. </font><font style="vertical-align: inherit;">Cela peut √™tre fait en utilisant la fen√™tre de m√©moire de Visual Studio, qui est un outil tr√®s utile pour suivre les octets ou la m√©moire (vous pouvez √©galement d√©finir des points d'arr√™t dans cette fen√™tre). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous ne voyez pas la fen√™tre de m√©moire, acc√©dez √† D√©bogage&gt; M√©moire&gt; M√©moire.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27d/cba/0d3/27dcba0d33094493822f4444a4c0d8c8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous voyons les valeurs en m√©moire en hexad√©cimal. </font><font style="vertical-align: inherit;">Ces valeurs peuvent √™tre compar√©es √† l'affichage hexad√©cimal dans slade en cliquant avec le bouton droit sur une bosse et en l'affichant en hexad√©cimal.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cc/159/757/1cc15975726f8a1204bf674aa0824fc6.png" alt="Slade"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comparez-les avec l'adresse du WAD charg√© en m√©moire. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/970/2af/c96/9702afc96be99794e7d9f01e4d6d89bb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et la derni√®re chose pour aujourd'hui: nous avons vu toutes ces valeurs de vertex, mais existe-t-il un moyen facile de les visualiser sans √©crire de code? </font><font style="vertical-align: inherit;">Je ne veux pas perdre de temps l√†-dessus, juste pour d√©couvrir que nous allons dans la mauvaise direction. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Certes, quelqu'un a d√©j√† cr√©√© un traceur. </font><font style="vertical-align: inherit;">J'ai googl√© ¬´dessiner des points sur un graphique¬ª et le premier r√©sultat a √©t√© le site Web </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plot Points - Desmos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sur celui-ci, vous pouvez coller des nombres depuis le presse-papiers et il les dessinera. </font><font style="vertical-align: inherit;">Ils doivent √™tre au format "(x, y)". </font><font style="vertical-align: inherit;">Pour l'obtenir, changez simplement la fonction de sortie √† l'√©cran.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"("</span></span> &lt;&lt; vertex.XPosition &lt;&lt; <span class="hljs-string"><span class="hljs-string">","</span></span> &lt;&lt; vertex.YPosition &lt;&lt; <span class="hljs-string"><span class="hljs-string">")"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ouah! </font><font style="vertical-align: inherit;">Il ressemble d√©j√† √† un E1M1! </font><font style="vertical-align: inherit;">Nous avons r√©alis√© quelque chose!</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/499/ce6/36b/499ce636b2dbd6bd3e158bff07304b37.png" alt="Points de trac√© E1M1"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous √™tes paresseux pour ce faire, voici un lien vers un graphique en pointill√©s: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plot Vertex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais faisons un pas de plus: apr√®s un peu de travail, nous pouvons relier ces points en fonction des lignes de rep√®re.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2f/423/35b/c2f42335b751d3bd9acec03251204977.png" alt="E1M1 Plot Vertex"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici le lien: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E1M1 Plot Vertex</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code source </font></font></h2><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code source</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les r√©f√©rences </font></font></h2><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom Wiki </font></font></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZDoom Wiki</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr471552/">https://habr.com/ru/post/fr471552/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr471538/index.html">De l'id√©e d'une application mobile au MVP dans lequel les investisseurs investiront</a></li>
<li><a href="../fr471542/index.html">Reconnaissance de texte OCR</a></li>
<li><a href="../fr471544/index.html">A propos de l'amour, ou pourquoi le centurion cosaque a chang√© son uniforme en robe ouzbek</a></li>
<li><a href="../fr471548/index.html">Top 5 des livres √† lire par un artiste</a></li>
<li><a href="../fr471550/index.html">O√π obtenir de l'audio pour le d√©veloppement de jeux et d'autres projets commerciaux? Des biblioth√®ques aux sons de la nature</a></li>
<li><a href="../fr471554/index.html">Comment r√©duire les risques de r√©clamations fiscales li√©es √† la vente d'applications et de contenus?</a></li>
<li><a href="../fr471556/index.html">Fujitsu World Tour 2019. Comment √©tait notre plus grande conf√©rence</a></li>
<li><a href="../fr471558/index.html">Maman, je suis √† la t√©l√©vision: comment s'est pass√©e la finale du concours Digital Breakthrough</a></li>
<li><a href="../fr471562/index.html">Superinfection 2: Rubicon de probl√®mes, le fiasco de la technologie et un nouvel espoir</a></li>
<li><a href="../fr471564/index.html">Friends RaspberryPi avec TP-Link TL-WN727N</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>