<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤰🏿 👩🏻‍🤝‍👨🏽 👨‍👦‍👦 Reagir ganchos - ganhar ou perder? 🎮 🆗 👨🏽‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Com o lançamento do novo React 16.6.0, HOOKS (PROPOSAL) apareceu na documentação. Agora eles estão disponíveis no react 17.0.0-alpha e são discutidos ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reagir ganchos - ganhar ou perder?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428317/"><p><img src="https://habrastorage.org/webt/qi/fs/qc/qifsqcglrtrastzefywxuzgnhfk.jpeg" alt="imagem"></p><br><p>  Com o lançamento do novo React 16.6.0, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HOOKS (PROPOSAL)</a> apareceu na documentação.  Agora eles estão disponíveis no react 17.0.0-alpha e são discutidos no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RFC</a> aberto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">: React Hooks</a> .  Vamos ver o que é e por que é necessário sob o corte. </p><a name="habracut"></a><br><p>  Sim, é RFC e você pode influenciar a implementação final, discutindo com os criadores do reag porque eles escolheram essa ou aquela abordagem. </p><br><p>  Vamos dar uma olhada em como é um gancho padrão: </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { useState } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Example</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Declare a new state variable, which we'll call "count" const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me &lt;/button&gt; &lt;/div&gt; ); }</span></span></code> </pre> <br><p>  Tente pensar nesse código, este é um teaser e, no final do artigo, você já entenderá o que significa.  A primeira coisa que você deve saber é que isso não quebra a compatibilidade com versões anteriores e talvez elas sejam adicionadas na versão 16.7 após a coleta de comentários e sugestões na RFC. </p><br><p>  Como os rapazes garantem, este não é um plano para eliminar as aulas de um reagente. </p><br><p>  Além disso, ganchos não substituem os conceitos atuais da reação, tudo está no lugar de adereços / estado / contexto / refs.  Esta é apenas outra maneira de usar seu poder. </p><br><h3 id="motivaciya">  Motivação </h3><br><p>  Os ganchos resolvem, à primeira vista, problemas não conectados que apareceram com o suporte de dezenas de milhares de componentes ao longo de 5 anos no facebook. </p><br><p>  O mais difícil é reutilizar a lógica em componentes com estado, a reação não tem como anexar um comportamento reutilizável ao componente (por exemplo, conectá-lo ao repositório).  Se você trabalhou com o React, conhece o conceito de HOC (componente de alta ordem) ou renderiza adereços.  Esses padrões são bons o suficiente, mas às vezes são usados ​​excessivamente, exigem reestruturação dos componentes para que possam ser usados, o que geralmente torna o código mais complicado.  Vale a pena examinar um aplicativo típico de reação e ficará claro o que está em jogo. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/35f/c76/c98/35fc76c98f2288b4c2c46a45a2f4145c.gif" alt="imagem"></p><br><p>  Isso é chamado <em>de inferno envolto - inferno envolto</em> . </p><br><p>  Uma aplicação de HOCs sozinha é normal nas realidades atuais, eles conectaram o componente à loja / tema / localização / custom hock, acho que todo mundo sabe disso. </p><br><p>  Torna-se claro que a reação precisa de outro mecanismo primitivo para separar a lógica. </p><br><p>  Usando ganchos, podemos extrair o estado de um componente para que possa ser testado e reutilizado.  Os ganchos permitem reutilizar a lógica do estado sem alterar a hierarquia dos componentes.  Isso facilita a troca de links entre muitos componentes ou todo o sistema.  Além disso, os componentes da classe parecem bastante assustadores, descrevemos os métodos do ciclo de vida de <code>componentDidMount</code> / <code>shouldComponentUpdate</code> / <code>componentDidUpdate</code> , o estado do componente, cria métodos para trabalhar com o estado / lado, vincula métodos para a instância do componente e, assim, pode continuar.  Normalmente, esses componentes vão além das linhas x, onde x é difícil o suficiente para entender. </p><br><p>  Os ganchos permitem fazer o mesmo dividindo a lógica entre componentes em pequenas funções e usando-os dentro dos componentes. </p><br><h3 id="klassy-slozhny-dlya-lyudey-i-dlya-mashin">  As aulas são difíceis para pessoas e carros </h3><br><p>  Ao observar as aulas no Facebook, é um grande obstáculo ao aprender o React.  Você precisa entender como <code>this</code> funciona e, como em outras linguagens de programação, você também deve se lembrar sobre os manipuladores de eventos de ligação.  Sem sentenças de sintaxe estáveis, o código parece muito detalhado.  As pessoas entendem os padrões de adereços / estado e o chamado fluxo de dados de cima para baixo, mas as classes são bastante difíceis de entender. </p><br><p>  Especialmente se não se limitando a modelos, há pouco tempo os caras da reação experimentaram o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">layout dos componentes</a> com o Prepack e obtiveram resultados promissores, mas, mesmo assim, os componentes da classe permitem criar padrões indesejados indesejados que fazem essas otimizações desaparecerem, as classes também não migram muito bem quando As classes de recarga a quente tornam isso não confiável.  Primeiro, os caras queriam fornecer uma API que suporta todas as otimizações e funciona bem com uma reinicialização a quente. </p><br><h3 id="glyanem-na-huki">  Dê uma olhada nos ganchos </h3><br><h4 id="state-hook">  Gancho de estado </h4><br><p>  O código abaixo renderiza um parágrafo e um botão e, se clicarmos no botão, o valor no parágrafo será incrementado. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { useState } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Example</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Declare a new state variable, which we'll call "count" const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me &lt;/button&gt; &lt;/div&gt; ); }</span></span></code> </pre> <br><p>  A partir disso, podemos concluir que esse gancho funciona de maneira semelhante com um conceito como <code>state</code> . <br>  Um método <code>useState</code> um pouco mais detalhado usa um argumento, esse é o valor padrão e retorna uma tupla na qual existe o valor em si e o método para alterá-lo, ao contrário de setState, setCount não fará <em>mesclagem de</em> valores, mas simplesmente atualize-o.  Também podemos usar várias declarações de estado, por exemplo: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExampleWithManyStates</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Declare multiple state variables! const [age, setAge] = useState(42); const [fruit, setFruit] = useState('banana'); const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]); // ... }</span></span></code> </pre> <br><p>  Assim, criamos vários estados ao mesmo tempo e não precisamos pensar em como decompô-los de alguma forma.  Assim, pode-se distinguir que ganchos são funções que permitem "conectar-se" aos chips de componentes de classe, assim como ganchos não funcionam dentro de classes, é importante lembrar. </p><br><h4 id="effect-hook">  Gancho de efeito </h4><br><p>  Frequentemente, nos componentes da classe, criamos funções de efeito colateral, por exemplo, assinamos eventos ou fazemos solicitações de dados, geralmente para isso usamos os métodos <code>componentDidUpdate</code> / <code>componentDidUpdate</code> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { useState, useEffect } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Example</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [count, setCount] = useState(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Similar to componentDidMount and componentDidUpdate: useEffect(() =&gt; { // Update the document title using the browser API document.title = `You clicked ${count} times`; }); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me &lt;/button&gt; &lt;/div&gt; ); }</span></span></code> </pre> <br><p>  Quando chamamos <code>useEffect</code> , dizemos à reação para fazer um 'efeito colateral' após atualizar as alterações na árvore DOM.  Os efeitos são declarados dentro do componente, portanto, eles têm acesso a props / state.  Além disso, podemos criá-los exatamente da mesma maneira que você quiser. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FriendStatusWithCounter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [count, setCount] = useState(<span class="hljs-number"><span class="hljs-number">0</span></span>); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.title = <span class="hljs-string"><span class="hljs-string">`You clicked </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${count}</span></span></span><span class="hljs-string"> times`</span></span>; }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [isOnline, setIsOnline] = useState(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); }; }); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleStatusChange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">status</span></span></span><span class="hljs-function">) </span></span>{ setIsOnline(status.isOnline); } <span class="hljs-comment"><span class="hljs-comment">// ...</span></span></code> </pre> <br><p>  Imediatamente, vale a pena prestar atenção ao segundo efeito colateral, retornamos a função, fazemos isso para executar algumas ações após a desmontagem do componente, na nova API isso é chamado de efeitos com a limpeza.  Outros efeitos podem retornar qualquer coisa. </p><br><h3 id="pravila-hukov">  Regras de gancho </h3><br><p>  Ganchos são apenas funções javascript, mas requerem apenas duas regras: </p><br><ul><li>  Ganchos devem ser executados no topo da hierarquia de funções (isso significa que você não deve chamar ganchos em condições e loops, caso contrário, a reação não pode garantir a ordem de execução dos ganchos) </li><li>  Ganchos de chamada apenas nas funções React ou componentes funcionais ou ganchos de chamada de ganchos personalizados (abaixo). <br>  Para seguir essas regras, os caras da equipe de reação criaram um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">plug-in de linter</a> que gerará <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um</a> erro se você chamar ganchos nos componentes da classe ou em loops e condições. </li></ul><br><h3 id="kastomnye-huki">  Ganchos personalizados </h3><br><p>  Ao mesmo tempo, queremos reutilizar a lógica dos componentes com estado, geralmente os padrões HOC ou de adereços de renderização são usados ​​para isso, mas eles criam volume adicional de nosso aplicativo. <br>  Por exemplo, descrevemos a seguinte função: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { useState, useEffect } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useFriendStatus</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">friendID</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [isOnline, setIsOnline] = useState(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleStatusChange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">status</span></span></span><span class="hljs-function">) </span></span>{ setIsOnline(status.isOnline); } useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange); }; }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isOnline; }</code> </pre> <br><p>  Perceba esse código, será um gancho personalizado que podemos chamar em vários componentes.  Por exemplo, assim: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FriendStatus</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isOnline = useFriendStatus(props.friend.id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isOnline === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Loading...'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isOnline ? <span class="hljs-string"><span class="hljs-string">'Online'</span></span> : <span class="hljs-string"><span class="hljs-string">'Offline'</span></span>; }</code> </pre> <br><p>  mais ou menos </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FriendListItem</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isOnline = useFriendStatus(props.friend.id); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">li</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{{</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">color:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">isOnline</span></span></span></span><span class="xml"><span class="hljs-tag"> ? '</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">green</span></span></span></span><span class="xml"><span class="hljs-tag">' </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span></span><span class="xml"><span class="hljs-tag"> '</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">black</span></span></span></span><span class="xml"><span class="hljs-tag">' }}&gt;</span></span></span><span class="xml"> {props.friend.name} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">li</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); }</code> </pre> <br><p>  De qualquer forma, reutilizamos o estado do componente, cada chamada para a função <code>useFriendStatus</code> cria um estado isolado.  Também é importante notar que o início desta função começa com a palavra <em>use</em> , o que significa que é um gancho.  Recomendamos que você siga este formato.  Você pode escrever ganchos personalizados para qualquer coisa, animações / assinaturas / temporizadores e muito mais. </p><br><p>  Existem mais alguns ganchos. </p><br><h4 id="usecontext">  useContext </h4><br><p>  <code>useContext</code> permite que você use o valor de retorno usual em vez de renderProps, o contexto que queremos recuperar nele e ele o retornará para nós, para que possamos nos livrar de todos os HOCs que passaram o contexto para adereços. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Example</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> locale = useContext(LocaleContext); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> theme = useContext(ThemeContext); <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  E agora podemos apenas usar o objeto de contexto no valor de retorno. </p><br><h4 id="usecallback">  useCallback </h4><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoizedCallback = useCallback( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { doSomething(a, b); }, [a, b], );</code> </pre> <br><p>  Quantas vezes você teve que criar um componente de uma classe apenas para salvar uma referência a um método?  Isso não precisa mais ser feito, podemos usar useCallback e nossos componentes não serão redesenhados porque um novo link para o onClick chegou. </p><br><h4 id="usememo">  useMemo </h4><br><p>  Retornamos o valor memorizado, o valor memorizado significa que ele é calculado apenas quando um dos argumentos mudou, na segunda vez que a mesma coisa não será calculada. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoizedValue = useMemo(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> computeExpensiveValue(a, b), [a, b]);</code> </pre> <br><p>  Sim, aqui você deve duplicar os valores na matriz para que o gancho entenda que eles não foram alterados. </p><br><h4 id="useref">  useRef </h4><br><p>  <code>useRef</code> retorna um valor <code>.current</code> , onde o campo <code>.current</code> será inicializado com o primeiro argumento, o objeto existirá enquanto o componente existir. <br>  O exemplo mais comum ao se concentrar na entrada </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TextInputWithFocusButton</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> inputEl = useRef(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onButtonClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// `current` points to the mounted text input element inputEl.current.focus(); }; return ( &lt;&gt; &lt;input ref={inputEl} type="text" /&gt; &lt;button onClick={onButtonClick}&gt;Focus the input&lt;/button&gt; &lt;/&gt; ); }</span></span></code> </pre> <br><h4 id="useimperativemethods">  useImperativeMethods </h4><br><p>  <code>useImperativeMethods</code> customiza o valor da instância que é passada do pai e usa ref diretamente.  Como sempre, os links diretos devem ser evitados e o <code>forwardRef</code> deve ser usado </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FancyInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props, ref</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> inputRef = useRef(); useImperativeMethods(ref, () =&gt; <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ focus: (</span></span></span><span class="hljs-function">) =&gt;</span></span> { inputRef.current.focus(); } })); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">input</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">ref</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{inputRef}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">...</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">; } FancyInput = forwardRef(FancyInput);</span></span></code> </pre> <br><p>  Neste exemplo, o componente que <code>FancyInput</code> pode chamar <code>fancyInputRef.current.focus()</code> . </p><br><h4 id="usemutationeffect">  useMutationEffect </h4><br><p>  <code>useMutationEffect</code> muito semelhante ao <code>useEffect</code> exceto que ele é iniciado de forma síncrona no estágio em que a reação altera os valores do DOM antes da atualização dos componentes vizinhos. Esse gancho deve ser usado para executar mutações no DOM. <br>  É melhor preferir useEffect para impedir o bloqueio de alterações visuais. </p><br><h4 id="uselayouteffect">  useLayoutEffect </h4><br><p>  <code>useLayoutEffect</code> é semelhante ao <code>useEffect</code> exceto que é executado de forma síncrona <em>após todas as atualizações do DOM</em> e a nova renderização síncrona.  As atualizações planejadas em <code>useLayoutEffect</code> são aplicadas de forma síncrona antes que o navegador possa desenhar elementos.  Você também deve tentar usar o <code>useEffect</code> padrão para não bloquear alterações visuais. </p><br><h4 id="usereducer">  useReducer </h4><br><p>  <code>useReducer</code> é um gancho para criar um redutor que retorna o estado e a capacidade de despachar alterações: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [state, dispatch] = useReducer(reducer, initialState);</code> </pre> <br><p>  Se você entende como o Redux funciona, entende como o <code>useReducer</code> funciona.  O mesmo exemplo que estava com o contador acima apenas através do <code>useReducer</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> initialState = {<span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reducer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, action</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'reset'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> initialState; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'increment'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">count</span></span>: state.count + <span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'decrement'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">count</span></span>: state.count - <span class="hljs-number"><span class="hljs-number">1</span></span>}; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Counter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{initialCount}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [state, dispatch] = useReducer(reducer, initialState); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;&gt; Count: {state.count} &lt;button onClick={(</span></span></span><span class="hljs-function">) =&gt;</span></span> dispatch({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'reset'</span></span>})}&gt; Reset &lt;<span class="hljs-regexp"><span class="hljs-regexp">/button&gt; &lt;button onClick={() =&gt; dispatch({type: 'increment'})}&gt;+&lt;/</span></span>button&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{()</span></span></span></span><span class="xml"><span class="hljs-tag"> =&gt;</span></span></span><span class="xml"> dispatch({type: 'decrement'})}&gt;-</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;<span class="hljs-regexp"><span class="hljs-regexp">/&gt; ); }</span></span></code> </pre> <br><p>  UseReducer também recebe 3 argumentos, esta é a <code>action</code> que deve ser executada quando o redutor é inicializado: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> initialState = {<span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reducer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, action</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'reset'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">count</span></span>: action.payload}; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'increment'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">count</span></span>: state.count + <span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'decrement'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">count</span></span>: state.count - <span class="hljs-number"><span class="hljs-number">1</span></span>}; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Counter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{initialCount}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [state, dispatch] = useReducer( reducer, initialState, {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'reset'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: initialCount}, ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;&gt; Count: {state.count} &lt;button onClick={(</span></span></span><span class="hljs-function">) =&gt;</span></span> dispatch({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'reset'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: initialCount})}&gt; Reset &lt;<span class="hljs-regexp"><span class="hljs-regexp">/button&gt; &lt;button onClick={() =&gt; dispatch({type: 'increment'})}&gt;+&lt;/</span></span>button&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{()</span></span></span></span><span class="xml"><span class="hljs-tag"> =&gt;</span></span></span><span class="xml"> dispatch({type: 'decrement'})}&gt;-</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;<span class="hljs-regexp"><span class="hljs-regexp">/&gt; ); }</span></span></code> </pre> <br><p>  Também podemos criar um contexto nesse redutor e usá-lo através do gancho <code>useContext</code> usá-lo em todo o aplicativo. Isso permanece para trabalhos de casa. </p><br><h4 id="podvodya-itog">  Resumir </h4><br><p>  Hooks são uma abordagem bastante poderosa para resolver o inferno do invólucro e resolver vários problemas, mas todos eles podem ser usados ​​com uma definição de <em>transferência</em> de <em>link</em> .  Já começam a aparecer coleções de ganchos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">para uso</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esta coleção</a> .  Você pode aprender mais sobre ganchos na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt428317/">https://habr.com/ru/post/pt428317/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt428305/index.html">Voce estuda ingles Quadrinhos para o resgate</a></li>
<li><a href="../pt428307/index.html">Desafiantes Java # 1: Sobrecarga de método na JVM</a></li>
<li><a href="../pt428311/index.html">TrustZone: SO confiável e seus aplicativos</a></li>
<li><a href="../pt428313/index.html">O telegrama no MacOS [presumivelmente] também armazena correspondência localmente de forma acessível</a></li>
<li><a href="../pt428315/index.html">5 medos de desenvolvedores que superamos</a></li>
<li><a href="../pt428321/index.html">Análise preditiva de dados - modelagem e validação</a></li>
<li><a href="../pt428327/index.html">O que procurar: Regulamento Europeu de Identificação Eletrônica eIDAS</a></li>
<li><a href="../pt428329/index.html">Treinamento de reforço: analisando jogos de vídeo</a></li>
<li><a href="../pt428333/index.html">2018 RAIF Hackathon AI Hackathon Resultados</a></li>
<li><a href="../pt428335/index.html">Atualização de atalho Siri</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>