<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõÄüèΩ üïû üéí Reflexiones sobre C ++ moderno y desarrollo de juegos üññüèΩ üë∞üèæ üí°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El nuevo a√±o para los desarrolladores de juegos comenz√≥ con una ola de cr√≠ticas que cay√≥ sobre el comit√© de estandarizaci√≥n de C ++ despu√©s de la publ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reflexiones sobre C ++ moderno y desarrollo de juegos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435036/">  <i>El nuevo a√±o para los desarrolladores de juegos comenz√≥ con una ola de cr√≠ticas que cay√≥ sobre el comit√© de estandarizaci√≥n de C ++ despu√©s de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicaci√≥n de las Quejas de Aras Prankevichus sobre Modern C ++</a> .</i>  <i>Surgi√≥ una pregunta seria: ¬øel comit√© de est√°ndares realmente perdi√≥ contacto con la realidad, o es al rev√©s, y estos desarrolladores de juegos est√°n separados del resto de la comunidad de C ++?</i> <i><br><br></i>  <i>Le ofrecemos una traducci√≥n de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">popular publicaci√≥n de</a> Ben Dean, un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">veterano de la industria del juego</a> , que trabaj√≥ durante mucho tiempo en Blizzard, Electronic Arts y Bullfrog como desarrollador de C ++ y l√≠der de equipo, en el que responde a las cr√≠ticas desde la perspectiva de su propia experiencia.</i> <br><blockquote> TL; DR: El Comit√© de Normalizaci√≥n de C ++ no tiene un objetivo oculto de ignorar las necesidades de los desarrolladores de juegos, y C ++ "moderno" no se convertir√° en un lenguaje "depurado". </blockquote>  Durante la semana pasada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">,</a> hubo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una discusi√≥n activa</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en Twitter</a> , durante la cual muchos programadores, especialmente aquellos que trabajan en el campo del desarrollo de juegos, hablaron de que el vector de desarrollo actual de "C ++ moderno" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no satisface sus necesidades</a> .  En particular, desde el punto de vista de un desarrollador de juegos ordinario, todo parece como si se ignorara el rendimiento de depuraci√≥n en el lenguaje, y la optimizaci√≥n del c√≥digo se vuelve esperada y necesaria. <br><br>  Debido a que en 2019 logr√© trabajar en la industria del juego durante m√°s de 23 a√±os, tengo mi propia opini√≥n basada en observaciones sobre este tema en relaci√≥n con el desarrollo del juego, que me gustar√≠a compartir.  ¬øLa depuraci√≥n es importante para los desarrolladores de juegos y por qu√©?  ¬øCu√°les son los problemas asociados con √©l? <br><br>  Para empezar, una peque√±a digresi√≥n en la historia. <br><a name="habracut"></a><br>  Muchos desarrolladores de juegos de C ++ trabajan en Microsoft Visual C ++.  Hist√≥ricamente, se ha formado un gran mercado de juegos alrededor de las plataformas de Microsoft, y esto ha afectado la experiencia t√≠pica de un programador de juegos ordinario.  En los a√±os 90 y 2000, la mayor√≠a de los juegos se escribieron teniendo en cuenta estas circunstancias.  Incluso con el advenimiento de consolas de otros fabricantes y la creciente popularidad de los juegos m√≥viles, los activos de muchos estudios AAA y numerosos programadores de juegos actuales son herramientas hechas por Microsoft. <br><br>  Visual Studio es posiblemente el mejor depurador para C ++ del mundo.  Adem√°s, Visual Studio realmente se destaca m√°s en t√©rminos de depuraci√≥n de programas, m√°s que con su front-end, back-end, implementaci√≥n de STL o cualquier otra cosa.  En los √∫ltimos cinco a√±os, Microsoft ha logrado avances significativos en el desarrollo de herramientas de desarrollo de C ++, pero incluso antes de eso, el depurador en Visual Studio siempre ha sido muy bueno.  Entonces, cuando est√° desarrollando en una PC con Windows, siempre tiene a mano un depurador de clase mundial. <br><br>  Dado lo anterior, veamos el proceso de obtenci√≥n de c√≥digo en el que no habr√° errores;  oportunidades que tenemos desde el punto de vista de un programador que no maneja juegos;  as√≠ como las limitaciones que enfrentan los desarrolladores de juegos.  Si reformula el argumento principal a favor del "vector de desarrollo de C ++ moderno", se reducir√° a tipos, herramientas y pruebas.  Siguiendo este pensamiento, el depurador deber√≠a ser la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√∫ltima l√≠nea de defensa</a> .  Antes de lograrlo, tenemos las siguientes opciones. <br><br><h3>  Oportunidad No. 1: Tipos </h3><br>  Podemos utilizar la mayor cantidad de tipeo fuerte que sea necesario para eliminar clases enteras de errores en tiempo de compilaci√≥n.  La tipificaci√≥n fuerte es, sin duda, una oportunidad que nos ha brindado la evoluci√≥n reciente de C ++;  por ejemplo, comenzando con C ++ 11, logramos: <br><br><ul><li> extensi√≥n significativa de los <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">type traits</a></code> de <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">type traits</a></code> ; </li><li>  innovaciones tales como <code>nullptr</code> y <code>scoped enum</code> para combatir el patrimonio C: escritura d√©bil; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GSL</a> y herramientas auxiliares; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conceptos</a> en C ++ 20. </li></ul><br>  Es posible que a algunos de ustedes no les guste la metaprogramaci√≥n de plantillas;  otros pueden no gustarle el estilo de codificaci√≥n que usa <code>auto</code> casi universalmente.  Independientemente de estas preferencias, el motivo principal para usar los estilos enumerados en C ++ se traza claramente aqu√≠: este es el deseo de ayudar al compilador para que, a su vez, pueda ayudarnos, usando al mismo tiempo lo que mejor sabe: el sistema de tipos. <br><br>  Si hablamos de programaci√≥n de juegos, la tipificaci√≥n fuerte aqu√≠ es un campo amplio para la investigaci√≥n, y es utilizada activamente por programadores de juegos que conozco, que est√°n interesados ‚Äã‚Äãen mejorar sus habilidades de aplicaci√≥n C ++ en la pr√°ctica.  Aqu√≠ hay dos cosas importantes que preocupan: el efecto sobre el tiempo de compilaci√≥n y el efecto sobre la legibilidad del c√≥digo. <br><br>  Francamente, puede ignorar f√°cilmente el tiempo de compilaci√≥n, pero solo con la condici√≥n de que sea un programador en una empresa muy grande que no juega juegos y que tenga una infraestructura interna establecida y una potencia inform√°tica infinita para compilar cualquier c√≥digo que pueda escribir .  Estas grandes empresas est√°n preocupadas por el costo de la compilaci√≥n, por lo tanto, usan m√≥dulos, pero, por regla general, esto no causa dolor a los desarrolladores individuales.  Al mismo tiempo, para la mayor√≠a de los programadores de juegos, este no es el caso.  Los desarrolladores independientes no tienen granjas para construir;  Los desarrolladores de juegos AAA a menudo usan algo como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Incredibuild</a> , pero dado el hecho de que pueden trabajar f√°cilmente con una base de c√≥digo que tiene 10 a√±os o m√°s, el proceso de compilaci√≥n a√∫n puede tomar de 15 a 20 minutos. <br><br>  Podemos discutir sobre el costo relativo de agregar hardware versus el costo del tiempo del programador, y estoy de acuerdo con la opini√≥n de que el hardware es m√°s barato, sin embargo: <br><br><ul><li>  El hardware es un gasto real de una sola vez que se asignar√° al presupuesto del trimestre actual, en contraste con los gastos no tan tangibles en tiempo / contrataci√≥n / y similares, que se asignar√°n por un per√≠odo de tiempo m√°s largo.  La gente no hace frente a la decisi√≥n a favor de tal compromiso, y las empresas est√°n especialmente construidas de tal manera que optimizan las ganancias a corto plazo. </li><li>  La infraestructura requiere soporte, y casi nadie entra en la industria del juego para convertirse en un ingeniero de lanzamiento.  En comparaci√≥n con otras √°reas donde se usa C ++, el salario de los desarrolladores de juegos no es tan alto, y los que no son ingenieros de juegos reciben un salario a√∫n menor. </li></ul><br>  Tambi√©n se puede especular sobre el hecho de que el tiempo de compilaci√≥n nunca deber√≠a haber alcanzado tal estado;  Y de nuevo estoy de acuerdo contigo.  El precio de esto es la vigilancia constante, una vez m√°s, proveniente de un ingeniero de lanzamiento, e, idealmente, alguna herramienta automatizada que le permite rastrear los cambios en el tiempo requerido para construir la construcci√≥n.  Afortunadamente, con el advenimiento de los sistemas de CI, este objetivo se puede lograr mucho m√°s f√°cilmente hoy. <br><br><h3>  Oportunidad No. 2: Herramientas </h3><br>  Deber√≠amos utilizar el m√°ximo de las herramientas disponibles: advertencias, an√°lisis est√°tico, desinfectantes, herramientas de an√°lisis din√°mico, perfiladores y otros. <br><br>  Mi experiencia es que los desarrolladores de juegos usan estas herramientas siempre que sea posible, pero aqu√≠ la industria en su conjunto tiene varios problemas: <br><br><ul><li>  Estas herramientas tienden a funcionar mejor en plataformas que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no son de Microsoft</a> y, como se mencion√≥ anteriormente, este no es un escenario t√≠pico de desarrollo de juegos. </li><li>  La mayor√≠a de estas herramientas est√°n destinadas a trabajar con C ++ "est√°ndar".  De <code>CStaticVector</code> admiten <code>std::vector</code> , pero no mi clase <code>CStaticVector</code> de un motor hipot√©tico.  Por supuesto, culpar a las herramientas es in√∫til, pero esta sigue siendo una de las barreras para su uso que los desarrolladores tienen que superar. </li><li>  La creaci√≥n y el mantenimiento de una cadena de CI que ejecute todas estas herramientas requiere la presencia de ingenieros de lanzamiento y, como se mencion√≥ anteriormente, contratar personas para trabajos de ingenier√≠a que no est√°n directamente relacionados con los juegos es un problema sist√©mico para la industria del juego. </li></ul><br>  Entonces, dado que estas herramientas funcionan tan bien con C ++ est√°ndar, ¬øpor qu√© los desarrolladores de juegos no usan STL? <br><br>  ¬øD√≥nde comenzar la respuesta a esta pregunta?  Quiz√°s, de la pr√≥xima excursi√≥n a la historia del desarrollo del juego: <br><br><ul><li>  Hasta principios de los 90, no confiamos en los compiladores de C, por lo que escribimos juegos en ensamblador. </li><li>  Desde el comienzo hasta mediados de los 90, comenzamos a confiar en los compiladores de C, pero a√∫n no confiamos en los compiladores de C ++.  Nuestro c√≥digo era C, que usaba comentarios de estilo C ++, y ya no necesit√°bamos escribir typedefs para nuestras estructuras todo el tiempo. </li><li>  Alrededor de 2000, la revoluci√≥n C ++ tuvo lugar en el mundo del desarrollo de juegos.  Fue una era <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de patrones de dise√±o</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">grandes jerarqu√≠as de clases</a> .  En ese momento, el soporte STL en las consolas dejaba mucho que desear, y las consolas gobernaban el mundo en ese momento.  En PS2, estamos atrapados para siempre con GCC 2.95. </li><li>  Alrededor de 2010, se lanzaron dos revoluciones m√°s.  El dolor de usar grandes jerarqu√≠as de clase estimul√≥ el desarrollo de un enfoque de componentes para el c√≥digo.  Este cambio contin√∫a su evoluci√≥n hoy en forma de arquitecturas Entity-Component-System.  De la mano de esta fue la segunda revoluci√≥n: un intento de aprovechar las arquitecturas multiprocesador. </li></ul><br>  Durante estos cambios de paradigma, las plataformas de desarrollo de juegos en s√≠ estaban cambiando constantemente, y estaban cambiando seriamente.  La memoria segmentada ha dado paso a un espacio de direcciones plano.  Las plataformas se han convertido en multiprocesador, sim√©tricas y no muy.  Los desarrolladores de juegos, acostumbrados a trabajar con arquitecturas Intel, tuvieron que acostumbrarse a MIPS (Playstation), luego a un hardware especial con CPU heterog√©neas (PS2), luego a PowerPC (XBox 360), luego a una heterogeneidad a√∫n mayor (PS3) ... La nueva plataforma viene con nuevas caracter√≠sticas de rendimiento para procesadores, memoria y unidades.  Si quer√≠a lograr un rendimiento √≥ptimo, se vio obligado a reescribir su antiguo c√≥digo, y muchas veces.  Ni siquiera mencionar√© cu√°nto influyeron los juegos por la aparici√≥n y el crecimiento de la popularidad de Internet, as√≠ como las restricciones que los titulares de la plataforma impusieron a los desarrolladores. <br><br>  Hist√≥ricamente, las implementaciones de STL en plataformas de juego han sido insatisfactorias.  No es un secreto que los contenedores STL no son adecuados para los juegos.  Si empuja al desarrollador del juego a la pared, entonces tal vez √©l admite que <code>std::string</code> est√° bastante bien, y <code>std::vector</code> es una opci√≥n predeterminada razonable.  Pero todos los contenedores contenidos en el STL tienen un problema de control de asignaci√≥n e inicializaci√≥n.  Muchos juegos tienen que preocuparse por las limitaciones de memoria para diversas tareas, y para aquellos objetos para los cuales la memoria probablemente tendr√° que asignarse din√°micamente durante el juego, a menudo se usan asignadores de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><i>losas</i></a> o <i>arena</i> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El tiempo constante amortizado</a> no es un buen resultado, ya que la asignaci√≥n es potencialmente una de las cosas m√°s "costosas" que pueden suceder durante la ejecuci√≥n del programa, y ‚Äã‚Äãno quiero omitir un marco solo porque sucedi√≥ cuando no lo esperaba .  Como desarrollador de juegos, debo administrar mis requisitos de memoria por adelantado. <br><br>  Se obtiene una historia similar para otras dependencias en general.  Los desarrolladores de juegos quieren saber qu√© toma cada ciclo de procesador, d√≥nde y cu√°ndo y de qu√© es responsable cada byte de memoria, y tambi√©n d√≥nde y cu√°ndo se controla cada hilo de ejecuci√≥n.  Hasta hace poco, los compiladores de Microsoft cambiaban ABI con cada actualizaci√≥n, por lo que si ten√≠a muchas dependencias, reconstruirlas todas podr√≠a ser un proceso doloroso.  Los desarrolladores de juegos generalmente prefieren peque√±as dependencias que son f√°ciles de integrar, hacen solo una cosa y lo hacen bien, preferiblemente con una API de estilo C, y son utilizadas por muchas compa√±√≠as, son de dominio p√∫blico o tienen una licencia gratuita que no requiere una indicaci√≥n del autor.  <i>SQLite</i> y <i>zlib</i> son buenos ejemplos de lo que los desarrolladores de juegos prefieren usar. <br><br>  Adem√°s, la industria de los juegos C ++ tiene una rica historia de pacientes con el s√≠ndrome "No inventado aqu√≠".  Esto deber√≠a esperarse de la industria, que comenz√≥ con entusiastas individuales que hicieron sus propias cosas con equipos completamente nuevos y no ten√≠an otras opciones.  La industria del juego, entre otras cosas, es la √∫nica en la que los programadores se indican en los cr√©ditos sin ning√∫n orden en particular.  <i>¬°Escribir una variedad de cosas es divertido y ayuda a tu carrera!</i>  <i>¬°Es mucho mejor construir algo propio que comprar ya hecho!</i>  Y dado que estamos tan preocupados por el rendimiento, podemos adaptar nuestra soluci√≥n de tal manera que sea adecuada espec√≠ficamente para nuestro proyecto, en lugar de tomar una soluci√≥n generalizada que desperdicie recursos irreflexivamente.  La hostilidad hacia Boost es el principal ejemplo de c√≥mo tal pensamiento se manifiesta en el desarrollo del juego.  Trabaj√© en proyectos que fueron de la siguiente manera: <br><br><ul><li>  Para comenzar, para resolver un problema en particular, conectamos una biblioteca de Boost al proyecto. </li><li>  Todo funciona muy bien.  Cuando necesita actualizar, se produce un peque√±o dolor, pero no m√°s que al actualizar cualquier otra dependencia. </li><li>  Otro juego quiere usar nuestro c√≥digo, pero el escollo es que usamos Boost, a pesar de que nuestra experiencia con Boost ha ido bastante bien. </li><li>  Eliminamos el c√≥digo usando Boost, pero ahora nos enfrentamos a un nuevo problema: debemos resolver el problema que la biblioteca de Boost en lugar de la nuestra resolvi√≥ antes. </li><li>  Esencialmente copiamos las partes del c√≥digo Boost que necesitamos en nuestros propios espacios de nombres. </li><li>  M√°s tarde, inevitablemente y una y otra vez nos encontramos con el hecho de que necesitamos una funcionalidad adicional que ya estar√≠a en el c√≥digo original si no la hubi√©ramos descartado.  Pero ahora somos los propietarios de este c√≥digo, por lo que debemos continuar admiti√©ndolo. </li></ul><br>  No nos gusta algo enorme que est√° tratando de hacer muchas cosas al mismo tiempo o que puede afectar el tiempo de compilaci√≥n, y esto es bastante razonable.  Lo que la gente comete errores una y otra vez es que se oponen a aceptar el supuesto dolor hoy, mientras que debido a esta decisi√≥n enfrentar√°n un dolor muy real y mucho mayor con el apoyo de algo a expensas de alguien. el presupuesto que tendr√°n que experimentar en los pr√≥ximos tres a√±os.  Lamentablemente, la presencia de evidencia en forma de juegos que utilizan con √©xito un plato de STL y Boost, de ninguna manera puede afectar la psicolog√≠a humana y convencer a los desarrolladores de juegos. <br><br>  Por todas estas razones, muchas compa√±√≠as de juegos han creado sus propias bibliotecas que cubren lo que hace STL, y a√∫n m√°s, al tiempo que admiten casos de uso espec√≠ficos del juego.  Algunas grandes compa√±√≠as de juegos incluso pudieron dominar el desarrollo de su propio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">reemplazo de STL</a> completo, casi completamente compatible con API, lo que posteriormente conllev√≥ enormes costos para apoyar este proyecto. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Es aconsejable encontrar una alternativa mejorada a</a> <code>std::map</code> , o aplicar una <i>peque√±a optimizaci√≥n del b√∫fer</i> en <code>std::vector</code> .  Es mucho menos aceptable estar condenado a admitir sus propias implementaciones de <code>algorithms</code> o <code>type traits</code> , lo que har√° poco bien.  En cuanto a m√≠, es lamentable que para la mayor√≠a de los desarrolladores, los STL sean solo contenedores.  Dado que al aprender STL al principio, se les ense√±a exactamente eso, hablando de STL, la mayor√≠a implica <code>std::vector</code> , aunque de hecho deber√≠an pensar en <code>std::find_if</code> . <br><br><h3>  Oportunidad No. 3: Pruebas </h3><br>  Se argumenta que se deben realizar pruebas exhaustivas, TDD y / o BDD deben cubrir todo el c√≥digo que se puede cubrir, y los errores deben abordarse escribiendo nuevas pruebas. <br><br>  Por lo tanto, discutamos el tema de las pruebas. <br><br>  A juzgar por mi experiencia, las pruebas automatizadas pr√°cticamente no se utilizan en la industria del juego.  Por qu√© <br><br><h4>  1. Porque la correcci√≥n <i>no</i> es <i>tan</i> importante, pero no hay una especificaci√≥n real </h4><br>  Como un joven programador en la industria del juego, r√°pidamente me deshice de la idea de que deber√≠a esforzarme por simular algo de manera realista.  Los juegos son <i>humo y espejos</i> y la b√∫squeda de caminos cortos.  A nadie le importa cu√°n realista sea tu simulaci√≥n;  Lo principal es que sea divertido.  Cuando no tienes otra especificaci√≥n que "el juego deber√≠a sentirse bien", falta el tema de la prueba.  Gracias a los errores, la jugabilidad puede incluso mejorar.  Muy a menudo, un error entra en el lanzamiento, e incluso se gana el amor de los usuarios ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">recuerda el mismo Gandhi de Civilization</a> ).  Los juegos son diferentes de otras √°reas que usan C ++;  aqu√≠ la falta de correcci√≥n no lleva al hecho de que alguien eventualmente pierda sus ahorros. <br><br><h4>  2. Porque es dif√≠cil </h4><br>  Por supuesto, le gustar√≠a producir pruebas automatizadas siempre que pueda.  Esto se puede hacer para algunos subsistemas para los cuales hay resultados finales claramente establecidos.  Las pruebas unitarias en la industria del juego, por supuesto, est√°n presentes, pero por regla general se limitan al c√≥digo de bajo nivel: los an√°logos de STL mencionados anteriormente, los procedimientos de conversi√≥n de cadenas, los m√©todos de motor f√≠sico, etc.  Los casos en que la secci√≥n ejecutable del c√≥digo tiene resultados predecibles generalmente se prueban mediante pruebas unitarias, aunque TDD no se usa aqu√≠, ya que los programadores de juegos prefieren simplificar sus vidas, y no al rev√©s.  Pero, ¬øc√≥mo se prueba el c√≥digo de juego (ver punto uno)?  Tan pronto como va m√°s all√° de las pruebas unitarias, inmediatamente se encuentra con otra raz√≥n por la cual probar juegos es tan dif√≠cil. <br><br><h4>  3. Porque el contenido est√° involucrado </h4><br>  Probando sistemas no triviales probablemente incluir√° la provisi√≥n de contenido con el cual ser√° implementado.  La mayor√≠a de los ingenieros no son muy buenos para producir este contenido por s√≠ mismos, por lo que para obtener una prueba significativa, deber√° atraer a alguien con las habilidades adecuadas para crear el contenido.  Despu√©s de lo cual encontrar√° el problema de medir lo que obtiene en la salida; despu√©s de todo, esto ya no es una l√≠nea o un n√∫mero, sino una imagen en la pantalla o un sonido que cambia con el tiempo. <br><br><h4>  4. Porque no lo practicamos </h4><br>  La prueba unitaria es una funci√≥n para la que conozco las posibles entradas y salidas.  Sin embargo, la jugabilidad es un comportamiento impredecible, que evoluciona din√°micamente, y no s√© c√≥mo se podr√≠a probar adecuadamente este fen√≥meno.  ¬øQu√© puedo probar? Si, ‚Äã‚Äãpor supuesto, obtengo permiso de mi gerente para dedicar suficiente tiempo a esto, esto es, por ejemplo, el rendimiento o las capacidades de alto nivel, como el emparejamiento, que puedo analizar.  Tal trabajo de infraestructura puede ser emocionante para algunos programadores de juegos, pero para la mayor√≠a simplemente no es interesante, y adem√°s requiere la aprobaci√≥n y el apoyo del propietario de la billetera.  Como programador de juegos, nunca tengo la oportunidad de practicar escribir ex√°menes de alto nivel. <br><br><h4>  5. Dado que [empresa] no ve la necesidad de realizar pruebas automatizadas </h4><br>  Nuestro objetivo principal es lanzar el juego.  Vivimos en una era de industria que avanza con √©xitos que aprovechan al m√°ximo su dinero en el primer mes de ventas, cuando los costos de comercializaci√≥n de estos √©xitos se maximizan.  El ciclo de vida de las consolas nos ense√±√≥ que, en cualquier caso, el c√≥digo no durar√° tanto.  Si estamos trabajando en un juego en l√≠nea, lo m√°s probable es que tengamos tiempo adicional para probar el emparejamiento o la carga del servidor.  Dado que para el lanzamiento del juego necesitamos que su rendimiento est√© en orden, al menos deber√≠amos realizar pruebas de rendimiento, pero no deber√≠amos automatizar este proceso.  Para la administraci√≥n en la industria del juego, las pruebas automatizadas no son m√°s que una p√©rdida de tiempo y dinero.  Para su implementaci√≥n, es necesario contratar ingenieros experimentados que llevar√°n a cabo el trabajo, cuyo resultado ser√° casi imperceptible.  Se podr√≠a dedicar el mismo tiempo al desarrollo de nuevas funciones.  A corto plazo, es mucho m√°s rentable utilizar personal de control de calidad para probar el juego, lo que nos lleva al siguiente punto. <br><br><h4>  6. Porque, en general, las pruebas en juegos se clasifican como actividades de segundo orden </h4><br>  Me encantan los buenos profesionales de control de calidad.  Para m√≠ valen su peso en oro.  Saben c√≥mo mejorar tu juego rompi√©ndolo de una manera que nunca se te hubiera pasado por la cabeza.  Son expertos especializados en tu juego en ese aspecto en el que no entiendes y casi nunca entiendes.  Son mejores que un equipo de compiladores s√∫per capaces para ayudarlo a hacer todo bien.  Me alegra haber tenido la oportunidad de trabajar con varios maravillosos especialistas en control de calidad durante los a√±os de mi trabajo. <br><br>  Casi siempre tuve que luchar para asegurarme de que permanecieran en mi equipo. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En las grandes empresas AAA, una organizaci√≥n de control de calidad suele ser un departamento completamente separado de cualquier equipo de desarrollo, con su propia estructura organizativa y de gesti√≥n. Supuestamente, esto se hace para que puedan ser objetivos durante la prueba. En la pr√°ctica, todo est√° lejos de ser tan hermoso. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Son tratados como engranajes en un mecanismo enorme, que a menudo se lanzan entre proyectos sin previo aviso y generalmente se tratan como si alguien pudiera manejar su trabajo. Cuando el proyecto "se aleja" de la fecha l√≠mite, los ingenieros pueden sentir la crisis en su propia piel, pero el control de calidad se vuelve mucho m√°s fuerte, porque tienen que trabajar en el turno de noche y los fines de semana, adem√°s de que tambi√©n reciben noticias sombr√≠as sobre la actualidad. estado de calidad del proyecto.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Est√°n seriamente mal pagados. Los evaluadores m√°s experimentados con a√±os de experiencia en el √°rea tem√°tica reciben menos de la mitad de lo que pagan a un desarrollador de nivel medio. Tuve que trabajar con los ingenieros de control de calidad m√°s inteligentes que crearon proyectos para pruebas de rendimiento con seguimiento y alertas, crearon marcos para probar API y pruebas de estr√©s, y realizaron muchas otras tareas supuestamente indignas de la √©poca de los "ingenieros reales". Estoy seguro de que estas personas m√°s inteligentes obtendr√≠an mucho m√°s si trabajaran en cualquier otra gran empresa de tecnolog√≠a. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No son de confianza. No es raro que los evaluadores se mantengan separados de otros desarrolladores, y sus credenciales les permiten acceder solo al piso del edificio donde trabajan ellos mismos, o incluso usar una entrada separada.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se ven obligados a obedecer. A menudo se les dice a los evaluadores que no molesten a otros ingenieros. Cuando necesitan informar un error directamente, se les pide que se comuniquen con los ingenieros respetuosamente, como "la Sra. H." o "Sr. Y." A veces recib√≠ una llamada de los jefes molestos de los departamentos de control de calidad, en esos casos cuando contact√© a aquellos que descubrieron el error para una investigaci√≥n conjunta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todo esto suena como una historia terrible, y que no todos tengan que lidiar con tales cosas, desafortunadamente esto sucede con bastante frecuencia; tan a menudo que los ingenieros comienzan a pensar, quiz√°s bajo una carga de estr√©s constante, pero eso no los disculpa, que el trabajo de QA es buscar sus propios errores o, lo que es peor, comenzar a culpar a QA por los errores.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En los mejores equipos con los que tuve que trabajar, insistimos en que nuestros equipos tengan sus propios ingenieros de control de calidad que trabajar√≠an con nosotros. </font><font style="vertical-align: inherit;">Sin embargo, no perdieron su objetividad o deseo de lograr un mejor resultado. </font><font style="vertical-align: inherit;">Les complaci√≥ recibir ayuda de los programadores para redactar pruebas automatizadas. </font><font style="vertical-align: inherit;">Lo que ciertamente no dudo es que ser√≠a √∫til para la industria del juego hacer la automatizaci√≥n con m√°s frecuencia.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rendimiento de depuraci√≥n </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado todo lo anterior, los h√°bitos de depuraci√≥n, la plataforma para las API y las herramientas que a√∫n est√°n creciendo, y la complejidad (combinada con la falta de cultura) de las pruebas automatizadas, queda claro por qu√© los desarrolladores de juegos insisten en las capacidades de depuraci√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero al mismo tiempo, sigue habiendo problemas con la depuraci√≥n en s√≠ misma y problemas con la forma en que los desarrolladores de juegos hacen frente al vector de desarrollo actual de C ++.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El principal problema con la depuraci√≥n es que no se escala. </font><font style="vertical-align: inherit;">Entre los desarrolladores de juegos de desarrolladores que leen esta publicaci√≥n, hay quienes deciden que los fen√≥menos que describ√≠ no est√°n de acuerdo con lo que observaron en su pr√°ctica. </font><font style="vertical-align: inherit;">Posiblemente, esto se deba al hecho de que tarde o temprano ellos mismos tuvieron que lidiar con el problema de la escalabilidad de la depuraci√≥n, y encontraron una forma de evitarlo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En otras palabras, queremos tener una depuraci√≥n productiva, porque para detectar errores, a menudo necesitamos poder ejecutar aplicaciones con conjuntos de datos suficientemente grandes y representativos. Pero, de hecho, cuando llegamos a este punto, el depurador generalmente se convierte en una herramienta demasiado grosera para usar, independientemente de si es productiva o no. Por supuesto, establecer puntos de interrupci√≥n en los datos ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puntos de interrupci√≥n de datos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) puede ser √∫til para detectar problemas de tama√±o mediano, pero ¬øqu√© sucede si encontramos errores reales, los que quedan despu√©s de que parece que lo hemos solucionado todo? Con los que surgen bajo la carga de la red, o en el caso de una falta de memoria, o que trabajan al l√≠mite de las capacidades de subprocesamiento m√∫ltiple, o que suceden solo para un peque√±o subconjunto no identificado en el contexto de un mill√≥n de otros jugadores, o surgen solo en versiones de disco del juego, o solo en la asamblea en alem√°n, o despu√©s de pasar tres horas en pruebas de estabilidad ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prueba de remojo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rasgo dos, podemos confiar solo en el depurador. En este caso, hacemos lo que siempre hicimos. Estamos tratando de aislar el problema, hacer que suceda con m√°s frecuencia; agregamos el registro y tamizamos nuestro programa a trav√©s de √©l; ajustamos temporizadores y configuraciones de flujo; utilizamos b√∫squeda de compilaci√≥n binaria; estudiamos volcados de n√∫cleos y registros de fallos; intentamos reproducir el problema recortando el contenido al m√≠nimo; reflexionamos sobre lo que podr√≠a estar causando el problema y lo discutimos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A menudo, hasta que lleguemos a la causa real del accidente, tendremos tiempo para arreglar algunas otras cosas. En otras palabras, resolvemos problemas y, al final, usar un depurador es solo una peque√±a parte de este proceso. Entonces s√≠, la velocidad de depuraci√≥n es una buena adici√≥n, pero su falta no nos impide seguir siendo ingenieros. Todav√≠a necesitamos nuestras otras habilidades, como la capacidad de analizar los volcados del n√∫cleo y leer el ensamblador optimizado.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando uso "C ++ moderno", uso el depurador de la misma manera que de costumbre. Reviso el c√≥digo reci√©n escrito; Pongo puntos de interrupci√≥n en los datos que me interesan; Yo uso un depurador para explorar c√≥digo desconocido. Con el advenimiento del "C ++ moderno", nada de esto cambia, y s√≠, aunque el STL usa identificadores _ feos _, esto no hace que el STL sea m√°gico. A veces es √∫til ver qu√© hace el STL "debajo del cap√≥" o pasar por encima; o, como puede hacer ahora, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">use el depurador para ocultarme el c√≥digo de la biblioteca</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando me encuentro con problemas de rendimiento de depuraci√≥n, generalmente no es que el "C ++ moderno" me frene, el hecho es que en este momento ya estoy tratando de hacer demasiado. El uso del depurador </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no se escala</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a diferencia de los tipos, herramientas y pruebas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yo mismo estaba preocupado por el problema de que el c√≥digo C ++ necesitaba m√°s y m√°s optimizaci√≥n, y estaba interesado en la opini√≥n de los desarrolladores de compiladores sobre esto. El hecho es que no hay una respuesta √∫nica. Ya estamos en el continuo, y tenemos la oportunidad de avanzar m√°s en esta direcci√≥n sin da√±ar la capacidad de depurar c√≥digo. Hoy, nuestros compiladores realizan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">copias de elisi√≥n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para objetos temporales.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, incluso si no les pedimos que realicen esta optimizaci√≥n. </font><font style="vertical-align: inherit;">Esto no afecta nuestra capacidad de depurar aplicaciones. </font><font style="vertical-align: inherit;">Dudo que nos quejemos de que las compilaciones de depuraci√≥n comenzaron a incluir NRVO u otra media docena de optimizaciones que se pueden hacer de tal manera que no las notaremos durante la depuraci√≥n. </font><font style="vertical-align: inherit;">Sospecho que C ++ se est√° moviendo en </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esa</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> direcci√≥n.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ep√≠logo: El camino de C ++ moderno </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si trabajas como programador en el campo del desarrollo de juegos y no te gusta hacia d√≥nde se dirige C ++, entonces b√°sicamente tienes dos opciones para posibles acciones adicionales. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1. No hacer nada </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suponiendo que todav√≠a va a escribir c√≥digo C ++, simplemente puede continuar usando el lenguaje de la misma manera que lo hizo antes. No es necesario comenzar a usar ninguna funci√≥n nueva si no desea hacerlo. Casi todo lo que usa ahora continuar√° siendo compatible, y al hacerlo, en los pr√≥ximos a√±os continuar√° cosechando los beneficios de mejorar el compilador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta es una estrategia de comportamiento completamente apropiada para quienes trabajan para s√≠ mismos o con un equipo de personas de ideas afines. C ++ 98, junto con algunas caracter√≠sticas m√°s nuevas, sigue siendo una buena opci√≥n para escribir juegos en √©l.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, si trabaja en una gran empresa, tarde o temprano tendr√° que enfrentar cambios en el idioma, ya que tendr√° que aumentar el equipo y contratar nuevas personas. </font><font style="vertical-align: inherit;">A su vez, cuando contrata desarrolladores de C ++, esto significar√° contratar desarrolladores con C ++ "moderno". </font><font style="vertical-align: inherit;">Ocurrir√° un cambio de generaciones, como ya sucedi√≥ con el ensamblador, C y C ++ 98. </font><font style="vertical-align: inherit;">Puede administrar el proceso si establece l√≠mites sobre lo que est√° permitido en su base de c√≥digo y lo que no, pero esta soluci√≥n no lo salvar√° a largo plazo. </font><font style="vertical-align: inherit;">¬øY qu√© debes hacer en este caso?</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2. Participa </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En lugar de ir a un solo GDC una vez al a√±o, comience a visitar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CppCon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , donde obtendr√° mucho m√°s beneficio del dinero que su compa√±√≠a gast√≥ en un boleto. Participar en discusiones sobre est√°ndares; unirse a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grupos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y suscribirse a boletines informativos; lea los </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">borradores de normas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y brinde retroalimentaci√≥n a los autores. Si tambi√©n puede asistir a las reuniones del comit√©, estar√° bien, pero incluso si no, a√∫n puede hacer mucho para transmitir su punto de vista a los dem√°s. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La membres√≠a en el Comit√© C ++ est√° abierta a todos. Toda la informaci√≥n necesaria para aquellos que desean participar en el trabajo de SG14, SG7 o SG15, o cualquier otro grupo de trabajo relacionado con su √°rea de inter√©s,</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se puede encontrar en isocpp.org</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">El comit√© no tiene planes secretos; de hecho, ¬ørealmente crees que m√°s de 200 programadores pueden ponerse de acuerdo sobre una agenda com√∫n? </font><font style="vertical-align: inherit;">Aqu√≠, incluso los "jefes" del comit√© a menudo no "empujan" sus ideas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si desea que se escuche su opini√≥n, entonces debe comenzar a hablar donde se pueda escuchar su opini√≥n, y no en Twitter o Reddit. </font><font style="vertical-align: inherit;">Por favor tome este consejo. Espero con ansias nuestra discusi√≥n.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es435036/">https://habr.com/ru/post/es435036/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es435018/index.html">En 2018, finalmente comenzamos a tomarnos en serio el tiempo que pasamos en el tel√©fono inteligente</a></li>
<li><a href="../es435020/index.html">Sal√≥n de la fama de la electr√≥nica de consumo: las historias de los mejores artilugios de los √∫ltimos 50 a√±os, parte 2</a></li>
<li><a href="../es435026/index.html">Hacemos un messenger * que funciona incluso en el elevador</a></li>
<li><a href="../es435028/index.html">Pruebas C sin SMS y registro</a></li>
<li><a href="../es435032/index.html">La nave espacial Chang'e-4 hizo un aterrizaje exitoso en el lado lejano de la luna y envi√≥ la primera foto</a></li>
<li><a href="../es435038/index.html">Energ√≠a nuclear mundial en 2018</a></li>
<li><a href="../es435040/index.html">Bitcoin hace 10 a√±os</a></li>
<li><a href="../es435044/index.html">Antig√ºedades: Minidisc en su h√°bitat natural</a></li>
<li><a href="../es435050/index.html">Historia de c√≥mo se instal√≥ .NET 4.5 en ReactOS</a></li>
<li><a href="../es435054/index.html">Universidad ITMO "en la pr√°ctica": con qu√© empresas de tecnolog√≠a cooperamos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>