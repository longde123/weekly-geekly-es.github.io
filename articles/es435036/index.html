<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛀🏽 🕞 🎒 Reflexiones sobre C ++ moderno y desarrollo de juegos 🖖🏽 👰🏾 💡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El nuevo año para los desarrolladores de juegos comenzó con una ola de críticas que cayó sobre el comité de estandarización de C ++ después de la publ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reflexiones sobre C ++ moderno y desarrollo de juegos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435036/">  <i>El nuevo año para los desarrolladores de juegos comenzó con una ola de críticas que cayó sobre el comité de estandarización de C ++ después de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicación de las Quejas de Aras Prankevichus sobre Modern C ++</a> .</i>  <i>Surgió una pregunta seria: ¿el comité de estándares realmente perdió contacto con la realidad, o es al revés, y estos desarrolladores de juegos están separados del resto de la comunidad de C ++?</i> <i><br><br></i>  <i>Le ofrecemos una traducción de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">popular publicación de</a> Ben Dean, un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">veterano de la industria del juego</a> , que trabajó durante mucho tiempo en Blizzard, Electronic Arts y Bullfrog como desarrollador de C ++ y líder de equipo, en el que responde a las críticas desde la perspectiva de su propia experiencia.</i> <br><blockquote> TL; DR: El Comité de Normalización de C ++ no tiene un objetivo oculto de ignorar las necesidades de los desarrolladores de juegos, y C ++ "moderno" no se convertirá en un lenguaje "depurado". </blockquote>  Durante la semana pasada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">,</a> hubo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una discusión activa</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en Twitter</a> , durante la cual muchos programadores, especialmente aquellos que trabajan en el campo del desarrollo de juegos, hablaron de que el vector de desarrollo actual de "C ++ moderno" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no satisface sus necesidades</a> .  En particular, desde el punto de vista de un desarrollador de juegos ordinario, todo parece como si se ignorara el rendimiento de depuración en el lenguaje, y la optimización del código se vuelve esperada y necesaria. <br><br>  Debido a que en 2019 logré trabajar en la industria del juego durante más de 23 años, tengo mi propia opinión basada en observaciones sobre este tema en relación con el desarrollo del juego, que me gustaría compartir.  ¿La depuración es importante para los desarrolladores de juegos y por qué?  ¿Cuáles son los problemas asociados con él? <br><br>  Para empezar, una pequeña digresión en la historia. <br><a name="habracut"></a><br>  Muchos desarrolladores de juegos de C ++ trabajan en Microsoft Visual C ++.  Históricamente, se ha formado un gran mercado de juegos alrededor de las plataformas de Microsoft, y esto ha afectado la experiencia típica de un programador de juegos ordinario.  En los años 90 y 2000, la mayoría de los juegos se escribieron teniendo en cuenta estas circunstancias.  Incluso con el advenimiento de consolas de otros fabricantes y la creciente popularidad de los juegos móviles, los activos de muchos estudios AAA y numerosos programadores de juegos actuales son herramientas hechas por Microsoft. <br><br>  Visual Studio es posiblemente el mejor depurador para C ++ del mundo.  Además, Visual Studio realmente se destaca más en términos de depuración de programas, más que con su front-end, back-end, implementación de STL o cualquier otra cosa.  En los últimos cinco años, Microsoft ha logrado avances significativos en el desarrollo de herramientas de desarrollo de C ++, pero incluso antes de eso, el depurador en Visual Studio siempre ha sido muy bueno.  Entonces, cuando está desarrollando en una PC con Windows, siempre tiene a mano un depurador de clase mundial. <br><br>  Dado lo anterior, veamos el proceso de obtención de código en el que no habrá errores;  oportunidades que tenemos desde el punto de vista de un programador que no maneja juegos;  así como las limitaciones que enfrentan los desarrolladores de juegos.  Si reformula el argumento principal a favor del "vector de desarrollo de C ++ moderno", se reducirá a tipos, herramientas y pruebas.  Siguiendo este pensamiento, el depurador debería ser la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">última línea de defensa</a> .  Antes de lograrlo, tenemos las siguientes opciones. <br><br><h3>  Oportunidad No. 1: Tipos </h3><br>  Podemos utilizar la mayor cantidad de tipeo fuerte que sea necesario para eliminar clases enteras de errores en tiempo de compilación.  La tipificación fuerte es, sin duda, una oportunidad que nos ha brindado la evolución reciente de C ++;  por ejemplo, comenzando con C ++ 11, logramos: <br><br><ul><li> extensión significativa de los <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">type traits</a></code> de <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">type traits</a></code> ; </li><li>  innovaciones tales como <code>nullptr</code> y <code>scoped enum</code> para combatir el patrimonio C: escritura débil; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GSL</a> y herramientas auxiliares; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conceptos</a> en C ++ 20. </li></ul><br>  Es posible que a algunos de ustedes no les guste la metaprogramación de plantillas;  otros pueden no gustarle el estilo de codificación que usa <code>auto</code> casi universalmente.  Independientemente de estas preferencias, el motivo principal para usar los estilos enumerados en C ++ se traza claramente aquí: este es el deseo de ayudar al compilador para que, a su vez, pueda ayudarnos, usando al mismo tiempo lo que mejor sabe: el sistema de tipos. <br><br>  Si hablamos de programación de juegos, la tipificación fuerte aquí es un campo amplio para la investigación, y es utilizada activamente por programadores de juegos que conozco, que están interesados ​​en mejorar sus habilidades de aplicación C ++ en la práctica.  Aquí hay dos cosas importantes que preocupan: el efecto sobre el tiempo de compilación y el efecto sobre la legibilidad del código. <br><br>  Francamente, puede ignorar fácilmente el tiempo de compilación, pero solo con la condición de que sea un programador en una empresa muy grande que no juega juegos y que tenga una infraestructura interna establecida y una potencia informática infinita para compilar cualquier código que pueda escribir .  Estas grandes empresas están preocupadas por el costo de la compilación, por lo tanto, usan módulos, pero, por regla general, esto no causa dolor a los desarrolladores individuales.  Al mismo tiempo, para la mayoría de los programadores de juegos, este no es el caso.  Los desarrolladores independientes no tienen granjas para construir;  Los desarrolladores de juegos AAA a menudo usan algo como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Incredibuild</a> , pero dado el hecho de que pueden trabajar fácilmente con una base de código que tiene 10 años o más, el proceso de compilación aún puede tomar de 15 a 20 minutos. <br><br>  Podemos discutir sobre el costo relativo de agregar hardware versus el costo del tiempo del programador, y estoy de acuerdo con la opinión de que el hardware es más barato, sin embargo: <br><br><ul><li>  El hardware es un gasto real de una sola vez que se asignará al presupuesto del trimestre actual, en contraste con los gastos no tan tangibles en tiempo / contratación / y similares, que se asignarán por un período de tiempo más largo.  La gente no hace frente a la decisión a favor de tal compromiso, y las empresas están especialmente construidas de tal manera que optimizan las ganancias a corto plazo. </li><li>  La infraestructura requiere soporte, y casi nadie entra en la industria del juego para convertirse en un ingeniero de lanzamiento.  En comparación con otras áreas donde se usa C ++, el salario de los desarrolladores de juegos no es tan alto, y los que no son ingenieros de juegos reciben un salario aún menor. </li></ul><br>  También se puede especular sobre el hecho de que el tiempo de compilación nunca debería haber alcanzado tal estado;  Y de nuevo estoy de acuerdo contigo.  El precio de esto es la vigilancia constante, una vez más, proveniente de un ingeniero de lanzamiento, e, idealmente, alguna herramienta automatizada que le permite rastrear los cambios en el tiempo requerido para construir la construcción.  Afortunadamente, con el advenimiento de los sistemas de CI, este objetivo se puede lograr mucho más fácilmente hoy. <br><br><h3>  Oportunidad No. 2: Herramientas </h3><br>  Deberíamos utilizar el máximo de las herramientas disponibles: advertencias, análisis estático, desinfectantes, herramientas de análisis dinámico, perfiladores y otros. <br><br>  Mi experiencia es que los desarrolladores de juegos usan estas herramientas siempre que sea posible, pero aquí la industria en su conjunto tiene varios problemas: <br><br><ul><li>  Estas herramientas tienden a funcionar mejor en plataformas que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no son de Microsoft</a> y, como se mencionó anteriormente, este no es un escenario típico de desarrollo de juegos. </li><li>  La mayoría de estas herramientas están destinadas a trabajar con C ++ "estándar".  De <code>CStaticVector</code> admiten <code>std::vector</code> , pero no mi clase <code>CStaticVector</code> de un motor hipotético.  Por supuesto, culpar a las herramientas es inútil, pero esta sigue siendo una de las barreras para su uso que los desarrolladores tienen que superar. </li><li>  La creación y el mantenimiento de una cadena de CI que ejecute todas estas herramientas requiere la presencia de ingenieros de lanzamiento y, como se mencionó anteriormente, contratar personas para trabajos de ingeniería que no están directamente relacionados con los juegos es un problema sistémico para la industria del juego. </li></ul><br>  Entonces, dado que estas herramientas funcionan tan bien con C ++ estándar, ¿por qué los desarrolladores de juegos no usan STL? <br><br>  ¿Dónde comenzar la respuesta a esta pregunta?  Quizás, de la próxima excursión a la historia del desarrollo del juego: <br><br><ul><li>  Hasta principios de los 90, no confiamos en los compiladores de C, por lo que escribimos juegos en ensamblador. </li><li>  Desde el comienzo hasta mediados de los 90, comenzamos a confiar en los compiladores de C, pero aún no confiamos en los compiladores de C ++.  Nuestro código era C, que usaba comentarios de estilo C ++, y ya no necesitábamos escribir typedefs para nuestras estructuras todo el tiempo. </li><li>  Alrededor de 2000, la revolución C ++ tuvo lugar en el mundo del desarrollo de juegos.  Fue una era <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de patrones de diseño</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">grandes jerarquías de clases</a> .  En ese momento, el soporte STL en las consolas dejaba mucho que desear, y las consolas gobernaban el mundo en ese momento.  En PS2, estamos atrapados para siempre con GCC 2.95. </li><li>  Alrededor de 2010, se lanzaron dos revoluciones más.  El dolor de usar grandes jerarquías de clase estimuló el desarrollo de un enfoque de componentes para el código.  Este cambio continúa su evolución hoy en forma de arquitecturas Entity-Component-System.  De la mano de esta fue la segunda revolución: un intento de aprovechar las arquitecturas multiprocesador. </li></ul><br>  Durante estos cambios de paradigma, las plataformas de desarrollo de juegos en sí estaban cambiando constantemente, y estaban cambiando seriamente.  La memoria segmentada ha dado paso a un espacio de direcciones plano.  Las plataformas se han convertido en multiprocesador, simétricas y no muy.  Los desarrolladores de juegos, acostumbrados a trabajar con arquitecturas Intel, tuvieron que acostumbrarse a MIPS (Playstation), luego a un hardware especial con CPU heterogéneas (PS2), luego a PowerPC (XBox 360), luego a una heterogeneidad aún mayor (PS3) ... La nueva plataforma viene con nuevas características de rendimiento para procesadores, memoria y unidades.  Si quería lograr un rendimiento óptimo, se vio obligado a reescribir su antiguo código, y muchas veces.  Ni siquiera mencionaré cuánto influyeron los juegos por la aparición y el crecimiento de la popularidad de Internet, así como las restricciones que los titulares de la plataforma impusieron a los desarrolladores. <br><br>  Históricamente, las implementaciones de STL en plataformas de juego han sido insatisfactorias.  No es un secreto que los contenedores STL no son adecuados para los juegos.  Si empuja al desarrollador del juego a la pared, entonces tal vez él admite que <code>std::string</code> está bastante bien, y <code>std::vector</code> es una opción predeterminada razonable.  Pero todos los contenedores contenidos en el STL tienen un problema de control de asignación e inicialización.  Muchos juegos tienen que preocuparse por las limitaciones de memoria para diversas tareas, y para aquellos objetos para los cuales la memoria probablemente tendrá que asignarse dinámicamente durante el juego, a menudo se usan asignadores de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><i>losas</i></a> o <i>arena</i> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El tiempo constante amortizado</a> no es un buen resultado, ya que la asignación es potencialmente una de las cosas más "costosas" que pueden suceder durante la ejecución del programa, y ​​no quiero omitir un marco solo porque sucedió cuando no lo esperaba .  Como desarrollador de juegos, debo administrar mis requisitos de memoria por adelantado. <br><br>  Se obtiene una historia similar para otras dependencias en general.  Los desarrolladores de juegos quieren saber qué toma cada ciclo de procesador, dónde y cuándo y de qué es responsable cada byte de memoria, y también dónde y cuándo se controla cada hilo de ejecución.  Hasta hace poco, los compiladores de Microsoft cambiaban ABI con cada actualización, por lo que si tenía muchas dependencias, reconstruirlas todas podría ser un proceso doloroso.  Los desarrolladores de juegos generalmente prefieren pequeñas dependencias que son fáciles de integrar, hacen solo una cosa y lo hacen bien, preferiblemente con una API de estilo C, y son utilizadas por muchas compañías, son de dominio público o tienen una licencia gratuita que no requiere una indicación del autor.  <i>SQLite</i> y <i>zlib</i> son buenos ejemplos de lo que los desarrolladores de juegos prefieren usar. <br><br>  Además, la industria de los juegos C ++ tiene una rica historia de pacientes con el síndrome "No inventado aquí".  Esto debería esperarse de la industria, que comenzó con entusiastas individuales que hicieron sus propias cosas con equipos completamente nuevos y no tenían otras opciones.  La industria del juego, entre otras cosas, es la única en la que los programadores se indican en los créditos sin ningún orden en particular.  <i>¡Escribir una variedad de cosas es divertido y ayuda a tu carrera!</i>  <i>¡Es mucho mejor construir algo propio que comprar ya hecho!</i>  Y dado que estamos tan preocupados por el rendimiento, podemos adaptar nuestra solución de tal manera que sea adecuada específicamente para nuestro proyecto, en lugar de tomar una solución generalizada que desperdicie recursos irreflexivamente.  La hostilidad hacia Boost es el principal ejemplo de cómo tal pensamiento se manifiesta en el desarrollo del juego.  Trabajé en proyectos que fueron de la siguiente manera: <br><br><ul><li>  Para comenzar, para resolver un problema en particular, conectamos una biblioteca de Boost al proyecto. </li><li>  Todo funciona muy bien.  Cuando necesita actualizar, se produce un pequeño dolor, pero no más que al actualizar cualquier otra dependencia. </li><li>  Otro juego quiere usar nuestro código, pero el escollo es que usamos Boost, a pesar de que nuestra experiencia con Boost ha ido bastante bien. </li><li>  Eliminamos el código usando Boost, pero ahora nos enfrentamos a un nuevo problema: debemos resolver el problema que la biblioteca de Boost en lugar de la nuestra resolvió antes. </li><li>  Esencialmente copiamos las partes del código Boost que necesitamos en nuestros propios espacios de nombres. </li><li>  Más tarde, inevitablemente y una y otra vez nos encontramos con el hecho de que necesitamos una funcionalidad adicional que ya estaría en el código original si no la hubiéramos descartado.  Pero ahora somos los propietarios de este código, por lo que debemos continuar admitiéndolo. </li></ul><br>  No nos gusta algo enorme que está tratando de hacer muchas cosas al mismo tiempo o que puede afectar el tiempo de compilación, y esto es bastante razonable.  Lo que la gente comete errores una y otra vez es que se oponen a aceptar el supuesto dolor hoy, mientras que debido a esta decisión enfrentarán un dolor muy real y mucho mayor con el apoyo de algo a expensas de alguien. el presupuesto que tendrán que experimentar en los próximos tres años.  Lamentablemente, la presencia de evidencia en forma de juegos que utilizan con éxito un plato de STL y Boost, de ninguna manera puede afectar la psicología humana y convencer a los desarrolladores de juegos. <br><br>  Por todas estas razones, muchas compañías de juegos han creado sus propias bibliotecas que cubren lo que hace STL, y aún más, al tiempo que admiten casos de uso específicos del juego.  Algunas grandes compañías de juegos incluso pudieron dominar el desarrollo de su propio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">reemplazo de STL</a> completo, casi completamente compatible con API, lo que posteriormente conllevó enormes costos para apoyar este proyecto. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Es aconsejable encontrar una alternativa mejorada a</a> <code>std::map</code> , o aplicar una <i>pequeña optimización del búfer</i> en <code>std::vector</code> .  Es mucho menos aceptable estar condenado a admitir sus propias implementaciones de <code>algorithms</code> o <code>type traits</code> , lo que hará poco bien.  En cuanto a mí, es lamentable que para la mayoría de los desarrolladores, los STL sean solo contenedores.  Dado que al aprender STL al principio, se les enseña exactamente eso, hablando de STL, la mayoría implica <code>std::vector</code> , aunque de hecho deberían pensar en <code>std::find_if</code> . <br><br><h3>  Oportunidad No. 3: Pruebas </h3><br>  Se argumenta que se deben realizar pruebas exhaustivas, TDD y / o BDD deben cubrir todo el código que se puede cubrir, y los errores deben abordarse escribiendo nuevas pruebas. <br><br>  Por lo tanto, discutamos el tema de las pruebas. <br><br>  A juzgar por mi experiencia, las pruebas automatizadas prácticamente no se utilizan en la industria del juego.  Por qué <br><br><h4>  1. Porque la corrección <i>no</i> es <i>tan</i> importante, pero no hay una especificación real </h4><br>  Como un joven programador en la industria del juego, rápidamente me deshice de la idea de que debería esforzarme por simular algo de manera realista.  Los juegos son <i>humo y espejos</i> y la búsqueda de caminos cortos.  A nadie le importa cuán realista sea tu simulación;  Lo principal es que sea divertido.  Cuando no tienes otra especificación que "el juego debería sentirse bien", falta el tema de la prueba.  Gracias a los errores, la jugabilidad puede incluso mejorar.  Muy a menudo, un error entra en el lanzamiento, e incluso se gana el amor de los usuarios ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">recuerda el mismo Gandhi de Civilization</a> ).  Los juegos son diferentes de otras áreas que usan C ++;  aquí la falta de corrección no lleva al hecho de que alguien eventualmente pierda sus ahorros. <br><br><h4>  2. Porque es difícil </h4><br>  Por supuesto, le gustaría producir pruebas automatizadas siempre que pueda.  Esto se puede hacer para algunos subsistemas para los cuales hay resultados finales claramente establecidos.  Las pruebas unitarias en la industria del juego, por supuesto, están presentes, pero por regla general se limitan al código de bajo nivel: los análogos de STL mencionados anteriormente, los procedimientos de conversión de cadenas, los métodos de motor físico, etc.  Los casos en que la sección ejecutable del código tiene resultados predecibles generalmente se prueban mediante pruebas unitarias, aunque TDD no se usa aquí, ya que los programadores de juegos prefieren simplificar sus vidas, y no al revés.  Pero, ¿cómo se prueba el código de juego (ver punto uno)?  Tan pronto como va más allá de las pruebas unitarias, inmediatamente se encuentra con otra razón por la cual probar juegos es tan difícil. <br><br><h4>  3. Porque el contenido está involucrado </h4><br>  Probando sistemas no triviales probablemente incluirá la provisión de contenido con el cual será implementado.  La mayoría de los ingenieros no son muy buenos para producir este contenido por sí mismos, por lo que para obtener una prueba significativa, deberá atraer a alguien con las habilidades adecuadas para crear el contenido.  Después de lo cual encontrará el problema de medir lo que obtiene en la salida; después de todo, esto ya no es una línea o un número, sino una imagen en la pantalla o un sonido que cambia con el tiempo. <br><br><h4>  4. Porque no lo practicamos </h4><br>  La prueba unitaria es una función para la que conozco las posibles entradas y salidas.  Sin embargo, la jugabilidad es un comportamiento impredecible, que evoluciona dinámicamente, y no sé cómo se podría probar adecuadamente este fenómeno.  ¿Qué puedo probar? Si, ​​por supuesto, obtengo permiso de mi gerente para dedicar suficiente tiempo a esto, esto es, por ejemplo, el rendimiento o las capacidades de alto nivel, como el emparejamiento, que puedo analizar.  Tal trabajo de infraestructura puede ser emocionante para algunos programadores de juegos, pero para la mayoría simplemente no es interesante, y además requiere la aprobación y el apoyo del propietario de la billetera.  Como programador de juegos, nunca tengo la oportunidad de practicar escribir exámenes de alto nivel. <br><br><h4>  5. Dado que [empresa] no ve la necesidad de realizar pruebas automatizadas </h4><br>  Nuestro objetivo principal es lanzar el juego.  Vivimos en una era de industria que avanza con éxitos que aprovechan al máximo su dinero en el primer mes de ventas, cuando los costos de comercialización de estos éxitos se maximizan.  El ciclo de vida de las consolas nos enseñó que, en cualquier caso, el código no durará tanto.  Si estamos trabajando en un juego en línea, lo más probable es que tengamos tiempo adicional para probar el emparejamiento o la carga del servidor.  Dado que para el lanzamiento del juego necesitamos que su rendimiento esté en orden, al menos deberíamos realizar pruebas de rendimiento, pero no deberíamos automatizar este proceso.  Para la administración en la industria del juego, las pruebas automatizadas no son más que una pérdida de tiempo y dinero.  Para su implementación, es necesario contratar ingenieros experimentados que llevarán a cabo el trabajo, cuyo resultado será casi imperceptible.  Se podría dedicar el mismo tiempo al desarrollo de nuevas funciones.  A corto plazo, es mucho más rentable utilizar personal de control de calidad para probar el juego, lo que nos lleva al siguiente punto. <br><br><h4>  6. Porque, en general, las pruebas en juegos se clasifican como actividades de segundo orden </h4><br>  Me encantan los buenos profesionales de control de calidad.  Para mí valen su peso en oro.  Saben cómo mejorar tu juego rompiéndolo de una manera que nunca se te hubiera pasado por la cabeza.  Son expertos especializados en tu juego en ese aspecto en el que no entiendes y casi nunca entiendes.  Son mejores que un equipo de compiladores súper capaces para ayudarlo a hacer todo bien.  Me alegra haber tenido la oportunidad de trabajar con varios maravillosos especialistas en control de calidad durante los años de mi trabajo. <br><br>  Casi siempre tuve que luchar para asegurarme de que permanecieran en mi equipo. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En las grandes empresas AAA, una organización de control de calidad suele ser un departamento completamente separado de cualquier equipo de desarrollo, con su propia estructura organizativa y de gestión. Supuestamente, esto se hace para que puedan ser objetivos durante la prueba. En la práctica, todo está lejos de ser tan hermoso. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Son tratados como engranajes en un mecanismo enorme, que a menudo se lanzan entre proyectos sin previo aviso y generalmente se tratan como si alguien pudiera manejar su trabajo. Cuando el proyecto "se aleja" de la fecha límite, los ingenieros pueden sentir la crisis en su propia piel, pero el control de calidad se vuelve mucho más fuerte, porque tienen que trabajar en el turno de noche y los fines de semana, además de que también reciben noticias sombrías sobre la actualidad. estado de calidad del proyecto.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Están seriamente mal pagados. Los evaluadores más experimentados con años de experiencia en el área temática reciben menos de la mitad de lo que pagan a un desarrollador de nivel medio. Tuve que trabajar con los ingenieros de control de calidad más inteligentes que crearon proyectos para pruebas de rendimiento con seguimiento y alertas, crearon marcos para probar API y pruebas de estrés, y realizaron muchas otras tareas supuestamente indignas de la época de los "ingenieros reales". Estoy seguro de que estas personas más inteligentes obtendrían mucho más si trabajaran en cualquier otra gran empresa de tecnología. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No son de confianza. No es raro que los evaluadores se mantengan separados de otros desarrolladores, y sus credenciales les permiten acceder solo al piso del edificio donde trabajan ellos mismos, o incluso usar una entrada separada.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se ven obligados a obedecer. A menudo se les dice a los evaluadores que no molesten a otros ingenieros. Cuando necesitan informar un error directamente, se les pide que se comuniquen con los ingenieros respetuosamente, como "la Sra. H." o "Sr. Y." A veces recibí una llamada de los jefes molestos de los departamentos de control de calidad, en esos casos cuando contacté a aquellos que descubrieron el error para una investigación conjunta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todo esto suena como una historia terrible, y que no todos tengan que lidiar con tales cosas, desafortunadamente esto sucede con bastante frecuencia; tan a menudo que los ingenieros comienzan a pensar, quizás bajo una carga de estrés constante, pero eso no los disculpa, que el trabajo de QA es buscar sus propios errores o, lo que es peor, comenzar a culpar a QA por los errores.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En los mejores equipos con los que tuve que trabajar, insistimos en que nuestros equipos tengan sus propios ingenieros de control de calidad que trabajarían con nosotros. </font><font style="vertical-align: inherit;">Sin embargo, no perdieron su objetividad o deseo de lograr un mejor resultado. </font><font style="vertical-align: inherit;">Les complació recibir ayuda de los programadores para redactar pruebas automatizadas. </font><font style="vertical-align: inherit;">Lo que ciertamente no dudo es que sería útil para la industria del juego hacer la automatización con más frecuencia.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rendimiento de depuración </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado todo lo anterior, los hábitos de depuración, la plataforma para las API y las herramientas que aún están creciendo, y la complejidad (combinada con la falta de cultura) de las pruebas automatizadas, queda claro por qué los desarrolladores de juegos insisten en las capacidades de depuración. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero al mismo tiempo, sigue habiendo problemas con la depuración en sí misma y problemas con la forma en que los desarrolladores de juegos hacen frente al vector de desarrollo actual de C ++.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El principal problema con la depuración es que no se escala. </font><font style="vertical-align: inherit;">Entre los desarrolladores de juegos de desarrolladores que leen esta publicación, hay quienes deciden que los fenómenos que describí no están de acuerdo con lo que observaron en su práctica. </font><font style="vertical-align: inherit;">Posiblemente, esto se deba al hecho de que tarde o temprano ellos mismos tuvieron que lidiar con el problema de la escalabilidad de la depuración, y encontraron una forma de evitarlo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En otras palabras, queremos tener una depuración productiva, porque para detectar errores, a menudo necesitamos poder ejecutar aplicaciones con conjuntos de datos suficientemente grandes y representativos. Pero, de hecho, cuando llegamos a este punto, el depurador generalmente se convierte en una herramienta demasiado grosera para usar, independientemente de si es productiva o no. Por supuesto, establecer puntos de interrupción en los datos ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puntos de interrupción de datos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) puede ser útil para detectar problemas de tamaño mediano, pero ¿qué sucede si encontramos errores reales, los que quedan después de que parece que lo hemos solucionado todo? Con los que surgen bajo la carga de la red, o en el caso de una falta de memoria, o que trabajan al límite de las capacidades de subprocesamiento múltiple, o que suceden solo para un pequeño subconjunto no identificado en el contexto de un millón de otros jugadores, o surgen solo en versiones de disco del juego, o solo en la asamblea en alemán, o después de pasar tres horas en pruebas de estabilidad ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prueba de remojo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rasgo dos, podemos confiar solo en el depurador. En este caso, hacemos lo que siempre hicimos. Estamos tratando de aislar el problema, hacer que suceda con más frecuencia; agregamos el registro y tamizamos nuestro programa a través de él; ajustamos temporizadores y configuraciones de flujo; utilizamos búsqueda de compilación binaria; estudiamos volcados de núcleos y registros de fallos; intentamos reproducir el problema recortando el contenido al mínimo; reflexionamos sobre lo que podría estar causando el problema y lo discutimos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A menudo, hasta que lleguemos a la causa real del accidente, tendremos tiempo para arreglar algunas otras cosas. En otras palabras, resolvemos problemas y, al final, usar un depurador es solo una pequeña parte de este proceso. Entonces sí, la velocidad de depuración es una buena adición, pero su falta no nos impide seguir siendo ingenieros. Todavía necesitamos nuestras otras habilidades, como la capacidad de analizar los volcados del núcleo y leer el ensamblador optimizado.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando uso "C ++ moderno", uso el depurador de la misma manera que de costumbre. Reviso el código recién escrito; Pongo puntos de interrupción en los datos que me interesan; Yo uso un depurador para explorar código desconocido. Con el advenimiento del "C ++ moderno", nada de esto cambia, y sí, aunque el STL usa identificadores _ feos _, esto no hace que el STL sea mágico. A veces es útil ver qué hace el STL "debajo del capó" o pasar por encima; o, como puede hacer ahora, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">use el depurador para ocultarme el código de la biblioteca</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando me encuentro con problemas de rendimiento de depuración, generalmente no es que el "C ++ moderno" me frene, el hecho es que en este momento ya estoy tratando de hacer demasiado. El uso del depurador </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no se escala</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a diferencia de los tipos, herramientas y pruebas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yo mismo estaba preocupado por el problema de que el código C ++ necesitaba más y más optimización, y estaba interesado en la opinión de los desarrolladores de compiladores sobre esto. El hecho es que no hay una respuesta única. Ya estamos en el continuo, y tenemos la oportunidad de avanzar más en esta dirección sin dañar la capacidad de depurar código. Hoy, nuestros compiladores realizan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">copias de elisión</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para objetos temporales.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, incluso si no les pedimos que realicen esta optimización. </font><font style="vertical-align: inherit;">Esto no afecta nuestra capacidad de depurar aplicaciones. </font><font style="vertical-align: inherit;">Dudo que nos quejemos de que las compilaciones de depuración comenzaron a incluir NRVO u otra media docena de optimizaciones que se pueden hacer de tal manera que no las notaremos durante la depuración. </font><font style="vertical-align: inherit;">Sospecho que C ++ se está moviendo en </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esa</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dirección.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Epílogo: El camino de C ++ moderno </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si trabajas como programador en el campo del desarrollo de juegos y no te gusta hacia dónde se dirige C ++, entonces básicamente tienes dos opciones para posibles acciones adicionales. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1. No hacer nada </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suponiendo que todavía va a escribir código C ++, simplemente puede continuar usando el lenguaje de la misma manera que lo hizo antes. No es necesario comenzar a usar ninguna función nueva si no desea hacerlo. Casi todo lo que usa ahora continuará siendo compatible, y al hacerlo, en los próximos años continuará cosechando los beneficios de mejorar el compilador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta es una estrategia de comportamiento completamente apropiada para quienes trabajan para sí mismos o con un equipo de personas de ideas afines. C ++ 98, junto con algunas características más nuevas, sigue siendo una buena opción para escribir juegos en él.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, si trabaja en una gran empresa, tarde o temprano tendrá que enfrentar cambios en el idioma, ya que tendrá que aumentar el equipo y contratar nuevas personas. </font><font style="vertical-align: inherit;">A su vez, cuando contrata desarrolladores de C ++, esto significará contratar desarrolladores con C ++ "moderno". </font><font style="vertical-align: inherit;">Ocurrirá un cambio de generaciones, como ya sucedió con el ensamblador, C y C ++ 98. </font><font style="vertical-align: inherit;">Puede administrar el proceso si establece límites sobre lo que está permitido en su base de código y lo que no, pero esta solución no lo salvará a largo plazo. </font><font style="vertical-align: inherit;">¿Y qué debes hacer en este caso?</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2. Participa </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En lugar de ir a un solo GDC una vez al año, comience a visitar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CppCon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , donde obtendrá mucho más beneficio del dinero que su compañía gastó en un boleto. Participar en discusiones sobre estándares; unirse a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grupos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y suscribirse a boletines informativos; lea los </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">borradores de normas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y brinde retroalimentación a los autores. Si también puede asistir a las reuniones del comité, estará bien, pero incluso si no, aún puede hacer mucho para transmitir su punto de vista a los demás. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La membresía en el Comité C ++ está abierta a todos. Toda la información necesaria para aquellos que desean participar en el trabajo de SG14, SG7 o SG15, o cualquier otro grupo de trabajo relacionado con su área de interés,</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se puede encontrar en isocpp.org</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">El comité no tiene planes secretos; de hecho, ¿realmente crees que más de 200 programadores pueden ponerse de acuerdo sobre una agenda común? </font><font style="vertical-align: inherit;">Aquí, incluso los "jefes" del comité a menudo no "empujan" sus ideas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si desea que se escuche su opinión, entonces debe comenzar a hablar donde se pueda escuchar su opinión, y no en Twitter o Reddit. </font><font style="vertical-align: inherit;">Por favor tome este consejo. Espero con ansias nuestra discusión.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es435036/">https://habr.com/ru/post/es435036/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es435018/index.html">En 2018, finalmente comenzamos a tomarnos en serio el tiempo que pasamos en el teléfono inteligente</a></li>
<li><a href="../es435020/index.html">Salón de la fama de la electrónica de consumo: las historias de los mejores artilugios de los últimos 50 años, parte 2</a></li>
<li><a href="../es435026/index.html">Hacemos un messenger * que funciona incluso en el elevador</a></li>
<li><a href="../es435028/index.html">Pruebas C sin SMS y registro</a></li>
<li><a href="../es435032/index.html">La nave espacial Chang'e-4 hizo un aterrizaje exitoso en el lado lejano de la luna y envió la primera foto</a></li>
<li><a href="../es435038/index.html">Energía nuclear mundial en 2018</a></li>
<li><a href="../es435040/index.html">Bitcoin hace 10 años</a></li>
<li><a href="../es435044/index.html">Antigüedades: Minidisc en su hábitat natural</a></li>
<li><a href="../es435050/index.html">Historia de cómo se instaló .NET 4.5 en ReactOS</a></li>
<li><a href="../es435054/index.html">Universidad ITMO "en la práctica": con qué empresas de tecnología cooperamos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>