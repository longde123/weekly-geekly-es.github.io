<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üß° „Ä∞Ô∏è ‚è∫Ô∏è Seguimiento din√°mico con todas las funciones en Linux utilizando eBPF y bpftrace ‚úãüèª üõï üêê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""En el modo de rastreo, el programador ve la secuencia de ejecuci√≥n del comando y los valores de las variables en este paso de la ejecuci√≥n del progra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Seguimiento din√°mico con todas las funciones en Linux utilizando eBPF y bpftrace</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/441258/"><img src="https://habrastorage.org/webt/gd/t6/e_/gdt6e_wwaanx1prvqkhdhj5ptss.jpeg"><br><br>  "En el modo de rastreo, el programador ve la secuencia de ejecuci√≥n del comando y los valores de las variables en este paso de la ejecuci√≥n del programa, lo que facilita la detecci√≥n de errores", nos dice Wikipedia.  Como fan√°ticos de Linux, nos encontramos regularmente con la pregunta de qu√© herramientas espec√≠ficas son las mejores para implementarlo.  Y queremos compartir la traducci√≥n de un art√≠culo del programador Hongley Lai que recomienda bpftrace.  Mirando hacia el futuro, dir√© que el art√≠culo termina sucintamente: "bpftrace es el futuro".  Entonces, ¬øpor qu√© impresion√≥ tanto al colega de Lai?  Una respuesta detallada debajo del corte. <br><a name="habracut"></a><br>  Hay dos herramientas principales de rastreo en Linux: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">strace le</a> permite ver qu√© llamadas al sistema se est√°n realizando; <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ltrace le</a> permite ver qu√© bibliotecas din√°micas se est√°n llamando. <br><br>  A pesar de su utilidad, estas herramientas son limitadas.  ¬øY si necesita averiguar qu√© sucede dentro de un sistema o una llamada a la biblioteca?  ¬øY si necesita no solo compilar una lista de llamadas, sino tambi√©n, por ejemplo, recopilar estad√≠sticas sobre cierto comportamiento?  ¬øY si necesita rastrear varios procesos y comparar datos de varias fuentes? <br><br>  En 2019, finalmente obtuvimos una respuesta decente a estas preguntas en Linux: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bpftrace</a> basado en la tecnolog√≠a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">eBPF</a> .  Bpftrace le permite escribir peque√±os programas que se ejecutan cada vez que ocurre un evento. <br><br>  En este art√≠culo describir√© c√≥mo instalar bpftrace y ense√±ar√© su aplicaci√≥n b√°sica.  Tambi√©n dar√© una descripci√≥n general de c√≥mo se ve el ecosistema de rastreo (por ejemplo, ‚Äú¬øqu√© es eBPF?‚Äù) Y c√≥mo ha evolucionado hasta convertirse en lo que tenemos hoy. <br><br><img src="https://habrastorage.org/webt/v9/vp/di/v9vpdivpv8a6roolw_kiz7wtnfs.png"><br><br><h3>  ¬øQu√© es un rastro? </h3><br>  Como se mencion√≥ anteriormente, bpftrace le permite escribir peque√±os programas que se ejecutan cada vez que ocurre un evento. <br><br>  ¬øQu√© es un evento?  Podr√≠a ser una llamada al sistema, una llamada a la funci√≥n o incluso algo que ocurre dentro de tales solicitudes.  Tambi√©n puede ser un temporizador o un evento de hardware, por ejemplo, "han transcurrido 50 ms desde el √∫ltimo de los mismos eventos", "se produjo un error de p√°gina", "se produjo un cambio de contexto" o "se produjo un procesador de p√©rdida de cobro". <br><br>  ¬øQu√© se puede hacer en respuesta a un evento?  Puede prometer algo, recopilar estad√≠sticas y ejecutar comandos de shell arbitrarios.  Tendr√° acceso a diversa informaci√≥n contextual, como el PID actual, el seguimiento de la pila, el tiempo, los argumentos de llamada, los valores de retorno, etc. <br><br>  Cuando usar  En muchos.  Puede averiguar por qu√© la aplicaci√≥n es lenta compilando una lista de las llamadas m√°s lentas.  Puede determinar si hay p√©rdidas de memoria en la aplicaci√≥n y, de ser as√≠, d√≥nde.  Lo uso para entender por qu√© Ruby usa tanta memoria. <br><br>  La gran ventaja de bpftrace es que no necesita volver a compilar la aplicaci√≥n.  No es necesario escribir manualmente llamadas impresas ni ning√∫n otro c√≥digo de depuraci√≥n en el c√≥digo fuente de la aplicaci√≥n en estudio.  Ni siquiera es necesario reiniciar las aplicaciones.  Y todo esto con gastos generales muy bajos.  Esto hace que bpftrace sea especialmente √∫til para depurar sistemas directamente en el producto o en otra situaci√≥n donde hay dificultades con la recompilaci√≥n. <br><br><h3>  DTrace: padre del rastro </h3><br>  Durante mucho tiempo, la mejor herramienta de rastreo fue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DTrace</a> , un completo marco de rastreo din√°mico desarrollado originalmente por Sun Microsystems (los creadores de Java).  Al igual que bpftrace, DTrace le permite escribir peque√±os programas que se ejecutan en respuesta a eventos.  De hecho, muchos de los elementos clave del ecosistema son desarrollados en gran parte por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Brendan Gregg</a> , un reconocido experto de DTrace que actualmente trabaja en Netflix.  Lo que explica las similitudes entre DTrace y bpftrace. <br><br><img src="https://habrastorage.org/webt/2p/wc/4w/2pwc4wawnfzibvlwt7ia0xibodc.jpeg"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Introducci√≥n a Solaris DTrace (2009)</a> por S. Tripathi, Sun Microsystems</i> <br><br>  En alg√∫n momento, Sun abri√≥ la fuente de DTrace.  Hoy, DTrace est√° disponible en Solaris, FreeBSD y macOS (aunque la versi√≥n de macOS generalmente no funciona porque System Integrity Protection, SIP, ha roto muchos de los principios en los que se ejecuta DTrace). <br><br>  S√≠, has notado correctamente ... Linux no est√° en esta lista.  Esto no es un problema de ingenier√≠a, es un problema de licencia.  DTrace se abri√≥ bajo el CDDL en lugar de la GPL.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El puerto Linux DTrace ha</a> estado disponible desde 2011, pero nunca ha sido compatible con los principales desarrolladores de Linux.  A principios de 2018, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Oracle volvi√≥ a abrir DTrace bajo la GPL</a> , pero para entonces ya era demasiado tarde. <br><br><h3>  Ecosistema de rastreo de Linux </h3><br>  Sin duda, el rastreo es muy √∫til, y la comunidad de Linux ha tratado de desarrollar sus propias soluciones a este tema.  Pero, a diferencia de Solaris, Linux no est√° regulado por un proveedor espec√≠fico y, por lo tanto, no hubo un esfuerzo deliberado para desarrollar un reemplazo completamente funcional para DTrace.  El ecosistema de rastreo de Linux ha evolucionado lenta y naturalmente, resolviendo problemas a medida que surgen.  Y solo recientemente este ecosistema ha crecido lo suficiente como para competir seriamente con DTrace. <br><br>  Debido al crecimiento natural, este ecosistema puede parecer un poco ca√≥tico, y consta de muchos componentes diferentes.  Afortunadamente, Julia Evans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">escribi√≥ una revisi√≥n de este ecosistema</a> (atenci√≥n, fecha de publicaci√≥n - 2017, antes del advenimiento de bpftrace). <br><br><img src="https://habrastorage.org/webt/io/km/zq/iokmzq2fmqyechm1boqeks-w2za.png"><br>  <i>Ecosistema de rastreo de Linux descrito por Julia Evans</i> <br><br>  No todos los elementos son igualmente importantes.  Perm√≠tanme resumir brevemente qu√© elementos considero m√°s importantes. <br><br>  <b>Fuentes de eventos</b> <br><br>  Los datos de eventos pueden provenir del n√∫cleo o del espacio de usuario (aplicaciones y bibliotecas).  Algunos de ellos est√°n disponibles autom√°ticamente, sin esfuerzos adicionales del desarrollador, mientras que otros requieren un anuncio manual. <br><br><img src="https://habrastorage.org/webt/2t/xm/mm/2txmmm6rz5xfcwcglsxy8zopr6q.jpeg"><br>  <i>Descripci√≥n general de las fuentes m√°s importantes de eventos rastreados en Linux</i> <br><br>  En el lado del n√∫cleo, hay kprobes ( <i>de "sondas del n√∫cleo", "sensor del n√∫cleo", aprox. Per.</i> ), Un mecanismo que le permite rastrear cualquier llamada de funci√≥n dentro del n√∫cleo.  Con √©l, puede rastrear no solo las llamadas del sistema, sino tambi√©n lo que sucede dentro de ellos (porque los puntos de entrada de las llamadas del sistema llaman a otras funciones internas).  Tambi√©n puede usar kprobes para rastrear eventos del kernel que no son llamadas del sistema, por ejemplo, "los datos almacenados en el b√∫fer se escriben en el disco", "el paquete TCP se env√≠a a trav√©s de la red" o "el cambio de contexto est√° en curso". <br><br>  Los puntos de rastreo del n√∫cleo permiten rastrear eventos no est√°ndar definidos por los desarrolladores del n√∫cleo.  Estos eventos no est√°n al nivel de las llamadas a funciones.  Para crear tales puntos, los desarrolladores del kernel colocan manualmente la macro TRACE_EVENT en el c√≥digo del kernel. <br><br>  Ambas fuentes tienen pros y contras.  Kprobes funciona "autom√°ticamente" porque  no requiere que los desarrolladores del kernel codifiquen manualmente el c√≥digo.  Pero los eventos kprobe pueden cambiar arbitrariamente de una versi√≥n del kernel a otra, porque las funciones cambian constantemente: se agregan, eliminan y cambian de nombre. <br><br>  Los puntos de traza del n√∫cleo son generalmente m√°s estables en el tiempo y pueden proporcionar informaci√≥n contextual √∫til que puede no estar disponible si se usa kprobes.  Usando kprobes, puede acceder a argumentos de llamada de funci√≥n.  Pero con la ayuda de puntos de rastreo, puede obtener cualquier informaci√≥n que el desarrollador del n√∫cleo decida describir manualmente. <br><br>  En el espacio de usuario hay un an√°logo de kprobes: uprobes.  Est√° dise√±ado para rastrear llamadas a funciones en el espacio del usuario. <br><br>  Los sensores USDT ("Rastreos de espacio de usuario definidos est√°ticamente") son un an√°logo de los puntos de rastreo del n√∫cleo en el espacio de usuario.  Los desarrolladores de aplicaciones necesitan agregar manualmente sensores USDT a su c√≥digo. <br><br>  Dato interesante: DTrace ha proporcionado durante mucho tiempo la API de C para definir su propio an√°logo de sensores USDT (utilizando la macro DTRACE_PROBE).  Los desarrolladores de ecosistemas de rastreo en Linux decidieron dejar el c√≥digo fuente compatible con esta API, por lo que cualquier macro DTRACE_PROBE se convierte autom√°ticamente en sensores USDT. <br><br>  Por lo tanto, en teor√≠a, strace se puede implementar usando kprobes, y ltrace se puede implementar usando uprobes.  No estoy seguro de si esto ya se practica o no. <br><br>  <b>Interfaces</b> <br><br>  Las interfaces son aplicaciones que permiten a los usuarios usar f√°cilmente or√≠genes de eventos. <br><br>  Veamos c√≥mo funcionan las fuentes de eventos.  El flujo de trabajo es el siguiente: <br><br><ol><li>  El kernel representa un mecanismo, generalmente un archivo / proc o / sys que est√° abierto para escritura, que registra tanto la intenci√≥n de rastrear el evento como lo que deber√≠a seguir al evento. </li><li>  Despu√©s de registrarse, el n√∫cleo localiza en la memoria el n√∫cleo / funci√≥n en el espacio de usuario / puntos de rastreo / sensores USDT y cambia su c√≥digo para que ocurra algo m√°s. </li><li>  El resultado de este "algo m√°s" se puede recoger m√°s tarde utilizando alg√∫n mecanismo. </li></ol><br>  ¬°No quisiera hacer todo esto manualmente!  Por lo tanto, las interfaces vienen al rescate: hacen todo esto por usted. <br><br>  Hay interfaces para todos los gustos y colores.  En el campo de las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">interfaces basadas en eBPF,</a> existen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">interfaces de</a> bajo nivel que requieren una comprensi√≥n profunda de c√≥mo interactuar con las fuentes de eventos y c√≥mo funciona el bytecode de eBPF.  Y son de alto nivel y f√°ciles de operar, aunque durante su existencia no demostraron una gran flexibilidad. <br><br>  Es por eso que bpftrace, la √∫ltima interfaz, es mi favorita.  Es f√°cil de usar y flexible como DTrace.  Pero es bastante nuevo y requiere pulido. <br><br><h3>  eBPF </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">eBPF</a> es la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nueva estrella de rastreo de Linux</a> en la que se basa bpftrace.  Cuando rastrea un evento, desea que algo suceda en el n√∫cleo.  ¬øQu√© manera flexible de determinar qu√© es este "algo"?  Por supuesto, usando un lenguaje de programaci√≥n (o usando c√≥digo de m√°quina). <br><br>  eBPF (versi√≥n mejorada del filtro de paquetes Berkeley).  Esta es una m√°quina virtual de alto rendimiento que se ejecuta en el n√∫cleo y tiene las siguientes propiedades / limitaciones: <br><br><ul><li>  Todas las interacciones del espacio del usuario ocurren a trav√©s de "tarjetas" eBPF, que son almacenamiento de datos de valor clave. </li><li>  No hay ciclos para que cada programa eBPF finalice en un momento espec√≠fico. </li><li>  Espera, dijimos Batch Filter?  Tienes raz√≥n: originalmente fueron dise√±ados para filtrar paquetes de red.  Esta es una tarea similar: al reenviar paquetes (la ocurrencia de un evento) debe realizar alguna acci√≥n administrativa (aceptar, descartar, registrar o redirigir un paquete, etc.) Se invent√≥ una m√°quina virtual para acelerar tales acciones (con capacidad JIT) compilaci√≥n).  Se considera una versi√≥n "extendida" debido al hecho de que, en comparaci√≥n con la versi√≥n original del Berkeley Packet Filter, eBPF puede usarse fuera del contexto de la red. </li></ul><br>  Ah√≠ tienes.  Con bpftrace, puede determinar qu√© eventos rastrear y qu√© deber√≠a suceder en respuesta.  Bpftrace compila su programa bpftrace de alto nivel en el c√≥digo de bytes eBPF, rastrea eventos y carga el c√≥digo de bytes en el n√∫cleo. <br><br><h3>  D√≠as oscuros antes de eBPF </h3><br>  Antes de eBPF, las opciones de soluci√≥n eran, por decirlo suavemente, inc√≥modas.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SystemTap</a> es un poco el predecesor "m√°s serio" para bpftrace en la familia Linux.  Los scripts de SystemTap se traducen al lenguaje C y se cargan en el n√∫cleo como m√≥dulos.  El m√≥dulo de kernel resultante se carga. <br><br>  Este enfoque era muy fr√°gil y mal soportado fuera de Red Hat Enterprise Linux.  Para m√≠, nunca funcion√≥ bien en Ubuntu, que tendi√≥ a romper SystemTap en cada actualizaci√≥n del n√∫cleo debido a un cambio en la estructura de datos del n√∫cleo.  Tambi√©n se dice que en los primeros d√≠as de su existencia, SystemTap <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">f√°cilmente condujo al kernel panic</a> . <br><br><h3>  Instalaci√≥n de bpftrace </h3><br>  ¬°Es hora de remangarse las mangas!  En esta gu√≠a, veremos c√≥mo instalar bpftrace en Ubuntu 18.04.  Las versiones m√°s nuevas de la distribuci√≥n no son deseables, porque  durante la instalaci√≥n, necesitaremos paquetes que a√∫n no se hayan compilado para ellos. <br><br>  <b>Instalaci√≥n de dependencia</b> <br><br>  Primero, instale Clang 5.0, lbclang 5.0 y LLVM 5.0, incluidos todos los archivos de encabezado.  Utilizaremos los paquetes proporcionados por llvm.org, porque los que est√°n en los repositorios de Ubuntu son <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">problem√°ticos</a> . <br><br><pre><code class="plaintext hljs">wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key | sudo apt-key add - cat &lt;&lt;EOF | sudo tee -a /etc/apt/sources.list deb http://apt.llvm.org/xenial/ llvm-toolchain-xenial main deb-src http://apt.llvm.org/xenial/ llvm-toolchain-xenial main deb http://apt.llvm.org/xenial/ llvm-toolchain-xenial-5.0 main deb-src http://apt.llvm.org/xenial/ llvm-toolchain-xenial-5.0 main EOF sudo apt update sudo apt install clang-5.0 libclang-5.0-dev llvm-5.0 llvm-5.0-dev</code> </pre> <br>  Siguiente: <br><br><pre> <code class="plaintext hljs">sudo apt install bison cmake flex g++ git libelf-dev zlib1g-dev libfl-dev</code> </pre> <br>  Y, por √∫ltimo, instale libbfcc-dev desde arriba, no desde el repositorio de Ubuntu.  No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hay archivos de encabezado</a> en el paquete que se encuentra en Ubuntu.  Y este problema no se resolvi√≥ ni siquiera a las 18.10. <br><br><pre> <code class="plaintext hljs">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 4052245BD4284CDD echo "deb https://repo.iovisor.org/apt/$(lsb_release -cs) $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/iovisor.list sudo apt update sudo apt install bcc-tools libbcc-examples linux-headers-$(uname -r)</code> </pre> <br>  <b>Instalaci√≥n principal de bpftrace</b> <br><br>  ¬°Es hora de instalar bpftrace desde la fuente!  Vamos a clonarlo, ensamblarlo e instalarlo en / usr / local: <br><br><pre> <code class="plaintext hljs">git clone https://github.com/iovisor/bpftrace cd bpftrace mkdir build &amp;&amp; cd build cmake -DCMAKE_BUILD_TYPE=DEBUG .. make -j4 sudo make install</code> </pre> <br>  Y ya terminaste!  El ejecutable se instalar√° en / usr / local / bin / bpftrace.  Puede cambiar el destino utilizando el argumento cmake, que se ve as√≠ de forma predeterminada: <br><br><pre> <code class="plaintext hljs">DCMAKE_INSTALL_PREFIX=/usr/local.</code> </pre> <br>  <b>Ejemplos de una l√≠nea</b> <br><br>  Ejecutemos algunos bpftrace single-liners para comprender nuestras capacidades.  Tom√© estos de la <a href="">gu√≠a</a> de <a href="">Brendan Gregg</a> , que tiene una descripci√≥n detallada de cada uno de ellos. <br><br>  # 1. Mostrar una lista de sensores <br><br><pre> <code class="plaintext hljs">bpftrace -l 'tracepoint:syscalls:sys_enter_*'</code> </pre> <br>  # 2. Saludos <br><br><pre> <code class="plaintext hljs">bpftrace -e 'BEGIN { printf("hello world\n"); }'</code> </pre> <br>  # 3. Abrir un archivo <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:syscalls:sys_enter_open { printf("%s %s\n", comm, str(args-&gt;filename)); }'</code> </pre> <br>  # 4. El n√∫mero de llamadas al sistema por proceso <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:raw_syscalls:sys_enter { @[comm] = count(); }'</code> </pre> <br>  # 5. Distribuci√≥n de llamadas read () por n√∫mero de bytes <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:syscalls:sys_exit_read /pid == 18644/ { @bytes = hist(args-&gt;retval); }'</code> </pre> <br>  # 6. Rastreo din√°mico de contenido read () <br><br><pre> <code class="plaintext hljs">bpftrace -e 'kretprobe:vfs_read { @bytes = lhist(retval, 0, 2000, 200); }'</code> </pre> <br>  # 7. Tiempo empleado en llamadas read () <br><br><pre> <code class="plaintext hljs">bpftrace -e 'kprobe:vfs_read { @start[tid] = nsecs; } kretprobe:vfs_read /@start[tid]/ { @ns[comm] = hist(nsecs - @start[tid]); delete(@start[tid]); }'</code> </pre> <br>  # 8. Conteo de eventos a nivel de proceso <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:sched:sched* { @[name] = count(); } interval:s:5 { exit(); }'</code> </pre> <br>  # 9. Pilar de trabajo del kernel de perfilado <br><br><pre> <code class="plaintext hljs">bpftrace -e 'profile:hz:99 { @[stack] = count(); }'</code> </pre> <br>  # 10. Planificador de seguimiento <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:sched:sched_switch { @[stack] = count(); }'</code> </pre> <br>  # 11. Rastreo de bloqueo de E / S <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:block:block_rq_complete { @ = hist(args-&gt;nr_sector * 512); }'</code> </pre> <br>  Visite el sitio web de Brendan Gregg para averiguar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">qu√© tipo de salida pueden generar los equipos anteriores</a> . <br><br>  <b>Ejemplo de sintaxis de script y temporizaci√≥n de E / S</b> <br><br>  La cadena que se pasa a trav√©s del modificador '-e' es el contenido del script bpftrace.  La sintaxis en este caso es, condicionalmente, un conjunto de construcciones: <br><br><pre> <code class="plaintext hljs">&lt;event source&gt; /&lt;optional filter&gt;/ { &lt;program body&gt; }</code> </pre> <br>  Veamos el s√©ptimo ejemplo, sobre los tiempos de las operaciones de lectura del sistema de archivos: <br><br><pre> <code class="plaintext hljs">kprobe:vfs_read { @start[tid] = nsecs; } &lt;- 1 -&gt;&lt;-- 2 -&gt; &lt;---------- 3 ---------&gt;</code> </pre> <br>  <i>Trazamos</i> el evento desde el mecanismo <i>kprobe</i> , es decir, rastreamos el comienzo de la funci√≥n del n√∫cleo. <br>  La funci√≥n del kernel para el rastreo es <i>vfs_read</i> , esta funci√≥n se llama cuando el kernel realiza una operaci√≥n de lectura desde el sistema de archivos (VFS desde "Virtual FileSystem", abstracci√≥n del sistema de archivos dentro del kernel). <br><br>  Cuando <i>vfs_read</i> comienza a <i>ejecutarse</i> (es decir, antes de que la funci√≥n haya realizado un trabajo √∫til), se inicia el programa bpftrace.  Guarda la marca de tiempo actual (en nanosegundos) en una matriz asociativa global llamada <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">st</a> art</i> .  La clave es <i>tid</i> , una referencia al id del subproceso actual. <br><br><pre> <code class="plaintext hljs">kretprobe:vfs_read /@start[tid]/ { @ns[comm] = hist(nsecs - @start[tid]); delete(@start[tid]); } &lt;-- 1 --&gt; &lt;-- 2 -&gt; &lt;---- 3 ----&gt; &lt;----------------------------- 4 -----------------------------&gt;</code> </pre> <br>  1. <i>Trazamos</i> el evento desde el mecanismo <i>kretprobe</i> , que es similar a <i>kprobe</i> , excepto que se llama cuando la funci√≥n devuelve el resultado de su ejecuci√≥n. <br><br>  2. La funci√≥n del n√∫cleo para el rastreo es <i>vfs_read</i> . <br><br>  3. Este es un filtro opcional.  Comprueba si la hora de inicio se ha registrado previamente.  Sin este filtro, el programa se puede iniciar mientras lee y captura solo el final, lo que resulta en un tiempo <i>estimado nsecs - 0</i> , en lugar de <i>nsecs - start</i> . <br><br>  4. El cuerpo del programa. <br><br>  <i>nsecs - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">st</a> art [tid]</i> calcula cu√°nto tiempo ha pasado desde el inicio de la funci√≥n vfs_read. <br>  <i>@ns [comm] = hist (...)</i> agrega los datos especificados al histograma bidimensional almacenado en <i>@ns</i> .  La tecla de <i>comunicaci√≥n se</i> refiere al nombre de la aplicaci√≥n actual.  Entonces tendremos un histograma comando por comando. <br><br>  <i>delete (...)</i> elimina la hora de inicio de la matriz asociativa, porque ya no la necesitamos. <br><br>  Esta es la conclusi√≥n final.  Tenga en cuenta que todos los histogramas se muestran autom√°ticamente.  No se requiere el uso expl√≠cito del comando print histogram.  <i>@ns</i> no es una variable especial, por lo que el histograma no se muestra por eso. <br><br><pre> <code class="plaintext hljs">@ns[snmp-pass]: [0, 1] 0 | | [2, 4) 0 | | [4, 8) 0 | | [8, 16) 0 | | [16, 32) 0 | | [32, 64) 0 | | [64, 128) 0 | | [128, 256) 0 | | [256, 512) 27 |@@@@@@@@@ | [512, 1k) 125 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ | [1k, 2k) 22 |@@@@@@@ | [2k, 4k) 1 | | [4k, 8k) 10 |@@@ | [8k, 16k) 1 | | [16k, 32k) 3 |@ | [32k, 64k) 144 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@| [64k, 128k) 7 |@@ | [128k, 256k) 28 |@@@@@@@@@@ | [256k, 512k) 2 | | [512k, 1M) 3 |@ | [1M, 2M) 1 | |</code> </pre> <br><br>  <b>Ejemplo de sensor de USDT</b> <br><br>  Tomemos este c√≥digo C y gu√°rdelo en el archivo <i>tracetest.c</i> : <br><br><pre> <code class="plaintext hljs">#include &lt;sys/sdt.h&gt; #include &lt;sys/time.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; static long myclock() { struct timeval tv; gettimeofday(&amp;tv, NULL); DTRACE_PROBE1(tracetest, testprobe, tv.tv_sec); return tv.tv_sec; } int main(int argc, char **argv) { while (1) { myclock(); sleep(1); } return 0; }</code> </pre> <br>  Este programa se ejecuta sin cesar llamando a <i>myclock ()</i> una vez por segundo.  <i>myclock ()</i> consulta la hora actual y devuelve el n√∫mero de segundos desde el comienzo de la era. <br><br>  La llamada a <i>DTRACE_PROBE1</i> aqu√≠ define un punto de rastreo est√°tico USDT. <br><br><ul><li>  La macro <i>DTRACE_PROBE1</i> se toma de <i>sys / sdt.h.</i>  La macro oficial de USDT, que hace lo mismo, se llama <i>STAP_PROBE1</i> (STAP de SystemTap, que fue el primer mecanismo de Linux admitido en USDT).  Pero dado que USDT es compatible con los sensores de espacio de usuario DTrace, <i>DTRACE_PROBE1</i> es solo una referencia a <i>STAP_PROBE1</i> . </li><li>  El primer par√°metro es el nombre del proveedor.  Creo que este es un vestigio sobrante de DTrace, porque bpftrace no parece estar haciendo nada √∫til con √©l.  Sin embargo, hay un matiz ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">que descubr√≠ al depurar el problema en la aplicaci√≥n 328</a> ): el nombre del proveedor debe ser id√©ntico al nombre del archivo binario de la aplicaci√≥n; de lo contrario, bpftrace no podr√° encontrar el punto de rastreo. </li><li>  El segundo par√°metro es el nombre del punto de rastreo. </li><li>  Cualquier par√°metro adicional es el contexto proporcionado por los desarrolladores.  El n√∫mero <i>1</i> en <i>DTRACE_PROBE1</i> significa que queremos pasar un par√°metro adicional. </li></ul><br>  Asegur√©monos de que sys / sdt.h est√© disponible para nosotros, y armemos el programa: <br><br><pre> <code class="plaintext hljs">sudo apt install systemtap-sdt-dev gcc tracetest.c -o tracetest -Wall -g</code> </pre> <br>  Le indicamos a bpftrace que muestre el PID y "el tiempo es [n√∫mero]" cada <i>vez que se</i> alcanza la <i>prueba de prueba</i> : <br><br><pre> <code class="plaintext hljs">sudo bpftrace -e 'usdt:/full-path-to/tracetest:testprobe { printf("%d: time is %d\n", pid, arg0); }'</code> </pre> <br>  Bpftrace contin√∫a funcionando mientras presionamos Ctrl-C.  Por lo tanto, abra una nueva terminal y ejecute <i>tracetest</i> all√≠: <br><br>  # En la nueva terminal <br>  ./tracetest <br><br>  Regrese a la primera terminal con bpftrace, all√≠ deber√≠a ver algo como: <br><br><pre> <code class="plaintext hljs">Attaching 1 probe... 30909: time is 1549023215 30909: time is 1549023216 30909: time is 1549023217 ... ^C</code> </pre> <br>  <b>Ejemplo de asignaci√≥n de memoria usando glibc ptmalloc</b> <br><br>  Utilizo bpftrace para entender por qu√© Ruby usa tanta memoria.  Y como parte de mi investigaci√≥n, necesito comprender c√≥mo el asignador de memoria de glibc usa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">regiones de memoria</a> . <br><br>  Para optimizar el rendimiento multin√∫cleo, el asignador de memoria glibc asigna varias "√°reas" del sistema operativo.  Cuando la aplicaci√≥n solicita la asignaci√≥n de memoria, el asignador selecciona un √°rea que no est√° en uso y marca parte de esta √°rea como "usada".  Dado que los subprocesos utilizan diferentes √°reas, se reduce el n√∫mero de bloqueos, lo que conduce a un rendimiento mejorado de subprocesos m√∫ltiples. <br><br>  Pero este enfoque genera mucha basura, y parece que un consumo de memoria tan alto en Ruby se debe precisamente a eso.  Para comprender mejor la naturaleza de esta basura, me preguntaba: ¬øqu√© significa "elegir un √°rea que no se utiliza"?  Esto puede significar uno de: <br><br><ul><li>  Cada vez que <i>se</i> llama a <i>malloc ()</i> , el asignador recorre en iteraci√≥n todas las √°reas y encuentra la que no est√° bloqueada actualmente.  Y solo si est√°n todos bloqueados, intentar√° crear uno nuevo. </li><li>  La primera vez que <i>se</i> llama a <i>malloc ()</i> en un subproceso espec√≠fico (o cuando se inicia el subproceso), el asignador seleccionar√° el que no est√° bloqueado actualmente.  Y si todos est√°n bloqueados, intentar√° crear uno nuevo. </li><li>  La primera vez que <i>se</i> llama a <i>malloc ()</i> en un subproceso espec√≠fico (o cuando se inicia el subproceso), el asignador intentar√° crear una nueva regi√≥n, independientemente de si hay regiones desbloqueadas.  Solo si no se puede crear un √°rea nueva (por ejemplo, cuando se agota el l√≠mite), reutilizar√° la existente. </li><li>  Probablemente hay m√°s opciones que no he considerado. </li></ul><br>  No hay una respuesta espec√≠fica en la documentaci√≥n, cu√°l de estas caracter√≠sticas le permite seleccionar un √°rea que no se utiliza.  Estudi√© el c√≥digo fuente de glibc, que sugiri√≥ que la opci√≥n 3 podr√≠a hacer esto.  Pero quer√≠a verificar experimentalmente que interpretaba el c√≥digo fuente correctamente, sin la necesidad de depurar el c√≥digo en glibc. <br><br>  Aqu√≠ est√° la funci√≥n del asignador de memoria glibc que crea una nueva √°rea.  Pero puede llamarlo solo despu√©s de verificar el l√≠mite. <br><br><pre> <code class="plaintext hljs">static mstate _int_new_arena(size_t size) { mstate arena; size = calculate_how_much_memory_to_ask_from_os(size); arena = do_some_stuff_to_allocate_memory_from_os(); LIBC_PROBE(memory_arena_new, 2, arena, size); do_more_stuff(); return arena; }</code> </pre> <br>  ¬øPuedo usar <i>uprobes</i> para rastrear la funci√≥n <i>_int_new_arena</i> ?  Lamentablemente no.  Por alguna raz√≥n, este s√≠mbolo no est√° disponible en glibc Ubuntu 18.04.  Incluso despu√©s de instalar s√≠mbolos de depuraci√≥n. <br><br>  Afortunadamente, hay un sensor USDT en esta funci√≥n.  <i>LIBC_PROBE</i> es un macro alias para <i>STAP_PROBE</i> . <br>  El nombre del proveedor es libc. <br>  El nombre del sensor es memory_arena_new. <br>  El n√∫mero 2 significa que hay 2 argumentos adicionales especificados por el desarrollador. <br>  arena es la direcci√≥n del √°rea que se extrajo del sistema operativo, y el tama√±o es su tama√±o. <br><br>  Antes de que podamos usar este sensor, debemos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">solucionar el problema 328</a> .  Necesitamos crear un enlace simb√≥lico con glibc en alg√∫n lugar con el nombre <i>libc</i> , porque bpftrace espera que el nombre de la biblioteca (que de lo contrario ser√≠a <i>libc-2.27.so</i> ) sea id√©ntico al nombre del proveedor <i>(libc)</i> . <br><br><pre> <code class="plaintext hljs">ln -s /lib/x86_64-linux-gnu/libc-2.27.so /tmp/libc</code> </pre> <br>  Ahora le indicamos a bpftrace que se conecte al sensor memory_arena_new del USDT, cuyo nombre de proveedor es <i>libc</i> : <br><br><pre> <code class="plaintext hljs">sudo bpftrace -e 'usdt:/tmp/libc:memory_arena_new { printf("PID %d: created new arena at %p, size %d\n", pid, arg0, arg1); }'</code> </pre> <br>  En otra terminal, ejecutaremos Ruby, que crear√° tres hilos que no hacen nada y terminan en un segundo.  Debido al bloqueo global del int√©rprete, Ruby <i>malloc ()</i> no debe ser llamado en paralelo por diferentes hilos. <br><br><pre> <code class="plaintext hljs">ruby -e '3.times { Thread.new { } }; sleep 1'</code> </pre> <br>  Volviendo a la terminal con bpftrace, veremos: <br><br><pre> <code class="plaintext hljs">Attaching 1 probe... PID 431: created new arena at 0x7f40e8000020, size 576 PID 431: created new arena at 0x7f40e0000020, size 576 PID 431: created new arena at 0x7f40e4000020, size 576</code> </pre> <br>  ¬°Aqu√≠ est√° la respuesta a nuestra pregunta!  Cada vez que crea un nuevo hilo en Ruby, glibc resalta un √°rea nueva independientemente de la competitividad. <br><br>  <b>¬øQu√© puntos de rastreo est√°n disponibles?</b>  <b>¬øQu√© debo rastrear?</b> <br><br>  Puede enumerar todos los puntos de rastreo de hardware, temporizadores, kprobe y kernel est√°tico ejecutando el comando: <br><br><pre> <code class="plaintext hljs">sudo bpftrace -l</code> </pre> <br>  Puede enumerar todos los puntos de rastreo de uprobe (caracteres de funci√≥n) de una aplicaci√≥n o biblioteca haciendo: <br><br><pre> <code class="plaintext hljs">nm /path-to-binary</code> </pre> <br>  Puede enumerar todos los puntos de rastreo de la aplicaci√≥n o biblioteca USDT ejecutando el siguiente comando: <br><br><pre> <code class="plaintext hljs">/usr/share/bcc/tools/tplist -l /path-to/binary</code> </pre> <br>  Con respecto a qu√© puntos de rastreo usar: no estar√≠a de m√°s entender el c√≥digo fuente de lo que va a rastrear.  Te recomiendo que estudies el c√≥digo fuente. <br><br>  <b>Consejo: un formato estructural para puntos de rastreo en el n√∫cleo</b> <br><br>  Aqu√≠ hay un consejo √∫til sobre los puntos de rastreo del n√∫cleo.  ¬°Puede verificar qu√© campos de argumento est√°n disponibles leyendo el archivo / sys / kernel / debug / tracing / events! <br><br>  Por ejemplo, suponga que desea rastrear llamadas a <i>madvise (..., MADV_DONTNEED)</i> : <br><br><pre> <code class="plaintext hljs">sudo bpftrace -l | grep madvise</code> </pre> <br>  - nos dir√° que podemos usar tracepoint: syscalls: sys_enter_madvise. <br><br><pre> <code class="plaintext hljs">sudo cat /sys/kernel/debug/tracing/events/syscalls/sys_enter_madvise/format</code> </pre> <br>  - nos dar√° la siguiente informaci√≥n: <br><br><pre> <code class="plaintext hljs">name: sys_enter_madvise ID: 569 format: field:unsigned short common_type; offset:0; size:2; signed:0; field:unsigned char common_flags; offset:2; size:1; signed:0; field:unsigned char common_preempt_count; offset:3; size:1; signed:0; field:int common_pid; offset:4; size:4; signed:1; field:int __syscall_nr; offset:8; size:4; signed:1; field:unsigned long start; offset:16; size:8; signed:0; field:size_t len_in; offset:24; size:8; signed:0; field:int behavior; offset:32; size:8; signed:0; print fmt: "start: 0x%08lx, len_in: 0x%08lx, behavior: 0x%08lx", ((unsigned long)(REC-&gt;start)), ((unsigned long)(REC-&gt;len_in)), ((unsigned long)(REC-&gt;behavior))</code> </pre> <br>  Firma de Madvise seg√∫n el manual: <i>(void * addr, size_t length, int advice)</i> .  ¬°Los √∫ltimos tres campos de esta estructura corresponden a estos par√°metros! <br><br>  ¬øCu√°l es el significado de MADV_DONTNEED?  A juzgar por grep MADV_DONTNEED / usr / include, es igual a 4: <br><br><pre> <code class="plaintext hljs">/usr/include/x86_64-linux-gnu/bits/mman-linux.h:80:# define MADV_DONTNEED 4 /* Don't need these pages. */</code> </pre> <br>  Entonces nuestro equipo bpftrace se convierte en: <br><br><pre> <code class="plaintext hljs">sudo bpftrace -e 'tracepoint:syscalls:sys_enter_madvise /args-&gt;behavior == 4/ { printf("madvise DONTNEED called\n"); }'</code> </pre> <br><h3>  Conclusi√≥n </h3><br>  ¬°Bpftrace es maravilloso!  Bpftrace es el futuro! <br><br>  Si desea saber m√°s sobre √©l, le recomiendo que se familiarice con <a href="">su liderazgo</a> , as√≠ como con la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primera publicaci√≥n de 2019</a> en el blog de Brendan Gregg. <br><br>  Buena depuraci√≥n! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/441258/">https://habr.com/ru/post/441258/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441244/index.html">La vulnerabilidad de WinRar, sin cerrar durante 19 a√±os, le permite colocar el archivo desempaquetado en cualquier lugar</a></li>
<li><a href="../441248/index.html">Rusia ocup√≥ el noveno lugar en la clasificaci√≥n global de SSL, por delante de China, Dinamarca y Suiza</a></li>
<li><a href="../441250/index.html">Inicio r√°pido: Ir + Apache Kafka + Redis</a></li>
<li><a href="../441252/index.html">"Art√≠culo de mamada": los cient√≠ficos procesaron 109 horas de sexo oral para desarrollar una IA que apesta a un miembro</a></li>
<li><a href="../441254/index.html">Seminario "Por qu√© nos pusimos en contacto con Kubernetes y lo que obtenemos de √©l", 28 de febrero, Mosc√∫</a></li>
<li><a href="../441260/index.html">C√≥mo ayudaron los gr√°ficos de redes neuronales</a></li>
<li><a href="../441262/index.html">Las tareas simples y largas eliminan a los candidatos mejor que los cortos y complejos</a></li>
<li><a href="../441264/index.html">Gu√≠a del usuario de Kibana. Visualizaci√≥n. Parte 2</a></li>
<li><a href="../441266/index.html">C√≥mo funciona el marco tiOPF para delphi / lazarus. Plantilla de visitante</a></li>
<li><a href="../441268/index.html">Ceedling + Eclipse o pruebas unitarias para microcontroladores</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>