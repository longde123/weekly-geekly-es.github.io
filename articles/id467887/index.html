<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤳🏻 📑 👢 Refleksi Caustic Realistis 👩🏿‍🤝‍👨🏻 🧑🏻 📆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sebagian besar seniman teknis pada titik tertentu dalam karier mereka mencoba membuat refleksi yang masuk akal tentang kaustik. Jika Anda seorang peng...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Refleksi Caustic Realistis</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467887/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/hd/an/yo/hdanyowyfitt8zvoj7vaeu3drdi.gif"></div><br>  Sebagian besar seniman teknis pada titik tertentu dalam karier mereka mencoba membuat refleksi yang masuk akal tentang kaustik.  Jika Anda seorang pengembang game, maka salah satu alasan utama untuk membaca Twitter adalah aliran inspirasi yang tak ada habisnya yang dapat Anda tarik darinya.  Beberapa hari yang lalu, Florian Gelzenlichter ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer">kolyaTQ</a> di twitter) memposting GIF dari efek kaustik yang dibuat di Unity menggunakan shader.  Posting (disajikan di bawah) dengan cepat memperoleh 1,5 ribu suka, yang menunjukkan minat yang tulus pada jenis konten ini. <br><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1165251296720576512"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  Meskipun saya biasanya lebih tertarik pada serangkaian artikel yang lebih panjang dan rumit secara teknis (misalnya, tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer">hamburan cahaya atmosfer volumetrik</a> [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terjemahan</a> di Habré] dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer">kinematika terbalik</a> [terjemahan bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kedua</a> di Habré), saya tidak bisa menahan godaan untuk menulis tutorial singkat dan lucu) tentang efek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer">Florian</a> . <br><br>  Di akhir artikel ini ada tautan untuk mengunduh paket Unity dan semua aset yang diperlukan. <br><a name="habracut"></a><br><h2>  Apa itu kaustik? </h2><br>  Anda mungkin tidak <em>menyadari</em> konsep <em>kaustik</em> , meskipun Anda mengalami efek ini setiap hari.  Caustics adalah pantulan cahaya yang disebabkan oleh permukaan melengkung.  Dalam kasus umum, permukaan melengkung dapat berperilaku seperti lensa, memfokuskan cahaya di beberapa titik dan menyebarkannya di tempat lain.  Media yang paling umum memberikan efek seperti itu adalah kaca dan air, yang menghasilkan apa yang disebut <strong>gelombang kaustik</strong> (lihat di bawah). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2cf/dcc/0c7/2cfdcc0c727f1637ffc5c360fd816a8f.jpg"></div><br>  Caustics dapat mengambil bentuk lain.  Pelangi, misalnya, adalah fenomena optik yang terjadi ketika cahaya dibiaskan dalam tetesan hujan.  Karena itu, sebenarnya, itu pedas. <br><br><h2>  Efek anatomi </h2><br>  Ciri khas dari gelombang kaustik adalah cara bergeraknya;  kemungkinan besar Anda melihatnya jika Anda pernah melihat bagian bawah kolam.  Membuat kembali kaustik asli sangat mahal karena membutuhkan simulasi banyak sinar. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer">Florian</a> berhasil menciptakan efek yang masuk akal, dimulai dengan tekstur kaustik tunggal.  Untuk membuat tutorial saya, saya menggunakan tekstur yang ditunjukkan di bawah ini, diambil dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer">OpenGameArt</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3a/418/def/c3a418defd9ff05890f63c4c35e728ad.gif" width="250" height="250"></div><br>  Sifat penting yang memungkinkan efek ini terwujud adalah bahwa pola kaustik yang diperlihatkan di atas <strong>mulus</strong> .  Ini berarti bahwa Anda dapat menempatkan dua gambar di samping satu sama lain dan tidak akan ada jahitan yang terlihat di antara mereka.  Karena kita ingin menggunakan efek ini pada permukaan besar, penting bagi kita untuk memiliki kesempatan untuk meregangkan tekstur ini tanpa air mata yang dapat menghancurkan ilusi. <br><br>  Setelah menerima tekstur, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer">Florian</a> menyarankan untuk mengambil tiga langkah: <br><br><ul><li>  Terapkan pola kaustik dua kali ke permukaan model, setiap kali menggunakan ukuran dan kecepatan yang berbeda </li><li> Campurkan dua pola dengan operator <code>min</code> </li><li>  Pisahkan saluran RGB saat pengambilan sampel. </li></ul><br>  Mari kita lihat bagaimana Anda dapat menerapkan setiap langkah di Unity. <br><br><h2>  Penciptaan Shader </h2><br>  Langkah pertama adalah membuat shader baru.  Karena efek ini kemungkinan akan digunakan dalam game 3D yang juga memiliki pencahayaan nyata, yang terbaik adalah memulai dengan <strong>shader permukaan</strong> .  Shader permukaan adalah salah satu dari banyak jenis shader yang didukung oleh Unity (seperti <strong>vertex dan shader fragmen</strong> untuk bahan yang tidak diterangi, <strong>shader layar</strong> untuk efek pasca-pemrosesan, dan <strong>shader komputasi</strong> untuk simulasi di luar layar). <br><br>  Shader permukaan baru hanya memiliki beberapa fitur.  Untuk membuat efek ini, kita perlu mentransfer informasi ke shader.  Yang pertama adalah tekstur kaustik.  Kedua, ini adalah parameter yang digunakan untuk mengukur dan mengimbanginya. <br><br>  Mari kita membuat dua <em>properti shader</em> : <br><br><pre> <code class="cpp hljs">Properties { ... [Header(Caustics)] _CausticsTex(<span class="hljs-string"><span class="hljs-string">"Caustics (RGB)"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-comment"><span class="hljs-comment">// Tiling X, Tiling Y, Offset X, Offset Y _Caustics_ST("Caustics ST", Vector) = (1,1,0,0) }</span></span></code> </pre> <br>  dan <em>variabel Cg yang</em> sesuai: <br><br><pre> <code class="cpp hljs">sampler2D _CausticsTex; float4 _Caustics_ST;</code> </pre> <br>  <em>Properti shader</em> sesuai dengan bidang yang ditampilkan di Inspektur Material Persatuan.  <em>Variabel Cg yang</em> sesuai adalah nilai-nilai itu sendiri, yang dapat digunakan dalam kode shader. <br><br>  Seperti yang Anda lihat dari kode di atas, <code>_Caustics_ST</code> adalah <code>float4</code> , artinya berisi empat nilai.  Kami akan menggunakannya untuk mengontrol pengambilan sampel tekstur kaustik.  Yaitu: <br><br><ul><li>  <code>_Caustics_ST.x</code> : skala tekstur kaustik sepanjang sumbu X; </li><li>  <code>_Caustics_ST.y</code> : skala tekstur kaustik sepanjang sumbu Y; </li><li>  <code>_Caustics_ST.z</code> : perpindahan tekstur kaustik di sepanjang sumbu X; </li><li>  <code>_Caustics_ST.w</code> : perpindahan tekstur kaustik di sepanjang sumbu Y; </li></ul><br><div class="spoiler">  <b class="spoiler_title">Mengapa variabel bernama _Caustics_ST?</b> <div class="spoiler_text">  Jika Anda sudah memiliki sedikit pengalaman bekerja dengan shader, maka Anda sudah melihat properti lain yang diakhiri dengan akhiran <code>_ST</code> .  Di Unity, <code>_ST</code> dapat digunakan untuk menambahkan informasi tambahan tentang bagaimana tekstur sampel. <br><br>  Misalnya, jika Anda membuat variabel Cg <code>_MainTex_ST</code> , maka Anda dapat menggunakannya untuk mengatur ukuran dan mengimbangi saat menerapkan tekstur ke model. <br><br>  Biasanya variabel <code>_ST</code> tidak memerlukan properti karena mereka ditampilkan secara otomatis di inspektur.  Namun, dalam kasus khusus ini, kami tidak dapat mengandalkan ini karena kami perlu sampel tekstur dua kali, setiap kali dengan skala dan offset yang berbeda.  Di masa depan, kita perlu menduplikasi variabel ini menjadi dua variabel yang berbeda. </div></div><br><h2>  Tekstur pengambilan sampel </h2><br>  Setiap <em>permukaan shader</em> berisi fungsi, biasa disebut <code>surf</code> , yang digunakan untuk menentukan warna setiap piksel yang diberikan.  Fungsi <code>surf</code> "standar" terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutputStandard o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Albedo comes from a texture tinted by color fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color; o.Albedo = c.rgb; // Metallic and smoothness come from slider variables o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</span></span></code> </pre> <br>  Warna akhir ditentukan oleh jumlah bidang yang shader harus menginisialisasi dan kembali dalam struktur yang disebut <code>SurfaceOutputStandard</code> .  Kita perlu mengubah <code>Albedo</code> , yang kira-kira cocok dengan warna objek yang diterangi oleh cahaya putih. <br><br>  Di shader permukaan yang baru dibuat, Albedo diambil dari tekstur yang disebut <code>_MainTex</code> .  Karena efek kaustik ditumpangkan di atas tekstur yang ada, kita harus melakukan pengambilan sampel tambahan tekstur di <code>_CausticsTex</code> . <br><br>  Teknik yang disebut <strong>hamparan UV</strong> memungkinkan Anda memahami bagian mana dari tekstur yang perlu disampel, tergantung pada bagian geometri mana yang perlu dirender.  Ini dilakukan dengan menggunakan <code>uv_MainTex</code> - variabel <code>float2</code> , disimpan di setiap vertex dari model 3D dan menunjukkan koordinat tekstur. <br><br>  Gagasan kami adalah menggunakan <code>_Caustics_ST</code> untuk menskala dan mengimbangi <code>uv_MainTex</code> untuk meregangkan dan memindahkan tekstur kaustik ke seluruh model. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutputStandard o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Albedo comes from a texture tinted by color fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color; o.Albedo = c.rgb; // Caustics sampling fixed2 uv = IN.uv_MainTex * _Caustics_ST.xy + _Caustics_ST.zw; fixed3 caustics = tex2D(_CausticsTex, uv).rgb; // Add o.Albedo.rgb += caustics; // Metallic and smoothness come from slider variables o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Apa yang terjadi jika Albedo melebihi 1?</b> <div class="spoiler_text">  Dalam kode di atas, kami menambahkan dua tekstur.  Warna biasanya antara <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>0</mn></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="2.074ex" viewBox="0 -772.3 500.5 892.8" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/467887/&amp;usg=ALkJrhj2nXRMWaAvd7dFZHTULNApkkgkqg#MJMAIN-30" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>0</mn></math></span></span><script type="math/tex" id="MathJax-Element-1"> 0 </script>  sebelumnya <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>1</mn></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="2.074ex" viewBox="0 -772.3 500.5 892.8" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/467887/&amp;usg=ALkJrhj2nXRMWaAvd7dFZHTULNApkkgkqg#MJMAIN-31" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-2"> 1 </script>  Namun, tidak ada jaminan bahwa sebagai hasilnya, beberapa nilai tidak akan melebihi interval ini. <br><br>  Pada shader lama, ini bisa menyebabkan masalah.  Ini sebenarnya <em>fitur</em> .  Jika nilai warna piksel melebihi satu, maka ini artinya pengaruhnya harus "menyebar" di luar batas negara dan memengaruhi piksel yang berdekatan. <br><br>  Inilah yang terjadi ketika refleksi specular yang sangat cerah diperoleh.  Namun, efek ini seharusnya tidak dibuat hanya oleh shader permukaan.  Agar efeknya berfungsi, kamera harus mengaktifkan <strong>HDR</strong> .  Properti ini adalah singkatan dari <strong>High Dynamic Range</strong> ;  itu memungkinkan nilai warna melebihi <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>1</mn></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="2.074ex" viewBox="0 -772.3 500.5 892.8" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/467887/&amp;usg=ALkJrhj2nXRMWaAvd7dFZHTULNApkkgkqg#MJMAIN-31" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-3"> 1 </script>  .  Juga, untuk mengaburkan jumlah warna yang berlebihan pada piksel tetangga, efek pasca pemrosesan diperlukan. <br><br>  Unity memiliki tumpukan post-processing sendiri, yang memiliki filter bloom yang melakukan hal itu.  Anda dapat membaca lebih lanjut tentang ini di Blog Persatuan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer">PostFX v2 - Visual luar biasa, ditingkatkan</a> . </div></div><br>  Hasil awal ditunjukkan di bawah ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9d5/16f/1de/9d516f1de5a00d84b60e95674cf35650.png" width="843" height="406"></div><br><h2>  Kaustik animasi </h2><br>  Salah satu fitur terpenting dari kaustik adalah bagaimana ia bergerak.  Saat ini, mereka hanya diproyeksikan secara statis ke permukaan model sebagai tekstur kedua. <br><br>  Animasi materi dalam shader dapat diimplementasikan menggunakan properti Unity <code>_Time</code> .  Ini dapat digunakan untuk mengakses waktu gim saat ini, yaitu, menambah waktu ke persamaan. <br><br>  Cara termudah adalah dengan hanya mengimbangi tekstur berdasarkan waktu saat ini. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Caustics UV fixed2 uv = IN.uv_MainTex * _Caustics_ST.xy + _Caustics_ST.zw; uv += _CausticsSpeed * _Time.y; // Sampling fixed3 caustics = tex2D(_CausticsTex, uv).rgb; // Add o.Albedo.rgb += caustics;</span></span></code> </pre> <br>  Bidang <code>_Time.y</code> berisi waktu pemutaran saat ini dalam <em>detik</em> .  Jika refleksi bergerak terlalu cepat, Anda dapat melipatgandakannya dengan faktor.  Untuk ini, variabel <code>_CausticsSpeed</code> dari tipe <code>float2</code> digunakan dalam kode yang disajikan di atas. <br><br>  Anda mungkin perlu menggetarkan tekstur kaustik dalam sinusoid untuk keperluan Anda.  Penting untuk dipahami di sini bahwa tidak ada cara standar untuk menyadari efeknya.  Tergantung pada kebutuhan Anda, Anda dapat membuat pantulan kaustik bergerak sangat berbeda. <br><br>  Hasil yang ditunjukkan di bawah ini masih cukup biasa-biasa saja.  Ini normal: kita masih harus melakukan banyak hal untuk membuat pantulan terlihat indah. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b6e/37d/d6b/b6e37dd6b3d6e172c342c7902845f60d.gif"></div><br><h2>  Pengambilan sampel berganda </h2><br>  Efeknya menjadi hidup jika Anda mencicipi tekstur kaustik tidak hanya sekali, tetapi dua kali.  Jika Anda meletakkannya di atas satu sama lain dan memindahkannya dengan kecepatan yang berbeda, hasilnya akan sangat berbeda. <br><br>  Pertama, kami menduplikasi properti <code>_Caustics_ST</code> dan <code>_CausticsSpeed</code> sehingga sampel dari dua tekstur memiliki skala, perpindahan, dan kecepatan yang berbeda: <br><br><pre> <code class="cpp hljs">[Header(Caustics)] _CausticsTex(<span class="hljs-string"><span class="hljs-string">"Caustics (RGB)"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-comment"><span class="hljs-comment">// Tiling X, Tiling Y, Offset X, Offset Y _Caustics1_ST("Caustics 1 ST", Vector) = (1,1,0,0) _Caustics2_ST("Caustics 1 ST", Vector) = (1,1,0,0) // Speed X, Speed Y _Caustics1_Speed("Caustics 1 Speed", Vector) = (1, 1, 0 ,0) _Caustics2_Speed("Caustics 2 Speed", Vector) = (1, 1, 0 ,0)</span></span></code> </pre> <br>  Sekarang kami memiliki dua sampel kaustik, mereka dapat dicampur menggunakan operator <code>min</code> .  Jika Anda hanya mengambil nilai rata-rata, hasilnya tidak akan terlalu bagus. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Caustics samplings fixed3 caustics1 = ... fixed3 caustics2 = ... // Blend o.Albedo.rgb += min(caustics1, caustics2);</span></span></code> </pre> <br>  Perubahan kecil seperti itu membuat perbedaan besar: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ea/c9d/444/3eac9d4448485555980e10424e3f4ad5.gif"></div><br>  Agar kode tetap cantik, Anda juga dapat membungkus kode sampling kaustik dalam fungsi Anda sendiri: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Caustics fixed3 c1 = causticsSample(_CausticsTex, IN.uv_MainTex, _Caustics1_ST, _Caustics1_Speed); fixed3 c2 = causticsSample(_CausticsTex, IN.uv_MainTex, _Caustics2_ST, _Caustics2_Speed); o.Albedo.rgb += min(c1, c2);</span></span></code> </pre> <br><h2>  Pemisahan RGB </h2><br>  Agar pantulan kaustik terlihat bagus, Anda perlu melakukan trik terakhir.  Melewati irisan, cahaya dengan panjang gelombang berbeda dibiaskan secara berbeda.  Ini berarti bahwa ketika bergerak melalui air, cahaya dapat "terpecah" menjadi warna yang berbeda. <br><br>  Untuk mensimulasikan efek ini, kita dapat membagi masing-masing sampel kaustik menjadi tiga, satu untuk setiap saluran warna.  Dengan mengambil sampel saluran merah, hijau, dan biru dengan sedikit bias, kami mendapatkan ketidakcocokan warna. <br><br>  Mari kita mulai dengan menambahkan properti <code>_SplitRGB</code> , yang menunjukkan kekuatan efek <code>_SplitRGB</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Caustics UV fixed2 uv = IN.uv_MainTex * _Caustics_ST.xy + _Caustics_ST.zw; uv += _CausticsSpeed * _Time.y; // RGB split fixed s = _SplitRGB; fixed r = tex2D(tex, uv + fixed2(+s, +s)).r; fixed g = tex2D(tex, uv + fixed2(+s, -s)).g; fixed b = tex2D(tex, uv + fixed2(-s, -s)).b; fixed3 caustics = fixed3(r, g, b);</span></span></code> </pre> <br>  Jumlah offset saluran RGB dapat dipilih secara sewenang-wenang, tetapi bahkan dengan offset sederhana ini, gambar yang sangat meyakinkan diperoleh: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a96/ccc/bd8/a96cccbd861252130d289d9362ef0ec0.gif"></div><br><h2>  Kesimpulan dan unduhan </h2><br>  Jika Anda tertarik mempelajari cara membuat tekstur kaustik mulus, maka Anda harus membaca artikel menarik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer">Tekstur Kaustik Berkala</a> . <br><br>  Sementara itu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer">Florian</a> terus bekerja pada shader kaustik dan telah membuat beberapa perbaikan yang cukup menarik yang bisa dilihat. <br><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-1" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1167866285369131008"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  Paket lengkap untuk tutorial ini tersedia di Patreon, termasuk semua aset yang diperlukan untuk membuat ulang teknik ini.  Paket ini diekspor dari Unity 2019.2 dan membutuhkan Postprocessing Stack v2. <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aset Standar</a> : Hanya File <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aset yang dibayar</a> : adegan penuh, termasuk tekstur dan bahan kaustik. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467887/">https://habr.com/ru/post/id467887/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467875/index.html">Jangan malu, minus</a></li>
<li><a href="../id467877/index.html">Android untuk insinyur radio (dan tidak hanya)</a></li>
<li><a href="../id467881/index.html">Tutu.ru backend meetup</a></li>
<li><a href="../id467883/index.html">Kubernetes 1.16 - cara memutakhirkan dan tidak merusak apa pun</a></li>
<li><a href="../id467885/index.html">Tambang produk dan segmen</a></li>
<li><a href="../id467891/index.html">FAQ tentang tanda tangan cloud [elektronik]</a></li>
<li><a href="../id467893/index.html">Hanya pembungkus Qt lain untuk gRPC dan protobuf</a></li>
<li><a href="../id467895/index.html">Pola apa yang ditemukan jaringan saraf?</a></li>
<li><a href="../id467897/index.html">Alat uji otomatis, integrasi Yandex Mapkit 3, desain keren, dan pendekatan UI Berbasis Server - Pengumuman mitap Android</a></li>
<li><a href="../id467901/index.html">Sanggah empat stereotip tentang bahasa pemrograman Rust</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>