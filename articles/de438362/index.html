<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò¢ ü§¨ ü¶â Wie wir die Konfiguration unserer Services von XML nach YAML √ºbersetzt haben ü§Ωüèø üëµüèª üë®üèª‚Äç‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hintergrund 
 Unser Unternehmen hat unter anderem mehrere Services (genauer gesagt - 12) entwickelt, die als Backend unserer Systeme dienen. Jeder der...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie wir die Konfiguration unserer Services von XML nach YAML √ºbersetzt haben</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/utex/blog/438362/"><h2>  Hintergrund </h2><br>  Unser Unternehmen hat unter anderem mehrere Services (genauer gesagt - 12) entwickelt, die als Backend unserer Systeme dienen.  Jeder der Dienste ist ein Windows-Dienst und f√ºhrt seine spezifischen Aufgaben aus. <br><br>  Ich m√∂chte alle diese Dienste auf * nix-OS √ºbertragen.  Verlassen Sie dazu den Wrapper in Form von Windows-Diensten und wechseln Sie von .NET Framework zu .NET Standard. <br><br>  Die letzte Anforderung f√ºhrt dazu, dass Legacy-Code entfernt werden muss, der in .NET Standard nicht unterst√ºtzt wird, einschlie√ülich  von der Unterst√ºtzung f√ºr die Konfiguration unserer Server √ºber XML, implementiert mit Klassen von System.Configuration.  Gleichzeitig wird das seit langem bestehende Problem behoben, das darin besteht, dass wir in XML-Konfigurationen von Zeit zu Zeit Fehler beim √Ñndern von Einstellungen gemacht haben (z. B. manchmal haben wir das schlie√üende Tag an der falschen Stelle platziert oder es √ºberhaupt vergessen), aber ein wunderbarer Leser von System.Xml-XML-Konfigurationen. XmlDocument verschluckt solche Konfigurationen stillschweigend und f√ºhrt zu einem v√∂llig unvorhersehbaren Ergebnis. <br><br>  Es wurde beschlossen, √ºber die trendige YAML auf Konfiguration umzusteigen.  Welche Probleme hatten wir und wie haben wir sie gel√∂st? In diesem Artikel. <br><a name="habracut"></a><br><h2>  Was haben wir? </h2><br><h3>  Wie lesen wir die Konfiguration aus XML? </h3><br>  Bei den meisten anderen Projekten lesen wir XML auf standardm√§√üige Weise. <br><br>  Jeder Dienst verf√ºgt √ºber eine Einstellungsdatei f√ºr .NET-Projekte mit dem Namen AppSettings.cs, die alle f√ºr den Dienst erforderlichen Einstellungen enth√§lt.  Ungef√§hr so: <br><br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">System.Configuration.SettingsProvider(typeof(PortableSettingsProvider))</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AppSettings</span></span> : <span class="hljs-title"><span class="hljs-title">IServerManagerConfigStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IWebSettingsStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IServerSettingsStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IGraphiteAddressStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IDatabaseConfigStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IBlackListStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IKeyCloackConfigFilePathProvider</span></span>, <span class="hljs-title"><span class="hljs-title">IPrometheusSettingsStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IMetricsConfig</span></span> { }</code> </pre> <br><br>  Eine √§hnliche Technik zum Trennen von Einstellungen in Schnittstellen macht es bequem, sie sp√§ter √ºber einen DI-Container zu verwenden. <br><br>  Die ganze Magie des Speicherns von Einstellungen ist in PortableSettingsProvider (siehe Klassenattribut) sowie in der Designer-Datei AppSettings.Designer.cs verborgen: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()</span></span>] [<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>::System.CodeDom.Compiler.GeneratedCodeAttribute(<span class="hljs-string"><span class="hljs-string">"Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator"</span></span>, <span class="hljs-string"><span class="hljs-string">"14.0.0.0"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AppSettings</span></span> : <span class="hljs-title"><span class="hljs-title">global</span></span>::<span class="hljs-title"><span class="hljs-title">System</span></span>.<span class="hljs-title"><span class="hljs-title">Configuration</span></span>.<span class="hljs-title"><span class="hljs-title">ApplicationSettingsBase</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> AppSettings defaultInstance = ((AppSettings)(<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>::System.Configuration.ApplicationSettingsBase.Synchronized(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AppSettings()))); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> AppSettings Default { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> defaultInstance; } } [<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>::System.Configuration.UserScopedSettingAttribute()] [<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>::System.Diagnostics.DebuggerNonUserCodeAttribute()] [<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>::System.Configuration.DefaultSettingValueAttribute(<span class="hljs-string"><span class="hljs-string">"35016"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ListenPort { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-string"><span class="hljs-string">"ListenPort"</span></span>])); } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-string"><span class="hljs-string">"ListenPort"</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } ...</code> </pre><br>  Wie Sie sehen k√∂nnen, sind hinter den Kulissen alle Eigenschaften verborgen, die wir der Serverkonfiguration hinzuf√ºgen, wenn wir sie √ºber den Einstellungsdesigner in Visual Studio bearbeiten. <br><br>  Unsere oben erw√§hnte PortableSettingsProvider-Klasse liest die XML-Datei direkt, und das Leseergebnis wird bereits in SettingsProvider verwendet, um Einstellungen in die AppSettings-Eigenschaften zu schreiben. <br><br>  Ein Beispiel f√ºr die XML-Konfiguration, die wir lesen (die meisten Einstellungen sind aus Sicherheitsgr√ºnden ausgeblendet): <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">configuration</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">configSections</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">sectionGroup</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"userSettings"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"System.Configuration.UserSettingsGroup"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">section</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"MetricServer.Properties.Settings"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"System.Configuration.ClientSettingsSection"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">sectionGroup</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">configSections</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">userSettings</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">MetricServer.Properties.Settings</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">setting</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"MCXSettings"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">serializeAs</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"String"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>Inactive, ChartLen: 1000, PrintLen: 50, UseProxy: False<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">setting</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">setting</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"KickUnknownAfter"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">serializeAs</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"String"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>00:00:10<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">setting</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">MetricServer.Properties.Settings</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">userSettings</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">configuration</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><h3>  Welche YAML-Dateien m√∂chte ich lesen </h3><br>  So etwas wie das: <br><br><pre> <code class="plaintext hljs">VirtualFeed: MaxChartHistoryLength: 10 Port: 35016 UseThrottling: True ThrottlingIntervalMs: 50000 UseHistoryBroadcast: True CalendarName: "EmptyCalendar" UsMarketFeed: UseImbalances: True</code> </pre><br><h3>  √úbergangsprobleme </h3><br>  <b>Erstens sind die</b> Konfigurationen in XML "flach", in YAML jedoch nicht (Abschnitte und Unterabschnitte werden unterst√ºtzt).  Dies ist in den obigen Beispielen deutlich zu sehen.  Mit XML haben wir das Problem der flachen Einstellungen gel√∂st, indem wir eigene Parser eingef√ºhrt haben, die Zeichenfolgen eines bestimmten Typs in unsere komplexeren Klassen konvertieren k√∂nnen.  Ein Beispiel f√ºr eine solch komplexe Zeichenfolge: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">setting</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"MCXSettings"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">serializeAs</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"String"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>Inactive, ChartLen: 1000, PrintLen: 50, UseProxy: False<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">setting</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Ich habe keine Lust, solche Transformationen durchzuf√ºhren, wenn ich mit YAML arbeite.  Gleichzeitig sind wir jedoch durch die vorhandene ‚Äûflache‚Äú Struktur der AppSettings-Klasse eingeschr√§nkt: Alle Eigenschaften der darin enthaltenen Einstellungen sind in einem Heap zusammengefasst. <br><br>  <b>Zweitens sind die</b> Konfigurationen unserer Server kein statischer Monolith, wir √§ndern sie von Zeit zu Zeit direkt im Verlauf der Serverarbeit, d. H.  Diese √Ñnderungen m√ºssen in der Lage sein, zur Laufzeit im laufenden Betrieb zu erfassen.  Zu diesem Zweck erben wir in der XML-Implementierung unsere AppSettings von INotifyPropertyChanged (tats√§chlich wird jede Schnittstelle, die AppSettings implementiert, davon geerbt) und abonnieren die Aktualisierung der Ereignisse der Einstellungseigenschaften.  Dieser Ansatz funktioniert, weil die Standardklasse System.Configuration.ApplicationSettingsBase standardm√§√üig INotifyPropertyChanged implementiert.  Ein √§hnliches Verhalten muss nach dem √úbergang zu YAML beibehalten werden. <br><br>  <b>Drittens haben</b> wir nicht eine Konfigurationsdatei f√ºr jeden Server, sondern zwei so viele: eine mit Standardeinstellungen, die andere mit √ºberschriebenen.  Dies ist erforderlich, damit Sie in mehreren Instanzen von Servern desselben Typs, die unterschiedliche Ports abh√∂ren und leicht unterschiedliche Einstellungen haben, nicht den gesamten Satz von Einstellungen vollst√§ndig kopieren m√ºssen. <br><br>  <b>Und noch ein Problem</b> : Der Zugriff auf die Einstellungen erfolgt nicht nur √ºber Schnittstellen, sondern auch √ºber den direkten Zugriff auf AppSettings.Default.  Ich m√∂chte Sie daran erinnern, wie es in den Backstage-AppSettings.Designer.cs deklariert ist: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> AppSettings defaultInstance = ((AppSettings)(<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>::System.Configuration.ApplicationSettingsBase.Synchronized(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AppSettings()))); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> AppSettings Default { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> defaultInstance; } }</code> </pre><br>  Basierend auf dem Vorstehenden war es notwendig, einen neuen Ansatz zum Speichern von Einstellungen in AppSettings zu entwickeln. <br><br><h2>  L√∂sung </h2><br><h3>  Toolkit </h3><br>  F√ºr das direkte Lesen entschied sich YAML, vorgefertigte Bibliotheken zu verwenden, die √ºber NuGet erh√§ltlich sind: <br><br><ul><li>  YamlDotNet - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/aaubry/YamlDotNet</a> .  Aus der Bibliotheksbeschreibung (√úbersetzung): <br><blockquote>  YamlDotNet ist die .NET-Bibliothek f√ºr YAML.  YamlDotNet bietet einen Low-Level-Parser und einen YAML-Generator sowie ein High-Level-Objektmodell √§hnlich XmlDocument.  Ebenfalls enthalten ist eine Serialisierungsbibliothek, mit der Sie Objekte von / zu YAML-Streams lesen und schreiben k√∂nnen. </blockquote><br></li><li>  NetEscapades.Configuration - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/andrewlock/NetEscapades.Configuration</a> .  Dies ist der Konfigurationsanbieter selbst (im Sinne von Microsoft.Extensions.Configuration.IConfigurationSource, der in ASP.NET Core-Anwendungen aktiv verwendet wird), der YAML-Dateien nur mit dem oben genannten YamlDotNet liest. <br></li></ul><br>  Lesen Sie hier mehr √ºber die Verwendung dieser Bibliotheken. <br><br><h3>  √úbergang zu YAML </h3><br>  Der √úbergang selbst wurde in zwei Schritten durchgef√ºhrt: Zuerst haben wir einfach von XML zu YAML gewechselt, aber eine flache Hierarchie von Konfigurationsdateien beibehalten, und dann haben wir Abschnitte in YAML-Dateien eingegeben.  Diese Phasen k√∂nnten im Prinzip zu einer zusammengefasst werden, und der Einfachheit halber werde ich genau das tun.  Alle unten beschriebenen Aktionen wurden nacheinander auf jeden Dienst angewendet. <br><br><h3>  Vorbereiten einer YML-Datei </h3><br>  Zuerst m√ºssen Sie die YAML-Datei selbst vorbereiten.  Wir nennen es den Namen des Projekts (n√ºtzlich f√ºr zuk√ºnftige Integrationstests, die in der Lage sein sollten, mit verschiedenen Servern zu arbeiten und deren Konfigurationen voneinander zu unterscheiden). Legen Sie die Datei direkt im Stammverzeichnis des Projekts neben AppSettings ab: <br><br><img src="https://habrastorage.org/webt/es/2h/jo/es2hjofltziwk8fbqj3f5faxte0.png"><br><br>  Speichern wir zun√§chst in der YML-Datei eine ‚Äûflache‚Äú Struktur: <br><br><pre> <code class="plaintext hljs">VirtualFeed: "MaxChartHistoryLength: 10, UseThrottling: True, ThrottlingIntervalMs: 50000, UseHistoryBroadcast: True, CalendarName: EmptyCalendar" VirtualFeedPort: 35016 UsMarketFeedUseImbalances: True</code> </pre><br><h3>  AppSettings mit Einstellungen f√ºllen </h3><br>  Wir √ºbertragen alle Eigenschaften von AppSettings.Designer.cs auf AppSettings.cs und entfernen gleichzeitig die √ºberfl√ºssigen Attribute des Designers und den Code selbst in get / set-parts. <br><br>  Es war: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">global::System.Configuration.UserScopedSettingAttribute()</span></span>] [<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>::System.Diagnostics.DebuggerNonUserCodeAttribute()] [<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>::System.Configuration.DefaultSettingValueAttribute(<span class="hljs-string"><span class="hljs-string">"35016"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> VirtualFeedPort{ <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-string"><span class="hljs-string">"VirtualFeedPort"</span></span>])); } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-string"><span class="hljs-string">"VirtualFeedPort"</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } }</code> </pre><br>  Es wurde: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> VirtualFeedPort { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre><br>  Wir werden AppSettings <b>.Designer</b> .cs als unn√∂tig entfernen.  √úbrigens k√∂nnen Sie jetzt den Abschnitt userSettings in der Datei app.config vollst√§ndig entfernen, wenn er sich im Projekt befindet. Dort werden dieselben Standardeinstellungen gespeichert, die wir √ºber den Einstellungsdesigner festlegen. <br>  Mach weiter. <br><br><h3>  Steuerungseinstellungen im laufenden Betrieb </h3><br>  Da wir in der Lage sein m√ºssen, Aktualisierungen unserer Einstellungen zur Laufzeit abzufangen, m√ºssen wir INotifyPropertyChanged in unseren AppSettings implementieren.  Die Basis System.Configuration.ApplicationSettingsBase ist nicht mehr vorhanden. Sie k√∂nnen sich nicht auf Magie verlassen. <br><br>  Sie k√∂nnen es "auf der Stirn" implementieren: indem Sie eine Implementierung einer Methode hinzuf√ºgen, die das gew√ºnschte Ereignis ausl√∂st, und es im Setter jeder Eigenschaft aufrufen.  Dies sind jedoch zus√§tzliche Codezeilen, die zus√§tzlich √ºber alle Dienste hinweg kopiert werden m√ºssen. <br><br>  Machen wir es sch√∂ner - stellen Sie die zus√§tzliche Basisklasse AutoNotifier vor, die tats√§chlich dasselbe tut, jedoch hinter den Kulissen, genau wie zuvor System.Configuration.ApplicationSettingsBase: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Implements </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;see cref="INotifyPropertyChanged"/&gt;</span></span></span><span class="hljs-comment"> for classes with a lot of public properties (ie AppSettings). </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> This implementation is: </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> - fairly slow, so don't use it for classes where getting/setting of properties is often operation; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> - not for properties described in inherited classes of 2nd level (bad idea: Inherit2 -&gt; Inherit1 -&gt; AutoNotifier; good idea: sealed Inherit -&gt; AutoNotifier) </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public abstract class AutoNotifier : INotifyPropertyChanged { public event PropertyChangedEventHandler PropertyChanged; private readonly ConcurrentDictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string, object&gt;</span></span></span><span class="hljs-comment"> _wrappedValues = new ConcurrentDictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string, object&gt;</span></span></span><span class="hljs-comment">(); //just to avoid manual writing a lot of fields protected T Get</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment">([CallerMemberName] string propertyName = null) { return (T)_wrappedValues.GetValueOrDefault(propertyName, () =&gt; default(T)); } protected void Set</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment">(T value, [CallerMemberName] string propertyName = null) { // ReSharper disable once AssignNullToNotNullAttribute _wrappedValues.AddOrUpdate(propertyName, value, (s, o) =&gt; value); OnPropertyChanged(propertyName); } public object this[string propertyName] { get { return Get</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;object&gt;</span></span></span><span class="hljs-comment">(propertyName); } set { Set(value, propertyName); } } protected void OnPropertyChanged([CallerMemberName] string propertyName = null) { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } }</span></span></code> </pre><br>  Hier k√∂nnen Sie mit dem Attribut [CallerMemberName] automatisch den Eigenschaftsnamen des aufrufenden Objekts abrufen, d. H.  AppSettings <br><br>  Jetzt k√∂nnen wir unsere AppSettings von dieser Basisklasse AutoNotifier erben, und dann wird jede Eigenschaft leicht ge√§ndert: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> VirtualFeedPort { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { Set(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } }</code> </pre><br>  Mit diesem Ansatz sehen unsere AppSettings-Klassen, die sogar viele Einstellungen enthalten, kompakt aus und implementieren gleichzeitig INotifyPropertyChanged vollst√§ndig. <br><br>  Ja, ich wei√ü, dass es m√∂glich w√§re, etwas mehr Magie einzuf√ºhren, indem Sie beispielsweise Castle.DynamicProxy.IInterceptor verwenden, √Ñnderungen an den erforderlichen Eigenschaften abfangen und dort Ereignisse ausl√∂sen.  Aber eine solche Entscheidung schien mir zu √ºberladen. <br><br><h3>  Lesen von Einstellungen aus einer YAML-Datei </h3><br>  Der n√§chste Schritt besteht darin, den Leser der YAML-Konfiguration selbst hinzuzuf√ºgen.  Dies geschieht irgendwo n√§her am Start des Dienstes.  Wenn wir unn√∂tige Details verbergen, die nicht mit dem diskutierten Thema zusammenh√§ngen, erhalten wir etwas √Ñhnliches: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IServerConfigurationProvider </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadServerConfiguration</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IReadOnlyDictionary&lt;Type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; allSections</span></span></span><span class="hljs-function">)</span></span> { IConfigurationBuilder builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConfigurationBuilder().SetBasePath(ConfigFiles.BasePath); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> configFile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> configFiles) { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> directory = Path.GetDirectoryName(configFile); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(directory)) <span class="hljs-comment"><span class="hljs-comment">//can be empty if relative path is used { Directory.CreateDirectory(directory); } builder = builder.AddYamlFile(configFile, optional: true, reloadOnChange: true); } IConfigurationRoot config = builder.Build(); // load prepared files and merge them return new ServerConfigurationProvider&lt;TAppSettings&gt;(config, allSections); }</span></span></code> </pre><br>  In dem vorgestellten Code ist ConfigurationBuilder wahrscheinlich nicht von besonderem Interesse - alle Arbeiten damit √§hneln der Arbeit mit Konfigurationen in ASP.NET Core.  Die folgenden Punkte sind jedoch von Interesse.  Erstens hatten wir "out of the box" auch die M√∂glichkeit, Einstellungen aus mehreren Dateien zu kombinieren.  Dies setzt voraus, dass mindestens zwei Konfigurationsdateien pro Server vorhanden sind, wie oben erw√§hnt.  Zweitens √ºbergeben wir die gesamte Lesekonfiguration an einen bestimmten ServerConfigurationProvider.  Warum? <br><br><h3>  Abschnitte in der YAML-Datei </h3><br>  Wir werden diese Frage sp√§ter beantworten und nun zu der Anforderung zur√ºckkehren, hierarchisch strukturierte Einstellungen in einer YML-Datei zu speichern. <br><br>  Die Implementierung ist im Prinzip recht einfach.  Zun√§chst stellen wir in der YML-Datei die Struktur vor, die wir ben√∂tigen: <br><br><pre> <code class="plaintext hljs">VirtualFeed: MaxChartHistoryLength: 10 Port: 35016 UseThrottling: True ThrottlingIntervalMs: 50000 UseHistoryBroadcast: True CalendarName: "EmptyCalendar" UsMarketFeed: UseImbalances: True</code> </pre><br>  Gehen wir jetzt zu AppSettings und bringen ihm bei, wie wir unsere Eigenschaften in Abschnitte unterteilen k√∂nnen.  Irgendwie so: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AppSettings</span></span> : <span class="hljs-title"><span class="hljs-title">AutoNotifier</span></span>, <span class="hljs-title"><span class="hljs-title">IWebSettingsStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IServerSettingsStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IServerManagerAddressStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IGlobalCredentialsStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IGraphiteAddressStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IDatabaseConfigStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IBlackListStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IKeyCloackConfigFilePathProvider</span></span>, <span class="hljs-title"><span class="hljs-title">IPrometheusSettingsStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IHeartBeatConfig</span></span>, <span class="hljs-title"><span class="hljs-title">IConcurrentAcceptorProperties</span></span>, <span class="hljs-title"><span class="hljs-title">IMetricsConfig</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IReadOnlyDictionary&lt;Type, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; Sections { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;Type, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; { {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IDatabaseConfigStorage), <span class="hljs-string"><span class="hljs-string">"Database"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IWebSettingsStorage), <span class="hljs-string"><span class="hljs-string">"Web"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IServerSettingsStorage), <span class="hljs-string"><span class="hljs-string">"Server"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IConcurrentAcceptorProperties), <span class="hljs-string"><span class="hljs-string">"ConcurrentAcceptor"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IGraphiteAddressStorage), <span class="hljs-string"><span class="hljs-string">"Graphite"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IKeyCloackConfigFilePathProvider), <span class="hljs-string"><span class="hljs-string">"Keycloak"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IPrometheusSettingsStorage), <span class="hljs-string"><span class="hljs-string">"Prometheus"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IHeartBeatConfig), <span class="hljs-string"><span class="hljs-string">"Heartbeat"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IServerManagerAddressStorage), <span class="hljs-string"><span class="hljs-string">"ServerManager"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IGlobalCredentialsStorage), <span class="hljs-string"><span class="hljs-string">"GlobalCredentials"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IBlackListStorage), <span class="hljs-string"><span class="hljs-string">"Blacklist"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IMetricsConfig), <span class="hljs-string"><span class="hljs-string">"Metrics"</span></span>} }; ...</code> </pre><br>  Wie Sie sehen k√∂nnen, haben wir AppSettings direkt ein W√∂rterbuch hinzugef√ºgt, wobei die Schl√ºssel die Arten von Schnittstellen sind, die von der AppSettings-Klasse implementiert werden, und die Werte die √úberschriften der entsprechenden Abschnitte sind.  Jetzt k√∂nnen wir die Hierarchie in der YML-Datei mit der Hierarchie der Eigenschaften in AppSettings vergleichen (obwohl nicht tiefer als eine Verschachtelungsebene, aber in unserem Fall war dies ausreichend). <br><br>  Warum machen wir das hier - in AppSettings?  Weil wir auf diese Weise die Informationen √ºber die Einstellungen f√ºr verschiedene Entit√§ten nicht verbreiten und dies au√üerdem der nat√ºrlichste Ort ist, weil  in jedem Dienst und dementsprechend in jedem AppSettings einen eigenen Einstellungsbereich. <br><br><h3>  Wenn Sie keine Hierarchie in den Einstellungen ben√∂tigen? </h3><br>  Im Prinzip ist es ein seltsamer Fall, aber wir hatten ihn genau in der ersten Phase, als wir einfach von XML zu YAML wechselten, ohne die Vorteile von YAML zu nutzen. <br><br>  In diesem Fall kann nicht die gesamte Liste der Abschnitte gespeichert werden, und ServerConfigurationProvider ist viel einfacher (wird sp√§ter erl√§utert). <br><br>  Der wichtige Punkt ist jedoch, dass wir, wenn wir uns entscheiden, eine flache Hierarchie zu verlassen, nur die Anforderung erf√ºllen k√∂nnen, den Zugriff auf Einstellungen √ºber AppSettings.Default aufrechtzuerhalten.  F√ºgen Sie dazu hier einen so einfachen √∂ffentlichen Konstruktor in AppSettings hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> AppSettings Default { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AppSettings</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Default = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre><br>  Jetzt k√∂nnen wir weiterhin √ºberall √ºber AppSettings.Default auf die Einstellungsklasse zugreifen (vorausgesetzt, die Einstellungen wurden bereits √ºber IConfigurationRoot in ServerConfigurationProvider gelesen und AppSettings wurde entsprechend instanziiert). <br><br>  Wenn eine flache Hierarchie nicht akzeptabel ist, m√ºssen Sie AppSettings ohnehin loswerden. Standardm√§√üig √ºberall per Code und mit Einstellungen nur √ºber Schnittstellen arbeiten (was im Prinzip gut ist).  Warum so - es wird weiter klar. <br><br><h3>  ServerConfigurationProvider </h3><br>  Die zuvor erw√§hnte spezielle ServerConfigurationProvider-Klasse befasst sich mit der Magie, die es Ihnen erm√∂glicht, mit der neuen hierarchischen YAML-Konfiguration mit nur flachen AppSettings vollst√§ndig zu arbeiten. <br><br>  Wenn Sie nicht warten k√∂nnen, ist es hier. <br><br><div class="spoiler">  <b class="spoiler_title">Vollst√§ndiger ServerConfigurationProvider-Code</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Provides different configurations for current server </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public class ServerConfigurationProvider</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;TAppSettings&gt;</span></span></span><span class="hljs-comment"> : IServerConfigurationProvider where TAppSettings : new() { private static readonly Logger Logger = LogManager.GetCurrentClassLogger(); private readonly IConfigurationRoot _configuration; private readonly IReadOnlyDictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type, string&gt;</span></span></span><span class="hljs-comment"> _sectionsByInterface; private readonly IReadOnlyDictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string, Type&gt;</span></span></span><span class="hljs-comment"> _interfacesBySections; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Section name -&gt; config </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> private readonly ConcurrentDictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string, TAppSettings&gt;</span></span></span><span class="hljs-comment"> _cachedSections; public ServerConfigurationProvider(IConfigurationRoot configuration, IReadOnlyDictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type, string&gt;</span></span></span><span class="hljs-comment"> allSections) { _configuration = configuration; _cachedSections = new ConcurrentDictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string, TAppSettings&gt;</span></span></span><span class="hljs-comment">(); _sectionsByInterface = allSections; var interfacesBySections = new Dictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string, Type&gt;</span></span></span><span class="hljs-comment">(); foreach (KeyValuePair</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type, string&gt;</span></span></span><span class="hljs-comment"> interfaceAndSection in _sectionsByInterface) { //section names must be unique interfacesBySections.Add(interfaceAndSection.Value, interfaceAndSection.Key); } _interfacesBySections = interfacesBySections; _configuration.GetReloadToken()?.RegisterChangeCallback(OnConfigurationFileChanged, null); } private void OnConfigurationFileChanged(object _) { UpdateCache(); } private void UpdateCache() { foreach (string sectionName in _cachedSections.Keys) { Type sectionInterface = _interfacesBySections[sectionName]; TAppSettings newSection = ReadSection(sectionName, sectionInterface); TAppSettings oldSection; if (_cachedSections.TryGetValue(sectionName, out oldSection)) { UpdateSection(oldSection, newSection); } } } private void UpdateSection(TAppSettings oldConfig, TAppSettings newConfig) { foreach (PropertyInfo propertyInfo in typeof(TAppSettings).GetProperties().Where(p =&gt; p.GetMethod != null &amp;&amp; p.SetMethod != null)) { propertyInfo.SetValue(newConfig, propertyInfo.GetValue(oldConfig)); } } public IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type&gt;</span></span></span><span class="hljs-comment"> AllSections =&gt; _sectionsByInterface.Keys; public TSettingsSectionInterface FindSection</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;TSettingsSectionInterface&gt;</span></span></span><span class="hljs-comment">() where TSettingsSectionInterface : class { return (TSettingsSectionInterface)FindSection(typeof(TSettingsSectionInterface)); } [CanBeNull] public object FindSection(Type sectionInterface) { string sectionName = FindSectionName(sectionInterface); if (sectionName == null) { return null; } //we must return same instance of settings for same requested section (otherwise changing of settings will lead to inconsistent state) return _cachedSections.GetOrAdd(sectionName, typeName =&gt; ReadSection(sectionName, sectionInterface)); } private string FindSectionName(Type sectionInterface) { string sectionName; if (!_sectionsByInterface.TryGetValue(sectionInterface, out sectionName)) { Logger.Debug("This server doesn't contain settings for {0}", sectionInterface.FullName); return null; } return sectionName; } private TAppSettings ReadSection(string sectionName, Type sectionInterface) { TAppSettings parsed; try { IConfigurationSection section = _configuration.GetSection(sectionName); CheckSection(section, sectionName, sectionInterface); parsed = section.Get</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;TAppSettings&gt;</span></span></span><span class="hljs-comment">(); if (parsed == null) { //means that this section is empty or all its properties are empty return new TAppSettings(); } ReadArrays(parsed, section); } catch (Exception ex) { Logger.Fatal(ex, "Something wrong during reading section {0} in config", sectionName.SafeSurround()); throw; } return parsed; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Manual reading of array properties in config </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> private void ReadArrays(TAppSettings settings, IConfigurationSection section) { foreach (PropertyInfo propertyInfo in GetPublicProperties(typeof(TAppSettings), needSetters: true).Where(p =&gt; typeof(IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string&gt;</span></span></span><span class="hljs-comment">).IsAssignableFrom(p.PropertyType))) { ClearDefaultArrayIfOverridenExists(section.Key, propertyInfo.Name); IConfigurationSection enumerableProperty = section.GetSection(propertyInfo.Name); propertyInfo.SetValue(settings, enumerableProperty.Get</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;IEnumerable&lt;string&gt;</span></span></span><span class="hljs-comment">&gt;()); } } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Clears array property from default config to use overriden one. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Standard implementation merges default and overriden array by indexes - this is not what we need </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> private void ClearDefaultArrayIfOverridenExists(string sectionName, string propertyName) { List</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;IConfigurationProvider&gt;</span></span></span><span class="hljs-comment"> providers = _configuration.Providers.ToList(); if (providers.Count == 0) { return; } string propertyTemplate = $"{sectionName}:{propertyName}:"; if (!providers[providers.Count - 1].TryGet($"{propertyTemplate}{0}", out _)) { //we should use array from default config, because overriden config has no overriden array return; } foreach (IConfigurationProvider provider in providers.Take(providers.Count - 1)) { for (int i = 0; ; i++) { string propertyInnerName = $"{propertyTemplate}{i}"; if (!provider.TryGet(propertyInnerName, out _)) { break; } provider.Set(propertyInnerName, null); } } } private void CheckSection(IConfigurationSection section, string sectionName, Type sectionInterface) { ICollection</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;PropertyInfo&gt;</span></span></span><span class="hljs-comment"> properties = GetPublicProperties(sectionInterface, needSetters: false); var configProperties = new HashSet</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string&gt;</span></span></span><span class="hljs-comment">(section.GetChildren().Select(c =&gt; c.Key)); foreach (PropertyInfo propertyInfo in properties) { if (!configProperties.Remove(propertyInfo.Name)) { if (propertyInfo.PropertyType != typeof(string) &amp;&amp; typeof(IEnumerable).IsAssignableFrom(propertyInfo.PropertyType)) { //no way to distinguish absent array and empty array :( Logger.Debug("Property {0} has no valuable items in configs section {1}", propertyInfo.Name, sectionName.SafeSurround()); } else { Logger.Fatal("Property {0} not found in configs section {1}", propertyInfo.Name, sectionName.SafeSurround()); } } } if (configProperties.Any()) { Logger.Fatal("Unexpected config properties {0} in configs section {1}", configProperties.SafeSurroundAndJoin(), sectionName.SafeSurround()); } } private static ICollection</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;PropertyInfo&gt;</span></span></span><span class="hljs-comment"> GetPublicProperties(Type type, bool needSetters) { if (!type.IsInterface) { return type.GetProperties().Where(x =&gt; x.GetMethod != null &amp;&amp; (!needSetters || x.SetMethod != null)).ToArray(); } var propertyInfos = new List</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;PropertyInfo&gt;</span></span></span><span class="hljs-comment">(); var considered = new List</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type&gt;</span></span></span><span class="hljs-comment">(); var queue = new Queue</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type&gt;</span></span></span><span class="hljs-comment">(); considered.Add(type); queue.Enqueue(type); while (queue.Count &gt; 0) { Type subType = queue.Dequeue(); foreach (Type subInterface in subType.GetInterfaces()) { if (considered.Contains(subInterface)) { continue; } considered.Add(subInterface); queue.Enqueue(subInterface); } PropertyInfo[] typeProperties = subType.GetProperties(BindingFlags.FlattenHierarchy | BindingFlags.Public | BindingFlags.Instance); IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;PropertyInfo&gt;</span></span></span><span class="hljs-comment"> newPropertyInfos = typeProperties.Where(x =&gt; x.GetMethod != null &amp;&amp; (!needSetters || x.SetMethod != null) &amp;&amp; !propertyInfos.Contains(x)); propertyInfos.InsertRange(0, newPropertyInfos); } return propertyInfos; } }</span></span></code> </pre><br></div></div><br>  ServerConfigurationProvider wird von der AppSettings-Einstellungsklasse parametrisiert: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ServerConfigurationProvider</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TAppSettings</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IServerConfigurationProvider</span></span> <span class="hljs-title"><span class="hljs-title">where</span></span> <span class="hljs-title"><span class="hljs-title">TAppSettings</span></span> : <span class="hljs-title"><span class="hljs-title">new</span></span>()</code> </pre><br>  Auf diese Weise k√∂nnen Sie es, wie Sie vielleicht vermuten, sofort in allen Diensten verwenden. <br><br>  Die Lesekonfiguration selbst (IConfigurationRoot) sowie das oben erw√§hnte Abschnittsw√∂rterbuch (AppSettings.Sections) werden an den Konstruktor √ºbergeben.  Es gibt ein Abonnement f√ºr Dateiaktualisierungen (m√∂chten wir diese √Ñnderungen im Falle einer √Ñnderung der YML-Datei sofort auf uns √ºbertragen?): <br><br><pre> <code class="cs hljs">_configuration.GetReloadToken()?.RegisterChangeCallback(OnConfigurationFileChanged, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnConfigurationFileChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> sectionName <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _cachedSections.Keys) { Type sectionInterface = _interfacesBySections[sectionName]; TAppSettings newSection = ReadSection(sectionName, sectionInterface); TAppSettings oldSection; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_cachedSections.TryGetValue(sectionName, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> oldSection)) { UpdateSection(oldSection, newSection); } } }</code> </pre><br>  Wie Sie hier sehen k√∂nnen, gehen wir beim Aktualisieren der YML-Datei alle uns bekannten Abschnitte durch und lesen sie jeweils.  Wenn der Abschnitt dann bereits fr√ºher im Cache gelesen wurde (d. H. Von einer Klasse bereits irgendwo im Code angefordert wurde), schreiben wir die alten Werte im Cache mit neuen um. <br><br>  Es scheint - warum jeden Abschnitt lesen, warum nicht nur diejenigen lesen, die sich im Cache befinden (d. H. Gefordert werden)?  Weil wir beim Lesen des Abschnitts eine √úberpr√ºfung auf die richtige Konfiguration implementiert haben.  Und bei falschen Einstellungen werden die entsprechenden Warnungen ausgegeben und Probleme protokolliert.  Es ist besser, sich so schnell wie m√∂glich √ºber Probleme bei den Konfigurations√§nderungen zu informieren, aus denen wir sofort alle Abschnitte lesen. <br><br>  Das Aktualisieren alter Werte im Cache mit neuen Werten ist trivial genug: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateSection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TAppSettings oldConfig, TAppSettings newConfig</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-function"><span class="hljs-function">PropertyInfo propertyInfo </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">typeof</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TAppSettings</span></span></span><span class="hljs-function">).</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetProperties</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>).</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Where</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p =&gt; p.GetMethod != </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;&amp; p.SetMethod != </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">))</span></span> { propertyInfo.SetValue(newConfig, propertyInfo.GetValue(oldConfig)); } }</code> </pre><br>  Das Lesen von Abschnitten ist jedoch nicht so einfach: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> TAppSettings </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadSection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sectionName, Type sectionInterface</span></span></span><span class="hljs-function">)</span></span> { TAppSettings parsed; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { IConfigurationSection section = _configuration.GetSection(sectionName); CheckSection(section, sectionName, sectionInterface); parsed = section.Get&lt;TAppSettings&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsed == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//means that this section is empty or all its properties are empty return new TAppSettings(); } ReadArrays(parsed, section); } catch (Exception ex) { Logger.Fatal(ex, "Something wrong during reading section {0} in config", sectionName.SafeSurround()); throw; } return parsed; }</span></span></code> </pre><br>  Hier lesen wir zun√§chst den Abschnitt selbst mit dem Standard IConfigurationRoot.GetSection.   -    . <br><br>        : section.Get     YAML- ‚Äî      ( , .. )  ,     . <br><br>   : <br><br><pre> <code class="plaintext hljs">VirtualFeed: Names: []</code> </pre><br>    VirtualFeed   Names    ,  YAML-,  , ,   VirtualFeed   . . <br><br>             IEnumerable-  .     ¬´ ¬ª    . <br><br><pre> <code class="cs hljs">ReadArrays(parsed, section); ... <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Manual reading of array properties in config </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> private void ReadArrays(TAppSettings settings, IConfigurationSection section) { foreach (PropertyInfo propertyInfo in GetPublicProperties(typeof(TAppSettings), needSetters: true).Where(p =&gt; typeof(IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string&gt;</span></span></span><span class="hljs-comment">).IsAssignableFrom(p.PropertyType))) { ClearDefaultArrayIfOverridenExists(section.Key, propertyInfo.Name); IConfigurationSection enumerableProperty = section.GetSection(propertyInfo.Name); propertyInfo.SetValue(settings, enumerableProperty.Get</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;IEnumerable&lt;string&gt;</span></span></span><span class="hljs-comment">&gt;()); } } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Clears array property from default config to use overriden one. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Standard implementation merges default and overriden array by indexes - this is not what we need </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> private void ClearDefaultArrayIfOverridenExists(string sectionName, string propertyName) { List</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;IConfigurationProvider&gt;</span></span></span><span class="hljs-comment"> providers = _configuration.Providers.ToList(); if (providers.Count == 0) { return; } string propertyTemplate = $"{sectionName}:{propertyName}:"; if (!providers[providers.Count - 1].TryGet($"{propertyTemplate}{0}", out _)) { //we should use array from default config, because overriden config has no overriden array return; } foreach (IConfigurationProvider provider in providers.Take(providers.Count - 1)) { for (int i = 0; ; i++) { string propertyInnerName = $"{propertyTemplate}{i}"; if (!provider.TryGet(propertyInnerName, out _)) { break; } provider.Set(propertyInnerName, null); } } }</span></span></code> </pre><br>  ,    ,     IEnumerable        ¬´¬ª,       .      :           -?   ‚Äî     ,  ,    -, .    ,    (     )         IConfigurationSection,       .  -     . <br><br>   ReadSection        : FindSection. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CanBeNull</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindSection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type sectionInterface</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> sectionName = FindSectionName(sectionInterface); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sectionName == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//we must return same instance of settings for same requested section (otherwise changing of settings will lead to inconsistent state) return _cachedSections.GetOrAdd(sectionName, typeName =&gt; ReadSection(sectionName, sectionInterface)); }</span></span></code> </pre><br>  ,    ,          AppSettings.Default:     ( )    FindSection          AppSettings,      , , ,     AppSettings.Default,                ,       (     ‚Äî NULL  0). <br><br>        : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckSection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IConfigurationSection section, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sectionName, Type sectionInterface</span></span></span><span class="hljs-function">)</span></span> { ICollection&lt;PropertyInfo&gt; properties = GetPublicProperties(sectionInterface, needSetters: <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> configProperties = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(section.GetChildren().Select(c =&gt; c.Key)); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (PropertyInfo propertyInfo <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> properties) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!configProperties.Remove(propertyInfo.Name)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (propertyInfo.PropertyType != <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IEnumerable).IsAssignableFrom(propertyInfo.PropertyType)) { <span class="hljs-comment"><span class="hljs-comment">//no way to distinguish absent array and empty array :( Logger.Debug("Property {0} has no valuable items in configs section {1}", propertyInfo.Name, sectionName.SafeSurround()); } else { Logger.Fatal("Property {0} not found in configs section {1}", propertyInfo.Name, sectionName.SafeSurround()); } } } if (configProperties.Any()) { Logger.Fatal("Unexpected config properties {0} in configs section {1}", configProperties.SafeSurroundAndJoin(), sectionName.SafeSurround()); } }</span></span></code> </pre><br>           ( ‚Äî  ).           :    ,    ,   ,       - .    ,   -      .   ,     , ..  ,      ,    ,        . <br><br>   ‚Äî     ,              ¬´--¬ª?   ,    ,   ,       ,    ‚Äî    ,    ,    . ,          ,  .    ,  ,         . <br><br>          GetPublicProperties, ,  ,       .     ,    ,   ,     ,   ,    , , ,        ,     . <br><br><h3>    </h3><br>                 : <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Provides different configurations for current server </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public interface IServerConfigurationProvider { TSettingsSectionInterface FindSection</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;TSettingsSectionInterface&gt;</span></span></span><span class="hljs-comment">() where TSettingsSectionInterface : class; object FindSection(Type sectionInterface); IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type&gt;</span></span></span><span class="hljs-comment"> AllSections { get; } }</span></span></code> </pre><br>     ‚Äî FindSection ‚Äî      .  Irgendwie so: <br><br><pre> <code class="cs hljs">IThreadPoolProperties threadPoolProperties = ConfigurationProvider.FindSection&lt;IThreadPoolProperties&gt;();</code> </pre><br>       ‚Äî  . <br><br><h3>    </h3><br>       IoC-  Castle Windsor.          . ,      . <br><br>      Extension-,    ,          : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ServerConfigurationProviderExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterAllConfigurationSections</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IWindsorContainer container, IServerConfigurationProvider configurationProvider</span></span></span><span class="hljs-function">)</span></span> { Register(container, configurationProvider, configurationProvider.AllSections.ToArray()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Register</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IWindsorContainer container, IServerConfigurationProvider configurationProvider, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">params</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Type[] configSections</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> registrations = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IRegistration[configSections.Length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; registrations.Length; i++) { Type configSection = configSections[i]; <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> section = configurationProvider.FindSection(configSection); registrations[i] = Component.For(configSection).Instance(section).Named(configSection.FullName); } container.Register(registrations); } }</code> </pre><br>        (     AllSections   IServerConfigurationProvider). <br><br>      ,           ServerConfigurationProvider,        ServerConfigurationProvider    Windsor. <br>     , ,  FindSection  IServerConfigurationProvider. <br><br>        Windsor  Extension-: <br><br><pre> <code class="cs hljs">container.RegisterAllConfigurationSections(configProvider);</code> </pre><br><h2>  Fazit </h2><br><h3>   </h3><br>            XML  YAML,         . <br><br> YAML-,    XML,         ,      . <br><br>        YAML,    .   ,          ,    . ,     . <br><br>        -   ¬´ ¬ª.  ,          YAML- (        -). <br><br>        ‚Äî    ,        ¬´ ¬ª. <br><br><h3>     </h3><br>        ,   -  ,  -, ..       ,  -     -  . <br><br>           AppSettings.Default,    ,  . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438362/">https://habr.com/ru/post/de438362/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438350/index.html">Vollst√§ndiger Leitfaden zur professionellen Suche nach versteckten Kameras und Spionageger√§ten</a></li>
<li><a href="../de438352/index.html">Video des Abstiegs des Rovers "Yutu-2", seiner ersten Meter auf der Mondoberfl√§che. Der zweiw√∂chige Schlaf auf dem Mond ist vorbei</a></li>
<li><a href="../de438354/index.html">Vue, Storybook, TypeScript - Starten eines neuen Projekts unter Ber√ºcksichtigung der Best Practices</a></li>
<li><a href="../de438356/index.html">Von SQL Server Data Warehouse Fast Track (DWFT) zertifizierte Architektur: Was dies bedeutet und wie es funktioniert</a></li>
<li><a href="../de438358/index.html">Ehemalige NSA-Mitarbeiter spionieren die von den VAE in Auftrag gegebenen iPhones der Opfer aus</a></li>
<li><a href="../de438364/index.html">Replikation des weltweit ersten digitalen Voice Scramblers</a></li>
<li><a href="../de438366/index.html">Noch eine √úberpr√ºfung der OATH-Hardware-Token-Funktion in Azure Cloud MFA</a></li>
<li><a href="../de438368/index.html">Intelligente Gl√ºhbirnen, die in den M√ºll geworfen werden, sind eine wertvolle Quelle f√ºr pers√∂nliche Informationen.</a></li>
<li><a href="../de438370/index.html">Cyberkriminalit√§t als Dienstleistung: Dienstleistungen und Preise</a></li>
<li><a href="../de438372/index.html">Die NASA versucht weiterhin, Kontakt zu Opportunity aufzunehmen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>