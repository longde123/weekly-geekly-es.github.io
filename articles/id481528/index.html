<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎟️ 🚦 😵 Bagaimana tes dapat membantu Anda dalam membuat UI-kit Anda sendiri 👨🏾‍⚖️ 👨‍👨‍👦‍👦 🧑🏽‍🤝‍🧑🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagi mereka yang tidak suka pengantar panjang, mari langsung ke kesimpulan - menulis tes untuk komponen Anda. Serius, ini semua yang ingin saya kataka...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana tes dapat membantu Anda dalam membuat UI-kit Anda sendiri</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481528/">  Bagi mereka yang tidak suka pengantar panjang, mari langsung ke kesimpulan - menulis tes untuk komponen Anda.  Serius, ini semua yang ingin saya katakan.  Tetapi jangan menganggap ini terlalu serius, bayangkan ini adalah kesimpulan dari teorema, teorema frontend.  Dan sekarang, kita perlu menemukan bukti. <br><a name="habracut"></a><br>  Jadi, mari kita bayangkan.  Apa yang umum dalam pengembangan IT, tidak hanya di frontend, backend atau desain, bahasa pemrograman, manajemen, metodologi dan terus?  Saya kira ada satu prinsip utama - dekomposisi dan komponen. <br><br>  Apakah kita mau atau tidak, apakah kita mengerti apa yang kita tulis atau tidak, kita bekerja dengan komponen, kita selalu menguraikan tugas menjadi yang lebih kecil. <br><br>  Dan berkumpul untuk jutaan kali untuk menulis implementasi tabel selanjutnya untuk perangkat UI-indah dalam diri kita, saya pikir - pekerjaan awal apa yang harus saya lakukan?  Apa sebenarnya yang harus ditulis?  Dan mulai dari mana? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/600/120/eb4/600120eb4a5523a073af57d1d56e36b4.png" alt="gambar"><br><br>  Setelah berbicara dengan teman satu tim, saya mendengar beberapa tips.  Saya hanya sangat menyukainya.  Karena saya penggemar singularitas dan sedikit graphql, saya diminta untuk tidak menulis apa pun.  Gunakan tag {table} dan beberapa jaringan saraf akan memproses tabel ini, membuat permintaan graphql, dan mengisi tabel dengan data.  Mudah :) <br>  Tetapi seperti yang mereka katakan - "ada kesalahan fatal dalam sistem apa pun", saya mulai berpikir tentang "bagaimana menciptakan roda saya sendiri".  Dan orang-orang pintar sudah membuat segalanya sebelum kita.  Kami, kaum milenial, hanya dapat mengatur ulang lemping-lemping dan menyebutkan berbagai hal secara berbeda. <br><br>  Saya siap untuk memperkenalkan seperangkat prinsip saya sendiri tentang prototipe kit UI - IDOLS!  Mari lihat! <br><br>  Saya adalah singkatan dari antarmuka segregasi, D singkatan dari Ketergantungan inversi, O berdiri ... hanya bercanda, tentu saja, itu SOLID <br><br>  Semua upaya untuk memformalkan kerja dengan komponen dikurangi menjadi ini.  Prinsip-prinsip ini dapat diperluas tanpa batas, tetapi semuanya selalu hasil akhirnya dikurangi menjadi lima.  Jika kita, tentu saja, berbicara tentang OOP atau CBP (pemrograman berbasis komponen). <br><br>  Mari memuat prinsip-prinsip ini ke dalam "RAM" kami dan membahas poin-poinnya. <br><br><h3>  S - Tanggung Jawab Tunggal </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/512/df3/3b6/512df33b63f26500f8925f172b4a9915.gif" alt="gambar"><br>  Hmm, tolong jangan ... <br><br>  Gunakan komponen khusus untuk berbagai kasus.  Anda TIDAK boleh membuat komponen, yang akan dapat memotong sesuatu dan merenggut sesuatu pada saat yang bersamaan.  Buat dua bagian berbeda. <br><br><h3>  O - Buka / Tutup </h3><br>  Prinsip tersebut mengatakan bahwa komponen Anda harus terbuka untuk perbaikan dan ditutup untuk modifikasi, dengan kata lain, Anda dapat menggunakan kembali komponen Anda dalam komponen lain, tetapi Anda tidak boleh mengubah komponen Anda jika sudah mematuhi prinsip tanggung jawab tunggal. <br><br><h3>  L - substitusi Liskov </h3><br>  Perluasan kecil dari prinsip sebelumnya, setiap instance dari subclass dapat digunakan sebagai pengganti instance dari kelas dasar.  Saya tidak yakin bagaimana prinsip ini sesuai dengan konteks komponen, kemungkinan besar itu hanya duplikasi dari prinsip sebelumnya. <br><br><h3>  I - Segregasi antarmuka </h3><br>  Kita akan membicarakan ini lebih jauh, sekarang kita dapat mengatakan bahwa lebih baik memberi pengembang lain banyak antarmuka kecil daripada yang besar tetapi untuk semuanya.  Mari kita bandingkan contoh di bawah ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b5b/7bb/981/b5b7bb981c678f483ebed5cf91971716.png" alt="gambar"><br>  Semuanya mengonfigurasi di satu tempat, tidak dapat dipertahankan, tidak dapat digunakan kembali ... <br><br><img src="https://habrastorage.org/getpro/habr/post_images/576/dc0/c47/576dc0c47a3c8edc5f21ecb64153f42b.png" alt="gambar"><br>  Semuanya sebagai konstruktor, berkumpul sesuai keinginan dan kenyamanan Anda <br><br><h3>  D - Ketergantungan inversi </h3><br>  Prinsip bahwa berbagai bagian aplikasi tidak boleh tahu apa-apa tentang satu sama lain, dan harus diwariskan hanya melalui antarmuka umum.  Di sini kita berbicara lebih banyak tentang penggunaan kembali dan mengurangi keterhubungan komponen.  Komponen Tabel tidak perlu tahu dari mana dan bagaimana data berasal, hanya perlu mengetahui DataLoader bersyarat, yang bisa berupa apa saja. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3cf/7c7/a9a/3cf7c7a9a29d4616f239367d4c13027f.png" alt="gambar"><br><br>  Tetapi satu sudut pandang tidak cukup bagi kita.  Karena dalam situasi ini, sangat mudah untuk menjadi sandera pada ide ini.  Oleh karena itu, kami melihat pengembangan komponen di sisi lain, dari sisi desain. <br><br>  Dalam hal ini, kami akan mempertimbangkan salah satu pendekatan desain yang semakin populer, yaitu desain atom.  Secara relatif, desain atom adalah cara lain untuk menguraikan elemen UI dengan membandingkannya dengan hierarki dari fisika dan biologi. <br><br>  Jadi mari kita lihat, apa itu desain atomik. <br><br><h3>  Token </h3><br>  Level pertama adalah token, seseorang memasukkan ini dalam model, seseorang tidak, tetapi perlu disebutkan.  Token (warna, ukuran font, jarak, animasi) adalah primitif yang dapat kita gunakan kembali pada platform apa pun. <br><br>  Perlu dicatat bahwa semakin tinggi kita dalam hierarki dalam desain atom, semakin banyak kegunaan kembali menurun.  Tetapi lebih lanjut tentang itu nanti. <br><br><h3>  Atom </h3><br>  Berikutnya adalah atom (komponen sederhana tanpa logika, input, tombol).  Level pertama adalah di mana komponen muncul dan apa yang mereka output.  Atom tidak memiliki keadaan apa pun, hanya menampilkan markup bergaya statis. <br><br><h3>  Molekul </h3><br>  Atom-atom kemudian berkumpul menjadi molekul (ikatan komponen yang lebih kompleks).  Molekul dapat memiliki keadaan sendiri, tetapi ini bukan keadaan bisnis, itu bisa menjadi keadaan konfigurasi (seperti isOpen).  Kita dapat menebak bahwa molekul lebih seperti proksi antara kondisi bisnis teratas dan bagaimana kita menyelaraskan konten atom atau anak-anak kita bergantung pada kondisi ini. <br><br>  Molekul adalah level terakhir tempat kita dapat memenuhi gaya. <br><br><h3>  Organisme </h3><br>  Molekul membentuk organisme (kelompok kerja komponen yang tidak terpisahkan), misalnya, header, footer dan sebagainya.  Organisme tidak tahu apa-apa tentang organisme dan gaya lain, ini adalah "wadah DNA" logika bisnis kami, yang tahu bagaimana menunjukkan ini dan kapan harus diubah. <br><br><h3>  Templat / Halaman </h3><br>  Satu tingkat terakhir dari desain atom.  Level ini mewakili kelompok organisme, yang termasuk halaman saat ini. <br><br>  Kita dapat membuat komposisi organisme pada halaman melalui molekul dan kemudian menyebut halaman itu sebagai "tata letak" dan menggunakannya kembali mengubah organisme kita di dalamnya. <br><br>  Dengan menggunakan dua pendekatan ini (SOLID dan Atom), kami akan mencoba merumuskan beberapa rekomendasi saat mengembangkan komponen.  Jadi, rekomendasi itu akan diperlukan bagi kita untuk memahami, apa sebenarnya yang kita lakukan ketika kita mengatakan "membuat komponen satu lagi". <br><br>  Menimbang bahwa, komponen-komponen ini akan bekerja dengan pengembang lain, kami akan mengingat ini ketika kami akan meletakkan antarmuka dan API. <br><br>  Kita dapat mulai mengembangkan antarmuka ideal kita. <br><br>  Hal pertama yang harus Anda lakukan adalah jangan mulai mengembangkan antarmuka yang ideal.  Antarmuka yang ideal adalah kekurangannya.  Antarmuka adalah penghalang antara apa yang Anda lakukan dan kapan mulai bekerja.  Ini adalah rasa sakit, yang harus dihindari. <br><br>  Dengan demikian, solusi terbaik adalah sebagai berikut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b78/283/6cc/b782836ccaf89f564af263a1dc2eb274.png" alt="gambar"><br>  Ini dengan lancar membawa kita ke yang berikut: <br><br><h3>  1. Tentukan status komponen </h3><br>  Jika pengembang yang menggunakan komponen ini melihatnya untuk pertama kali, lakukan sedikit penyesuaian untuk itu, terjemahkan komponen ke status baru saat kompleksitas pengaturan meningkat dan beri tahu pengembang tentang hal itu. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9a0/57c/fab/9a057cfab3b778d2db16ff7781442a0f.png" alt="gambar"><br><br>  Negara-negara dapat sangat berbeda pada waktu yang berbeda. <br>  Kosong → Mengunduh → Memuat → Memuat bagian lain → Penuh → Kesalahan, dll. <br>  Bimbing pengembang melalui semua kemungkinan kombinasi negara, ajari mereka saat mereka bekerja. <br><br>  Ketika berhadapan dengan masalah negara, seseorang secara tidak sengaja menemukan masalah status default.  Karena itu, rekomendasi kedua. <br><br><h3>  2. Tetapkan nilai default </h3><br>  Dengan item ini, Anda dapat membunuh dua burung dengan satu batu, Anda tidak hanya memberikan informasi dasar kepada pengembang apa yang terjadi dengan aplikasi tetapi untuk Anda, tidak adanya satu atau variabel lain tidak akan menjadi kejutan yang merusak segalanya.  Juga, pemeriksaan jelek untuk keberadaan mereka pada prinsipnya tidak diperlukan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/af5/319/7d2/af53197d2ee168059b47030a793bf8a8.png" alt="gambar"><br><br>  Lebih lanjut, jika pengembang masih ingin menambahkan pengaturan, perlu membantunya dalam hal ini, dan tidak ikut campur. <br><br>  Dengan teori Richard Gregory, orang menjelajahi dunia di sekitar mereka berdasarkan pengalaman visual sebelumnya.  Dan jika komponen Anda mengubah sesuatu di bawah kapnya dan Anda ingin memberi tahu pengembang tentang hal itu, maka hubungi hook dan callback Anda dengan mudah. <br><br><h3>  3. Tidak perlu menemukan kembali roda </h3><br>  Bukan changePasswordInputValue, tetapi onChange, karena jika itu adalah "molekul" Anda, akan selalu jelas apa nilainya akan berubah. <br><br>  Nah, coba ikuti aturan penamaan umum, awalan on untuk acara, kata kerja untuk tindakan, dan jika Anda menggunakan bendera boolean yang Dinonaktifkan di satu tempat, lalu gunakan di mana-mana, Anda tidak perlu lagi Diaktifkan, konsisten. <br><br>  Hal berikutnya yang harus Anda perhatikan adalah bahwa ketika Anda selesai mengerjakan komponen, Anda meneruskannya, pengembang lain akan bekerja dengannya lebih jauh.  Dan jika ada yang tidak beres dengan komponen Anda, Anda harus memulai lingkaran pengembangan baru: pengembang menemukan bug atau tidak dapat melakukan sesuatu yang mereka inginkan → membuka masalah → Anda mencari waktu untuk memperbaikinya → mempertimbangkan konsistensi → memperbaiki → perbarui paket → umumkan ke pengembang → perbarui paket → coba lakukan apa yang mereka inginkan seminggu yang lalu. <br><br><h3>  4. Cobalah memberi pengembang sebanyak mungkin kendali </h3><br>  Seolah-olah mereka menulis komponen ini sekarang - kesimpulan langsung dari salah satu prinsip SOLID <br>  Misalkan Anda membiarkan sepotong teks diteruskan ke komponen Anda.  Jika teks ini ada, maka akan ditampilkan, tetapi Anda juga ingat aturan tentang status default dan menulis kondisi bahwa jika teks tidak dikirim, maka tunjukkan teks default.  Jadi, dengan nada yang baik, itu akan memberikan pengembang secara eksplisit menunjukkan bahwa teks tidak diperlukan di sini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c4c/a1a/730/c4ca1a7300df915ee720aeaf1d211d31.png" alt="gambar"><br><br>  Nah, jika Anda menganggap bahwa pertama-tama kami mulai bekerja dengan komponen atom, maka rekomendasi berikut berasal dari sini. <br><br><h3>  5. Jaga komponen Anda tetap bersih dan kering agar abstraksi tidak bocor (KISS). </h3><br>  Bagaimana cara mengikuti ini?  - sederhananya, jangan menulis kode di komponen Anda.  Hanya templat dan cara menggambar data input.  Jika Anda perlu membuat peta, memfilter, mengurangi data, Anda memiliki konstanta yang tidak dapat didefinisikan ulang di luar, templat Anda menggunakan literal, yang salah - ini bukan atom lagi, tetapi sesuatu yang lain, lebih sulit untuk dipertahankan.  Ini harus dihindari. <br><br>  Jadi, kami mendapat daftar rekomendasi yang akan bagus untuk diikuti. <br><br><ol><li>  Tentukan status </li><li>  Tetapkan nilai default </li><li>  Jangan menemukan kembali roda </li><li>  Biarkan mereka (devs) berkuasa </li><li>  Keep It Simple, Stupid (KISS) </li></ol><br>  Tetapi otak kita diatur sedemikian rupa sehingga setelah menulis beberapa tiga komponen - kita mulai berpikir bahwa kita tidak perlu melihat daftar ini untuk memeriksa semua poin.  Dan kita tahu bahwa di antara tugas yang lebih kompleks dan yang lebih mudah, kita selalu memilih yang lebih mudah karena berfungsi seperti itu.  Kami senang menghemat energi kami, kami membutuhkannya, sebagai cadangan.  Oleh karena itu, daftar tersebut selalu hilang dalam pertemuan sampai waktu yang lebih baik, dan kami terus memperbaiki bug ke master. <br><br>  Hanya jika kita memahami bahwa menjadikannya bijaksana untuk kita, secara umum, akan lebih mudah daripada tidak tidur selama dua minggu berturut-turut, memperbaiki bug dalam produksi, kita akan membuat tugas lebih sulit (untuk alasan obyektif) dan lebih mudah (untuk kita alasan). <br><br>  Lalu bagaimana cara menipu otak kita dan membuat rekomendasi bekerja? <br><br>  Baiklah, mari kita coba untuk mengotomatisasi ini. <br><br><h3>  Otomatisasi </h3><br>  Kita dapat menggunakan bundel eslint + lefthook atau alat git-hook lainnya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca4/d27/576/ca4d27576be845430a6c9f8f63266e17.png" alt="gambar"><br><br>  Kami menjelaskan aturan bagaimana kami ingin melihat variabel kami dan bagaimana kode kami harus ditata.  Kami melarang angka ajaib dan literal dalam templat, kami berharap dari kami bahwa kami akan segera menulis dok untuk kode kami.  Kami menutup cek ini untuk hook git dan mendapatkan pemberitahuan otomatis bahwa kode kami buruk dan harus diperbarui. <br><br>  Tapi ini bukan peluru perak dan kami tidak bisa memenuhi semua rekomendasi.  Hanya sebagian. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/011/93c/bd8/01193cbd83fd6e04332f434db6a41ddb.png" alt="gambar"><br><br>  Dengan cara ini, kita tidak dapat menangani kemungkinan keadaan kita dan tidak dapat menjamin bahwa devs lain akan mendapatkan apa yang mereka inginkan.  Kami hanya dapat berasumsi, misalnya, bahwa sesuatu akan tetap kembali (alias nilai default) tetapi tidak lebih. <br><br>  Maka Anda bisa mencoba cara lain.  Kembangkan komponen kami melalui SDD.  Pengembangan Didorong Storybook. <br><br><h3>  Pengembangan didorong Storybook </h3><br>  Kami memiliki file cerita dalam bentuk di mana kami menggambarkan semua kemungkinan status komponen.  Dan sebuah buku cerita mengumpulkan cerita-cerita ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3d4/cd7/ae4/3d4cd7ae4d32a947e46e20302ceed45e.png" alt="gambar"><br>  Kisah kami tentang komponen <br><br><img src="https://habrastorage.org/getpro/habr/post_images/74b/33a/4e8/74b33a4e84ead0e44854f1d217222e11.png" alt="gambar"><br>  Bagaimana buku cerita menunjukkan cerita kepada kita <br><br>  Mengembangkan komponen Anda secara terpisah dari lingkungan kerja tidak hanya merupakan nilai tambah bagi kemurnian komponen, tetapi juga akan memungkinkan Anda untuk segera melihat status mana yang tidak tercakup oleh pengujian, dan yang, pada prinsipnya, tidak ada. <br><br>  Tetapi pada akhirnya, ini juga tidak akan memberi kita semua yang kita inginkan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d1f/cd1/000/d1fcd1000db741827c30f198dd5caf1d.png" alt="gambar"><br><br>  Karena itu, hanya satu hal yang tersisa. <br><br><h3>  Tes dan Snapshots </h3><br>  Karena komponen kami adalah atom dan molekul, menjadi menyenangkan untuk menulis unit test, setiap komponen bertanggung jawab untuk satu fungsi yang dapat dengan mudah kita uji dengan membuang beberapa item dari daftar rekomendasi sekaligus. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eb3/1e7/454/eb31e7454245f6427aa2667263a1b8b5.png" alt="gambar"><br><br>  Kami dapat mengatur pemeriksaan snapshot, yang akan memungkinkan kami untuk memantau keadaan komponen kami dan mempelajari semua perubahan di masa depan. <br><br>  Kita dapat menggunakan bundel dengan enzim untuk mengendalikan harapan kita selama pengembangan.  Dan anehnya, ketika datang ke rekomendasi di mana kita mengharapkan sesuatu dari pengembang yang menulis kode, hanya tes dan tulisan mereka yang paling sesuai.  Mereka benar-benar diciptakan untuk ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/012/7de/3e7/0127de3e73e263b686cb9fbe8f7d0dea.png" alt="gambar"><br><br>  Dan ini dia ... <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0f8/e0d/adf/0f8e0dadfc1c7d70455e70a06f691ce1.png" alt="gambar"><br><br>  Tulis tes untuk komponen Anda.  Terima kasih. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481528/">https://habr.com/ru/post/id481528/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481510/index.html">Optimalisasi Persatuan: bagaimana hierarki adegan mencuri Anda</a></li>
<li><a href="../id481516/index.html">Kompleksitas berolahraga pesawat ruang angkasa</a></li>
<li><a href="../id481518/index.html">Profesional Manajemen Proyek (PMP): Edisi 6 Apa? Mengapa dan mengapa?</a></li>
<li><a href="../id481522/index.html">Di bar yang lebih rendah, atau melawan anggapan kewarasan</a></li>
<li><a href="../id481524/index.html">Audit Serentak Selama Voting Elektronik</a></li>
<li><a href="../id481530/index.html">Nevanger: Umpan untuk kecepatan</a></li>
<li><a href="../id481532/index.html">Forensik memori, Bebek Karet dan kata sandi GPO. Pemecahan masalah dengan r0ot-mi. Bagian 2</a></li>
<li><a href="../id481534/index.html">Is Delphi Dying - False</a></li>
<li><a href="../id481536/index.html">Sejarah sistem nama domain: protokol "perang"</a></li>
<li><a href="../id481538/index.html">20 mitos SEO untuk mati pada tahun 2020</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>