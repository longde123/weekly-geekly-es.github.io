<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õ™Ô∏è ‚úçüèø üåÄ Padr√µes de procedimentos que podem ser usados ‚Äã‚Äãcom cart√µes lado a lado üêÄ üõ∂ ‚≠êÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A gera√ß√£o de procedimentos √© usada para aumentar a variabilidade dos jogos. Projetos conhecidos incluem Minecraft , Enter the Gungeon e Descenders . N...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Padr√µes de procedimentos que podem ser usados ‚Äã‚Äãcom cart√µes lado a lado</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471084/">  A gera√ß√£o de procedimentos √© usada para aumentar a variabilidade dos jogos.  Projetos conhecidos incluem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Minecraft</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Enter the Gungeon</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Descenders</a> .  Neste post, explicarei alguns dos algoritmos que podem ser usados ‚Äã‚Äãao trabalhar com o sistema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tilemap</a> , que apareceu como uma fun√ß√£o 2D no Unity 2017.2 e com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RuleTile</a> . <br><br>  Com a cria√ß√£o processual de mapas, cada jogo que passa ser√° √∫nico.  Voc√™ pode usar v√°rios dados de entrada, como hora ou n√≠vel atual do jogador, para alterar dinamicamente o conte√∫do, mesmo ap√≥s a montagem do jogo. <br><br><h2>  Sobre o que √© este post? </h2><br>  Veremos algumas das maneiras mais comuns de criar mundos procedimentais, bem como algumas varia√ß√µes que eu criei.  Aqui est√° um exemplo do que voc√™ pode criar depois de ler o artigo.  Tr√™s algoritmos trabalham juntos para criar um mapa usando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tilemap</a> e o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RuleTile</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/349/44e/154/34944e154f324b508701b42877494500.gif"></div><br>  No processo de gerar um mapa usando qualquer algoritmo, obtemos uma matriz <code>int</code> contendo todos os novos dados.  Voc√™ pode continuar a modificar esses dados ou renderiz√°-los em um mapa de blocos. <br><a name="habracut"></a><br>  Antes de ler mais, seria bom saber o seguinte: <br><br><ol><li>  Distinguimos o que √© um bloco e o que n√£o est√° usando valores bin√°rios.  1 √© uma pe√ßa, 0 √© a sua aus√™ncia. </li><li>  Armazenaremos todos os cart√µes em um array inteiro bidimensional retornado ao usu√°rio no final de cada fun√ß√£o (exceto aquele em que a renderiza√ß√£o √© realizada). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Usarei a</a> fun√ß√£o de matriz <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GetUpperBound ()</a> para obter a altura e a largura de cada mapa, para que a fun√ß√£o receba menos vari√°veis ‚Äã‚Äãe o c√≥digo seja mais limpo. </li><li>  Costumo usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mathf.FloorToInt ()</a> , porque o sistema de coordenadas Tilemap √© iniciado no canto inferior esquerdo, e Mathf.FloorToInt () permite arredondar n√∫meros para um n√∫mero inteiro. </li><li>  Todo o c√≥digo nesta postagem est√° escrito em C #. </li></ol><br><h2>  Gera√ß√£o de matriz </h2><br>  GenerateArray cria uma nova matriz <code>int</code> do tamanho especificado.  Tamb√©m podemos indicar se a matriz deve ser preenchida ou vazia (1 ou 0).  Aqui est√° o c√≥digo: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] GenerateArray(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> empty) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[width, height]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">0</span></span>); x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">1</span></span>); y++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (empty) { map[x, y] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { map[x, y] = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> map; }</code> </pre> <br><h2>  Renderiza√ß√£o de mapa </h2><br>  Esta fun√ß√£o √© usada para renderizar um mapa em um mapa de blocos.  Fazemos um loop pela largura e altura do mapa, colocando blocos somente quando a matriz no ponto testado tiver o valor 1. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RenderMap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[,] map, Tilemap tilemap, TileBase tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Clear the map (ensures we dont overlap) tilemap.ClearAllTiles(); //Loop through the width of the map for (int x = 0; x &lt; map.GetUpperBound(0) ; x++) { //Loop through the height of the map for (int y = 0; y &lt; map.GetUpperBound(1); y++) { // 1 = tile, 0 = no tile if (map[x, y] == 1) { tilemap.SetTile(new Vector3Int(x, y, 0), tile); } } } }</span></span></code> </pre> <br><h2>  Atualiza√ß√£o do mapa </h2><br>  Esta fun√ß√£o √© usada apenas para atualizar o mapa e n√£o para renderizar novamente.  Gra√ßas a isso, podemos usar menos recursos sem redesenhar cada bloco e seus dados. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateMap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[,] map, Tilemap tilemap</span></span></span><span class="hljs-function">) </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//Takes in our map and tilemap, setting null tiles where needed { for (int x = 0; x &lt; map.GetUpperBound(0); x++) { for (int y = 0; y &lt; map.GetUpperBound(1); y++) { //We are only going to update the map, rather than rendering again //This is because it uses less resources to update tiles to null //As opposed to re-drawing every single tile (and collision data) if (map[x, y] == 0) { tilemap.SetTile(new Vector3Int(x, y, 0), null); } } } }</span></span></span></span></code> </pre> <br><h2>  Perlin de ru√≠do </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O ru√≠do Perlin</a> pode ser usado para v√°rios prop√≥sitos.  Primeiro, podemos us√°-lo para criar a camada superior do nosso mapa.  Para fazer isso, basta obter um novo ponto usando a posi√ß√£o atual xe seed. <br><br><h3>  Solu√ß√£o simples </h3><br>  Este m√©todo de gera√ß√£o usa a forma mais simples de realiza√ß√£o do ru√≠do Perlin na gera√ß√£o de n√≠veis.  Podemos usar a fun√ß√£o Unity para ru√≠do Perlin, para n√£o escrevermos o c√≥digo.  Tamb√©m usaremos apenas n√∫meros inteiros para o mapa de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">blocos</a> , usando a fun√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mathf.FloorToInt ()</a> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] PerlinNoise(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seed) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newPoint; <span class="hljs-comment"><span class="hljs-comment">//Used to reduced the position of the Perlin point float reduction = 0.5f; //Create the Perlin for (int x = 0; x &lt; map.GetUpperBound(0); x++) { newPoint = Mathf.FloorToInt((Mathf.PerlinNoise(x, seed) - reduction) * map.GetUpperBound(1)); //Make sure the noise starts near the halfway point of the height newPoint += (map.GetUpperBound(1) / 2); for (int y = newPoint; y &gt;= 0; y--) { map[x, y] = 1; } } return map; }</span></span></code> </pre> <br>  Aqui est√° o que parece depois da renderiza√ß√£o em um mapa de blocos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d18/ab8/4e1/d18ab84e1e13fa2f8480424cfecc3de5.gif"></div><br><h3>  Suaviza√ß√£o </h3><br>  Voc√™ tamb√©m pode pegar esta fun√ß√£o e suaviz√°-la.  Defina intervalos para fixar as alturas de Perlin e execute a suaviza√ß√£o entre esses pontos.  Essa fun√ß√£o ser√° um pouco mais complicada, pois para intervalos voc√™ precisa considerar listas de valores inteiros. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] PerlinNoiseSmooth(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seed, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> interval) { <span class="hljs-comment"><span class="hljs-comment">//Smooth the noise and store it in the int array if (interval &gt; 1) { int newPoint, points; //Used to reduced the position of the Perlin point float reduction = 0.5f; //Used in the smoothing process Vector2Int currentPos, lastPos; //The corresponding points of the smoothing. One list for x and one for y List&lt;int&gt; noiseX = new List&lt;int&gt;(); List&lt;int&gt; noiseY = new List&lt;int&gt;(); //Generate the noise for (int x = 0; x &lt; map.GetUpperBound(0); x += interval) { newPoint = Mathf.FloorToInt((Mathf.PerlinNoise(x, (seed * reduction))) * map.GetUpperBound(1)); noiseY.Add(newPoint); noiseX.Add(x); } points = noiseY.Count;</span></span></code> </pre> <br>  Na primeira parte desta fun√ß√£o, primeiro verificamos se o intervalo √© maior que um.  Nesse caso, gere ru√≠do.  A gera√ß√£o √© realizada em intervalos para que a suaviza√ß√£o possa ser aplicada.  A pr√≥xima parte da fun√ß√£o √© suavizar os pontos. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Start at 1 so we have a previous position already for (int i = 1; i &lt; points; i++) { //Get the current position currentPos = new Vector2Int(noiseX[i], noiseY[i]); //Also get the last position lastPos = new Vector2Int(noiseX[i - 1], noiseY[i - 1]); //Find the difference between the two Vector2 diff = currentPos - lastPos; //Set up what the height change value will be float heightChange = diff.y / interval; //Determine the current height float currHeight = lastPos.y; //Work our way through from the last x to the current x for (int x = lastPos.x; x &lt; currentPos.x; x++) { for (int y = Mathf.FloorToInt(currHeight); y &gt; 0; y--) { map[x, y] = 1; } currHeight += heightChange; } } }</span></span></code> </pre> <br>  A suaviza√ß√£o √© realizada da seguinte maneira: <br><br><ol><li>  Temos a posi√ß√£o atual e a √∫ltima </li><li>  Temos a diferen√ßa entre dois pontos, a informa√ß√£o mais importante que precisamos √© a diferen√ßa ao longo do eixo y </li><li>  Em seguida, determinamos o quanto a altera√ß√£o precisa ser feita para chegar ao ponto; isso √© feito dividindo a diferen√ßa em y pela vari√°vel de intervalo. </li><li>  Em seguida, come√ßamos a definir posi√ß√µes, indo at√© zero </li><li>  Quando atingirmos 0 no eixo y, adicione a mudan√ßa de altura √† altura atual e repita o processo para a pr√≥xima posi√ß√£o x </li><li>  Terminando com cada posi√ß√£o entre a √∫ltima e a atual, passamos para o pr√≥ximo ponto </li></ol><br>  Se o intervalo for menor que um, simplesmente usaremos a fun√ß√£o anterior, que far√° todo o trabalho por n√≥s. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Defaults to a normal Perlin gen map = PerlinNoise(map, seed); } return map;</span></span></code> </pre> <br>  Vamos dar uma olhada na renderiza√ß√£o: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91d/e8f/112/91de8f112bb1aa4bbd139245a1c8c215.gif"></div><br><h2>  Passeio aleat√≥rio </h2><br><h3>  Passeio aleat√≥rio </h3><br>  Esse algoritmo executa um lan√ßamento de moeda.  Podemos obter um de dois resultados.  Se o resultado for ‚Äú√°guia‚Äù, subimos um bloco para cima, se o resultado for ‚Äúcoroa‚Äù, ent√£o movemos o bloco para baixo.  Isso cria alturas, movendo-se constantemente para cima ou para baixo.  A √∫nica desvantagem de um algoritmo desse tipo √© o seu bloqueio muito percept√≠vel.  Vamos dar uma olhada em como isso funciona. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] RandomWalkTop(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seed) { <span class="hljs-comment"><span class="hljs-comment">//Seed our random System.Random rand = new System.Random(seed.GetHashCode()); //Set our starting height int lastHeight = Random.Range(0, map.GetUpperBound(1)); //Cycle through our width for (int x = 0; x &lt; map.GetUpperBound(0); x++) { //Flip a coin int nextMove = rand.Next(2); //If heads, and we aren't near the bottom, minus some height if (nextMove == 0 &amp;&amp; lastHeight &gt; 2) { lastHeight--; } //If tails, and we aren't near the top, add some height else if (nextMove == 1 &amp;&amp; lastHeight &lt; map.GetUpperBound(1) - 2) { lastHeight++; } //Circle through from the lastheight to the bottom for (int y = lastHeight; y &gt;= 0; y--) { map[x, y] = 1; } } //Return the map return map; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57b/791/cd4/57b791cd49bb1c967e994638406371a8.gif"></div><br>  <i>Parte superior aleat√≥ria da caminhada com anti-aliasing</i> <br><br>  Essa gera√ß√£o nos proporciona alturas mais suaves em compara√ß√£o com a gera√ß√£o de ru√≠do Perlin. <br><br>  Essa varia√ß√£o do Random Walk fornece um resultado muito mais suave em compara√ß√£o com a vers√£o anterior.  Podemos implement√°-lo adicionando mais duas vari√°veis ‚Äã‚Äã√† fun√ß√£o: <br><br><ul><li>  A primeira vari√°vel √© usada para determinar quanto tempo leva para manter a altura atual.  √â inteiro e √© redefinido quando a altura muda </li><li>  A segunda vari√°vel √© inserida na fun√ß√£o e √© usada como a largura m√≠nima da se√ß√£o para altura.  Tornar-se-√° mais claro quando examinarmos a fun√ß√£o. </li></ul><br>  Agora sabemos o que adicionar.  Vamos dar uma olhada na fun√ß√£o: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] RandomWalkTopSmoothed(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seed, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minSectionWidth) { <span class="hljs-comment"><span class="hljs-comment">//Seed our random System.Random rand = new System.Random(seed.GetHashCode()); //Determine the start position int lastHeight = Random.Range(0, map.GetUpperBound(1)); //Used to determine which direction to go int nextMove = 0; //Used to keep track of the current sections width int sectionWidth = 0; //Work through the array width for (int x = 0; x &lt;= map.GetUpperBound(0); x++) { //Determine the next move nextMove = rand.Next(2); //Only change the height if we have used the current height more than the minimum required section width if (nextMove == 0 &amp;&amp; lastHeight &gt; 0 &amp;&amp; sectionWidth &gt; minSectionWidth) { lastHeight--; sectionWidth = 0; } else if (nextMove == 1 &amp;&amp; lastHeight &lt; map.GetUpperBound(1) &amp;&amp; sectionWidth &gt; minSectionWidth) { lastHeight++; sectionWidth = 0; } //Increment the section width sectionWidth++; //Work our way from the height down to 0 for (int y = lastHeight; y &gt;= 0; y--) { map[x, y] = 1; } } //Return the modified map return map; }</span></span></code> </pre> <br>  Como voc√™ pode ver no gif mostrado abaixo, suavizar o algoritmo de passeio aleat√≥rio permite obter belos segmentos planos no n√≠vel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c1/baf/b53/7c1bafb53bda68f46d617fa4ee2f5c11.gif"></div><br><h2>  Conclus√£o </h2><br>  Espero que este artigo o inspire a usar a gera√ß√£o procedural em seus projetos.  Se voc√™ quiser saber mais sobre mapas gerados proceduralmente, explore os excelentes recursos do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Wiki de Gera√ß√£o de Procedimento</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Roguebasin.com</a> . <br><br>  Na segunda parte do artigo, usaremos a gera√ß√£o procedural para criar sistemas de cavernas. <br><br><h2>  Parte 2 </h2><br>  Tudo o que discutiremos nesta parte pode ser encontrado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste projeto</a> .  Voc√™ pode baixar ativos e experimentar seus pr√≥prios algoritmos processuais. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/349/44e/154/34944e154f324b508701b42877494500.gif"></div><br><h1>  Perlin de ru√≠do </h1><br>  Na parte anterior, vimos maneiras de aplicar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ru√≠do Perlin</a> para criar as camadas superiores.  Felizmente, o ru√≠do de Perlin tamb√©m pode ser usado para criar uma caverna.  Isso √© realizado calculando o novo valor de ru√≠do Perlin, que recebe os par√¢metros da posi√ß√£o atual multiplicados pelo modificador.  O modificador √© um valor de 0 a 1. Quanto maior o valor do modificador, mais ca√≥tica ser√° a gera√ß√£o do Perlin.  Em seguida, arredondamos esse valor para o n√∫mero inteiro (0 ou 1), que armazenamos na matriz do mapa.  Veja como isso √© implementado: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] PerlinNoiseCave(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> modifier, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> edgesAreWalls) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newPoint; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">0</span></span>); x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">1</span></span>); y++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edgesAreWalls &amp;&amp; (x == <span class="hljs-number"><span class="hljs-number">0</span></span> || y == <span class="hljs-number"><span class="hljs-number">0</span></span> || x == map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">0</span></span>) - <span class="hljs-number"><span class="hljs-number">1</span></span> || y == map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">1</span></span>) - <span class="hljs-number"><span class="hljs-number">1</span></span>)) { map[x, y] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//Keep the edges as walls } else { //Generate a new point using Perlin noise, then round it to a value of either 0 or 1 newPoint = Mathf.RoundToInt(Mathf.PerlinNoise(x * modifier, y * modifier)); map[x, y] = newPoint; } } } return map; }</span></span></code> </pre> <br>  Usamos o modificador em vez da semente porque os resultados da gera√ß√£o de Perlin parecem melhores quando multiplicados por um n√∫mero de 0 a 0,5.  Quanto menor o valor, mais irregular ser√° o resultado.  D√™ uma olhada nos resultados da amostra.  O GIF come√ßa com um valor modificador de 0,01 e atinge incrementalmente um valor de 0,25. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/760/abb/891/760abb891c7f225803aecc64c24af5ed.gif"></div><br>  A partir deste gif, pode-se ver que a gera√ß√£o Perlin a cada incremento simplesmente aumenta o padr√£o. <br><br><h1>  Passeio aleat√≥rio </h1><br>  Na parte anterior, vimos que voc√™ pode usar um sorteio para determinar onde a plataforma se mover√° para cima ou para baixo.  Nesta parte, usaremos a mesma ideia, mas <br>  com duas op√ß√µes adicionais para deslocamento √† esquerda e √† direita.  Essa varia√ß√£o do algoritmo Random Walk nos permite criar cavernas.  Para fazer isso, selecionamos uma dire√ß√£o aleat√≥ria, depois movemos nossa posi√ß√£o e exclu√≠mos o bloco.  Continuamos esse processo at√© atingir o n√∫mero necess√°rio de pe√ßas que precisam ser destru√≠das.  At√© agora, usamos apenas 4 dire√ß√µes: cima, baixo, esquerda, direita. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] RandomWalkCave(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seed, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> requiredFloorPercent) { <span class="hljs-comment"><span class="hljs-comment">//Seed our random System.Random rand = new System.Random(seed.GetHashCode()); //Define our start x position int floorX = rand.Next(1, map.GetUpperBound(0) - 1); //Define our start y position int floorY = rand.Next(1, map.GetUpperBound(1) - 1); //Determine our required floorAmount int reqFloorAmount = ((map.GetUpperBound(1) * map.GetUpperBound(0)) * requiredFloorPercent) / 100; //Used for our while loop, when this reaches our reqFloorAmount we will stop tunneling int floorCount = 0; //Set our start position to not be a tile (0 = no tile, 1 = tile) map[floorX, floorY] = 0; //Increase our floor count floorCount++;</span></span></code> </pre> <br>  A fun√ß√£o come√ßa com o seguinte: <br><br><ol><li>  Encontre a posi√ß√£o inicial </li><li>  Calcule o n√∫mero de pisos a serem exclu√≠dos. </li><li>  Exclua o bloco na posi√ß√£o inicial </li><li>  Adicione um ao n√∫mero de pe√ßas. </li></ol><br>  Ent√£o passamos para o <code>while</code> .  Ele criar√° uma caverna: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (floorCount &lt; reqFloorAmount) { <span class="hljs-comment"><span class="hljs-comment">//Determine our next direction int randDir = rand.Next(4); switch (randDir) { //Up case 0: //Ensure that the edges are still tiles if ((floorY + 1) &lt; map.GetUpperBound(1) - 1) { //Move the y up one floorY++; //Check if that piece is currently still a tile if (map[floorX, floorY] == 1) { //Change it to not a tile map[floorX, floorY] = 0; //Increase floor count floorCount++; } } break; //Down case 1: //Ensure that the edges are still tiles if ((floorY - 1) &gt; 1) { //Move the y down one floorY--; //Check if that piece is currently still a tile if (map[floorX, floorY] == 1) { //Change it to not a tile map[floorX, floorY] = 0; //Increase the floor count floorCount++; } } break; //Right case 2: //Ensure that the edges are still tiles if ((floorX + 1) &lt; map.GetUpperBound(0) - 1) { //Move the x to the right floorX++; //Check if that piece is currently still a tile if (map[floorX, floorY] == 1) { //Change it to not a tile map[floorX, floorY] = 0; //Increase the floor count floorCount++; } } break; //Left case 3: //Ensure that the edges are still tiles if ((floorX - 1) &gt; 1) { //Move the x to the left floorX--; //Check if that piece is currently still a tile if (map[floorX, floorY] == 1) { //Change it to not a tile map[floorX, floorY] = 0; //Increase the floor count floorCount++; } } break; } } //Return the updated map return map; }</span></span></code> </pre> <br><h3>  O que estamos fazendo aqui? </h3><br>  Bem, primeiro, com a ajuda de um n√∫mero aleat√≥rio, escolhemos a dire√ß√£o a seguir.  Em seguida, verificamos a nova dire√ß√£o com a <code>switch case</code> .  Nesta declara√ß√£o, verificamos se a posi√ß√£o √© uma parede.  Caso contr√°rio, exclua o elemento com o bloco da matriz.  Continuamos a fazer isso at√© atingir a √°rea desejada.  O resultado √© mostrado abaixo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c6/fc1/86c/2c6fc186c67095e13c1dcbea4c95aff4.gif"></div><br>  Eu tamb√©m criei minha pr√≥pria vers√£o dessa fun√ß√£o, que tamb√©m inclui instru√ß√µes diagonais.  O c√≥digo da fun√ß√£o √© bastante longo; portanto, se voc√™ quiser v√™-lo, fa√ßa o download do projeto no link no in√≠cio desta parte do artigo. <br><br><h1>  T√∫nel direcional </h1><br>  Um t√∫nel direcional come√ßa em uma borda do mapa e atinge a borda oposta.  Podemos controlar a curvatura e a rugosidade do t√∫nel passando-os para a fun√ß√£o de entrada.  Tamb√©m podemos definir o comprimento m√≠nimo e m√°ximo das partes do t√∫nel.  Vamos dar uma olhada na implementa√ß√£o: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] DirectionalTunnel(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minPathWidth, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxPathWidth, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxPathChange, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> roughness, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> curvyness) { <span class="hljs-comment"><span class="hljs-comment">//This value goes from its minus counterpart to its positive value, in this case with a width value of 1, the width of the tunnel is 3 int tunnelWidth = 1; //Set the start X position to the center of the tunnel int x = map.GetUpperBound(0) / 2; //Set up our random with the seed System.Random rand = new System.Random(Time.time.GetHashCode()); //Create the first part of the tunnel for (int i = -tunnelWidth; i &lt;= tunnelWidth; i++) { map[x + i, 0] = 0; }</span></span></code> </pre> <br><h3>  O que est√° havendo? </h3><br>  Primeiro, definimos o valor da largura.  O valor da largura passar√° do valor com menos para positivo.  Gra√ßas a isso, obteremos o tamanho necess√°rio.  Nesse caso, usamos o valor 1, que por sua vez nos dar√° uma largura total de 3, porque usamos os valores -1, 0, 1. <br><br>  Em seguida, definimos a posi√ß√£o inicial em x, para isso ocupamos o meio da largura do mapa.  Depois disso, podemos colocar um t√∫nel na primeira parte do mapa. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/605/0a7/552/6050a75522b8d628722d5373ddee8c76.png"></div><br>  Agora vamos entrar no resto do mapa. <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//Cycle through the array for (int y = 1; y &lt; map.GetUpperBound(1); y++) { //Check if we can change the roughness if (rand.Next(0, 100) &gt; roughness) { //Get the amount we will change for the width int widthChange = Random.Range(-maxPathWidth, maxPathWidth); //Add it to our tunnel width value tunnelWidth += widthChange; //Check to see we arent making the path too small if (tunnelWidth &lt; minPathWidth) { tunnelWidth = minPathWidth; } //Check that the path width isnt over our maximum if (tunnelWidth &gt; maxPathWidth) { tunnelWidth = maxPathWidth; } } //Check if we can change the curve if (rand.Next(0, 100) &gt; curvyness) { //Get the amount we will change for the x position int xChange = Random.Range(-maxPathChange, maxPathChange); //Add it to our x value x += xChange; //Check we arent too close to the left side of the map if (x &lt; maxPathWidth) { x = maxPathWidth; } //Check we arent too close to the right side of the map if (x &gt; (map.GetUpperBound(0) - maxPathWidth)) { x = map.GetUpperBound(0) - maxPathWidth; } } //Work through the width of the tunnel for (int i = -tunnelWidth; i &lt;= tunnelWidth; i++) { map[x + i, y] = 0; } } return map; }</span></span></code> </pre> <br>  Geramos um n√∫mero aleat√≥rio para compara√ß√£o com o valor da rugosidade e, se for maior que esse valor, a largura do caminho pode ser alterada.  Tamb√©m verificamos o valor para n√£o tornar a largura muito pequena.  Na pr√≥xima parte do c√≥digo, percorremos o mapa.  Em cada est√°gio, ocorre o seguinte: <br><br><ol><li>  Geramos um novo n√∫mero aleat√≥rio comparado com o valor da curvatura.  Como no teste anterior, se for maior que o valor, alteramos o ponto central do caminho.  Tamb√©m realizamos uma verifica√ß√£o para n√£o ir al√©m do mapa. </li><li>  Finalmente, estamos colocando um t√∫nel na parte rec√©m-criada. </li></ol><br>  Os resultados desta implementa√ß√£o s√£o assim: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d25/bd4/d34/d25bd4d348871f08fcb383c3508ab25f.gif"></div><br><h1>  Aut√¥matos celulares </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aut√¥matos celulares</a> usam c√©lulas vizinhas para determinar se a c√©lula atual est√° ativada (1) ou desativada (0).  A base para determinar as c√©lulas vizinhas √© criada com base em uma grade de c√©lulas gerada aleatoriamente.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Geraremos</a> essa grade de origem usando a fun√ß√£o C # <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Random.Next</a> . <br><br>  Como temos algumas implementa√ß√µes diferentes de aut√¥matos celulares, escrevi uma fun√ß√£o separada para gerar essa grade b√°sica.  A fun√ß√£o fica assim: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] GenerateCellularAutomata(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seed, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fillPercent, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> edgesAreWalls) { <span class="hljs-comment"><span class="hljs-comment">//Seed our random number generator System.Random rand = new System.Random(seed.GetHashCode()); //Initialise the map int[,] map = new int[width, height]; for (int x = 0; x &lt; map.GetUpperBound(0); x++) { for (int y = 0; y &lt; map.GetUpperBound(1); y++) { //If we have the edges set to be walls, ensure the cell is set to on (1) if (edgesAreWalls &amp;&amp; (x == 0 || x == map.GetUpperBound(0) - 1 || y == 0 || y == map.GetUpperBound(1) - 1)) { map[x, y] = 1; } else { //Randomly generate the grid map[x, y] = (rand.Next(0, 100) &lt; fillPercent) ? 1 : 0; } } } return map; }</span></span></code> </pre> <br>  Nesta fun√ß√£o, voc√™ tamb√©m pode definir se nossa grade precisa de paredes.  Em todos os outros aspectos, √© bastante simples.  Verificamos um n√∫mero aleat√≥rio com porcentagem de preenchimento para determinar se a c√©lula atual est√° ativada.  Veja o resultado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/585/bfa/9ec/585bfa9ec7953056e160af10b4efbc88.gif"></div><br><h2>  O bairro de Moore </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O bairro de Moore √©</a> usado para suavizar a gera√ß√£o inicial de aut√¥matos celulares.  O bairro de Moore fica assim: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30b/c02/328/30bc02328e772a2955aa071bfdbc2cc6.png"></div><br>  As seguintes regras se aplicam ao bairro: <br><br><ul><li>  Verificamos o vizinho em cada uma das dire√ß√µes. </li><li>  Se o vizinho for um bloco ativo, adicione um ao n√∫mero de blocos circundantes. </li><li>  Se o vizinho √© um bloco inativo, n√£o fazemos nada. </li><li>  Se uma c√©lula tiver mais de 4 blocos adjacentes, ative a c√©lula. </li><li>  Se a c√©lula tiver exatamente 4 blocos adjacentes, n√£o faremos nada com ela. </li><li>  Repita at√© verificarmos cada bloco do mapa. </li></ul><br>  A fun√ß√£o de verifica√ß√£o de vizinhan√ßa de Moore √© a seguinte: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMooreSurroundingTiles</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[,] map, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> edgesAreWalls</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* Moore Neighbourhood looks like this ('T' is our tile, 'N' is our neighbours) * * NNN * NTN * NNN * */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tileCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> neighbourX = x - <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbourX &lt;= x + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbourX++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> neighbourY = y - <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbourY &lt;= y + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbourY++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbourX &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; neighbourX &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; neighbourY &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; neighbourY &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">1</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">//We don't want to count the tile we are checking the surroundings of if(neighbourX != x || neighbourY != y) { tileCount += map[neighbourX, neighbourY]; } } } } return tileCount; }</span></span></code> </pre> <br>  Depois de verificar o ladrilho, usamos essas informa√ß√µes na fun√ß√£o de suaviza√ß√£o.  Aqui, como na gera√ß√£o de aut√¥matos celulares, pode-se indicar se as bordas do mapa devem ser paredes. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] SmoothMooreCellularAutomata(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> edgesAreWalls, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> smoothCount) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; smoothCount; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">0</span></span>); x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">1</span></span>); y++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> surroundingTiles = GetMooreSurroundingTiles(map, x, y, edgesAreWalls); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edgesAreWalls &amp;&amp; (x == <span class="hljs-number"><span class="hljs-number">0</span></span> || x == (map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">0</span></span>) - <span class="hljs-number"><span class="hljs-number">1</span></span>) || y == <span class="hljs-number"><span class="hljs-number">0</span></span> || y == (map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">1</span></span>) - <span class="hljs-number"><span class="hljs-number">1</span></span>))) { <span class="hljs-comment"><span class="hljs-comment">//Set the edge to be a wall if we have edgesAreWalls to be true map[x, y] = 1; } //The default moore rule requires more than 4 neighbours else if (surroundingTiles &gt; 4) { map[x, y] = 1; } else if (surroundingTiles &lt; 4) { map[x, y] = 0; } } } } //Return the modified map return map; }</span></span></code> </pre> <br>  √â importante observar aqui que a fun√ß√£o possui um loop <code>for</code> que executa a suaviza√ß√£o do n√∫mero especificado de vezes.  Gra√ßas a isso, um cart√£o mais bonito √© obtido. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68f/082/25c/68f08225c0c31cb243969192744f7b16.gif"></div><br>  Sempre podemos modificar esse algoritmo conectando salas se, por exemplo, houver apenas dois blocos entre elas. <br><br><h2>  Bairro Von Neumann </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O bairro de von Neumann</a> √© outra maneira popular de implementar aut√¥matos celulares.  Para essa gera√ß√£o, usamos um bairro mais simples do que na gera√ß√£o Moore.  O bairro fica assim: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/952/d30/66c/952d3066c638932947db9c9a95ee36bf.png"></div><br>  As seguintes regras se aplicam ao bairro: <br><br><ul><li>  Verificamos os vizinhos imediatos do bloco, sem considerar os diagonais. </li><li>  Se a c√©lula estiver ativa, adicione um √† quantidade. </li><li>  Se a c√©lula estiver inativa, n√£o fa√ßa nada. </li><li>  Se a c√©lula tiver mais de 2 vizinhos, ativamos a c√©lula atual. </li><li>  Se a c√©lula tiver menos de 2 vizinhos, tornaremos a c√©lula atual inativa. </li><li>  Se houver exatamente 2 vizinhos, n√£o altere a c√©lula atual. </li></ul><br>  O segundo resultado usa os mesmos princ√≠pios que o primeiro, mas expande a √°rea do bairro. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verificamos vizinhos com a seguinte fun√ß√£o: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetVNSurroundingTiles</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[,] map, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> edgesAreWalls</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* von Neumann Neighbourhood looks like this ('T' is our Tile, 'N' is our Neighbour) * * N * NTN * N * */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tileCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//Keep the edges as walls if(edgesAreWalls &amp;&amp; (x - 1 == 0 || x + 1 == map.GetUpperBound(0) || y - 1 == 0 || y + 1 == map.GetUpperBound(1))) { tileCount++; } //Ensure we aren't touching the left side of the map if(x - 1 &gt; 0) { tileCount += map[x - 1, y]; } //Ensure we aren't touching the bottom of the map if(y - 1 &gt; 0) { tileCount += map[x, y - 1]; } //Ensure we aren't touching the right side of the map if(x + 1 &lt; map.GetUpperBound(0)) { tileCount += map[x + 1, y]; } //Ensure we aren't touching the top of the map if(y + 1 &lt; map.GetUpperBound(1)) { tileCount += map[x, y + 1]; } return tileCount; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tendo recebido o n√∫mero de vizinhos, podemos prosseguir para suavizar a matriz. </font><font style="vertical-align: inherit;">Como antes, precisamos de um loop </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para concluir o n√∫mero de itera√ß√µes de suaviza√ß√£o passadas para a entrada.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] SmoothVNCellularAutomata(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> edgesAreWalls, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> smoothCount) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; smoothCount; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">0</span></span>); x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">1</span></span>); y++) { <span class="hljs-comment"><span class="hljs-comment">//Get the surrounding tiles int surroundingTiles = GetVNSurroundingTiles(map, x, y, edgesAreWalls); if (edgesAreWalls &amp;&amp; (x == 0 || x == map.GetUpperBound(0) - 1 || y == 0 || y == map.GetUpperBound(1))) { //Keep our edges as walls map[x, y] = 1; } //von Neuemann Neighbourhood requires only 3 or more surrounding tiles to be changed to a tile else if (surroundingTiles &gt; 2) { map[x, y] = 1; } else if (surroundingTiles &lt; 2) { map[x, y] = 0; } } } } //Return the modified map return map; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como voc√™ pode ver abaixo, o resultado final √© muito mais complicado do que o bairro de Moore: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c15/fcd/1bb/c15fcd1bb16d2451b47fb7d37aea1f9b.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aqui, como nas proximidades de Moore, voc√™ pode executar um script adicional para otimizar as conex√µes entre as partes do mapa. </font></font><br><br><h1>  Conclus√£o </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espero que este artigo o inspire a usar algum tipo de gera√ß√£o processual em seus projetos. </font><font style="vertical-align: inherit;">Se voc√™ n√£o fez o download do projeto, pode obt√™-lo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt471084/">https://habr.com/ru/post/pt471084/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt471072/index.html">Quanto gramas em telegrama?</a></li>
<li><a href="../pt471074/index.html">Synet - uma estrutura para o lan√ßamento de redes neurais pr√©-treinadas na CPU</a></li>
<li><a href="../pt471076/index.html">Como a Matrix criou um legado √† prova de balas</a></li>
<li><a href="../pt471078/index.html">O Chrome bloquear√° completamente o conte√∫do misto</a></li>
<li><a href="../pt471080/index.html">Quem √© respons√°vel pela qualidade de testar o aplicativo? 10 raz√µes para obter erros na produ√ß√£o</a></li>
<li><a href="../pt471086/index.html">Gerador de capa de m√∫sica Python no Blender</a></li>
<li><a href="../pt471088/index.html">Especialistas em TI Burn Out: 4 hist√≥rias do gerente, desenvolvedor, produto e administrador. E a receita de Southbridge</a></li>
<li><a href="../pt471090/index.html">[N√£o] use CDN</a></li>
<li><a href="../pt471092/index.html">Comando cp: copiando pastas de arquivo para * nix corretamente</a></li>
<li><a href="../pt471094/index.html">O Tutu.ru e o Clube de Programadores de Moscou s√£o convidados para uma reuni√£o de back-end em 17 de outubro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>