<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòô ‚ôçÔ∏è üóÇÔ∏è Uma hist√≥ria sobre V8, React e uma queda no desempenho. Parte 1 üìª üï§ üåÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O material, a primeira parte da tradu√ß√£o publicada hoje, discutir√° como o mecanismo JavaScript da V8 seleciona as melhores maneiras de representar v√°r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Uma hist√≥ria sobre V8, React e uma queda no desempenho. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/467247/">  O material, a primeira parte da tradu√ß√£o publicada hoje, discutir√° como o mecanismo JavaScript da V8 seleciona as melhores maneiras de representar v√°rios valores JS na mem√≥ria e como isso afeta os mecanismos internos da V8 em rela√ß√£o ao trabalho com os chamados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">formul√°rios. objetos</a> (Forma).  Tudo isso nos ajudar√° a descobrir a ess√™ncia do recente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">problema de desempenho do React</a> . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/pu/wk/8i/puwk8ihuo_in6vqmeg86j2-5sxa.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Tipos de dados JavaScript</font> </h2><br>  Cada valor JavaScript pode ter apenas um dos oito tipos de dados existentes: <code>Number</code> , <code>String</code> , <code>Symbol</code> , <code>BigInt</code> , <code>Boolean</code> , <code>Undefined</code> , <code>Null</code> e <code>Object</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36e/5e0/3fb/36e5e03fb481b601d2bb1cc61a1fa2f4.png"></div><br>  <i><font color="#999999">Tipos de dados JavaScript</font></i> <br><br>  O tipo de valor pode ser determinado usando o operador <code>typeof</code> , mas h√° uma exce√ß√£o importante: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 'number' typeof 'foo'; // 'string' typeof Symbol('bar'); // 'symbol' typeof 42n; // 'bigint' typeof true; // 'boolean' typeof undefined; // 'undefined' typeof null; // 'object' -   ,     typeof { x: 42 }; // 'object'</span></span></code> </pre> <br>  Como voc√™ pode ver, o comando <code>typeof null</code> retorna <code>'object'</code> , n√£o <code>'null'</code> , apesar do fato de o <code>null</code> ter seu pr√≥prio tipo - <code>Null</code> .  Para entender o motivo desse <code>typeof</code> comportamento, levamos em considera√ß√£o o fato de que o conjunto de todos os tipos de JavaScript pode ser dividido em dois grupos: <br><br><ul><li>  Objetos (ou seja, digite <code>Object</code> ). </li><li>  Valores primitivos (ou seja, quaisquer valores n√£o-objetivos). </li></ul><br>  √Ä luz desse conhecimento, verifica-se que <code>null</code> significa "sem valor de objeto", enquanto <code>undefined</code> significa "sem valor". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e9/8e6/c97/0e98e6c97b3e87411146a60f1c67cf8e.png"></div><br>  <i><font color="#999999">Valores primitivos, objetos, nulos e indefinidos</font></i> <br><br>  Seguindo essas reflex√µes no esp√≠rito de Java, Brendan Eich projetou o JavaScript para que o operador <code>typeof</code> retornasse <code>'object'</code> para os valores desses tipos que est√£o localizados na figura anterior √† direita.  Todos os valores de objetos e <code>null</code> chegam aqui.  √â por isso que a express√£o <code>typeof null === 'object'</code> √© verdadeira, embora exista um tipo separado <code>Null</code> na especifica√ß√£o da linguagem. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/23e/df7/0e2/23edf70e2101cc687a759653f150305d.png"></div><br>  <i><font color="#999999">A express√£o typeof v === 'object' √© verdadeira</font></i> <br><br><h2>  <font color="#3AC1EF">Representa√ß√£o de valores</font> </h2><br>  Os mecanismos JavaScript devem poder representar quaisquer valores JavaScript na mem√≥ria.  No entanto, √© importante observar que os tipos de valor em JavaScript s√£o separados de como os mecanismos JS os representam na mem√≥ria. <br><br>  Por exemplo, um valor de 42 no JavaScript √© do tipo <code>number</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 'number'</span></span></code> </pre> <br>  Existem v√°rias maneiras de representar n√∫meros inteiros como 42 na mem√≥ria: <br><div class="scrollable-table"><table><tbody><tr><td>  Submiss√£o <br></td><td>  Bits <br></td></tr><tr><td>  8 bits, al√©m de dois <br></td><td>  0010 1010 <br></td></tr><tr><td>  32 bits, com adi√ß√£o de at√© dois <br></td><td>  0000 0000 0000 0000 0000 0000 0010 1010 <br></td></tr><tr><td>  Decimal com c√≥digo bin√°rio (BCD) compactado <br></td><td>  0100 0010 <br></td></tr><tr><td>  32 bits, n√∫mero de ponto flutuante IEEE-754 <br></td><td>  0 100 0010 0010 1000 0000 0000 0000 0000 <br></td></tr><tr><td>  64 bits, n√∫mero de ponto flutuante IEEE-754 <br></td><td>  0100 0000 0100 0101 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 <br></td></tr></tbody></table></div><br>  De acordo com o padr√£o ECMAScript, os n√∫meros s√£o valores de ponto flutuante de 64 bits, conhecidos como n√∫meros de ponto flutuante de precis√£o dupla (Float64).  No entanto, isso n√£o significa que os mecanismos JavaScript sempre armazenem n√∫meros em uma exibi√ß√£o do Float64.  Isso seria muito, muito ineficiente!  Os mecanismos podem usar outras representa√ß√µes internas de n√∫meros - desde que o comportamento dos valores corresponda exatamente ao comportamento dos n√∫meros do Float64. <br><br>  A maioria dos n√∫meros em aplicativos JS reais, como se viu, s√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√≠ndices de</a> matriz ECMAScript v√°lidos.  Ou seja - n√∫meros inteiros no intervalo de 0 a 2 <sup>32</sup> -2. <br><br><pre> <code class="javascript hljs">array[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//      . array[42]; array[2**32-2]; //      .</span></span></code> </pre> <br>  Os mecanismos JavaScript podem escolher o formato ideal para representar esses valores na mem√≥ria.  Isso √© feito para otimizar o c√≥digo que funciona com elementos da matriz usando √≠ndices.  Um processador que executa opera√ß√µes de acesso √† mem√≥ria precisa que os √≠ndices da matriz estejam dispon√≠veis como n√∫meros armazenados em uma exibi√ß√£o com a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">adi√ß√£o de dois</a> .  Se, em vez disso, representarmos os √≠ndices de matrizes na forma de valores do Float64, isso significaria um desperd√≠cio de recursos do sistema, pois o mecanismo precisaria converter os n√∫meros do Float64 em um formato com adi√ß√£o de dois e vice-versa sempre que algu√©m acessar um elemento da matriz. <br><br>  A representa√ß√£o de n√∫meros de 32 bits com a adi√ß√£o de at√© dois √© √∫til n√£o apenas para otimizar o trabalho com matrizes.  Em geral, pode-se notar que o processador executa opera√ß√µes inteiras muito mais rapidamente do que as opera√ß√µes que usam valores de ponto flutuante.  √â por isso que, no exemplo a seguir, o primeiro ciclo sem problemas √© duas vezes mais r√°pido em compara√ß√£o com o segundo ciclo. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; ++i) {  <span class="hljs-comment"><span class="hljs-comment">//  } for (let i = 0.1; i &lt; 1000.1; ++i) {  //  }</span></span></code> </pre> <br>  O mesmo se aplica aos c√°lculos usando operadores matem√°ticos. <br><br>  Por exemplo, o desempenho do operador de retirar o restante da divis√£o do pr√≥ximo fragmento de c√≥digo depende de quais n√∫meros est√£o envolvidos nos c√°lculos. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> remainder = value % divisor; <span class="hljs-comment"><span class="hljs-comment">//  -  `value`  `divisor`   , //    .</span></span></code> </pre> <br>  Se os dois operandos s√£o representados por n√∫meros inteiros, o processador pode calcular o resultado com muita efici√™ncia.  H√° otimiza√ß√£o adicional no V8 para casos em que o operando do <code>divisor</code> √© representado por um n√∫mero com pot√™ncia de dois.  Para valores representados como n√∫meros de ponto flutuante, os c√°lculos s√£o muito mais complicados e demoram muito mais. <br><br>  Como as opera√ß√µes com n√∫meros inteiros geralmente s√£o executadas muito mais rapidamente do que as opera√ß√µes com valores de ponto flutuante, pode parecer que os mecanismos sempre podem armazenar todos os n√∫meros inteiros e todos os resultados de opera√ß√µes com n√∫meros inteiros em um formato com adi√ß√£o de dois.  Infelizmente, essa abordagem violaria a especifica√ß√£o ECMAScript.  Como j√° mencionado, o padr√£o fornece a representa√ß√£o de n√∫meros no formato Float64, e algumas opera√ß√µes com n√∫meros inteiros podem levar ao aparecimento de resultados na forma de n√∫meros de ponto flutuante.  √â importante que, nessas situa√ß√µes, os mecanismos JS produzam resultados corretos. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Float64   53-  . //         . 2**53 === 2**53+1; // true // Float64   ,   -1 * 0   -0,  //           . -1*0 === -0; // true // Float64   Infinity,   , //     . 1/0 === Infinity; // true -1/0 === -Infinity; // true // Float64    NaN. 0/0 === NaN;</span></span></code> </pre> <br>  Embora no exemplo anterior todos os n√∫meros no lado esquerdo das express√µes sejam n√∫meros inteiros, todos os n√∫meros no lado direito das express√µes s√£o valores de ponto flutuante.  √â por isso que nenhuma das opera√ß√µes anteriores pode ser executada corretamente usando um formato de 32 bits com uma adi√ß√£o de at√© duas.  Os mecanismos JavaScript precisam prestar aten√ß√£o especial para garantir que, ao executar opera√ß√µes com n√∫meros inteiros, voc√™ obtenha os resultados Float64 corretos (embora capazes de parecer incomuns - como no exemplo anterior). <br><br>  No caso de n√∫meros inteiros pequenos que se enquadram no intervalo da representa√ß√£o de 31 bits de n√∫meros inteiros assinados, o V8 usa uma representa√ß√£o especial chamada <code>Smi</code> .  Tudo o que n√£o √© um valor <code>Smi</code> √© representado como um valor <code>HeapObject</code> , que √© o endere√ßo de alguma entidade na mem√≥ria.  Para n√∫meros que n√£o se enquadram no intervalo <code>Smi</code> , temos um tipo especial de <code>HeapObject</code> - o chamado <code>HeapNumber</code> . <br><br><pre> <code class="javascript hljs">-<span class="hljs-literal"><span class="hljs-literal">Infinity</span></span> <span class="hljs-comment"><span class="hljs-comment">// HeapNumber -(2**30)-1 // HeapNumber  -(2**30) // Smi       -42 // Smi        -0 // HeapNumber         0 // Smi       4.2 // HeapNumber        42 // Smi   2**30-1 // Smi     2**30 // HeapNumber  Infinity // HeapNumber       NaN // HeapNumber</span></span></code> </pre> <br>  Como voc√™ pode ver no exemplo anterior, alguns n√∫meros JS s√£o representados como <code>Smi</code> e outros como <code>HeapNumber</code> .  O mecanismo V8 √© otimizado em termos de processamento de n√∫meros <code>Smi</code> .  O fato √© que pequenos n√∫meros inteiros s√£o muito comuns em programas JS reais.  Ao trabalhar com valores <code>Smi</code> , n√£o √© necess√°rio alocar mem√≥ria para entidades individuais.  Al√©m disso, seu uso permite executar opera√ß√µes r√°pidas com n√∫meros inteiros. <br><br><h2>  <font color="#3AC1EF">Compara√ß√£o de Smi, HeapNumber e MutableHeapNumber</font> </h2><br>  Vamos falar sobre como √© a estrutura interna desses mecanismos.  Suponha que tenhamos o seguinte objeto: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> o = {  <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-comment"><span class="hljs-comment">// Smi  y: 4.2, // HeapNumber };</span></span></code> </pre> <br>  O valor 42 da propriedade do objeto <code>x</code> √© codificado como <code>Smi</code> .  Isso significa que ele pode ser armazenado dentro do pr√≥prio objeto.  Para armazenar o valor 4.2, por outro lado, voc√™ precisar√° criar uma entidade separada.  No objeto, haver√° um link para esta entidade. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/116/718/f34/116718f3426bccd613dd35dc95be9739.png"></div><br>  <i><font color="#999999">Armazenamento de v√°rios valores</font></i> <br><br>  Suponha que estamos executando o seguinte c√≥digo JavaScript: <br><br><pre> <code class="javascript hljs">ox += <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ox   52 oy += 1; // oy   5.2</span></span></code> </pre> <br>  Nesse caso, o valor da propriedade <code>x</code> pode ser atualizado em seu local de armazenamento.  O fato √© que o novo valor de <code>x</code> √© 52 e esse n√∫mero est√° dentro do intervalo de <code>Smi</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d8/400/d42/4d8400d42a2046c9727d4ff76ad2b483.png"></div><br>  <i><font color="#999999">O novo valor da propriedade x √© armazenado onde o valor anterior foi armazenado.</font></i> <br><br>  No entanto, o novo valor de <code>y</code> , 5.2, n√£o se encaixa no intervalo de <code>Smi</code> e, al√©m disso, difere do valor anterior de y - 4.2.  Como resultado, a V8 precisa alocar mem√≥ria para a nova entidade <code>HeapNumber</code> e referenci√°-la j√° do objeto. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ba/ecf/095/9baecf0951766c6e2781b552593b6b94.png"></div><br>  <i><font color="#999999">Nova entidade HeapNumber para armazenar o novo valor y</font></i> <br><br>  <code>HeapNumber</code> entidades <code>HeapNumber</code> s√£o imut√°veis.  Isso permite implementar algumas otimiza√ß√µes.  Suponha que desejemos definir a propriedade do objeto <code>x</code> valor da propriedade <code>y</code> : <br><br><pre> <code class="javascript hljs">ox = oy; <span class="hljs-comment"><span class="hljs-comment">// ox   5.2</span></span></code> </pre> <br>  Ao executar esta opera√ß√£o, podemos simplesmente nos referir √† mesma entidade <code>HeapNumber</code> e n√£o alocar mem√≥ria adicional para armazenar o mesmo valor. <br><br>  Uma das desvantagens da imunidade das entidades HeapNuber √© que a atualiza√ß√£o frequente de campos com valores fora do intervalo <code>Smi</code> √© lenta.  Isso √© demonstrado no seguinte exemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   `HeapNumber`. const o = { x: 0.1 }; for (let i = 0; i &lt; 5; ++i) {  //    `HeapNumber`.  ox += 1; }</span></span></code> </pre> <br>  Ao processar a primeira linha, √© criada uma inst√¢ncia de <code>HeapNumber</code> , cujo valor inicial √© 0.1.  No corpo do ciclo, esse valor muda para 1.1, 2.1, 3.1, 4.1 e, finalmente, para 5.1.  Como resultado, no processo de execu√ß√£o desse c√≥digo, <code>HeapNumber</code> 6 inst√¢ncias do <code>HeapNumber</code> , cinco das quais ser√£o submetidas a opera√ß√µes de coleta de lixo ap√≥s a conclus√£o do loop. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d10/7e2/8f1/d107e28f181bf1eaf1fd57765bdfe49f.png"></div><br>  <i><font color="#999999">Entidades HeapNumber</font></i> <br><br>  Para evitar esse problema, a V8 possui otimiza√ß√£o, que √© um mecanismo para atualizar campos num√©ricos cujos valores n√£o se enquadram no intervalo <code>Smi</code> nos mesmos locais em que j√° est√£o armazenados.  Se um campo num√©rico armazena valores para os quais a entidade <code>Smi</code> n√£o <code>Smi</code> adequada para armazenamento, a V8, na forma de um objeto, marca esse campo como <code>Double</code> e aloca mem√≥ria para a entidade <code>MutableHeapNumber</code> , que armazena o valor real representado no formato Float64. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a17/c42/466/a17c42466cde98778836809e09df4da6.png"></div><br>  <i><font color="#999999">Usando entidades MutableHeapNumber</font></i> <br><br>  Como resultado, ap√≥s a altera√ß√£o do valor do campo, a V8 n√£o precisa mais alocar mem√≥ria para a nova entidade <code>HeapNumber</code> .  Em vez disso, basta escrever o novo valor em uma entidade <code>MutableHeapNumber</code> existente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c86/3bd/d1c/c863bdd1c81213b080d86bed079e9e5f.png"></div><br>  <i><font color="#999999">Escrevendo um novo valor para MutableHeapNumber</font></i> <br><br>  No entanto, essa abordagem tem suas desvantagens.  Ou seja, como os valores de <code>MutableHeapNumber</code> podem mudar, √© importante garantir que o sistema funcione de maneira que esses valores se comportem conforme fornecido na especifica√ß√£o de idioma. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/176/be3/8ca/176be38cad03b4e4ab2881d7a9b67bfd.png"></div><br>  <i><font color="#999999">Desvantagens do MutableHeapNumber</font></i> <br><br>  Por exemplo, se voc√™ atribuir o valor de <code>ox</code> alguma outra vari√°vel <code>y</code> , precisar√° garantir que o valor de <code>y</code> n√£o seja alterado com uma mudan√ßa subsequente em <code>ox</code> .  Isso seria uma viola√ß√£o da especifica√ß√£o do JavaScript!  Como resultado, ao acessar <code>ox</code> , o n√∫mero deve ser reembalado para o valor <code>HeapNumber</code> usual antes de ser atribu√≠do <code>y</code> . <br><br>  No caso de n√∫meros de ponto flutuante, o V8 executa as opera√ß√µes de empacotamento acima usando seus mecanismos internos.  Por√©m, no caso de n√∫meros inteiros pequenos, usar <code>MutableHeapNumber</code> seria uma perda de tempo, porque <code>Smi</code> √© uma maneira mais eficiente de representar esses n√∫meros. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// ""  `x`    object.x += 1; //   `x`  </span></span></code> </pre> <br>  Para evitar o uso ineficiente dos recursos do sistema, tudo o que precisamos fazer para trabalhar com n√∫meros inteiros pequenos √© marcar os campos correspondentes nas formas de objetos como <code>Smi</code> .  Como resultado, os valores desses campos, desde que correspondam ao intervalo <code>Smi</code> , podem ser atualizados diretamente dentro dos objetos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b6a/d23/b96/b6ad23b9635e31d8f695d7170b8d3d7c.png"></div><br>  <i><font color="#999999">Trabalhar com n√∫meros inteiros cujos valores se enquadram no intervalo de Smi</font></i> <br><br>  Para continuar ... <br><br>  <b>Caros leitores!</b>  Voc√™ encontrou problemas de desempenho do JavaScript causados ‚Äã‚Äãpor recursos do mecanismo JS? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt467247/">https://habr.com/ru/post/pt467247/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt467231/index.html">Apresentando o Login com a Apple no seu aplicativo iOS</a></li>
<li><a href="../pt467237/index.html">Aumente o servidor DNS sobre HTTPS</a></li>
<li><a href="../pt467239/index.html">A diferen√ßa entre o cientista de dados e um adolescente em um carro esportivo</a></li>
<li><a href="../pt467241/index.html">Carrinho de caminh√£o ROS. Parte 4. Criando uma simula√ß√£o de rob√¥ usando os editores rviz e gazebo</a></li>
<li><a href="../pt467245/index.html">Dmitry Matskevich, Dbrain: sobre o empreendedorismo como defici√™ncia mental, IA e seguran√ßa emocional</a></li>
<li><a href="../pt467249/index.html">Uma hist√≥ria sobre V8, React e uma queda no desempenho. Parte 2</a></li>
<li><a href="../pt467251/index.html">Ref√©ns COBOL e Matem√°tica. Parte 1</a></li>
<li><a href="../pt467253/index.html">Ref√©ns COBOL e Matem√°tica. Parte 2</a></li>
<li><a href="../pt467255/index.html">Tr√™s erros comuns de seguran√ßa que todo desenvolvedor de reagentes deve conhecer</a></li>
<li><a href="../pt467257/index.html">N√£o guarde todos os seus ovos em uma cesta de uma s√≥ vez</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>