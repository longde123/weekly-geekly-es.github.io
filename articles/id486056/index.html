<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§ ğŸ™† ğŸï¸ Dari skrip ke platform kami sendiri: bagaimana kami mengotomatiskan pengembangan di Cyan Institute ğŸ‘©ğŸ¼â€ğŸ­ ğŸš£ğŸ¼ ğŸ—“ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di RIT 2019, kolega kami Alexander Korotkov membuat laporan tentang otomatisasi pengembangan di CIAN: untuk menyederhanakan kehidupan dan pekerjaan, k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dari skrip ke platform kami sendiri: bagaimana kami mengotomatiskan pengembangan di Cyan Institute</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/cian/blog/486056/"><img src="https://habrastorage.org/webt/di/vp/_w/divp_woyk4ubltspau3m_ogodkg.png"><br><br>  Di RIT 2019, kolega kami Alexander Korotkov membuat <a href="https://www.youtube.com/watch%3Fv%3D0wvUyjexoIg">laporan</a> tentang otomatisasi pengembangan di CIAN: untuk menyederhanakan kehidupan dan pekerjaan, kami menggunakan platform Integro kami sendiri.  Ini memonitor siklus hidup tugas, menghilangkan operasi rutin dari pengembang, dan secara signifikan mengurangi jumlah bug dalam produksi.  Dalam posting ini kami akan melengkapi laporan Alexander dan memberi tahu Anda bagaimana kami beralih dari skrip sederhana menjadi menggabungkan produk open source melalui platform kami sendiri dan apa yang dilakukan oleh tim otomasi terpisah. <br><a name="habracut"></a><br><h2>  Tingkat nol </h2><br>  <i><b>"Tidak ada level nol, saya tidak tahu ini"</b></i> <i><br></i>  <i>Shifu master dari film "Kung Fu Panda"</i> <br><br>  Otomasi di CIAN dimulai 14 tahun setelah pendirian perusahaan.  Kemudian ada 35 orang di tim pengembangan.  Sulit dipercaya, bukan?  Tentu saja, otomasi memang ada dalam beberapa bentuk, tetapi area terpisah dari integrasi berkelanjutan dan pengiriman kode mulai terbentuk pada tahun 2015. <br><br>  Pada saat itu, kami memiliki monolit besar dari Python, C # dan PHP yang digunakan pada server Linux / Windows.  Untuk penyebaran monster ini, kami memiliki satu set skrip yang kami jalankan secara manual.  Ada juga majelis monolit, menyebabkan rasa sakit dan penderitaan karena konflik ketika menggabungkan cabang, mengedit cacat dan membangun kembali "dengan serangkaian tugas yang berbeda dalam pembangunan."  Proses yang disederhanakan tampak seperti ini: <br><br><img src="https://habrastorage.org/webt/bz/tn/ll/bztnllnatyoaiauwlw0xvvaatde.jpeg"><br><br>  Ini tidak cocok untuk kami, dan kami ingin membangun proses pembangunan dan penyebaran yang berulang, otomatis, dan terkontrol.  Untuk melakukan ini, kami membutuhkan sistem CI / CD, dan kami memilih antara versi gratis dari Teamcity dan Jenkins gratis, karena kami bekerja dengan mereka dan keduanya cocok kami untuk serangkaian fungsi.  Kami memilih Teamcity sebagai produk yang lebih baru.  Kemudian kami tidak menggunakan arsitektur microservice dan tidak mengandalkan banyak tugas dan proyek. <br><br><h2>  Kami sampai pada ide sistem kami sendiri </h2><br>  Implementasi Teamcity hanya menghapus sebagian dari pekerjaan manual: masih ada penciptaan Permintaan Tarik, promosi tugas berdasarkan status di Jira, pemilihan tugas untuk dirilis.  Teamcity tidak bisa lagi mengatasinya.  Itu perlu untuk memilih jalur otomatisasi lebih lanjut.  Kami mempertimbangkan opsi untuk bekerja dengan skrip di Teamcity atau beralih ke sistem otomasi pihak ketiga.  Tetapi pada akhirnya, kami memutuskan bahwa kami membutuhkan fleksibilitas maksimum yang hanya diberikan oleh solusi kami sendiri.  Jadi versi pertama dari sistem otomasi internal yang disebut Integro muncul. <br><br>  Teamcity terlibat dalam otomatisasi pada tingkat awal proses perakitan dan penyebaran, dan Integro telah berfokus pada otomatisasi tingkat atas dari proses pengembangan.  Itu perlu untuk menggabungkan pekerjaan dengan tugas-tugas di Jira dengan memproses kode sumber terkait di Bitbucket.  Pada tahap ini, Integro mulai memiliki alur kerja sendiri untuk bekerja dengan berbagai jenis tugas. <br><br>  Karena peningkatan otomatisasi dalam proses bisnis, jumlah proyek dan berjalan di Teamcity telah meningkat.  Jadi masalah baru muncul: satu instance Teamcity gratis tidak ada (3 agen dan 100 proyek), kami menambahkan contoh lain (3 agen lebih dan 100 proyek), lalu satu lagi.  Akibatnya, kami mendapat sistem beberapa kluster, yang sulit dikelola: <br><br><img src="https://habrastorage.org/webt/hb/gv/rp/hbgvrp2ms-wfixyw-v0wycqjphy.png"><br><br>  Ketika muncul pertanyaan tentang instance 4, kami menyadari bahwa kami tidak bisa hidup seperti itu lagi, karena total biaya untuk mendukung 4 instance tidak lagi sesuai dengan kerangka kerja apa pun.  Muncul pertanyaan untuk membeli Teamcity berbayar atau memilih Jenkins gratis.  Kami melakukan perhitungan pada mesin virtual dan rencana untuk otomatisasi dan memutuskan bahwa kami akan hidup dengan Jenkins.  Setelah beberapa minggu, kami beralih ke Jenkins dan menyingkirkan bagian sakit kepala yang terkait dengan mendukung beberapa instance Teamcity.  Oleh karena itu, kami dapat fokus pada pengembangan Integro dan menyelesaikan Jenkins untuk diri kita sendiri. <br><br>  Dengan tumbuhnya otomatisasi dasar (dalam bentuk pembuatan Permintaan Tarik otomatis, pengumpulan dan publikasi cakupan Kode dan cek lainnya), ada keinginan kuat untuk menolak rilis manual sebanyak mungkin dan memberikan karya ini kepada robot.  Selain itu, perusahaan mulai pindah ke layanan microser, yang membutuhkan rilis sering, dan terpisah satu sama lain.  Jadi kami secara bertahap sampai pada rilis otomatis dari layanan microser kami (untuk saat ini, kami merilis monolith secara manual karena kerumitan prosesnya).  Tetapi, seperti biasanya, kompleksitas baru telah muncul. <br><br><h2>  Pengujian Otomatis </h2><br><img src="https://habrastorage.org/webt/kk/rc/v8/kkrcv8melsazessicjkebzle2s4.jpeg"><br><br>  Karena otomatisasi rilis, proses pengembangan telah dipercepat, sebagian karena melewatkan beberapa tahap pengujian.  Dan ini menyebabkan hilangnya kualitas sementara.  Kedengarannya klise, tetapi seiring dengan percepatan rilis, perlu untuk mengubah metodologi pengembangan produk.  Itu perlu untuk berpikir tentang otomatisasi pengujian, menanamkan tanggung jawab pribadi (di sini kita berbicara tentang "menerima gagasan di kepala", dan bukan denda moneter) dari pengembang untuk kode yang dirilis dan bug di dalamnya, serta tentang keputusan untuk mengeluarkan / tidak mengeluarkan tugas melalui penyebaran otomatis. <br><br>  Menghilangkan masalah kualitas, kami sampai pada dua keputusan penting: kami mulai melakukan pengujian kenari dan menerapkan pemantauan otomatis latar belakang kesalahan dengan respons otomatis terhadap kelebihannya.  Solusi pertama memungkinkan untuk menemukan kesalahan yang jelas sebelum kode sepenuhnya masuk ke produksi, yang kedua mengurangi waktu respons terhadap masalah dalam produksi.  Kesalahan, tentu saja, memang terjadi, tetapi kita menghabiskan sebagian besar waktu dan energi kita bukan pada koreksi, tetapi pada minimalisasi. <br><br><h2>  Tim otomasi </h2><br>  Sekarang kami memiliki staf dari 130 pengembang, dan kami terus <a href="https://habr.com/ru/article/469965/">berkembang</a> .  Tim untuk integrasi berkelanjutan dan pengiriman kode (selanjutnya disebut sebagai tim Deploy and Integration atau DI) terdiri dari 7 orang dan bekerja dalam 2 arah: pengembangan platform otomasi Integro dan DevOps. <br><br>  DevOps bertanggung jawab atas lingkungan Dev / Beta dari situs web CIAN, lingkungan Integro, membantu pengembang untuk memecahkan masalah dan mengembangkan pendekatan baru untuk meningkatkan skala lingkungan.  Lini bisnis Integro berkaitan dengan Integro sendiri dan layanan terkait, misalnya, plug-in untuk Jenkins, Jira, Confluence, dan juga mengembangkan utilitas bantu dan aplikasi untuk tim pengembangan. <br><br>  Tim DI bekerja bersama dengan tim Platform, yang mengembangkan arsitektur, perpustakaan, dan pendekatan pengembangan dalam perusahaan.  Pada saat yang sama, setiap pengembang di dalam CIAN dapat berkontribusi untuk otomatisasi, misalnya, membuat mikroautomasi dengan kebutuhan tim atau berbagi ide keren bagaimana membuat otomasi menjadi lebih baik. <br><br><h2>  Otomatisasi puff pie di cyan </h2><br><img src="https://habrastorage.org/webt/v8/xt/rz/v8xtrzfhj8bp-kzio9qduuixgf4.png"><br><br>  Semua sistem yang terlibat dalam otomasi dapat dibagi menjadi beberapa lapisan: <br><br><ol><li>  Sistem eksternal (Jira, Bitbucket, dll.).  Tim pengembangan bekerja dengan mereka. <br></li><li>  Platform Integro.  Paling sering, pengembang tidak bekerja dengannya secara langsung, tetapi dialah yang mendukung pekerjaan semua otomatisasi. <br></li><li>  Jasa pengiriman, pembuatan dan penemuan (mis. Jeknins, Konsul, Nomad).  Dengan bantuan mereka, kami menyebarkan kode pada server dan saling memberikan layanan. <br></li><li>  Lapisan fisik (server, OS, perangkat lunak terkait).  Pada level ini, kode kita berfungsi.  Ini bisa berupa server fisik atau virtual (LXC, KVM, Docker). <br></li></ol><br>  Berdasarkan konsep ini, kami membagi bidang tanggung jawab dalam tim DI.  Dua level pertama berada di area tanggung jawab area pengembangan Integro, dan dua level terakhir sudah berada di area tanggung jawab DevOps.  Pemisahan ini memungkinkan Anda untuk fokus pada tugas dan tidak mengganggu interaksi, karena kami bersebelahan dan terus bertukar pengetahuan dan pengalaman. <br><br><h2>  Integro </h2><br>  Mari fokus pada Integro dan mulai dengan tumpukan teknologi: <br><br><ul><li>  CentOs 7 <br></li><li>  Docker + Nomad + Konsul + Vault <br></li><li>  Java 11 (monolith Integro lama akan tetap ada di Java 8) <br></li><li>  Spring Boot 2.X + Spring Cloud Config <br></li><li>  PostgreSql 11 <br></li><li>  Rabbitmq <br></li><li>  Apache terbakar <br></li><li>  Camunda (tertanam) <br></li><li>  Grafana + Grafit + Prometheus + Jaeger + ELK <br></li><li>  UI Web: React (CSR) + MobX <br></li><li>  SSO: Keycloak <br></li></ul><br>  Kami mematuhi prinsip pengembangan layanan-mikro, meskipun kami memiliki warisan dalam bentuk monolit dari versi awal Integro.  Setiap microservice berputar dalam wadah buruh pelabuhannya, layanan berkomunikasi satu sama lain melalui permintaan HTTP dan pesan RabbitMQ.  Layanan Microsoft menemukan satu sama lain melalui Konsul dan melaksanakan permintaan untuk itu, melewati otorisasi melalui SSO (Keycloak, OAuth 2 / OpenID Connect). <br><br><img src="https://habrastorage.org/webt/ib/mn/ne/ibmnnec5ijrxrai9mpx_tdiipri.png"><br><br>  Sebagai contoh nyata, pertimbangkan interaksi dengan Jenkins, yang terdiri dari langkah-langkah berikut: <br><br><ol><li>  Layanan microser workflow manajemen (selanjutnya disebut sebagai microservice Flow) ingin menjalankan perakitan di Jenkins.  Untuk melakukan ini, ia menemukan melalui Konsul IP: integrasi layanan perangkat lunak PORT dengan Jenkins (selanjutnya disebut layanan perangkat lunak Jenkins) dan mengiriminya permintaan tidak sinkron untuk memulai perakitan di Jenkins. <br></li><li>  Layanan mikro Jenkins, setelah menerima permintaan tersebut, menghasilkan dan memberikan kembali ID Pekerjaan, yang kemudian memungkinkan untuk mengidentifikasi hasil pekerjaan.  Bersamaan dengan ini, ia mulai membangun di Jenkins melalui panggilan ke REST API. <br></li><li>  Jenkins membangun dan, setelah selesai, mengirimkan webhook dengan hasilnya ke layanan mikro Jenkins. <br></li><li>  Layanan mikro Jenkins, setelah menerima webhook, menghasilkan pesan tentang penyelesaian pemrosesan permintaan dan melampirkan hasil eksekusi padanya.  Pesan yang dihasilkan dikirim ke antrian RabbitMQ. <br></li><li>  Melalui RabbitMQ, pesan yang diterbitkan sampai ke microservice Flow, yang belajar tentang hasil pemrosesan tugasnya dengan mencocokkan ID Pekerjaan dari permintaan dan pesan yang diterima. <br></li></ol><br>  Sekarang kami memiliki sekitar 30 layanan mikro yang dapat dibagi menjadi beberapa kelompok: <br><br><ol><li>  Manajemen konfigurasi. <br></li><li>  Menginformasikan dan berinteraksi dengan pengguna (instant messenger, mail). <br></li><li>  Bekerja dengan kode sumber. <br></li><li>  Integrasi dengan alat penyebaran (jenkins, nomad, konsul, dll.). <br></li><li>  Pemantauan (rilis, bug, dll.). <br></li><li>  Utilitas web (UI untuk mengelola lingkungan pengujian, mengumpulkan statistik, dll.). <br></li><li>  Integrasi dengan pelacak tugas dan sistem serupa. <br></li><li>  Kelola alur kerja untuk berbagai tugas. <br></li></ol><br><h2>  Tugas alur kerja </h2><br>  Integro mengotomatiskan kegiatan yang terkait dengan siklus hidup tugas.  Disederhanakan oleh siklus hidup tugas, maksud kami alur kerja tugas di Jira.  Dalam proses pengembangan kami, ada beberapa variasi alur kerja tergantung pada proyek, jenis tugas dan opsi yang dipilih dalam tugas tertentu. <br><br>  Pertimbangkan alur kerja yang paling sering kita gunakan: <br><br><img src="https://habrastorage.org/webt/yu/va/8x/yuva8xxb7edyldadgxorqwixdtm.jpeg"><br><br>  Dalam diagram, roda gigi menunjukkan bahwa transisi disebut oleh Integro secara otomatis, sedangkan sosok manusia berarti bahwa transisi tersebut secara manual disebut oleh orang tersebut.  Mari kita lihat beberapa cara agar tugas dapat melalui alur kerja ini. <br><br>  Pengujian manual untuk DEV + BETA tanpa tes kenari (biasanya kami merilis monolit): <br><br><img src="https://habrastorage.org/webt/nu/ab/be/nuabbeencu3tzfmryb2wpcya-cy.png"><br><br>  Mungkin ada kombinasi transisi lainnya.  Terkadang jalur yang akan diambil tugas dapat dipilih melalui opsi di Jira. <br><br><h2>  Gerakan tugas </h2><br>  Pertimbangkan langkah-langkah dasar yang dilakukan saat memindahkan tugas pada alur kerja "Pengujian untuk pengujian kenari DEV +": <br><br>  1. Pengembang atau PM menciptakan tugas. <br><br>  2. Pengembang mengambil tugas untuk bekerja.  Setelah selesai, transfer ke status IN REVIEW. <br><br>  3. Jira mengirimkan Webhook menuju microservice Jira (bertanggung jawab untuk integrasi dengan Jira). <br><br>  4. Jira microservice mengirimkan permintaan ke layanan Flow (bertanggung jawab atas alur kerja internal di mana pekerjaan dilakukan) untuk memulai alur kerja. <br><br>  5. Di dalam layanan Flow: <br><br><ul><li>  Peninjau untuk tugas tersebut ditugaskan (Pengguna-microservice yang mengetahui segalanya tentang pengguna + Jira-microservice). </li><li>  Melalui microservice Sumber (ia tahu tentang repositori dan cabang, tetapi tidak bekerja dengan kode itu sendiri), ia mencari repositori di mana ada cabang tugas kami (untuk menyederhanakan pencarian, nama cabang cocok dengan nomor tugas di Jira).  Paling sering, tugas hanya memiliki satu cabang dalam satu repositori, ini menyederhanakan pengelolaan antrian pada penyebaran dan mengurangi konektivitas antara repositori. </li><li>  Untuk setiap cabang yang ditemukan, urutan tindakan berikut dilakukan: <br><br>  i) Memicu cabang utama (Git microservice untuk bekerja dengan kode). <br>  ii) Cabang diblokir dari perubahan oleh pengembang (Bitbucket microservice). <br>  iii) Permintaan Tarik dibuat di cabang ini (Bitbucket microservice). <br>  iv) Pesan tentang Permintaan Tarik baru dikirim ke obrolan pengembang (Beri tahu layanan mikro untuk bekerja dengan notifikasi). <br>  v) Membangun, menguji, dan menyebarkan tugas ke DEV (layanan mikro Jenkins untuk bekerja dengan Jenkins). <br>  vi) Jika semua paragraf sebelumnya telah berhasil diselesaikan, maka Integro menempatkan Approve-nya dalam Pull Request (Bitbucket microservice). </li><li>  Integro mengharapkan Pull Request Approve dari pengulas yang ditunjuk. </li><li>  Segera setelah semua Approve yang diperlukan telah diterima (termasuk pengujian otomatis telah berhasil dilewati), Integro mentransfer tugas ke status Test on Dev (Jira microservice). </li></ul><br>  6. Penguji menguji tugas.  Jika tidak ada masalah, maka mereka mentransfer tugas ke status Ready For Build. <br><br>  7. Integro â€œmelihatâ€ bahwa tugas tersebut siap untuk dirilis, dan meluncurkan penyebarannya dalam mode kenari (Jenkins microservice).  Kesiapan untuk rilis ditentukan oleh seperangkat aturan.  Misalnya, tugas dalam status yang benar, tidak ada kunci pada tugas lain, sekarang tidak ada perhitungan aktif dari layanan Microsoft ini, dll. <br><br>  8. Tugas dipindahkan ke status Canary (Jira-microservice). <br><br>  9. Jenkins memulai melalui Nomad penyebaran tugas dalam mode kenari (biasanya 1-3 instance) dan memberi tahu layanan pemantauan rilis (DeployWatch microservice) dari perhitungan. <br><br>  10. DeployWatch-microservice mengumpulkan kesalahan latar belakang dan menanggapinya jika perlu.  Jika kesalahan latar belakang terlampaui (laju latar belakang dihitung secara otomatis), pengembang akan diberi tahu melalui layanan microser Notify.  Jika setelah 5 menit pengembang tidak merespons (mengklik Kembalikan atau Tetap), maka kembalinya otomatis contoh kenari dimulai.  Jika latar belakang tidak terlampaui, maka pengembang harus secara manual meluncurkan penyebaran tugas pada Produksi (dengan menekan tombol di UI).  Jika dalam waktu 60 menit pengembang tidak meluncurkan penyebaran dalam Produksi, maka instance kenari juga akan dipompa keluar karena alasan keamanan. <br><br>  11. Setelah meluncurkan penyebaran ke Produksi: <br><br><ul><li>  Tugas dipindahkan ke status Produksi (Jira microservice). </li><li>  Jenkins microservice memulai proses penyebaran dan memberi tahu penyebaran microservice DeployWatch. </li><li>  DeployWatch-microservice memverifikasi bahwa semua kontainer diperbarui pada Produksi (ada kasus ketika tidak semua diperbarui). </li><li>  Pemberitahuan tentang hasil penyebaran ke Produksi dikirim melalui layanan pemberitahuan mikro. </li></ul><br>  12. Pengembang akan memiliki waktu 30 menit untuk memulai rollback tugas dengan Production jika terdeteksi perilaku keliru dari layanan microser.  Setelah waktu ini, tugas akan secara otomatis dituangkan ke master (Git-microservice). <br><br>  13. Setelah penggabungan master berhasil, status tugas akan diubah menjadi Tertutup (Jira microservice). <br><br>  Skema ini tidak berpura-pura terperinci sepenuhnya (pada kenyataannya, bahkan ada lebih banyak langkah), tetapi memungkinkan Anda untuk mengevaluasi tingkat integrasi ke dalam proses.  Kami tidak menganggap skema ini ideal dan meningkatkan proses pelacakan rilis dan penyebaran otomatis. <br><br><h2>  Apa selanjutnya </h2><br>  Kami memiliki rencana besar untuk pengembangan otomatisasi, misalnya, penolakan operasi manual selama rilis monolit, peningkatan pemantauan selama penyebaran otomatis, peningkatan interaksi dengan pengembang. <br><br>  Tapi untuk sekarang, mari kita berhenti di tempat ini.  Kami membahas banyak topik secara dangkal dalam tinjauan otomasi, beberapa tidak menyentuhnya sama sekali, jadi kami akan dengan senang hati menjawab pertanyaan.  Kami menunggu saran tentang apa yang akan dibahas secara rinci, tulis di komentar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id486056/">https://habr.com/ru/post/id486056/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id486042/index.html">Pembawa pesan dan telekomunikasi</a></li>
<li><a href="../id486046/index.html">Kernel Linux termasuk WireGuard VPN</a></li>
<li><a href="../id486048/index.html">Apa itu "ini" dan apa yang dimakannya</a></li>
<li><a href="../id486050/index.html">Perpustakaan Webix JavaScript melalui mata seorang pemula. Bagian 3. Modul, diagram, tabel pohon</a></li>
<li><a href="../id486052/index.html">Bumi hangus adalah ibu dari semua game. Wawancara dengan penciptanya</a></li>
<li><a href="../id486060/index.html">Temukan Ketertiban dalam Kekacauan TI: Mengatur Pengembangan Anda Sendiri</a></li>
<li><a href="../id486062/index.html">Render zero-copy sederhana dari video yang dipercepat perangkat keras dalam QML</a></li>
<li><a href="../id486064/index.html">Buat tayangan slide animasi dalam CSS murni.</a></li>
<li><a href="../id486066/index.html">Di area akses. Temukan jarak dari titik ke suatu daerah dan kurangi permintaan geocoding terbalik</a></li>
<li><a href="../id486070/index.html">ACL beralih secara detail</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>