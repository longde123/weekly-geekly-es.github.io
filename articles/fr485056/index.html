<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✉️ 🏳️‍🌈 🌺 Diviser et conquérir 🔤 📃 🚶🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lorsque je travaillais avec une base de données (en particulier avec PostgreSQL), j'ai eu l'idée de sélectionner les données d'une table en parallèle ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Diviser et conquérir</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485056/"><img src="https://habrastorage.org/webt/ad/6e/t3/ad6et3oklrzvpn7ha_iomzmftgw.png"><br>  Lorsque je travaillais avec une base de données (en particulier avec PostgreSQL), j'ai eu l'idée de sélectionner les données d'une table en parallèle (en utilisant Go GoP).  Et je me suis demandé, "est-il possible de scanner des lignes d'échantillons dans des goroutines individuelles?" <br><br>  Il s'est avéré que <b>func (* Rows) Scan</b> ne peut pas être appelé simultanément dans les gourutins.  Sur la base de cette limitation, j'ai décidé d'effectuer d'autres processus en parallèle avec le balayage des chaînes, en particulier la préparation des données résultantes. <br><a name="habracut"></a><br>  Parce que  Scan empile les données selon les pointeurs, j'ai décidé de faire deux tranches (j'expliquerai pourquoi deux plus tard), entre lesquelles je vais basculer Scan, tandis que le reste des gourutins traitera les données déjà sélectionnées. <br><br>  Au départ, j'ai besoin de connaître le nombre d'exemples de colonnes: <br><br><pre><code class="go hljs">columns, err = rows.Columns() count := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(columns)</code> </pre> <br>  Ensuite, je crée deux tranches avec des valeurs et des pointeurs vers ces valeurs (où j'ajouterai des données lors de l'analyse des lignes): <br><br><pre> <code class="go hljs">values := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}, count) valuesPtrs := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}, count) values_ := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}, count) valuesPtrs_ := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}, count) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> columns { valuesPtrs[i] = &amp;values;[i] valuesPtrs_[i] = &amp;values;_[i] }</code> </pre> <br>  Dans cet exemple, j'ajouterai le résultat de la sélection à la chaîne de chaîne [chaîne], où les noms de colonne seront les clés.  Vous pouvez utiliser une structure spécifique indiquant les types, mais depuis  le but de cette publication est de découvrir à partir de la habrasociety à quel point l'approche proposée est viable, arrêtons-nous sur la sélection sur la carte. <br><br>  Ensuite, je sépare deux gorutins, dont l'un formera la carte résultante: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(deleteNullValues </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">, check, finish </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">, dbData </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, columns []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, data *[]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">map</span></span></span></span><span class="hljs-function"><span class="hljs-params">[</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { lnc := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(columns) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> &lt;-check { row := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; lnc; i++ { el := &lt;-dbData b, ok := el.([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ok { row[columns[i]] = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(b) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> el == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> deleteNullValues == <span class="hljs-literal"><span class="hljs-literal">false</span></span> { row[columns[i]] = <span class="hljs-string"><span class="hljs-string">""</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { row[columns[i]] = fmt.Sprint(el) } } } *data = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(*data, row) } finish &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br>  Et la seconde bascule entre deux tranches avec les valeurs générées par Scan et les envoie au canal de la gourutine précédente (qui forme le résultat): <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transferData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(values, values_ []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, dbData </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, swtch, working, check </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> &lt;-working { check &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> &lt;-swtch { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, v := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> values { dbData &lt;- v } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, v := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> values_ { dbData &lt;- v } } } }</code> </pre> <br>  Le processus principal basculera entre les tranches de pointeurs et sélectionnera les données: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rows.Next() { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> chnl { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err = rows.Scan(valuesPtrs...); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"rows.Scan: %s\n%s\n%#v\n"</span></span>, err, query, args) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err = rows.Scan(valuesPtrs_...); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"rows.Scan: %s\n%s\n%#v\n"</span></span>, err, query, args) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } } working &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> swtch &lt;- chnl chnl = !chnl }</code> </pre> <br>  Dans la base de données, j'ai formé un tableau avec 32 colonnes et y ai ajouté 100 000 lignes. <br>  À la suite du test (lors de l'échantillonnage des données 50 fois), j'ai obtenu les données suivantes: <br>  Temps passé: 1m8.022277124s - échantillonnage du résultat à l'aide d'une seule tranche <br>  Temps passé: 1m7.806109441s - échantillonnage du résultat à l'aide de deux tranches <br><br>  Avec une augmentation du nombre d'itérations à 100: <br>  Temps passé: 2m15.973344023s - sélection du résultat à l'aide d'une seule tranche <br>  Temps passé: 2m15.057413845s - échantillonnage du résultat à l'aide de deux tranches <br><br>  La différence augmente avec l'augmentation du volume de données et l'augmentation des colonnes dans le tableau. <br>  Cependant, le résultat inverse a été observé avec une diminution de la quantité de données ou avec une diminution du nombre de colonnes du tableau, ce qui, en principe, est compréhensible, car  les frais généraux des étapes préparatoires et le département gourutin «dévorent» le temps précieux et le résultat est nivelé. <br><br>  En ce qui concerne deux tranches et deux gorutins: j'ai effectué des tests avec un grand nombre de tranches, mais le temps d'échantillonnage a augmenté, car, évidemment, les fonctions getData et transferData traitent les données plus rapidement que l'analyse des valeurs de la base de données.  Par conséquent, même avec un plus grand nombre de cœurs, cela n'a aucun sens d'ajouter de nouvelles tranches pour Scan et des goroutines supplémentaires (sauf pour les volumes de données très sauvages). <br><br>  Dans le code github, je donne un <a href="https://github.com/helginet/gopostgres">exemple de travail de</a> cette approche.  Mes tâches utilisent également d'autres packages, que j'ai supprimés de ce qui précède, mais l'idée principale ne devrait pas en souffrir. <br><br>  En général, j'attends des critiques constructives de la communauté intéressée.  Je vous remercie! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr485056/">https://habr.com/ru/post/fr485056/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr485042/index.html">En raison du support 5G obligatoire, les smartphones avec Snapdragon 865 seront pires en 2020</a></li>
<li><a href="../fr485044/index.html">Nous démontons l'horloge numérique du vaisseau spatial Soyouz</a></li>
<li><a href="../fr485046/index.html">Comment planifier une stratégie de produit gagnante</a></li>
<li><a href="../fr485050/index.html">Hypercube. Comment nous avons fourni aux développeurs des appareils de test et ne les avons pas perdus</a></li>
<li><a href="../fr485052/index.html">Qui est un bon AQ?</a></li>
<li><a href="../fr485058/index.html">"Vérifier l'horloge": ce que l'on sait du nouveau protocole de synchronisation de l'heure du serveur</a></li>
<li><a href="../fr485068/index.html">Code propre pour TypeScript - Partie 2</a></li>
<li><a href="../fr485070/index.html">Andrew Eun "Passion pour l'apprentissage automatique." Traduction des chapitres 36-46</a></li>
<li><a href="../fr485074/index.html">Comment ne pas mourir sur un projet ou 5 hacks de vie</a></li>
<li><a href="../fr485078/index.html">Difficile, vulnérable, sous-configuré: cyber-menaces 2020</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>