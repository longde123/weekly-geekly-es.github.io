<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¢ ğŸ‘©â€â¤ï¸â€ğŸ‘© ğŸ’ Implementasi Awalan Pohon C yang Cunning ğŸ”° â—¼ï¸ ğŸ§•ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Empat bulan telah berlalu sejak publikasi artikel tentang upaya saya pada implementasi pohon awalan tingkat rendah. Terlepas dari semua ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementasi Awalan Pohon C yang Cunning</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428175/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2cf/e02/c47/2cfe02c47506426be25fb36004a78b1d.jpg" alt="gambar"></div><br><h2>  Pendahuluan </h2><br>  Empat bulan telah berlalu sejak publikasi artikel tentang upaya saya pada implementasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pohon awalan</a> tingkat rendah.  Terlepas dari semua upaya saya, langit-langit di mana implementasi saya sebelumnya dari pohon awalan ternyata mampu adalah ~ 80 ribu kata per detik.  Saya kemudian menghabiskan banyak waktu dan energi, tetapi hasilnya akan cocok hanya sebagai pekerjaan laboratorium dalam ilmu komputer. <br><br>  Banyak yang kemudian mengatakan kepada saya: â€œJangan menciptakan sepeda yang sudah kami temukan!  Gunakan solusi turnkey. "  Kesulitannya adalah saya tidak bisa menggunakan sesuatu yang paling tidak saya mengerti secara umum. <br><br>  Saya pikir saya mengerti pohon awalan, dan inilah yang berhasil saya capai. <br><a name="habracut"></a><br><h2>  Prinsip kerja </h2><br>  Saya tidak tahu bahasa Inggris dengan baik, jadi dari banyak artikel yang saya baca tentang topik pohon awalan, beberapa informasi mungkin tidak sampai ke saya.  Oleh karena itu, saya datang dengan cara mengatur semuanya, hanya memahami prinsip dasar pohon awalan.  Bagi mereka yang tidak tahu, saya akan mencoba menggambarkannya lebih jelas daripada yang tertulis di Wikipedia.  Jadi saya menjelaskan apa yang saya lakukan kepada istri saya. <br><br>  Pohon awalan adalah struktur logis untuk menyimpan data yang dapat direpresentasikan sebagai indeks kartu buku di perpustakaan.  Setiap kotak memiliki nomor.  Setiap kotak sesuai dengan huruf alfabet tertentu.  Di dalamnya ada nomor-nomor dari laci-laci berikut, yang bisa Anda temukan yang berikut dan seterusnya.  Ketika tidak ada apa pun di dalam kotak, ini berarti bahwa huruf kotak ini adalah yang terakhir dalam kata.  Masalahnya adalah bahwa beberapa kotak tetap hampir kosong, karena mengandung 1 atau 2 angka, dan ruang yang tersisa kosong. <br><br>  Untuk mengatasi masalah ini, banyak varietas pohon awalan telah muncul, termasuk: HAT-trie, tri-array ganda, trip tripple-array.  Justru fakta bahwa saya tidak dapat sepenuhnya memahami prinsip kerja mereka yang mendorong saya ke pohon sesederhana file kartu perpustakaan. <br><br>  Terakhir kali saya berhasil menerapkan implementasi konsumsi memori yang agak ekonomis dari pohon awalan sederhana.  Melanjutkan metafora ini dengan indeks kartu perpustakaan, saya membuat laci di lemari arsip saya dengan berbagai ukuran, untuk alfabet penuh, kotak ini adalah yang terbesar, untuk 1 huruf yang terkecil. <br><br>  Saya berhasil menerapkan skema PHP yang persis sama di C. <br><br>  <b>1.</b> Setiap huruf dari kata sesuai dengan tabel yang ditetapkan dikodekan dengan angka dari 2 hingga 95. Misalnya, kata "abv" dikodekan dengan tiga angka: 11, 12, 13. Untuk kinerja maksimum, array dua dimensi dari nomor 1 byte <code>uint8_t abc[256][256] = {};</code>  Untuk mengonversi suatu program, ia membaca satu baris dengan 1 byte, ia mencoba untuk mengambil nilai setiap byte dalam array kami.  Sebagai contoh, kode digit adalah 1 = 49, jadi kami melihat <code>abc[49][0];</code>  .  Jika ada nilai selain '\ 0', maka ini adalah kode dari surat kami, ingat dan pergi ke byte berikutnya.  Dalam kasus kami, kata "abv" terdiri dari urutan 6 byte, dua byte per huruf: 208, 176, 208, 177, 208, 178. Karena pengkodean utf-8 dirancang sehingga byte pertama dari karakter byte tunggal tidak pernah bersamaan dengan byte pertama multi-byte , dalam array kami <code>abc[208][0] = 0;</code>  . <br><br>  Namun, untuk pasangan byte ada beberapa kecocokan: <br><br><pre> <code class="hljs markdown">/<span class="hljs-bullet"><span class="hljs-bullet">*  [11] *</span></span>/ abc[<span class="hljs-string"><span class="hljs-string">208</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">176</span></span>] = 11; /<span class="hljs-bullet"><span class="hljs-bullet">*  [12] *</span></span>/ abc[<span class="hljs-string"><span class="hljs-string">208</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">177</span></span>] = 12; /<span class="hljs-bullet"><span class="hljs-bullet">*  [13] *</span></span>/ abc[<span class="hljs-string"><span class="hljs-string">208</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">178</span></span>] = 13;</code> </pre><br>  <b>2.</b> Sekarang kita perlu menuliskan angka 11, 12 dan 13 di kotak-kotak pohon kita.  Pohon ini terdiri dari 2 blok memori non-eksplosif yang terpisah, yang pertama adalah blok node, yang kedua adalah blok tautan, serta dua konter node sibuk dan sel yang ditempati dari blok tautan.  Setiap simpul pohon terdiri dari 16 byte, 12 bit bitmask, dan 4 byte untuk menyimpan id dari blok tautan.  Topeng memungkinkan Anda untuk menyimpan angka dari 2 hingga 96 bit.  Bit pertama dari mask digunakan untuk menandai akhir kata pada node ini.  Setiap node dapat sesuai dengan id dari blok tautan jika setidaknya 1 huruf ditulis dalam node ini, atau tidak sesuai jika node adalah "daun" dalam hal pohon, yaitu, sebuah kata berakhir di atasnya.  Disajikan di perpustakaan, laci kosong. <br><br>  <b>3.</b> Ambil topeng dari simpul (root) pertama.  trie-&gt; node [0] .mask;  Kami menghitung bit yang diangkat dalam topeng ini, mulai dari yang kedua (yang pertama untuk kata akhir bendera).  Jika tidak ada bit dalam topeng yang dinaikkan, mis.  Karena node kosong, maka kita memerlukan blok tautan ukuran 1 untuk menyimpan nomor 11 kita, ambil nomor dari penghitung referensi tautan blok dan tambah nilainya satu per satu (karena kita perlu ukuran 1).  Kami mengambil nomor dari penghitung simpul dan juga meningkatkan nilai yang lama sebesar 1. Kami menulis id blok tautan, yang merupakan angka yang diperoleh dari penghitung blok tautan, di simpul akar kami.  Dan dalam id ini dari blok link, tulis id dari node baru, yaitu nomor yang diperoleh dari penghitung node.  Sekarang, selain simpul akar (id 0), kita memiliki simpul huruf "a" (id 1).  Untuk menulis angka 12 yang sesuai dengan huruf "b", kami melakukan hal yang sama, tetapi dengan simpul huruf "a". <br><br>  <b>4.</b> Pada huruf terakhir "c" kita tidak memerlukan tempat di blok tautan, karena kita akan memiliki simpul terakhir pada cabang atau simpul - lembar.  Node seperti itu hanya memiliki 1 bit pada mask yang diangkat. <br><br>  <b>5.</b> Bagian tersulit dari pekerjaan pohon terjadi ketika ditulis ke simpul di mana beberapa huruf telah ditulis.  Dalam hal ini, skema operasi adalah sebagai berikut: <br><br>  Misalkan kita ingin menambahkan kata "bvg" (12, 13, 14) ke pohon kami, di mana kata "abv" (11, 12, 13) sudah ditulis.  Kami menghitung bit di topeng simpul akar ke bit surat yang menarik bagi kami.  Kami memiliki huruf "b" dengan kode 12, yang berarti bahwa bit dari huruf ini adalah 12, dalam mask dari 1 hingga 12 bit bit 11 dari huruf "a" telah dimunculkan.  Jadi kita memiliki ukuran saat ini dari blok tautan untuk simpul akar 1. Kita menulis huruf kedua, jadi sekarang kita membutuhkan blok tautan dengan ukuran 2. Di sini registri blok yang dibebaskan berperan, di mana id dan ukuran bagian dalam blok tautan tidak lagi digunakan oleh node pohon.  ID lama kami dari blok tautan untuk simpul akar ukuran 1 baru saja masuk ke registri bagian bebas ukuran 1, karena simpul akar kami memerlukan ukuran yang lebih besar.  Registri kami tidak memiliki bagian yang sesuai dengan ukuran 2 dan kami kembali mengambil nilai dari penghitung blok tautan sebagai id baru dari blok tautan, menambah penghitung dengan 2. Pada alamat baru dari blok tautan dalam urutan yang sama di mana bit berada di masker simpul, kami menulis nilai id simpul dari blok lama tautan untuk huruf "a" dari kata pertama dan nilai simpul yang baru dibuat dari huruf "b" dari kata kedua. <br><img src="https://habrastorage.org/webt/nx/cr/md/nxcrmdtlm8gezn4zkxk2_5vni_m.png"><br><br><h2>  Kecepatan kerja </h2><br>  Drum roll berbunyi ... Ingat hasil terakhir?  Sekitar 80 ribu kata per detik.  Pohon itu dibuat dari kamus semua kata-kata Rusia OpenCorpora 3 039 982 kata.  Dan inilah yang terjadi sekarang: <br><br><pre> <code class="hljs pgsql">yatrie creation <span class="hljs-type"><span class="hljs-type">time</span></span>: <span class="hljs-number"><span class="hljs-number">4.588216</span></span>s (<span class="hljs-number"><span class="hljs-number">666</span></span>k wps) yatrie <span class="hljs-keyword"><span class="hljs-keyword">search</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> mln. rounds: <span class="hljs-number"><span class="hljs-number">0.565618</span></span>s (<span class="hljs-number"><span class="hljs-number">1.76</span></span>m wps)</code> </pre> <br>  <b>UPDATE 11/01/2018:</b> <br>  Dalam versi 0.0.2, dimungkinkan untuk meningkatkan kecepatan hampir 2 kali dengan mengganti fungsi penuh dengan fungsi makro, serta mengubah struktur masker simpul ke topeng uint32_t [3], sebelumnya itu adalah topeng uint8_t [12]. <br>  Juga menambahkan macro LIKELY () UNLIKELY () untuk memprediksi hasil yang diharapkan di blok if (), jika memungkinkan. <br>  <b>UPDATE 11/05/2018:</b> <br>  Memutar sedikit lagi.  Saya berhasil membuatnya bekerja dengan baik bahkan ketika mengkompilasi -O3 dan -Ofast.  Kecepatan pencarian di pohon adalah ~ 0,2 Î¼s atau 0,2c per 1 juta pengulangan.  Rupanya kecepatan ini diperoleh karena transisi ke format topeng yang berbeda.  Sebelumnya, ada 12 byte 8 bit, dan sekarang 3 int32 dan fungsi yang sangat cepat untuk menghitung bit di int32. <br><br><h3>  Seberapa kompak ini? </h3><br>  Kamus OpenCorpora yang ditentukan membutuhkan ~ 84MB, yang tidak lebih buruk dari libdatrie, yang menghasilkan ~ 80MB. <br><br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode Sumber</a> <br><br>  Selamat datang </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id428175/">https://habr.com/ru/post/id428175/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id428161/index.html">Reformasi untuk mensubsidi bahan bakar fosil yang telah dicapai melalui kerja keras sedang dalam bahaya</a></li>
<li><a href="../id428165/index.html">Podcast kernel Linux dengan Open Source Summit Europe 2018</a></li>
<li><a href="../id428167/index.html">Pabrik robot pertama di Rusia dan apa hubungannya dengan sosis?</a></li>
<li><a href="../id428169/index.html">DJI mengumumkan Mavic 2 Enterprise - alat yang ampuh untuk para profesional</a></li>
<li><a href="../id428173/index.html">Prettier, ESLint, Husky, Lint-Staged, dan EditorConfig: Alat untuk Menulis Kode Rapi</a></li>
<li><a href="../id428177/index.html">Jadi apa yang salah dengan mencari pekerjaan / pekerja di bidang TI?</a></li>
<li><a href="../id428179/index.html">Pada pelelangan Jepang, prototipe Wii-controller, yang dikembangkan untuk GameCube</a></li>
<li><a href="../id428181/index.html">Mesin Moral: tanpa ampun atau tidak berarti?</a></li>
<li><a href="../id428183/index.html">Implementasi algoritma Levenberg-Marquardt untuk mengoptimalkan jaringan saraf pada TensorFlow</a></li>
<li><a href="../id428187/index.html">Cara menulis ekstensi untuk GNOME Shell: Mode Jangan Ganggu</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>