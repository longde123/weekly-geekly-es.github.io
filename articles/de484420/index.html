<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì® üåßÔ∏è ü¶Ö √Ñnderungen in der beliebten BattlEye-Antichita und M√∂glichkeiten, sie zu umgehen „Ä∞Ô∏è üìå üà∫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wichtige BattlEye-Shellcode-Updates 
 Die Zeit vergeht, Anti-Cheats √§ndern sich, und um die Wirksamkeit des Produkts zu erh√∂hen, erscheinen und versch...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√Ñnderungen in der beliebten BattlEye-Antichita und M√∂glichkeiten, sie zu umgehen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484420/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/zd/c7/fe/zdc7ferp6hnuf19n_aid_mh4tca.png"></div><br><h2>  Wichtige BattlEye-Shellcode-Updates </h2><br>  Die Zeit vergeht, Anti-Cheats √§ndern sich, und um die Wirksamkeit des Produkts zu erh√∂hen, erscheinen und verschwinden Funktionen in ihnen.  Vor einem Jahr habe ich in meinem <a href="https://vmcall.blog/battleye-anticheat-analysis-and-mitigation/">Blog</a> eine detaillierte Beschreibung des BattlEye-Shellcodes erstellt. Dieser Teil des Artikels spiegelt die √Ñnderungen wider, die am Shellcode vorgenommen wurden. <br><br><h2>  Zeitstempel auf der schwarzen Liste </h2><br>  In einer k√ºrzlich durchgef√ºhrten BattlEye-Analyse waren nur zwei Kompilierungszeitstempel in der Liste der Schattenverbote enthalten, und es sieht so aus, als h√§tten die Entwickler beschlossen, viel mehr hinzuzuf√ºgen: <br><br> <code>0x5B12C900 (action_x64.dll) <br> 0x5A180C35 (TerSafe.dll, Epic Games) <br> 0xFC9B9325 (?) <br> 0x456CED13 (d3dx9_32.dll) <br> 0x46495AD9 (d3dx9_34.dll) <br> 0x47CDEE2B (d3dx9_32.dll) <br> 0x469FF22E (d3dx9_35.dll) <br> 0x48EC3AD7 (D3DCompiler_40.dll) <br> 0x5A8E6020 (?) <br> 0x55C85371 (d3dx9_32.dll) <br> 0x456CED13 (?) <br> 0x46495AD9 (D3DCompiler_40.dll) <br> 0x47CDEE2B (D3DX9_37.dll) <br> 0x469FF22E (?) <br> 0x48EC3AD7 (?) <br> 0xFC9B9325 (?) <br> 0x5A8E6020 (?) <br> 0x55C85371 (?)</code> <br> <br>  Ich konnte die verbleibenden Zeitstempel nicht identifizieren, und die beiden <b>0xF *******</b> sind die Hashes, die von den deterministischen Assemblys von Visual Studio erstellt wurden.  Vielen Dank an @mottikraus und T0B1 f√ºr die Identifizierung einiger Zeitstempel. <br><a name="habracut"></a><br><h2>  Modulpr√ºfungen </h2><br>  Wie die Hauptanalyse gezeigt hat, besteht das Hauptmerkmal von BattlEye in der Aufz√§hlung der Module. Ab dem Zeitpunkt der letzten Analyse wurde der Liste ein weiteres Modul hinzugef√ºgt: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> battleye::misc::module_unknown1() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!GetProcAddress(current_module, <span class="hljs-string"><span class="hljs-string">"NSPStartup"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (optional_header.data_directory[<span class="hljs-number"><span class="hljs-number">4</span></span>].size == <span class="hljs-number"><span class="hljs-number">0x1B20</span></span> || optional_header.data_directory[<span class="hljs-number"><span class="hljs-number">4</span></span>].size == <span class="hljs-number"><span class="hljs-number">0xE70</span></span> || optional_header.data_directory[<span class="hljs-number"><span class="hljs-number">4</span></span>].size == <span class="hljs-number"><span class="hljs-number">0x1A38</span></span> || timestamp &gt;= <span class="hljs-number"><span class="hljs-number">0x5C600000</span></span> &amp;&amp; timestamp &lt; <span class="hljs-number"><span class="hljs-number">0x5C700000</span></span>) { report_module_unknown report = {}; report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span>; report.report_id = <span class="hljs-number"><span class="hljs-number">0x35</span></span>; report.val1 = <span class="hljs-number"><span class="hljs-number">0x5C0</span></span>; report.timestamp = timestamp; report.image_size = optional_header.size_of_image; report.entrypoint = optional_header.address_of_entry_point; report.directory_size = optional_header.data_directory[<span class="hljs-number"><span class="hljs-number">4</span></span>].size; battleye::report(&amp;report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(report), <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } }</code> </pre> <br>  Dies ist wahrscheinlich die Erkennung bestimmter Proxy-DLLs, da hier die Gr√∂√üe der Umleitungstabelle √ºberpr√ºft wird. <br><br><h2>  Fenstertitel </h2><br>  In der vorherigen Analyse wurden verschiedene Cheat-Anbieter mit Fensternamen gekennzeichnet, aber seitdem √ºberpr√ºft der Shellcode diese Fensterk√∂pfe nicht mehr.  Die Liste der Fenstertitel wurde komplett ersetzt durch: <br><br> <code>Chod's <br> Satan5</code> <br> <br><h2>  Bildnamen </h2><br>  BattlEye ist daf√ºr bekannt, sehr primitive Erkennungsmethoden zu verwenden, und eine davon ist eine schwarze Liste von Bildnamen.  Jedes Jahr wird die Liste der verbotenen Bildnamen l√§nger und in den letzten 11 Monaten wurden f√ºnf neue hinzugef√ºgt: <br><br> <code>frAQBc8W.dll <br> C:\\Windows\\mscorlib.ni.dll <br> DxtoryMM_x64.dll <br> Project1.dll <br> OWClient.dll <br></code> <br>  Es ist zu beachten, dass das Vorhandensein eines Moduls mit einem Namen, der einem der Elemente in der Liste entspricht, nicht bedeutet, dass Sie sofort gesperrt werden.  Die Berichts-Engine √ºbertr√§gt auch grundlegende Modulinformationen, die am wahrscheinlichsten zur Unterscheidung von Cheats von Kollisionen auf dem BattlEye-Server verwendet werden. <br><br><h2>  7-Rei√üverschluss </h2><br>  7-Zip war weit verbreitet und wird von Teilnehmern der Cheatszene weiterhin als Speicherf√ºller f√ºr Code-Voids (Code-Caves) verwendet.  BattlEye versucht, dem entgegenzuwirken, indem es eine <b>sehr</b> schlechte Integrit√§tspr√ºfung durchf√ºhrt, die sich seit meinem vorherigen Artikel ge√§ndert hat: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::check_7zip() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> module_handle = GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"..\\..\\Plugins\\ZipUtility\\ThirdParty\\7zpp\\dll\\Win64\\7z.dll"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// --- REMOVED --- // if (module_handle &amp;&amp; *(int*)(module_handle + 0x1000) != 0xFF1441C7) // --- ADDED --- if (module_handle &amp;&amp; *(int*)(module_handle + 0x1008) != 0x83485348) { sevenzip_report.unknown_1 = 0; sevenzip_report.report_id = 0x46; sevenzip_report.unknown_2 = 0; sevenzip_report.data1 = *(__int64*)(module_handle + 0x1000; sevenzip_report.data2 = *(__int64*)(module_handle + 0x1008; battleye::report(&amp;sevenzip_report, sizeof(sevenzip_report), false); } }</span></span></code> </pre> <br>  Es scheint, dass die BattlEye-Entwickler vermutet haben, dass mein vorheriger Artikel viele Benutzer dazu veranlasst hat, diese √úberpr√ºfung zu umgehen, indem sie einfach die gew√ºnschten Bytes an den von BattlEye √ºberpr√ºften Speicherort kopieren.  Wie haben sie die Situation behoben?  Wir haben die √úberpr√ºfung um acht Bytes verschoben und weiterhin die gleiche schlechte Methode zum √úberpr√ºfen der Integrit√§t verwendet.  Die schreibgesch√ºtzte ausf√ºhrbare Partition. Sie m√ºssen lediglich 7-Zip von der Festplatte herunterladen und die verschobenen Partitionen miteinander vergleichen.  Wenn es Unstimmigkeiten gibt, stimmt etwas nicht.  Im Ernst, Leute, es ist nicht so schwer, Integrit√§tspr√ºfungen durchzuf√ºhren. <br><br><h2>  Netzwerkpr√ºfung </h2><br>  Die Aufz√§hlung der TCP-Tabelle funktioniert immer noch, aber nachdem ich eine fr√ºhere Analyse ver√∂ffentlicht habe, in der Entwickler kritisiert wurden, dass sie Cloudflare-IP-Adressen kennzeichnen, haben sie diese Pr√ºfung immer noch entfernt.  Anti-Cheat meldet immer noch den Port, den xera.ph f√ºr die Verbindung verwendet, aber die Entwickler haben eine neue Pr√ºfung hinzugef√ºgt, um festzustellen, ob der Prozess mit der Verbindung einen aktiven Schutz hat (vermutlich wird dies mit dem Handler durchgef√ºhrt). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> network::scan_tcp_table { <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(local_port_buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(local_port_buffer); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (iteration_index = <span class="hljs-number"><span class="hljs-number">0</span></span>; iteration_index; &lt; <span class="hljs-number"><span class="hljs-number">500</span></span> ++iteration_index) { <span class="hljs-comment"><span class="hljs-comment">// GET NECESSARY SIZE OF TCP TABLE auto table_size = 0; GetExtendedTcpTable(0, &amp;table_size, false, AF_INET, TCP_TABLE_OWNER_MODULE_ALL, 0); // ALLOCATE BUFFER OF PROPER SIZE FOR TCP TABLE auto allocated_ip_table = (MIB_TCPTABLE_OWNER_MODULE*)malloc(table_size); if (GetExtendedTcpTable(allocated_ip_table, &amp;table_size, false, AF_INET, TCP_TABLE_OWNER_MODULE_ALL, 0) != NO_ERROR) goto cleanup; for (entry_index = 0; entry_index &lt; allocated_ip_table-&gt;dwNumEntries; ++entry_index) { // --- REMOVED --- // const auto ip_address_match_1 = // allocated_ip_table-&gt;table[entry_index].dwRemoteAddr == 0x656B1468; // 104.20.107.101 // // const auto ip_address_match_2 = // allocated_ip_table-&gt;table[entry_index].dwRemoteAddr == 0x656C1468; // 104.20.108.101 // +++ ADDED +++ const auto target_process = OpenProcess(QueryLimitedInformation, 0, ip_table-&gt;table[entry_index].dwOwningPid); const auto protected = target_process == INVALID_HANDLE &amp;&amp; GetLastError() == 0x57; if (!protected) { CloseHandle(target_process); return; } const auto port_match = allocated_ip_table-&gt;table[entry_index].dwRemotePort == 20480; for (port_index = 0; port_index &lt; 10 &amp;&amp; allocated_ip_table-&gt;table[entry_index].dwLocalPort != local_port_buffer[port_index]; ++port_index) { if (local_port_buffer[port_index]) continue tcp_table_report.unknown = 0; tcp_table_report.report_id = 0x48; tcp_table_report.module_id = 0x5B9; tcp_table_report.data = BYTE1(allocated_ip_table-&gt;table[entry_index].dwLocalPort) | (LOBYTE(allocated_ip_table-&gt;table[entry_index.dwLocalPort) &lt;&lt; 8; battleye::report(&amp;tcp_table_report, sizeof(tcp_table_report), false); local_port_buffer[port_index] = allocated_ip_table-&gt;table[entry_index].dwLocalPort; break } } cleanup: // FREE TABLE AND SLEEP free(allocated_ip_table); Sleep(10 } }</span></span></code> </pre> <br>  Danke IChooseYou und Zusammenfassung <br><br><h2>  BattlEye Stack Bypass </h2><br>  Hacking Games ist ein st√§ndiges Katz- und Mausspiel, daher verbreiten sich Ger√ºchte √ºber neue Tricks wie ein Feuer.  In diesem Teil werden wir uns mit neuen heuristischen Techniken befassen, die k√ºrzlich von einem gro√üen Anbieter von Anti-Cheats, BattlEye, in unser Arsenal aufgenommen wurden.  Am h√§ufigsten werden diese Techniken als Stack-Walking bezeichnet.  Normalerweise werden sie implementiert, indem eine Funktion verarbeitet und der Stapel durchsucht wird, um herauszufinden, wer diese Funktion speziell aufgerufen hat.  Warum musst du das tun?  Wie jedes andere Programm verf√ºgen Videospiel-Hacks √ºber eine Reihe bekannter Funktionen, mit denen sie Informationen von der Tastatur abrufen, auf der Konsole ausgeben oder bestimmte mathematische Ausdr√ºcke berechnen k√∂nnen.  Dar√ºber hinaus lieben es Videospiel-Hacks, ihre Existenz im Speicher oder auf der Festplatte zu verbergen, damit Anti-Cheat-Software sie nicht findet.  Aber was Cheat-Programme vergessen, ist, dass sie regelm√§√üig Funktionen aus anderen Bibliotheken aufrufen, und dies kann verwendet werden, um unbekannte Cheats heuristisch zu erkennen.  Durch die Implementierung der Stack-Traversal-Engine f√ºr Funktionen wie <code>std::print</code> k√∂nnen wir diese Cheats auch dann finden, wenn sie maskiert sind. <br><br>  BattlEye <strong>implementierte einen</strong> ‚ÄûStack-Bypass‚Äú, obwohl dies nicht √∂ffentlich angek√ºndigt wurde und zum Zeitpunkt der Ver√∂ffentlichung des Artikels nur Ger√ºchte im Umlauf waren.  Achten Sie auf die Anf√ºhrungszeichen - was Sie hier sehen, ist nicht wirklich eine Stapel-Tour, sondern nur eine Kombination aus der √úberpr√ºfung der Absenderadresse und dem Speicherauszug des aufrufenden Programms.  Eine echte Stack-Traversal-Implementierung w√ºrde den Stack durchlaufen und einen echten Call-Stack generieren. <br><br>  Wie ich in einem fr√ºheren Artikel √ºber BattlEye erkl√§rt habe, √ºbertr√§gt das Anti-Cheat-System den Shellcode dynamisch in das Spiel, wenn es ausgef√ºhrt wird.  Diese Shell-Codes haben unterschiedliche Gr√∂√üen und Aufgaben und werden nicht gleichzeitig √ºbertragen.  Eine bemerkenswerte Eigenschaft eines solchen Systems ist, dass die Forscher den Anti-Cheat w√§hrend des Multiplayer-Spiels dynamisch analysieren m√ºssen, was die Bestimmung der Eigenschaften dieses Anti-Cheats erschwert.  Es erm√∂glicht Anti-Cheat auch, verschiedene Ma√ünahmen auf verschiedene Benutzer anzuwenden, um beispielsweise ein st√§rker invasives Modul nur auf eine Person zu √ºbertragen, die ein ungew√∂hnlich hohes Verh√§ltnis von Morden und Todesf√§llen und dergleichen aufweist. <br><br>  Einer dieser Shell-Codes, BattlEye, ist f√ºr die Durchf√ºhrung dieser Stapelanalyse verantwortlich.  wir werden es <em>shellcode8kb</em> nennen, da es im Vergleich zu <em>shellcodemain</em> , das ich <a href="https://vmcall.blog/battleye-anticheat-analysis-and-mitigation/">hier</a> dokumentiert <a href="https://vmcall.blog/battleye-anticheat-analysis-and-mitigation/">habe,</a> etwas kleiner <a href="https://vmcall.blog/battleye-anticheat-analysis-and-mitigation/">ist</a> .  Dieser kleine Shell-Code, der die <strong>AddVectoredExceptionHandler-</strong> Funktion verwendet, bereitet einen vektorisierten Ausnahmehandler vor und setzt dann Interrupt-Traps f√ºr die folgenden Funktionen: <br><br> <code>GetAsyncKeyState <br> GetCursorPos <br> IsBadReadPtr <br> NtUserGetAsyncKeyState <br> GetForegroundWindow <br> CallWindowProcW <br> NtUserPeekMessage <br> NtSetEvent <br> sqrtf <br> __stdio_common_vsprintf_s <br> CDXGIFactory::TakeLock <br> TppTimerpExecuteCallback</code> <br> <br>  Dazu <strong>durchl√§uft</strong> es einfach die Liste der standardm√§√üig verwendeten Funktionen und setzt die erste Anweisung der entsprechenden Funktion auf <strong>int3</strong> , die als Haltepunkt verwendet wird.  Nach dem Setzen eines Haltepunkts durchlaufen alle Aufrufe der entsprechenden Funktion den Exception-Handler, der vollen Zugriff auf die Register und den Stack hat.  Bei diesem Zugriff gibt der Ausnahmehandler die Adresse des aufrufenden Programms oben im Stapel aus. Wenn eine der heuristischen Bedingungen erf√ºllt ist, werden 32 Byte der aufrufenden Funktion ausgegeben und mit der Berichtskennung <strong>0x31</strong> an den BattlEye-Server <strong>gesendet</strong> : <br><br><pre> <code class="cpp hljs">__int64 battleye::exception_handler(_EXCEPTION_POINTERS *exception) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exception-&gt;ExceptionRecord-&gt;ExceptionCode != STATUS_BREAKPOINT) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> caller_function = *(__int64 **)exception-&gt;ContextRecord-&gt;Rsp; MEMORY_BASIC_INFORMATION caller_memory_information = {}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> desired_size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// QUERY THE MEMORY PAGE OF THE CALLER const auto call_failed = NtQueryVirtualMemory( GetCurrentProcess(), caller_function, MemoryBasicInformation, &amp;caller_memory_information, sizeof(caller_memory_information), &amp;desired_size) &lt; 0; // IS THE MEMORY SOMEHOW NOT COMMITTED? (WOULD SUGGEST VAD MANIPULATIUON) const auto non_commit = caller_memory_information.State != MEM_COMMIT; // IS THE PAGE EXECUTABLE BUT DOES NOT BELONG TO A PROPERLY LOADED MODULE? const auto foreign_image = caller_memory_information.Type != MEM_IMAGE &amp;&amp; caller_memory_information.RegionSize &gt; 0x2000; // IS THE CALL BEING SPOOFED BY NAMAZSO? const auto spoof = *(_WORD *)caller_function == 0x23FF; // jmp qword ptr [rbx] // FLAG ALL ANBORMALITIES if (call_failed || non_commit || foreign_image || spoof) { report_stack.unknown = 0; report_stack.report_id = 0x31; report_stack.hook_id = hook_id; report_stack.caller = (__int64)caller_function; report_stack.function_dump[0] = *caller_function; report_stack.function_dump[1] = caller_function[1]; report_stack.function_dump[2] = caller_function[2]; report_stack.function_dump[3] = caller_function[3]; if (!call_failed) { report_stack.allocation_base = caller_memory_information.AllocationBase; report_stack.base_address = caller_memory_information.BaseAddress; report_stack.region_size = caller_memory_information.RegionSize; report_stack.type_protect_state = caller_memory_information.Type | caller_memory_information.Protect | caller_memory_information.State; } battleye::report(&amp;report_stack, sizeof(report_stack), false); return -1; } }</span></span></code> </pre> <br>  Wie wir sehen k√∂nnen, gibt der Exception-Handler alle aufrufenden Funktionen aus, wenn sich die Speicherseite kurzfristig √§ndert oder wenn die Funktion nicht zu einem bekannten Prozessmodul geh√∂rt (der Speicherseitentyp MEM_IMAGE wurde nicht von manuellen Zuordnern festgelegt).  Au√üerdem werden aufrufende Funktionen <strong>ausgegeben</strong> , wenn <strong>NtQueryVirtualMemory</strong> nicht aufgerufen werden <strong>kann,</strong> sodass Cheats nicht an diesen Systemaufruf <strong>gebunden</strong> werden und ihr Modul vor dem Stapelspeicherauszug verbergen.  Die letzte Bedingung ist tats√§chlich sehr interessant. Sie kennzeichnet alle aufrufenden Funktionen, die das <strong>Gadget jmp qword ptr [rbx] verwenden</strong> - die Methode, mit der die " <strong>R√ºcksprungadresse gef√§lscht</strong> " wird.  Es wurde <a href="https://www.unknowncheats.me/forum/anti-cheat-bypass/268039-x64-return-address-spoofing-source-explanation.html">von</a> meinem Co-Sekret√§r Mitglied Spitznamen namazso ver√∂ffentlicht.  Es scheint, dass die Entwickler von BattlEye gesehen haben, dass die Leute diese Methode des Spoofings in ihren Spielen verwenden, und beschlossen, direkt darauf zu zielen.  Erw√§hnenswert ist hier, dass die von namazsos beschriebene Methode gut funktioniert, nur ein anderes Gadget verwendet oder ganz anders oder nur ein anderes Register - es spielt keine Rolle. <br><br>  BattlEye-Entwicklertipp: Das <code>CDXGIFactory::TakeLock</code> in Ihrem Speicher verwenden, ist nicht korrekt, da Sie (versehentlich oder absichtlich) das CC-Padding aktiviert haben, das bei jedem Kompilieren sehr unterschiedlich ist.  Um maximale Kompatibilit√§t zu erreichen, m√ºssen Sie die F√ºllung (das erste Byte in der Signatur) entfernen, damit Sie h√∂chstwahrscheinlich mehr Betr√ºger fangen k√∂nnen :) <br><br>  Die vollst√§ndige Struktur, die an den BattlEye-Server gesendet wird, sieht folgenderma√üen aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unaligned</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">battleye_stack_report</span></span></span><span class="hljs-class"> {</span></span> __int8 unknown; __int8 report_id; __int8 val0; __int64 caller; __int64 function_dump[<span class="hljs-number"><span class="hljs-number">4</span></span>]; __int64 allocation_base; __int64 base_address; __int32 region_size; __int32 type_protect_state; };</code> </pre> <br><h2>  Hypervisor-Erkennung in BattlEye </h2><br>  Das Katz- und Mausspiel im Bereich der Hacking-Spiele ist weiterhin eine Quelle der Innovation bei Exploits und der Bek√§mpfung von Betr√ºgern.  Der Einsatz von Virtualisierungstechnologie in Hacking-Spielen begann sich nach dem Aufkommen von so <a href="https://github.com/tandasat/DdiMon">benutzerfreundlichen</a> Hypervisoren wie <a href="https://github.com/tandasat/DdiMon">DdiMon</a> Satoshi Tanda und <a href="https://github.com/wbenny/hvpp">hvpp</a> Peter Benes aktiv zu entwickeln.  Diese beiden Projekte werden aufgrund der niedrigen Einstiegsschwelle und der detaillierten Dokumentation von den meisten bezahlten Cheats der Underground-Hacker-Szene genutzt.  Diese Ver√∂ffentlichungen d√ºrften das Wettr√ºsten auf dem Gebiet der Hypervisoren beschleunigen, das sich nun in der Community der Game-Hacker manifestiert.  <a href="https://www.unknowncheats.me/">Folgendes</a> sagt der Administrator einer der gr√∂√üten Gaming-Hacking-Communities mit dem Spitznamen <a href="https://www.unknowncheats.me/">wlan</a> zu dieser Situation: <br><br><blockquote>  Mit dem Aufkommen gebrauchsfertiger Hypervisor-Systeme f√ºr Hacking-Spiele wurde es unvermeidlich, dass Anti-Cheats wie BattlEye sich auf die allgemeine Erkennung von Virtualisierung konzentrierten. </blockquote><br>  Die weitverbreitete Verwendung von Hypervisoren ist auf die j√ºngsten Verbesserungen bei der Betrugsbek√§mpfung zur√ºckzuf√ºhren, die Hackern nur sehr wenige M√∂glichkeiten lie√üen, Spiele auf herk√∂mmliche Weise zu modifizieren.  Die Popularit√§t von Hypervisoren l√§sst sich durch die einfache Vermeidung von Anti-Cheat erkl√§ren, da die Virtualisierung das Verbergen von Informationen mithilfe von Mechanismen wie <a href="https://revers.engineering/syscall-hooking-via-extended-feature-enable-register-efer/">Syscall Hooks</a> und <a href="https://www.anandtech.com/show/2480/10">MMU-Virtualisierung</a> vereinfacht. <br><br>  Vor kurzem hat BattlEye die Erkennung g√§ngiger Hypervisoren wie der oben genannten Plattformen (DdiMon, hvpp) mithilfe der zeitbasierten Erkennung implementiert.  Diese Erkennung versucht, nicht standardm√§√üige CPUID-Befehlszeitwerte zu erkennen.  CPUID ist eine relativ kosteng√ºnstige Anweisung f√ºr reale Ger√§te, die normalerweise nur zweihundert Zyklen ben√∂tigt. In einer virtuellen Umgebung kann die Ausf√ºhrung aufgrund unn√∂tiger Operationen, die durch die Introspection-Engine verursacht werden, zehnmal l√§nger dauern.  Die Introspection-Engine unterscheidet sich von realen Ger√§ten, die den Vorgang einfach in der erwarteten Weise ausf√ºhren, da sie die an den Gast zur√ºckgegebenen Daten anhand eines beliebigen Kriteriums verfolgt und bedingt √§ndert. <br><br>  <strong>Unterhaltsame Tatsache:</strong> CPUID wird in diesen tempor√§ren Erkennungsprozeduren aktiv verwendet, da es sich um eine Anweisung mit einer bedingungslosen Ausgabe sowie um eine Anweisung mit nicht privilegierter Serialisierung handelt.  Dies bedeutet, dass die CPUID als <a href="https://en.wikipedia.org/wiki/Memory_barrier">Barriere verwendet wird</a> und sicherstellt, dass die Anweisungen vor und nach ihr befolgt werden.  Gleichzeitig werden die Timings unabh√§ngig von der √ºblichen Neuordnung von Anweisungen.  Sie k√∂nnen auch Befehle wie <a href="https://www.felixcloutier.com/x86/xsetbv">XSETBV verwenden</a> , die ebenfalls einen bedingungslosen Exit ausf√ºhren. Um jedoch ein unabh√§ngiges Timing zu gew√§hrleisten, ist eine Art Barrierebefehl erforderlich, damit keine vorher oder nachher erfolgende Neuordnung die Zuverl√§ssigkeit der Timings beeintr√§chtigt. <br><br><h4>  Anerkennung </h4><br>  Das Folgende ist das Erkennungsverfahren aus dem BattlEye-Modul ‚ÄûBEClient2‚Äú;  Ich habe das Reverse Engineering durchgef√ºhrt und den Code in Pseudo-C neu erstellt und dann auf <a href="https://twitter.com/vm_call">Twitter</a> gepostet.  Am Tag nach meinem Tweet √§nderten die BattlEye-Entwickler unerwartet die Verschleierung von BEClient2 und hofften anscheinend, dass dies mich daran hindern w√ºrde, das Modul zu analysieren.  Die vorherige Verschleierung √§nderte sich nicht l√§nger als ein Jahr, sondern erst am Tag nach meinem Tweet - eine beeindruckende Geschwindigkeit. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> battleye::take_time() { <span class="hljs-comment"><span class="hljs-comment">// SET THREAD PRIORITY TO THE HIGHEST const auto old_priority = SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL); // CALCULATE CYCLES FOR 1000MS const auto timestamp_calibrator = __rdtsc(); Sleep(1000); const auto timestamp_calibration = __rdtsc() - timestamp_calibrator; // TIME CPUID auto total_time = 0; for (std::size_t count = 0; count &lt; 0x6694; count++) { // SAVE PRE CPUID TIME const auto timestamp_pre = __rdtsc(); std::uint32_t cpuid_data[4] = {}; __cpuid(cpuid_data, 0); // SAVE THE DELTA total_time += __rdtsc() - timestamp_pre; } // SAVE THE RESULT IN THE GLOBAL REPORT TABLE battleye::report_table[0x1A8] = 10000000 * total_time / timestamp_calibration / 0x65; // RESTORE THREAD PRIORITY SetThreadPriority(GetCurrentThread(), old_priority); }</span></span></code> </pre> <br>  Wie ich oben sagte, ist dies die gebr√§uchlichste Erkennungstechnik, bei der bedingungslos abgefangene Anweisungen verwendet werden.  Es ist jedoch anf√§llig f√ºr falsche Zeiten, und wir werden im n√§chsten Abschnitt ausf√ºhrlich darauf eingehen. <br><br><h4>  Erkennungs-Bypass </h4><br>  Diese Erkennungsmethode weist Probleme auf.  Erstens ist es anf√§llig, Zeit zu f√§lschen, was normalerweise auf zwei Arten geschieht: durch Verschieben der TSC in VMCS oder durch Verringern der TSC bei jeder Ausf√ºhrung der CPUID.  Es gibt viele andere M√∂glichkeiten, um mit zeitbasierten Angriffen umzugehen. Letztere sind jedoch viel einfacher zu implementieren, da Sie sicherstellen k√∂nnen, dass die Ausf√ºhrungszeit des Befehls innerhalb von ein oder zwei Taktzyklen nach der Ausf√ºhrungssynchronisierung auf realen Ger√§ten liegt.  Die Schwierigkeit, diese Zeitf√§lschungstechnik zu entdecken, h√§ngt von der Erfahrung des Entwicklers ab.  Im n√§chsten Abschnitt werden wir uns mit F√§lschungen und Verbesserungen der in BattlEye erstellten Implementierung befassen.  Der zweite Grund f√ºr diesen Erkennungsmethodenfehler ist, dass die CPUID-Verz√∂gerung (Laufzeit) in verschiedenen Prozessoren je nach Wert des Blatts sehr unterschiedlich ist.  Es kann bis zu 70-300 Taktzyklen dauern, bis der Vorgang abgeschlossen ist.  Das dritte Problem bei diesem Erkennungsverfahren ist die Verwendung von SetThreadPriority.  Diese Windows-Funktion wird verwendet, um den Priorit√§tswert eines bestimmten Stream-Deskriptors festzulegen. Das Betriebssystem h√∂rt jedoch nicht immer auf die Anforderung.  Diese Funktion ist lediglich ein Vorschlag, um die Priorit√§t des Threads zu erh√∂hen, und es gibt keine Garantie daf√ºr, dass dies der Fall ist.  Daher ist es m√∂glich, dass diese Methode von Unterbrechungen oder anderen Prozessen betroffen ist. <br><br>  In diesem Fall ist es einfach, die Erkennung zu umgehen, und die beschriebene Technik der Zeitf√§lschung beseitigt diese Erkennungsmethode effektiv.  Wenn die Entwickler von BattlEye diese Methode verbessern m√∂chten, enth√§lt der folgende Abschnitt einige Empfehlungen. <br><br><h4>  Verbesserung </h4><br>  Diese Funktion kann auf viele Arten verbessert werden.  Erstens k√∂nnen Sie absichtlich Interrupts deaktivieren und die Priorit√§t eines Threads erzwingen, indem Sie CR8 auf das h√∂chste IRQL √§ndern.  Ideal w√§re es auch, diese Pr√ºfung in einem CPU-Kern zu isolieren.  Eine weitere Verbesserung: Sie sollten verschiedene Timer verwenden, aber viele davon sind nicht so genau wie TSC, aber es gibt einen solchen Timer namens APERF oder Actual Performance Clock.  Ich empfehle diesen Timer, weil es schwieriger ist, damit zu cheaten, und weil er nur dann einen Z√§hler ansammelt, wenn sich der logische Prozessor im Energiezustand C0 befindet.  Dies ist eine gro√üartige Alternative zur Verwendung von TSC.  Sie k√∂nnen auch den ACPI-, HPET-, PIT-Timer, GPU-Timer, NTP-Timer oder PPERF-Timer verwenden, der dem APERF-Timer √§hnelt, jedoch Ma√ünahmen z√§hlt, die als Ausf√ºhrungsanweisungen wahrgenommen werden.  Dies hat den Nachteil, dass Sie HWP aktivieren m√ºssen, das vom Zwischenoperator deaktiviert werden kann, und daher unbrauchbar ist. <br><br>  Nachfolgend finden Sie eine verbesserte Version des Erkennungsverfahrens, das im Kernel ausgef√ºhrt werden sollte: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> battleye::take_time() { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> cpuid_regs[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {}; _disable(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> aperf_pre = __readmsr(IA32_APERF_MSR) &lt;&lt; <span class="hljs-number"><span class="hljs-number">32</span></span>; __cpuid(&amp;cpuid_regs, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> aperf_post = __readmsr(IA32_APERF_MSR) &lt;&lt; <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> aperf_diff = aperf_post - aperf_pre; <span class="hljs-comment"><span class="hljs-comment">// CPUID IET ARRAY STORE // BATTLEYE REPORT TABLE STORE _enable(); }</span></span></code> </pre> <br>  <strong>Hinweis:</strong> IET steht f√ºr Instruction Execution Time. <br><br>  Das Verfahren kann jedoch bei der Erkennung g√§ngiger Hypervisoren immer noch sehr unzuverl√§ssig sein, da die CPUID-Laufzeiten stark variieren k√∂nnen.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es w√§re besser, den IET der beiden Anweisungen zu vergleichen. Eine davon sollte eine l√§ngere Ausf√ºhrungsverz√∂gerung aufweisen als die CPUID. Zum Beispiel kann es sich um FYL2XP1 handeln - eine arithmetische Anweisung, deren Ausf√ºhrung etwas l√§nger dauert als die durchschnittliche IET der CPUID-Anweisung. Dar√ºber hinaus verursacht es keine Traps im Hypervisor und seine Zeit kann zuverl√§ssig gemessen werden. Mit diesen beiden Funktionen k√∂nnte die Profilerstellungsfunktion ein Array zum Speichern der IET-Anweisungen CPUID und FYL2XP1 erstellen. Unter Verwendung des APERF-Timers w√§re es m√∂glich, den Anfangstakt einer arithmetischen Anweisung zu erhalten, die Anweisung auszuf√ºhren und das Delta der Uhr daf√ºr zu berechnen. Die Ergebnisse k√∂nnten im IET-Array f√ºr N Profilierungszyklen gespeichert werden, um den Durchschnittswert zu erhalten und den Prozess f√ºr die CPUID zu wiederholen. Wenn die Ausf√ºhrungszeit des CPUID-Befehls l√§nger als der arithmetische Befehl ist,Dann ist dies ein zuverl√§ssiges Zeichen daf√ºr, dass das System virtuell ist, da eine arithmetische Anweisung unter keinen Umst√§nden mehr Zeit als die Ausf√ºhrung der CPUID aufwenden kann, um Informationen √ºber den Hersteller oder die Version zu erhalten. Ein solches Erkennungsverfahren kann auch solche erkennen, die TSC-Offset / Skalierung verwenden.</font></font><br><br> ,                 ,      IRQL  ,      .   ,    BattlEye   ,        .    BattlEye       ,      . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de484420/">https://habr.com/ru/post/de484420/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de484408/index.html">RUTM-√Ñra</a></li>
<li><a href="../de484410/index.html">N√ºtzliche Entwicklergewohnheiten</a></li>
<li><a href="../de484412/index.html">NXP S32G Prozessor f√ºr moderne Automobilelektronikarchitektur</a></li>
<li><a href="../de484414/index.html">Ausw√§hlen eines Archivierungsprogramms f√ºr Sicherungsprotokolle</a></li>
<li><a href="../de484418/index.html">CEO Motoriki Ilya Chekh: Manchmal erwarten sie ideale Arbeit von experimentellen Prothesen, und dann sind sie entt√§uscht</a></li>
<li><a href="../de484424/index.html">Nvidia Orin - ein Chip f√ºr Roboterfahrzeuge</a></li>
<li><a href="../de484426/index.html">Ich und mein Moped. Ineffizienzskalierung</a></li>
<li><a href="../de484428/index.html">Eine Idee f√ºr ein Startup ohne Investor w√§hlen: im Gegenteil</a></li>
<li><a href="../de484430/index.html">Die weltweit erste HDR-f√§hige VR-Brille: Was ist √ºber den Prototyp von Panasonic bekannt?</a></li>
<li><a href="../de484436/index.html">Ungrateful Opensource: Der Entwickler des schnellsten Webservers hat sein Repository gel√∂scht - Wichtiges Update</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>