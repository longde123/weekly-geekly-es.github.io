<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö¥ ‚õé ü§¥ ¬øC√≥mo se ve tu texto? ü§™ ü§úüèø ü§∂üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Amigos, genial todos los viernes. Queremos compartir con ustedes una traducci√≥n de un art√≠culo preparado especialmente para estudiantes del curso "Des...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬øC√≥mo se ve tu texto?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/456110/"> Amigos, genial todos los viernes.  Queremos compartir con ustedes una traducci√≥n de un art√≠culo preparado especialmente para estudiantes del curso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Desarrollador de Android".</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Curso avanzado "</a> .  Que tengas una buena lectura. <br><br><img src="https://habrastorage.org/webt/vd/zx/ym/vdzxymfn0nm1ys_j8zkmlxz3w1m.png"><br><br>  C√≥mo dar estilo declarativamente al texto en Android. <br><br><img src="https://habrastorage.org/webt/5e/l9/cw/5el9cwaiwzb5lyueyebodvghtmk.png"><br>  <i>Ilustraci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Virginia Poltrack</a></i> <br><br>  <code>TextView</code> en aplicaciones de Android proporciona varios atributos para dise√±ar texto y varias formas de aplicarlos.  Estos atributos se pueden establecer directamente en el dise√±o, aplicar un estilo a la vista o el tema al dise√±o o, si lo desea, establecer la apariencia del texto.  ¬øPero qu√© de esto deber√≠a usarse?  ¬øY qu√© pasa si los combinas? <a name="habracut"></a><br><br><img src="https://habrastorage.org/webt/dq/uq/he/dquqher19iptbqt1qxilp4ohcyc.png"><br>  <i>¬øQu√© y cu√°ndo usar?</i> <br><br>  Este art√≠culo describe varios enfoques para la estilizaci√≥n declarativa de texto (es decir, cuando define estilos en un archivo XML), analiza el alcance y la prioridad de cada m√©todo. <br><br><h2>  tl; dr; </h2><br>  Deber√≠as leer la publicaci√≥n completa, pero aqu√≠ hay un resumen. <br><br>  Recuerde el orden de prioridad de varios m√©todos de estilo: si est√° tratando de estilizar un texto y no ve los resultados esperados, lo m√°s probable es que sus cambios sean anulados por algo con una prioridad m√°s alta en esta jerarqu√≠a: <br><br><img src="https://habrastorage.org/webt/f2/zr/lw/f2zrlwisr9g_nupki56f4fcv6g0.png"><br>  <i>Jerarqu√≠a de los m√©todos de dise√±o de texto.</i> <br><br>  Sugerir√≠a el siguiente procedimiento para dise√±ar: <br><br><ol><li>  Establezca cualquier estilo de aplicaci√≥n en <code>textViewStyle</code> como el estilo predeterminado para su tema. </li><li>  Instale el conjunto (peque√±o) de <code>TextAppearance</code> que <code>TextAppearance</code> su aplicaci√≥n (o usar√° / heredar√° de los <a href="">estilos de</a> MaterialComponent) y haga referencia a ellos directamente desde su vista </li><li>  Cree un <code>style</code> estableciendo atributos no admitidos por <code>TextAppearance</code> (que ellos mismos determinar√°n uno de sus <code>TextAppearance</code> ). </li><li>  Realice cualquier estilo √∫nico directamente en el dise√±o. </li></ol><br><h2>  Mostrar algo de estilo </h2><br>  Puede establecer directamente los atributos de <code>TextView</code> en el dise√±o, pero este enfoque puede ser m√°s tedioso e inseguro.  Imagine que de esta manera est√° intentando actualizar el color de todos los TextViews en la aplicaci√≥n.  Al igual que con todas las dem√°s vistas, puede (¬°y deber√≠a!) Usar estilos en su lugar para garantizar la coherencia, la reutilizaci√≥n y la facilidad de actualizaci√≥n.  Para este prop√≥sito, recomiendo crear estilos para el texto siempre que probablemente desee aplicar el mismo estilo a m√∫ltiples vistas.  Esto es extremadamente simple y es ampliamente compatible con el sistema de visualizaci√≥n de Android. <br><br>  ¬øQu√© sucede debajo del cap√≥ cuando le das estilo a la vista?  Si alguna vez escribi√≥ su vista personalizada, probablemente vio la llamada a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">context.obtainStyledAttributes (AttributeSet, int [], int, int)</a> .  Por lo tanto, el sistema de visualizaci√≥n en Android pasa a la vista los atributos especificados en el dise√±o.  El par√°metro <code>AttributeSet</code> , de hecho, puede considerarse como un mapa de los par√°metros XML que especifique en su dise√±o.  Si AttributeSet establece el estilo, <b>primero se lee</b> el <b>estilo</b> y luego se le aplican los atributos especificados directamente en la vista.  Por lo tanto, llegamos a la primera regla de prioridad. <br><br>  <b><i>Ver ‚Üí Estilo</i></b> <br><br>  Los atributos definidos directamente en la vista siempre "prevalecen" y anulan los atributos definidos en el estilo.  Tenga en cuenta que se aplica una <b>combinaci√≥n</b> de estilo y atributos de vista;  definir un atributo en la vista, que tambi√©n se especifica en el estilo, <b>no cancela</b> todo el estilo.  Tambi√©n debe tenerse en cuenta que, en su opini√≥n, no hay una forma real de determinar de d√≥nde viene la estilizaci√≥n;  El sistema de visualizaci√≥n lo decide una vez en una llamada similar.  No puede obtener ambas opciones y elegir. <br><br>  Aunque los estilos son extremadamente √∫tiles, tienen sus limitaciones.  Una de ellas es que solo puede aplicar un estilo a la vista (a diferencia de algo como CSS, donde puede aplicar varias clases).  <code>TextView</code> , sin embargo, tiene un truco; proporciona el atributo <code>TextAppearance</code> , que funciona de manera similar al <code>style</code> .  Si <code>TextAppearance</code> <code>style</code> texto mediante <code>TextAppearance</code> , deje el atributo de <code>style</code> libre para otros estilos, lo que parece pr√°ctico.  Echemos un vistazo m√°s de cerca a qu√© <code>TextAppearance</code> y c√≥mo funciona. <br><br><h2>  Aparici√≥n de texto </h2><br>  <code>TextAppearance</code> no tiene nada de m√°gico (por ejemplo, un modo secreto para aplicar varios estilos que no deber√≠a conocer), <code>TextView</code> ahorra trabajo innecesario.  Echemos un vistazo al constructor <code>TextView</code> para comprender lo que est√° sucediendo. <br><br><pre> <code class="kotlin hljs">TypedArray a = theme.obtainStyledAttributes(attrs, com.android.<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>.R.styleable.TextViewAppearance, defStyleAttr, defStyleRes); TypedArray appearance = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; int ap = a.getResourceId(com.android.<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>.R.styleable.TextViewAppearance_textAppearance, -<span class="hljs-number"><span class="hljs-number">1</span></span>); a.recycle(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ap != -<span class="hljs-number"><span class="hljs-number">1</span></span>) { appearance = theme.obtainStyledAttributes(ap, com.android.<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>.R.styleable.TextAppearance); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (appearance != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { readTextAppearance(context, appearance, attributes, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); appearance.recycle(); } <span class="hljs-comment"><span class="hljs-comment">// a little later a = theme.obtainStyledAttributes(attrs, com.android.internal.R.styleable.TextView, defStyleAttr, defStyleRes); readTextAppearance(context, a, attributes, true);</span></span></code> </pre> <br>  Entonces, ¬øqu√© est√° pasando aqu√≠?  Esencialmente, <code>TextView</code> primero busca ver si especific√≥ <code>android:textAppearance</code> , si es as√≠, carga este estilo y aplica todas las propiedades que se enumeran all√≠.  M√°s tarde, carga todos los atributos de la vista (que recuerda, incluido el estilo) y los aplica.  Entonces llegamos a la segunda regla de prioridad: <br><br>  <i><b>Ver ‚Üí Estilo ‚Üí Apariencia de texto</b></i> <br><br>  Como la apariencia del texto se verifica primero, cualquier atributo definido directamente en la vista o en el estilo lo anular√°. <br><br>  Con <code>TextAppearance</code> , hay otra <code>TextAppearance</code> a tener en cuenta: admite un <b>subconjunto</b> de los atributos de estilo que ofrece <code>TextView</code> .  Para comprender mejor lo que quiero decir, volvamos a esta l√≠nea: <br><br> <code>obtainStyledAttributes(ap, android.R.styleable.TextAppearance);</code> <br> <br>  Examinamos la versi√≥n <code>receiveStyledAttributes</code> con 4 argumentos, esta versi√≥n de 2 argumentos es ligeramente diferente de ella.  Ella mira el estilo dado (como lo define la primera <code>id</code> par√°metro) y lo filtra solo de acuerdo con los atributos en el estilo que aparecen en el segundo par√°metro, la matriz de <code>attrs</code> .  As√≠ que <code>android.R.styleable.TextAppearance</code> define el alcance de <code>TextAppearance</code> .  Al observar esta definici√≥n, vemos que <code>TextAppearance</code> <a href="">admite</a> muchos, <b>pero no todos, los</b> atributos que <a href="">admite</a> <code>TextView</code> . <br><br><pre> <code class="kotlin hljs">&lt;attr name=<span class="hljs-string"><span class="hljs-string">"textColor"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"textSize"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"textStyle"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"typeface"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"fontFamily"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"textColorHighlight"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"textColorHint"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"textColorLink"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"textAllCaps"</span></span> format=<span class="hljs-string"><span class="hljs-string">"boolean"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"shadowColor"</span></span> format=<span class="hljs-string"><span class="hljs-string">"color"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"shadowDx"</span></span> format=<span class="hljs-string"><span class="hljs-string">"float"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"shadowDy"</span></span> format=<span class="hljs-string"><span class="hljs-string">"float"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"shadowRadius"</span></span> format=<span class="hljs-string"><span class="hljs-string">"float"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"elegantTextHeight"</span></span> format=<span class="hljs-string"><span class="hljs-string">"boolean"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"letterSpacing"</span></span> format=<span class="hljs-string"><span class="hljs-string">"float"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"fontFeatureSettings"</span></span> format=<span class="hljs-string"><span class="hljs-string">"string"</span></span> /&gt;</code> </pre> <br>  <i><b>Atributos de estilo admitidos por <code>TextAppearance</code></b></i> <br><br>  Estos son algunos atributos de <code>TextView</code> que no est√°n incluidos en <code>TextAppearance</code> : <code>lineHeight[Multiplier|Extra]</code> , <code>lines</code> , <code>breakStrategy</code> y <code>breakStrategy</code> .  <code>TextAppearance</code> funciona a nivel de caracteres, no a nivel de p√°rrafo, por lo que los atributos que afectan a todo el dise√±o no son compatibles. <br><br>  Por lo tanto, <code>TextAppearance</code> muy √∫til, nos permite definir un estilo orientado a los atributos de estilizaci√≥n del texto y deja el <code>style</code> a la vista libre para otros fines.  Sin embargo, tiene un alcance limitado y se encuentra en la parte inferior de la cadena de prioridad, as√≠ que no se olvide de las limitaciones. <br><br><h2>  Valores predeterminados razonables </h2><br>  Cuando observamos c√≥mo la vista de Android resuelve los atributos ( <code>context.obtainStyledAttributes</code> ), en realidad lo simplificamos un poco.  Ella llama a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">theme.obtainStyledAttributes</a> (usando el <code>Theme Context</code> actual 'a).  Al verificar el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enlace</a> , se muestra el orden de prioridad que examinamos anteriormente, y se indican 2 lugares m√°s que est√° buscando para resolver atributos: el estilo predeterminado para la vista y el tema. <br><br>  <i>Al determinar el valor final de un atributo particular, entran en juego cuatro par√°metros de entrada:</i> <i><br><br></i> <ol><li>  <i>Cualquier valor de atributo en este AttributeSet.</i> </li><li>  <i>El recurso de estilo especificado en AttributeSet (denominado "estilo").</i> </li><li>  <i>El estilo predeterminado especificado por defStyleAttr y defstyleres</i> </li><li>  <i>Valores b√°sicos en este hilo.</i> </li></ol><br>  <i>Orden de prioridad de estilo de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n</a> del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tema</a></i> <br><br>  Volveremos a los temas, pero primero echemos un vistazo a los estilos predeterminados.  ¬øCu√°l es este estilo predeterminado?  Para responder a esta pregunta, creo que ser√≠a √∫til salir un poco del tema <code>TextView</code> y echar un vistazo a un <code>Button</code> simple.  Cuando inserta <code><code>&lt;</code> <code>Button</code> <code>&gt;</code></code> en su dise√±o, se ve m√°s o menos as√≠. <br><br><img src="https://habrastorage.org/webt/qn/da/wn/qndawn5dk_gwfj3h7wki2xzee8u.png"><br>  <i>Bot√≥n est√°ndar</i> <br><br>  Por qu√©  Si observa el c√≥digo fuente de <code>Button</code> , ver√° que es bastante escaso: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Button</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TextView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Button(Context context) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(context, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Button(Context context, AttributeSet attrs) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(context, attrs, com.android.<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>.R.attr.buttonStyle); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Button(Context context, AttributeSet attrs, int defStyleAttr) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(context, attrs, defStyleAttr, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Button(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(context, attrs, defStyleAttr, defStyleRes); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CharSequence getAccessibilityClassName() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Button.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.getName(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> PointerIcon onResolvePointerIcon(MotionEvent event, int pointerIndex) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getPointerIcon() == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; isClickable() &amp;&amp; isEnabled()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PointerIcon.getSystemIcon(getContext(), PointerIcon.TYPE_HAND); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onResolvePointerIcon(event, pointerIndex); } }</code> </pre> <br>  Eso es todo!  Aqu√≠ est√° toda la clase (sin comentarios).  Puede verificarlo usted mismo <a href="">aqu√≠</a> .  Esperar√©  Entonces, ¬øde d√≥nde viene el fondo, las letras may√∫sculas, la ondulaci√≥n, etc.?  Es posible que haya fallado, pero todo se definir√° en el constructor con 2 argumentos;  uno que se llama cuando el dise√±o se toma de XML.  Este es el √∫ltimo par√°metro que define <code>defaultStyleAttr</code> en <code>com.android.internal.R.attr.buttonStyle</code> .  Este es el estilo predeterminado, que es esencialmente un punto de referencia indirecto, lo que le permite especificar el estilo predeterminado.  No apunta directamente al estilo, pero le permite se√±alar uno de los especificados en su tema que comprobar√° al resolver atributos.  Y eso es exactamente de lo que todos los temas que generalmente heredas hacen para proporcionar la apariencia de los widgets est√°ndar.  Por ejemplo, si observa el tema Material, define <code>@style/Widget.Material.Light.Button</code> , y es este estilo el que proporciona todos los atributos que pasar√° <code>theme.obtainStyledAttributes</code> si no especific√≥ nada m√°s. <br><br>  Volver a <code>TextView</code> , tambi√©n ofrece un estilo predeterminado: <code>textViewStyle</code> .  Esto puede ser muy conveniente si desea aplicar algunos estilos a cada TextView en su aplicaci√≥n.  Suponga que desea establecer el espaciado de l√≠nea predeterminado en 1.2.  Puede hacer esto con <code>style/TextAppearance</code> e intentar aplicarlo durante una revisi√≥n de c√≥digo (o tal vez incluso con una elegante regla personalizada en Lint), pero debe estar atento y asegurarse de reclutar nuevos miembros del equipo , tenga cuidado con la refactorizaci√≥n, etc. <br><br>  Un mejor enfoque ser√≠a especificar su propio estilo predeterminado para todas las <code>TextView</code> de <code>TextView</code> en la aplicaci√≥n, estableciendo el comportamiento deseado.  Puede hacerlo configurando su propio estilo para <code>textViewStyle</code> , que se hereda de la plataforma o de <code>MaterialComponents/AppCompat</code> de forma predeterminada. <br><br><pre> <code class="kotlin hljs">&lt;style name=<span class="hljs-string"><span class="hljs-string">"Theme.MyApp"</span></span> parent=<span class="hljs-string"><span class="hljs-string">"@style/Theme.MaterialComponents.Light"</span></span>&gt; ... &lt;item name=<span class="hljs-string"><span class="hljs-string">"android:textViewStyle"</span></span>&gt;<span class="hljs-meta"><span class="hljs-meta">@style</span></span>/Widget.MyApp.TextView&lt;/item&gt;&lt;/style&gt; &lt;style name=<span class="hljs-string"><span class="hljs-string">"Widget.MyApp.TextView"</span></span> parent=<span class="hljs-string"><span class="hljs-string">"@android:style/Widget.Material.TextView"</span></span>&gt; &lt;item name=<span class="hljs-string"><span class="hljs-string">"android:textAppearance"</span></span>&gt;<span class="hljs-meta"><span class="hljs-meta">@style</span></span>/TextAppearance.MyApp.Body&lt;/item&gt; &lt;item name=<span class="hljs-string"><span class="hljs-string">"android:lineSpacingMultiplier"</span></span>&gt;<span class="hljs-meta"><span class="hljs-meta">@dimen</span></span>/text_line_spacing&lt;/item&gt; &lt;/style&gt;</code> </pre> <br>  Con esto en mente, nuestra regla de prioridad toma la forma: <br><br>  <i><b>Ver -&gt; Estilo -&gt; Estilo predeterminado -&gt; Apariencia de texto</b></i> <br><br>  Como parte de la resoluci√≥n de los atributos del sistema de visualizaci√≥n, este espacio se completa despu√©s de los estilos (de modo que todo en el estilo se cancela por el estilo aplicado o los atributos de visualizaci√≥n por defecto), pero a√∫n anular√° la apariencia del texto.  Los estilos predeterminados pueden ser muy convenientes.  Si alguna vez decide escribir su propia vista personalizada, pueden ser una forma poderosa de implementar el comportamiento predeterminado, facilitando la personalizaci√≥n. <br><br>  Si hereda el widget y no especifica su propio estilo predeterminado, aseg√∫rese de usar el estilo de clase principal predeterminado en los constructores (no pase solo 0).  Por ejemplo, si hereda de <code>AppCompatTextView</code> y escribe su propio constructor con 2 argumentos, aseg√∫rese de pasar <code>android.R.attr.textViewStyle  defaultStyleAttr</code> ( <a href="">como aqu√≠</a> ), de lo contrario perder√° el comportamiento de la clase padre. <br><br><h2>  Temas </h2><br>  Como se mencion√≥ anteriormente, hay otra forma (√∫ltima, lo prometo) de proporcionar informaci√≥n de estilo.  Otro lugar <code>theme.obtainStyledAttributes</code> se ver√° directamente en el tema en s√≠.  Es decir, si agrega un atributo de estilo a su tema, por ejemplo <code>android:textColor</code> , el sistema de visualizaci√≥n lo seleccionar√° como √∫ltimo recurso.  Como regla general, es una mala idea mezclar atributos de tema y atributos de estilo, es decir, lo que aplica directamente a la vista, como regla, nunca debe establecerse para el tema (y viceversa), pero hay un par de raras excepciones. <br><br>  Un ejemplo ser√≠a cuando intente cambiar la fuente en toda la aplicaci√≥n.  Puede usar uno de los m√©todos descritos anteriormente, pero ajustar manualmente los estilos / apariencia del texto en todas partes ser√° mon√≥tono e inseguro, y los estilos predeterminados solo funcionar√°n en el nivel del widget;  las subclases pueden anular este comportamiento, por ejemplo, los botones definen su propio <code>android:buttonStyle</code> , que su <code>android:textViewStyle</code> no recoger√°.  En cambio, puede especificar la fuente en su tema: <br><br><pre> <code class="kotlin hljs">&lt;style name=<span class="hljs-string"><span class="hljs-string">"Theme.MyApp"</span></span> parent=<span class="hljs-string"><span class="hljs-string">"@style/Theme.MaterialComponents.Light"</span></span>&gt; ... &lt;item name=<span class="hljs-string"><span class="hljs-string">"android:fontFamily"</span></span>&gt;<span class="hljs-meta"><span class="hljs-meta">@font</span></span>/space_mono&lt;/item&gt; &lt;/style&gt;</code> </pre> <br>  Ahora, cualquier vista que admita este atributo lo recoger√° si no es anulado por algo con una prioridad m√°s alta: <br><br>  <i><b>Ver ‚Üí Estilo ‚Üí Estilo predeterminado ‚Üí Tema ‚Üí Apariencia de texto</b></i> <br><br>  Nuevamente, dado que esto es parte del sistema de dise√±o de vistas, anular√° todo lo que se proporciona en forma de texto, pero ser√° anulado por cualquier atributo m√°s espec√≠fico. <br><br>  Recuerda esta prioridad.  En nuestro ejemplo con una fuente para toda la aplicaci√≥n, puede esperar que la <code>Toolbar</code> seleccione esta fuente, ya que contiene el t√≠tulo, que es un <code>TextView</code> .  Sin embargo, la clase Toolbar en s√≠ misma define un estilo predeterminado que contiene <code>titleTextAppearance</code> , que define <code>android:fontFamily</code> , y lo establece directamente en el encabezado <code>TextView</code> , anulando el valor del nivel del tema.  Los estilos de nivel de tema pueden ser √∫tiles, pero f√°ciles de anular, as√≠ que aseg√∫rese de aplicarlos correctamente. <br><br><h2>  Bonus: problemas no resueltos </h2><br>  Todo este art√≠culo se dedic√≥ al dise√±o declarativo de texto en el nivel de vista, es decir, c√≥mo <code>TextView</code> todo el <code>TextView</code> durante el llenado.  Cualquier estilo aplicado despu√©s del relleno (por ejemplo, <code>textView.setTextColor(‚Ä¶)</code> ) anular√° el estilo declarativo.  <code>TextView</code> tambi√©n admite estilos m√°s peque√±os a trav√©s de <code>Span</code> .  No voy a entrar en este tema, como se describe en detalle en los art√≠culos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Florina Muntenescu</a> . <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Estilo de texto fant√°stico con tramos</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tramos entendidos</a> <br><br>  Mencionar√© esto para completar, para tener en cuenta que el estilo y la amplitud del programa estar√°n en la parte superior del orden de prioridad: <br><br>  <i><b>Span ‚Üí Setters ‚Üí Ver ‚Üí Estilo ‚Üí Estilo predeterminado ‚Üí Tema ‚Üí Apariencia de texto</b></i> <br><br><h2>  Elige tu estilo </h2><br>  Aunque hay varias formas de dise√±ar su texto, comprender las diferencias entre los m√©todos y sus limitaciones lo ayuda a encontrar la herramienta adecuada para una tarea espec√≠fica o comprender por qu√© un m√©todo tiene prioridad sobre otro. <br><br>  ¬°Que tengas un buen estilo de texto! <br><br>  Invitamos a todos a un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">seminario web gratuito</a> en el marco del cual nos familiarizaremos con el marco DI Dagger 2: estudiaremos c√≥mo Dagger2 genera c√≥digo, trataremos las anotaciones JSR 330 y las construcciones Dagger2, aprenderemos c√≥mo usar Dagger2 en una aplicaci√≥n de m√≥dulos m√∫ltiples y consideraremos el inyector Dagger para Android. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/456110/">https://habr.com/ru/post/456110/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../456100/index.html">Ahora en el nuevo empaque: Kingston A400 en formato M.2 se apresura al mercado</a></li>
<li><a href="../456102/index.html">Reportes f√°ciles en C / C ++</a></li>
<li><a href="../456104/index.html">Ezblock Pi: programaci√≥n sin programaci√≥n, esta vez para fan√°ticos de Raspberry Pi</a></li>
<li><a href="../456106/index.html">Dividimos las funciones m√°s r√°pido. Experiencia de desarrollo de Android en Badoo</a></li>
<li><a href="../456108/index.html">Habr Weekly # 5 / Los temas oscuros est√°n en todas partes, las f√°bricas chinas en la Federaci√≥n de Rusia, donde los bancos han fluido, Pixel 4, ML contamina la atm√≥sfera</a></li>
<li><a href="../456112/index.html">Superando la Ley de Moore: C√≥mo reemplazar los transistores planos tradicionales</a></li>
<li><a href="../456114/index.html">Qu√© hay de nuevo en el desarrollo de Mamba</a></li>
<li><a href="../456116/index.html">C√≥mo construir un hermoso esquema de base de datos en yEd Graph Editor</a></li>
<li><a href="../456118/index.html">"La m√°quina de la emoci√≥n" de Marvin Minsky: Cap√≠tulo 8.1-2 "Creatividad"</a></li>
<li><a href="../456122/index.html">El hackat√≥n m√°s grande de Contour</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>