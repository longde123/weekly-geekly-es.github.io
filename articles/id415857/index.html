<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï¥üèª üåÇ üçÄ Kerangka UI dalam 5 menit üôéüèø üåå üî∂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beberapa waktu lalu saya bertanya-tanya mengapa ada begitu banyak kerangka kerja UI untuk web? Saya sudah berada di IT untuk waktu yang lama dan saya ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kerangka UI dalam 5 menit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415857/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/qi/bt/su/qibtsu7-adonxh3cztr05mvwabi.png"></div><br><p>  Beberapa waktu lalu saya bertanya-tanya mengapa ada begitu banyak kerangka kerja UI untuk web?  Saya sudah berada di IT untuk waktu yang lama dan saya tidak ingat bahwa perpustakaan UI pada platform lain lahir dan mati dengan kecepatan yang sama seperti di WEB.  Perpustakaan untuk OS desktop, seperti: MFC, Qt, WPF, dll.  - adalah monster yang berkembang selama bertahun-tahun dan tidak memiliki banyak alternatif.  Semuanya berbeda di Web - kerangka kerja dirilis hampir setiap minggu, para pemimpin berubah - mengapa ini terjadi? </p><br><p>  Saya pikir alasan utama adalah bahwa kompleksitas penulisan perpustakaan UI telah menurun tajam.  Ya, untuk menulis perpustakaan yang akan digunakan banyak orang - masih membutuhkan waktu dan keahlian yang besar, tetapi untuk menulis prototipe - yang, ketika dibungkus dengan API yang nyaman - akan siap digunakan - dibutuhkan waktu yang sangat sedikit.  Jika Anda tertarik bagaimana hal ini dapat dilakukan, baca terus. <a name="habracut"></a></p><br><h4 id="zachem-eta-statya">  Kenapa artikel ini? </h4><br><p>  Pada suatu waktu di Habr√© ada serangkaian artikel - untuk menulis X selama 30 baris kode pada js. </p><br><p>  Saya pikir - apakah mungkin untuk menulis reaksi dalam 30 baris?  Ya, untuk 30 baris saya tidak berhasil, tetapi hasil akhirnya cukup sepadan dengan angka ini. </p><br><p>  Secara umum, tujuan artikel ini murni mendidik.  Ini dapat membantu pemahaman yang lebih dalam tentang prinsip kerangka UI berdasarkan virtual house.  Pada artikel ini saya ingin menunjukkan betapa sederhananya membuat Kerangka UI lain berdasarkan rumah virtual. </p><br><p>  Pada awalnya saya ingin mengatakan apa yang saya maksud dengan kerangka UI - karena banyak yang berbeda pendapat tentang ini.  Sebagai contoh, beberapa orang percaya bahwa Angular dan Ember adalah kerangka kerja UI dan React hanyalah sebuah perpustakaan yang akan membuatnya lebih mudah untuk bekerja dengan tampilan bagian dari aplikasi. </p><br><p>  Kami mendefinisikan kerangka UI sebagai berikut: ini adalah pustaka yang membantu untuk membuat / memperbarui / menghapus elemen halaman atau individu dalam hal ini berbagai pembungkus yang lebih luas atas DOM API dapat berubah menjadi kerangka UI, satu-satunya pertanyaan adalah opsi abstraksi (API) yang disediakan pustaka ini untuk memanipulasi DOM dan dalam efektivitas manipulasi ini </p><br><p>  Dalam kata-kata yang diusulkan - Bereaksi adalah kerangka UI. </p><br><p>  Nah, mari kita lihat bagaimana menulis Bereaksi Anda dengan blackjack dan banyak lagi.  Bereaksi dikenal menggunakan konsep rumah virtual.  Dalam bentuk yang disederhanakan, itu terdiri dalam kenyataan bahwa node DOM nyata dibangun sesuai ketat dengan node pohon DOM virtual yang sebelumnya dibangun.  Manipulasi langsung dari DOM nyata tidak diterima, jika Anda perlu membuat perubahan ke DOM nyata, perubahan dilakukan ke DOM virtual, maka versi baru dari DOM virtual dibandingkan dengan yang lama, perubahan dikumpulkan yang harus diterapkan ke DOM nyata dan mereka diterapkan sedemikian rupa sehingga interaksi dengan DOM nyata diminimalkan DOM - yang membuat aplikasi lebih optimal. </p><br><p>  Karena virtual house tree adalah objek skrip java biasa - cukup mudah untuk memanipulasinya - mengubah / membandingkan node-nya, dengan kata itu mudah di sini saya mengerti bahwa kode assembly adalah virtual tetapi cukup sederhana dan dapat dihasilkan sebagian oleh preprosesor dari bahasa deklaratif JSX tingkat tinggi. </p><br><h4 id="nachnem-s-jsx">  Mari kita mulai dengan JSX </h4><br><p>  Ini adalah contoh kode JSX </p><br><pre><code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Component = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"main"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">input</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{()</span></span></span></span><span class="xml"><span class="hljs-tag"> =&gt;</span></span></span><span class="xml"> console.log('yo')}&gt; Submit </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> Component</code> </pre> <br><p>  kita perlu membuat DOM virtual seperti itu saat memanggil fungsi <code>Component</code> </p><br><pre> <code class="hljs powershell">const vdom = { type: <span class="hljs-string"><span class="hljs-string">'div'</span></span>, props: { className: <span class="hljs-string"><span class="hljs-string">'main'</span></span> }, children: [ { <span class="hljs-type"><span class="hljs-type">type</span></span>: <span class="hljs-string"><span class="hljs-string">'input'</span></span> }, { <span class="hljs-type"><span class="hljs-type">type</span></span>: <span class="hljs-string"><span class="hljs-string">'button'</span></span>, <span class="hljs-type"><span class="hljs-type">props</span></span>: { <span class="hljs-type"><span class="hljs-type">onClick</span></span>: () =&gt; <span class="hljs-type"><span class="hljs-type">console.log</span></span>(<span class="hljs-string"><span class="hljs-string">'yo'</span></span>) }, <span class="hljs-type"><span class="hljs-type">children</span></span>: [<span class="hljs-string"><span class="hljs-string">'Submit'</span></span>] } ] }</code> </pre> <br><p>  Tentu saja, kami tidak akan menulis transformasi ini secara manual, kami akan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">plugin ini</a> , plugin sudah usang, tetapi cukup sederhana untuk membantu kami memahami cara kerja semuanya.  Ini menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jsx-transform</a> , yang mengubah JSX seperti ini: </p><br><pre> <code class="hljs ruby">jsx.fromString(<span class="hljs-string"><span class="hljs-string">'&lt;h1&gt;Hello World&lt;/h1&gt;'</span></span>, { <span class="hljs-symbol"><span class="hljs-symbol">factory:</span></span> <span class="hljs-string"><span class="hljs-string">'h'</span></span> }); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'h("h1", null, ["Hello World"])'</span></span></code> </pre> <br><p>  jadi, semua yang perlu kita lakukan adalah mengimplementasikan konstruktor vdom dari h node, sebuah fungsi yang secara rekursif akan membuat node DOM virtual, dalam kasus reaksi, fungsi React.createElement melakukan ini.  Di bawah ini adalah implementasi primitif dari fungsi tersebut </p><br><pre> <code class="hljs actionscript">export <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">h</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(type, props, </span></span><span class="hljs-rest_arg"><span class="hljs-function"><span class="hljs-params"><span class="hljs-rest_arg">...stack</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> children = (stack || []).reduce(addChild, []) props = props || {} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> type === <span class="hljs-string"><span class="hljs-string">"string"</span></span> ? { type, props, children } : type(props, children) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addChild</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(acc, node)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Array.isArray(node)) { acc = node.reduce(addChild, acc) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span> == node || <span class="hljs-literal"><span class="hljs-literal">true</span></span> === node || <span class="hljs-literal"><span class="hljs-literal">false</span></span> === node) { } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { acc.push(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> node === <span class="hljs-string"><span class="hljs-string">"number"</span></span> ? node + <span class="hljs-string"><span class="hljs-string">""</span></span> : node) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> acc }</code> </pre> <br><p>  Tentu saja, rekursi menyulitkan kode sedikit di sini, tapi saya harap jelas, sekarang dengan fungsi ini kita dapat membangun vdom </p><br><pre> <code class="hljs scala"><span class="hljs-symbol"><span class="hljs-symbol">'h</span></span>(<span class="hljs-string"><span class="hljs-string">"h1"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, [<span class="hljs-string"><span class="hljs-string">"Hello World"</span></span>])' =&gt; { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>: <span class="hljs-symbol"><span class="hljs-symbol">'h</span></span>1', props:<span class="hljs-literal"><span class="hljs-literal">null</span></span>, children:[<span class="hljs-symbol"><span class="hljs-symbol">'Hello</span></span> <span class="hljs-type"><span class="hljs-type">World</span></span>']}</code> </pre> <br><p>  dan untuk node-node dari sarang apa pun </p><br><p>  Hebat, sekarang fungsi Komponen kami mengembalikan simpul vdom. </p><br><p>  Sekarang bagian yang <code></code> adalah, kita perlu menulis fungsi <code>patch</code> yang mengambil elemen DOM root dari aplikasi, vdom lama, vdom baru, dan memperbarui node DOM nyata sesuai dengan vdom baru. </p><br><p>  Mungkin Anda dapat menulis kode ini dengan lebih mudah, tetapi ternyata saya mengambil kode dari paket picodom </p><br><pre> <code class="hljs powershell">export <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">patch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(parent, oldNode, newNode)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> patchElement(parent, parent.children[<span class="hljs-number"><span class="hljs-number">0</span></span>], oldNode, newNode) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">patchElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(parent, element, oldNode, node, isSVG, nextSibling)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oldNode == null) { element = parent.insertBefore(createElement(node, isSVG), element) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.type != oldNode.type) { const oldElement = element element = parent.insertBefore(createElement(node, isSVG), oldElement) removeElement(parent, oldElement, oldNode) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { updateElement(element, oldNode.props, node.props) isSVG = isSVG || node.type === <span class="hljs-string"><span class="hljs-string">"svg"</span></span> let childNodes = [] ; (element.childNodes || []).forEach(element =&gt; childNodes.push(element)) let oldNodeIdex = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.children &amp;&amp; node.children.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; node.children.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oldNode.children &amp;&amp; oldNodeIdex &lt;= oldNode.children.length &amp;&amp; (node.children[<span class="hljs-type"><span class="hljs-type">i</span></span>].type &amp;&amp; node.children[<span class="hljs-type"><span class="hljs-type">i</span></span>].type === oldNode.children[<span class="hljs-type"><span class="hljs-type">oldNodeIdex</span></span>].type || (!node.children[<span class="hljs-type"><span class="hljs-type">i</span></span>].type &amp;&amp; node.children[<span class="hljs-type"><span class="hljs-type">i</span></span>] === oldNode.children[<span class="hljs-type"><span class="hljs-type">oldNodeIdex</span></span>])) ) { patchElement(element, childNodes[<span class="hljs-type"><span class="hljs-type">oldNodeIdex</span></span>], oldNode.children[<span class="hljs-type"><span class="hljs-type">oldNodeIdex</span></span>], node.children[<span class="hljs-type"><span class="hljs-type">i</span></span>], isSVG) oldNodeIdex++ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { let newChild = element.insertBefore( createElement(node.children[<span class="hljs-type"><span class="hljs-type">i</span></span>], isSVG), childNodes[<span class="hljs-type"><span class="hljs-type">oldNodeIdex</span></span>] ) patchElement(element, newChild, {}, node.children[<span class="hljs-type"><span class="hljs-type">i</span></span>], isSVG) } } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var i = oldNodeIdex; i &lt; childNodes.length; i++) { removeElement(element, childNodes[<span class="hljs-type"><span class="hljs-type">i</span></span>], oldNode.children ? oldNode.children[<span class="hljs-type"><span class="hljs-type">i</span></span>] || {} : {}) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element }</code> </pre> <br><p>  Implementasi naif ini, ini sangat tidak optimal, tidak memperhitungkan pengidentifikasi elemen (kunci, id) - untuk benar memperbarui elemen yang diperlukan dalam daftar, tetapi dalam kasus primitif itu berfungsi dengan baik. </p><br><p>  Implementasi <code>createElement updateElement removeElement</code> saya tidak membawanya ke sini, yang penting, siapa pun yang tertarik dapat melihat sumbernya di <a href="">sini</a> . </p><br><p>  Ada satu-satunya peringatan - ketika properti <code>value</code> untuk elemen <code>input</code> diperbarui, perbandingan tidak boleh dilakukan dengan vnode lama tetapi dengan atribut <code>value</code> di rumah nyata - ini akan mencegah elemen aktif memperbarui properti ini (karena sudah diperbarui di sana) dan mencegah masalah dengan kursor dan seleksi. </p><br><p>  Nah, itu saja sekarang kita hanya perlu mengumpulkan potongan-potongan ini dan menulis Kerangka UI <br>  Kami tetap dalam <a href="">5 baris</a> . </p><br><ol><li>  Seperti dalam Bereaksi, untuk membangun aplikasi kita membutuhkan 3 parameter <br> <code>export function app(selector, view, initProps) {</code> <br>  selector - selector dom root di mana aplikasi akan di-mount (secara default 'body') <br>  view - fungsi yang membangun vnode root <br>  initProps - properti aplikasi awal </li><li>  Ambil elemen root di DOM <br> <code>const rootElement = document.querySelector(selector || 'body')</code> </li> <li>  Kami mengumpulkan vdom dengan properti awal <br> <code>let node = view(initProps)</code> </li> <li>  Kami memasang vdom yang diterima di DOM sebagai vdom lama yang kami ambil batal <br> <code>patch(rootElement, null, node)</code> </li> <li>  Kami mengembalikan fungsi pembaruan aplikasi dengan properti baru <br> <code>return props =&gt; patch(rootElement, node, (node = view(props)))</code> </li> </ol><br><p>  <strong>Kerangka sudah siap!</strong> </p><br><p>  'Hello world' pada Kerangka ini akan terlihat seperti ini: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { h, app } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../src/index"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h2</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{`Hello ${state}`}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h2</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">input</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{state}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">oninput</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{e</span></span></span></span><span class="xml"><span class="hljs-tag"> =&gt;</span></span></span><span class="xml"> render(e.target.value)} /&gt; </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ) } const render = app('body', view, 'world')</span></span></code> </pre> <br><p>  Pustaka ini, seperti Bereaksi, mendukung komposisi komponen, menambahkan, menghapus komponen saat runtime, sehingga dapat dianggap sebagai Kerangka UI <code></code> .  Sebuah use case yang sedikit lebih kompleks dapat ditemukan di sini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ToDo example</a> . </p><br><p>  Tentu saja, ada banyak hal di perpustakaan ini: peristiwa siklus hidup (walaupun tidak sulit untuk mempercepatnya, kami sendiri mengelola pembuatan / pemutakhiran / penghapusan node), pembaruan terpisah dari node anak seperti ini.setState (untuk ini Anda perlu menyimpan tautan ke elemen DOM untuk masing-masing simpul vdom - ini akan sedikit mempersulit logika), kode patchElement sangat tidak optimal, tidak akan berfungsi dengan baik pada sejumlah besar elemen, tidak melacak elemen dengan pengenal, dll. </p><br><p>  Bagaimanapun, perpustakaan dikembangkan untuk tujuan pendidikan - jangan menggunakannya dalam produksi :) </p><br><p>  <em>PS:</em> Saya terinspirasi oleh perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hyperapp yang</a> luar biasa untuk artikel ini, bagian dari kode diambil dari sana. </p><br><p>  Pengodean yang bagus! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id415857/">https://habr.com/ru/post/id415857/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id415845/index.html">Tanyakan Ethan: Bagaimana kita tahu umur tata surya?</a></li>
<li><a href="../id415847/index.html">Gadget audio tujuan khusus: Dictograph - dari bengkel dan opera hingga penyadapan pertama, mahakarya teknis 1907</a></li>
<li><a href="../id415851/index.html">Red Omega PS2 Emulator</a></li>
<li><a href="../id415853/index.html">Misi Hayabusa 2: asteroid mengungkapkan sejarah tata surya</a></li>
<li><a href="../id415855/index.html">Membuat pengontrol berdasarkan logika fuzzy dengan penyetelan multi-saluran</a></li>
<li><a href="../id415859/index.html">RuSSIR 2018: Sekolah Musim Panas ke-12 dalam Pengambilan Informasi</a></li>
<li><a href="../id415863/index.html">‚ÄúMulai minggu yang tepat‚Äù: gadget mana yang akan membantu mengurangi kebisingan sekitar dan ‚Äúmenangkap‚Äù konsentrasi</a></li>
<li><a href="../id415865/index.html">Basis pengetahuan penurunan harga (atau blog, atau dokumentasi proyek)</a></li>
<li><a href="../id415867/index.html">Y Combinator Investor School: Ron Conway</a></li>
<li><a href="../id415871/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 321 (25 Juni - 1 Juli 2018)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>