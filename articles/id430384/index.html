<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ„ ğŸ‘©ğŸ½â€ğŸ¤â€ğŸ‘¨ğŸ¾ ğŸš¨ Membuat peta dari fitur noise ğŸ•´ğŸ» ğŸ‘¶ğŸ» ğŸ‘¨â€ğŸš€</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salah satu artikel paling populer di situs saya dikhususkan untuk pembuatan peta poligon ( terjemahan dalam HabrÃ©). Membuat kartu semacam itu membutuh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membuat peta dari fitur noise</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430384/">  Salah satu artikel paling populer di situs saya dikhususkan untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pembuatan peta poligon</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terjemahan</a> dalam HabrÃ©).  Membuat kartu semacam itu membutuhkan banyak usaha.  Tetapi saya tidak memulai dengan ini, tetapi dengan tugas yang <em>jauh</em> lebih sederhana, yang akan saya uraikan di sini.  Teknik sederhana ini memungkinkan Anda membuat kartu semacam itu dalam kurang dari 50 baris kode: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b16/95e/c42/b1695ec42f626197fddd201f7f40fa8a.png"></div><br>  Saya tidak akan menjelaskan cara <em>menggambar</em> kartu seperti itu: itu tergantung pada bahasa, perpustakaan grafik, platform, dll.  Saya hanya akan menjelaskan cara <em>mengisi array</em> dengan data peta. <br><br><h2>  Kebisingan </h2><br>  Cara standar untuk menghasilkan peta 2D adalah menggunakan noise dengan pita frekuensi terbatas sebagai blok penyusun, seperti noise Perlin atau noise simplex.  Seperti inilah fungsi noise: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/855/159/49e/85515949e4c77ba82599050333ec79fa.png" alt="gambar"></div><br>  Kami menetapkan angka dari 0,0 hingga 1,0 untuk setiap titik di peta.  Dalam gambar ini, 0,0 berwarna hitam dan 1,0 berwarna putih. <a name="habracut"></a>  Berikut ini cara mengatur warna setiap titik kisi dalam sintaks bahasa mirip-C: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; height; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; width; x++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> nx = x/width - <span class="hljs-number"><span class="hljs-number">0.5</span></span>, ny = y/height - <span class="hljs-number"><span class="hljs-number">0.5</span></span>; value[y][x] = noise(nx, ny); } }</code> </pre> <br>  Pengulangan akan bekerja dengan cara yang sama dalam Javascript, Python, Haxe, C ++, C #, Java dan sebagian besar bahasa populer lainnya, jadi saya akan menunjukkannya dalam sintaks mirip-C sehingga Anda dapat mengonversinya ke bahasa yang Anda butuhkan.  Di sisa tutorial, saya akan menunjukkan bagaimana isi siklus berubah ( <code>value[y][x]=â€¦</code> garis <code>value[y][x]=â€¦</code> ) saat menambahkan fungsi baru.  Demo akan menunjukkan contoh lengkap. <br><br>  Di beberapa perpustakaan, perlu untuk menggeser atau mengalikan nilai yang dihasilkan untuk mengembalikannya dalam kisaran 0,0-1,0. <br><br><h2>  Tinggi </h2><br>  Kebisingan itu sendiri hanyalah kumpulan angka.  Kita harus memberinya <em>makna</em> .  Hal pertama yang dapat Anda pikirkan adalah untuk mengikat nilai noise ke ketinggian (ini disebut "peta ketinggian").  Mari kita ambil suara yang ditunjukkan di atas dan menggambarnya sebagai ketinggian: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/047/4bf/8d9/0474bf8d9dd73ad63fefc84140385f50.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b14/cb9/c53/b14cb9c535820e30c6eab79dda6322ec.png"></div><br>  Kode tetap hampir sama, dengan pengecualian loop dalam.  Sekarang terlihat seperti ini: <br><br><pre> <code class="cpp hljs">elevation[y][x] = noise(nx, ny);</code> </pre> <br>  Ya, dan hanya itu.  Data peta tetap sama, tetapi sekarang saya akan menyebutnya <code>elevation</code> (tinggi), bukan <code>value</code> . <br><br>  Kami punya banyak bukit, tetapi tidak lebih.  Apa yang salah <br><br><h3>  Frekuensi </h3><br>  Kebisingan dapat dihasilkan pada <em>frekuensi</em> apa pun.  Sejauh ini saya hanya memilih satu frekuensi.  Mari kita lihat bagaimana pengaruhnya. <br><br>  <strong>Coba ubah nilainya dengan slider</strong> (dalam artikel asli) dan lihat apa yang terjadi pada frekuensi yang berbeda: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pu/ox/dh/puoxdhmnucu5e3miflqogwqddwq.gif"></div><br>  Itu hanya mengubah skala.  Awalnya ini tampaknya tidak terlalu berguna, tetapi ternyata tidak.  Saya punya satu lagi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tutorial</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terjemahan</a> dalam HabrÃ©), yang menjelaskan <em>teori</em> : konsep seperti frekuensi, amplitudo, oktaf, noise pink dan biru, dan sebagainya. <br><br><pre> <code class="cpp hljs">elevation[y][x] = noise(freq * nx, freq * ny);</code> </pre> <br>  Kadang-kadang juga berguna untuk mengingat <em>panjang gelombang</em> , yang merupakan kebalikan dari besarnya.  Ketika frekuensinya dua kali lipat, ukurannya hanya dibelah dua.  Menggandakan panjang gelombang semua menjadi dua kali lipat.  Panjang gelombang adalah jarak yang diukur dalam piksel / ubin / meter atau unit lain yang telah Anda pilih untuk peta.  Ini terkait dengan frekuensi: <code>wavelength = map_size / frequency</code> . <br><br><h3>  Oktaf </h3><br>  Untuk membuat peta ketinggian lebih menarik, kami akan <em>menambahkan noise dengan frekuensi berbeda</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dr/wt/uj/drwtujuho39t3uluoanf5vthl6o.png"></div><br><br><pre> <code class="cpp hljs">elevation[y][x] = <span class="hljs-number"><span class="hljs-number">1</span></span> * noise(<span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.5</span></span> * noise(<span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.25</span></span> * noise(<span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny);</code> </pre> <br>  Mari kita gabungkan bukit frekuensi tinggi besar dengan bukit frekuensi tinggi kecil di satu peta.  <strong>Pindahkan penggeser</strong> (dalam artikel asli) untuk menambahkan bukit kecil ke dalam campuran: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/km/wh/bb/kmwhbbf29gwpdqcwtrbrnsighhw.gif"></div><br>  Sekarang jauh lebih seperti bantuan fraktal yang kita butuhkan!  Kita bisa mendapatkan bukit dan gunung yang kasar, tetapi kita masih tidak memiliki dataran datar.  Untuk melakukan ini, Anda perlu sesuatu yang lain. <br><br><h3>  Redistribusi </h3><br>  Fungsi noise memberi kita nilai antara 0 dan 1 (atau dari -1 hingga +1, tergantung pada perpustakaan).  Untuk membuat dataran datar, kita dapat <em>menaikkan ketinggian menjadi kekuatan</em> .  <strong>Gerakkan slider</strong> (dalam artikel asli) untuk mendapatkan derajat yang berbeda. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3d/px/wc/3dpxwcatvtjknukqlih0hs7fecs.gif"></div><br><pre> <code class="cpp hljs">e = <span class="hljs-number"><span class="hljs-number">1</span></span> * noise(<span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.5</span></span> * noise(<span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.25</span></span> * noise(<span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny); elevation[y][x] = Math.<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(e, exponent);</code> </pre> <br>  Nilai <em>tinggi ketinggian rata-rata lebih rendah ke dataran</em> , dan nilai rendah menaikkan ketinggian rata-rata menuju puncak gunung.  Kita harus menghilangkannya.  Saya menggunakan fungsi daya karena lebih sederhana, tetapi Anda dapat menggunakan kurva apa pun;  Saya memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">demo yang</a> lebih rumit. <br><br>  Sekarang kita memiliki peta ketinggian yang realistis, mari kita tambahkan bioma! <br><br><h2>  Bioma </h2><br>  Noise memberi angka, tetapi kita membutuhkan peta dengan hutan, gurun, dan lautan.  Hal pertama yang dapat Anda lakukan adalah mengubah ketinggian kecil menjadi air: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/et/hu/hv/ethuhvixmvjso_zt-_ev3gtu-tu.gif"></div><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">biome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; waterlevel) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WATER; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LAND; }</code> </pre> <br>  Wow, ini sudah menjadi seperti dunia yang dihasilkan secara prosedural!  Kami memiliki air, rumput, dan salju.  Tetapi bagaimana jika kita membutuhkan lebih banyak?  Mari kita membuat urutan air, pasir, rumput, hutan, sabana, padang pasir dan salju: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5fd/aa0/237/5fdaa023713e487a95fed02484380d03.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/1d9/8b4/6561d98b4ceda31b7ff49ece890e4e83.png"></div><br>  <i>Relief berdasarkan ketinggian</i> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">biome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WATER; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BEACH; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FOREST; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> JUNGLE; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.7</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SAVANNAH; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.9</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DESERT; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SNOW; }</code> </pre> <br>  Wow, itu terlihat hebat!  Untuk game Anda, Anda dapat mengubah nilai dan bioma.  Crysis akan memiliki lebih banyak hutan;  Skyrim memiliki lebih banyak es dan salju.  Tetapi tidak peduli bagaimana Anda mengubah angka, pendekatan ini sangat terbatas.  Jenis bantuan sesuai dengan ketinggian, oleh karena itu membentuk strip.  Untuk membuatnya lebih menarik, kita perlu memilih bioma berdasarkan sesuatu yang lain.  Mari kita buat peta kebisingan <em>kedua</em> untuk kelembaban. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f4/1e3/de8/4f41e3de81e756ee9097be620ff5e08e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c7c/b6a/317/c7cb6a31702505881dbbf3d2ddb1244b.png"></div><br>  <i>Di atas adalah suara ketinggian;</i>  <i>bawah - kebisingan kelembaban</i> <br><br>  Sekarang mari kita gunakan tinggi dan kelembaban <em>bersama</em> .  Pada gambar pertama yang ditunjukkan di bawah ini, sumbu y adalah tinggi (diambil dari gambar di atas), dan sumbu x adalah kelembaban (gambar kedua lebih tinggi).  Ini memberi kita peta yang menarik: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e9/34c/6c1/0e934c6c1358e89adc1b8e4e11b4b21c.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ca/d11/e8e/3cad11e8edae614c2600342c37d6d4eb.png"></div><br>  <i>Relief berdasarkan pada dua nilai noise</i> <br><br>  Ketinggian kecil adalah samudera dan pantai.  Ketinggian yang tinggi berbatu dan bersalju.  Di antaranya, kami mendapatkan beragam bioma.  Kode ini terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">biome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e, m)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> OCEAN; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.12</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BEACH; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &gt; <span class="hljs-number"><span class="hljs-number">0.8</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SCORCHED; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BARE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TUNDRA; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SNOW; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &gt; <span class="hljs-number"><span class="hljs-number">0.6</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.33</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_DESERT; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.66</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SHRUBLAND; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TAIGA; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &gt; <span class="hljs-number"><span class="hljs-number">0.3</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.16</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_DESERT; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.50</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GRASSLAND; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.83</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_DECIDUOUS_FOREST; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_RAIN_FOREST; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.16</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUBTROPICAL_DESERT; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.33</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GRASSLAND; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.66</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TROPICAL_SEASONAL_FOREST; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TROPICAL_RAIN_FOREST; }</code> </pre> <br>  Jika perlu, Anda dapat mengubah semua nilai ini sesuai dengan persyaratan game Anda. <br><br>  Jika kita tidak membutuhkan bioma, maka gradien halus (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini</a> ) dapat membuat warna: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd4/963/61d/bd496361d481367788a33ebece885cb6.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28e/799/58e/28e79958eb0b9990fa9e1978fa727def.png"></div><br>  Untuk kedua bioma dan gradien, nilai noise tunggal tidak memberikan variabilitas yang cukup, tetapi dua sudah cukup. <br><br><h2>  Iklim </h2><br>  Di bagian sebelumnya, saya menggunakan <em>ketinggian</em> sebagai pengganti <em>suhu</em> .  Semakin tinggi, semakin rendah suhu.  Namun, garis lintang geografis juga memengaruhi suhu.  Mari kita gunakan ketinggian dan garis lintang untuk mengontrol suhu: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mr/fz/qn/mrfzqnq2ouo7zupt4kscz5a2gv8.png"></div><br>  Di dekat kutub (garis lintang besar) iklimnya lebih dingin, dan di puncak gunung (ketinggian besar) iklimnya juga lebih dingin.  Sejauh ini saya telah mengusahakannya tidak terlalu sulit: untuk pendekatan yang tepat untuk parameter ini, Anda memerlukan banyak pengaturan halus. <br><br>  Ada juga perubahan iklim <em>musiman</em> .  Di musim panas dan musim dingin, belahan utara dan selatan menjadi lebih hangat dan lebih dingin, tetapi di khatulistiwa situasinya tidak banyak berubah.  Banyak yang juga dapat dilakukan di sini, misalnya, seseorang dapat mensimulasikan angin dan arus laut yang berlaku, efek bioma pada iklim, dan efek rata-rata lautan pada suhu. <br><br><h2>  Pulau-pulau </h2><br>  Dalam beberapa proyek, saya membutuhkan batas peta menjadi air.  Ini mengubah dunia menjadi satu atau lebih pulau.  Ada banyak cara untuk melakukan ini, tetapi saya menggunakan solusi yang cukup sederhana dalam generator peta poligon saya: Saya mengubah ketinggian sebagai <code>e = e + a - b*d^c</code> , di mana <code>d</code> adalah jarak dari pusat (pada skala 0-1).  Pilihan lain adalah mengubah <code>e = (e + a) * (1 - b*d^c)</code> .  Konstanta <code>a</code> menaikkan semuanya, <code>b</code> menurunkan tepian ke bawah, dan <code>c</code> mengontrol laju penurunan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uq/gb/s4/uqgbs4h2ifsrwd2hsfvrrhue3ju.png"></div><br>  <em>Saya tidak sepenuhnya puas dengan ini</em> dan masih banyak yang harus dieksplorasi.  Haruskah jarak Manhattan atau Euclidean?  Haruskah itu tergantung pada jarak ke pusat atau pada jarak ke tepi?  Haruskah jarak kuadrat, atau linier, atau memiliki derajat lain?  Haruskah itu penambahan / pengurangan, atau perkalian / pembagian, atau sesuatu yang lain?  Dalam artikel asli, <b>coba</b> Tambah, a = 0,1, b = 0,3, c = 2,0, atau <b>coba</b> Lipatgandakan, a = 0,05, b = 1,00, c = 1,5.  Opsi yang sesuai dengan Anda bergantung pada proyek Anda. <br><br>  Mengapa tetap menggunakan fungsi matematika standar?  Seperti yang saya katakan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tentang kerusakan pada RPG</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terjemahan</a> pada HabrÃ©), semua orang (termasuk saya) menggunakan fungsi matematika, seperti polinomial, distribusi eksponensial, dll., Tetapi di komputer kita tidak dapat dibatasi pada mereka.  Kita dapat mengambil fungsi formasi <em>apa saja</em> dan menggunakannya di sini, menggunakan tabel pencarian <code>e = e + height_adjust[d]</code> .  Sejauh ini saya belum mempelajari masalah ini. <br><br><h2>  Kebisingan runcing </h2><br>  Alih-alih menaikkan ketinggian ke kekuatan, kita dapat menggunakan nilai absolut untuk membuat puncak yang tajam: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ridgenoise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> * (<span class="hljs-number"><span class="hljs-number">0.5</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-number"><span class="hljs-number">0.5</span></span> - noise(nx, ny))); }</code> </pre> <br>  Untuk menambahkan oktaf, kita dapat memvariasikan amplitudo frekuensi tinggi sehingga hanya pegunungan yang menerima suara yang ditambahkan: <br><br><pre> <code class="cpp hljs">e0 = <span class="hljs-number"><span class="hljs-number">1</span></span> * ridgenoise(<span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny); e1 = <span class="hljs-number"><span class="hljs-number">0.5</span></span> * ridgenoise(<span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny) * e0; e2 = <span class="hljs-number"><span class="hljs-number">0.25</span></span> * ridgenoise(<span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny) * (e0+e1); e = e0 + e1 + e2; elevation[y][x] = Math.<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(e, exponent);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/co/ku/kg/cokukg_3lgom28_bnm3cu4u-4dc.gif"></div><br>  Saya tidak punya banyak pengalaman dengan teknik ini, jadi saya perlu bereksperimen untuk belajar bagaimana menggunakannya dengan baik.  Mungkin juga menarik untuk mencampur kebisingan frekuensi rendah runcing dengan kebisingan frekuensi tinggi non-runcing. <br><br><h2>  Teras </h2><br>  Jika kita membulatkan ketinggian ke tingkat n berikutnya, kita mendapatkan teras: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zv/bo/5k/zvbo5k_de80zv8utx6fxorpxfha.png"></div><br>  Ini adalah hasil dari penerapan fungsi redistribusi tinggi dalam bentuk <code>e = f(e)</code> .  Di atas, kami menggunakan <code>e = Math.pow(e, exponent)</code> untuk mempertajam puncak gunung;  di sini kita menggunakan <code>e = Math.round(e * n) / n</code> untuk membuat teras.  Jika Anda menggunakan fungsi non-langkah, maka teras dapat dibulatkan atau terjadi hanya pada ketinggian tertentu. <br><br><h2>  Penempatan pohon </h2><br>  Biasanya kami menggunakan noise fraktal untuk ketinggian dan kelembaban, tetapi juga dapat digunakan untuk menempatkan objek yang berjarak tidak merata, seperti pohon dan batu.  Untuk ketinggian kami menggunakan amplitudo tinggi dengan frekuensi rendah ("red noise").  Untuk menempatkan objek Anda perlu menggunakan amplitudo tinggi dengan frekuensi tinggi ("noise biru").  Di sebelah kiri adalah pola noise biru;  di sebelah kanan adalah tempat-tempat di mana noise lebih besar dari nilai yang berdekatan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xo/u4/ze/xou4zen4vzp46h3l7ecmcmdqsda.png"></div><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> yc = <span class="hljs-number"><span class="hljs-number">0</span></span>; yc &lt; height; yc++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xc = <span class="hljs-number"><span class="hljs-number">0</span></span>; xc &lt; width; xc++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> max = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     for (int yn = yc - R; yn &lt;= yc + R; yn++) { for (int xn = xc - R; xn &lt;= xc + R; xn++) { double e = value[yn][xn]; if (e &gt; max) { max = e; } } } if (value[yc][xc] == max) { //    xc,yc } } }</span></span></code> </pre> <br>  Memilih R yang berbeda untuk setiap bioma, kita bisa mendapatkan kerapatan variabel pohon: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/764/e0e/32a/764e0e32ac9171654161a94a29f66118.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa1/940/61f/aa194061fd97796c08238123b57199c7.png"></div><br>  Sangat menyenangkan bahwa noise seperti itu dapat digunakan untuk menempatkan pohon, tetapi algoritma lain seringkali lebih efektif dan membuat distribusi yang lebih merata: Tempat Poisson, ubin Van atau dithering grafik. <br><br><h2>  Hingga tak terbatas dan seterusnya </h2><br>  Perhitungan bioma pada posisi (x, y) tidak tergantung pada perhitungan semua posisi lainnya.  <strong>Perhitungan lokal</strong> ini memiliki dua sifat yang mudah digunakan: ia dapat dihitung secara paralel, dan dapat digunakan untuk medan tanpa akhir.  <strong>Tempatkan kursor mouse di minimap</strong> (dalam artikel asli) di sebelah kiri untuk menghasilkan peta di sebelah kanan.  Anda dapat membuat bagian mana pun dari kartu tanpa menghasilkan (dan bahkan tanpa menyimpan) seluruh kartu. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/98b/932/152/98b932152f6c24f496034283fa904499.png"><img src="https://habrastorage.org/getpro/habr/post_images/6a5/811/c84/6a5811c84c56c1706aedbc505fc32aa9.png"><br><br><h2>  Implementasi </h2><br>  Menggunakan noise untuk menghasilkan medan adalah solusi yang populer, dan di Internet Anda dapat menemukan tutorial untuk berbagai bahasa dan platform.  Kode untuk menghasilkan kartu dalam berbagai bahasa kurang lebih sama.  Inilah loop paling sederhana dalam tiga bahasa berbeda: <br><br><ul><li>  <b>Javascript:</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gen = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimplexNoise(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">nx, ny</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Rescale from -1.0:+1.0 to 0.0:1.0 return gen.noise2D(nx, ny) / 2 + 0.5; } let value = []; for (let y = 0; y &lt; height; y++) { value[y] = []; for (let x = 0; x &lt; width; x++) { let nx = x/width - 0.5, ny = y/height - 0.5; value[y][x] = noise(nx, ny); } }</span></span></code> </pre> </li><li>  <b>C ++:</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::Perlin gen; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Rescale from -1.0:+1.0 to 0.0:1.0 return gen.GetValue(nx, ny, 0) / 2.0 + 0.5; } double value[height][width]; for (int y = 0; y &lt; height; y++) { for (int x = 0; x &lt; width; x++) { double nx = x/width - 0.5, ny = y/height - 0.5; value[y][x] = noise(nx, ny); } }</span></span></code> </pre> </li><li>  <b>Python:</b> <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> opensimplex <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> OpenSimplex gen = OpenSimplex() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Rescale from -1.0:+1.0 to 0.0:1.0 return gen.noise2d(nx, ny) / 2.0 + 0.5 value = [] for y in range(height): value.append([0] * width) for x in range(width): nx = x/width - 0.5 ny = y/height - 0.5 value[y][x] = noise(nx, ny)</span></span></code> </pre> </li></ul><br>  Semua perpustakaan noise hampir sama.  Coba <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">opensimplex untuk Python</a> , atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">libnoise untuk C ++</a> , atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">simplex-noise</a> untuk Javascript.  Untuk sebagian besar bahasa populer, ada banyak perpustakaan kebisingan.  Atau Anda dapat mempelajari cara kerja Perlin noise atau merealisasikannya sendiri.  <em>Saya tidak melakukannya.</em> <br><br>  Di pustaka suara yang berbeda untuk bahasa Anda, detail aplikasi mungkin sedikit berbeda (beberapa angka kembali dalam kisaran 0,0 hingga 1,0, yang lain dalam kisaran dari -1,0 hingga +1,0), tetapi gagasan dasarnya sama.  Untuk proyek nyata, Anda mungkin perlu membungkus fungsi <code>noise</code> dan objek <code>gen</code> dalam kelas, tetapi detail ini tidak relevan, jadi saya membuatnya global. <br><br>  Untuk proyek sederhana seperti itu, tidak masalah suara apa pun yang Anda gunakan: Perlin noise, noise simplex, noise OpenSimplex, nilai noise, offset titik tengah, algoritme berlian, atau transformasi Fourier terbalik.  Masing-masing dari mereka memiliki pro dan kontra, tetapi untuk generator kartu yang sama mereka semua membuat nilai output yang kurang lebih sama. <br><br>  <em>Render</em> peta tergantung pada platform dan gim, jadi saya tidak menerapkannya;  kode ini hanya diperlukan untuk menghasilkan ketinggian dan bioma, rendering yang tergantung pada gaya yang digunakan dalam permainan.  Anda dapat menyalin, port dan menggunakannya dalam proyek Anda. <br><br><h2>  Eksperimennya </h2><br>  Saya melihat pencampuran oktaf, menaikkan derajat ke kekuatan, dan menggabungkan ketinggian dengan kelembaban untuk membuat bioma.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sini</a> Anda dapat mempelajari grafik interaktif yang memungkinkan Anda untuk bereksperimen dengan semua parameter ini, yang menunjukkan kode terdiri dari: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lh/yq/xn/lhyqxnbeaj0friycenleop7mcdw.png"></div><br>  Berikut ini contoh kode: <br><br><pre> <code class="cpp hljs">var rng1 = PM_PRNG.create(seed1); var rng2 = PM_PRNG.create(seed2); var gen1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimplexNoise(rng1.nextDouble.bind(rng1)); var gen2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimplexNoise(rng2.nextDouble.bind(rng2)); <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gen1.noise2D(nx, ny)/<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gen2.noise2D(nx, ny)/<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; height; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; width; x++) { var nx = x/width - <span class="hljs-number"><span class="hljs-number">0.5</span></span>, ny = y/height - <span class="hljs-number"><span class="hljs-number">0.5</span></span>; var e = (<span class="hljs-number"><span class="hljs-number">1.00</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.50</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.25</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.13</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">8</span></span> * nx, <span class="hljs-number"><span class="hljs-number">8</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.06</span></span> * noise1(<span class="hljs-number"><span class="hljs-number">16</span></span> * nx, <span class="hljs-number"><span class="hljs-number">16</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.03</span></span> * noise1(<span class="hljs-number"><span class="hljs-number">32</span></span> * nx, <span class="hljs-number"><span class="hljs-number">32</span></span> * ny)); e /= (<span class="hljs-number"><span class="hljs-number">1.00</span></span>+<span class="hljs-number"><span class="hljs-number">0.50</span></span>+<span class="hljs-number"><span class="hljs-number">0.25</span></span>+<span class="hljs-number"><span class="hljs-number">0.13</span></span>+<span class="hljs-number"><span class="hljs-number">0.06</span></span>+<span class="hljs-number"><span class="hljs-number">0.03</span></span>); e = Math.<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(e, <span class="hljs-number"><span class="hljs-number">5.00</span></span>); var m = (<span class="hljs-number"><span class="hljs-number">1.00</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.75</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.33</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.33</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">8</span></span> * nx, <span class="hljs-number"><span class="hljs-number">8</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.33</span></span> * noise2(<span class="hljs-number"><span class="hljs-number">16</span></span> * nx, <span class="hljs-number"><span class="hljs-number">16</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.50</span></span> * noise2(<span class="hljs-number"><span class="hljs-number">32</span></span> * nx, <span class="hljs-number"><span class="hljs-number">32</span></span> * ny)); m /= (<span class="hljs-number"><span class="hljs-number">1.00</span></span>+<span class="hljs-number"><span class="hljs-number">0.75</span></span>+<span class="hljs-number"><span class="hljs-number">0.33</span></span>+<span class="hljs-number"><span class="hljs-number">0.33</span></span>+<span class="hljs-number"><span class="hljs-number">0.33</span></span>+<span class="hljs-number"><span class="hljs-number">0.50</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* draw biome(e, m) at x,y */</span></span> } }</code> </pre> <br>  Ada kesulitan: untuk kebisingan ketinggian dan kelembaban perlu menggunakan benih yang berbeda, jika tidak mereka akan berubah menjadi sama, dan kartu tidak akan terlihat begitu menarik.  Dalam Javascript, saya menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">png-parkmiller library</a> ;  di C ++, Anda dapat menggunakan dua <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">objek linear_congruential_engine yang</a> terpisah;  dengan Python, Anda bisa membuat dua instance terpisah dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kelas random.Random</a> . <br><br><h2>  Pikiran </h2><br>  Saya suka pendekatan ini untuk memetakan generasi karena <b>kesederhanaannya</b> .  Cepat dan hanya memerlukan sedikit kode untuk menghasilkan hasil yang layak. <br><br>  Saya tidak suka keterbatasannya dalam pendekatan ini.  Perhitungan lokal berarti bahwa setiap titik tidak tergantung pada yang lainnya.  Area peta yang berbeda <em>tidak saling terhubung</em> .  Setiap tempat di peta â€œsepertinyaâ€ sama.  Tidak ada batasan global, misalnya, â€œharus ada 3 hingga 5 danau di petaâ€ atau fitur global, seperti sungai yang mengalir dari puncak tertinggi ke lautan.  Juga, saya tidak suka fakta bahwa untuk mendapatkan gambar yang bagus Anda perlu mengkonfigurasi parameter untuk waktu yang lama. <br><br>  Mengapa saya merekomendasikannya?  Saya pikir ini adalah titik awal yang baik, terutama untuk game indie dan game jams.  Dua teman saya menulis versi awal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Realm of the Mad God</a> hanya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam</a> 30 hari untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kontes game</a> .  Mereka meminta saya untuk membantu membuat peta.  Saya menggunakan teknik ini (ditambah beberapa fitur yang ternyata tidak terlalu berguna) dan membuat peta untuk mereka.  Beberapa bulan kemudian, setelah menerima umpan balik dari para pemain dan dengan hati-hati mempelajari desain permainan, kami menciptakan generator peta yang lebih maju berdasarkan poligon Voronoi, yang dijelaskan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terjemahan</a> dalam HabrÃ©).  Generator kartu ini tidak menggunakan teknik yang dijelaskan dalam artikel ini.  Menggunakan noise untuk membuat peta dengan cara yang sama sekali berbeda. <br><br><h2>  Informasi tambahan </h2><br>  Ada <em>banyak</em> hal keren yang dapat Anda lakukan dengan fungsi noise.  Jika Anda mencari di Internet, Anda dapat menemukan opsi seperti turbulensi, ombak, multifractal bergerigi, redaman amplitudo, bertingkat, derau voronoi, turunan analitik, warping domain, dan lainnya.  Anda dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman ini</a> sebagai sumber inspirasi.  Saya tidak mempertimbangkannya di sini, artikel saya berfokus pada kesederhanaan. <br><br>  Proyek ini dipengaruhi oleh proyek pembuatan peta saya sebelumnya: <br><br><ul><li>  Saya menggunakan suara keseluruhan Perlin untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">generator kartu Realm of the Mad God pertama saya</a> .  Kami menggunakannya untuk enam bulan pertama pengujian alpha, dan kemudian menggantinya dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">generator peta pada poligon Voronoi</a> , khusus dibuat untuk persyaratan gameplay yang kami tentukan selama pengujian alpha.  Bioma dan warna mereka untuk artikel diambil dari proyek-proyek ini. </li><li>  Saat mempelajari pemrosesan sinyal audio, saya menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tutorial derau</a> yang menjelaskan konsep seperti frekuensi, amplitudo, oktaf, dan "warna" derau.  Konsep yang sama yang berfungsi untuk suara juga berlaku untuk pembuatan kartu berbasis kebisingan.  Pada saat itu, saya membuat beberapa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">generasi bantuan demo</a> mentah, tetapi saya tidak menyelesaikannya. </li><li>  Terkadang saya bereksperimen untuk menemukan batasan.  Saya ingin tahu berapa banyak kode yang minimal diperlukan untuk membuat peta yang meyakinkan.  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek mini ini,</a> saya mencapai <b>nol</b> baris kode - semuanya dilakukan dengan filter gambar (turbulensi, ambang batas, gradien warna).  Ini membuat saya bahagia dan sedih.  Sejauh mana pembuatan peta dapat dilakukan oleh filter gambar?  Cukup besar.  Segala sesuatu yang dijelaskan di atas tentang "skema gradien warna halus" diambil dari percobaan ini.  Lapisan noise adalah filter gambar turbulensi;  oktaf adalah gambar yang saling bertumpukan;  Alat derajat disebut "koreksi kurva" di Photoshop. </li></ul><br>  Yang sedikit mengganggu saya adalah bahwa sebagian besar kode yang ditulis pengembang game untuk generasi medan berbasis kebisingan (termasuk perpindahan titik tengah) ternyata sama dengan filter suara dan gambar.  Di sisi lain, itu menciptakan hasil yang cukup baik hanya dalam beberapa baris kode, itulah sebabnya saya menulis artikel ini.  Ini adalah <em>titik referensi yang cepat dan mudah</em> .  Biasanya saya tidak menggunakan kartu seperti itu untuk waktu yang lama, tetapi menggantinya dengan generator peta yang lebih kompleks segera setelah saya mengetahui jenis kartu apa yang lebih cocok untuk desain permainan.  Bagi saya, ini adalah pola standar: mulai dengan sesuatu yang sangat sederhana, dan kemudian menggantinya setelah saya lebih memahami sistem yang saya gunakan. <br><br>  Ada <em>banyak</em> hal yang dapat dilakukan dengan kebisingan, dalam artikel yang saya sebutkan hanya sedikit.  Coba <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Noise Studio</a> untuk menguji berbagai fitur secara interaktif. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430384/">https://habr.com/ru/post/id430384/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430374/index.html">Rekayasa Data dan lainnya: Memutar kaset video dan slide dari rapat</a></li>
<li><a href="../id430376/index.html">Panduan JavaScript Bagian 6: Pengecualian, Titik Koma, Literal Templat</a></li>
<li><a href="../id430378/index.html">J2CL - Better Late Than Never</a></li>
<li><a href="../id430380/index.html">Panduan JavaScript Bagian 5: Array dan Loop</a></li>
<li><a href="../id430382/index.html">Panduan JavaScript Bagian 4: Fitur</a></li>
<li><a href="../id430386/index.html">Pembangkit listrik penyimpanan solid state akan dibangun di India</a></li>
<li><a href="../id430388/index.html">Web Summit Unconference</a></li>
<li><a href="../id430392/index.html">Bagaimana saya mengembangkan dan menguji API dengan "sepeda" PieceofScript saya</a></li>
<li><a href="../id430394/index.html">Menerapkan pencarian instan di Android menggunakan RxJava</a></li>
<li><a href="../id430396/index.html">Replikasi berantai: membangun repositori KV yang efektif (bagian 1/2)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>