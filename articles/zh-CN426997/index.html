<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎱 👨🏾‍🤝‍👨🏽 👷🏼 如何使用MaterialShapeDrawable创建自定义形状 👷 👨🏿‍🍳 🌩️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Material Design 2.0引入了几个新概念。 其中之一是特别注意界面元素的几何形式。 并且有一种简单的方法可以制作漂亮的自定义形状。 它称为MaterialShapeDrawable。 让我们看看它的实用性和简便性。 


 有几种方法可以将图形元素添加到Android应用程序的屏幕。 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如何使用MaterialShapeDrawable创建自定义形状</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mobileup/blog/426997/"><img src="https://habrastorage.org/getpro/habr/post_images/585/f26/743/585f267433530ce6e9add3c7de072e35.jpg" alt="图片"><br><br><p>  Material Design 2.0引入了几个新概念。 其中之一是特别注意界面元素的几何形式。 并且有一种简单的方法可以制作漂亮的自定义形状。 它称为MaterialShapeDrawable。 让我们看看它的实用性和简便性。 </p><a name="habracut"></a><br><p> 有几种方法可以将图形元素添加到Android应用程序的屏幕。 最简单的方法是以webp或png格式导入位图。 另一个选择是使用VectorDrawable，它允许您将图像拉伸到所需的大小。 将图形添加到屏幕的另一种方法是使用ShapeDrawable。 后者是添加简单背景甚至创建图标的最简单方法。 使用ShapeDrawable创建的图像与屏幕上的像素密度无关。 它们可以在xml文件中描述，可以是另一个图形资源（例如StateListDrawable）的一部分，并且可以从API v.1开始存在于Android SDK中。 </p><br><p> 要更改图形的外观，我们可以更改几个ShapeDrawable属性：图形的名称，填充颜色（或渐变）和图形的边框颜色。 对于矩形，您还可以设置角的半径。 使用这些属性，您可以创建图形，这些图形将用作屏幕上的单个图像，分隔线，按钮背景或用于任何其他目的。 如果应用程序使用API​​ v.21 +和ShapeDrawable作为具有高程的元素的背景，则这些元素下的阴影也将具有正确的形状： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/456/6b3/fd7/4566b3fd778a1edfdcce710510d1a2c4.png" alt="图片"></p><br><p>  ShapeDrawable是一种方便的工具，几乎总是可以很好地完成其工作，但是随着Material Design 2.0的出现，开发人员需要更加灵活的工具。 新的设计系统鼓励使用不同的形式来强调其含义，条件和个人应用风格。 我在上面写道，有几种方法可以实现所需的目标，但是其中最简单的目标已不再适用。 这是否意味着我们需要开始使用矢量图形，从而失去为带有高程的界面元素“自由”创建阴影的能力？ 还是值得回退到使用光栅图像并为屏幕上的六个可能像素密度创建图形资源？ 幸运的是，随着Material Design 2.0的出现，一个全新的组件库已经出现。 </p><br><p>创建该库是为了统一Material Design UI组件在所有版本的Android和其他平台上的外观和行为（该库有iOS，Web和Flutter的版本）。 零部件库为新的材料设计实现了许多功能。 例如，它包括具有预期行为的BottomAppBar组件。 在其他组件和实用程序中，有MaterialShapeDrawable类。 我认为，这是解决新设计系统对开发人员提出的任务的必要工具。 </p><br><p> 尽管MaterialShapeDrawable在1.0.0库版本中仍被认为是实验性的，但可用于在应用程序中创建炫酷效果。 在MaterialShapeDrawable类中，您可以通过指定形状的侧面和每个角度来描述形状。 这些指定的属性可以由内插器控制，从而允许它们进行动画处理。 </p><br><p> 要创建自己的MaterialShapeDrawable，可以使用需要在参数中传递ShapePathModel类型的对象的构造函数。 它分别在EdgeTreatment和CornerTreatment类中存储有关图形的每个边和每个角的信息（总是正好有四个侧面和角度，但这几乎不影响借助它们描述任何图形）。 您可以亲自为每个边和角指定描述，或者通过调用一个方法一次为整个图形设置一次。 </p><br><p> 该库已经有关于边和角的处理的几个现成的描述，其中包括有关Material Design 2.0中引入的组件形状的大多数创新。 已经存在：RoundedCornerTreatment-用于圆角，CutCornerTreatment-用于切角，TriangleEdgeTreatment-在侧面切割或添加三角形。 为了演示他们的工作，有一个简单的示例： </p><br><pre><code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> shapePathModel = ShapePathModel().apply { setAllCorners(CutCornerTreatment(dip(<span class="hljs-number"><span class="hljs-number">5</span></span>).toFloat())) setAllEdges(TriangleEdgeTreatment(dip(<span class="hljs-number"><span class="hljs-number">5</span></span>).toFloat(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> backgroundDrawable = MaterialShapeDrawable(shapePathModel).apply { setTint(ContextCompat.getColor(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span><span class="hljs-symbol"><span class="hljs-symbol">@MainActivity</span></span>, R.color.colorPrimary)) paintStyle = Paint.Style.FILL } textView.background = backgroundDrawable</code> </pre> <br><p> 它看起来像这样： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/02b/b43/168/02bb431689af8046223fd77e58fd0f2a.png" alt="图片"></p><br><p> 当然，您可以简单地创建自己的面和角度描述。 始终为左上方的元素设置形状，而Drawable将执行旋转/反射操作以获得最终形状。 有一个小例子来说明这一点： </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CutoutCornersTreatment</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> size: <span class="hljs-built_in"><span class="hljs-built_in">Float</span></span>) : CornerTreatment() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCornerPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(angle: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-function"><span class="hljs-params">, interpolation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-function"><span class="hljs-params">, shapePath: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ShapePath</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { shapePath.reset(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, size * interpolation) shapePath.lineTo(size * interpolation, size * interpolation) shapePath.lineTo(size * interpolation, <span class="hljs-number"><span class="hljs-number">0f</span></span>) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CurvedEdgeTreatment</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> size: <span class="hljs-built_in"><span class="hljs-built_in">Float</span></span>) : EdgeTreatment() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getEdgePath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(length: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-function"><span class="hljs-params">, interpolation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-function"><span class="hljs-params">, shapePath: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ShapePath</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { shapePath.quadToPoint(length / <span class="hljs-number"><span class="hljs-number">2f</span></span>, size * interpolation, length, <span class="hljs-number"><span class="hljs-number">0f</span></span>) } }</code> </pre> <br><p> 如果将此MaterialShapeDrawable用作背景，则结果将如下所示： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/98a/5b5/671/98a5b56711a7a3cec44ed62c459deaf2.png" alt="图片"></p><br><p> 新材料组件库的bottomappbar程序包具有BottomAppBarTopEdgeTreatment。 它在BottomAppBar中描述了FloatingActionButton按钮的切口。 可以根据按钮的位置和大小为其上侧设置动画。 我建议您阅读这些类的代码，以便亲眼看到MaterialShapeDrawable的使用非常灵活，几乎所有事情都可以使用它完成。 </p><br><p> 如果我们谈论通常的ShapeDrawable，还有另一个值得一提的细节-投射与轮廓对应的形状阴影的能力。 由于您现在可以使用MaterialShapeDrawable创建非常不寻常的形状的轮廓，因此不要将阴影的形状带入图像的形状令人失望，尤其是当这些阴影在Matarial Design 2.0中随处可见时。  MaterialShapeDrawable也可以计算阴影的外观。 使用shadowEnabled属性，您可以启用阴影，该阴影将完全遵循图形本身的轮廓，还可以确定阴影的半径，高程和颜色。 听起来好得令人难以置信？ 不幸的是。 如果使用MaterialShapeDrawable的阴影，则会得到一个普通的阴影（由Paint类的setShadowLayer（）方法绘制，该方法是在文本上绘制阴影的），但会裁剪到显示结果的UI组件的边界： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5aa/e8b/134/5aae8b1341f9adabf86daaefeccb09fa.png" alt="图片"></p><br><p> 请记住，与它的API一样，MaterialShapeDrawable仍被视为实验性的，并且将来可能会更改。 还值得注意的是，新的Material Components库的代码是开放的，因此非常欢迎在Bug跟踪器中创建票证，甚至提出具有修复已知问题的请求。 实际上，当您阅读这些行时，该库的master分支中的API已经稍有不同（例如，将使用ShapeAppearanceModel代替ShapePathModel），这表明工作正在进行中。 下一个版本中有希望的功能之一可能是能够确定整个应用程序主题的默认边/角度。 您可以从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">官方文档</a>或库资源中了解更多信息。 </p><br><blockquote>  <em>来自翻译者：</em> <br>  <em>很酷，有些工具可以向通常的ShapeDrawable添加新功能，并且可以帮助创建最简单的图形。</em>  <em>这样一来，开发人员就不必为每件小事拉扯设计师，而是自己解决问题，并且所需时间大大减少。</em>  <em>我们正在等待材料组件库的下一个版本尝试实践解决现有问题的新方法。</em> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN426997/">https://habr.com/ru/post/zh-CN426997/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN426985/index.html">Kubernetes的kubebox和其他控制台外壳</a></li>
<li><a href="../zh-CN426987/index.html">学习OpenGL。 第6.3课-基于图像的照明。 漫射</a></li>
<li><a href="../zh-CN426991/index.html">创业文摘：莫斯科即将举行的10个IT事件</a></li>
<li><a href="../zh-CN426993/index.html">我需要学习C才能理解计算机的工作原理吗？</a></li>
<li><a href="../zh-CN426995/index.html">回收会危害产品和员工</a></li>
<li><a href="../zh-CN426999/index.html">顺应趋势，或转向RxJava和LiveData</a></li>
<li><a href="../zh-CN427003/index.html">Unity中的六边形地图：战争迷雾，地图研究，程序生成</a></li>
<li><a href="../zh-CN427005/index.html">AI开发人员-百万富翁的职业？</a></li>
<li><a href="../zh-CN427009/index.html">电子的“行走”：对不饱和键结构内部的电荷的操纵</a></li>
<li><a href="../zh-CN427011/index.html">我的“ Hello World！” 在FPGA或UART的下一版本上</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>