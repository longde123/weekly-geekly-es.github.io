<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍💼 😌 🛸 10,3 secondes par hachage: extraction sur l'ordinateur de contrôle embarqué du vaisseau spatial Apollo 👇 👳🏿 👩🏿‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous avons réussi à restaurer l'ordinateur de contrôle embarqué du vaisseau spatial Apollo. Et maintenant, quand nous avons entre nos mains la seule i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>10,3 secondes par hachage: extraction sur l'ordinateur de contrôle embarqué du vaisseau spatial Apollo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/466071/">  Nous avons réussi à restaurer l'ordinateur de contrôle embarqué du vaisseau spatial Apollo.  Et maintenant, quand nous avons entre nos mains la seule instance qui fonctionne au monde, j'ai pensé à écrire du code pour cela.  Bien que l'idée d'extraire des bitcoins à l'aide d'un ordinateur des années 60 éloignées semble insensée, cela valait la peine d'être essayé.  L'implémentation de l'algorithme de cryptage Bitcoin dans le code assembleur à l'aide d'un ordinateur 15 bits a été difficile, mais j'ai quand même réussi à le faire fonctionner.  Malheureusement, l'ordinateur s'est avéré si lent qu'il faudrait une éternité pour former un bloc de bitcoin. <br><br><img src="https://habrastorage.org/webt/xz/mf/yh/xzmfyhdoyptogtrwcjc_ydkwcei.jpeg"><br><br>  L'ordinateur de contrôle embarqué Apollo / Apollo (AGC) a été développé dans les années 1960. Il effectuait des calculs et contrôlait le mouvement, la navigation et les modules de commande et lunaire pendant les vols dans le cadre du programme Apollo.  À une époque où la taille des ordinateurs pouvait varier de la taille du réfrigérateur à la taille de la pièce, Apollo Guidance était suffisamment petite pour voler dans l'espace.  Cet ordinateur historique a été l'un des premiers à utiliser des circuits intégrés.  Une telle machine pesait près de 32 kg. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/uh/yn/sh/uhynsh4ge-n0cupepcpgexaja9u.jpeg"><br><br>  L'ordinateur de contrôle embarqué du vaisseau spatial Apollo a joué un rôle important dans le développement du développement logiciel, dirigé par Margaret Hamilton. <br><br><blockquote>  Margaret Hamilton dirigeait le département de développement logiciel du Massachusetts Institute of Technology (MIT).  Le département a développé un logiciel embarqué pour le programme spatial Apollo de la NASA. </blockquote>  Apollo (AGC) était équipé d'un système d'exploitation en temps réel avec multitâche coopératif, plusieurs tâches prioritaires pouvaient être effectuées simultanément, il y avait une fonction de dépannage.  La plupart des logiciels étaient en assembleur, un interpréteur a été développé pour AGC, qui permettait d'exécuter 5 à 7 machines virtuelles simultanément dans deux kilo-octets de mémoire. <br><br><h3>  Comment fonctionne Bitcoin Mining </h3><br>  Pas du tout d'actualité: en tant que principale monnaie numérique, le Bitcoin a été au premier plan de l'attention ces dernières années.  Le système Bitcoin peut être considéré comme un livre de comptes dans lequel est conservé à qui appartiennent les bitcoins, cela vous permet de les transférer d'un utilisateur à un autre.  La fonctionnalité révolutionnaire de Bitcoin est la décentralisation complète, il n'y a pas d'administrateur central ou d'analogue de celui-ci.  Au lieu de cela, les enregistrements sont distribués à des milliers de machines sur Internet et le système fonctionne sans assistance. <br><blockquote>  Il s'agit d'une sorte de journal dans lequel toutes les transactions sont enregistrées sans possibilité de modifier les données, mais uniquement leur ajout.  Une sorte de copie d'une telle revue se trouve sur les systèmes de tous les participants à ce réseau, et toutes les transactions et informations concernant la circulation et l'accumulation de fonds se trouvent également sur toutes ces revues. <br></blockquote>  Pour s'assurer que tout le monde est d'accord avec les transactions valides, Bitcoin utilise un processus appelé minage - environ toutes les 10 minutes, un bloc de transactions en attente est extrait, ce qui rend ce bloc «officiel».  Le système Bitcoin est conçu de telle manière que l'extraction de blocs nécessite une énorme quantité de puissance de calcul, ce qui élimine la «prise de pouvoir» par un mineur.  Les mineurs (mineurs de bitcoins) se font concurrence, générant des milliers de milliards de milliards de «hachages» aléatoires, jusqu'à ce que quelqu'un ait la chance d'en trouver un à partir de 18 zéros.  Ce hachage forme un bloc généré avec succès, après quoi tout le monde passe à l'extraction du bloc suivant.  Idée: obtenir accidentellement 18 zéros de suite est extrêmement improbable, il faut donc un grand nombre de tentatives avant que quelqu'un réussisse.  Eh bien, cela ressemble à une loterie, où les mineurs continuent d'essayer jusqu'à ce que quelqu'un «gagne», la recherche d'un code de hachage est comparable à la recherche d'un grain de sable particulier dans tout le sable de la Terre. <br><br>  Chaque fois, après avoir extrait le bloc, de nouveaux Bitcoins sont créés;  Actuellement, un mineur prospère peut recevoir 12,5 nouveaux Bitcoins (d'une valeur de 140 000 $), ainsi que des frais de transaction.  L'idée même de pouvoir obtenir 140 000 $ toutes les 10 minutes incite les mineurs à construire des centres de données remplis d'équipements spécialisés utilisant une énorme quantité d'électricité. <br><br><img src="https://habrastorage.org/webt/k5/ef/x9/k5efx9o3xk9sseqatzqz5m_j7rm.png"><br><br>  Le diagramme ci-dessus montre ce qui est réellement inclus dans le bloc extrait.  La partie jaune est l'en-tête du bloc (qui est hachée), suivie des transactions qui entrent dans le bloc.  Chaque bloc contient un hachage du bloc précédent, à la suite de quoi tous les blocs sont réunis, formant une chaîne de blocs.  A droite, le hachage est réussi, car il commence par un grand nombre de zéros. <br><br>  Pour résumer le processus d'exploration de données: vous collectez de nouvelles transactions bitcoin et créez un en-tête, comme indiqué dans le diagramme ci-dessus.  Vous générez un hachage de bloc cryptographique.  Si, pour une chance incroyable, le résultat commence avec 18 zéros, vous envoyez le bloc au réseau Bitcoin et «gagnez» 140 000 $ en bitcoins.  Sinon, vous modifiez légèrement le titre et réessayez.  Si quelqu'un d'autre parvient à obtenir un bloc, vous recommencez avec un nouveau bloc et de nouvelles transactions. <br><br><h3>  Algorithme de hachage Bitcoin SHA-256 </h3><br>  D'où viennent ces hachages?  Le processus d'exploration de Bitcoin est basé sur la cryptographie avec une «fonction de hachage», qui convertit le bloc de données en une valeur de hachage presque aléatoire.  L'algorithme de hachage est conçu pour être facilement implémenté, mais il est fiable sur le plan cryptographique: il n'y a aucun moyen connu de trouver rapidement un hachage réussi, sauf pour essayer des millions de hachages en utilisant la force brute.  En particulier, Bitcoin utilise une fonction de hachage cryptographique standard appelée SHA-256.  Cet algorithme est simple, mais il peut être utilisé pour crypter des données de manière totalement imprévisible. <br><blockquote>  SHA-256 est une fonction unidirectionnelle pour créer des empreintes digitales de longueur fixe (256 bits, 32 octets) à partir de données d'entrée jusqu'à 2,31 exaoctets (2 (bits)) et est un cas particulier d'un algorithme de la famille SHA-2 d'algorithmes cryptographiques </blockquote>  L'algorithme SHA-256 est décrit approximativement sur la page des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pseudo-codes</a> <br><br>  Les fonctions de hachage de la famille SHA-2 sont basées sur la structure Merkle - Damgard.  Après l'ajout, le message d'origine est divisé en blocs, chaque bloc en 16 mots.  L'algorithme passe chaque bloc de messages à travers une boucle avec 64 itérations.  À chaque itération, 2 mots sont transformés, les mots restants définissent la fonction de conversion.  Les résultats de traitement de chaque bloc sont ajoutés, la somme est la valeur de la fonction de hachage.  Étant donné que l'initialisation de l'état interne est effectuée en traitant le bloc précédent, il n'y a aucun moyen de traiter les blocs en parallèle. <br><br><img src="https://habrastorage.org/webt/iy/wv/zk/iywvzk_hsrwmodjeon1y-0d13ic.png"><br><br>  L'étape de codage des informations, également appelée «ronde», est répétée 64 fois.  Le diagramme ci-dessus montre un tour qui prend huit valeurs de hachage de 4 octets, de A à H, effectue plusieurs opérations et génère de nouvelles valeurs pour AH.  Comme vous pouvez le voir sur le diagramme, seuls A et E changent par tour, tandis que d'autres changent simplement.  Cependant, après 64 tours, les données d'entrée sont complètement brouillées, ce qui conduit à une sortie imprévisible du hachage. <br><br>  Les opérations dans SHA-256 sont de simples opérations au niveau du bit.  Les champs rouges ci-dessus indiquent une addition de 32 bits, générant de nouvelles valeurs pour A et E. Le bloc "sélectif" Ch sélectionne les bits de F ou G en fonction de la valeur de l'entrée E. Les blocs "totaux" Σ tournent et additionnent les bits.  Le bloc Ma "Most" évalue les bits à chaque position A, B et C et sélectionne quelle valeur sera en majorité.  Les valeurs Kt sont une constante.  L'entrée va à l'algorithme à travers la valeur de Wt.  Ces opérations peuvent être facilement implémentées sur un ordinateur à l'aide d'opérations arithmétiques et logiques simples. <br><br><h3>  Processeur informatique de contrôle de vaisseau spatial Apollo </h3><br>  Apollo (AGC) n'avait pas de microprocesseur, car il a été construit bien avant que les microprocesseurs ne soient développés en tant que tels.  Au lieu de cela, le processeur se composait d'environ 5600 portes NOR. <br>  Ces portes ont été interconnectées pour créer des circuits tels que des déclencheurs, des registres, des additionneurs binaires, une logique de commande, etc.  AGC est l'un des premiers ordinateurs à utiliser des circuits intégrés;  chaque circuit intégré contenait deux vannes NOR.  L'ordinateur avait 24 modules logiques similaires à celui ci-dessous.  Chaque module logique avait 120 circuits intégrés (240 vannes NOR).  Par exemple, les registres et les ALU ont été implémentés avec quatre modules, chacun implémentant 4 bits de processeur. <br><br><img src="https://habrastorage.org/webt/ob/7-/pc/ob7-pcpyyfuejmupu_ho6bkjgxo.jpeg"><br><br>  L'architecture informatique était inhabituelle par rapport aux normes modernes: elle utilisait un mot de 15 bits avec parité (à cette époque, les ordinateurs avaient souvent une taille de mot qui correspondait à l'application, et pas nécessairement 2).  AGC n'avait que 2K mots en RAM, 36K mots en ROM.  Le dispositif de stockage permanent (ROM) était une sélection linéaire de plusieurs noyaux cousus, une mémoire "tricotée".  L'ordinateur de contrôle Apollo était lent même par rapport aux normes des années 1960;  il pouvait effectuer environ 40 000 opérations par seconde.  Le principal avantage d'AGC était les E / S: il avait des centaines de connexions d'E / S et pouvait fournir un contrôle en temps réel des engins spatiaux. <br><br><h3>  Implémentation de SHA-256 sur l'ordinateur de navigation Apollo </h3><br>  Mon implémentation de l'algorithme de hachage SHA-256 suit de très près le pseudo-code.  Cependant, j'ai rencontré quelques difficultés car le jeu d'instructions AGC manque de nombreuses fonctionnalités des ordinateurs modernes.  Par exemple, AGC (comme de nombreux ordinateurs des années 1960) n'avait pas de pile, vous deviez donc suivre l'adresse de retour pour chaque appel au sous-programme. <br><br>  Une autre complication était que l'algorithme SHA-256 utilise des nombres non signés 32 bits, tandis que l'AGC utilisait des nombres signés 15 bits, de longues unités obsolètes, donc même l'opération d'addition nécessitait un code complexe.  Pour entrer un nombre de 32 bits dans l'AGC, j'ai divisé chaque mot en un fragment de 4 bits et deux fragments de 14 bits.  (J'ai utilisé des fragments de 14 bits, pas des fragments de 15 bits, car j'avais besoin d'utiliser une arithmétique non signée). <br><br>  Le problème suivant était la mémoire AGC, ou plutôt sa taille.  L'ordinateur de contrôle, comme la plupart des ordinateurs des années 1960, utilisait de la mémoire sur des noyaux magnétiques, chaque bit était stocké dans un minuscule anneau de ferrite magnétisé.  La mémoire du noyau étant plutôt encombrante, l'AGC disposait d'environ 4 Ko de RAM.  Le schéma d'adressage AGC a rendu la tâche encore plus compliquée, car seulement 256 mots étaient accessibles si le mécanisme de commutation de bloc de mémoire gênant n'était pas utilisé.  Le problème était que l'algorithme SHA-256 utilisait huit valeurs de hachage (32 bits), une table de confirmation de 64 mots et 8 mots de valeurs intermédiaires.  Seuls ces trois tableaux utilisaient 240 mots d'AGC, laissant environ 16 mots pour tout le reste (valeurs temporaires, adresse de retour du programme, nombre de cycles, pointeurs, etc.). J'ai réussi à tout réduire en un seul bloc de mémoire, en réutilisant ces 16 mots pour divers objectifs, mais j'ai passé beaucoup de temps à déboguer le problème pendant que la variable prenait de l'espace qui était encore en cours d'utilisation. <br><br><img src="https://habrastorage.org/webt/u5/vw/5j/u5vw5jmsgw5t5vfdewhkmcbr_i0.jpeg"><br><br>  La plupart des ordinateurs modernes ont des commandes de décalage / rotation spéciales pour fonctionner sur les mots, mais l'AGC a plutôt utilisé trois registres spéciaux. <br><br>  L'algorithme SHA-256 utilise de nombreux décalages et rotations 32 bits, que j'ai dû convertir en boucles à l'aide d'un registre cyclique 15 bits.  Bien que l'opération de décalage, telle que x &gt;&gt; 10, soit triviale, j'avais besoin de mettre en œuvre un sous-programme complet pour le lancer sur le vaisseau spatial Apollo. <br><br><img src="https://habrastorage.org/webt/4-/hr/k8/4-hrk8hithkhfgcruth2yfecvjs.jpeg"><br><br>  Pour préserver le jeu d'instructions et la petite taille du code, il y avait plusieurs instructions pour l'AGC avec des «effets secondaires» inattendus.  Par exemple, l'instruction TS (transfert vers un périphérique de stockage) a écrit une valeur en mémoire, ce qui à première vue était un processus simple.  Mais si l'addition précédente avait un débordement (c'est-à-dire un report), TS a sauté l'instruction suivante et a chargé le registre d'accumulation de +1 ou -1.  En d'autres termes, le simple fait d'écrire une valeur en mémoire peut entraîner un saut dans le flux de contrôle et un changement de casse.  Cela a permis de traiter les césures pour <a href="">les opérations arithmétiques avec une précision considérablement accrue</a> , la plupart des ordinateurs l'implémentant simplement à l'aide de l'instruction «Ajouter avec césure». <br><br><h3>  Lancement du programme </h3><br>  Dans la vidéo ci-dessous - mon programme bitcoin fonctionnant sur un véritable ordinateur de contrôle de vaisseau spatial Apollo, les résultats sont affichés sur notre DSKY (abréviation de Display / Keyboard - display / keyboard).  DSKY avait un simple pavé numérique avec des boutons suffisamment grands pour que les astronautes puissent appuyer tout en portant des gants.  L'ordinateur a affiché les résultats en chiffres;  les astronautes devraient savoir dans quelles unités la sortie est: en pieds, secondes, degrés, etc.  Nous avons utilisé une copie de DSKY créée par Karl, car personne ne nous laisserait travailler sur un vrai DSKY. <br><br>  L'ordinateur Apollo avait une interface utilisateur très simple.  L'astronaute a choisi l'action en appuyant sur la touche Verbe (Verbe), en entrant le numéro du verbe et en appuyant sur Entrée.  Il a ensuite sélectionné le point de consigne en entrant «Noun» (Noun).  (Les astronautes avaient une carte de référence avec une liste de tous les verbes et noms).  J'ai ajouté l'exploitation minière Bitcoin en tant que verbe 65 dans un programme appelé Borealis;  Vous pouvez voir comment Mike présente le verbe 65 au début de la vidéo. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/XiBuzzOt43g" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Apollo a pris 5,15 secondes pour créer un hachage SHA-256.  Étant donné que Bitcoin utilise un double hachage, le taux de hachage est de 10,3 secondes.  Actuellement, le réseau Bitcoin effectue environ 65 EH / s (65 quintillions de hachages par seconde).  L'ordinateur de contrôle embarqué prendra 4 × 10 ^ 23 secondes pour obtenir l'unité.  Et c'est un million de fois l'âge de l'univers (4,3 × 10 ^ 17). <br><br>  Étant donné la complexité astronomique du processus d'extraction, vous vous demandez peut-être comment j'ai réussi à exploiter le bloc.  C'est simple - pour cette démonstration, j'ai utilisé un bloc qui a été exploité avec succès dans le passé comme entrée, en particulier le bloc # 286819.  Ainsi, l'algorithme a fonctionné rapidement, mais comme c'était un vieux bloc, je n'y ai pas fait d'argent. <br><br>  Pour évaluer les performances de l'exploration informatique Apollo, comparez-les aux performances des mineurs USB compacts.  Un tel appareil exécute 130 milliards de hachages par seconde et son coût est inférieur à 70 $.  Ce n'est pas comparable à l'ordinateur de contrôle Apollo de 150 000 $.  À une époque, Apollo était un système extrêmement compact avec une faible consommation d'énergie, consommant 55 watts.  Le mineur USB, cependant, consomme 12 watts et tient facilement dans votre main.  Une énorme différence de performances est associée à une augmentation exponentielle de la vitesse de l'ordinateur décrite dans la loi de Moore, et en même temps à l'avantage de l'équipement utilisateur actuel pour l'extraction de bitcoins. <br><br><h3>  Programmation AGC - hier et aujourd'hui </h3><br>  Dans les années 60, le code de l'ordinateur de bord était écrit sur des cartes perforées et assemblé sur bande à l'aide d'un système logiciel appelé YUL.  Ce système était plus avancé que ce à quoi on aurait pu s'attendre dans les années 60, il comprenait un système de gestion du code source, suivait et incluait les changements.  Pour le vol, le logiciel a été installé sur une ROM avec une sélection linéaire de noyaux cousus à plusieurs reprises (dans la mémoire «tricotée»), et les fils ont physiquement passé autour des noyaux pour 0 ou à travers les noyaux pour 1. En d'autres termes, chacun de ces noyaux a été fabriqué sur commande et les données ont été stockées dans le modèle de fils de tissage.  Cela garantissait un stockage fiable de la ROM haute densité, mais nécessitait plusieurs semaines pour la fabrication. <br><br><img src="https://habrastorage.org/webt/1l/sz/c4/1lszc4y39b1t-3yl5juxkzkdrgs.jpeg"><br><br>  Comme il n'était pas pratique de produire un nouveau noyau de corde pour chaque changement, une approche différente a été utilisée pendant le développement.  Le simulateur de stockage à noyau magnétique a permis de charger le programme dans l'ordinateur de bord à partir d'un périphérique de stockage externe.  Ce simulateur fait partie d'un dispositif de contrôle de la taille d'un réfrigérateur (ci-dessous dans l'image) - l'interface de débogage vers l'AGC via le connecteur de diagnostic sur l'ordinateur de bord.  Le moniteur a permis aux programmeurs de définir des points d'arrêt, de vérifier les registres, etc., à l'aide d'indicateurs et de commutateurs. <br><br><img src="https://habrastorage.org/webt/bw/mr/ew/bwmrewxhr6dk9lnq7lagfwfoi0w.jpeg"><br><br>  Dans mon cas, j'ai écrit un logiciel sur mon ordinateur portable et l'ai compilé avec yaYUL, une version moderne de YUL écrite par l'équipe Virtual AGC.       AGC,  Code:: Blocks IDE,    ,    ,    1960- .      AGC,    .  ,         AGC,      AGC,     . <br><br><img src="https://habrastorage.org/webt/lh/0j/ke/lh0jkei6xvmmhuu6arb1zlugini.png"><br><br><h3>  Conclusion </h3><br>     SHA-256        Apollo,    ,    10,3   .         .          ;    0,67   .    IBM    1960-      80   .       Xerox Alto (  1973 ,  Macintosh),   1,5   .  ,   Apollo     IBM   ,   Alto. <br><br><img src="https://habrastorage.org/webt/gp/04/vb/gp04vb13m5c2orfi4xjuvskl5_i.jpeg"><br><br>   Apollo  1973   25,4  ,    150   .        200  , ,      ,        Apollo      .       —    Apollo,          . <br><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Github</a> ;     <a href="">BITCOIN.agc</a> . CuriousMarc  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  AGC</a> ,           . <br><br>  Merci de rester avec nous.  Aimez-vous nos articles?  Vous voulez voir des matériaux plus intéressants?  Soutenez-nous en passant une commande ou en le recommandant à vos amis, une <b>réduction de 30% pour les utilisateurs Habr sur un serveur d'entrée de gamme analogique unique que nous avons inventé pour vous:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Toute la vérité sur VPS (KVM) E5-2650 v4 (6 cœurs) 10 Go DDR4 240 Go SSD 1 Gbps à partir de 20 $ ou comment diviser le serveur?</a>  (les options sont disponibles avec RAID1 et RAID10, jusqu'à 24 cœurs et jusqu'à 40 Go de DDR4). <br><br>  <b>Dell R730xd 2 fois moins cher?</b>  Nous avons seulement <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2 x Intel TetraDeca-Core Xeon 2x E5-2697v3 2.6GHz 14C 64GB DDR4 4x960GB SSD 1Gbps 100 TV à partir de 199 $</a> aux Pays-Bas!</b>  <b><b>Dell R420 - 2x E5-2430 2.2Ghz 6C 128GB DDR3 2x960GB SSD 1Gbps 100TB - à partir de 99 $!</b></b>  Pour en savoir plus sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">création d'un bâtiment d'infrastructure.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">classe utilisant des serveurs Dell R730xd E5-2650 v4 coûtant 9 000 euros pour un sou?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr466071/">https://habr.com/ru/post/fr466071/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr466053/index.html">Représentation des sociétés informatiques russes à Singapour: pourquoi pas?</a></li>
<li><a href="../fr466059/index.html">Livre «Design Thinking. De la perspicacité aux nouveaux produits et marchés »</a></li>
<li><a href="../fr466065/index.html">Résumé des nouvelles de PostgreSQL. Numéro 17</a></li>
<li><a href="../fr466067/index.html">Économiseur d'écran enchanteur pour Kodi</a></li>
<li><a href="../fr466069/index.html">Comment amener l'équipe à rechercher des idées plus productives</a></li>
<li><a href="../fr466075/index.html">Comment j'ai quitté la science fondamentale dans une startup</a></li>
<li><a href="../fr466077/index.html">Journée Techdir de diffusion à Saint-Pétersbourg</a></li>
<li><a href="../fr466081/index.html">3 septembre</a></li>
<li><a href="../fr466089/index.html">Algorithme de pensée et de conscience, partie 2</a></li>
<li><a href="../fr466093/index.html">Comment fonctionne kubectl exec?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>