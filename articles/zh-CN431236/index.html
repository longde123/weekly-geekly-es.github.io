<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌙 ⛹🏻 📣 如何在2018年用Objective-C编写 第一部分 👨🏼‍🚒 ⛳️ 🏴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大多数iOS项目部分或全部切换到Swift。 Swift是一种很棒的语言，它伴随着iOS开发的未来。 但是语言与工具包有着千丝万缕的联系，Swift工具包也有缺点。 


 Swift编译器仍然存在导致其崩溃或生成错误代码的错误。 Swift没有稳定的ABI。 而且，非常重要的是，Swift项目已经...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如何在2018年用Objective-C编写 第一部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/joom/blog/431236/"><p> 大多数iOS项目部分或全部切换到Swift。  Swift是一种很棒的语言，它伴随着iOS开发的未来。 但是语言与工具包有着千丝万缕的联系，Swift工具包也有缺点。 </p><br><p>  Swift编译器仍然存在导致其崩溃或生成错误代码的错误。  Swift没有稳定的ABI。 而且，非常重要的是，Swift项目已经进行了太长时间。 </p><br><p> 在这方面，现有的项目可能会更有利可图，以继续在Objective-C上开发。 而且，Objective-C不再是以前的样子！ </p><br><p> 在本系列文章中，我们将向您展示Objective-C的有用功能和改进，这使编写代码更加轻松。 每个用Objective-C编写的人都会发现一些有趣的东西。 </p><br><p><img src="https://habrastorage.org/webt/40/ah/xl/40ahxlidhdgcqetc2vg-m2dz8ja.jpeg"></p><a name="habracut"></a><br>
<h2 id="let-i-var">  <code>let</code>和<code>var</code> </h2><br><p>  Objective-C不再需要显式指定变量类型：在Xcode 8中，出现了<code>__auto_type</code>语言扩展，并且在Objective-C ++中可以使用Xcode 8类型推断之前（在C ++ 0X出现时使用<code>auto</code>关键字）。 </p><br><p> 首先， <code>let</code>添加<code>let</code>和<code>var</code>宏： </p><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#define let __auto_type const #define var __auto_type</span></span></code> </pre> <br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//  NSArray&lt;NSString *&gt; *const items = [string componentsSeparatedByString:@","]; void(^const completion)(NSData * _Nullable, NSURLResponse * _Nullable, NSError * _Nullable) = ^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) { // ... }; //  let items = [string componentsSeparatedByString:@","]; let completion = ^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) { // ... };</span></span></code> </pre> <br><p> 如果您过去是在指向Objective-C类的指针之后编写<code>const</code> ，那么这是不可接受的，但是现在隐式指定<code>const</code> （通过<code>let</code> ）已被视为理所当然。 将块保存到变量时，这种差异特别明显。 </p><br><p> 对于我们自己，我们开发了一个规则，使用<code>let</code>和<code>var</code>声明所有变量。 即使将变量初始化为<code>nil</code> ： </p><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">nullable</span></span> JMSomeResult *)doSomething { var result = (JMSomeResult *)<span class="hljs-literal"><span class="hljs-literal">nil</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (...) { result = ...; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p> 唯一的例外是需要在每个代码分支中为变量分配值时： </p><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (...) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (...) { value = ...; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { value = ...; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { value = ...; }</code> </pre> <br><p> 只有这样，如果我们忘记为分支之一分配值，才会收到编译器警告。 </p><br><p> 最后：将<code>let</code>和<code>var</code>用于<code>id</code>类型的变量，您需要禁用<code>auto-var-id</code>警告（在项目设置的“ Other Warning Flags”中添加<code>-Wno-auto-var-id</code> ）。 </p><br><h2 id="avtovyvod-tipa-vozvraschaemogo-znacheniya-bloka"> 自动块类型返回值 </h2><br><p> 很少有人知道编译器可以推断块返回值的类型： </p><br><pre> <code class="objectivec hljs">let block = ^{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">@"abc"</span></span>; }; <span class="hljs-comment"><span class="hljs-comment">// `block`   `NSString *(^const)(void)`</span></span></code> </pre> <br><p> 非常方便。 特别是如果您使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ReactiveObjC</a>编写反应式代码。 但是，有许多限制必须明确指定返回值的类型。 </p><br><ol><li><p> 如果一个块中有多个<code>return</code> ，则返回不同类型的值。 </p><br><pre> <code class="objectivec hljs">let block1 = ^<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span> value){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// `NSNotFound`   `NSInteger` return NSNotFound; } }; let block2 = ^JMSomeBaseClass *(BOOL flag) { if (flag) { return [[JMSomeBaseClass alloc] init]; } else { // `JMSomeDerivedClass`   `JMSomeBaseClass` return [[JMSomeDerivedClass alloc] init]; } };</span></span></code> </pre> <br></li><li><p> 如果该块中有一个<code>return</code> ，则返回<code>nil</code> 。 </p><br><pre> <code class="objectivec hljs">let block1 = ^<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> * _Nullable(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>; }; let block2 = ^<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> * _Nullable(<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span> flag) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flag) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">@"abc"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>; } };</code> </pre> <br></li><li><p> 如果该块应返回<code>BOOL</code> 。 </p><br><pre> <code class="objectivec hljs">let predicate = ^<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span> lhs, <span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span> rhs){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs &gt; rhs; };</code> </pre> <br></li></ol><br><p> 在C中（因此在Objective-C中）具有比较运算符的表达式的类型为<code>int</code> 。 因此，最好总是始终明确指定返回类型<code>BOOL</code>为规则。 </p><br><h2 id="generics-i-forin"> 泛型和<code>for...in</code> </h2><br><p> 在Xcode 7中，泛型（或更确切地说是轻量级的泛型）出现在Objective-C中。 我们希望您已经使用它们。 但是，如果没有，您可以观看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WWDC会话</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>阅读。 </p><br><p> 对于我们自己，我们已经开发了一个规则，始终指定通用参数，即使它是<code>id</code> （ <code>NSArray&lt;id&gt; *</code> ）。 因此，很容易区分传统代码中尚未指定通用参数的代码。 </p><br><p> 借助<code>let</code>和<code>var</code>宏，我们希望可以在<code>for...in</code>循环中使用它们： </p><br><pre> <code class="objectivec hljs">let items = (<span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *&gt; *)@[<span class="hljs-string"><span class="hljs-string">@"a"</span></span>, <span class="hljs-string"><span class="hljs-string">@"b"</span></span>, <span class="hljs-string"><span class="hljs-string">@"c"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> items) { <span class="hljs-built_in"><span class="hljs-built_in">NSLog</span></span>(<span class="hljs-string"><span class="hljs-string">@"%@"</span></span>, item); }</code> </pre> <br><p> 但是此类代码无法编译。 极有可能在<code>for...in</code>不支持<code>__auto_type</code> ，因为<code>for...in</code>仅与实现<code>NSFastEnumeration</code>协议的集合<code>NSFastEnumeration</code>使用。 对于Objective-C中的协议，不支持泛型。 </p><br><p> 要解决此缺陷，请尝试使您的<code>foreach</code>宏。 首先想到的是：Foundation中的所有集合都具有<code>objectEnumerator</code>属性，并且该宏可能看起来像这样： </p><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#define foreach(object_, collection_) \ for (typeof([(collection_).objectEnumerator nextObject]) object_ in (collection_))</span></span></code> </pre> <br><p> 但是对于<code>NSDictionary</code>和<code>NSMapTable</code>协议方法将对键而不是值进行<code>NSFastEnumeration</code> （您需要使用<code>keyEnumerator</code> ，而不是<code>objectEnumerator</code> ）。 </p><br><p> 我们将需要声明一个新属性，该属性仅用于获取<code>typeof</code>表达式中的类型： </p><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSArray</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">__covariant</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectType</span></span></span><span class="hljs-class">&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ForeachSupport</span></span></span><span class="hljs-class">) @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">strong</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">readonly</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectType</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">jm_enumeratedType</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSDictionary</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">__covariant</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyType</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">__covariant</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectType</span></span></span><span class="hljs-class">&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ForeachSupport</span></span></span><span class="hljs-class">) @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">strong</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">readonly</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyType</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">jm_enumeratedType</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> #</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">define</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foreach</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object_</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">collection_</span></span></span><span class="hljs-class">) \ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">for</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeof</span></span></span><span class="hljs-class">((</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">collection_</span></span></span><span class="hljs-class">).</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">jm_enumeratedType</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object_</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">in</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">collection_</span></span></span><span class="hljs-class">))</span></span></code> </pre> <br><p> 现在我们的代码看起来好多了： </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//  for (MyItemClass *item in items) { NSLog(@"%@", item); } //  foreach (item, items) { NSLog(@"%@", item); }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Xcode片段</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">foreach (&lt;<span class="hljs-meta"><span class="hljs-meta">#object#&gt;, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#collection#&gt;</span></span></span><span class="hljs-meta">) { </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#statements#&gt;</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> </div></div><br><h2 id="generics-i-copymutablecopy"> 泛型和<code>copy</code> / <code>mutableCopy</code> <code>copy</code> </h2><br><p> 在Objective-C中无法键入的另一个地方是<code>-mutableCopy</code>和<code>-mutableCopy</code> （以及<code>-copyWithZone:</code>和<code>-mutableCopyWithZone:</code>方法，但我们不直接调用它们）。 </p><br><p> 为了避免显式强制转换，可以使用return类型重新声明方法。 例如，对于<code>NSArray</code>声明为： </p><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSArray</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">__covariant</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectType</span></span></span><span class="hljs-class">&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypedCopying</span></span></span><span class="hljs-class">) - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSArray</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectType</span></span></span><span class="hljs-class">&gt; *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">copy</span></span></span><span class="hljs-class">; - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSMutableArray</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectType</span></span></span><span class="hljs-class">&gt; *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mutableCopy</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre> <br><pre> <code class="objectivec hljs">let items = [<span class="hljs-built_in"><span class="hljs-built_in">NSMutableArray</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *&gt; array]; <span class="hljs-comment"><span class="hljs-comment">// ... //  let itemsCopy = (NSArray&lt;NSString *&gt; *)[items copy]; //  let itemsCopy = [items copy];</span></span></code> </pre> <br><h2 id="warn_unused_result"> <code>warn_unused_result</code> </h2> <br><p> 由于我们已经重新声明了-copy和<code>-mutableCopy</code> ，因此很高兴保证将使用调用这些方法的结果。 为此，Clang具有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>warn_unused_result</code></a>属性。 </p><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#define JM_WARN_UNUSED_RESULT __attribute__((warn_unused_result))</span></span></code> </pre> <br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSArray</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">__covariant</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectType</span></span></span><span class="hljs-class">&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypedCopying</span></span></span><span class="hljs-class">) - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSArray</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectType</span></span></span><span class="hljs-class">&gt; *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">copy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JM_WARN_UNUSED_RESULT</span></span></span><span class="hljs-class">; - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSMutableArray</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectType</span></span></span><span class="hljs-class">&gt; *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mutableCopy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JM_WARN_UNUSED_RESULT</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre> <br><p> 对于以下代码，编译器将生成警告： </p><br><pre> <code class="objectivec hljs">let items = @[<span class="hljs-string"><span class="hljs-string">@"a"</span></span>, <span class="hljs-string"><span class="hljs-string">@"b"</span></span>, <span class="hljs-string"><span class="hljs-string">@"c"</span></span>]; [items mutableCopy]; <span class="hljs-comment"><span class="hljs-comment">// Warning: Ignoring return value of function declared with 'warn_unused_result' attribute.</span></span></code> </pre> <br><h2 id="overloadable"> <code>overloadable</code> </h2> <br><p> 很少有人知道Clang允许您使用C语言（因此是Objective-C）重新定义函数。 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>overloadable</code></a>属性，可以创建具有相同名称但具有不同类型的参数或不同编号的函数。 </p><br><p>  <em>可覆盖的函数不能仅在返回值的类型上有所不同。</em> </p><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#define JM_OVERLOADABLE __attribute__((overloadable))</span></span></code> </pre> <br><pre> <code class="objectivec hljs">JM_OVERLOADABLE <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> JMCompare(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lhs, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rhs); JM_OVERLOADABLE <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> JMCompare(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lhs, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rhs, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> accuracy); JM_OVERLOADABLE <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> JMCompare(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> lhs, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> rhs); JM_OVERLOADABLE <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> JMCompare(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> lhs, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> rhs, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> accuracy);</code> </pre><br><h2 id="boxed-expressions"> 盒装表达式 </h2><br><p> 早在2012年，在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WWDC 413上，</a> Apple引入了<code>NSNumber</code> ， <code>NSArray</code>和<code>NSDictionary</code>文字以及框式表达式。 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Clang文档中</a>阅读有关文字和带框表达式的更多信息。 </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//  @YES // [NSNumber numberWithBool:YES] @NO // [NSNumber numberWithBool:NO] @123 // [NSNumber numberWithInt:123] @3.14 // [NSNumber numberWithDouble:3.14] @[obj1, obj2] // [NSArray arrayWithObjects:obj1, obj2, nil] @{key1: obj1, key2: obj2} // [NSDictionary dictionaryWithObjectsAndKeys:obj1, key1, obj2, key2, nil] // Boxed expressions @(boolVariable) // [NSNumber numberWithBool:boolVariable] @(intVariable) // [NSNumber numberWithInt:intVariable)]</span></span></code> </pre> <br><p> 使用文字和框式表达式，您可以轻松地获得一个代表数字或布尔值的对象。 但是要获得包装结构的对象，您需要编写一些代码： </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//  `NSDirectionalEdgeInsets`  `NSValue` let insets = (NSDirectionalEdgeInsets){ ... }; let value = [[NSValue alloc] initWithBytes:&amp;insets objCType:@encode(typeof(insets))]; // ... //  `NSDirectionalEdgeInsets`  `NSValue` var insets = (NSDirectionalEdgeInsets){}; [value getValue:&amp;insets];</span></span></code> </pre> <br><p> 为某些类定义了辅助方法和属性（例如<code>+[NSValue valueWithCGPoint:]</code>方法和<code>CGPointValue</code>属性），但这仍然不如盒装表达式方便！ </p><br><p> 在2015年， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Alex Denisov</a>为Clang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">制作了一个补丁</a> ，允许您使用盒装表达式将<code>NSValue</code>所有结构包装<code>NSValue</code> 。 </p><br><p> 为了使我们的结构支持盒装表达式，您只需为该结构添加<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>objc_boxable</code></a>属性。 </p><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#define JM_BOXABLE __attribute__((objc_boxable))</span></span></code> </pre> <br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> JM_BOXABLE JMDimension { JMDimensionUnit unit; <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span> value; } JMDimension;</code> </pre> <br><p> 我们可以在结构中使用<code>@(...)</code>语法： </p><br><pre> <code class="objectivec hljs">let dimension = (JMDimension){ ... }; let boxedValue = @(dimension); <span class="hljs-comment"><span class="hljs-comment">//   `NSValue *`</span></span></code> </pre> <br><p> 您仍然必须通过<code>-[NSValue getValue:]</code>方法或category方法来<code>-[NSValue getValue:]</code>结构。 </p><br><p>  CoreGraphics定义了自己的宏<code>CG_BOXABLE</code> ，并且<code>CGPoint</code> ， <code>CGSize</code> ， <code>CGVector</code>和<code>CGRect</code>已经支持盒装表达式。 </p><br><p> 对于其他常用结构，我们可以自己添加对框式表达式的支持： </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> JM_BOXABLE _NSRange <span class="hljs-built_in"><span class="hljs-built_in">NSRange</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> JM_BOXABLE <span class="hljs-built_in"><span class="hljs-built_in">CGAffineTransform</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CGAffineTransform</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> JM_BOXABLE <span class="hljs-built_in"><span class="hljs-built_in">UIEdgeInsets</span></span> <span class="hljs-built_in"><span class="hljs-built_in">UIEdgeInsets</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> JM_BOXABLE <span class="hljs-built_in"><span class="hljs-built_in">NSDirectionalEdgeInsets</span></span> <span class="hljs-built_in"><span class="hljs-built_in">NSDirectionalEdgeInsets</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> JM_BOXABLE <span class="hljs-built_in"><span class="hljs-built_in">UIOffset</span></span> <span class="hljs-built_in"><span class="hljs-built_in">UIOffset</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> JM_BOXABLE <span class="hljs-built_in"><span class="hljs-built_in">CATransform3D</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CATransform3D</span></span>;</code> </pre> <br><h2 id="compound-literals"> 复合文字 </h2><br><p> 另一个有用的语言构造是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">复合文字</a> 。 复合文字在GCC中作为语言扩展出现，后来被添加到C11标准中。 </p><br><p> 如果早些时候，遇到了对<code>UIEdgeInsetsMake</code>的调用，我们只能猜测会得到什么缩进（我们必须观察<code>UIEdgeInsetsMake</code>函数的声明），然后使用复合文字来<code>UIEdgeInsetsMake</code>代码本身： </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//  UIEdgeInsetsMake(1, 2, 3, 4) //  (UIEdgeInsets){ .top = 1, .left = 2, .bottom = 3, .right = 4 }</span></span></code> </pre> <br><p> 当某些字段为零时，使用这种构造更加方便： </p><br><pre> <code class="objectivec hljs">(<span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span>){ .y = <span class="hljs-number"><span class="hljs-number">10</span></span> } <span class="hljs-comment"><span class="hljs-comment">//  (CGPoint){ .x = 0, .y = 10 } (CGRect){ .size = { .width = 10, .height = 20 } } //  (CGRect){ .origin = { .x = 0, .y = 0 }, .size = { .width = 10, .height = 20 } } (UIEdgeInsets){ .top = 10, .bottom = 20 } //  (UIEdgeInsets){ .top = 20, .left = 0, .bottom = 10, .right = 0 }</span></span></code> </pre> <br><p> 当然，在复合文字中，您不仅可以使用常量，还可以使用任何表达式： </p><br><pre> <code class="objectivec hljs">textFrame = (<span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span>){ .origin = { .y = <span class="hljs-built_in"><span class="hljs-built_in">CGRectGetMaxY</span></span>(buttonFrame) + textMarginTop }, .size = textSize };</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Xcode片段</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">(<span class="hljs-built_in"><span class="hljs-built_in">NSRange</span></span>){ .location = &lt;<span class="hljs-meta"><span class="hljs-meta">#location#&gt;, .length = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#length#&gt;</span></span></span><span class="hljs-meta"> } (CGPoint){ .x = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#x#&gt;</span></span></span><span class="hljs-meta">, .y = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#y#&gt;</span></span></span><span class="hljs-meta"> } (CGSize){ .width = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#width#&gt;</span></span></span><span class="hljs-meta">, .height = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#height#&gt;</span></span></span><span class="hljs-meta"> } (CGRect){ .origin = { .x = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#x#&gt;</span></span></span><span class="hljs-meta">, .y = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#y#&gt;</span></span></span><span class="hljs-meta"> }, .size = { .width = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#width#&gt;</span></span></span><span class="hljs-meta">, .height = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#height#&gt;</span></span></span><span class="hljs-meta"> } } (UIEdgeInsets){ .top = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#top#&gt;</span></span></span><span class="hljs-meta">, .left = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#left#&gt;</span></span></span><span class="hljs-meta">, .bottom = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#bottom#&gt;</span></span></span><span class="hljs-meta">, .right = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#right#&gt;</span></span></span><span class="hljs-meta"> } (NSDirectionalEdgeInsets){ .top = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#top#&gt;</span></span></span><span class="hljs-meta">, .leading = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#leading#&gt;</span></span></span><span class="hljs-meta">, .bottom = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#bottom#&gt;</span></span></span><span class="hljs-meta">, .trailing = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#trailing#&gt;</span></span></span><span class="hljs-meta"> } (UIOffset){ .horizontal = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#horizontal#&gt;</span></span></span><span class="hljs-meta">, .vertical = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#vertical#&gt;</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> </div></div><br><h2 id="nullability"> 可空性 </h2><br><p> 在Xcode 6.3.2中，可<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">空性注释</a>出现在Objective-C中。 苹果开发人员添加了它们，以便将Objective-C API导入Swift。 但是，如果在语言中添加了一些内容，则应尝试将其放入服务中。 并且我们将说明我们如何在Objective-C项目中使用可空性以及存在哪些局限性。 </p><br><p>  <em>要刷新您的知识，您可以观看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WWDC会话</a> 。</em> </p><br><p> 我们要做的第一件事是开始在所有<code>.m</code>文件中编写<code>NS_ASSUME_NONNULL_BEGIN</code> / <code>NS_ASSUME_NONNULL_END</code> 。 为了不手动执行此操作，我们直接在Xcode中修补文件模板。 </p><br><p> 我们还开始为所有私有属性和方法正确设置可空性。 </p><br><p> 如果将宏<code>NS_ASSUME_NONNULL_BEGIN</code> / <code>NS_ASSUME_NONNULL_END</code>添加到现有的<code>.m</code>文件中， <code>null_resettable</code> <code>_Nullable</code>在整个文件中添加丢失的<code>nullable</code> ， <code>null_resettable</code>和<code>_Nullable</code> 。 </p><br><p> 默认情况下，所有有用的可空性编译器警告均处于启用状态。 但是，我想提出一个极端警告： <code>-Wnullable-to-nonnull-conversion</code> （在项目设置的“其他警告标志”中设置）。 当具有可为空类型的变量或表达式隐式转换为非空类型时，编译器会生成此警告。 </p><br><pre> <code class="objectivec hljs">+ (<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)foo:(<span class="hljs-keyword"><span class="hljs-keyword">nullable</span></span> <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)string { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> string; <span class="hljs-comment"><span class="hljs-comment">// Implicit conversion from nullable pointer 'NSString * _Nullable' to non-nullable pointer type 'NSString * _Nonnull' }</span></span></code> </pre> <br><p> 不幸的是，对于<code>__auto_type</code> （因此是<code>let</code>和<code>var</code> ），此警告不起作用。 通过<code>__auto_type</code>推导的类型将丢弃可空性注释。 而且，根据苹果开发人员在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">rdar中</a>的评论<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">：// 27062504</a> ，此行为不会改变。 实验上已经观察到，将<code>_Nullable</code>或<code>_Nonnull</code>添加到<code>__auto_type</code>不会产生任何影响。 </p><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)test:(<span class="hljs-keyword"><span class="hljs-keyword">nullable</span></span> <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)string { let tmp = string; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmp; <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre> <br><p> 为了抑制<code>nullable-to-nonnull-conversion</code>我们编写了一个“强制展开”的宏。 想法取自<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>RBBNotNil</code></a>宏。 但是由于<code>__auto_type</code>的行为<code>__auto_type</code>设法摆脱了辅助类。 </p><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#define JMNonnull(obj_) \ ({ \ NSCAssert(obj_, @</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Expected `%@` not to be nil."</span></span></span><span class="hljs-meta">, @#obj_); \ (typeof({ __auto_type result_ = (obj_); result_; }))(obj_); \ })</span></span></code> </pre> <br><p> 使用<code>JMNonnull</code>宏的示例： </p><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JMRobot</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">strong</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nullable</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JMLeg</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">leftLeg</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">strong</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nullable</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JMLeg</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rightLeg</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implementation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JMRobot</span></span></span><span class="hljs-class"> - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stepLeft</span></span></span><span class="hljs-class"> </span></span>{ [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> step:JMNonnull(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.leftLeg)] } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)stepRight { [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> step:JMNonnull(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.rightLeg)] } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)step:(JMLeg *)leg { <span class="hljs-comment"><span class="hljs-comment">// ... } @end</span></span></code> </pre> <br><p> 请注意，在撰写本文时， <code>nullable-to-nonnull-conversion</code>警告并不<code>nullable-to-nonnull-conversion</code> ：编译器尚未了解<code>nullable</code>变量，在检查了不等式之后， <code>nil</code>可以解释为<code>nonnull</code> 。 </p><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)foo:(<span class="hljs-keyword"><span class="hljs-keyword">nullable</span></span> <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)string { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (string != <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> string; <span class="hljs-comment"><span class="hljs-comment">// Implicit conversion from nullable pointer 'NSString * _Nullable' to non-nullable pointer type 'NSString * _Nonnull' } else { return @""; } }</span></span></code> </pre> <br><p> 在Objective-C ++代码中，您可以通过使用<code>if let</code>构造来解决此限制，因为Objective-C ++允许在<code>if</code>的表达式中声明变量。 </p><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)foo:(<span class="hljs-keyword"><span class="hljs-keyword">nullable</span></span> <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)stringOrNil { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (let string = stringOrNil) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> string; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">@""</span></span>; } }</code> </pre> <br><h2 id="poleznye-ssylki"> 有用的链接 </h2><br><p> 我想提及的还有许多其他知名的宏和关键字： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>@available</code></a>关键字， <code>NS_DESIGNATED_INITIALIZER</code> ， <code>NS_UNAVAILABLE</code> ， <code>NS_REQUIRES_SUPER</code> ， <code>NS_NOESCAPE</code> ， <code>NS_ENUM</code> ， <code>NS_OPTIONS</code> （或您具有相同属性的宏）宏和库@keypath宏。 我们还建议您查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">libextobjc</a>库的其余部分。 </p><br><div class="spoiler">  <b class="spoiler_title">还有什么要读</b> <div class="spoiler_text"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://pspdfkit.com/blog/2017/even-swiftier-objective-c/</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://medium.com/@maicki/type-in​​ference-with-auto-type-55a38ef56372</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://nshipster.com/__attribute__/</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://www.bignerdranch.com/blog/bools-sharp-corners/</a> </p></div></div><br><p>  →本文的代码发布在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">gist中</a> 。 </p><br><h2 id="zaklyuchenie"> 结论 </h2><br><p> 在本文的第一部分中，我们试图讨论主要功能和简单的语言改进，这极大地促进了Objective-C代码的编写和支持。 在下一部分中，我们将展示如何使用Swift中的枚举（它们也是案例类；它们也是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代数数据类型</a> ，ADT）进一步提高生产率，以及在协议级别实现方法的可能性。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN431236/">https://habr.com/ru/post/zh-CN431236/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN431226/index.html">FPGA Cyclone IV的Snake游戏（带有VGA和SPI游戏杆）</a></li>
<li><a href="../zh-CN431228/index.html">光的障碍物：液晶助您一臂之力</a></li>
<li><a href="../zh-CN431230/index.html">HPC基础架构的存储，或者我们如何在理研日本研究中心收集65 PB的存储</a></li>
<li><a href="../zh-CN431232/index.html">我们在Node.js上生成漂亮的SVG占位符</a></li>
<li><a href="../zh-CN431234/index.html">12月11日，莫斯科-Alfa JS MeetUp</a></li>
<li><a href="../zh-CN431238/index.html">2018年12月IT领域人力资源专业人员的事件摘要</a></li>
<li><a href="../zh-CN431242/index.html">TLS和Web证书</a></li>
<li><a href="../zh-CN431244/index.html">“两个未过滤的”或射击一条腿的简单方法</a></li>
<li><a href="../zh-CN431246/index.html">Mail.Ru组的@OpenStack Meetup：11月30日</a></li>
<li><a href="../zh-CN431248/index.html">谁将负责复杂项目的开发质量或质量门方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>