<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌪️ 🖱️ 👰🏿 Au moins une astuce Vim que vous ne connaissiez pas 🧔🏾 👌🏼 🧙🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je travaille chez Vim depuis huit ans et je découvre constamment quelque chose de nouveau. Il est considéré comme une vertu de Vim. Pour moi, c'est un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Au moins une astuce Vim que vous ne connaissiez pas</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454742/"> Je travaille chez Vim depuis huit ans et je découvre constamment quelque chose de nouveau.  Il est considéré comme une vertu de Vim.  Pour moi, c'est un manque d'ouverture: un tas de fonctions cachées sont cachées trop profondément. <br><br>  Ils parlent de la beauté de l'édition modale et des objets texte, mais il me semble que l'essence de Vim n'est pas cela.  Vim est un patchwork de sous-systèmes obstrués par des outils supplémentaires.  Seulement en mode d'édition normal plus d'une centaine de raccourcis clavier!  Cette densité de boîtes à outils explique en grande partie pourquoi Vim est si utile.  Si «afficher toutes les balises d'un mot clé» est juste <code>g]</code> , cette commande sera utilisée beaucoup plus souvent. <br><br>  Dans les systèmes avec un manque d'ouverture, il faut compter sur le leadership.  Mais pour Vim, il n'y en a pas tellement.  Il existe des articles pour les débutants, tels que <code>ciw</code> (à ne pas confondre avec la CIA, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le manuel de la CIA pour Vim</a> ) et similaires.  Et il y a des articles d'experts qui sont plongés dans des sous-systèmes.  Mais personne ne parle vraiment de ces trucs spéciaux qui vous font vous exclamer: bon sang, comme j'en avais besoin depuis six ans! <br><a name="habracut"></a><br>  Cet article concerne certaines des petites astuces que j'utilise dans Vim.  Aucun d'entre eux n'est démonté dans tous les détails, donc si quelque chose vous intéresse, je vous recommande de creuser des informations supplémentaires.  Ils ne sont pas non plus liés les uns aux autres.  Mais c'est normal.  En général, il y en a plus qu'assez pour vraiment aider presque tout le monde. <br><br><h1>  Structure de l'article </h1><br>  Très grossier, les utilisateurs de Vim se répartissent en deux catégories.  <b>Les puristes</b> apprécient la petite taille et l'omniprésence.  En règle générale, ils minimisent la configuration au cas où vous devriez travailler sur un ordinateur inconnu (par exemple, via ssh).  Les extenseurs, d'autre part, remplissent Vim de plugins, de fonctions et de mappages locaux dans une tentative futile de prétendre utiliser Emacs.  Si vous leur prenez du vimrc, les gars resteront complètement impuissants. <br><br>  Comme vous le devinez probablement, je suis beaucoup plus proche des expanseurs que des puristes.  J'ai divisé les astuces en deux sections selon que des modifications sont nécessaires dans le Vim de base. <br><br><h1>  Puristes </h1><br>  Pour les commandes modales, des vues d'aide standard sont utilisées, c'est-à-dire que <code>&lt;cr&gt;</code> signifie que vous appuyez sur la touche Entrée.  Lorsque vous avez besoin d'aide <code>:h</code> pour une ligne spécifique, par exemple <code>:h E676</code> , la ligne sera entre parenthèses. <br><br><h2>  Diverses commandes en mode normal </h2><br><h4>  ": et @: </h4><br>  <code>":</code> est un registre contenant la dernière commande exécutée. Vous pouvez taper <code>":p</code> pour l'imprimer dans le tampon.  <code>@:</code> répète la dernière commande. <br><br><h4>  "= </h4><br>  Inscrivez-vous aux «expressions».  Ici, vous pouvez entrer n'importe quelle expression vimL et l'insérer, l'utiliser avec ctrl-R, etc. Ainsi, par exemple, l'horodatage local est inséré en tapant <code>"=strftime("%c")&lt;cr&gt;p</code> . <br><br><h4>  mA, 'A </h4><br>  <code>m{letter}</code> place la marque à la position du curseur.  Ensuite, <code>'{letter}</code> ira à cette ligne.  Pour les lettres minuscules, il agit sur le tampon, il convient donc à la navigation.  Cela fonctionne globalement pour les lettres majuscules: même si vous êtes dans un autre fichier, <code>'A</code> ira dans le fichier étiqueté <code></code>  Vous pouvez voir toutes vos balises avec la commande <code>:marks:</code> <br><br><h4>  ctrl-A et ctrl-X </h4><br>  Augmente et diminue le nombre suivant de la ligne à l'emplacement du curseur ou à sa droite.  Puisqu'il va immédiatement au nombre, la combinaison peut être utilisée de n'importe où.  <code>10c-A</code> beaucoup plus simple que <code>wwwwwciw20</code> . <br><br><h4>  q: </h4><br>  Ouvre l'historique des équipes précédentes.  Vous pouvez l'utiliser avec n'importe quel texte Vim, mais les modifications ne sont pas enregistrées.  Cependant, vous pouvez exécuter la commande modifiée à l'aide de <code>&lt;CR&gt;</code> .  Cela vous permet de modifier et de redémarrer très rapidement les commandes ou de rechercher les anciennes pour les réutiliser. <br><br><h4>  q /, q? </h4><br>  Identique à <code>q:</code> sauf recherche. <br><br><h4>  ctrl-I, ctrl-O </h4><br>  Passe à l'emplacement suivant ou précédent dans la liste des sauts.  Utile pour une vérification rapide puis un retour en arrière.  C'est très agréable de lire les fichiers d'aide. <br><br><h2>  Macros </h2><br>  Consultez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet article</a> pour un aperçu plus approfondi de l'utilisation des macros. <br><br><h2>  Mode visuel </h2><br><h4>  gv </h4><br>  Sélectionne l'élément visuel précédent. <br><br><h4>  v_o </h4><br>  Va de l'autre côté du bloc visuel.  Utile si vous avez commencé une ligne trop bas ou quelque chose comme ça.  En mode bloc, il passe à l'angle diagonal opposé et utilise <code>v_O</code> pour passer à l' <code>v_O</code> horizontal opposé. <br><br><h4>  g ctrl-A / ctrl-X </h4><br>  En mode visuel, ctrl-A incrémente simplement le premier nombre de chaque ligne.  D'un autre côté, <code>g ctrl-A</code> incrémentera d'une ligne à chaque ligne.  Ceci est beaucoup plus facile à expliquer dans le tableau: <br><br><div class="scrollable-table"><table><thead><tr><th>  <strong>sélectionné</strong> </th><th> <code>ctrl-A</code> </th> <th> <code>g ctrl-A</code> </th> <th> <code>2 g ctrl-A</code> </th> </tr></thead><tbody><tr><td><pre>  un 0
 b 0
 c
 d 0 </pre></td><td><pre>  un 1
 b 1
 c
 d 1 </pre></td><td><pre>  un 1
 b 2
 c
 d 3 </pre></td><td><pre>  un 2
 b 4
 c
 d 6 </pre></td></tr></tbody></table></div><br><h4>  Opérateurs: v, V, cv (: h o_v) </h4><br>  Vous savez probablement qu'en mode visuel, vous pouvez sélectionner des caractères (v), des lignes (V) et des blocs (ctrl-V).  Mais ces trois combinaisons peuvent être utilisées comme opérateurs de mouvement pour le fragment correspondant.  Par exemple, vous avez le texte suivant: <br><br> <code>abc <br> abc <br> abc</code> <br> <br>  Si vous placez le curseur sur le haut <code>b</code> et appuyez sur <code>d2j</code> , il supprimera les trois lignes, car <code>j</code> déplace ligne par ligne.  Si <code>d&lt;cV&gt;2j</code> enfoncé à la place, le mouvement devient bloc par bloc et seule la colonne du milieu avec trois lettres <code>b</code> est supprimée. <br><br>  Un cas d'utilisation est la suppression dans la recherche.  Normal <code>d/</code> déplace caractère par caractère.  Par conséquent, j'utilise <code>dV/</code> pour le mouvement ligne par ligne avec suppression.  Il existe une autre façon de procéder: <br><br><h4>  / regex / {n} </h4><br>  Déplacer n lignes en dessous de la correspondance, ou autant de lignes vers le haut si la valeur est négative.  Comme effet secondaire, le mouvement se produit ligne par ligne.  Ainsi, si vous souhaitez supprimer la première ligne correspondant à <code>regex</code> , vous pouvez saisir <code>d/regex//0</code> . <br><br><h2>  Ex-équipes </h2><br>  Vous entrez des ex-commandes en mode commande, par exemple, la commande <code>:s</code> .  En plus du remplacement, il existe de nombreuses autres commandes utiles.  Tous ces exemples nécessitent une plage, telle que <code>%</code> . <br><br><h4>  : g / regex / ex </h4><br>  Exécute la commande uniquement sur les lignes correspondant à l'expression régulière.  Par exemple, vous pouvez saisir <code>g/regex/d</code> pour supprimer toutes les lignes correspondant à regex.  La commande <code>v</code> est similaire à <code>g</code> , mais fonctionne sur toutes les lignes qui <i>ne</i> correspondent <i>pas</i> à l'expression régulière. <br><br>  Les astuces deviennent plus puissantes avec la norme et quelques autres. <br><br><h4>  : norme {Vim} </h4><br>  Agit comme si vous exécutiez {Vim} sur chaque ligne de la plage.  Par exemple, <code>g/regex/norm f dw</code> supprimera le premier mot après le premier espace de chaque ligne correspondant à l'expression régulière regex.  C'est souvent beaucoup plus simple qu'une macro. <br><br>  <code>norm</code> obéit à toutes vos comparaisons.  Par exemple, si vous avez attribué <code>jk</code> à <code>&lt;esc&gt;</code> en mode insertion, la <code>norm I jk$diw</code> ajoutera un espace au début de la ligne, <i>quittera le mode insertion</i> , puis supprimera le dernier mot de la ligne.  J'aime vraiment cette fonctionnalité, mais si vous préférez ne pas utiliser vos mappages, vous pouvez appliquer la <code>norm!</code>  . <br><br><h4>  : co. </h4><br>  Copie une plage dans la ligne actuelle.  Vous pouvez également spécifier des valeurs arbitraires au lieu d'un point, par exemple, <code>+3</code> ou <code>'a. mv</code>  <code>'a. mv</code> pour se déplacer. <br><br><h4>  : y {reg} </h4><br>  Copie la plage dans le registre <code>{reg}</code> .  Si <code>{reg}</code> majuscule, il est ajouté au cas existant.  c'est à dire une telle équipe <br><br> <code>let @a = '' | %g/regex/y A</code> <br> <br>  copiera toutes les lignes correspondant à l' <code>regex</code> dans tout le fichier.  Cela permet d'extraire le texte cassé du fichier et de le copier dans le presse-papiers du système (en utilisant <code>let @+ = @a</code> ). <br><br><h4>  : windo {ex} </h4><br>  Exécute une commande dans toutes les fenêtres.  Par exemple <code>:windo $</code> toutes les fenêtres vers le bas.  Il y a <code>bufdo</code> , <code>cdo</code> , <code>tabdo</code> et autres. <br><br>  Fonctionne très bien avec <code>g</code> et <code>s</code> .  Pour remplacer toutes les combinaisons <code>AA</code> par <code>BB</code> avec un aperçu des remplacements, vous pouvez entrer <code>vimgrep AA</code> en chargeant toutes les correspondances dans quickfix puis <code>cdo s/AA/BB/cge</code> pour rechercher / remplacer toutes les correspondances. <br><br><h2>  Vim for Extender </h2><br>  Voici des astuces qui nécessitent d'enregistrer les paramètres ou de modifier une session Vim.  Hypothétiquement, ils peuvent être utilisés dans le mode "puritain", simplement en entrant des commandes, mais certains impliquent des changements assez sérieux qui contredisent l'esprit du purisme. <br><br>  Voici seulement le plus insolite.  Beaucoup de gens attribuent <code>H</code> à la casquette <code>^</code> , donc ces choses ne valent pas la peine d'être mentionnées.  En outre, cela n'a aucun sens de parler de <code>vim-sensible</code> ou de <code>vim-surround</code> , mais uniquement de plugins plus exotiques. <br><br>  Si vous configurez constamment votre vimrc, faites-vous plaisir et ajoutez une commande distincte pour cela: <br><br> <code>command! Vimrc :vs $MYVIMRC</code> <br> <br><h2>  Paramètres </h2><br>  J'ai tous les paramètres, les raccourcis clavier et les fonctions stockés dans un seul fichier vimrc.  La division en plusieurs fichiers rend la recherche difficile. <br><br>  La plupart des paramètres ne sont pas vraiment des «trucs».  Il vaut mieux regarder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vim-sensible</a> : presque tous les paramètres à partir de là conviendront à votre vimrc. <br><br><h4>  définir lazyredraw </h4><br>  Ne redessinez pas l'écran au milieu d'une macro (pour améliorer les performances). <br><br><h4>  définir smartcase / ignorecase </h4><br>  Avec ces deux paramètres, une recherche sans majuscules ne respecte pas la casse et une recherche avec des majuscules est sensible à la casse. <br><br><h4>  définir un fichier </h4><br>  Sauvegarde des actions, même si vous fermez et ouvrez Vim, afin que les actions d'annulation soient toujours disponibles.  Très pratique en combinaison avec le plugin undotree. <br><br><h4>  set foldcolumn = {n} </h4><br>  Colonne latérale avec blocs effondrés.  Plus <code>n</code> grand, plus les blocs sont réduits dans la colonne et pour le reste, le nombre est indiqué. <br><br><h4>  set suffixesadd = {str} </h4><br>  <code>gf</code> signifie généralement "aller au fichier sous le curseur", mais nécessite une extension de fichier dans la ligne.  <code>suffixesadd</code> ajoute l'extension spécifiée.  Si <code>suffixesadd=.md</code> , la commande <code>gf</code> sur la ligne 'foo' recherchera les fichiers <code>foo</code> et <code>foo.md</code> <br><br><h4>  set inccommand = nosplit </h4><br>  Uniquement pour Neovim.  La <code>incommand</code> montre en temps réel les changements que l'équipe apportera.  Seul <code>s</code> est actuellement pris en charge, mais même cela est incroyablement utile.  Si vous entrez <code>:s/regex</code> , toutes les correspondances sont mises en surbrillance.  Si vous ajoutez <code>/change</code> , il affichera tous les remplacements.  Fonctionne avec toutes les propriétés d'expression régulière, y compris les backlinks et les groupes. <br><br><h3>  définir la ligne d'état (: h état ligne) </h3><br>  Détermine les éléments à afficher dans le panneau en bas de chaque fenêtre.  Ici, le formatage est beaucoup plus compliqué et capricieux que dans d'autres paramètres, vous devez donc passer du temps à l'expliquer.  Il existe quelques astuces simples.  Tout d'abord, regardez la barre d'état Vim par défaut: <br><br> <code>:set statusline=%&lt;%f\ %h%m%r%=%-14.(%l,%c%V%)\ %P</code> <br> <br>  Ici, il est plus facile de remplacer <code>%P</code> (pourcentage du fichier sur le curseur).  Le format de la barre d'état est la valeur après le signe de pourcentage entre accolades.  Par conséquent, pour les fichiers Markdown, vous pouvez écrire ceci: <br><br> <code>:set statusline=%&lt;%f\ %h%m%r%=%-14.(%l,%c%V%)\ %{wordcount()[\"words\"]}</code> <br> <br>  Et remplacez le pourcentage du fichier par le nombre de mots dans le document. <br><br>  Ou installez une <code>tabline</code> .  Si vous n'utilisez pas d'onglets, cette ligne peut devenir une «ligne d'état globale».  Par exemple <br><br> <code>set tabline=%{strftime('%c')}</code> <br> <br>  affichera toujours la date en haut. <br><br><h2>  Liaisons de touches </h2><br>  J'ai <i>beaucoup de</i> fixations. <br><br>  De nombreuses touches pratiques dans Vim sont stupidement attribuées par défaut.  Par exemple, enregistrer la séquence de touches <code>s</code> est synonyme de <code>cl</code> (enregistrer une séquence de touches), et <code>U</code> est identique à <code>u</code> , sauf pour écrire annuler comme une nouvelle modification, qui est fonctionnellement inutile.  <code>Q</code> identique à <code>gQ</code> et est en tout cas un formidable piège.  <code>Z</code> utilisé uniquement pour <code>ZZ</code> et <code>ZQ</code> .  Mon Dieu, même le manuel de Vim recommande de réaffecter les touches <code>_</code> et à certaines fonctions, car "vous ne les utiliserez probablement jamais".  Je préférerais ne pas enregistrer un clic, mais ajouter des fonctions complètement nouvelles au clavier.  Voici quelques unes de mes fixations: <br><br><h4>  nnoremap Q @@ </h4><br>  Sans ralentir le passage en ex-mode, répète la dernière macro. <br><br><h4>  nnoremap s "_d </h4><br>  Il fait fonctionner la clé <code>s</code> (avec les paramètres appropriés pour <code>ss</code> et <code>S</code> ) comme d, uniquement sans enregistrer le texte supprimé dans le registre.  Utile pour ne pas obstruer le registre. <br><br><h4>  nnoremap &lt;cj&gt; &lt;cw&gt; j </h4><br>  Accédez à la fenêtre ci-dessous.  Affectations appropriées pour <code>h</code> , <code>k</code> , <code>l</code> .  Travailler avec des fenêtres est beaucoup plus facile. <br><br><h4>  nnoremap &lt;leader&gt; e: exe getline (ligne ('.')) &lt;cr&gt; </h4><br>  Exécutez la ligne actuelle comme s'il s'agissait d'une commande.  Dans les expériences, c'est souvent plus pratique que <code>q:</code> <br><br><h2>  Arguments spéciaux (: h map-arguments) </h2><br>  La commande <code>map &lt;buffer&gt; lhs rhs</code> active le mappage de clé pour ce tampon uniquement.  Il fonctionne vraiment de manière pratique avec les commandes automatiques comme combinaison de touches temporaire ou lors de la définition d'affectations via une fonction.  Les affectations de tampons ont priorité sur les affectations globales, c'est-à-dire que vous pouvez remplacer la commande générale plus utile dans une situation spécifique. <br><br>  La commande <code>map &lt;expr&gt; {lhs} {expr}</code> vérifie <code>{expr}</code> et utilise la valeur de retour comme remappage final des clés.  Un cas d'utilisation simple est contraignant en fonction des conditions.  Je les ai: <br><br> <code>nnoremap &lt;expr&gt; k (v:count == 0 ? 'gk' : 'k') <br> nnoremap &lt;expr&gt; j (v:count == 0 ? 'gj' : 'j')</code> <br> <br>  Ce qui fait que <code>j</code> et <code>k</code> déplacent le long de la ligne <i>jusqu'à ce qu'un</i> nombre soit trouvé, et ensuite la clé est annulée.  Par conséquent, je peux parcourir de longs paragraphes de prose sans casser des combinaisons telles que <code>10j</code> . <br><br>  L'argument <code>&lt;silent&gt;</code> utile si des liaisons exécutent des commandes ex. <br><br><h2>  inoremaps </h2><br>  Grâce à <code>inoremap</code> liaisons fonctionnent en mode insertion.  Là, ils commencent à travailler, donc <code>inoremap ;a aaaa</code> introduira «aaaa» au lieu de «; a».  Si vous voulez faire quelque chose en mode normal, utilisez <code>&lt;cO&gt;</code> .  Par exemple, si nous avons <br><br> <code>inoremap ;1 &lt;co&gt;ma</code> <br> <br>  puis <code>;1</code> définira <code>'a</code> . <br><br>  J'aime spécifier d'utiliser des points-virgules comme clé pour les réaffectations, car dans les textes normaux, il y a presque toujours un espace ou une nouvelle ligne après le point-virgule. <br><br><h2>  autocmd </h2><br>  Les commandes automatiques sont idéales pour la configuration.  Habituellement, vous les configurez comme ceci: <br><br><pre> <code class="plaintext hljs">augroup {name} autocmd! " Prevents duplicate autocommands au {events} {file regex} {command} augroup END</code> </pre> <br>  Ensuite, si l'un des événements {events} se produit dans le fichier {file regex}, la commande {command} se déclenchera.  Les événements sont répertoriés <code>:h event</code> .  Par exemple, si vous écrivez <br><br><pre> <code class="plaintext hljs">augroup every autocmd! au InsertEnter * set norelativenumber au InsertLeave * set relativenumber augroup END</code> </pre> <br>  alors vim désactivera le numéro relatif pour le mode d'insertion uniquement. <br><br>  La commande <code>au {event} &lt;buffer&gt; {ex}</code> applique la commande auto uniquement au tampon actuel.  Parfois, j'utilise ceci pour ajouter des gestionnaires d'événements à court terme à un fichier spécifique. <br><br><h3>  BufNewFile, BufRead </h3><br>  <code>BufnewFile</code> démarre lorsqu'un nouveau fichier est créé, <code>BufRead</code> - lorsque le tampon est ouvert pour la première fois.  Ils sont généralement utilisés pour ajouter des paramètres et des remappages à des types de fichiers spécifiques.  J'en ai un: <br><br><pre> <code class="plaintext hljs">augroup md autocmd! au BufNewFile,BufRead *.md syntax keyword todo TODO au BufNewFile,BufRead *.md inoremap &lt;buffer&gt; ;` ```&lt;cr&gt;&lt;cr&gt;```&lt;Up&gt;&lt;Up&gt; augroup END</code> </pre> <br>  Ce n'est que dans les fichiers Markdown que la ligne TODO est mise en évidence et les caractères <code>;`</code> en mode insertion ajoute une notation de code. <br><br>  Les équipes automatiques vous permettent de faire des choses beaucoup plus complexes.  Par exemple, <code>au</code> pour <code>BufWriteCmd</code> remplace l'enregistrement standard, vous permettant d'implémenter une logique personnalisée.  Cela va au-delà des «astuces» et va dans le domaine de la «magie noire». <br><br><h2>  Plugins </h2><br>  La plupart des gens connaissent les plugins populaires tels que <code>vim-surround</code> et <code>NERDtree</code> .  Voici une liste de quelques-uns peu connus que je trouve très utiles. <br><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Undotree</a> </h3><br>  Dans la plupart des éditeurs de texte, les actions d'annulation se produisent de façon linéaire.  Si vous apportez une modification à A, l'annulez, puis apportez une modification à B, alors A est perdu pour toujours.  Cependant, Vim stocke l'arborescence entière des actions annulées.  La commande <code>u</code> annule l'action dans la branche d'arbre actuelle et <code>g</code> passe à la version <i>chronologique</i> précédente.  Vous pouvez afficher la liste des actions annulées avec la commande <code>:undolist</code> . <br><br>  Mais ce format n'est pas très clair.  Il est préférable de voir l'arbre réel.  C'est exactement ce <code>Undotree</code> fait <code>Undotree</code> : il présente une bonne représentation ASCII de l'arbre des actions annulées avec une navigation pratique. <br><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vim.swap</a> </h3><br>  Le plugin fournit des commandes pour échanger des arguments, vous pouvez donc remplacer <code>(a, f(b, c))</code> par <code>(f(b, c), a)</code> en quelques frappes.  Je dois régulièrement faire de telles modifications, c'est donc une amélioration majeure de la qualité de vie. <br><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Neoterm</a> </h3><br>  Connecte une API de niveau supérieur au terminal intégré neo / vim.  Par exemple <code>:T {text}</code> envoie {text} à la console.  Bon pour créer un environnement interactif. <br><br><h2>  "TODO {{{ </h2><br>  De nombreux sujets ne sont pas traités dans cet article car ils sont trop techniques ou doivent être expliqués en détail, comme l'écriture de fonction ou le système de syntaxe.  Et je ne sais pas grand-chose.  Je voudrais étudier plus en détail les sujets suivants: <br><br><h3>  Fenêtres Aperçu, Quickfix et Liste </h3><br>  J'utilise parfois des outils avec ces fenêtres, mais je ne sais pas comment les manipuler.  Je voudrais ajouter des erreurs de correction rapide à mon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plugin TLA +</a> .  J'aime aussi l'idée de mettre les informations de support et les commandes de rappel dans la fenêtre d'aperçu.  Cela ouvre des possibilités difficiles à reproduire dans l'IDE. <br><br><h2>  API Neovim </h2><br>  Neovim propose une API avancée pour intégrer Vim à des programmes externes.  Votre script Python peut envoyer des commandes à l'instance Neovim et vous pouvez contrôler l'éditeur via le serveur, par exemple.  J'ai vu des démos conceptuelles sympas où la saisie semi-automatique se produit en fonction des informations d'un navigateur.  Ça a l'air très cool! <br><br><h2>  Objets texte </h2><br>  Jamais créé un tel. <br><br><hr><br>  Il s'agissait donc d'un bref aperçu de certaines des fonctions implicites de Vim.  J'espère que vous avez découvert quelque chose d'utile! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr454742/">https://habr.com/ru/post/fr454742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr454732/index.html">5 techniques de priorisation robustes pour les équipes informatiques</a></li>
<li><a href="../fr454734/index.html">Sauvegarde, Partie 4: Présentation et test de zbackup, restic, borgbackup</a></li>
<li><a href="../fr454736/index.html">Prise en charge de Visual Studio 2019 dans PVS-Studio</a></li>
<li><a href="../fr454738/index.html">Prise en charge de Visual Studio 2019 dans PVS-Studio</a></li>
<li><a href="../fr454740/index.html">Mai 2019 Joomla Digest</a></li>
<li><a href="../fr454744/index.html">Présentation des rapports de suivi Java de la conférence RigaDevDays</a></li>
<li><a href="../fr454748/index.html">Guide de survie MongoDB</a></li>
<li><a href="../fr454750/index.html">Swift UI - galoper à travers l'Europe</a></li>
<li><a href="../fr454754/index.html">Quand vaut-il la peine de vérifier l'hypothèse d'une efficacité non moindre?</a></li>
<li><a href="../fr454756/index.html">Vérification de l'efficacité du site et des paramètres publicitaires, du coût pour attirer les clients du grossiste</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>