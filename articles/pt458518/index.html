<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äç‚öïÔ∏è üéÖüèΩ ‚ò£Ô∏è Python consome muita mem√≥ria ou como reduzir o tamanho dos objetos? üìø üå∫ üçë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Um problema de mem√≥ria pode surgir quando um grande n√∫mero de objetos est√° ativo na RAM durante a execu√ß√£o de um programa, especialmente se houver res...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python consome muita mem√≥ria ou como reduzir o tamanho dos objetos?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458518/"><p>  Um problema de mem√≥ria pode surgir quando um grande n√∫mero de objetos est√° ativo na RAM durante a execu√ß√£o de um programa, especialmente se houver restri√ß√µes na quantidade total de mem√≥ria dispon√≠vel. </p><br><p>  Abaixo est√° uma vis√£o geral de alguns m√©todos para reduzir o tamanho dos objetos, o que pode reduzir significativamente a quantidade de RAM necess√°ria para programas em Python puro. </p><br><p>  <strong>Nota:</strong> <em>Esta √© a vers√£o em ingl√™s da minha <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">postagem</a> original (em russo).</em> </p><a name="habracut"></a><br><p> Para simplificar, consideraremos estruturas em Python para representar pontos com as coordenadas <code>x</code> , <code>y</code> , <code>z</code> com acesso aos valores das coordenadas por nome. </p><br><h3 id="dict">  Dict </h3><br><p>  Em pequenos programas, especialmente em scripts, √© bastante simples e conveniente usar o <code>dict</code> para representar informa√ß√µes estruturais: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; ob = {'x':1, 'y':2, 'z':3} &gt;&gt;&gt; x = ob['x'] &gt;&gt;&gt; ob['y'] = y</code> </pre> <br><p>  Com o advento de uma implementa√ß√£o mais compacta no Python 3.6 com um conjunto ordenado de chaves, o <code>dict</code> se tornou ainda mais atraente.  No entanto, vejamos o tamanho de sua presen√ßa na RAM: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; print(sys.getsizeof(ob)) 240</code> </pre> <br><p>  √â preciso muita mem√≥ria, especialmente se voc√™ precisar criar repentinamente um grande n√∫mero de inst√¢ncias: </p><br><div class="scrollable-table"><table><thead><tr><th>  N√∫mero de inst√¢ncias </th><th>  Tamanho dos objetos </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  240 Mb </td></tr><tr><td>  10.000.000 </td><td>  2,40 Gb </td></tr><tr><td>  100.000.000 </td><td>  24 gb </td></tr></tbody></table></div><br><h3 id="class-instance">  Inst√¢ncia de classe </h3><br><p>  Para quem gosta de vestir tudo nas classes, √© prefer√≠vel definir estruturas como uma classe com acesso pelo nome do atributo: </p><br><pre> <code class="plaintext hljs">class Point: # def __init__(self, x, y, z): self.x = x self.y = y self.z = z &gt;&gt;&gt; ob = Point(1,2,3) &gt;&gt;&gt; x = ob.x &gt;&gt;&gt; ob.y = y</code> </pre> <br><p>  A estrutura da inst√¢ncia da classe √© interessante: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Campo </th><th>  Tamanho (bytes) </th></tr><tr><td>  PyGC_Head </td><td>  24 </td></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  __weakref__ </td><td>  8 </td></tr><tr><td>  __dict__ </td><td>  8 </td></tr><tr><td>  <b>TOTAL:</b> </td><td>  <b>56.</b> </td></tr></tbody></table></div><br><p>  Aqui <code>__weakref__</code> √© uma refer√™ncia √† lista das chamadas refer√™ncias fracas a esse objeto, o campo <code>__dict__</code> √© uma refer√™ncia ao dicion√°rio de inst√¢ncia da classe, que cont√©m os valores dos atributos da inst√¢ncia (observe que a plataforma de refer√™ncias de 64 bits ocupa 8 bytes).  A partir do Python 3.3, o espa√ßo compartilhado √© usado para armazenar chaves no dicion√°rio para todas as inst√¢ncias da classe.  Isso reduz o tamanho do rastreamento da inst√¢ncia na RAM: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; print(sys.getsizeof(ob), sys.getsizeof(ob.__dict__)) 56 112</code> </pre> <br><p>  Como resultado, um grande n√∫mero de inst√¢ncias de classe tem um espa√ßo menor na mem√≥ria que um dicion√°rio comum ( <code>dict</code> ): </p><br><div class="scrollable-table"><table><thead><tr><th>  N√∫mero de inst√¢ncias </th><th>  Tamanho </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  168 Mb </td></tr><tr><td>  10.000.000 </td><td>  1,68 Gb </td></tr><tr><td>  100.000.000 </td><td>  16,8 Gb </td></tr></tbody></table></div><br><p>  √â f√°cil ver que o tamanho da inst√¢ncia na RAM ainda √© grande devido ao tamanho do dicion√°rio da inst√¢ncia. </p><br><h3 id="instance-of-class-with--__slots__">  Inst√¢ncia da classe com __slots__ </h3><br><p>  Uma redu√ß√£o significativa no tamanho de uma inst√¢ncia de classe na RAM √© obtida com a elimina√ß√£o de <code>__dict__</code> e <code>__weakref__</code> .  Isso √© poss√≠vel com a ajuda de um "truque" com <code>__slots__</code> : </p><br><pre> <code class="plaintext hljs">class Point: __slots__ = 'x', 'y', 'z' def __init__(self, x, y, z): self.x = x self.y = y self.z = z &gt;&gt;&gt; ob = Point(1,2,3) &gt;&gt;&gt; print(sys.getsizeof(ob)) 64</code> </pre> <br><p>  O tamanho do objeto na RAM tornou-se significativamente menor: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Campo </th><th>  Tamanho (bytes) </th></tr><tr><td>  PyGC_Head </td><td>  24 </td></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  x </td><td>  8 </td></tr><tr><td>  y </td><td>  8 </td></tr><tr><td>  z </td><td>  8 </td></tr><tr><td>  <b>TOTAL:</b> </td><td>  <b>64</b> </td></tr></tbody></table></div><br><p>  O uso de <code>__slots__</code> na defini√ß√£o de classe faz com que o espa√ßo ocupado por um grande n√∫mero de inst√¢ncias na mem√≥ria seja reduzido significativamente: </p><br><div class="scrollable-table"><table><thead><tr><th>  N√∫mero de inst√¢ncias </th><th>  Tamanho </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  64 Mb </td></tr><tr><td>  10.000.000 </td><td>  640 Mb </td></tr><tr><td>  100.000.000 </td><td>  6,4 Gb </td></tr></tbody></table></div><br><p>  Atualmente, esse √© o principal m√©todo de reduzir substancialmente o espa√ßo ocupado pela mem√≥ria de uma inst√¢ncia de uma classe na RAM. </p><br><p>  Essa redu√ß√£o √© alcan√ßada pelo fato de que na mem√≥ria ap√≥s o t√≠tulo do objeto, as refer√™ncias do objeto s√£o armazenadas - os valores dos atributos e o acesso a eles √© realizado usando descritores especiais que est√£o no dicion√°rio de classes: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; pprint(Point.__dict__) mappingproxy( .................................... 'x': &lt;member 'x' of 'Point' objects&gt;, 'y': &lt;member 'y' of 'Point' objects&gt;, 'z': &lt;member 'z' of 'Point' objects&gt;})</code> </pre> <br><p>  Para automatizar o processo de cria√ß√£o de uma classe com <code>__slots__</code> , existe uma biblioteca [namedlist] ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://pypi.org/project/namedlist</a> ).  A fun√ß√£o <code>namedlist.namedlist</code> cria uma classe com <code>__slots__</code> : </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; Point = namedlist('Point', ('x', 'y', 'z'))</code> </pre> <br><p>  Outro pacote [attrs] ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://pypi.org/project/attrs</a> ) permite automatizar o processo de cria√ß√£o de classes com e sem <code>__slots__</code> . </p><br><h3 id="tuple">  Tuple </h3><br><p>  O Python tamb√©m possui uma <code>tuple</code> tipo embutida para representar estruturas de dados imut√°veis.  Uma tupla √© uma estrutura ou registro fixo, mas sem nomes de campos.  Para acesso ao campo, o √≠ndice do campo √© usado.  Os campos da tupla s√£o associados de uma vez por todas aos objetos de valor no momento da cria√ß√£o da inst√¢ncia da tupla: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; ob = (1,2,3) &gt;&gt;&gt; x = ob[0] &gt;&gt;&gt; ob[1] = y # ERROR</code> </pre> <br><p>  Inst√¢ncias de tupla s√£o bastante compactas: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; print(sys.getsizeof(ob)) 72</code> </pre> <br><p>  Eles ocupam 8 bytes na mem√≥ria mais do que inst√¢ncias de classes com <code>__slots__</code> , pois o rastreamento da tupla na mem√≥ria tamb√©m cont√©m v√°rios campos: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Campo </th><th>  Tamanho (bytes) </th></tr><tr><td>  PyGC_Head </td><td>  24 </td></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  ob_size </td><td>  8 </td></tr><tr><td>  [0] </td><td>  8 </td></tr><tr><td>  [1] </td><td>  8 </td></tr><tr><td>  [2] </td><td>  8 </td></tr><tr><td>  <b>TOTAL:</b> </td><td>  <b>72</b> </td></tr></tbody></table></div><br><h3 id="namedtuple">  Namedtuple </h3><br><p>  Como a tupla √© usada muito amplamente, um dia houve uma solicita√ß√£o de que voc√™ ainda poderia ter acesso aos campos e tamb√©m pelo nome.  A resposta para esta solicita√ß√£o foi o m√≥dulo <code>collections.namedtuple</code> . </p><br><p>  A fun√ß√£o <code>namedtuple</code> foi projetada para automatizar o processo de gera√ß√£o dessas classes: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; Point = namedtuple('Point', ('x', 'y', 'z'))</code> </pre> <br><p>  Ele cria uma subclasse de tupla, na qual os descritores s√£o definidos para acessar os campos pelo nome.  Para o nosso exemplo, seria algo parecido com isto: </p><br><pre> <code class="plaintext hljs"> class Point(tuple): # @property def _get_x(self): return self[0] @property def _get_y(self): return self[1] @property def _get_z(self): return self[2] # def __new__(cls, x, y, z): return tuple.__new__(cls, (x, y, z))</code> </pre> <br><p>  Todas as inst√¢ncias de tais classes t√™m um espa√ßo de mem√≥ria id√™ntico ao de uma tupla.  Um grande n√∫mero de inst√¢ncias deixa um espa√ßo de mem√≥ria um pouco maior: </p><br><div class="scrollable-table"><table><thead><tr><th>  N√∫mero de inst√¢ncias </th><th>  Tamanho </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  72 Mb </td></tr><tr><td>  10.000.000 </td><td>  720 Mb </td></tr><tr><td>  100.000.000 </td><td>  7,2 Gb </td></tr></tbody></table></div><br><h3 id="recordclass-mutable-namedtuple-without-cyclic-gc">  Classe de grava√ß√£o: mut√°vel nomeado duplo sem GC c√≠clico </h3><br><p>  Como a <code>tuple</code> e, consequentemente, as <code>namedtuple</code> nomeados <code>namedtuple</code> pares geram objetos imut√°veis, no sentido de que o atributo <code>ob.x</code> n√£o pode mais ser associado a outro objeto de valor, surgiu uma solicita√ß√£o para uma variante mut√°vel denominada por casal.  Como n√£o existe um tipo interno no Python que seja id√™ntico √† tupla que suporta atribui√ß√µes, muitas op√ß√µes foram criadas.  Vamos nos concentrar em [recordclass] ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://pypi.org/project/recordclass</a> ), que recebeu uma classifica√ß√£o de [stackoverflow] ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://stackoverflow.com/questions/29290359/existence-of-mutable-named- tuple-em-</a> python / 29419745).  Al√©m disso, pode ser usado para reduzir o tamanho dos objetos na RAM em compara√ß√£o com o tamanho dos objetos semelhantes a <code>tuple</code> . </p><br><p>  O pacote <strong>recordclass</strong> apresenta o tipo <code>recordclass.mutabletuple</code> , que √© quase id√™ntico √† tupla, mas tamb√©m suporta atribui√ß√µes.  Basicamente, s√£o criadas subclasses quase completamente id√™nticas aos nomeados, mas tamb√©m suportam a atribui√ß√£o de novos valores aos campos (sem criar novas inst√¢ncias).  A fun√ß√£o <code>recordclass</code> , como a fun√ß√£o <code>namedtuple</code> , permite automatizar a cria√ß√£o dessas classes: </p><br><pre> <code class="plaintext hljs"> &gt;&gt;&gt; Point = recordclass('Point', ('x', 'y', 'z')) &gt;&gt;&gt; ob = Point(1, 2, 3)</code> </pre> <br><p>  As inst√¢ncias de classe t√™m a mesma estrutura que a <code>tuple</code> , mas apenas sem <code>PyGC_Head</code> : </p><br><div class="scrollable-table"><table><tbody><tr><th>  Campo </th><th>  Tamanho (bytes) </th></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  ob_size </td><td>  8 </td></tr><tr><td>  x </td><td>  8 </td></tr><tr><td>  y </td><td>  8 </td></tr><tr><td>  y </td><td>  8 </td></tr><tr><td>  <b>TOTAL:</b> </td><td>  <b>48.</b> </td></tr></tbody></table></div><br><p>  Por padr√£o, a fun√ß√£o <code>recordclass</code> cria uma classe que n√£o participa do mecanismo de coleta de lixo c√≠clico.  Normalmente, <code>namedtuple</code> e <code>recordclass</code> s√£o usados ‚Äã‚Äãpara gerar classes representando registros ou estruturas de dados simples (n√£o recursivas).  Us√°-los corretamente no Python n√£o gera refer√™ncias circulares.  Por esse motivo, na sequ√™ncia de inst√¢ncias de classes geradas pela <code>recordclass</code> de <code>recordclass</code> , por <code>default, the</code> <code>fragment is excluded, which is necessary for classes supporting the cyclic garbage collection mechanism (more precisely: in the</code> PyGC_Head <code>fragment is excluded, which is necessary for classes supporting the cyclic garbage collection mechanism (more precisely: in the</code> <code>structure, corresponding to the created class, in the</code> PyTypeObject <code>structure, corresponding to the created class, in the</code> <code>field, by default, the flag</code> sinalizadores <code>field, by default, the flag</code> Py_TPFLAGS_HAVE_GC` n√£o est√° definido). </p><br><p>  O tamanho do espa√ßo ocupado pela mem√≥ria de um grande n√∫mero de inst√¢ncias √© menor que o das inst√¢ncias da classe com <code>__slots__</code> : </p><br><div class="scrollable-table"><table><thead><tr><th>  N√∫mero de inst√¢ncias </th><th>  Tamanho </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  48 Mb </td></tr><tr><td>  10.000.000 </td><td>  480 Mb </td></tr><tr><td>  100.000.000 </td><td>  4,8 Gb </td></tr></tbody></table></div><br><h3 id="dataobject">  Dataobject </h3><br><p>  Outra solu√ß√£o proposta na biblioteca de classe de registro √© baseada na id√©ia: use a mesma estrutura de armazenamento na mem√≥ria que nas inst√¢ncias de classe com <code>__slots__</code> , mas n√£o participe do mecanismo de coleta de lixo c√≠clico.  Essas classes s√£o geradas usando a fun√ß√£o <code>recordclass.make_dataclass</code> : </p><br><pre> <code class="plaintext hljs"> &gt;&gt;&gt; Point = make_dataclass('Point', ('x', 'y', 'z'))</code> </pre> <br><p>  A classe criada dessa maneira, por padr√£o, cria inst√¢ncias mut√°veis. </p><br><p>  Outra maneira - use a declara√ß√£o de classe com heran√ßa de <code>recordclass.dataobject</code> : </p><br><pre> <code class="plaintext hljs">class Point(dataobject): x:int y:int z:int</code> </pre> <br><p>  As classes criadas dessa maneira criar√£o inst√¢ncias que n√£o participam do mecanismo de coleta de lixo c√≠clico.  A estrutura da inst√¢ncia na mem√≥ria √© a mesma do caso com <code>__slots__</code> , mas sem o <code>PyGC_Head</code> : </p><br><div class="scrollable-table"><table><tbody><tr><th>  Campo </th><th>  Tamanho (bytes) </th></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  x </td><td>  8 </td></tr><tr><td>  y </td><td>  8 </td></tr><tr><td>  y </td><td>  8 </td></tr><tr><td>  <b>TOTAL:</b> </td><td>  <b>40.</b> </td></tr></tbody></table></div><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; ob = Point(1,2,3) &gt;&gt;&gt; print(sys.getsizeof(ob)) 40</code> </pre> <br><p>  Para acessar os campos, descritores especiais tamb√©m s√£o usados ‚Äã‚Äãpara acessar o campo por seu deslocamento desde o in√≠cio do objeto, localizado no dicion√°rio de classes: </p><br><pre> <code class="plaintext hljs">mappingproxy({'__new__': &lt;staticmethod at 0x7f203c4e6be0&gt;, ....................................... 'x': &lt;recordclass.dataobject.dataslotgetset at 0x7f203c55c690&gt;, 'y': &lt;recordclass.dataobject.dataslotgetset at 0x7f203c55c670&gt;, 'z': &lt;recordclass.dataobject.dataslotgetset at 0x7f203c55c410&gt;})</code> </pre> <br><p>  O tamanho da √°rea ocupada por mem√≥ria de um grande n√∫mero de inst√¢ncias √© o m√≠nimo poss√≠vel para o CPython: </p><br><div class="scrollable-table"><table><thead><tr><th>  N√∫mero de inst√¢ncias </th><th>  Tamanho </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  40 Mb </td></tr><tr><td>  10.000.000 </td><td>  400 Mb </td></tr><tr><td>  100.000.000 </td><td>  4,0 Gb </td></tr></tbody></table></div><br><h3 id="cython">  Cython </h3><br><p>  H√° uma abordagem baseada no uso do [Cython] ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://cython.org</a> ).  Sua vantagem √© que os campos podem assumir os valores dos tipos at√¥micos da linguagem C.  Descritores para acessar campos do Python puro s√£o criados automaticamente.  Por exemplo: </p><br><pre> <code class="plaintext hljs">cdef class Python: cdef public int x, y, z def __init__(self, x, y, z): self.x = x self.y = y self.z = z</code> </pre> <br><p>  Nesse caso, as inst√¢ncias t√™m um tamanho de mem√≥ria ainda menor: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; ob = Point(1,2,3) &gt;&gt;&gt; print(sys.getsizeof(ob)) 32</code> </pre> <br><p>  O rastreio da inst√¢ncia na mem√≥ria possui a seguinte estrutura: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Campo </th><th>  Tamanho (bytes) </th></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  x </td><td>  4 </td></tr><tr><td>  y </td><td>  4 </td></tr><tr><td>  y </td><td>  4 </td></tr><tr><td>  est√° vazio </td><td>  4 </td></tr><tr><td>  <b>TOTAL:</b> </td><td>  <b>32.</b> </td></tr></tbody></table></div><br><p>  O tamanho da √°rea de cobertura de um grande n√∫mero de c√≥pias √© menor: </p><br><div class="scrollable-table"><table><thead><tr><th>  N√∫mero </th><th>  Tamanho </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  32 Mb </td></tr><tr><td>  10.000.000 </td><td>  320 Mb </td></tr><tr><td>  100.000.000 </td><td>  3,2 Gb </td></tr></tbody></table></div><br><p>  No entanto, deve-se lembrar que ao acessar do c√≥digo Python, uma convers√£o de <code>int</code> para um objeto Python e vice-versa ser√° realizada sempre. </p><br><h3 id="numpy">  Numpy </h3><br><p>  O uso de matrizes multidimensionais ou matrizes de registros para uma grande quantidade de dados fornece um ganho de mem√≥ria.  No entanto, para um processamento eficiente em Python puro, voc√™ deve usar m√©todos de processamento focados no uso de fun√ß√µes do pacote <code>numpy</code> . </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; Point = numpy.dtype(('x', numpy.int32), ('y', numpy.int32), ('z', numpy.int32)])</code> </pre> <br><p>  Uma matriz de <code>N</code> elementos, inicializada com zeros, √© criada usando a fun√ß√£o: </p><br><pre> <code class="plaintext hljs"> &gt;&gt;&gt; points = numpy.zeros(N, dtype=Point)</code> </pre> <br><p>  O tamanho da matriz na mem√≥ria √© o m√≠nimo poss√≠vel: </p><br><div class="scrollable-table"><table><thead><tr><th>  N√∫mero de objetos </th><th>  Tamanho </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  12 Mb </td></tr><tr><td>  10.000.000 </td><td>  120 Mb </td></tr><tr><td>  100.000.000 </td><td>  1,20 Gb </td></tr></tbody></table></div><br><p>  O acesso normal aos elementos e linhas da matriz exigir√° a convers√£o de um objeto Python para um valor C <code>int</code> e vice-versa.  A extra√ß√£o de uma √∫nica linha resulta na cria√ß√£o de uma matriz que cont√©m um √∫nico elemento.  Seu rastreio n√£o ser√° mais t√£o compacto: </p><br><pre> <code class="plaintext hljs"> &gt;&gt;&gt; sys.getsizeof(points[0]) 68</code> </pre> <br><p>  Portanto, como observado acima, no c√≥digo Python, √© necess√°rio processar matrizes usando fun√ß√µes do pacote <code>numpy</code> . </p><br><h3 id="conclusion">  Conclus√£o </h3><br><p>  Em um exemplo claro e simples, foi poss√≠vel verificar se a comunidade de desenvolvedores e usu√°rios da linguagem de programa√ß√£o Python (CPython) tem possibilidades reais de uma redu√ß√£o significativa na quantidade de mem√≥ria usada pelos objetos. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt458518/">https://habr.com/ru/post/pt458518/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt458504/index.html">13 npm truques para economizar tempo</a></li>
<li><a href="../pt458506/index.html">N√£o Portal 3, mas pr√≥ximo: teletransporte qu√¢ntico de informa√ß√µes dentro de um diamante</a></li>
<li><a href="../pt458508/index.html">Um olhar por dentro: p√≥s-gradua√ß√£o na EPFL. Parte 4.2: o lado financeiro</a></li>
<li><a href="../pt458514/index.html">A viola√ß√£o do RGPD √© punida de forma mais ativa - novas multas e o impacto de regulamentos fora da UE</a></li>
<li><a href="../pt458516/index.html">Obtenha um log de trabalho de Jira</a></li>
<li><a href="../pt458520/index.html">O livro "C√≥digo de alto desempenho na plataforma .NET. 2¬™ edi√ß√£o</a></li>
<li><a href="../pt458524/index.html">VC palavra nuvem no joelho</a></li>
<li><a href="../pt458530/index.html">Zabbix, s√©ries temporais e TimescaleDB</a></li>
<li><a href="../pt458532/index.html">Pioneiros de novas tecnologias: Vadim Artsev contou como deixou de ser cego</a></li>
<li><a href="../pt458536/index.html">Python + Pyside2 ou simplesmente "Calculadora"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>