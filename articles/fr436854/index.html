<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏼 🧥 🗄️ Rust 1.32 Release 👌🏾 🗨️ 🧔🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'équipe de développement de Rust est heureuse d'annoncer la sortie d'une nouvelle version de Rust, 1.32.0. Rust est un langage de programmation qui p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rust 1.32 Release</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436854/"><p>  L'équipe de développement de Rust est heureuse d'annoncer la sortie d'une nouvelle version de Rust, 1.32.0.  Rust est un langage de programmation qui permet à chacun de créer des logiciels fiables et efficaces. </p><br><p> Si vous avez une version précédente de Rust installée à l'aide de <code>rustup</code> , alors pour mettre à niveau Rust vers la version 1.32.0, il vous suffit de faire: </p><br><pre> <code class="bash hljs">$ rustup update stable</code> </pre> <br><p>  Si vous n'avez pas encore installé <code>rustup</code> , vous pouvez l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">installer à</a> partir de la page correspondante de notre site Web.  <a href="">Des notes de version détaillées pour Rust 1.32.0</a> sont disponibles sur GitHub. </p><br><blockquote>  Une note <code>rustup</code> : plusieurs nouvelles versions de <code>rustup</code> ont été <code>rustup</code> !  Pour mettre à jour <code>rustup</code> lui-même, effectuez <code>rustup self update</code> . </blockquote><br><h2 id="chto-voshlo-v-stabilnuyu-versiyu-1320">  Ce qui est inclus dans la version stable 1.32.0 </h2><br><p>  Rust 1.32.0 a acquis plusieurs améliorations améliorant la vie, a changé l'allocateur de mémoire par défaut et a rendu plus de fonctions constantes.  Lisez ces modifications ci-dessous ou voyez-en plus <a href="">dans les notes de version</a> . </p><a name="habracut"></a><br><h4 id="makros-dbg">  Macro dbg </h4><br><p>  Commençons par une amélioration qui améliore la vie.  Utilisez-vous le débogage d'impression?  Si c'est le cas et que vous souhaitez imprimer une valeur tout en travaillant sur le code, vous êtes obligé de le faire: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{:?}"</span></span>, x); <span class="hljs-comment"><span class="hljs-comment">//    println!("{:#?}", x);</span></span></code> </pre> <br><p>  Ce n'est pas <em>le plus gros</em> obstacle qui ralentit le développement, mais il faut trop d'efforts pour simplement déboguer la sortie de la valeur <code>x</code> .  De plus, le contexte n'est pas pris en compte ici.  Si vous en possédez plusieurs <code>println!</code>  s, il devient difficile de déterminer à quoi se réfère la sortie, jusqu'à ce que vous ajoutiez vous-même des informations de contexte à chaque appel, ce qui nécessite encore plus de travail. </p><br><p>  À ces fins, dans Rust 1.32.0, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nous avons ajouté une nouvelle macro dbg!</a>  : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span>; dbg!(x); }</code> </pre> <br><p>  Après avoir démarré ce programme, vous verrez: </p><br><pre> <code class="plaintext hljs">[src/main.rs:4] x = 5</code> </pre> <br><p>  Avec le nom de la variable et sa valeur, le nom du fichier et le numéro de ligne où l'appel <code>dbg!</code> été effectué seront affichés <code>dbg!</code>  . </p><br><p>  De plus, <code>println!</code>  imprime à la sortie standard, il est donc préférable d'utiliser <code>eprintln!</code>  pour imprimer dans le flux d'erreur standard.  Macro <code>dbg!</code>  sorties à <code>stderr</code> , et à juste titre. </p><br><p>  Cela fonctionne même dans les cas difficiles.  Prenons un exemple de mise en œuvre factorielle: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span></span>(n: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> { n } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { n * factorial(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) } }</code> </pre> <br><p>  Afin de le déboguer, nous pouvons utiliser <code>eprintln!</code>  : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span></span>(n: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> { eprintln!(<span class="hljs-string"><span class="hljs-string">"n: {}"</span></span>, n); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> { eprintln!(<span class="hljs-string"><span class="hljs-string">"n &lt;= 1"</span></span>); n } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> n = n * factorial(n - <span class="hljs-number"><span class="hljs-number">1</span></span>); eprintln!(<span class="hljs-string"><span class="hljs-string">"n: {}"</span></span>, n); n } }</code> </pre> <br><p>  Nous voulons afficher <code>n</code> à chaque itération et voir le contexte de chacune des branches.  Pour <code>factorial(4)</code> affichera: </p><br><pre> <code class="plaintext hljs">n: 4 n: 3 n: 2 n: 1 n &lt;= 1 n: 2 n: 6 n: 24</code> </pre> <br><p>  C'est acceptable, mais pas particulièrement bon.  Peut-être pourrions-nous travailler à améliorer la sortie des informations contextuelles pour rendre la conclusion plus claire.  Mais ensuite, au lieu de déboguer notre code, nous améliorerons le code de débogage. </p><br><p>  Prenons le même exemple en utilisant <code>dbg!</code>  : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span></span>(n: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dbg!(n &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { dbg!(<span class="hljs-number"><span class="hljs-number">1</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { dbg!(n * factorial(n - <span class="hljs-number"><span class="hljs-number">1</span></span>)) } }</code> </pre> <br><p>  Nous avons simplement encapsulé une macro avec chacune des expressions que nous voulons afficher.  En conséquence, nous obtenons: </p><br><pre> <code class="plaintext hljs">[src/main.rs:3] n &lt;= 1 = false [src/main.rs:3] n &lt;= 1 = false [src/main.rs:3] n &lt;= 1 = false [src/main.rs:3] n &lt;= 1 = true [src/main.rs:4] 1 = 1 [src/main.rs:5] n * factorial(n - 1) = 2 [src/main.rs:5] n * factorial(n - 1) = 6 [src/main.rs:5] n * factorial(n - 1) = 24 [src/main.rs:11] factorial(4) = 24</code> </pre> <br><p>  Puisque la macro est <code>dbg!</code>  renvoie la valeur de débogage elle-même, contrairement à <code>eprintln!</code>  , qui retourne <code>()</code> , alors nous n'avons pas besoin de modifier la structure de notre code.  De plus, nous obtenons une conclusion <em>beaucoup</em> plus utile. </p><br><p>  Nous avons accordé beaucoup d'attention à une si petite macro, car nous espérons qu'elle simplifiera votre processus de débogage.  Bien sûr, nous continuons également à travailler sur le soutien de <code>gdb</code> and Co. </p><br><h4 id="po-umolchaniyu-ubran-jemalloc">  <code>jemalloc</code> supprimé par <code>jemalloc</code> </h4><br><p>  Il était une fois, Rust avait une grande autonomie similaire à Erlang.  Pour lui, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jemalloc a</a> été choisi à la place de l'allocateur système, car il était souvent plus productif.  Peu à peu, nous nous sommes débarrassés de l'exécution de plus en plus et à la fin, presque tout a été supprimé, mais jemalloc est resté.  Nous n'avions aucun moyen de choisir un allocateur personnalisé, et donc nous ne pouvions pas supprimer complètement jemalloc, afin de ne pas nuire à ceux qui en avaient besoin. </p><br><p>  De plus, l'affirmation selon laquelle <code>jemalloc</code> a toujours été l' <code>jemalloc</code> par défaut était principalement liée au monde UNIX, car il n'était par défaut que sur <em>certaines</em> plates-formes.  En particulier, l'objectif de MSVC sur Windows utilise depuis longtemps un allocateur système. </p><br><p>  Enfin, bien que jemalloc ait <em>généralement de</em> bonnes performances, ce n'est pas toujours le cas.  De plus, il ajoute environ 300 kilo-octets à chaque exécutable.  De plus, nous avons accumulé de nombreux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">autres problèmes</a> avec jemalloc.  En général, il est étrange que le langage système n'utilise pas l'allocateur système par défaut. </p><br><p>  Pour ces raisons, dès que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rust 1.28 a fourni un moyen de choisir un allocateur global</a> , nous avons commencé à planifier de basculer vers l'allocateur système par défaut et de fournir <code>jemalloc</code> tant que bibliothèque externe.  Dans Rust 1.32, nous avons finalement terminé ce travail, et maintenant par défaut votre programme utilisera l'allocateur système. </p><br><p>  Si vous souhaitez continuer à utiliser jemalloc, utilisez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la bibliothèque jemallocator</a> .  Pour ce faire, spécifiez dans <code>Cargo.toml</code> : </p><br><pre> <code class="plaintext hljs">jemallocator = "0.1.8"</code> </pre> <br><p>  Et dans le fichier racine de votre projet: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[global_allocator]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ALLOC: jemallocator::Jemalloc = jemallocator::Jemalloc;</code> </pre> <br><p>  C'est tout!  Si vous n'avez pas besoin de jemalloc, vous n'êtes plus obligé de l'utiliser, mais si vous en avez besoin, le problème est résolu avec quelques lignes de code. </p><br><h4 id="zaklyuchitelnye-uluchsheniya-sistemy-moduley">  Améliorations du système de module final </h4><br><p>  Dans les deux dernières versions, nous avons parlé de plusieurs améliorations apportées au système de modules.  Dans la version 1.32.0 et l'édition 2018, nous avons ajouté la dernière modification.  Il est appelé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"chemins uniformes"</a> et vous permet de travailler avec des chemins d'importation de la même manière qu'avec d'autres chemins, qui fonctionnaient auparavant de manière incorrecte.  Par exemple: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span></span> { Red, Green, Blue } <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Color::*;</code> </pre> <br><p>  Ce code <em>n'a</em> pas été compilé <em>auparavant</em> , car les chemins <code>use</code> devraient avoir commencé avec <code>super</code> , <code>self</code> ou <code>crate</code> .  Maintenant, grâce au compilateur prenant en charge les chemins cohérents, ce code fonctionnera et fera ce que vous attendez: importer des variantes de l'énumération <code>Color</code> définie ci-dessus. </p><br><p>  Cette modification complète notre révision du système de modules.  Nous espérons que vous apprécierez l'utilisation du système simplifié! </p><br><h4 id="uluchsheniya-makrosov">  Améliorations des macros </h4><br><p>  Rust 1.32.0 a publié plusieurs améliorations de macro.  Tout d'abord, un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nouveau spécificateur de fragment littéral a</a> été ajouté: </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">macro_rules!</span></span> m { ($lt:literal) =&gt; {}; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { m!(<span class="hljs-string"><span class="hljs-string">"some string literal"</span></span>); }</code> </pre> <br><p>  Le fragment <code>literal</code> est mappé à des littéraux de tout type: chaîne, numérique et caractère. </p><br><p>  Dans l' <code>macro_rules</code> 2018 <code>macro_rules</code> pouvez-vous également utiliser des <code>macro_rules</code> <strong><code>?</code></strong>  : </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">macro_rules!</span></span> bar { ($(a)?) =&gt; {} }</code> </pre> <br><p>  Fragment avec <strong><code>?</code></strong>  une occurrence zéro ou une sera mise en correspondance, tout comme un fragment avec <code>*</code> correspond déjà à des occurrences «zéro ou plus», et avec <strong><code>+</code></strong> , une ou plusieurs occurrences. </p><br><h3 id="stabilizaciya-standartnoy-biblioteki">  Stabilisation de la bibliothèque standard </h3><br><p>  Macro <code>dbg!</code>  , que nous avons déjà décrit ci-dessus, est devenu un ajout important à la bibliothèque standard.  De plus, 19 fonctions ont été rendues constantes et tous les types primitifs numériques ont reçu des fonctions de conversion en un tableau d'octets et vice versa avec l'ordre d'octets spécifié.  Il y a six fonctions avec les noms <code>to_&lt;endian&gt;_bytes</code> et <code>from_&lt;endian&gt;_bytes</code> , où <code>&lt;endian&gt;</code> est: </p><br><ul><li>  <code>ne</code> - ordre natif (endianité native) </li><li>  <code>le</code> - ordre du junior au senior (petit endian) </li><li>  <code>be</code> - ordre du plus vieux au plus jeune (big endian) </li></ul><br><p>  Voir <a href="">les notes de version pour plus de</a> détails. </p><br><h3 id="uluchsheniya-v-cargo">  Améliorations du fret </h3><br><p>  Cargo a reçu l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">alias <strong>cargo c</strong> pour la commande <strong>cargo check</strong></a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">autorise</a> désormais l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">utilisation des noms d'utilisateur dans les URL du référentiel</a> . </p><br><p>  Voir <a href="">les notes de version pour plus de</a> détails. </p><br><h2 id="razrabotchiki-1320">  Développeurs 1.32.0 </h2><br><p>  Beaucoup de gens ont créé ensemble Rust 1.32.0.  Nous n'aurions pas pu terminer le travail sans chacun de vous.  <a href="">Je vous remercie!</a> </p><br><p>  <em>De la part d'un traducteur: Je remercie tout particulièrement les membres de la communauté Rustycrate et personnellement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@dashadee</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">ozkriff</a> pour leur aide dans la traduction et la relecture.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr436854/">https://habr.com/ru/post/fr436854/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr436842/index.html">Solution Veeam pour la sauvegarde et la restauration de machines virtuelles sur la plateforme Nutanix AHV. 2e partie</a></li>
<li><a href="../fr436846/index.html">Le condensé de matières fraîches du monde du front-end de la dernière semaine n ° 348 (14-20 janvier 2019)</a></li>
<li><a href="../fr436848/index.html">La NSA annonce la sortie d'un outil interne de rétro-ingénierie</a></li>
<li><a href="../fr436850/index.html">Erreurs courantes lors de l'écriture des tests unitaires. Conférence Yandex</a></li>
<li><a href="../fr436852/index.html">Ralentir pour stimuler le développement</a></li>
<li><a href="../fr436856/index.html">Plan de développement informatique selon le ministère des Communications: souveraineté numérique, blockchain dans le logement et les services communaux, logiciel pour «réalité changée»</a></li>
<li><a href="../fr436858/index.html">Espéranto, elfique et klingon</a></li>
<li><a href="../fr436860/index.html">Dell et Alienware au CES 2019: un guide de toutes les innovations majeures</a></li>
<li><a href="../fr436862/index.html">AMD Ryzen Matisse de 3e génération: Octa-Core Zen 2 avec PCIe 4.0 pour ordinateur de bureau</a></li>
<li><a href="../fr436864/index.html">Comment tester votre propre distribution de système d'exploitation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>