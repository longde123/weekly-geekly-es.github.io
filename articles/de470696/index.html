<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äç‚öñÔ∏è üë∞ üë®‚Äçüë®‚Äçüë¶ Warum ist Kaldi gut f√ºr die Spracherkennung? (aktualisiert am 25.12.2019) üëµüèº üëåüèæ üë∞üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Warum interessiere ich mich (und ich hoffe Sie) f√ºr Spracherkennung? Erstens ist diese Richtung eine der beliebtesten im Vergleich zu anderen Aufgaben...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Warum ist Kaldi gut f√ºr die Spracherkennung? (aktualisiert am 25.12.2019)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470696/"><img src="https://habrastorage.org/webt/u6/kw/t0/u6kwt05e-r1amvb5tgew7dby6fk.jpeg"><br><br>  Warum interessiere ich mich (und ich hoffe Sie) f√ºr Spracherkennung?  Erstens ist diese Richtung eine der beliebtesten im Vergleich zu anderen Aufgaben der Computerlinguistik, da die Spracherkennungstechnologie mittlerweile fast √ºberall eingesetzt wird - von der Erkennung eines einfachen Ja / Nein im automatischen Callcenter der Bank bis zur Unterst√ºtzung von ‚ÄûSmall Talk‚Äú "Smart Column" wie "Alice".  Zweitens ist es f√ºr ein Spracherkennungssystem von hoher Qualit√§t erforderlich, die effektivsten Werkzeuge zum Erstellen und Konfigurieren eines solchen Systems zu finden (dieser Artikel ist einem dieser Werkzeuge gewidmet).  Das zweifelsohne ‚ÄûPlus‚Äú bei der Auswahl einer Spezialisierung auf dem Gebiet der Spracherkennung ist f√ºr mich pers√∂nlich, dass f√ºr die Forschung auf diesem Gebiet sowohl Programmierer- als auch Sprachkenntnisse erforderlich sind.  Dies ist sehr anregend und zwingt dazu, Wissen in verschiedenen Disziplinen zu erwerben. <br><a name="habracut"></a><br><h3>  Warum gibt es Kaldi schlie√ülich andere Rahmenbedingungen f√ºr die Spracherkennung? </h3><br>  Um diese Frage zu beantworten, sollten die vorhandenen Analoga und die von ihnen verwendeten Algorithmen und Technologien ber√ºcksichtigt werden (die in Kaldi verwendeten Algorithmen werden im Artikel weiter beschrieben): <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">CMU Sphinx</a> <br>  CMU Sphinx (nicht zu verwechseln mit der Sphinx-Suchmaschine!) Ist ein Spracherkennungssystem, das von Entwicklern der Carnegie Mellon University entwickelt wurde und aus verschiedenen Modulen zum Extrahieren von Sprachfunktionen, zur Spracherkennung (einschlie√ülich auf Mobilger√§ten) und zum Training f√ºr eine solche Erkennung besteht.  CMU Sphinx verwendet versteckte Markov-Modelle auf der Ebene der akustisch-phonetischen Erkennung und statistische N-Gramm-Modelle auf der Ebene der sprachlichen Erkennung.  Das System verf√ºgt au√üerdem √ºber eine Reihe interessanter Funktionen: Erkennung langer Sprache (z. B. Transkripte oder Tonaufnahmen eines Interviews), Verbindung eines gro√üen W√∂rterbuchs mit Hunderttausenden von Wortformen usw. Es ist wichtig zu beachten, dass sich das System mit jeder Version st√§ndig weiterentwickelt, Erkennungsqualit√§t und Leistung verbessert werden .  Es gibt auch plattform√ºbergreifende und praktische Dokumentation.  Unter den Minuspunkten bei der Verwendung dieses Systems ist es m√∂glich, die Unf√§higkeit, CMU Sphinx "out of the box" zu starten, herauszustellen, weil  Selbst die L√∂sung einfacher Probleme erfordert Kenntnisse √ºber die Anpassung des akustischen Modells, auf dem Gebiet der Sprachmodellierung usw. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Julius</a> <br>  Julius wird seit 1997 von japanischen Entwicklern entwickelt. Jetzt wird das Projekt vom Advanced Science, Technology &amp; Management Research Institute in Kyoto unterst√ºtzt.  Das Modell basiert auf N-Gramm und kontextsensitiven Hidden-Markov-Modellen. Das System kann Sprache in Echtzeit erkennen.  Die Nachteile sind die Verteilung nur f√ºr das japanische Sprachmodell (obwohl es ein VoxForge-Projekt gibt, das akustische Modelle f√ºr andere Sprachen erstellt, insbesondere f√ºr die englische Sprache) und das Fehlen stabiler Aktualisierungen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">RWTH ASR</a> <br>  Das Modell wurde seit 2001 von Spezialisten der Technischen Universit√§t Rhein-Westfalen entwickelt und besteht aus mehreren in C ++ geschriebenen Bibliotheken und Werkzeugen.  Das Projekt umfasst auch Installationsdokumentation, verschiedene Trainingssysteme, Vorlagen, akustische Modelle, Sprachmodelle, Unterst√ºtzung f√ºr neuronale Netze usw. Gleichzeitig ist der RWTH ASR praktisch plattform√ºbergreifend und hat eine niedrige Geschwindigkeit. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Htk</a> <br>  HTK (Hidden Markov Model Toolkit) ist eine Reihe von Spracherkennungswerkzeugen, die 1989 an der Universit√§t Cambridge entwickelt wurden.  Das Toolkit, das auf versteckten Markov-Modellen basiert, wird am h√§ufigsten als zus√§tzliches Tool zum Erstellen von Spracherkennungssystemen verwendet (dieses Framework wird beispielsweise von Julius-Entwicklern verwendet).  Trotz der Tatsache, dass der Quellcode √∂ffentlich verf√ºgbar ist, ist die Verwendung von HTK zum Erstellen von Systemen f√ºr Endbenutzer durch die Lizenz verboten, weshalb das Toolkit derzeit nicht beliebt ist.  Das System hat auch eine relativ niedrige Geschwindigkeit und Genauigkeit. </li></ul><br>  In dem Artikel ‚ÄûVergleichende Analyse von Open-Source-Spracherkennungssystemen‚Äú ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">https://research-journal.org/technical/sravnitelnyj-analiz-sistem-raspoznavaniya-rechi-s-otkrytym-kodom/</a> ) wurde eine Studie durchgef√ºhrt, in der alle durchgef√ºhrt wurden Die Systeme wurden in einem englischsprachigen Fall (160 Stunden) geschult und in einem kleinen 10-Stunden-Testfall angewendet.  Als Ergebnis stellte sich heraus, dass Kaldi die h√∂chste Erkennungsgenauigkeit aufweist und in Bezug auf die Geschwindigkeit etwas schneller als seine Konkurrenten ist.  Das Kaldi-System bietet dem Benutzer au√üerdem die gr√∂√üte Auswahl an Algorithmen f√ºr verschiedene Aufgaben und ist sehr bequem zu bedienen.  Gleichzeitig wird betont, dass die Arbeit mit der Dokumentation f√ºr einen unerfahrenen Benutzer unpraktisch sein kann  Es ist f√ºr Spracherkennungsprofis konzipiert.  Im Allgemeinen eignet sich Kaldi jedoch besser f√ºr die wissenschaftliche Forschung als seine Kollegen. <br><cut></cut><br><h3>  So installieren Sie Kaldi </h3><br><ol><li>  Laden Sie das Archiv aus dem Repository unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">https://github.com/kaldi-asr/kaldi</a> herunter: <br><img src="https://habrastorage.org/webt/2-/2q/wh/2-2qwhrs79zle9ze1jsmqrdeg3k.jpeg"></li><li>  Packen Sie das Archiv aus und gehen Sie zu kaldi-master / tools / extras. </li><li>  Wir f√ºhren ./check_dependencies.sh aus: <br><img src="https://habrastorage.org/webt/hr/nm/ug/hrnmugjo9pswjvy-vnnbz2unasc.png"><br>  Wenn Sie danach nicht "alles in Ordnung" sehen, √∂ffnen Sie die Datei kaldi-master / tools / INSTALL und folgen Sie den Anweisungen dort. </li><li>  Wir f√ºhren make aus (in kaldi-master / tools, nicht in kaldi-master / tools / extras): <br><img src="https://habrastorage.org/webt/pl/6w/qz/pl6wqzcxloc93pat9ddwbvpdd-g.png"></li><li>  Gehe zu kaldi-master / src. </li><li>  Wir f√ºhren ./configure --shared aus, und Sie k√∂nnen die Installation mit oder ohne CUDA-Technologie konfigurieren, indem Sie den Pfad zum installierten CUDA angeben (./configure --cudatk-dir = / usr / local / cuda-8.0) oder den Anfangswert ‚Äûyes‚Äú √§ndern "To" no "(./ configure --use-cuda = no). <br><br>  Wenn Sie gleichzeitig sehen: <br><br><img src="https://habrastorage.org/webt/0o/fo/fk/0ofofk6kgbhousqfpnzagxh5lze.png"><br><br>  Entweder haben Sie Schritt 4 nicht befolgt, oder Sie m√ºssen OpenFst selbst herunterladen und installieren: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">http://www.openfst.org/twiki/bin/view/FST/FstDownload</a> . </li><li>  Wir machen abh√§ngig. </li><li>  Wir f√ºhren make -j aus.  Es wird empfohlen, dass Sie die richtige Anzahl von Prozessorkernen eingeben, die Sie beim Erstellen verwenden, z. B. make -j 2. </li><li>  Als Ergebnis erhalten wir: <br><img src="https://habrastorage.org/webt/h4/bs/zb/h4bszbrxejdjz02pxg7jx110v78.png"></li></ol><cut></cut><br><h3>  Ein Beispiel f√ºr die Verwendung eines Modells mit installiertem Kaldi </h3><br>  Als Beispiel habe ich das kaldi-ru Modell Version 0.6 verwendet. <a href="" rel="nofollow">Sie k√∂nnen es √ºber diesen Link herunterladen</a> : <br><br><ol><li>  Gehen Sie nach dem Herunterladen zur Datei kaldi-ru-0.6 / decode.sh und geben Sie den Pfad zum installierten Kaldi an. F√ºr mich sieht es so aus: <br><br><img src="https://habrastorage.org/webt/g6/a_/ah/g6a_ahhtdnva3mmlhbu5fn7yqii.png"><br></li><li>  Wir starten das Modell und geben die Datei an, in der die Sprache erkannt werden soll.  Sie k√∂nnen die Datei decoder-test.wav verwenden. Dies ist eine spezielle Datei f√ºr den Test. Sie befindet sich bereits in diesem Ordner: <br><br><img src="https://habrastorage.org/webt/gq/er/gt/gqergtoumyqfba4uhvo_j--cydm.png"><br></li><li>  Und hier ist, was das Modell erkannte: <br><img src="https://habrastorage.org/webt/8g/sh/kj/8gshkjtdsxzh_lj8xl7djhoen1k.png"></li></ol><br><h3>  Welche Algorithmen werden verwendet, was liegt der Arbeit zugrunde? </h3><br>  Ausf√ºhrliche Informationen zum Projekt finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">http://kaldi-asr.org/doc/</a> . Hier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">m√∂chte</a> ich einige wichtige Punkte hervorheben: <br><br><ul><li>  Zum Extrahieren akustischer Merkmale aus dem Eingangssignal werden entweder akustische MFCC (Mel-Frequency Cepstral Coefficients) oder etwas weniger beliebte PLPs (Perceptual Linear Prediction - siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">H. Hermansky, ‚ÄûPerceptual Linear Predictive (PLP) -Analyse von Sprache‚Äú</a> ) verwendet.  Bei der ersten Methode wird das Spektrum des urspr√ºnglichen Signals von der Hertz-Skala in die Kreideskala umgewandelt, und dann werden die Cepstralkoeffizienten unter Verwendung der inversen Kosinustransformation (https://habr.com/en/post/140828/) berechnet.  Die zweite Methode basiert auf der Regressionsdarstellung von Sprache: Es wird ein Signalmodell erstellt, das die Vorhersage der aktuellen Signalprobe durch eine lineare Kombination beschreibt - das Produkt bekannter Abtastwerte von Eingangs- und Ausgangssignalen und linearen Vorhersagekoeffizienten.  Die Berechnung der Sprachzeichen reduziert sich unter bestimmten Bedingungen darauf, diese Koeffizienten zu finden. </li><li>  Das akustische Modellierungsmodul umfasst Hidden-Markov-Modelle (HMM), ein Mischungsmodell aus Gau√üschen Verteilungen (GMM), tiefen neuronalen Netzen, n√§mlich Time-Delay Neural Networks (TDNN). </li><li>  Die Sprachmodellierung wird mit einer Finite-State-Maschine oder FST (Finite-State-Transducer) durchgef√ºhrt.  FST codiert eine Zuordnung von einer Eingabezeichenfolge zu einer Ausgabezeichenfolge, und es gibt Gewichte f√ºr den √úbergang, die die Wahrscheinlichkeit der Berechnung des Eingabezeichens in der Ausgabe bestimmen. </li><li>  Die Decodierung erfolgt mit dem Vorw√§rts-R√ºckw√§rts-Algorithmus. </li></ul><br><h3>  Informationen zum Erstellen des Modells kaldi-ru-0.6 </h3><br>  F√ºr die russische Sprache gibt es ein vorab trainiertes Erkennungsmodell, das von Nikolai Shmyryov erstellt wurde und auf vielen Websites und Foren auch als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">nsh bekannt ist</a> . <br><br><ul><li>  Um Merkmale zu extrahieren, wurde die MFCC-Methode verwendet, und das akustisch-phonetische Modell selbst basiert auf neuronalen Netzen vom Typ TDNN. </li><li>  Das Trainingsbeispiel waren die Soundtracks von Videos in russischer Sprache, die von YouTube heruntergeladen wurden. </li><li>  Um ein Sprachmodell zu erstellen, haben wir das CMUdict-W√∂rterbuch und genau das Vokabular verwendet, das im Trainingssatz enthalten war.  Aufgrund der Tatsache, dass das W√∂rterbuch √§hnliche Aussprachen verschiedener W√∂rter enthielt, wurde beschlossen, jedem Wort den Wert ‚ÄûWahrscheinlichkeit‚Äú zuzuweisen und diese zu normalisieren. </li><li>  Um das Sprachmodell zu lernen, wurde das RNNLM-Framework (wiederkehrende Sprachmodelle f√ºr neuronale Netze) verwendet, das, wie der Name schon sagt, auf wiederkehrenden neuronalen Netzen basiert (anstelle der guten alten N-Gramme). </li></ul><br><cut></cut><br><h3>  Vergleich mit Google Speech API und Yandex Speech Kit </h3><br>  Sicherlich hatte einer der Leser beim Lesen der vorherigen Abs√§tze eine Frage: Okay, wir haben herausgefunden, dass Kaldi seinen direkten Kollegen √ºberlegen ist, aber was ist mit Erkennungssystemen von Google und Yandex?  Vielleicht ist die Relevanz der zuvor beschriebenen Frameworks zweifelhaft, ob es Tools dieser beiden Giganten gibt?  Die Frage ist wirklich gut, also lasst uns testen! <br><br><ul><li>  Als Datensatz nehmen wir die Datens√§tze und die entsprechende Textentschl√ºsselung aus dem ber√ºchtigten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">VoxForge</a> .  Nachdem jedes System 3677 Audiodateien erkannt hatte, erhielt ich die folgenden WER-Werte (Word Error Rate): <br><br><img src="https://habrastorage.org/webt/ca/s9/vr/cas9vriacqyf-xrvijr3-dxu3_s.jpeg"><br></li><li>  Die Aufzeichnungen von VoxForge sind ohne Hintergrundger√§usche, Intonation, Sprachgeschwindigkeit usw. ungef√§hr √§hnlich.  Lassen Sie uns die Aufgabe komplizieren: Nehmen Sie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Open_stt-</a> Validierungs-Subkorpus, der Telefonanrufe, YouTube-Audiospuren und H√∂rb√ºcher enth√§lt, und bewerten Sie die Leistung mithilfe von WER und CER (Character Error Rate). <br><br>  Nachdem ich die Textabschriften erhalten hatte, bemerkte ich, dass Google und Yandex (im Gegensatz zu Kaldi) W√∂rter wie erkannten <br>  "Eins" als "1".  Dementsprechend bestand die Notwendigkeit, solche F√§lle zu korrigieren (wie in den von den Autoren von open_stt bereitgestellten Referenzprotokollen wird alles in Briefform dargestellt), was sich auf das Endergebnis auswirkte: <br><br><img src="https://habrastorage.org/webt/1e/si/iw/1esiiwizr_zz5y1p7vdc6ye_ao8.png"><br></li></ul><br>  Zusammenfassend k√∂nnen wir sagen, dass alle Systeme die Aufgabe auf ungef√§hr derselben Ebene bew√§ltigten und Kaldi dem Yandex Speech Kit und der Google Speech API nicht viel unterlegen war.  Im zweiten Fall bietet das Yandex Speech Kit die beste Leistung  Es erkennt am besten kurze Audiodateien im Vergleich zu Mitbewerbern, die keinen Teil davon erkennen konnten (f√ºr Google ist die Anzahl dieser Dateien sogar zu gro√ü).  Schlie√ülich ist anzumerken, dass Kaldi mehr als 12 Stunden gebraucht hat, um 28111 Dateien zu erkennen, andere Systeme, die in viel k√ºrzerer Zeit verwaltet wurden.  Gleichzeitig sind das Yandex Speech Kit und die Google Speech API ‚ÄûBlack Boxes‚Äú, die auf den Servern anderer Personen weit entfernt funktionieren und nicht f√ºr die Optimierung zug√§nglich sind. Kaldi kann jedoch an die Besonderheiten der jeweiligen Aufgabe angepasst werden - charakteristisches Vokabular (Professionalit√§t, Jargon, Umgangssprache), Aussprachemerkmale usw.  Und das alles kostenlos und ohne SMS!  Das System ist eine Art Designer, mit dem wir alle etwas Ungew√∂hnliches und Interessantes schaffen k√∂nnen. <br><br>  Ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">danke</a> dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Yandex.Cloud-</a> Team, das mir bei der Implementierung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">open_stt-</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Fallerkennung</a> geholfen hat. <br><br>  Ich arbeite im Labor APDiMO NSU: <br>  Website: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">https://bigdata.nsu.ru/</a> <br>  VK Group: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">https://vk.com/lapdimo</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de470696/">https://habr.com/ru/post/de470696/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de470684/index.html">Was ist im Lebenslauf zu schreiben, wenn keine Berufserfahrung vorliegt?</a></li>
<li><a href="../de470686/index.html">Technologie f√ºr die Smart City. Wird St. Petersburg die erste Metropole f√ºr Blinde?</a></li>
<li><a href="../de470688/index.html">Was ist √ºber VMworld 2019 bekannt?</a></li>
<li><a href="../de470692/index.html">Wie wir eine neue Rosbank-Website erstellt haben und was daraus wurde</a></li>
<li><a href="../de470694/index.html">Auswahl einer E-Mail-Marketing-Plattform: Was ist f√ºr russische Unternehmen zu beachten?</a></li>
<li><a href="../de470700/index.html">Tischplatte. Metallic Lautlos Ihre</a></li>
<li><a href="../de470706/index.html">Python + Keras + LSTM: Erstellen Sie in einer halben Stunde einen Text√ºbersetzer</a></li>
<li><a href="../de470710/index.html">Maschinelles Lernen f√ºr Ihre Wohnungssuche. Teil 2</a></li>
<li><a href="../de470714/index.html">Wie ich zum Digital Breakthrough Finale kam</a></li>
<li><a href="../de470718/index.html">"Algebraische Effekte" in der menschlichen Sprache</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>