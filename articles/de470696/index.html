<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍⚖️ 👰 👨‍👨‍👦 Warum ist Kaldi gut für die Spracherkennung? (aktualisiert am 25.12.2019) 👵🏼 👌🏾 👰🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Warum interessiere ich mich (und ich hoffe Sie) für Spracherkennung? Erstens ist diese Richtung eine der beliebtesten im Vergleich zu anderen Aufgaben...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Warum ist Kaldi gut für die Spracherkennung? (aktualisiert am 25.12.2019)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470696/"><img src="https://habrastorage.org/webt/u6/kw/t0/u6kwt05e-r1amvb5tgew7dby6fk.jpeg"><br><br>  Warum interessiere ich mich (und ich hoffe Sie) für Spracherkennung?  Erstens ist diese Richtung eine der beliebtesten im Vergleich zu anderen Aufgaben der Computerlinguistik, da die Spracherkennungstechnologie mittlerweile fast überall eingesetzt wird - von der Erkennung eines einfachen Ja / Nein im automatischen Callcenter der Bank bis zur Unterstützung von „Small Talk“ "Smart Column" wie "Alice".  Zweitens ist es für ein Spracherkennungssystem von hoher Qualität erforderlich, die effektivsten Werkzeuge zum Erstellen und Konfigurieren eines solchen Systems zu finden (dieser Artikel ist einem dieser Werkzeuge gewidmet).  Das zweifelsohne „Plus“ bei der Auswahl einer Spezialisierung auf dem Gebiet der Spracherkennung ist für mich persönlich, dass für die Forschung auf diesem Gebiet sowohl Programmierer- als auch Sprachkenntnisse erforderlich sind.  Dies ist sehr anregend und zwingt dazu, Wissen in verschiedenen Disziplinen zu erwerben. <br><a name="habracut"></a><br><h3>  Warum gibt es Kaldi schließlich andere Rahmenbedingungen für die Spracherkennung? </h3><br>  Um diese Frage zu beantworten, sollten die vorhandenen Analoga und die von ihnen verwendeten Algorithmen und Technologien berücksichtigt werden (die in Kaldi verwendeten Algorithmen werden im Artikel weiter beschrieben): <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">CMU Sphinx</a> <br>  CMU Sphinx (nicht zu verwechseln mit der Sphinx-Suchmaschine!) Ist ein Spracherkennungssystem, das von Entwicklern der Carnegie Mellon University entwickelt wurde und aus verschiedenen Modulen zum Extrahieren von Sprachfunktionen, zur Spracherkennung (einschließlich auf Mobilgeräten) und zum Training für eine solche Erkennung besteht.  CMU Sphinx verwendet versteckte Markov-Modelle auf der Ebene der akustisch-phonetischen Erkennung und statistische N-Gramm-Modelle auf der Ebene der sprachlichen Erkennung.  Das System verfügt außerdem über eine Reihe interessanter Funktionen: Erkennung langer Sprache (z. B. Transkripte oder Tonaufnahmen eines Interviews), Verbindung eines großen Wörterbuchs mit Hunderttausenden von Wortformen usw. Es ist wichtig zu beachten, dass sich das System mit jeder Version ständig weiterentwickelt, Erkennungsqualität und Leistung verbessert werden .  Es gibt auch plattformübergreifende und praktische Dokumentation.  Unter den Minuspunkten bei der Verwendung dieses Systems ist es möglich, die Unfähigkeit, CMU Sphinx "out of the box" zu starten, herauszustellen, weil  Selbst die Lösung einfacher Probleme erfordert Kenntnisse über die Anpassung des akustischen Modells, auf dem Gebiet der Sprachmodellierung usw. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Julius</a> <br>  Julius wird seit 1997 von japanischen Entwicklern entwickelt. Jetzt wird das Projekt vom Advanced Science, Technology &amp; Management Research Institute in Kyoto unterstützt.  Das Modell basiert auf N-Gramm und kontextsensitiven Hidden-Markov-Modellen. Das System kann Sprache in Echtzeit erkennen.  Die Nachteile sind die Verteilung nur für das japanische Sprachmodell (obwohl es ein VoxForge-Projekt gibt, das akustische Modelle für andere Sprachen erstellt, insbesondere für die englische Sprache) und das Fehlen stabiler Aktualisierungen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">RWTH ASR</a> <br>  Das Modell wurde seit 2001 von Spezialisten der Technischen Universität Rhein-Westfalen entwickelt und besteht aus mehreren in C ++ geschriebenen Bibliotheken und Werkzeugen.  Das Projekt umfasst auch Installationsdokumentation, verschiedene Trainingssysteme, Vorlagen, akustische Modelle, Sprachmodelle, Unterstützung für neuronale Netze usw. Gleichzeitig ist der RWTH ASR praktisch plattformübergreifend und hat eine niedrige Geschwindigkeit. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Htk</a> <br>  HTK (Hidden Markov Model Toolkit) ist eine Reihe von Spracherkennungswerkzeugen, die 1989 an der Universität Cambridge entwickelt wurden.  Das Toolkit, das auf versteckten Markov-Modellen basiert, wird am häufigsten als zusätzliches Tool zum Erstellen von Spracherkennungssystemen verwendet (dieses Framework wird beispielsweise von Julius-Entwicklern verwendet).  Trotz der Tatsache, dass der Quellcode öffentlich verfügbar ist, ist die Verwendung von HTK zum Erstellen von Systemen für Endbenutzer durch die Lizenz verboten, weshalb das Toolkit derzeit nicht beliebt ist.  Das System hat auch eine relativ niedrige Geschwindigkeit und Genauigkeit. </li></ul><br>  In dem Artikel „Vergleichende Analyse von Open-Source-Spracherkennungssystemen“ ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">https://research-journal.org/technical/sravnitelnyj-analiz-sistem-raspoznavaniya-rechi-s-otkrytym-kodom/</a> ) wurde eine Studie durchgeführt, in der alle durchgeführt wurden Die Systeme wurden in einem englischsprachigen Fall (160 Stunden) geschult und in einem kleinen 10-Stunden-Testfall angewendet.  Als Ergebnis stellte sich heraus, dass Kaldi die höchste Erkennungsgenauigkeit aufweist und in Bezug auf die Geschwindigkeit etwas schneller als seine Konkurrenten ist.  Das Kaldi-System bietet dem Benutzer außerdem die größte Auswahl an Algorithmen für verschiedene Aufgaben und ist sehr bequem zu bedienen.  Gleichzeitig wird betont, dass die Arbeit mit der Dokumentation für einen unerfahrenen Benutzer unpraktisch sein kann  Es ist für Spracherkennungsprofis konzipiert.  Im Allgemeinen eignet sich Kaldi jedoch besser für die wissenschaftliche Forschung als seine Kollegen. <br><cut></cut><br><h3>  So installieren Sie Kaldi </h3><br><ol><li>  Laden Sie das Archiv aus dem Repository unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">https://github.com/kaldi-asr/kaldi</a> herunter: <br><img src="https://habrastorage.org/webt/2-/2q/wh/2-2qwhrs79zle9ze1jsmqrdeg3k.jpeg"></li><li>  Packen Sie das Archiv aus und gehen Sie zu kaldi-master / tools / extras. </li><li>  Wir führen ./check_dependencies.sh aus: <br><img src="https://habrastorage.org/webt/hr/nm/ug/hrnmugjo9pswjvy-vnnbz2unasc.png"><br>  Wenn Sie danach nicht "alles in Ordnung" sehen, öffnen Sie die Datei kaldi-master / tools / INSTALL und folgen Sie den Anweisungen dort. </li><li>  Wir führen make aus (in kaldi-master / tools, nicht in kaldi-master / tools / extras): <br><img src="https://habrastorage.org/webt/pl/6w/qz/pl6wqzcxloc93pat9ddwbvpdd-g.png"></li><li>  Gehe zu kaldi-master / src. </li><li>  Wir führen ./configure --shared aus, und Sie können die Installation mit oder ohne CUDA-Technologie konfigurieren, indem Sie den Pfad zum installierten CUDA angeben (./configure --cudatk-dir = / usr / local / cuda-8.0) oder den Anfangswert „yes“ ändern "To" no "(./ configure --use-cuda = no). <br><br>  Wenn Sie gleichzeitig sehen: <br><br><img src="https://habrastorage.org/webt/0o/fo/fk/0ofofk6kgbhousqfpnzagxh5lze.png"><br><br>  Entweder haben Sie Schritt 4 nicht befolgt, oder Sie müssen OpenFst selbst herunterladen und installieren: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">http://www.openfst.org/twiki/bin/view/FST/FstDownload</a> . </li><li>  Wir machen abhängig. </li><li>  Wir führen make -j aus.  Es wird empfohlen, dass Sie die richtige Anzahl von Prozessorkernen eingeben, die Sie beim Erstellen verwenden, z. B. make -j 2. </li><li>  Als Ergebnis erhalten wir: <br><img src="https://habrastorage.org/webt/h4/bs/zb/h4bszbrxejdjz02pxg7jx110v78.png"></li></ol><cut></cut><br><h3>  Ein Beispiel für die Verwendung eines Modells mit installiertem Kaldi </h3><br>  Als Beispiel habe ich das kaldi-ru Modell Version 0.6 verwendet. <a href="" rel="nofollow">Sie können es über diesen Link herunterladen</a> : <br><br><ol><li>  Gehen Sie nach dem Herunterladen zur Datei kaldi-ru-0.6 / decode.sh und geben Sie den Pfad zum installierten Kaldi an. Für mich sieht es so aus: <br><br><img src="https://habrastorage.org/webt/g6/a_/ah/g6a_ahhtdnva3mmlhbu5fn7yqii.png"><br></li><li>  Wir starten das Modell und geben die Datei an, in der die Sprache erkannt werden soll.  Sie können die Datei decoder-test.wav verwenden. Dies ist eine spezielle Datei für den Test. Sie befindet sich bereits in diesem Ordner: <br><br><img src="https://habrastorage.org/webt/gq/er/gt/gqergtoumyqfba4uhvo_j--cydm.png"><br></li><li>  Und hier ist, was das Modell erkannte: <br><img src="https://habrastorage.org/webt/8g/sh/kj/8gshkjtdsxzh_lj8xl7djhoen1k.png"></li></ol><br><h3>  Welche Algorithmen werden verwendet, was liegt der Arbeit zugrunde? </h3><br>  Ausführliche Informationen zum Projekt finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">http://kaldi-asr.org/doc/</a> . Hier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">möchte</a> ich einige wichtige Punkte hervorheben: <br><br><ul><li>  Zum Extrahieren akustischer Merkmale aus dem Eingangssignal werden entweder akustische MFCC (Mel-Frequency Cepstral Coefficients) oder etwas weniger beliebte PLPs (Perceptual Linear Prediction - siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">H. Hermansky, „Perceptual Linear Predictive (PLP) -Analyse von Sprache“</a> ) verwendet.  Bei der ersten Methode wird das Spektrum des ursprünglichen Signals von der Hertz-Skala in die Kreideskala umgewandelt, und dann werden die Cepstralkoeffizienten unter Verwendung der inversen Kosinustransformation (https://habr.com/en/post/140828/) berechnet.  Die zweite Methode basiert auf der Regressionsdarstellung von Sprache: Es wird ein Signalmodell erstellt, das die Vorhersage der aktuellen Signalprobe durch eine lineare Kombination beschreibt - das Produkt bekannter Abtastwerte von Eingangs- und Ausgangssignalen und linearen Vorhersagekoeffizienten.  Die Berechnung der Sprachzeichen reduziert sich unter bestimmten Bedingungen darauf, diese Koeffizienten zu finden. </li><li>  Das akustische Modellierungsmodul umfasst Hidden-Markov-Modelle (HMM), ein Mischungsmodell aus Gaußschen Verteilungen (GMM), tiefen neuronalen Netzen, nämlich Time-Delay Neural Networks (TDNN). </li><li>  Die Sprachmodellierung wird mit einer Finite-State-Maschine oder FST (Finite-State-Transducer) durchgeführt.  FST codiert eine Zuordnung von einer Eingabezeichenfolge zu einer Ausgabezeichenfolge, und es gibt Gewichte für den Übergang, die die Wahrscheinlichkeit der Berechnung des Eingabezeichens in der Ausgabe bestimmen. </li><li>  Die Decodierung erfolgt mit dem Vorwärts-Rückwärts-Algorithmus. </li></ul><br><h3>  Informationen zum Erstellen des Modells kaldi-ru-0.6 </h3><br>  Für die russische Sprache gibt es ein vorab trainiertes Erkennungsmodell, das von Nikolai Shmyryov erstellt wurde und auf vielen Websites und Foren auch als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">nsh bekannt ist</a> . <br><br><ul><li>  Um Merkmale zu extrahieren, wurde die MFCC-Methode verwendet, und das akustisch-phonetische Modell selbst basiert auf neuronalen Netzen vom Typ TDNN. </li><li>  Das Trainingsbeispiel waren die Soundtracks von Videos in russischer Sprache, die von YouTube heruntergeladen wurden. </li><li>  Um ein Sprachmodell zu erstellen, haben wir das CMUdict-Wörterbuch und genau das Vokabular verwendet, das im Trainingssatz enthalten war.  Aufgrund der Tatsache, dass das Wörterbuch ähnliche Aussprachen verschiedener Wörter enthielt, wurde beschlossen, jedem Wort den Wert „Wahrscheinlichkeit“ zuzuweisen und diese zu normalisieren. </li><li>  Um das Sprachmodell zu lernen, wurde das RNNLM-Framework (wiederkehrende Sprachmodelle für neuronale Netze) verwendet, das, wie der Name schon sagt, auf wiederkehrenden neuronalen Netzen basiert (anstelle der guten alten N-Gramme). </li></ul><br><cut></cut><br><h3>  Vergleich mit Google Speech API und Yandex Speech Kit </h3><br>  Sicherlich hatte einer der Leser beim Lesen der vorherigen Absätze eine Frage: Okay, wir haben herausgefunden, dass Kaldi seinen direkten Kollegen überlegen ist, aber was ist mit Erkennungssystemen von Google und Yandex?  Vielleicht ist die Relevanz der zuvor beschriebenen Frameworks zweifelhaft, ob es Tools dieser beiden Giganten gibt?  Die Frage ist wirklich gut, also lasst uns testen! <br><br><ul><li>  Als Datensatz nehmen wir die Datensätze und die entsprechende Textentschlüsselung aus dem berüchtigten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">VoxForge</a> .  Nachdem jedes System 3677 Audiodateien erkannt hatte, erhielt ich die folgenden WER-Werte (Word Error Rate): <br><br><img src="https://habrastorage.org/webt/ca/s9/vr/cas9vriacqyf-xrvijr3-dxu3_s.jpeg"><br></li><li>  Die Aufzeichnungen von VoxForge sind ohne Hintergrundgeräusche, Intonation, Sprachgeschwindigkeit usw. ungefähr ähnlich.  Lassen Sie uns die Aufgabe komplizieren: Nehmen Sie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Open_stt-</a> Validierungs-Subkorpus, der Telefonanrufe, YouTube-Audiospuren und Hörbücher enthält, und bewerten Sie die Leistung mithilfe von WER und CER (Character Error Rate). <br><br>  Nachdem ich die Textabschriften erhalten hatte, bemerkte ich, dass Google und Yandex (im Gegensatz zu Kaldi) Wörter wie erkannten <br>  "Eins" als "1".  Dementsprechend bestand die Notwendigkeit, solche Fälle zu korrigieren (wie in den von den Autoren von open_stt bereitgestellten Referenzprotokollen wird alles in Briefform dargestellt), was sich auf das Endergebnis auswirkte: <br><br><img src="https://habrastorage.org/webt/1e/si/iw/1esiiwizr_zz5y1p7vdc6ye_ao8.png"><br></li></ul><br>  Zusammenfassend können wir sagen, dass alle Systeme die Aufgabe auf ungefähr derselben Ebene bewältigten und Kaldi dem Yandex Speech Kit und der Google Speech API nicht viel unterlegen war.  Im zweiten Fall bietet das Yandex Speech Kit die beste Leistung  Es erkennt am besten kurze Audiodateien im Vergleich zu Mitbewerbern, die keinen Teil davon erkennen konnten (für Google ist die Anzahl dieser Dateien sogar zu groß).  Schließlich ist anzumerken, dass Kaldi mehr als 12 Stunden gebraucht hat, um 28111 Dateien zu erkennen, andere Systeme, die in viel kürzerer Zeit verwaltet wurden.  Gleichzeitig sind das Yandex Speech Kit und die Google Speech API „Black Boxes“, die auf den Servern anderer Personen weit entfernt funktionieren und nicht für die Optimierung zugänglich sind. Kaldi kann jedoch an die Besonderheiten der jeweiligen Aufgabe angepasst werden - charakteristisches Vokabular (Professionalität, Jargon, Umgangssprache), Aussprachemerkmale usw.  Und das alles kostenlos und ohne SMS!  Das System ist eine Art Designer, mit dem wir alle etwas Ungewöhnliches und Interessantes schaffen können. <br><br>  Ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">danke</a> dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Yandex.Cloud-</a> Team, das mir bei der Implementierung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">open_stt-</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Fallerkennung</a> geholfen hat. <br><br>  Ich arbeite im Labor APDiMO NSU: <br>  Website: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">https://bigdata.nsu.ru/</a> <br>  VK Group: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">https://vk.com/lapdimo</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de470696/">https://habr.com/ru/post/de470696/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de470684/index.html">Was ist im Lebenslauf zu schreiben, wenn keine Berufserfahrung vorliegt?</a></li>
<li><a href="../de470686/index.html">Technologie für die Smart City. Wird St. Petersburg die erste Metropole für Blinde?</a></li>
<li><a href="../de470688/index.html">Was ist über VMworld 2019 bekannt?</a></li>
<li><a href="../de470692/index.html">Wie wir eine neue Rosbank-Website erstellt haben und was daraus wurde</a></li>
<li><a href="../de470694/index.html">Auswahl einer E-Mail-Marketing-Plattform: Was ist für russische Unternehmen zu beachten?</a></li>
<li><a href="../de470700/index.html">Tischplatte. Metallic Lautlos Ihre</a></li>
<li><a href="../de470706/index.html">Python + Keras + LSTM: Erstellen Sie in einer halben Stunde einen Textübersetzer</a></li>
<li><a href="../de470710/index.html">Maschinelles Lernen für Ihre Wohnungssuche. Teil 2</a></li>
<li><a href="../de470714/index.html">Wie ich zum Digital Breakthrough Finale kam</a></li>
<li><a href="../de470718/index.html">"Algebraische Effekte" in der menschlichen Sprache</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>