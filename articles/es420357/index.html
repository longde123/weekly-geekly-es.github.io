<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÄ ü•Ñ ‚úãüèø Vuex: estructurando grandes proyectos y trabajando con m√≥dulos ü§û üéÑ ü§û</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vuex es una biblioteca de administraci√≥n de estado de aplicaci√≥n oficial y bien documentada dise√±ada espec√≠ficamente para Vue.js. El autor del materia...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vuex: estructurando grandes proyectos y trabajando con m√≥dulos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/420357/">  Vuex es una biblioteca de administraci√≥n de estado de aplicaci√≥n oficial y bien documentada dise√±ada espec√≠ficamente para Vue.js.  El autor del material, cuya traducci√≥n publicamos hoy, cree que usar esta biblioteca es mucho m√°s agradable que Redux, porque, en primer lugar, Vuex requiere menos c√≥digo repetitivo y, en segundo lugar, porque funciona con mecanismos asincr√≥nicos, no se necesitan bibliotecas adicionales aqu√≠.  Adem√°s, dado que la biblioteca Vuex fue creada por el mismo equipo que est√° trabajando en Vue, esta biblioteca se integra muy bien con este marco.  Desafortunadamente, al trabajar con Vuex a√∫n puede encontrar una dificultad, que consiste en preparar adecuadamente la estructura de los proyectos en los que planea utilizar esta biblioteca. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/lh/pj/o0/lhpjo0basq6-ilsaqqoua0ajpbi.jpeg"></a> <br><br>  En este art√≠culo encontrar√° una descripci√≥n de la metodolog√≠a para estructurar grandes proyectos utilizando Vuex, y un script dise√±ado para automatizar el proceso de creaci√≥n de m√≥dulos Vuex. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Vue-enterprise-boilerplate patr√≥n y problema de estructura del proyecto</font> </h2><br>  Uno de los desarrolladores de Vue, Chris Fritz, cre√≥ una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">plantilla</a> excelente para Vue, la estructura del proyecto presentada en la cual est√° dise√±ada para usar Vuex.  En particular, esta plantilla permite que Vuex registre autom√°ticamente m√≥dulos basados ‚Äã‚Äãen los archivos en la carpeta de <code>modules</code> .  La estructura de carpetas del proyecto puede parecerse a la siguiente figura. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ce/603/64f/8ce60364f855dbf775de3171ca2cf981.png"></div><br>  <i><font color="#999999">Estructura del proyecto y colocaci√≥n de c√≥digo inconveniente</font></i> <br><br>  Al usar esta plantilla, es necesario que el estado, captadores, acciones y mutaciones est√©n en el mismo archivo.  Personalmente, prefiero guardarlos en archivos separados, lo que permite, dado el hecho de que los m√≥dulos Vuex a veces son bastante grandes, es conveniente navegar por los programas, sin tener que desplazarse a trav√©s de grandes fragmentos de c√≥digo.  Siguiendo esta idea, cambiaremos el c√≥digo de la plantilla para que lo que se relaciona con m√≥dulos individuales se pueda clasificar en carpetas destinadas a estos m√≥dulos.  Es decir, la estructura del proyecto cambiar√° y ser√° similar a la que se muestra a continuaci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3cc/366/02b/3cc36602bdf8225aa8bf20db963973d9.png"></div><br>  <i><font color="#999999">La estructura del proyecto con el desglose de los materiales de los m√≥dulos en archivos separados que se encuentran en las carpetas de los m√≥dulos.</font></i> <br><br><h2>  <font color="#3AC1EF">Desarrollo de una plantilla que soporte una estructura de proyecto conveniente.</font> </h2><br>  Entonces, vamos a organizar el trabajo con Vuex para que podamos usar estructuras de carpetas y archivos similares a las mostradas en la figura anterior en nuestros proyectos.  Para hacer esto, primero cree un nuevo proyecto usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Vue CLI 3</a> . <br><br>  Despu√©s de tener una plantilla de proyecto lista para seguir trabajando con ella, instale Vuex y Lodash ejecutando el <code>npm install vuex lodash -save</code> en el terminal.  Para trabajar con m√≥dulos, necesitamos la funci√≥n <code>camelCase</code> de Lodash, que est√° dise√±ada para convertir cadenas al estilo camel. <br><br>  Ahora cree una carpeta y una estructura de archivo similar a la que se muestra en la figura anterior. <br><br>  Comencemos con el archivo <code>store.js</code> .  Aqu√≠ est√° su c√≥digo: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Vue <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vue'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Vuex <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vuex'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> modules <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./modules'</span></span> Vue.use(Vuex) const store = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Vuex.Store({ modules, <span class="hljs-keyword"><span class="hljs-keyword">strict</span></span>: process.env.NODE_ENV !== <span class="hljs-string"><span class="hljs-string">'production'</span></span> }) //    `init`     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (const moduleName <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.keys(modules)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (modules[moduleName].actions.init) {   store.dispatch(`${moduleName}/init`) } } export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> store</code> </pre> <br>  Vue y Vuex se importan aqu√≠, ya que no podemos prescindir de ellos.  Adem√°s, importamos m√≥dulos desde <code>/modules/index.js</code> .  A continuaci√≥n, inicializamos el almacenamiento y recorremos todos los m√≥dulos.  Si el m√≥dulo tiene una acci√≥n <code>init</code> , inicializamos el m√≥dulo.  Esto resulta ser muy √∫til para aquellos m√≥dulos que deben inicializarse cuando se inicia la aplicaci√≥n.  Como resultado, por supuesto, exportamos la <code>store</code> , despu√©s de lo cual, generalmente, se importa al archivo <code>main.js</code> y se agrega a la instancia de Vue. <br><br>  Ahora es el momento de trabajar con el archivo <code>index.js</code> , que se encuentra en la carpeta <code>/store/modules</code> . <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    Vuex     ,    . <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> camelCase <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lodash/camelCase'</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    const requireModule = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>.context( <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      <span class="hljs-string"><span class="hljs-string">'.'</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   index.js,    ,    <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-string"><span class="hljs-string">'actions'</span></span>, <span class="hljs-string"><span class="hljs-string">'mutations'</span></span>,  <span class="hljs-string"><span class="hljs-string">'getters'</span></span> . <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,      .js <span class="hljs-regexp"><span class="hljs-regexp">/^(?!.*(actions|mutations|getters|index)).*\.js$/</span></span> ); const modules = {}; requireModule.keys().forEach(fileName =&gt; { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-regexp"><span class="hljs-regexp">/\.unit\.js$/</span></span>.test(fileName)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>            modules[camelCase(fileName.split(<span class="hljs-string"><span class="hljs-string">'/'</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>].replace(<span class="hljs-regexp"><span class="hljs-regexp">/(\.\/|\.js)/g</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>))] = {   namespaced: <span class="hljs-literal"><span class="hljs-literal">true</span></span>,   ...requireModule(fileName).<span class="hljs-keyword"><span class="hljs-keyword">default</span></span> }; }); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> modules;</code> </pre> <br>  En este c√≥digo, primero importamos la funci√≥n camelCase de Lodash.  Luego usamos el m√©todo <code>require.context</code> para conectar los m√≥dulos.  Como tercer par√°metro, pasamos una expresi√≥n regular que filtrar√° el archivo <code>index.js</code> , as√≠ como los archivos cuyos nombres contienen las <code>actions</code> l√≠neas, <code>mutations</code> y <code>getters</code> .  Se importar√°n al archivo de estado, por ejemplo, en <code>auth.js</code> , y luego se exportar√°n.  Por ejemplo, as√≠ es como <code>auth.js</code> archivo <code>auth.js</code> carpeta <code>src/store/modules/auth/</code> al comienzo del trabajo: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> actions <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./actions'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mutations <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./mutations'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> getters <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./getters'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> state = {   <span class="hljs-attr"><span class="hljs-attr">user</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> {   state,   mutations,   getters,   actions };</code> </pre> <br>  Ahora solo queda pasar por todos los m√≥dulos y formar un solo objeto con todos ellos.  Aqu√≠ debe excluir todos los archivos en cuyo nombre hay una <code>unit</code> l√≠nea, ya que son necesarios solo para pruebas y no para desarrollo o para implementar un proyecto en producci√≥n.  Despu√©s de eso, agregamos una nueva propiedad al objeto de <code>modules</code> , que tendr√° el nombre del archivo de estado, por ejemplo, <code>auth</code> o <code>users</code> .  Adem√°s, utilizamos la funci√≥n <code>camelCase</code> para hacer que los nombres de propiedades se vean consistentes.  Luego <code>requireModule</code> el objeto de <code>modules</code> , <code>requireModule</code> trav√©s del <code>requireModule</code> y usando la <code>...requireModule(fileName).default</code> , y luego exportamos los <code>modules</code> . <br><br>  De hecho, as√≠ es como un proyecto puede estructurarse en qu√© estado, captadores, acciones y mutaciones se almacenan por separado y se organizan convenientemente.  Ahora hablemos sobre c√≥mo escribir un script para crear autom√°ticamente m√≥dulos Vuex. <br><br><h2>  <font color="#3AC1EF">Script para crear autom√°ticamente m√≥dulos Vuex</font> </h2><br>  Cree una nueva carpeta en la carpeta del proyecto con los <code>scripts</code> nombre, en ella cree el archivo <code>generateVuexModule.js</code> .  Para este proyecto necesitaremos Node.js, por lo tanto, si no tiene esta plataforma instalada, ahora es el momento de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">solucionarlo</a> .  Nuestro script tiene una sola dependencia: el paquete de <code>chalk</code> , que se utiliza para dise√±ar materiales que se muestran en la consola.  Puede instalar este paquete con el <code>npm install -save-dev chalk</code> . <br><br><h3>  <font color="#3AC1EF">‚ñçPaso 1</font> </h3><br>  En el archivo <code>generateVuexModule.js</code> , debe conectar tres m√≥dulos: <code>fs</code> , <code>path</code> y <code>chalk</code> .  Tambi√©n aqu√≠ necesita una constante con la ruta a la carpeta de m√≥dulos ( <code>src/store/modules</code> ) y otra constante - <code>args</code> , que har√° que los argumentos pasen al script cuando se ejecut√≥. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> chalk = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'chalk'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> modulesPath = <span class="hljs-string"><span class="hljs-string">'src/store/modules'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> args = process.argv.slice(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> error = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chalk.red(...args)); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> success = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chalk.green(...args)); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!args.length) { error(<span class="hljs-string"><span class="hljs-string">'You must provide a name for the module!'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br>  Como puede ver, escribimos todos los argumentos en los argumentos excepto los dos primeros, ya que representan la ruta a <code>node.exe</code> y el archivo de script, y no necesitamos esta informaci√≥n.  Solo nos interesa el tercer par√°metro: el nombre del nuevo m√≥dulo.  Adem√°s, hay un par de funciones, <code>error</code> y <code>success</code> , que utilizan el paquete de <code>chalk</code> antes mencionado para mostrar mensajes con textos de diferentes colores. <br><br>  Aqu√≠ debe verificar la longitud de la matriz <code>args</code> para saber si el nombre del m√≥dulo se pasa a nuestro script y, si no es as√≠, dar un mensaje de error.  Por lo tanto, si intenta ejecutar este script usando el comando <code>node generateVuexModule.js</code> del <code>node generateVuexModule.js</code> , sin pasarle nada m√°s, ver√° un mensaje de error en el terminal. <br><br><h3>  <font color="#3AC1EF">‚ñçPaso 2</font> </h3><br>  En este punto, tenemos un nombre para el m√≥dulo y la ruta dada por la constante <code>modulesPath</code> .  Sin embargo, todav√≠a tenemos que trabajar con estos datos.  Es decir, extraiga el nombre de la matriz de <code>args</code> y recopile la ruta completa al m√≥dulo, sin mencionar la formaci√≥n de su contenido. <br><br><pre> <code class="hljs pgsql">const moduleName = args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; const modulePath = <span class="hljs-type"><span class="hljs-type">path</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(__dirname, <span class="hljs-string"><span class="hljs-string">'../'</span></span>, modulesPath, moduleName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fs.existsSync(modulePath)) { error(`${moduleName} directory already <span class="hljs-keyword"><span class="hljs-keyword">exists</span></span>!`); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } const stateContent = `<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> getters <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./getters'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> actions <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./actions'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mutations <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./mutations'</span></span>; const state = {}; export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { state, getters, actions, mutations }; `; const exportFileContent = `<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">types</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@/store/types'</span></span>; export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { }; `;</code> </pre> <br>  El nombre del m√≥dulo estar√° en el elemento de la matriz de <code>args</code> con √≠ndice 0. En esta etapa del programa, podemos contar con la presencia de este elemento, ya que previamente intentamos extraerlo de <code>process.argv</code> , y luego verificamos la longitud de la matriz de <code>args</code> .  Adem√°s, preparamos la ruta completa utilizando el m√≥dulo de <code>path</code> y el m√©todo de <code>join</code> .  Obtuvimos el directorio actual usando la construcci√≥n <code>__dirname</code> , <code>__dirname</code> un nivel, ya que el archivo <code>generateVuexModule.js</code> se encuentra en la carpeta del proyecto de <code>scripts</code> .  Luego simplemente agregamos al resultado, el contenido de la <code>modulesPath</code> constante y el nombre del m√≥dulo.  En este punto, la constante <code>modulePath</code> debe contener algo como <code>pathToYourProject/project/src/store/modules/moduleName</code> .  Aqu√≠ es donde se crear√° el m√≥dulo.  Ahora, dado que tenemos la ruta completa, podemos verificar si este directorio existe.  No quisi√©ramos sobrescribir accidentalmente los archivos de un m√≥dulo existente.  Como resultado, si el directorio en el que planea crear un nuevo m√≥dulo existe, mostraremos un mensaje de error en letras rojas, gracias a <code>chalk</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/92c/7e1/bc7/92c7e1bc7826ddc9f300393109b247f4.png"></div><br>  <i><font color="#999999">Ejemplo de mensaje de error</font></i> <br><br>  A continuaci√≥n, debe crear constantes en las que habr√° datos para los archivos.  Como puede imaginar, <code>stateContent</code> usa para el archivo de estado, es decir, por ejemplo, para <code>auth.js</code> , y <code>exportFileContent</code> se usa para <code>getters.js</code> , <code>getters.js</code> y <code>mutations.js</code> .  Si es necesario, puede agregar a esta lista todo lo que se requiere en su proyecto. <br><br><h3>  <font color="#3AC1EF">‚ñçPaso 3</font> </h3><br>  Ahora solo tenemos que crear rutas para los archivos del m√≥dulo y crearlas. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> statePath = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${path.join(modulePath, </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">`</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${moduleName}</span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">.js`</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> gettersPath = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${path.join(modulePath, </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'getters.js'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> actionsPath = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${path.join(modulePath, </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'actions.js'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mutationsPath = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${path.join(modulePath, </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'mutations.js'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">`</span></span> fs.mkdirSync(modulePath); fs.appendFileSync(statePath, stateContent); fs.appendFileSync(gettersPath, exportFileContent); fs.appendFileSync(actionsPath, exportFileContent); fs.appendFileSync(mutationsPath, exportFileContent); success(<span class="hljs-string"><span class="hljs-string">'Module'</span></span>, moduleName, <span class="hljs-string"><span class="hljs-string">'generated!'</span></span>);</code> </pre> <br>  Primero declaramos cuatro constantes, cada una de las cuales contiene una ruta para el archivo correspondiente.  A continuaci√≥n, necesitamos crear una carpeta para el m√≥dulo.  Ya verificamos si existe dicha carpeta y le dimos un error si es as√≠.  Por lo tanto, no deber√≠a haber problemas con la creaci√≥n de una carpeta.  Y finalmente, usamos los <code>fs.appendFileSync</code> , colocando los nuevos archivos con los contenidos especificados en el proceso de creaci√≥n en el directorio reci√©n creado.  Al final, el script muestra un mensaje sobre la finalizaci√≥n exitosa de la operaci√≥n. <br><br>  Para usar este script, simplemente vaya a la carpeta de <code>scripts</code> de su proyecto en la terminal y ejecute un comando del <code>node generateVuexModule.js yourModuleName</code> formulario <code>node generateVuexModule.js yourModuleName</code> .  Despu√©s de completar con √©xito el script, ver√° un mensaje sobre la creaci√≥n de un m√≥dulo. <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  Despu√©s de revisar este material, aprendi√≥ sobre una plantilla para estructurar proyectos grandes donde planea usar Vuex, y un script que simplifica la creaci√≥n de m√≥dulos Vuex.  Esperamos que encuentre √∫til este conocimiento.  El c√≥digo del proyecto, cuyos ejemplos examinamos, se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br>  <b>Estimados lectores!</b>  ¬øC√≥mo estructuran las grandes aplicaciones de Vue que usan Vuex? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es420357/">https://habr.com/ru/post/es420357/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es420347/index.html">Aprende a crear tus propios comandos bash en menos de 4 minutos</a></li>
<li><a href="../es420349/index.html">Lista de verificaci√≥n de outsourcing de TI: trabajar sin riesgos</a></li>
<li><a href="../es420351/index.html">C√≥mo hacer b√∫squedas de usuarios en GitHub usando Vue</a></li>
<li><a href="../es420353/index.html">Hacemos que Shrimp sea a√∫n m√°s √∫til: agregue la transcodificaci√≥n de im√°genes a otros formatos</a></li>
<li><a href="../es420355/index.html">Reloj inteligente Pebble: c√≥mo convertirse en una rareza de la noche a la ma√±ana</a></li>
<li><a href="../es420359/index.html">Var, let o const? Problemas de alcance variable y ES6</a></li>
<li><a href="../es420361/index.html">Error al ejecutar TextBox.GetLineText en .NET WPF</a></li>
<li><a href="../es420363/index.html">Seminarios web de HPE en agosto-octubre: nuevos temas (+ SHD, pr√°ctica de IA, almacenamiento de petabytes llave en mano)</a></li>
<li><a href="../es420367/index.html">Apocalipsis con aire acondicionado: escenario de apag√≥n de red inteligente</a></li>
<li><a href="../es420369/index.html">Extreme Extended Edge, o IEEE 802.1BR Switching</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>