<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçüíª üö∂üèº üíù Reverse USB-SATA Adapter (Verlauf eines Praktikanten) üíí üòì üî•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hintergrund 


 Praktikum ist der Prozess des Wissens- und Erfahrungserwerbs. Unser Raccoon Security-Team ist der Ansicht, dass eine Verbesserung der ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reverse USB-SATA Adapter (Verlauf eines Praktikanten)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ntc-vulkan/blog/485966/"><h1 id="predystoriya">  Hintergrund </h1><br><p>  Praktikum ist der Prozess des Wissens- und Erfahrungserwerbs.  Unser Raccoon Security-Team ist der Ansicht, dass eine Verbesserung der Informationssicherheit von Ger√§ten und Software in unserer Umgebung nicht m√∂glich ist, ohne dieses Wissen und diese Erfahrung an zuk√ºnftige Generationen von Spezialisten weiterzugeben.  Deshalb organisieren wir seit vielen Jahren individuelle Praktika f√ºr talentierte Studenten und Absolventen. </p><br><p>  Sicherheitsforschung ist eine F√§higkeit, die an der Universit√§t nicht gelehrt wird.  Sie k√∂nnen es anhand konkreter Beispiele und unter Anleitung erfahrener Mentoren lernen.  Jedes Jahr l√∂sen unsere Praktikanten komplexe technische Probleme, erreichen ihre Ziele und gehen weiter, erweitern ihren beruflichen Horizont und machen die Welt ein wenig sicherer.  Jeder von ihnen hat seine eigene Geschichte, Spezialist zu werden, und das unter dem Strich - der Anfang von einem von ihnen. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/eu/dr/h-/eudrh-mevrjhfjo4jfjouffyyk4.png"></div><a name="habracut"></a><br><h1 id="vvedenie">  Einleitung </h1><br><p>  Im Oktober letzten Jahres war ich f√ºr ein technisches Praktikum bei der Firma NTC Vulkan.  Mein Interesse galt dem Bereich Reverse Engineering.  Ich wusste, was es war, ich hatte bereits versucht, Crackme unter x86 unabh√§ngig zu erforschen, aber ich verstand, dass das Interessanteste genau an der Schnittstelle von Software und Hardware liegt.  Ich hatte keine Erfahrung in diesem Bereich, aber ich hatte den Wunsch, meine Hand zu versuchen. </p><br><p> Ich hatte keine besonderen Erwartungen an diese Veranstaltung - Freunde und Bekannte sprechen oft √ºber technische Praktika bei verschiedenen namhaften Unternehmen.  Und als mir angeboten wurde, mich in der Erforschung eines USB-SATA-Adapters zu versuchen, freute ich mich einfach √ºber die neue Gelegenheit, etwas zu lernen.  Die gesammelten Erfahrungen und die erzielten Ergebnisse haben es erm√∂glicht, die Richtigkeit der Wahl des Praktikumsortes und des zuk√ºnftigen Berufes zu √ºberpr√ºfen. </p><br><p>  Die Studie begann mit der Anschaffung eines regul√§ren USB-SATA-Adapters.  Hier ist, was ich als n√§chstes getan habe. </p><br><h1 id="vizualnyy-shemotehnicheskiy-analiz">  Visuelle Schaltungsanalyse </h1><br><p>  Zuerst m√ºssen Sie die Adapterplatine √ºberpr√ºfen und die Grundelemente des Ger√§ts bestimmen.  In den folgenden Abbildungen sind die f√ºr den Betrieb des Ger√§ts wichtigen Hauptbl√∂cke der Komponenten gekennzeichnet.  Nach Recherchen aufgenommene Fotos: </p><br><img src="https://habrastorage.org/webt/9x/1n/ej/9x1nejzyxjz-zpfnb_d_v9y9giy.jpeg"><br><p>  <em>USB zu SATA Adapter.</em>  <em>Blick von oben</em> </p><br><img src="https://habrastorage.org/webt/tx/ra/je/txrajeoqdj1x7ytwn7huh0gdy6g.jpeg"><br><p>  <em>USB zu SATA Adapter.</em>  <em>Ansicht von unten</em> </p><br><p>  Nachdem ich einige Zeit bei Google verbracht hatte, stellte ich fest, dass sich zwei Spannungswandler auf der Platine befinden: einer mit 3,3 V und der andere mit 1,2 V. Der auf der Platine installierte Flash-Speicher ist ebenfalls sehr einfach zu bestimmen.  Das ROM funktioniert mit der SPI-Schnittstelle und die Speicherkapazit√§t betr√§gt 512 Kbit / s. </p><br><p>  Es scheint, dass die Phase der Schaltungsintelligenz fast abgeschlossen ist, aber eine schnelle Suche im Internet brachte auf Anfrage von ‚ÄûASM1051‚Äú keine Ergebnisse.  F√ºr den auf der Platine installierten Chip wurden keine Dokumente gefunden.  Richtig, es ist immer noch gelungen, Software zu finden, mit der Sie sie aktualisieren k√∂nnen.  Zus√§tzlich gibt es ein kleines <a href="https://datasheetspdf.com/pdf-file/917641/ASMedia/ASM1053/1">Datenblatt</a> f√ºr das √§ltere Modell <strong>ASM1053</strong> . </p><br><h1 id="usb">  USB </h1><br><p>  Bei Anschluss an einen Computer wird der Adapter als USB-Speicherger√§t angezeigt.  Ich entschied, dass ein tieferes Wissen √ºber <a href="https://ru.wikipedia.org/wiki/USB">USB</a> wahrscheinlich f√ºr meine Forschung n√ºtzlich sein w√ºrde, also verbrachte ich die n√§chsten Stunden damit, die Schnittstelle zu studieren. <br>  Im Allgemeinen k√∂nnen USB-Ger√§te je nach Funktionalit√§t unterschiedlichen Klassen angeh√∂ren.  Beispielsweise sind Flash-Laufwerke das Massenspeicherger√§t und Tastaturen und M√§use das <a href="https://ru.wikipedia.org/wiki/USB_HID">Human Interface Device (HID)</a> .  Und da mein Adapter im Ger√§te-Manager als Speicherger√§t angezeigt wird, bedeutet dies, dass er als Massenspeicher definiert ist und mit SCSI-Befehlen arbeiten sollte. </p><br><div class="spoiler">  <b class="spoiler_title">Grundlegende USB-Literatur, die sich als n√ºtzlich erwies</b> <div class="spoiler_text"><ul><li><p>  <a href="https://pierrelib.pagesperso-orange.fr/buses/USB_in_a_Nutshell.pdf">USB auf den Punkt gebracht</a> </p><br></li><li><p>  <a href="https://usb.org/sites/default/files/usbmassbulk_10.pdf">Massenspeicherklasse f√ºr Universal Serial Bus</a> </p><br></li><li><p>  <a href="http://ww1.microchip.com/downloads/en/appnotes/01169a.pdf">USB-Massenspeicherklasse auf einem eingebetteten Ger√§t</a> </p><br></li><li><p>  <a href="https://www.seagate.com/files/staticfiles/support/docs/manual/Interface%2520manuals/100293068j.pdf">Referenzhandbuch f√ºr SCSI-Befehle</a> </p><br></li></ul></div></div><br><h1 id="chtenie-pamyati-iz-pzu">  Speicher aus dem ROM lesen </h1><br><p>  Da √ºber den auf der Karte installierten ASM1051 nichts bekannt ist, wurde der Speicher aus dem ROM als die offensichtlichste Aktion angesehen.  Ich bin ins Labor gezogen.  Trennte den Flash-Speicherchip mit einem L√∂tf√∂n und verband ihn mit dem USB-Programmierger√§t ChipProg-48.  Es gab keine Probleme beim Lesen und ich hatte eine Bin√§rdatei in der Hand.  Zu diesem Zeitpunkt konnte ich nicht sagen, was sich auf dem Flash-Laufwerk befand, und begann, die Daten zu analysieren. </p><br><h1 id="analiz-binarnogo-fayla">  Analyse von Bin√§rdateien </h1><br><p>  Zun√§chst habe ich mit WinHex einen Speicherauszug aus dem ROM ge√∂ffnet, aber Sie k√∂nnen einen beliebigen HEX-Editor verwenden.  Begann die Bytes zu betrachten: </p><br><img src="https://habrastorage.org/webt/fz/g8/v7/fzg8v7gjqsop97y-kgybcmudrqa.jpeg"><br><p>  <em>Start eines Speicherauszugs, der aus dem ROM gelesen wird</em> </p><br><p> Der Screenshot oben ist ein Screenshot aus dem Editor.  Die Zeile <code>ASMT1051</code> , die mit der Adresse 0x44 beginnt, ist sofort ersichtlich.  Sie k√∂nnen die Zeile auch als <code>asmedia</code> von der Adresse 0x18 aus sehen.  F√ºr die erste Datenanalyse habe ich das Frequenzanalysetool verwendet, das in WinHex verf√ºgbar ist. </p><br><img src="https://habrastorage.org/webt/ui/r9/ad/uir9adkobpc6gnl55k6vjnaf65i.jpeg"><br><p>  <em>Histogramm der Frequenzanalyse des ROM-Speichers</em> </p><br><p>  Das Histogramm zeigt die Bytes, die sich am h√§ufigsten in der Datei befinden.  Zus√§tzlich zu den Heap-Werten 0x00 und 0xFF (die √§u√üersten Spalten des Histogramms) befinden sich h√§ufig die folgenden Bytes im Speicher: </p><br><ul><li>  0x02; </li><li>  0x74; </li><li>  0x90; </li><li>  0xA3; </li><li>  0xE0; </li><li>  0xF0. </li></ul><br><p>  Es w√§re m√∂glich, meine Annahme zu best√§tigen, dass sich Firmware im ROM befindet.  Ein einfacher Weg, dies zu tun, besteht darin, zu versuchen, die <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25B4_%25D0%25BE%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B0%25D1%2586%25D0%25B8%25D0%25B8">Operationscodes</a> verschiedener f√ºr Mikrocontroller geeigneter Architekturen (im Folgenden - MC) mit Bytes zu vergleichen, die sich h√§ufig im Speicher befinden. </p><br><p>  Wenn grob gesch√§tzt, sollten sehr oft in einem Code in Assembler solche Befehle wie: </p><br><ul><li>  mov; </li><li>  jmp; </li><li>  anrufen; </li><li>  ret. </li></ul><br><p>  Nat√ºrlich k√∂nnen diese Befehle in verschiedenen Architekturen unterschiedliche Variationen aufweisen, aber es gibt einen gesunden Menschenverstand. </p><br><p>  Ich musste mehrere Anweisungen f√ºr verschiedene Kernel durchgehen, bevor ich die richtigen fand.  Ein Vergleich mit der Architektur von <a href="https://ru.wikipedia.org/wiki/Intel_8051">Intel 8051</a> ergab ein sehr plausibles Ergebnis.  Die Opcodes einiger <a href="http://www.keil.com/support/man/docs/is51/is51_opcodes.htm">Befehle</a> stimmen mit g√§ngigen Bytes aus einer Datei √ºberein, zum Beispiel: </p><br><ul><li>  0x02 - LJMP addr16; </li><li>  0x74 - MOV A, #immed; </li><li>  0x90 - MOV DPTR, #immed; </li><li>  0xA3 - INC DPTR; </li><li>  0xE0 - MOVX A, @DPTR; </li><li>  0xF0 - MOVX @DPTR, A. </li></ul><br><p>  Es sieht wirklich so aus, als ob sich Firmware f√ºr MK im ROM befindet.  Man konnte die Bin√§rdatei sofort in den <a href="https://www.hex-rays.com/products/ida/index.shtml">IDA Pro-</a> Disassembler laden, aber beim Mittagessen fragte einer der Kollegen: </p><br><blockquote>  <em>"Sind Sie sicher, dass der Code im Speicher genau mit der Nulladresse beginnt?"</em> </blockquote><p>  Und wirklich, m√ºssen Sie ber√ºcksichtigen, dass einige "M√ºll" oder Daten von der Adresse 0x00 im Speicher sein k√∂nnen. </p><br><p>  Generell stand ich vor der Aufgabe, die Startadresse des Codes zu ermitteln.  Um dieses Ziel zu erreichen, ist es am besten, den <a href="https://www.eltan.com/products/spi-flash-tools/46-em100-emulator.html">EM100</a> SPI-Emulator zu verwenden.  Der Emulator ersetzt den Speicherchip auf der Platine, sodass das ROM nicht jedes Mal mit Firmware gel√∂tet werden muss. Au√üerdem kann der EM100 ein Speicherzugriffsprotokoll aufzeichnen.  Da die Firmware aus dem ROM bereits gelesen wurde, k√∂nnen Sie sie jetzt auf den SPI-Emulator herunterladen.  Als n√§chstes m√ºssen Sie den Emulator auf die Adapterplatine l√∂ten und ein Protokoll aufzeichnen, wenn Sie den Adapter √ºber USB an einen PC anschlie√üen. </p><br><img src="https://habrastorage.org/webt/8i/rp/f2/8irpf2mpqht4crvi8aqwcj3ot7s.jpeg"><br><p>  <em>Der SPI-Emulator ist mit der USB-SATA-Adapterplatine verl√∂tet</em> </p><br><p>  Ich habe die Verkabelung vom Emulator zu den Pads aus dem Flash-Speicher gel√∂tet und den Emulator mit ein paar Firmware geflasht.  Nun bleibt abzuwarten, ob und an welchen Adressen MK den Speicher adressiert. </p><br><img src="https://habrastorage.org/webt/yc/v6/te/ycv6teqfm5n_7gzvwgss1d6ycwk.png"><br><p>  <em>ROM f√ºr den Zugriff auf den ROM-Speicher (mit der SPI-Emulator-Software bezogen)</em> </p><br><p>  Die obige Abbildung zeigt, dass der auf der Karte installierte ASM1051-Controller beim Anschlie√üen der Stromversorgung an den Adapter mehrere 0x03-Befehle (Daten lesen) sendet. </p><br><p>  Zuerst liest der ASM1051 0x80 Bytes, beginnend mit 0x0000.  Es folgen zwei Bytes ab Adresse 0x0080 und zwei weitere Bytes ab Adresse 0x8082.  Dann liest es den gr√∂√üten Teil des Speichers aus dem ROM, beginnend mit der Adresse 0x0082. </p><br><p>  Wir k√∂nnen davon ausgehen, dass eine gro√üe Anzahl von Bytes, die zuletzt aus dem ROM gelesen wurden, beginnend mit der Adresse 0x0082, wahrscheinlich der Code ist.  Was und warum vorher abgefragt wird ist noch nicht klar.  Es ist nur bekannt, dass das ASM1051 als Antwort auf die erste Anforderung Zeilen aus dem Flash-Speicher empf√§ngt, die in der obigen Abbildung markiert sind.  Sie befanden sich nur in den ersten 0x80 Bytes. </p><br><p>  Es ist an der Zeit zu pr√ºfen, ob der externe Speicher auf der Karte Firmware f√ºr MK mit dem 8051-Kernel enth√§lt und der Code sich unter der Adresse 0x0082 befindet.  √ñffnen Sie den Speicherauszug in IDA Pro, geben Sie den Prozessortyp Intel 8051 und den Offset f√ºr den Code 0x0082 an. </p><br><img src="https://habrastorage.org/webt/r8/fy/pl/r8fyplytapyh-i_lfgazwcsoxga.png"><br><p>  <em>In IDA Pro ge√∂ffnete Bin√§rdatei mit Offset 0x82</em> </p><br><p>  Es gab keine Probleme beim √ñffnen der Bin√§rdatei im Disassembler. </p><br><p>  <strong><em>Schlussfolgerungen:</em></strong> </p><br><ol><li>  MK ASM1051 hat eine Architektur 8051. </li><li>  Im ROM gibt es einen Code, der mit der Adresse 0x82 beginnt.  Neben dem Code gibt es noch etwas anderes. </li><li>  Die ersten 0x80 Bytes fallen auf. </li></ol><br><h1 id="analiz-koda">  Code-Analyse </h1><br><p>  Nachdem ich sichergestellt habe, dass der Code in der IDA korrekt geladen ist, k√∂nnen Sie ihn analysieren und parallel dazu kommentieren. </p><br><p>  W√§hrend des Studiums des Codes wurden einfache Funktionen gefunden, wie das Subtrahieren von 32-Bit-Zahlen, verschiedene Handler, √§hnlich wie <code>switch ()</code> in S. Melkali, und sehr einfache Funktionen, wie das Speichern des Werts aus dem R7-Register in einem Speicher an einer Adresse.  Die wichtigsten Funde werde ich im Folgenden beschreiben. </p><br><h2 id="nahodka--1">  Finde Nr. 1 </h2><br><p>  Interessanterweise erhielt ich als Antwort auf meine Anfrage ( <a href="https://en.wikipedia.org/wiki/SCSI_command">SCSI-Befehl</a> ) eine Antwort mit zwei Zeilen, die wir am Anfang des ROM-Speichers sahen.  Nat√ºrlich habe ich diese Zeilen sofort im Speicher des Emulators ge√§ndert und auf eine Anfrage gewartet, um zu sehen, was ich geschrieben habe.  So ein naiver Traum brach schnell zusammen.  Als Antwort auf den Befehl sah ich eine weitere Zeile, das ASM1051 forderte nicht den gr√∂√üten Teil des Speichers vom ROM an.  MK liest nur die ersten 0x80 Bytes und alle.  In der Architektur von 8051 kann Masken- (Hardware-) Firmware verwendet werden, anscheinend hat ASM1051 damit begonnen, von dort zu booten. </p><br><p>  So wurde klar, dass die ersten 0x80-Bytes wirklich wichtig sind und das √Ñndern einfach nicht funktioniert.  Ich beschloss, die Anfragen, die MK an SPI stellt, genauer zu untersuchen, bevor ich den Code herunterlade. </p><br><img src="https://habrastorage.org/webt/ep/cl/8i/epcl8it0d2d63f8oq1tctpmfvii.png"><br><p>  <em>SPI-Datenanforderung im ROM</em> </p><br><p>  Zwei Anfragen von zwei Bytes schienen interessant.  Die Suche in IDA 0x00, 0x80 und 0xEB ergab eine Vielzahl von Ergebnissen, die ich nicht analysierte, aber Byte 0x5A kam seltener vor. </p><br><img src="https://habrastorage.org/webt/sv/ym/kf/svymkfdb-0nsj764k8igczukjj0.png"><br><p>  <em>Vergleich mit Byte 0x5A.</em>  <em>Pr√ºfsumme z√§hlen-8</em> </p><br><p>  Der sechste Klick f√ºhrte mich buchst√§blich zu dem in der obigen Abbildung gezeigten Codeabschnitt.  Es ist zu erkennen, dass der Wert aus dem Register mit der Adresse 0x80 <strong>7E</strong> mit 0x5A verglichen wird.  Dann wird die Pr√ºfsumme-8 f√ºr Werte von Adresse 0x80 <strong>04</strong> bis 0x80 <strong>7E</strong> gelesen.  Als n√§chstes wird der Wert bei 0x80 <strong>7F</strong> mit dem zuvor empfangenen Betrag verglichen. </p><br><img src="https://habrastorage.org/webt/j4/ao/x2/j4aox2tkbow4wzw57rrbprixw9u.png"><br><p>  <em>Der Beginn des Speichers im ROM</em> </p><br><p>  Solche Offsets √§hnelten dem Beginn eines Speicherauszugs aus dem ROM.  Die obige Abbildung zeigt, dass die Adresse 0x7E das Byte 0x5A enth√§lt.  Und wenn Sie die Pr√ºfsumme 8 f√ºr Bytes von der Position 0x04 bis 0x7E z√§hlen, erhalten wir 0xA7, und dieser Wert liegt nur an der Adresse 0x7F. </p><br><p>  Auf √§hnliche Weise gelang es uns, die Berechnung der Pr√ºfsumme f√ºr Bytes von der Adresse 0x0082 bis 0x807F (anscheinend ist dies der gesamte Code) zu finden, die mit dem Byte an der Adresse 0x8083 √ºberpr√ºft wird.  Und bei 0x8082 liegt wieder der Wert 0x5A. </p><br><p>  Ja, das ist etwas komplizierter als nur die Zeilen im Speicher zu √§ndern.  Ich habe sie auch ge√§ndert, aber ich habe auch die Pr√ºfsummen f√ºr die neue Datei an den richtigen Stellen berechnet und notiert.  Danach sah ich als Antwort auf den Befehl SCSI INQUIRY meine Zeilen. </p><br><p>  <strong><em>Schlussfolgerungen:</em></strong> </p><br><ol><li>  W√§hrend des Startvorgangs versucht der ASM1051, Code aus dem ROM herunterzuladen. </li><li>  Zun√§chst vergleicht das ASM1051 das Pr√ºfsummen-8-Byte von Adresse 0x04 bis 0x7E mit dem Wert bei 0x7F. </li><li>  Wenn der Vergleich der Pr√ºfsumme f√ºr die Pr√§ambel erfolgreich ist, k√∂nnen wir ihn f√ºr den "Code" (Adressen von 0x0082 bis 0x807F) ber√ºcksichtigen.  ASM1051 vergleicht diesen Wert mit dem Wert an Adresse 0x8083 und √ºberpr√ºft, ob sich Byte 0x5A an Adresse 0x8082 befindet. </li><li>  Wenn alle √úberpr√ºfungen korrekt sind, wird der ASM1051 aus dem ROM geladen, andernfalls wird die Maskenfirmware verwendet. </li></ol><br><h2 id="nahodka--2">  Finde Nummer 2 </h2><br><p>  Beim √úberpr√ºfen und Kommentieren von Funktionen stellte ich fest, dass die PRINTF-Funktion sehr h√§ufig im Code verwendet wird (ich habe es so genannt).  Das Interessante daran ist, dass vor dem Aufrufen ein <strong>gedrucktes</strong> Zeichen in das R7-Register geschrieben wird. </p><br><img src="https://habrastorage.org/webt/fn/0a/9a/fn0a9aafvgus1v4emxuf6j9kbea.png"><br><p>  <em>PRINTF-Funktion in IDA Pro</em> </p><br><p>  Die Funktion selbst wurde in der obigen Abbildung dargestellt.  Lass uns mit ihr umgehen.  Zun√§chst m√ºssen Sie den Wert aus dem Register mit der Adresse 0x7F6 in die Batterie verschieben.  Wenn es Null gibt, beenden Sie die Funktion.  Das Interessanteste passiert, wenn es nicht Null gibt.  Dann wird der Wert des Registers R7 in das Register mit der Adresse 0xC001 verschoben, und, wie wir uns erinnern, wird vor dem Aufruf dieser Funktion ein gedrucktes Zeichen in R7 geschrieben.  √úberpr√ºfen Sie anschlie√üend, ob der Wert in R7 dem Zeichencode ‚Äû.‚Äú Entspricht. Wenn nicht, beenden Sie die Funktion.  Wenn der Vergleich jedoch erfolgreich war, entnimmt die Funktion den Wert aus dem Register mit der Adresse 0x16A und verschiebt ihn nach 0xC001, was jedoch schwierig ist.  Beispielsweise wird die Funktion anstelle von Byte <strong>0x41</strong> (Zeichen "A" in ASCII) zu 0xC001 Byte 0x34 (Zeichen <strong>"4"</strong> in ASCII) und dann zu 0x31 (Zeichen <strong>"1"</strong> in ASCII) verschoben.  Beenden Sie die Funktion erneut. </p><br><p>  Ich habe festgestellt, dass die Pr√ºfung zu Beginn der Funktion nicht bestanden werden kann, da das Register mit der Adresse 0x7F6 auf Null initialisiert ist, dann √§ndert sich der Code nicht.  Das hei√üt, diese Funktion wird vom Programmierer deaktiviert, obwohl sie kompiliert bleibt.  Die Tatsache, dass Bytes nur in das 0xC001-Register geschrieben werden (und manchmal zwei in einer Reihe), legte nahe, dass dies h√∂chstwahrscheinlich ein Hardware-Register ist. </p><br><p>  All dies √§hnelt UART.  Um herauszufinden, ob dies der Fall ist, m√ºssen Sie folgende Schritte ausf√ºhren: </p><br><ol><li>  Identifizieren Sie die Beine auf dem ASM1051, an denen der UART ausgegeben wird. </li><li>  Definieren Sie UART-Parameter (Geschwindigkeit, Parit√§t, Anzahl der Stoppbits). </li><li>  Es w√§re sch√∂n, UART im Code zu aktivieren (anscheinend ist es deaktiviert). </li></ol><br><p>  Alles sieht ganz einfach aus: Sie k√∂nnen abwechselnd mit einem logischen Analysator die Beine ber√ºhren und nach dem suchen, auf dem der Moment des Sendens des UART sichtbar wird.  Bei Vorhandensein eines Signals kann die Geschwindigkeit durch die Zeit der Impulse bestimmt werden.  Mit den restlichen Parametern ist auch alles klar, sehen Sie nur den Moment des Sendens eines Bytes auf dem Analysator. </p><br><p>  Um diese Funktion zu "aktivieren", k√∂nnen Sie anstelle der ersten drei Zeilen Nullen schreiben, wobei der Wert im Register mit der Adresse 0x7F6 gepr√ºft wird.  Dazu √∂ffne ich nochmal die Firmware in WinHex. </p><br><img src="https://habrastorage.org/webt/rm/rw/mg/rmrwmgen5bw46g0r1a7uchsnkog.png"><br><p>  <em>Es werden sechs zur√ºckzusetzende Bytes zugewiesen.</em> </p><br><p>  Im Editor √§ndere ich die gew√ºnschten sechs Bytes in Nullen.  Jetzt ist die Firmware fertig und kann auf den ROM-Emulator heruntergeladen werden.  Wenn wir annehmen, dass die Funktion zur Ausgabe von Bytes in UART aktiviert ist und ihr Aufruf sehr h√§ufig im gesamten Code enthalten ist, k√∂nnen wir erwarten, dass die Bytes von der UART "fliegen", wenn der Adapter ausgef√ºhrt wird.  Ich hoffe, einen Tracer zu sehen, der in Bytes im UART anzeigt, wie viel Code ausgef√ºhrt wird. </p><br><p>  Wie ich oben geschrieben habe, k√∂nnen Sie sich den Logikanalysator einzeln ansehen, um die erforderlichen Rx- und Tx-Zweige zu finden.  Ich ging jedoch davon aus, dass sich Rx und Tx des ASM1051 an derselben Stelle befinden wie die ASM1053 - Beine 40 bzw. 41.  Ich habe die Analysesonde an Pin 41 (angenommener Tx) angeschlossen und sehe etwas √Ñhnliches wie das gew√ºnschte Signal: </p><br><img src="https://habrastorage.org/webt/qn/s7/rq/qns7rq-nxvqvqcgzlo4hwqb7spc.png"><br><p>  <em>Zeitdiagramm mit Schenkel 41 - Tx</em> </p><br><p>  Um den USB-UART-Konverter anzuschlie√üen und die eingehenden gedruckten Zeichen im Terminal zu beobachten, musste ich zwei d√ºnne Kabel direkt auf die Adapterplatine l√∂ten und mit Hei√ükleber befestigen. </p><br><img src="https://habrastorage.org/webt/jn/x2/-f/jnx2-fwuhcewoy4aodelx7ugqbk.jpeg"><br><p>  <em>Zwei Kabel an RX und TX angel√∂tet</em> </p><br><p>  Ich habe das Diagramm aus der Abbildung ‚ÄûZeitdiagramm von Abschnitt 41 - Tx‚Äú ein wenig studiert: Die Zeit eines Impulses betr√§gt anscheinend 1 Œºs und f√ºr sechs Bits 6,3 Œºs.  Nachdem ich den Wert in Baud neu berechnet hatte, erhielt ich ungef√§hr 950.000 Baud, die n√§chste Standard-UART-Geschwindigkeit ist 921600 Baud.  Ich denke, diese Diskrepanz ergibt sich aus dem Messfehler des logischen Analysators, ich habe nicht das w√ºrdigste Ger√§t genommen, sondern das chinesische ‚ÄûBaby‚Äú.  Nachdem ich die Parameter im Fenster des Terminal 1.9b-Programms eingestellt hatte, konnte ich eingehende Bytes vom ASM1051 MK w√§hrend des Betriebs beobachten. </p><br><img src="https://habrastorage.org/webt/fa/de/pc/fadepckvko4t2dyacaqt93hidao.png"><br><p>  <em>Programmfenster von Terminal 1.9b w√§hrend des Adapterbetriebs</em> </p><br><p>  <strong><em>Fazit:</em></strong> </p><br><p>  Das ASM1051 MK verf√ºgt √ºber ein UART-Hardwaremodul.  Das Register zum Senden von Daten hat die Adresse 0xC001.  Die Datenrate betr√§gt 921600 Baud.  Es gibt ein Stoppbit.  Leg 41 ist Tx und Leg 40 ist Rx (obwohl dies nicht genau ist). </p><br><h2 id="nahodka--3">  Finde Nummer 3 </h2><br><p>  Durch Scrollen durch den Code im Disassembler und Hinzuf√ºgen von Kommentaren k√∂nnen Sie Konstruktionen schwieriger finden, als eine Zahl in ein Register zu schreiben.  Also bin ich auf einen interessanten Handler gesto√üen, von dem ein Teil in C wie <code>switch ()</code> aussah. </p><br><img src="https://habrastorage.org/webt/zq/ra/nr/zqranrtexseqh7xpj0ynpjav9su.png"><br><p>  <em>Der Befehlshandler aus dem Register mit der Adresse 0x800F</em> </p><br><p>  Als ich begriff, dass irgendwo <a href="https://en.wikipedia.org/wiki/SCSI_command">SCSI-Befehle</a> verarbeitet <a href="https://en.wikipedia.org/wiki/SCSI_command">werden</a> m√ºssen, begann ich, nach Bytes zu suchen, mit denen der Inhalt des Registers mit der Adresse 0x800F in der obigen Abbildung verglichen wird.  Es stellte sich heraus, dass die ersten vier Zweige die Befehle Lesen (10), Schreiben (10), Lesen (16), Schreiben (16) pr√ºfen.  Es besteht kein Zweifel, dass dies ein SCSI-Befehlshandler ist.  Als n√§chstes habe ich mir eine Funktion angesehen, die aufgerufen wird, wenn der eingehende Befehl nicht Read / Write (u_Switch) ist.  Es liest abh√§ngig vom Byte im Register mit der Adresse 0x16A (der Wert wird von 0x800F √ºbernommen) die Adresse, zu der wir gelangen, wenn sie diese Funktion verlassen.  Dies √§hnelt <code>switch ()</code> . </p><br><img src="https://habrastorage.org/webt/8c/ni/xf/8cnixfxf9a1bcyzv0ttlsgpmcqo.png"><br><p>  <em>SCSI-Befehle wechseln</em> </p><br><p>  Da ich bereits das Byte ermittelt habe, mit dem ich den in den Adapter eingegangenen SCSI-Befehl vergleiche, habe ich die Adresszuordnung schnell nach Befehlen geordnet.  In der obigen Abbildung ist beispielsweise zu sehen, dass nach dem Verlassen der Funktion u_Switch die Adresse 0x1B85 angegeben wird, wenn das Byte 0x1A im Register mit der Adresse 0x16A enthalten ist.  Interessanterweise sind nicht alle Bytes im Vergleich zu u_Switch im SCSI-Standard definiert.  Das hei√üt, der Adapter kann die Bytes 0xE6 oder 0xDF verarbeiten, diese sind jedoch nicht durch den Standard festgelegt. </p><br><p>  Wie Sie sehen, kann der Adapter benutzerdefinierte Befehle ausf√ºhren, f√ºr die es Handlerfunktionen gibt. </p><br><img src="https://habrastorage.org/webt/4m/kn/bz/4mknbzam6xol2fhb750trvrxs_c.png"><br><p>  <em>Seite 13 der <a href="https://usb.org/sites/default/files/usbmassbulk_10.pdf">Universal Serial Bus-Massenspeicherklasse</a></em> </p><br><p>  <strong>Achten Sie</strong> auf den Offset <strong>0x0F</strong> zur Adresse 0x8000.  Vor dem Prozessor wird der SCSI-Befehl aus dem Register mit der Adresse 0x800F gelesen.  Wenn Sie die Tabelle in der obigen Abbildung sorgf√§ltig lesen, k√∂nnen Sie feststellen, dass das CBWCB-Feld im Command Block Wrapper (CBW) auch einen Offset von <strong>0x0F aufweist</strong> .  Es stellt sich heraus, dass die Adressen des ASM1051-RAM-Speichers, beginnend mit 0x8000, ein USB-Puffer sein k√∂nnen, wie in der folgenden Tabelle gezeigt. </p><br><div class="scrollable-table"><table><thead><tr><th>  Speicheradresse </th><th>  Beschreibung </th></tr></thead><tbody><tr><td>  0x8000-0x8003 </td><td>  dCBWSignature (USBC - bei Empfang eines Pakets) </td></tr><tr><td>  0x8004-0x8007 </td><td>  dCBWTag </td></tr><tr><td>  0x8008-0x800B </td><td>  dCBWDataTransferLength </td></tr><tr><td>  0x800C </td><td>  bmdCBWFlag </td></tr><tr><td>  0x800D </td><td>  bCBWLUN </td></tr><tr><td>  0x800E </td><td>  bCBWCBLength </td></tr><tr><td>  0x800F-0x801F </td><td>  CBWCB - SCSI-Befehl und seine Parameter </td></tr></tbody></table></div><br><p>  Die folgende Abbildung zeigt den Codeabschnitt, in dem der Vergleich mit der USBC-Zeichenfolge erfolgt (dies sollte die Signatur dCBWSignature sein) und die vorgeschlagene Signatur von der Adresse 0x8000 stammt.  Ich denke, dies reicht aus, um sicherzustellen, dass sich der USB-Puffer ab 0x8000 im RAM-Speicher befindet. </p><br><img src="https://habrastorage.org/webt/-t/et/eo/-teteok9i6rotmpp1w6wxy0bun4.png"><br><p>  <em>√úberpr√ºfen Sie das Feld dCBWSignature auf √úbereinstimmung mit der USBC-Zeichenfolge</em> </p><br><p>  <strong><em>Schlussfolgerungen:</em></strong> </p><br><ol><li>  MK ASM1051 kann nicht nur SCSI-Befehle verarbeiten, die im Standard beschrieben sind. </li><li>  Die Startadresse des USB-Puffers ist 0x8000.  Der SCSI-Befehl befindet sich im Register mit der Adresse 0x800F, was bedeutet, dass weitere Daten / Argumente der Befehle vorhanden sind. </li></ol><br><h2 id="nahodka--4">  Finde Nummer 4 </h2><br><p>  Da ich wusste, dass MK nicht standardm√§√üige Teams verarbeiten kann, wollte ich wissen, was sie tun.  Die meisten von ihnen gehorchten mir schnell.  Ich werde das Studium des Codes dieser Befehle nicht zitieren, da dies lange dauern kann und f√ºr einen separaten Artikel mit dem Titel ‚ÄûAssembler ist einfach‚Äú von Bedeutung sein kann. Die Ergebnisse werde ich in der folgenden Tabelle beschreiben. </p><br><div class="scrollable-table"><table><thead><tr><th>  SCSI-Befehl </th><th>  Teambeschreibung </th></tr></thead><tbody><tr><td>  0xE0 </td><td>  Erm√∂glicht das Lesen der ersten 0x80-Bytes aus dem ROM.  In Zukunft werde ich diesen Teil des Speichers als <em>Pr√§ambel bezeichnen</em> (ja, dieselben 0x80-Bytes, in denen sich die Zeilen <code>asmedia</code> und <code>ASM1051</code> ). </td></tr><tr><td>  0xE1 </td><td>  Schreibt die ersten 0x80-Bytes in das ROM </td></tr><tr><td>  0xE3 </td><td>  Schreibt eine beliebige Anzahl von Bytes von 0x80-Adressen in den ROM-Speicher.  Das Argument (wie sich herausstellte) ist die Gr√∂√üe des Pakets </td></tr><tr><td>  0xE4 </td><td>  Liest den Byteblock des ASM1051 RAM.  Nimmt als Argument die Startadresse und die Anzahl der gelesenen Bytes </td></tr><tr><td>  0xE5 </td><td>  Schreibt ein Byte in den RAM um </td></tr><tr><td>  0xE7 </td><td>  Liest das zuletzt empfangene Paket in den ATA-Puffer. </td></tr><tr><td>  0xE8 </td><td>  Startet das Ger√§t neu </td></tr></tbody></table></div><br><p>  Ich gebe zu, dass ich nicht alle Befehle durch Lesen von Funktionen in der IDA herausgefunden habe.  Nachdem ich w√§hrend der Recherche gegen die Wand gesto√üen war, fiel mir ein, dass ich <a href="https://www.usbdev.ru/files/asmedia/asm105mptool/">Software und viele Firmware</a> f√ºr das ASM1051 gesehen hatte, als ich nach Dokumentation suchte.  Mit der gefundenen Software k√∂nnen Sie die Firmware aktualisieren und das Ger√§t neu starten.  Daher entschied ich, dass es Zeit war, <a href="https://www.syssoft.ru/HHD-Software/Device-Monitoring-Studio/">Device Monitoring Studio zu verwenden</a> und zu sehen, was den PC w√§hrend des Updates an den Adapter sendet. </p><br><p>  Auf diese Weise konnte nachvollzogen werden, wie die Aktualisierung der Firmware abl√§uft: Zuerst wird die Pr√§ambel gesendet (mit dem Befehl 0xE1), dann wird der Code mit dem Befehl 0xE3 geschrieben und anschlie√üend durch einen Neustart (Befehl 0xE8) poliert.  F√ºr ein schnelles und bequemes Update habe ich ein Python-Skript geschrieben, das die erforderlichen Zeilen in die Pr√§ambel einf√ºgt, dann die Pr√ºfsummen liest und das Ger√§t aktualisiert.  Jetzt brauche ich keinen Emulator mehr, ich hatte die M√∂glichkeit, Firmware √ºber USB auf das ASM1051 hochzuladen, Sie k√∂nnen das native ROM auf die Karte zur√ºckschicken. </p><br><p>  <strong><em>Schlussfolgerungen</em></strong> </p><br><p>  Um die Firmware zu aktualisieren, m√ºssen drei SCSI-Befehle nacheinander ausgef√ºhrt werden: 0xE1, 0xE3 und 0xE8. </p><br><h2 id="nahodka--5">  Finde Nummer 5 </h2><br><p>  Neben den undokumentierten Befehlen war es interessant, die Handler von Standardbefehlen zu betrachten. </p><br><img src="https://habrastorage.org/webt/be/9e/st/be9estiir9g45o0thkj4bacvsmm.png"><br><p>  <em>Verschieben des dritten Bits vom Register 0xC884 zum siebten Bit des Registers 0x8002</em> </p><br><p>  Es gibt einen interessanten Test im Handler des SCSI-Befehls MODE SENSE (10).  Die obige Abbildung zeigt einen Teil des Funktionscodes.  Es ist zu sehen, dass das dritte Bit aus dem <strong>0xC884-</strong> Register gelesen wird.  Dann wird der Wert dieses Bits im Register auf 0x8002 gesetzt. </p><br><p>  Interessant ist hier, dass das <strong>0xC884-</strong> Register an keiner Stelle im Code initialisiert ist, was bedeutet, dass es sich h√∂chstwahrscheinlich um Hardware handelt. </p><br><img src="https://habrastorage.org/webt/fc/mw/sh/fcmwsh6pa3zzkpbsfxxici-t4g4.jpeg"><br><p>  <em>Tabelle 362 des <a href="https://www.seagate.com/files/staticfiles/support/docs/manual/Interface%2520manuals/100293068j.pdf">SCSI-Befehlsreferenzhandbuchs</a></em> </p><br><p>  Wenn Sie sich die Dokumentation zum 0x5A- <a href="https://www.seagate.com/files/staticfiles/support/docs/manual/Interface%2520manuals/100293068j.pdf">SCSI-Befehl</a> (MODE SENSE) ansehen, wird au√üerdem klar, dass der USB-SATA-Adapter auf die MODE SENSE-Anforderung reagieren sollte.  Das dritte Byte der Antwort enth√§lt das siebte Bit von WP (Schreibschutz - Schreibschutz).  √úbrigens habe ich bereits das <strong>siebte</strong> Bit in 0x8002 gesehen, und der <strong>Versatz</strong> vom Anfang des USB-Puffers (0x8000) betr√§gt hier genau <strong>3</strong> . </p><br><p>  <strong><em>Fazit:</em></strong> </p><br><p>  Der getestete USB-SATA-Adapter liest das dritte Bit aus dem Hardwareregister bei <strong>0xC884</strong> und sendet es als WP-Bit an den USB-Host. </p><br><h2 id="nahodka--6">  Suchen Sie die Nummer 6 </h2><br><p>  Das Hardware-Register, das bei der Untersuchung des SCSI-Befehlshandlers MODE SENSE gefunden wurde, ist dem GPIO sehr √§hnlich.  Um dies zu best√§tigen, entschloss ich mich, die ASM1051-Beine mit einem aktiven Widerstand zu ber√ºhren und den Registerwert (SCSI-Befehl 0xE4) mit der Adresse <strong>0xC884 auszulesen</strong> .  Dazu habe ich ein Python-Skript mit benutzerdefinierten SCSI-Befehlen geschrieben, das den Wert im <strong>0xC884-</strong> Register √ºberwacht und auf dem PC anzeigt. </p><br><div class="scrollable-table"><table><thead><tr><th>  Bits 0xC884 </th><th>  7 </th><th>  6 </th><th>  5 </th><th>  4 </th><th>  3 </th><th>  2 </th><th>  1 </th><th>  0 </th></tr></thead><tbody><tr><td>  Bein ASM1051 </td><td>  - </td><td>  - </td><td>  37 </td><td>  - </td><td>  9 </td><td>  10 </td><td>  45 </td><td>  44 </td></tr></tbody></table></div><br><p>  Nach einem solchen Experiment habe ich eine Tabelle zusammengestellt, in der ich angezeigt habe, welche Bits im <strong>0xC884-</strong> Register sich ge√§ndert haben, als der ASM1051-Widerstand die Beine ber√ºhrt hat.  Es stellt sich heraus, dass das untersuchte Register eng mit dem GPIO verbunden ist, der Versuch, darauf zu schreiben (mit dem SCSI-Befehl 0xE5), jedoch fehlgeschlagen ist - der Wert hat sich nicht ge√§ndert. </p><br><p>  Dann habe ich entschieden, dass dieses Register entweder schreibgesch√ºtzt ist oder dass das Schreiben in dieses Register auf Hardwareebene verboten ist.  Wenn zum Beispiel die MK-Beine urspr√ºnglich nur zum Lesen eingerichtet waren, ist das Schreiben in das <strong>0xC884-</strong> Register m√∂glicherweise nicht verf√ºgbar. </p><br><p>  Um die dem GPIO zugeordneten Register zu finden, habe ich im Allgemeinen den Initialisierungscode MK durchgesehen.  Ich habe alle Register aufgeschrieben, deren Adressen in der N√§he von <strong>0xC884 liegen</strong> .  Ich habe ungef√§hr 10 von ihnen. Ich erinnere Sie daran, dass der zehnte Zweig des MK mit der LED auf der Platine verbunden ist, es entspricht dem zweiten Bit im Register <strong>0xC884</strong> .          ‚Äì <strong>0880</strong> ,            (,    ).  ,   ,   <strong>0880</strong>      (/),   <strong>0884</strong>   ,  - . </p><br><p>         <strong>0880</strong>    ,    <strong>0884</strong>    .     <strong>0884</strong>  .           ASM1051. </p><br><p> <strong><em>:</em></strong> </p><br><p>    GPIO  ASM1051.    <strong>0880</strong>   /   I/O.  0884    I/O. </p><br><h2 id="nahodka--5-prodolzhenie">  ‚Ññ 5.  </h2><br><p>   GPIO-  ,  45-           <strong>0884</strong> .           <strong>WP</strong> ,    USB.       45-    ,    HDD,     ,  . </p><br><img src="https://habrastorage.org/webt/9m/yq/lv/9myqlvzd8guku1qfcllendjrtcc.png"><br><p> <em>     HDD,      45-  </em> </p><br><p>     .       GND 45-      ,      HDD.     . </p><br><p>  <strong><em>Fazit</em></strong> </p><br><p>   45-  ASM1051         HDD. </p><br><h1 id="razrabotka-sobstvennogo-ustroystva">    </h1><br><p>       USB-SATA-.           ASM1051.   ,  -  ,     .   ,     GPIO.    ‚Äì  ASM1051  ,         HDD. ,   ,     (¬´     ¬ª),     ,  ,         USB-SATA-   ASM1051. </p><br><p> ,           footprint  ASM1051,       datasheet  ASM1053.     ,        ASM1051   . </p><br><img src="https://habrastorage.org/webt/mf/9k/pi/mf9kpiav5oxxejflxjfndixzccy.jpeg"><br><p> <em>ASM1051     </em> </p><br><p>    ,       3D- ,    . </p><br><img src="https://habrastorage.org/webt/4n/vk/ea/4nvkearirndsx2wx6lzbv2--iu0.png"><br><p> <em>3D-      </em> </p><br><p>            <strong>WP</strong> .  GPIO ASM1051      ,   UART.  ,      SATA,     HDD.      USB 3.0 Micro-B     Type-C.  HDD      USB,   HDD 3.5"  +12 ,           12  21 .     . </p><br><img src="https://habrastorage.org/webt/zh/ji/wu/zhjiwuyqzibs09gswjbdlths-_g.jpeg"><br><p> <em>    </em> </p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>       ,       . </p><br><p>           -,    ,   .         ¬´ ¬´¬ª,          .        ,       . </p><br><p>   ,    (,   )   embedded-. ,  ,       .      ,    ,    , ,         . </p><br><p>       ,   datasheets,    ,   .       ,  <strong>   !</strong> </p><br><p> <a href="https://raccoonsecurity.ru/"><img src="https://habrastorage.org/webt/6d/ts/lv/6dtslv2uikkshhl7tmsi7fgjp0y.png"></a> </p><br><p> <em>Raccoon Security ‚Äì     ¬´¬ª     , , ,       .</em> <br> <em>        ,         ,     .       <a href="https://raccoonsecurity.ru/internship/"></a> .</em> </p><cut></cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de485966/">https://habr.com/ru/post/de485966/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de485950/index.html">Epidemie und Zensur: Versuchen die chinesischen Beh√∂rden, die Verbreitung von Informationen √ºber das Coronavirus einzuschr√§nken?</a></li>
<li><a href="../de485952/index.html">CLI-Schnittstelle f√ºr Laravel Artisan</a></li>
<li><a href="../de485954/index.html">Java Digest f√ºr den 28. Januar</a></li>
<li><a href="../de485958/index.html">[Administrator√ºbersicht] Was ist, wenn das Programm Administratorrechte ben√∂tigt und Sie dies nicht tun?</a></li>
<li><a href="../de485962/index.html">Pers√∂nliche Recherche zu 2019-nCoV</a></li>
<li><a href="../de485968/index.html">Und wieder Bypass-Schl√∂sser. RouterOS + BGP + OSPF</a></li>
<li><a href="../de485970/index.html">K√ºrzlich 30 Top-Interviews: Entwicklung, Design, Sciencepop und Lebensstil</a></li>
<li><a href="../de485972/index.html">Regressionsanalysemethoden in Data Science</a></li>
<li><a href="../de485974/index.html">Raspberry Pi und SIM7600E 4G HAT Modem</a></li>
<li><a href="../de485986/index.html">Top 5 Lokalisierungstrends im Jahr 2020</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>