<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍💻 🚶🏼 💝 Reverse USB-SATA Adapter (Verlauf eines Praktikanten) 💒 😓 🔥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hintergrund 


 Praktikum ist der Prozess des Wissens- und Erfahrungserwerbs. Unser Raccoon Security-Team ist der Ansicht, dass eine Verbesserung der ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reverse USB-SATA Adapter (Verlauf eines Praktikanten)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ntc-vulkan/blog/485966/"><h1 id="predystoriya">  Hintergrund </h1><br><p>  Praktikum ist der Prozess des Wissens- und Erfahrungserwerbs.  Unser Raccoon Security-Team ist der Ansicht, dass eine Verbesserung der Informationssicherheit von Geräten und Software in unserer Umgebung nicht möglich ist, ohne dieses Wissen und diese Erfahrung an zukünftige Generationen von Spezialisten weiterzugeben.  Deshalb organisieren wir seit vielen Jahren individuelle Praktika für talentierte Studenten und Absolventen. </p><br><p>  Sicherheitsforschung ist eine Fähigkeit, die an der Universität nicht gelehrt wird.  Sie können es anhand konkreter Beispiele und unter Anleitung erfahrener Mentoren lernen.  Jedes Jahr lösen unsere Praktikanten komplexe technische Probleme, erreichen ihre Ziele und gehen weiter, erweitern ihren beruflichen Horizont und machen die Welt ein wenig sicherer.  Jeder von ihnen hat seine eigene Geschichte, Spezialist zu werden, und das unter dem Strich - der Anfang von einem von ihnen. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/eu/dr/h-/eudrh-mevrjhfjo4jfjouffyyk4.png"></div><a name="habracut"></a><br><h1 id="vvedenie">  Einleitung </h1><br><p>  Im Oktober letzten Jahres war ich für ein technisches Praktikum bei der Firma NTC Vulkan.  Mein Interesse galt dem Bereich Reverse Engineering.  Ich wusste, was es war, ich hatte bereits versucht, Crackme unter x86 unabhängig zu erforschen, aber ich verstand, dass das Interessanteste genau an der Schnittstelle von Software und Hardware liegt.  Ich hatte keine Erfahrung in diesem Bereich, aber ich hatte den Wunsch, meine Hand zu versuchen. </p><br><p> Ich hatte keine besonderen Erwartungen an diese Veranstaltung - Freunde und Bekannte sprechen oft über technische Praktika bei verschiedenen namhaften Unternehmen.  Und als mir angeboten wurde, mich in der Erforschung eines USB-SATA-Adapters zu versuchen, freute ich mich einfach über die neue Gelegenheit, etwas zu lernen.  Die gesammelten Erfahrungen und die erzielten Ergebnisse haben es ermöglicht, die Richtigkeit der Wahl des Praktikumsortes und des zukünftigen Berufes zu überprüfen. </p><br><p>  Die Studie begann mit der Anschaffung eines regulären USB-SATA-Adapters.  Hier ist, was ich als nächstes getan habe. </p><br><h1 id="vizualnyy-shemotehnicheskiy-analiz">  Visuelle Schaltungsanalyse </h1><br><p>  Zuerst müssen Sie die Adapterplatine überprüfen und die Grundelemente des Geräts bestimmen.  In den folgenden Abbildungen sind die für den Betrieb des Geräts wichtigen Hauptblöcke der Komponenten gekennzeichnet.  Nach Recherchen aufgenommene Fotos: </p><br><img src="https://habrastorage.org/webt/9x/1n/ej/9x1nejzyxjz-zpfnb_d_v9y9giy.jpeg"><br><p>  <em>USB zu SATA Adapter.</em>  <em>Blick von oben</em> </p><br><img src="https://habrastorage.org/webt/tx/ra/je/txrajeoqdj1x7ytwn7huh0gdy6g.jpeg"><br><p>  <em>USB zu SATA Adapter.</em>  <em>Ansicht von unten</em> </p><br><p>  Nachdem ich einige Zeit bei Google verbracht hatte, stellte ich fest, dass sich zwei Spannungswandler auf der Platine befinden: einer mit 3,3 V und der andere mit 1,2 V. Der auf der Platine installierte Flash-Speicher ist ebenfalls sehr einfach zu bestimmen.  Das ROM funktioniert mit der SPI-Schnittstelle und die Speicherkapazität beträgt 512 Kbit / s. </p><br><p>  Es scheint, dass die Phase der Schaltungsintelligenz fast abgeschlossen ist, aber eine schnelle Suche im Internet brachte auf Anfrage von „ASM1051“ keine Ergebnisse.  Für den auf der Platine installierten Chip wurden keine Dokumente gefunden.  Richtig, es ist immer noch gelungen, Software zu finden, mit der Sie sie aktualisieren können.  Zusätzlich gibt es ein kleines <a href="https://datasheetspdf.com/pdf-file/917641/ASMedia/ASM1053/1">Datenblatt</a> für das ältere Modell <strong>ASM1053</strong> . </p><br><h1 id="usb">  USB </h1><br><p>  Bei Anschluss an einen Computer wird der Adapter als USB-Speichergerät angezeigt.  Ich entschied, dass ein tieferes Wissen über <a href="https://ru.wikipedia.org/wiki/USB">USB</a> wahrscheinlich für meine Forschung nützlich sein würde, also verbrachte ich die nächsten Stunden damit, die Schnittstelle zu studieren. <br>  Im Allgemeinen können USB-Geräte je nach Funktionalität unterschiedlichen Klassen angehören.  Beispielsweise sind Flash-Laufwerke das Massenspeichergerät und Tastaturen und Mäuse das <a href="https://ru.wikipedia.org/wiki/USB_HID">Human Interface Device (HID)</a> .  Und da mein Adapter im Geräte-Manager als Speichergerät angezeigt wird, bedeutet dies, dass er als Massenspeicher definiert ist und mit SCSI-Befehlen arbeiten sollte. </p><br><div class="spoiler">  <b class="spoiler_title">Grundlegende USB-Literatur, die sich als nützlich erwies</b> <div class="spoiler_text"><ul><li><p>  <a href="https://pierrelib.pagesperso-orange.fr/buses/USB_in_a_Nutshell.pdf">USB auf den Punkt gebracht</a> </p><br></li><li><p>  <a href="https://usb.org/sites/default/files/usbmassbulk_10.pdf">Massenspeicherklasse für Universal Serial Bus</a> </p><br></li><li><p>  <a href="http://ww1.microchip.com/downloads/en/appnotes/01169a.pdf">USB-Massenspeicherklasse auf einem eingebetteten Gerät</a> </p><br></li><li><p>  <a href="https://www.seagate.com/files/staticfiles/support/docs/manual/Interface%2520manuals/100293068j.pdf">Referenzhandbuch für SCSI-Befehle</a> </p><br></li></ul></div></div><br><h1 id="chtenie-pamyati-iz-pzu">  Speicher aus dem ROM lesen </h1><br><p>  Da über den auf der Karte installierten ASM1051 nichts bekannt ist, wurde der Speicher aus dem ROM als die offensichtlichste Aktion angesehen.  Ich bin ins Labor gezogen.  Trennte den Flash-Speicherchip mit einem Lötfön und verband ihn mit dem USB-Programmiergerät ChipProg-48.  Es gab keine Probleme beim Lesen und ich hatte eine Binärdatei in der Hand.  Zu diesem Zeitpunkt konnte ich nicht sagen, was sich auf dem Flash-Laufwerk befand, und begann, die Daten zu analysieren. </p><br><h1 id="analiz-binarnogo-fayla">  Analyse von Binärdateien </h1><br><p>  Zunächst habe ich mit WinHex einen Speicherauszug aus dem ROM geöffnet, aber Sie können einen beliebigen HEX-Editor verwenden.  Begann die Bytes zu betrachten: </p><br><img src="https://habrastorage.org/webt/fz/g8/v7/fzg8v7gjqsop97y-kgybcmudrqa.jpeg"><br><p>  <em>Start eines Speicherauszugs, der aus dem ROM gelesen wird</em> </p><br><p> Der Screenshot oben ist ein Screenshot aus dem Editor.  Die Zeile <code>ASMT1051</code> , die mit der Adresse 0x44 beginnt, ist sofort ersichtlich.  Sie können die Zeile auch als <code>asmedia</code> von der Adresse 0x18 aus sehen.  Für die erste Datenanalyse habe ich das Frequenzanalysetool verwendet, das in WinHex verfügbar ist. </p><br><img src="https://habrastorage.org/webt/ui/r9/ad/uir9adkobpc6gnl55k6vjnaf65i.jpeg"><br><p>  <em>Histogramm der Frequenzanalyse des ROM-Speichers</em> </p><br><p>  Das Histogramm zeigt die Bytes, die sich am häufigsten in der Datei befinden.  Zusätzlich zu den Heap-Werten 0x00 und 0xFF (die äußersten Spalten des Histogramms) befinden sich häufig die folgenden Bytes im Speicher: </p><br><ul><li>  0x02; </li><li>  0x74; </li><li>  0x90; </li><li>  0xA3; </li><li>  0xE0; </li><li>  0xF0. </li></ul><br><p>  Es wäre möglich, meine Annahme zu bestätigen, dass sich Firmware im ROM befindet.  Ein einfacher Weg, dies zu tun, besteht darin, zu versuchen, die <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25B4_%25D0%25BE%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B0%25D1%2586%25D0%25B8%25D0%25B8">Operationscodes</a> verschiedener für Mikrocontroller geeigneter Architekturen (im Folgenden - MC) mit Bytes zu vergleichen, die sich häufig im Speicher befinden. </p><br><p>  Wenn grob geschätzt, sollten sehr oft in einem Code in Assembler solche Befehle wie: </p><br><ul><li>  mov; </li><li>  jmp; </li><li>  anrufen; </li><li>  ret. </li></ul><br><p>  Natürlich können diese Befehle in verschiedenen Architekturen unterschiedliche Variationen aufweisen, aber es gibt einen gesunden Menschenverstand. </p><br><p>  Ich musste mehrere Anweisungen für verschiedene Kernel durchgehen, bevor ich die richtigen fand.  Ein Vergleich mit der Architektur von <a href="https://ru.wikipedia.org/wiki/Intel_8051">Intel 8051</a> ergab ein sehr plausibles Ergebnis.  Die Opcodes einiger <a href="http://www.keil.com/support/man/docs/is51/is51_opcodes.htm">Befehle</a> stimmen mit gängigen Bytes aus einer Datei überein, zum Beispiel: </p><br><ul><li>  0x02 - LJMP addr16; </li><li>  0x74 - MOV A, #immed; </li><li>  0x90 - MOV DPTR, #immed; </li><li>  0xA3 - INC DPTR; </li><li>  0xE0 - MOVX A, @DPTR; </li><li>  0xF0 - MOVX @DPTR, A. </li></ul><br><p>  Es sieht wirklich so aus, als ob sich Firmware für MK im ROM befindet.  Man konnte die Binärdatei sofort in den <a href="https://www.hex-rays.com/products/ida/index.shtml">IDA Pro-</a> Disassembler laden, aber beim Mittagessen fragte einer der Kollegen: </p><br><blockquote>  <em>"Sind Sie sicher, dass der Code im Speicher genau mit der Nulladresse beginnt?"</em> </blockquote><p>  Und wirklich, müssen Sie berücksichtigen, dass einige "Müll" oder Daten von der Adresse 0x00 im Speicher sein können. </p><br><p>  Generell stand ich vor der Aufgabe, die Startadresse des Codes zu ermitteln.  Um dieses Ziel zu erreichen, ist es am besten, den <a href="https://www.eltan.com/products/spi-flash-tools/46-em100-emulator.html">EM100</a> SPI-Emulator zu verwenden.  Der Emulator ersetzt den Speicherchip auf der Platine, sodass das ROM nicht jedes Mal mit Firmware gelötet werden muss. Außerdem kann der EM100 ein Speicherzugriffsprotokoll aufzeichnen.  Da die Firmware aus dem ROM bereits gelesen wurde, können Sie sie jetzt auf den SPI-Emulator herunterladen.  Als nächstes müssen Sie den Emulator auf die Adapterplatine löten und ein Protokoll aufzeichnen, wenn Sie den Adapter über USB an einen PC anschließen. </p><br><img src="https://habrastorage.org/webt/8i/rp/f2/8irpf2mpqht4crvi8aqwcj3ot7s.jpeg"><br><p>  <em>Der SPI-Emulator ist mit der USB-SATA-Adapterplatine verlötet</em> </p><br><p>  Ich habe die Verkabelung vom Emulator zu den Pads aus dem Flash-Speicher gelötet und den Emulator mit ein paar Firmware geflasht.  Nun bleibt abzuwarten, ob und an welchen Adressen MK den Speicher adressiert. </p><br><img src="https://habrastorage.org/webt/yc/v6/te/ycv6teqfm5n_7gzvwgss1d6ycwk.png"><br><p>  <em>ROM für den Zugriff auf den ROM-Speicher (mit der SPI-Emulator-Software bezogen)</em> </p><br><p>  Die obige Abbildung zeigt, dass der auf der Karte installierte ASM1051-Controller beim Anschließen der Stromversorgung an den Adapter mehrere 0x03-Befehle (Daten lesen) sendet. </p><br><p>  Zuerst liest der ASM1051 0x80 Bytes, beginnend mit 0x0000.  Es folgen zwei Bytes ab Adresse 0x0080 und zwei weitere Bytes ab Adresse 0x8082.  Dann liest es den größten Teil des Speichers aus dem ROM, beginnend mit der Adresse 0x0082. </p><br><p>  Wir können davon ausgehen, dass eine große Anzahl von Bytes, die zuletzt aus dem ROM gelesen wurden, beginnend mit der Adresse 0x0082, wahrscheinlich der Code ist.  Was und warum vorher abgefragt wird ist noch nicht klar.  Es ist nur bekannt, dass das ASM1051 als Antwort auf die erste Anforderung Zeilen aus dem Flash-Speicher empfängt, die in der obigen Abbildung markiert sind.  Sie befanden sich nur in den ersten 0x80 Bytes. </p><br><p>  Es ist an der Zeit zu prüfen, ob der externe Speicher auf der Karte Firmware für MK mit dem 8051-Kernel enthält und der Code sich unter der Adresse 0x0082 befindet.  Öffnen Sie den Speicherauszug in IDA Pro, geben Sie den Prozessortyp Intel 8051 und den Offset für den Code 0x0082 an. </p><br><img src="https://habrastorage.org/webt/r8/fy/pl/r8fyplytapyh-i_lfgazwcsoxga.png"><br><p>  <em>In IDA Pro geöffnete Binärdatei mit Offset 0x82</em> </p><br><p>  Es gab keine Probleme beim Öffnen der Binärdatei im Disassembler. </p><br><p>  <strong><em>Schlussfolgerungen:</em></strong> </p><br><ol><li>  MK ASM1051 hat eine Architektur 8051. </li><li>  Im ROM gibt es einen Code, der mit der Adresse 0x82 beginnt.  Neben dem Code gibt es noch etwas anderes. </li><li>  Die ersten 0x80 Bytes fallen auf. </li></ol><br><h1 id="analiz-koda">  Code-Analyse </h1><br><p>  Nachdem ich sichergestellt habe, dass der Code in der IDA korrekt geladen ist, können Sie ihn analysieren und parallel dazu kommentieren. </p><br><p>  Während des Studiums des Codes wurden einfache Funktionen gefunden, wie das Subtrahieren von 32-Bit-Zahlen, verschiedene Handler, ähnlich wie <code>switch ()</code> in S. Melkali, und sehr einfache Funktionen, wie das Speichern des Werts aus dem R7-Register in einem Speicher an einer Adresse.  Die wichtigsten Funde werde ich im Folgenden beschreiben. </p><br><h2 id="nahodka--1">  Finde Nr. 1 </h2><br><p>  Interessanterweise erhielt ich als Antwort auf meine Anfrage ( <a href="https://en.wikipedia.org/wiki/SCSI_command">SCSI-Befehl</a> ) eine Antwort mit zwei Zeilen, die wir am Anfang des ROM-Speichers sahen.  Natürlich habe ich diese Zeilen sofort im Speicher des Emulators geändert und auf eine Anfrage gewartet, um zu sehen, was ich geschrieben habe.  So ein naiver Traum brach schnell zusammen.  Als Antwort auf den Befehl sah ich eine weitere Zeile, das ASM1051 forderte nicht den größten Teil des Speichers vom ROM an.  MK liest nur die ersten 0x80 Bytes und alle.  In der Architektur von 8051 kann Masken- (Hardware-) Firmware verwendet werden, anscheinend hat ASM1051 damit begonnen, von dort zu booten. </p><br><p>  So wurde klar, dass die ersten 0x80-Bytes wirklich wichtig sind und das Ändern einfach nicht funktioniert.  Ich beschloss, die Anfragen, die MK an SPI stellt, genauer zu untersuchen, bevor ich den Code herunterlade. </p><br><img src="https://habrastorage.org/webt/ep/cl/8i/epcl8it0d2d63f8oq1tctpmfvii.png"><br><p>  <em>SPI-Datenanforderung im ROM</em> </p><br><p>  Zwei Anfragen von zwei Bytes schienen interessant.  Die Suche in IDA 0x00, 0x80 und 0xEB ergab eine Vielzahl von Ergebnissen, die ich nicht analysierte, aber Byte 0x5A kam seltener vor. </p><br><img src="https://habrastorage.org/webt/sv/ym/kf/svymkfdb-0nsj764k8igczukjj0.png"><br><p>  <em>Vergleich mit Byte 0x5A.</em>  <em>Prüfsumme zählen-8</em> </p><br><p>  Der sechste Klick führte mich buchstäblich zu dem in der obigen Abbildung gezeigten Codeabschnitt.  Es ist zu erkennen, dass der Wert aus dem Register mit der Adresse 0x80 <strong>7E</strong> mit 0x5A verglichen wird.  Dann wird die Prüfsumme-8 für Werte von Adresse 0x80 <strong>04</strong> bis 0x80 <strong>7E</strong> gelesen.  Als nächstes wird der Wert bei 0x80 <strong>7F</strong> mit dem zuvor empfangenen Betrag verglichen. </p><br><img src="https://habrastorage.org/webt/j4/ao/x2/j4aox2tkbow4wzw57rrbprixw9u.png"><br><p>  <em>Der Beginn des Speichers im ROM</em> </p><br><p>  Solche Offsets ähnelten dem Beginn eines Speicherauszugs aus dem ROM.  Die obige Abbildung zeigt, dass die Adresse 0x7E das Byte 0x5A enthält.  Und wenn Sie die Prüfsumme 8 für Bytes von der Position 0x04 bis 0x7E zählen, erhalten wir 0xA7, und dieser Wert liegt nur an der Adresse 0x7F. </p><br><p>  Auf ähnliche Weise gelang es uns, die Berechnung der Prüfsumme für Bytes von der Adresse 0x0082 bis 0x807F (anscheinend ist dies der gesamte Code) zu finden, die mit dem Byte an der Adresse 0x8083 überprüft wird.  Und bei 0x8082 liegt wieder der Wert 0x5A. </p><br><p>  Ja, das ist etwas komplizierter als nur die Zeilen im Speicher zu ändern.  Ich habe sie auch geändert, aber ich habe auch die Prüfsummen für die neue Datei an den richtigen Stellen berechnet und notiert.  Danach sah ich als Antwort auf den Befehl SCSI INQUIRY meine Zeilen. </p><br><p>  <strong><em>Schlussfolgerungen:</em></strong> </p><br><ol><li>  Während des Startvorgangs versucht der ASM1051, Code aus dem ROM herunterzuladen. </li><li>  Zunächst vergleicht das ASM1051 das Prüfsummen-8-Byte von Adresse 0x04 bis 0x7E mit dem Wert bei 0x7F. </li><li>  Wenn der Vergleich der Prüfsumme für die Präambel erfolgreich ist, können wir ihn für den "Code" (Adressen von 0x0082 bis 0x807F) berücksichtigen.  ASM1051 vergleicht diesen Wert mit dem Wert an Adresse 0x8083 und überprüft, ob sich Byte 0x5A an Adresse 0x8082 befindet. </li><li>  Wenn alle Überprüfungen korrekt sind, wird der ASM1051 aus dem ROM geladen, andernfalls wird die Maskenfirmware verwendet. </li></ol><br><h2 id="nahodka--2">  Finde Nummer 2 </h2><br><p>  Beim Überprüfen und Kommentieren von Funktionen stellte ich fest, dass die PRINTF-Funktion sehr häufig im Code verwendet wird (ich habe es so genannt).  Das Interessante daran ist, dass vor dem Aufrufen ein <strong>gedrucktes</strong> Zeichen in das R7-Register geschrieben wird. </p><br><img src="https://habrastorage.org/webt/fn/0a/9a/fn0a9aafvgus1v4emxuf6j9kbea.png"><br><p>  <em>PRINTF-Funktion in IDA Pro</em> </p><br><p>  Die Funktion selbst wurde in der obigen Abbildung dargestellt.  Lass uns mit ihr umgehen.  Zunächst müssen Sie den Wert aus dem Register mit der Adresse 0x7F6 in die Batterie verschieben.  Wenn es Null gibt, beenden Sie die Funktion.  Das Interessanteste passiert, wenn es nicht Null gibt.  Dann wird der Wert des Registers R7 in das Register mit der Adresse 0xC001 verschoben, und, wie wir uns erinnern, wird vor dem Aufruf dieser Funktion ein gedrucktes Zeichen in R7 geschrieben.  Überprüfen Sie anschließend, ob der Wert in R7 dem Zeichencode „.“ Entspricht. Wenn nicht, beenden Sie die Funktion.  Wenn der Vergleich jedoch erfolgreich war, entnimmt die Funktion den Wert aus dem Register mit der Adresse 0x16A und verschiebt ihn nach 0xC001, was jedoch schwierig ist.  Beispielsweise wird die Funktion anstelle von Byte <strong>0x41</strong> (Zeichen "A" in ASCII) zu 0xC001 Byte 0x34 (Zeichen <strong>"4"</strong> in ASCII) und dann zu 0x31 (Zeichen <strong>"1"</strong> in ASCII) verschoben.  Beenden Sie die Funktion erneut. </p><br><p>  Ich habe festgestellt, dass die Prüfung zu Beginn der Funktion nicht bestanden werden kann, da das Register mit der Adresse 0x7F6 auf Null initialisiert ist, dann ändert sich der Code nicht.  Das heißt, diese Funktion wird vom Programmierer deaktiviert, obwohl sie kompiliert bleibt.  Die Tatsache, dass Bytes nur in das 0xC001-Register geschrieben werden (und manchmal zwei in einer Reihe), legte nahe, dass dies höchstwahrscheinlich ein Hardware-Register ist. </p><br><p>  All dies ähnelt UART.  Um herauszufinden, ob dies der Fall ist, müssen Sie folgende Schritte ausführen: </p><br><ol><li>  Identifizieren Sie die Beine auf dem ASM1051, an denen der UART ausgegeben wird. </li><li>  Definieren Sie UART-Parameter (Geschwindigkeit, Parität, Anzahl der Stoppbits). </li><li>  Es wäre schön, UART im Code zu aktivieren (anscheinend ist es deaktiviert). </li></ol><br><p>  Alles sieht ganz einfach aus: Sie können abwechselnd mit einem logischen Analysator die Beine berühren und nach dem suchen, auf dem der Moment des Sendens des UART sichtbar wird.  Bei Vorhandensein eines Signals kann die Geschwindigkeit durch die Zeit der Impulse bestimmt werden.  Mit den restlichen Parametern ist auch alles klar, sehen Sie nur den Moment des Sendens eines Bytes auf dem Analysator. </p><br><p>  Um diese Funktion zu "aktivieren", können Sie anstelle der ersten drei Zeilen Nullen schreiben, wobei der Wert im Register mit der Adresse 0x7F6 geprüft wird.  Dazu öffne ich nochmal die Firmware in WinHex. </p><br><img src="https://habrastorage.org/webt/rm/rw/mg/rmrwmgen5bw46g0r1a7uchsnkog.png"><br><p>  <em>Es werden sechs zurückzusetzende Bytes zugewiesen.</em> </p><br><p>  Im Editor ändere ich die gewünschten sechs Bytes in Nullen.  Jetzt ist die Firmware fertig und kann auf den ROM-Emulator heruntergeladen werden.  Wenn wir annehmen, dass die Funktion zur Ausgabe von Bytes in UART aktiviert ist und ihr Aufruf sehr häufig im gesamten Code enthalten ist, können wir erwarten, dass die Bytes von der UART "fliegen", wenn der Adapter ausgeführt wird.  Ich hoffe, einen Tracer zu sehen, der in Bytes im UART anzeigt, wie viel Code ausgeführt wird. </p><br><p>  Wie ich oben geschrieben habe, können Sie sich den Logikanalysator einzeln ansehen, um die erforderlichen Rx- und Tx-Zweige zu finden.  Ich ging jedoch davon aus, dass sich Rx und Tx des ASM1051 an derselben Stelle befinden wie die ASM1053 - Beine 40 bzw. 41.  Ich habe die Analysesonde an Pin 41 (angenommener Tx) angeschlossen und sehe etwas Ähnliches wie das gewünschte Signal: </p><br><img src="https://habrastorage.org/webt/qn/s7/rq/qns7rq-nxvqvqcgzlo4hwqb7spc.png"><br><p>  <em>Zeitdiagramm mit Schenkel 41 - Tx</em> </p><br><p>  Um den USB-UART-Konverter anzuschließen und die eingehenden gedruckten Zeichen im Terminal zu beobachten, musste ich zwei dünne Kabel direkt auf die Adapterplatine löten und mit Heißkleber befestigen. </p><br><img src="https://habrastorage.org/webt/jn/x2/-f/jnx2-fwuhcewoy4aodelx7ugqbk.jpeg"><br><p>  <em>Zwei Kabel an RX und TX angelötet</em> </p><br><p>  Ich habe das Diagramm aus der Abbildung „Zeitdiagramm von Abschnitt 41 - Tx“ ein wenig studiert: Die Zeit eines Impulses beträgt anscheinend 1 μs und für sechs Bits 6,3 μs.  Nachdem ich den Wert in Baud neu berechnet hatte, erhielt ich ungefähr 950.000 Baud, die nächste Standard-UART-Geschwindigkeit ist 921600 Baud.  Ich denke, diese Diskrepanz ergibt sich aus dem Messfehler des logischen Analysators, ich habe nicht das würdigste Gerät genommen, sondern das chinesische „Baby“.  Nachdem ich die Parameter im Fenster des Terminal 1.9b-Programms eingestellt hatte, konnte ich eingehende Bytes vom ASM1051 MK während des Betriebs beobachten. </p><br><img src="https://habrastorage.org/webt/fa/de/pc/fadepckvko4t2dyacaqt93hidao.png"><br><p>  <em>Programmfenster von Terminal 1.9b während des Adapterbetriebs</em> </p><br><p>  <strong><em>Fazit:</em></strong> </p><br><p>  Das ASM1051 MK verfügt über ein UART-Hardwaremodul.  Das Register zum Senden von Daten hat die Adresse 0xC001.  Die Datenrate beträgt 921600 Baud.  Es gibt ein Stoppbit.  Leg 41 ist Tx und Leg 40 ist Rx (obwohl dies nicht genau ist). </p><br><h2 id="nahodka--3">  Finde Nummer 3 </h2><br><p>  Durch Scrollen durch den Code im Disassembler und Hinzufügen von Kommentaren können Sie Konstruktionen schwieriger finden, als eine Zahl in ein Register zu schreiben.  Also bin ich auf einen interessanten Handler gestoßen, von dem ein Teil in C wie <code>switch ()</code> aussah. </p><br><img src="https://habrastorage.org/webt/zq/ra/nr/zqranrtexseqh7xpj0ynpjav9su.png"><br><p>  <em>Der Befehlshandler aus dem Register mit der Adresse 0x800F</em> </p><br><p>  Als ich begriff, dass irgendwo <a href="https://en.wikipedia.org/wiki/SCSI_command">SCSI-Befehle</a> verarbeitet <a href="https://en.wikipedia.org/wiki/SCSI_command">werden</a> müssen, begann ich, nach Bytes zu suchen, mit denen der Inhalt des Registers mit der Adresse 0x800F in der obigen Abbildung verglichen wird.  Es stellte sich heraus, dass die ersten vier Zweige die Befehle Lesen (10), Schreiben (10), Lesen (16), Schreiben (16) prüfen.  Es besteht kein Zweifel, dass dies ein SCSI-Befehlshandler ist.  Als nächstes habe ich mir eine Funktion angesehen, die aufgerufen wird, wenn der eingehende Befehl nicht Read / Write (u_Switch) ist.  Es liest abhängig vom Byte im Register mit der Adresse 0x16A (der Wert wird von 0x800F übernommen) die Adresse, zu der wir gelangen, wenn sie diese Funktion verlassen.  Dies ähnelt <code>switch ()</code> . </p><br><img src="https://habrastorage.org/webt/8c/ni/xf/8cnixfxf9a1bcyzv0ttlsgpmcqo.png"><br><p>  <em>SCSI-Befehle wechseln</em> </p><br><p>  Da ich bereits das Byte ermittelt habe, mit dem ich den in den Adapter eingegangenen SCSI-Befehl vergleiche, habe ich die Adresszuordnung schnell nach Befehlen geordnet.  In der obigen Abbildung ist beispielsweise zu sehen, dass nach dem Verlassen der Funktion u_Switch die Adresse 0x1B85 angegeben wird, wenn das Byte 0x1A im Register mit der Adresse 0x16A enthalten ist.  Interessanterweise sind nicht alle Bytes im Vergleich zu u_Switch im SCSI-Standard definiert.  Das heißt, der Adapter kann die Bytes 0xE6 oder 0xDF verarbeiten, diese sind jedoch nicht durch den Standard festgelegt. </p><br><p>  Wie Sie sehen, kann der Adapter benutzerdefinierte Befehle ausführen, für die es Handlerfunktionen gibt. </p><br><img src="https://habrastorage.org/webt/4m/kn/bz/4mknbzam6xol2fhb750trvrxs_c.png"><br><p>  <em>Seite 13 der <a href="https://usb.org/sites/default/files/usbmassbulk_10.pdf">Universal Serial Bus-Massenspeicherklasse</a></em> </p><br><p>  <strong>Achten Sie</strong> auf den Offset <strong>0x0F</strong> zur Adresse 0x8000.  Vor dem Prozessor wird der SCSI-Befehl aus dem Register mit der Adresse 0x800F gelesen.  Wenn Sie die Tabelle in der obigen Abbildung sorgfältig lesen, können Sie feststellen, dass das CBWCB-Feld im Command Block Wrapper (CBW) auch einen Offset von <strong>0x0F aufweist</strong> .  Es stellt sich heraus, dass die Adressen des ASM1051-RAM-Speichers, beginnend mit 0x8000, ein USB-Puffer sein können, wie in der folgenden Tabelle gezeigt. </p><br><div class="scrollable-table"><table><thead><tr><th>  Speicheradresse </th><th>  Beschreibung </th></tr></thead><tbody><tr><td>  0x8000-0x8003 </td><td>  dCBWSignature (USBC - bei Empfang eines Pakets) </td></tr><tr><td>  0x8004-0x8007 </td><td>  dCBWTag </td></tr><tr><td>  0x8008-0x800B </td><td>  dCBWDataTransferLength </td></tr><tr><td>  0x800C </td><td>  bmdCBWFlag </td></tr><tr><td>  0x800D </td><td>  bCBWLUN </td></tr><tr><td>  0x800E </td><td>  bCBWCBLength </td></tr><tr><td>  0x800F-0x801F </td><td>  CBWCB - SCSI-Befehl und seine Parameter </td></tr></tbody></table></div><br><p>  Die folgende Abbildung zeigt den Codeabschnitt, in dem der Vergleich mit der USBC-Zeichenfolge erfolgt (dies sollte die Signatur dCBWSignature sein) und die vorgeschlagene Signatur von der Adresse 0x8000 stammt.  Ich denke, dies reicht aus, um sicherzustellen, dass sich der USB-Puffer ab 0x8000 im RAM-Speicher befindet. </p><br><img src="https://habrastorage.org/webt/-t/et/eo/-teteok9i6rotmpp1w6wxy0bun4.png"><br><p>  <em>Überprüfen Sie das Feld dCBWSignature auf Übereinstimmung mit der USBC-Zeichenfolge</em> </p><br><p>  <strong><em>Schlussfolgerungen:</em></strong> </p><br><ol><li>  MK ASM1051 kann nicht nur SCSI-Befehle verarbeiten, die im Standard beschrieben sind. </li><li>  Die Startadresse des USB-Puffers ist 0x8000.  Der SCSI-Befehl befindet sich im Register mit der Adresse 0x800F, was bedeutet, dass weitere Daten / Argumente der Befehle vorhanden sind. </li></ol><br><h2 id="nahodka--4">  Finde Nummer 4 </h2><br><p>  Da ich wusste, dass MK nicht standardmäßige Teams verarbeiten kann, wollte ich wissen, was sie tun.  Die meisten von ihnen gehorchten mir schnell.  Ich werde das Studium des Codes dieser Befehle nicht zitieren, da dies lange dauern kann und für einen separaten Artikel mit dem Titel „Assembler ist einfach“ von Bedeutung sein kann. Die Ergebnisse werde ich in der folgenden Tabelle beschreiben. </p><br><div class="scrollable-table"><table><thead><tr><th>  SCSI-Befehl </th><th>  Teambeschreibung </th></tr></thead><tbody><tr><td>  0xE0 </td><td>  Ermöglicht das Lesen der ersten 0x80-Bytes aus dem ROM.  In Zukunft werde ich diesen Teil des Speichers als <em>Präambel bezeichnen</em> (ja, dieselben 0x80-Bytes, in denen sich die Zeilen <code>asmedia</code> und <code>ASM1051</code> ). </td></tr><tr><td>  0xE1 </td><td>  Schreibt die ersten 0x80-Bytes in das ROM </td></tr><tr><td>  0xE3 </td><td>  Schreibt eine beliebige Anzahl von Bytes von 0x80-Adressen in den ROM-Speicher.  Das Argument (wie sich herausstellte) ist die Größe des Pakets </td></tr><tr><td>  0xE4 </td><td>  Liest den Byteblock des ASM1051 RAM.  Nimmt als Argument die Startadresse und die Anzahl der gelesenen Bytes </td></tr><tr><td>  0xE5 </td><td>  Schreibt ein Byte in den RAM um </td></tr><tr><td>  0xE7 </td><td>  Liest das zuletzt empfangene Paket in den ATA-Puffer. </td></tr><tr><td>  0xE8 </td><td>  Startet das Gerät neu </td></tr></tbody></table></div><br><p>  Ich gebe zu, dass ich nicht alle Befehle durch Lesen von Funktionen in der IDA herausgefunden habe.  Nachdem ich während der Recherche gegen die Wand gestoßen war, fiel mir ein, dass ich <a href="https://www.usbdev.ru/files/asmedia/asm105mptool/">Software und viele Firmware</a> für das ASM1051 gesehen hatte, als ich nach Dokumentation suchte.  Mit der gefundenen Software können Sie die Firmware aktualisieren und das Gerät neu starten.  Daher entschied ich, dass es Zeit war, <a href="https://www.syssoft.ru/HHD-Software/Device-Monitoring-Studio/">Device Monitoring Studio zu verwenden</a> und zu sehen, was den PC während des Updates an den Adapter sendet. </p><br><p>  Auf diese Weise konnte nachvollzogen werden, wie die Aktualisierung der Firmware abläuft: Zuerst wird die Präambel gesendet (mit dem Befehl 0xE1), dann wird der Code mit dem Befehl 0xE3 geschrieben und anschließend durch einen Neustart (Befehl 0xE8) poliert.  Für ein schnelles und bequemes Update habe ich ein Python-Skript geschrieben, das die erforderlichen Zeilen in die Präambel einfügt, dann die Prüfsummen liest und das Gerät aktualisiert.  Jetzt brauche ich keinen Emulator mehr, ich hatte die Möglichkeit, Firmware über USB auf das ASM1051 hochzuladen, Sie können das native ROM auf die Karte zurückschicken. </p><br><p>  <strong><em>Schlussfolgerungen</em></strong> </p><br><p>  Um die Firmware zu aktualisieren, müssen drei SCSI-Befehle nacheinander ausgeführt werden: 0xE1, 0xE3 und 0xE8. </p><br><h2 id="nahodka--5">  Finde Nummer 5 </h2><br><p>  Neben den undokumentierten Befehlen war es interessant, die Handler von Standardbefehlen zu betrachten. </p><br><img src="https://habrastorage.org/webt/be/9e/st/be9estiir9g45o0thkj4bacvsmm.png"><br><p>  <em>Verschieben des dritten Bits vom Register 0xC884 zum siebten Bit des Registers 0x8002</em> </p><br><p>  Es gibt einen interessanten Test im Handler des SCSI-Befehls MODE SENSE (10).  Die obige Abbildung zeigt einen Teil des Funktionscodes.  Es ist zu sehen, dass das dritte Bit aus dem <strong>0xC884-</strong> Register gelesen wird.  Dann wird der Wert dieses Bits im Register auf 0x8002 gesetzt. </p><br><p>  Interessant ist hier, dass das <strong>0xC884-</strong> Register an keiner Stelle im Code initialisiert ist, was bedeutet, dass es sich höchstwahrscheinlich um Hardware handelt. </p><br><img src="https://habrastorage.org/webt/fc/mw/sh/fcmwsh6pa3zzkpbsfxxici-t4g4.jpeg"><br><p>  <em>Tabelle 362 des <a href="https://www.seagate.com/files/staticfiles/support/docs/manual/Interface%2520manuals/100293068j.pdf">SCSI-Befehlsreferenzhandbuchs</a></em> </p><br><p>  Wenn Sie sich die Dokumentation zum 0x5A- <a href="https://www.seagate.com/files/staticfiles/support/docs/manual/Interface%2520manuals/100293068j.pdf">SCSI-Befehl</a> (MODE SENSE) ansehen, wird außerdem klar, dass der USB-SATA-Adapter auf die MODE SENSE-Anforderung reagieren sollte.  Das dritte Byte der Antwort enthält das siebte Bit von WP (Schreibschutz - Schreibschutz).  Übrigens habe ich bereits das <strong>siebte</strong> Bit in 0x8002 gesehen, und der <strong>Versatz</strong> vom Anfang des USB-Puffers (0x8000) beträgt hier genau <strong>3</strong> . </p><br><p>  <strong><em>Fazit:</em></strong> </p><br><p>  Der getestete USB-SATA-Adapter liest das dritte Bit aus dem Hardwareregister bei <strong>0xC884</strong> und sendet es als WP-Bit an den USB-Host. </p><br><h2 id="nahodka--6">  Suchen Sie die Nummer 6 </h2><br><p>  Das Hardware-Register, das bei der Untersuchung des SCSI-Befehlshandlers MODE SENSE gefunden wurde, ist dem GPIO sehr ähnlich.  Um dies zu bestätigen, entschloss ich mich, die ASM1051-Beine mit einem aktiven Widerstand zu berühren und den Registerwert (SCSI-Befehl 0xE4) mit der Adresse <strong>0xC884 auszulesen</strong> .  Dazu habe ich ein Python-Skript mit benutzerdefinierten SCSI-Befehlen geschrieben, das den Wert im <strong>0xC884-</strong> Register überwacht und auf dem PC anzeigt. </p><br><div class="scrollable-table"><table><thead><tr><th>  Bits 0xC884 </th><th>  7 </th><th>  6 </th><th>  5 </th><th>  4 </th><th>  3 </th><th>  2 </th><th>  1 </th><th>  0 </th></tr></thead><tbody><tr><td>  Bein ASM1051 </td><td>  - </td><td>  - </td><td>  37 </td><td>  - </td><td>  9 </td><td>  10 </td><td>  45 </td><td>  44 </td></tr></tbody></table></div><br><p>  Nach einem solchen Experiment habe ich eine Tabelle zusammengestellt, in der ich angezeigt habe, welche Bits im <strong>0xC884-</strong> Register sich geändert haben, als der ASM1051-Widerstand die Beine berührt hat.  Es stellt sich heraus, dass das untersuchte Register eng mit dem GPIO verbunden ist, der Versuch, darauf zu schreiben (mit dem SCSI-Befehl 0xE5), jedoch fehlgeschlagen ist - der Wert hat sich nicht geändert. </p><br><p>  Dann habe ich entschieden, dass dieses Register entweder schreibgeschützt ist oder dass das Schreiben in dieses Register auf Hardwareebene verboten ist.  Wenn zum Beispiel die MK-Beine ursprünglich nur zum Lesen eingerichtet waren, ist das Schreiben in das <strong>0xC884-</strong> Register möglicherweise nicht verfügbar. </p><br><p>  Um die dem GPIO zugeordneten Register zu finden, habe ich im Allgemeinen den Initialisierungscode MK durchgesehen.  Ich habe alle Register aufgeschrieben, deren Adressen in der Nähe von <strong>0xC884 liegen</strong> .  Ich habe ungefähr 10 von ihnen. Ich erinnere Sie daran, dass der zehnte Zweig des MK mit der LED auf der Platine verbunden ist, es entspricht dem zweiten Bit im Register <strong>0xC884</strong> .          – <strong>0880</strong> ,            (,    ).  ,   ,   <strong>0880</strong>      (/),   <strong>0884</strong>   ,  - . </p><br><p>         <strong>0880</strong>    ,    <strong>0884</strong>    .     <strong>0884</strong>  .           ASM1051. </p><br><p> <strong><em>:</em></strong> </p><br><p>    GPIO  ASM1051.    <strong>0880</strong>   /   I/O.  0884    I/O. </p><br><h2 id="nahodka--5-prodolzhenie">  № 5.  </h2><br><p>   GPIO-  ,  45-           <strong>0884</strong> .           <strong>WP</strong> ,    USB.       45-    ,    HDD,     ,  . </p><br><img src="https://habrastorage.org/webt/9m/yq/lv/9myqlvzd8guku1qfcllendjrtcc.png"><br><p> <em>     HDD,      45-  </em> </p><br><p>     .       GND 45-      ,      HDD.     . </p><br><p>  <strong><em>Fazit</em></strong> </p><br><p>   45-  ASM1051         HDD. </p><br><h1 id="razrabotka-sobstvennogo-ustroystva">    </h1><br><p>       USB-SATA-.           ASM1051.   ,  -  ,     .   ,     GPIO.    –  ASM1051  ,         HDD. ,   ,     («     »),     ,  ,         USB-SATA-   ASM1051. </p><br><p> ,           footprint  ASM1051,       datasheet  ASM1053.     ,        ASM1051   . </p><br><img src="https://habrastorage.org/webt/mf/9k/pi/mf9kpiav5oxxejflxjfndixzccy.jpeg"><br><p> <em>ASM1051     </em> </p><br><p>    ,       3D- ,    . </p><br><img src="https://habrastorage.org/webt/4n/vk/ea/4nvkearirndsx2wx6lzbv2--iu0.png"><br><p> <em>3D-      </em> </p><br><p>            <strong>WP</strong> .  GPIO ASM1051      ,   UART.  ,      SATA,     HDD.      USB 3.0 Micro-B     Type-C.  HDD      USB,   HDD 3.5"  +12 ,           12  21 .     . </p><br><img src="https://habrastorage.org/webt/zh/ji/wu/zhjiwuyqzibs09gswjbdlths-_g.jpeg"><br><p> <em>    </em> </p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>       ,       . </p><br><p>           -,    ,   .         « «»,          .        ,       . </p><br><p>   ,    (,   )   embedded-. ,  ,       .      ,    ,    , ,         . </p><br><p>       ,   datasheets,    ,   .       ,  <strong>   !</strong> </p><br><p> <a href="https://raccoonsecurity.ru/"><img src="https://habrastorage.org/webt/6d/ts/lv/6dtslv2uikkshhl7tmsi7fgjp0y.png"></a> </p><br><p> <em>Raccoon Security –     «»     , , ,       .</em> <br> <em>        ,         ,     .       <a href="https://raccoonsecurity.ru/internship/"></a> .</em> </p><cut></cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de485966/">https://habr.com/ru/post/de485966/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de485950/index.html">Epidemie und Zensur: Versuchen die chinesischen Behörden, die Verbreitung von Informationen über das Coronavirus einzuschränken?</a></li>
<li><a href="../de485952/index.html">CLI-Schnittstelle für Laravel Artisan</a></li>
<li><a href="../de485954/index.html">Java Digest für den 28. Januar</a></li>
<li><a href="../de485958/index.html">[Administratorübersicht] Was ist, wenn das Programm Administratorrechte benötigt und Sie dies nicht tun?</a></li>
<li><a href="../de485962/index.html">Persönliche Recherche zu 2019-nCoV</a></li>
<li><a href="../de485968/index.html">Und wieder Bypass-Schlösser. RouterOS + BGP + OSPF</a></li>
<li><a href="../de485970/index.html">Kürzlich 30 Top-Interviews: Entwicklung, Design, Sciencepop und Lebensstil</a></li>
<li><a href="../de485972/index.html">Regressionsanalysemethoden in Data Science</a></li>
<li><a href="../de485974/index.html">Raspberry Pi und SIM7600E 4G HAT Modem</a></li>
<li><a href="../de485986/index.html">Top 5 Lokalisierungstrends im Jahr 2020</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>