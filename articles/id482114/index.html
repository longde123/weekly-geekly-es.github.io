<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö¥ üë®üèª üññ Kirim email menggunakan asyncio dan aiohttp dari aplikasi Django üê§ üó®Ô∏è üîá</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! 

 Saya mengembangkan dan mendukung layanan notifikasi di Ostrovok.ru . Layanan ini ditulis dalam Python3 dan Django. Selain surat tran...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kirim email menggunakan asyncio dan aiohttp dari aplikasi Django</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ostrovok/blog/482114/">  Halo semuanya! <br><br>  Saya mengembangkan dan mendukung layanan notifikasi di <a href="https://www.ostrovok.ru/%3Futm_source%3Dhabr%26utm_medium%3Dpr%26utm_campaign%3Dporyvaev_dec19%26utm_content%3Darticle">Ostrovok.ru</a> .  Layanan ini ditulis dalam Python3 dan Django.  Selain surat transaksional, push, dan pesan, layanan ini juga melakukan tugas pengiriman massal penawaran komersial (bukan spam! Percayalah, berhenti berlangganan berfungsi lebih baik daripada berlangganan) untuk pengguna yang telah memberikan izin untuk ini.  Seiring waktu, basis penerima yang aktif tumbuh menjadi lebih dari satu juta alamat, yang layanan suratnya belum siap.  Saya ingin berbicara tentang bagaimana fitur Python baru memungkinkan untuk mempercepat pengiriman massal dan menghemat sumber daya dan masalah apa yang harus kami tangani saat bekerja dengan mereka. <br><br><img src="https://habrastorage.org/webt/qj/b-/xa/qjb-xaiilstmnucwa2xko6onw34.png"><br><a name="habracut"></a><br><h3>  Implementasi sumber </h3><br>  Awalnya, surat massal dilaksanakan dengan cara paling sederhana: untuk setiap penerima, tugas ditempatkan dalam antrian yang diambil oleh salah satu dari 60 pekerja massa (fitur dari antrian kami adalah bahwa setiap pekerja bekerja dalam proses yang terpisah), menyiapkan konteks untuk itu, membuat templat, mengirim Permintaan HTTP ke Mailgun untuk mengirim surat dan membuat catatan dalam database bahwa surat itu dikirim.  Keseluruhan pengiriman memakan waktu hingga 12 jam, mengirimkan sekitar 0,3 surat per detik dari setiap pekerja dan memblokir pengiriman kampanye kecil. <br><br><img src="https://habrastorage.org/webt/qk/7p/sg/qk7psgslwi6wa0vyhjaafg7bqkq.png"><br><br><h3>  Solusi asinkron </h3><br>  Pembuatan profil cepat menunjukkan bahwa sebagian besar waktu yang dihabiskan pekerja untuk membangun koneksi dengan Mailgun, jadi kami mulai mengelompokkan tugas menjadi potongan-potongan, dengan potongan untuk setiap pekerja.  Pekerja mulai menggunakan satu koneksi dengan Mailgun, yang memungkinkan untuk mengurangi waktu pengiriman hingga 9 jam, mengirimkan setiap pekerja rata-rata 0,5 huruf per detik.  Profiling berikutnya lagi menunjukkan bahwa bekerja dengan jaringan masih memakan sebagian besar waktu, yang mendorong kami untuk menggunakan asyncio. <br><br>  Sebelum memasukkan semua pemrosesan ke dalam siklus asyncio, kami harus memikirkan solusi untuk sejumlah masalah: <br><br><ol><li>  Django ORM belum dapat bekerja dengan asyncio, namun, ia melepaskan GIL selama eksekusi permintaan.  Ini berarti bahwa kueri basis data dapat dieksekusi di utas terpisah dan tidak memblokir loop utama. </li><li>  Versi aiohttp saat ini membutuhkan Python versi 3.6 dan lebih tinggi, yang pada saat implementasi diperlukan memperbarui gambar buruh pelabuhan.  Eksperimen pada versi aiohttp dan Python 3.5 yang lebih lama menunjukkan bahwa kecepatan pengiriman pada versi ini jauh lebih rendah daripada versi yang lebih baru, dan dapat dibandingkan dengan pengiriman berurutan. </li><li>  Menyimpan sejumlah besar asyncio corutin dengan cepat menyebabkan pengeluaran semua memori.  Ini berarti bahwa tidak mungkin untuk melakukan pra-persiapan semua coroutine untuk surat-surat dan menyebabkan siklus untuk memprosesnya, perlu untuk mempersiapkan data saat Anda mengirim surat yang sudah terbentuk. </li></ol><br>  Mempertimbangkan semua fitur, kami akan membuat di dalam masing-masing pekerja kami siklus asyncio kami dengan kesamaan pola ThreadPool, yang terdiri dari: <br><br><ul><li>  Satu atau lebih produsen bekerja dengan database melalui Django ORM di utas terpisah melalui asyncio.ThreadPoolExecutor.  Pabrikan mencoba untuk menggabungkan permintaan akuisisi data ke dalam kelompok-kelompok kecil, menjadikan template untuk data yang diterima melalui Jinja2 dan menambahkan data untuk dikirim ke antrian tugas. </li></ul><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_campaign_send_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ids: Iterable[int])</span></span></span><span class="hljs-function"> -&gt; Iterable[Mapping[str, Any]]:</span></span> <span class="hljs-string"><span class="hljs-string">"""    ,     Django ORM   ."""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [{<span class="hljs-string"><span class="hljs-string">'id'</span></span>: id} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ids] <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mail_campaign_producer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ids: Iterable[int], task_queue: asyncio.Queue)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""           ,    .      ,     ThreadPoolExecutor. """</span></span> loop = asyncio.get_event_loop() total = len(ids) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> subchunk_start <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, total, PRODUCER_SUBCHUNK_SIZE): subchunk_ids = ids[subchunk_start : min(subchunk_start + PRODUCER_SUBCHUNK_SIZE, total)] send_tasks = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> loop.run_in_executor(<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, get_campaign_send_data, subchunk_ids) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> task <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> send_tasks: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> task_queue.put(task)</code> </pre> <br><ul><li>  Beberapa ratus pengirim surat - asyncio coroutine, yang dalam siklus tanpa akhir membaca data dari antrian tugas, mengirim permintaan jaringan untuk masing-masing dan memasukkan hasilnya (respons, atau pengecualian) dalam antrian laporan. <br></li></ul><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_mail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data: Mapping[str, Any], session: aiohttp.ClientSession)</span></span></span><span class="hljs-function"> -&gt; Union[Mapping[str, Any], Exception]:</span></span> <span class="hljs-string"><span class="hljs-string">"""    ."""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> session.post(REQUEST_URL, data=data) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> response: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> response.status_code != <span class="hljs-number"><span class="hljs-number">200</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> Exception <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mail_campaign_sender</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( task_queue: asyncio.Queue, result_queue: asyncio.Queue, session: aiohttp.ClientSession )</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""        .     task_done,    ,   . """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: task_data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> task_queue.get() result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> send_mail(task_data, session) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> result_queue.put(result) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> asyncio.CancelledError: <span class="hljs-comment"><span class="hljs-comment">#     raise except Exception as exception: #     await result_queue.put(exception) finally: task_queue.task_done()</span></span></code> </pre><br><ul><li>  Satu atau lebih pekerja yang mengelompokkan data dari antrian laporan dan memberikan informasi tentang hasil pengiriman surat ke database massal dengan permintaan. </li></ul><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_campaign_results</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(results: Iterable[Union[Mapping[str, Any], Exception]])</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""  :         """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mail_campaign_reporter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(task_queue: asyncio.Queue, result_queue: asyncio.Queue)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""          ThreadPoolExecutor,        . """</span></span> loop = asyncio.get_event_loop() results_chunk = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: results_chunk.append(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> result_queue.get()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(results_chunk) &gt;= REPORTER_BATCH_SIZE: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> loop.run_in_executor(<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, process_campaign_results, results_chunk) results_chunk.clear() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> asyncio.CancelledError: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> loop.run_in_executor(<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, process_campaign_results, results_chunk) results_chunk.clear() <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>: result_queue.task_done()</code> </pre><br><ul><li>  Antrian tugas, yang merupakan turunan dari asyncio.Queue, dibatasi oleh jumlah maksimum elemen sehingga pabrikan tidak memenuhi sampai melimpahi, menghabiskan semua memori. </li><li>  Laporkan antrian, juga merupakan instance dari asyncio.Queue dengan batas jumlah item maksimum. </li><li>  Metode asinkron yang membuat antrian, pekerja, dan menyelesaikan distribusi dengan menghentikannya. </li></ul><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_mail_campaign</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( recipient_ids: Iterable[int], session: aiohttp.ClientSession, loop: asyncio.AbstractEventLoop = None )</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""       .    ,       . """</span></span> executor = ThreadPoolExecutor(max_workers=PRODUCERS_COUNT + <span class="hljs-number"><span class="hljs-number">1</span></span>) loop = loop <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> asyncio.get_event_loop() loop.set_default_executor(executor) task_queue = asyncio.Queue(maxsize=<span class="hljs-number"><span class="hljs-number">2</span></span> * SENDERS_COUNT, loop=loop) result_queue = asyncio.Queue(maxsize=<span class="hljs-number"><span class="hljs-number">2</span></span> * SENDERS_COUNT, loop=loop) producers = [ asyncio.ensure_future(mail_campaign_producer(recipient_ids, task_queue)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(PRODUCERS_COUNT) ] consumers = [ asyncio.ensure_future(mail_campaign_sender(task_queue, result_queue, session)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(SENDERS_COUNT) ] reporter = asyncio.ensure_future(mail_campaign_reporter(task_queue, result_queue)) <span class="hljs-comment"><span class="hljs-comment"># ,      done, _ = await asyncio.wait(producers) #    ,   await task_queue.join() while consumers: consumers.pop().cancel() #    ,     await result_queue.join() reporter.cancel()</span></span></code> </pre><br><ul><li>  Kode sinkron yang menciptakan loop dan memulai distribusi. </li></ul><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close_session</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(future: asyncio.Future, session: aiohttp.ClientSession)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""  ,    .  aiohttp      . """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.wait([future]) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">0.250</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> session.close() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mail_campaign_send_chunk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(recipient_ids: Iterable[int])</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""     .   ,  asyncio     . """</span></span> loop = asyncio.new_event_loop() asyncio.set_event_loop(loop) <span class="hljs-comment"><span class="hljs-comment"># Session connector = aiohttp.TCPConnector(limit_per_host=0, limit=0) session = aiohttp.ClientSession( connector=connector, auth=aiohttp.BasicAuth('api', API_KEY), loop=loop, read_timeout=60 ) send_future = asyncio.ensure_future(send_mail_campaign(recipient_ids, session, loop=loop)) cleanup_future = asyncio.ensure_future(close_session(send_future, session)) loop.run_until_complete(asyncio.wait([send_future, cleanup_future])) loop.close()</span></span></code> </pre><br>  Setelah menerapkan solusi ini, waktu untuk mengirim surat massal dikurangi menjadi satu jam dengan volume pengiriman yang sama dan 12 pekerja yang terlibat.  Artinya, setiap pekerja mengirim 20-25 surat per detik, yang 50-80 kali lebih produktif daripada solusi asli.  Konsumsi memori pekerja dipertahankan pada tingkat awal, beban prosesor meningkat sedikit, pemanfaatan jaringan meningkat berkali-kali, yang merupakan efek yang diharapkan.  Jumlah koneksi ke database juga meningkat, karena masing-masing aliran pekerja-produsen dan pekerja yang menyimpan laporan secara aktif bekerja dengan database.  Pada saat yang sama, pekerja gratis dapat mengirimkan surat kecil saat kampanye massal dikirim. <br><br><img src="https://habrastorage.org/webt/xl/uh/uk/xluhuk6q37flgfyywloujb40eda.png"><br><br>  Terlepas dari semua keuntungannya, implementasi ini memiliki sejumlah kesulitan yang harus dipertimbangkan: <br><br><ol><li>  Harus diperhatikan saat menangani kesalahan.  Pengecualian yang tidak ditangani dapat mengakhiri pekerja, menyebabkan kampanye membeku. </li><li>  Ketika pengiriman selesai, perlu untuk tidak kehilangan laporan tentang penerima yang belum menyelesaikan potongan sampai akhir, dan menyimpannya ke database. </li><li>  Logika untuk menghentikan dimulainya kembali kampanye secara paksa menjadi semakin rumit, karena setelah menghentikan pekerja pengirim, perlu untuk membandingkan penerima mana yang dikirim surat dan mana yang tidak. </li><li>  Setelah beberapa waktu, staf dukungan Mailgun menghubungi kami dan meminta kami untuk memperlambat kecepatan pengiriman, karena layanan email mulai untuk sementara waktu menolak email jika frekuensi pengiriman mereka melebihi nilai ambang batas.  Ini mudah dilakukan dengan mengurangi jumlah pekerja. </li><li>  Tidak mungkin menggunakan asyncio jika beberapa tahap pengiriman surat akan melakukan operasi yang menuntut prosesor.  Templat rendering menggunakan jinja2 ternyata bukan operasi yang sangat intensif sumber daya dan praktis tidak berpengaruh pada kecepatan pengiriman. </li><li>  Menggunakan asyncio untuk milis memerlukan penangan antrian distribusi untuk memulai dengan proses terpisah. </li></ol><br>  Semoga pengalaman kami bermanfaat bagi Anda!  Jika Anda memiliki pertanyaan atau ide, tulis di komentar! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id482114/">https://habr.com/ru/post/id482114/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id482100/index.html">Teknologi AMP dalam email: pro, kontra, dan kemungkinan penggunaan</a></li>
<li><a href="../id482102/index.html">Habr T&J 2019: hasil tahun ini</a></li>
<li><a href="../id482104/index.html">Bagaimana menghadapi kebiasaan orang yang diprogram</a></li>
<li><a href="../id482108/index.html">Kecerdasan yang tenang. Metode untuk mengidentifikasi potensi kerentanan WEB</a></li>
<li><a href="../id482110/index.html">Linux berjalan di kartu bisnis saya</a></li>
<li><a href="../id482126/index.html">Ulasan keras untuk TensorFlow</a></li>
<li><a href="../id482128/index.html">gReebok terdeteksi. Dermatovenerolog sendiri</a></li>
<li><a href="../id482130/index.html">Penugasan skala besar hak untuk pengguna domain dari hutan yang berbeda</a></li>
<li><a href="../id482132/index.html">Salinan Tesla Cybertruck ditemukan di Moskow. Ini adalah ... Rusia LADA Samara</a></li>
<li><a href="../id482134/index.html">Perbandingan hibrida atau apa yang diharapkan pemilik headphone Meze Rumania untuk 84 990 dan 239 990 rubel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>