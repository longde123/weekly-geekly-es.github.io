<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òòÔ∏è üôãüèæ üë®üèº‚Äçüç≥ Wir verwenden zu oft Redux-Selektoren üòº üë∂ üëï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn ich die Datei {domain} /selectors.js in den gro√üen React / Redux-Projekten betrachte, mit denen ich arbeite, sehe ich oft eine riesige Liste von ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir verwenden zu oft Redux-Selektoren</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485238/"><p>  Wenn ich die Datei {domain} /selectors.js in den gro√üen React / Redux-Projekten betrachte, mit denen ich arbeite, sehe ich oft eine riesige Liste von Redux-Selektoren dieser Art: </p><br><pre><code class="plaintext hljs">getUsers(state) getUser(id)(state) getUserId(id)(state) getUserFirstName(id)(state) getUserLastName(id)(state) getUserEmailSelector(id)(state) getUserFullName(id)(state) ‚Ä¶</code> </pre> <br><p>  Auf den ersten Blick sieht die Verwendung von Selektoren nicht ungew√∂hnlich aus, aber mit der Erfahrung beginnen wir zu verstehen, dass es zu viele Selektoren geben kann.  Und es scheint, wir haben bis zu diesem Punkt √ºberlebt. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/f62/2b9/e99/f622b9e99db638c8d9405beb722cd4e2.jpg" alt="Bild"><a name="habracut"></a><br><br><h2 id="redux-i-selektory">  Redux und Selektoren </h2><br><p>  Schauen wir uns Redux an.  Was ist er, warum?  Nach dem Lesen von redux.js.org haben wir verstanden, dass Redux ein "vorhersehbarer Container zum Speichern des JavaScript-Anwendungsstatus" ist. </p><br><p>  Bei Verwendung von Redux wird empfohlen, Selektoren zu verwenden, auch wenn diese optional sind.  Selektoren sind nur Mittel, um einige Teile aus dem gesamten Zustand herauszuholen, d. H.  Funktionen der Form <code>(State) =&gt; SubState</code> .  Normalerweise schreiben wir Selektoren, um nicht direkt auf den Status zuzugreifen, und k√∂nnen dann die Ergebnisse dieser Selektoren kombinieren oder auswendig lernen.  H√∂rt sich vern√ºnftig an. </p><br><h2 id="silno-pogruzhayas-v-selektory">  Tief eingetaucht in Selektoren </h2><br><p>  Die Liste der Selektoren, die ich in der Einleitung zu diesem Artikel zitiert habe, ist charakteristisch f√ºr Code, der in Eile erstellt wurde. </p><br><p>  Stellen Sie sich vor, wir haben ein Benutzermodell und m√∂chten ihm ein neues E-Mail-Feld hinzuf√ºgen.  Wir haben eine Komponente, die erwartet <code>firstName</code> , dass <code>firstName</code> und <code>lastName</code> eingegeben werden, und jetzt wartet sie auf eine weitere <code>email</code> .  Der Logik im Code mit den Selektoren <code>getUserEmailSelector</code> und ein neues E-Mail-Feld einf√ºhrend, muss der Autor den Selektor <code>getUserEmailSelector</code> hinzuf√ºgen und ihn verwenden, um dieses Feld an die Komponente zu √ºbergeben.  Bingo! </p><br><p>  Aber ist Bingo?  Und wenn wir einen anderen Selektor bekommen, welcher wird komplizierter?  Wir werden es mit anderen Selektoren kombinieren und vielleicht kommen wir zu diesem Bild: </p><br><pre> <code class="plaintext hljs">const getUsers = (state) =&gt; state.users; const getUser = (id) =&gt; (state) =&gt; getUsers(state)[id]; const getUserEmailSelector = (id) =&gt; (state) =&gt; getUser(id)(state).email;</code> </pre> <br><p>  Die erste Frage stellt sich: Was soll der Selektor <code>getUserEmailSelector</code> zur√ºckgeben, wenn der Selektor <code>getUser</code> zur√ºckgibt?  Und dies ist eine wahrscheinliche Situation - Bugs, Refactoring, Legacy - alles kann dazu f√ºhren.  Im Allgemeinen ist es nie Aufgabe der Selektoren, Fehler zu behandeln oder Standardwerte bereitzustellen. </p><br><p>  Das zweite Problem tritt beim Testen solcher Selektoren auf.  Wenn wir sie mit Unit-Tests abdecken wollen, ben√∂tigen wir Scheindaten, die mit den Daten aus der Produktion identisch sind.  Wir m√ºssen die Scheindaten des gesamten Staates (da der Staat in der Produktion nicht inkonsistent sein kann) nur f√ºr diesen Selektor verwenden.  Abh√§ngig von der Architektur unserer Anwendung kann dies sehr unpraktisch sein: Ziehen von Daten in Tests. </p><br><p>  Nehmen wir an, wir haben den <code>getUserEmailSelector</code> Selektor wie oben beschrieben geschrieben und getestet.  Wir benutzen es und verbinden die Komponente mit dem Staat: </p><br><pre> <code class="plaintext hljs">const mapStateToProps = (state, ownProps) =&gt; ({ firstName: getUserFirstName(ownProps.userId)(state), lastName: getUserLastName(ownProps.userId)(state), //   email: getUserEmailName(ownProps.userId)(state), })</code> </pre> <br><p>  Nach der obigen Logik haben wir die Selektoren erhalten, die am Anfang des Artikels standen. <br>  <strong>Wir sind zu weit gegangen.</strong>  <strong>Als Ergebnis haben wir eine Pseudo-API f√ºr die Entit√§t User geschrieben.</strong>  <strong>Diese API kann nicht au√üerhalb von Redux verwendet werden, da eine vollst√§ndige Statusumwandlung erforderlich ist.</strong>  <strong>Dar√ºber hinaus ist diese API nur schwer zu erweitern. Wenn Sie der Entit√§t "User" neue Felder hinzuf√ºgen, m√ºssen Sie neue Selektoren erstellen, sie zu "mapStateToProps" hinzuf√ºgen und mehr Code f√ºr die Textausgabe schreiben.</strong> </p><br><h2 id="a-mozhet-stoit-obraschatsya-k-polyam-suschnosti-napryamuyu">  Oder sollten Sie direkt auf die Entit√§tsfelder zugreifen? </h2><br><p>  Wenn das Problem nur darin besteht, dass wir zu viele Selektoren haben - verwenden wir vielleicht nur getUser und greifen direkt auf die Entit√§tseigenschaften zu, die wir ben√∂tigen? </p><br><pre> <code class="plaintext hljs">const user = getUser(id)(state); const email = user.email;</code> </pre> <br><p>  Dieser Ansatz l√∂st das Problem des Schreibens und der Unterst√ºtzung einer gro√üen Anzahl von Selektoren, schafft jedoch ein anderes Problem.  Wenn wir das Benutzermodell √§ndern m√ºssen, m√ºssen wir auch alle Stellen kontrollieren, an denen <code>user.email</code> ( <em>Anmerkung des √úbersetzers</em> oder anderes Feld, das wir √§ndern).  Bei einer gro√üen Menge an Code im Projekt kann dies eine schwierige Aufgabe werden und sogar ein kleines Refactoring erschweren.  Wenn wir einen Selektor hatten, sch√ºtzte er uns vor solchen Konsequenzen von √Ñnderungen, weil  √ºbernahm die Verantwortung f√ºr die Arbeit mit dem Modell und der Code mit dem Selektor wusste nichts √ºber das Modell. </p><br><p>  Direktzugriff ist verst√§ndlich.  Aber wie sieht es mit dem Empfang berechneter Daten aus?  Zum Beispiel mit dem vollst√§ndigen Benutzernamen, welcher ist eine Verkettung des Vor- und Nachnamens?  M√ºssen weiter graben ... </p><br><img src="https://habrastorage.org/getpro/habr/post_images/fc4/5d5/df3/fc45d5df378821827b32e53402d6a041.png" alt="Bild"><br><br><h2 id="model-predmetnoy-oblasti---vo-glave-redux---vtorichen">  Das Domain-Modell ist √ºberschrieben.  Redux - Sekund√§r </h2><br><p>  Sie k√∂nnen zu diesem Bild gelangen, indem Sie zwei Fragen beantworten: </p><br><ul><li>  Wie definieren wir unser Domainmodell? </li><li>  Wie werden wir die Daten speichern?  (Statusverwaltung, daf√ºr verwenden wir Redux * Anmerkung des √úbersetzers *, dass die Persistenzschicht in DDD aufgerufen wird) </li></ul><br><p>  Beantworten wir die Frage ‚ÄûWie definieren wir das Domain-Modell?‚Äú (In unserem Fall ‚ÄûBenutzer‚Äú), abstrahieren wir von Redux und entscheiden, was ein ‚ÄûBenutzer‚Äú ist und welche API f√ºr die Interaktion erforderlich ist. </p><br><pre> <code class="plaintext hljs">// api.ts type User = { id: string, firstName: string, lastName: string, email: string, ... } const getFirstName = (user: User) =&gt; user.firstName; const getLastName = (user: User) =&gt; user.lastName; const getFullName = (user: User) =&gt; `${user.firstName} ${user.lastName}`; const getEmail = (user: User) =&gt; user.email; ... const createUser = (id: string, firstName: string, ...) =&gt; User;</code> </pre> <br><p>  Es ist gut, wenn wir diese API immer verwenden und das Benutzermodell au√üerhalb der Datei api.ts als nicht zug√§nglich betrachten.  Dies bedeutet, dass wir uns seitdem niemals direkt den Feldern der Entit√§t zuwenden werden  Der Code, der die API verwendet, wei√ü nicht einmal, welche Entit√§t Felder hat. </p><br><p>  Jetzt k√∂nnen wir zu Redux zur√ºckkehren und Probleme l√∂sen, die nur den Status betreffen: </p><br><ul><li>  Welchen Platz nehmen Nutzer in unserem Artikel ein? </li><li>  Wie sollen wir Benutzer speichern?  Eine Liste?  W√∂rterbuch (Schl√ºsselwert)?  Wie sonst </li><li>  Wie erhalten wir eine Benutzerinstanz vom Staat?  Sollte eine Notiz verwendet werden?  (im Kontext des getUser-Selektors) </li></ul><br><h2 id="malenkoe-api-s-bolshimi-preimuschestvami">  Kleine API mit gro√üen Vorteilen </h2><br><p>  Unter Anwendung des Prinzips der Aufteilung der Verantwortung zwischen Fachgebiet und Staat erhalten wir viele Pr√§mien. </p><br><p>  Ein gut dokumentiertes Dom√§nenmodell (Benutzermodell und dessen API) in der Datei api.ts.  Es eignet sich gut zum Testen, als  hat keine Abh√§ngigkeiten.  Wir k√∂nnen das Modell und die API zur Wiederverwendung in anderen Anwendungen in die Bibliothek extrahieren. </p><br><p>  Wir k√∂nnen API-Funktionen einfach als Selektoren kombinieren, was einen unvergleichlichen Vorteil gegen√ºber dem direkten Zugriff auf Eigenschaften darstellt.  Dar√ºber hinaus ist unsere Datenschnittstelle jetzt einfach zu warten - wir k√∂nnen das Benutzermodell problemlos √§ndern, ohne den Code zu √§ndern, in dem es verwendet wird. </p><br><p>  Mit der API ist keine Zauberei passiert, es sieht immer noch klar aus.  Die API √§hnelt dem, was mit Selektoren gemacht wurde, hat aber einen entscheidenden Unterschied: Sie ben√∂tigt nicht den gesamten Status, muss nicht mehr den vollst√§ndigen Status der Anwendung zum Testen unterst√ºtzen - die API hat nichts mit Redux und ihrem Code zu tun. </p><br><p>  Die Komponentenst√ºtzen sind sauberer geworden.  Anstatt auf die Eingabe der Eigenschaften Vorname, Nachname und E-Mail zu warten, empf√§ngt die Komponente eine Benutzerinstanz und verwendet intern ihre API, um auf die erforderlichen Daten zuzugreifen.  Es stellt sich heraus, dass wir nur einen Selektor ben√∂tigen - getUser. </p><br><p>  Eine solche API bietet Reduzierern und Middleware Vorteile.  Der Vorteil besteht im Wesentlichen darin, dass Sie zuerst eine Instanz von User abrufen, die darin enthaltenen fehlenden Werte beheben, alle Fehler verarbeiten oder verhindern und dann die API-Methoden verwenden k√∂nnen.  Dies ist besser, als jedes einzelne Feld mit Hilfe von Selektoren vom Themenbereich isoliert darzustellen.  Somit wird Redux wirklich zu einem ‚Äûvorhersehbaren Container‚Äú und h√∂rt auf, ein ‚Äûg√∂ttliches‚Äú Objekt mit Wissen √ºber alles zu sein. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Mit guten Absichten (lesen Sie hier - Selektoren) ist der Weg zur H√∂lle geebnet: Wir wollten nicht direkt auf die Felder der Entit√§t zugreifen und haben daf√ºr separate Selektoren gemacht. </p><br><p>  Obwohl die Idee der Selektoren an sich gut ist, erschwert ihre √úberbeanspruchung die Pflege unseres Codes. </p><br><p>  Die im Artikel beschriebene L√∂sung schl√§gt vor, das Problem in zwei Schritten zu l√∂sen: Beschreiben Sie zuerst das Domain-Modell und dessen API und besch√§ftigen Sie sich dann mit Redux (Datenspeicherung, Selektoren).  Auf diese Weise schreiben Sie besseren und kleineren Code - Sie ben√∂tigen nur einen Selektor, um eine flexiblere und skalierbarere API zu erstellen. </p><br><h4 id="primechaniya-perevodchika">  Hinweise f√ºr √úbersetzer </h4><br><ol><li>  Ich habe das Wort state verwendet, da es anscheinend fest im Vokabular der russischsprachigen Entwickler verankert ist. </li><li>  Der Autor verwendet die W√∂rter Upstream / Downstream, um "High-Level- / Low-Level-Code" (falls nach Martin) oder "Code, der unten verwendet wird / Code, der unten das verwendet, was oben geschrieben ist" zu bedeuten, aber es ist nicht korrekt, herauszufinden, wie dies in der √úbersetzung verwendet wird Ich k√∂nnte mich deshalb tr√∂sten, indem ich versuche, den allgemeinen Sinn nicht zu ver√§rgern. </li></ol><br><p>  Gerne nehme ich Kommentare und Korrekturvorschl√§ge in PM entgegen und korrigiere sie. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de485238/">https://habr.com/ru/post/de485238/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de485224/index.html">Wie f√§llt die Warenlieferung ab dem 1. Januar 2020 unter die Zollgrenze?</a></li>
<li><a href="../de485226/index.html">UI-Entwicklung: Wem kann man zuh√∂ren - sich selbst oder dem Benutzer?</a></li>
<li><a href="../de485228/index.html">Was ist aktives Lernen?</a></li>
<li><a href="../de485230/index.html">Top 5 B√ºcher zum Lesen f√ºr einen Motion Designer</a></li>
<li><a href="../de485236/index.html">Python-Konfigurationsdateien</a></li>
<li><a href="../de485240/index.html">Layout go pet Projekt auf VPS</a></li>
<li><a href="../de485256/index.html">Ivan Lilekvist und Kim Dotkom, ein gro√ües Interview: Die Geschichte von Megaupload, Auslieferung an die Vereinigten Staaten, Freiheit, Bitcoin. Teil 1</a></li>
<li><a href="../de485260/index.html">13 H√§ufige Fehler f√ºr beginnende Business Analysten</a></li>
<li><a href="../de485264/index.html">Wie das Zip-Archiv aussieht und was wir damit machen k√∂nnen. Teil 4 - Das Archiv lesen</a></li>
<li><a href="../de485266/index.html">Habr-Wettbewerb: Gewinner des Ideenwettbewerbs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>