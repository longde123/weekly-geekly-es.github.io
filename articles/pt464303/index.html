<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôåüèª üï¢ ‚òÉÔ∏è Dados de s√©ries temporais em um DBMS relacional. Extens√µes TimescaleDB e PipelineDB for PostgreSQL üìØ üôâ üàöÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dados de s√©ries temporais ou s√©ries temporais s√£o dados que mudam com o tempo. Cota√ß√µes de moeda, telemetria de movimentos de transporte, estat√≠sticas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dados de s√©ries temporais em um DBMS relacional. Extens√µes TimescaleDB e PipelineDB for PostgreSQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/464303/">  Dados de s√©ries temporais ou s√©ries temporais s√£o dados que mudam com o tempo.  Cota√ß√µes de moeda, telemetria de movimentos de transporte, estat√≠sticas de acesso ao servidor ou carga da CPU s√£o dados de s√©ries temporais.  Para armazen√°-los, s√£o necess√°rias ferramentas espec√≠ficas - bancos de dados temporais.  Existem dezenas de ferramentas, por exemplo, InfluxDB ou ClickHouse.  Mas mesmo as melhores solu√ß√µes de armazenamento de s√©ries temporais t√™m desvantagens.  Todos os armazenamentos de s√©ries temporais s√£o de baixo n√≠vel, adequados apenas para dados de s√©ries temporais, e a execu√ß√£o e a inje√ß√£o na pilha atual s√£o caras e dolorosas. <br><br><img src="https://habrastorage.org/webt/sx/9x/bz/sx9xbzv26lix6lh-frspdsopknw.jpeg"><br><br>  Mas, se voc√™ tiver uma pilha do PostgreSQL, poder√° esquecer o InfluxDB e todos os outros bancos de dados temporais.  Instale duas extens√µes, TimescaleDB e PipelineDB, e armazene, processe e analise dados de s√©ries temporais diretamente no ecossistema do PostgreSQL.  Sem a introdu√ß√£o de solu√ß√µes de terceiros, sem as desvantagens dos armazenamentos temporais e sem os problemas de execut√°-los.  Quais s√£o essas extens√µes, quais s√£o suas vantagens e capacidades, dir√£o a <b>Ivan Muratov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">binakot</a> )</b> - chefe do departamento de desenvolvimento da "First Monitoring Company". <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/3WkNp7mllv0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  O que s√£o dados de s√©ries temporais ou s√©ries temporais? </h2><br><blockquote>  S√£o dados sobre o processo coletado em diferentes momentos de sua vida. </blockquote><br>  Por exemplo, a localiza√ß√£o do carro: velocidade, coordenadas, dire√ß√£o ou uso de recursos no servidor com dados sobre a carga na CPU, RAM usada e espa√ßo livre em disco. <br><br>  As s√©ries temporais t√™m v√°rios recursos. <br><br><ul><li>  Em uma <b>cinta de fixa√ß√£o</b> .  Qualquer registro de s√©rie temporal possui um campo com um registro de data e hora no qual o valor foi registrado. <br></li><li>  <b>As caracter√≠sticas do processo, chamadas de n√≠veis da s√©rie</b> : velocidade, coordenadas, carregamento de dados. <br></li><li>  Quase sempre com esses dados, eles funcionam <b>no modo somente acr√©scimo</b> .  Isso significa que os novos dados n√£o substituem os antigos.  Somente dados obsoletos s√£o exclu√≠dos. <br></li><li>  <b>As entradas n√£o s√£o consideradas separadamente uma da outra</b> .  Os dados s√£o usados ‚Äã‚Äãapenas coletivamente para janelas de tempo, intervalos ou per√≠odos. <br></li></ul><br><h3>  Solu√ß√µes populares de armazenamento </h3><br>  O gr√°fico que tirei do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">db-engines.com</a> mostra a popularidade de v√°rios modelos de armazenamento nos √∫ltimos dois anos. <br><br><img src="https://habrastorage.org/webt/w2/wf/_u/w2wf_uryfor_djey8enzmrskywo.jpeg"><br><br>  A posi√ß√£o de lideran√ßa √© ocupada por armazenamentos de s√©ries temporais, em segundo lugar - bancos de dados gr√°ficos, em seguida - bancos de dados relacionais e de valor-chave.  A popularidade de reposit√≥rios especializados est√° associada a um intenso crescimento na integra√ß√£o de tecnologias da informa√ß√£o: Big Data, redes sociais, IoT, monitoramento de infraestrutura de alta carga.  Al√©m de dados comerciais √∫teis, at√© logs e m√©tricas ocupam uma enorme quantidade de recursos. <br><br><h3>  Solu√ß√µes populares de armazenamento para dados de s√©ries temporais </h3><br>  O gr√°fico mostra solu√ß√µes especializadas para armazenar dados de s√©ries temporais.  A escala √© logar√≠tmica. <br><br><img src="https://habrastorage.org/webt/ny/bz/6_/nybz6_-_3ce7t0y7xre1oxkbks8.jpeg"><br><br>  L√≠der est√°vel InfluxDB.  Todo mundo que se deparou com dados de s√©ries temporais j√° ouviu falar sobre este produto.  Mas o gr√°fico mostra um aumento de dez vezes no TimescaleDB - uma extens√£o do DBMS relacional est√° lutando por um lugar ao sol entre os produtos que foram originalmente desenvolvidos sob a s√©rie temporal. <br><br><blockquote>  O PostgreSQL n√£o √© apenas um bom banco de dados, mas tamb√©m uma plataforma extens√≠vel para o desenvolvimento de solu√ß√µes especializadas. </blockquote><br><h2>  Postgres, Postgis e TimescaleDB </h2><br>  A Primeira Empresa de Monitoramento monitora o movimento de ve√≠culos usando sat√©lites.  N√≥s rastreamos 20.000 ve√≠culos e armazenamos dados de movimenta√ß√£o por dois anos.  No total, temos 10 TB de dados de telemetria atuais.  Em m√©dia, cada ve√≠culo envia 5 registros de telemetria por minuto enquanto dirige.  Os dados s√£o enviados via equipamento de navega√ß√£o para nossos servidores telem√°ticos.  Eles recebem 500 pacotes de navega√ß√£o por segundo. <br><br>  H√° algum tempo, decidimos atualizar globalmente a infraestrutura e passar de um mon√≥lito para microsservi√ßos.  Chamamos o novo sistema de Waliot, e ele j√° est√° em produ√ß√£o - 90% de todos os ve√≠culos s√£o transferidos para ele. <br><br>  Muita coisa mudou na infraestrutura, mas o link central permaneceu inalterado - esse √© o banco de dados PostgreSQL.  Agora estamos trabalhando na vers√£o 10 e nos preparando para passar para 11. Al√©m do PostgreSQL, como armazenamento principal, na pilha, usamos o PostGIS para computa√ß√£o geoespacial e o TimescaleDB para armazenar uma grande variedade de dados de s√©ries temporais. <br><br><h3>  Por que o PostgreSQL? </h3><br>  Por que estamos tentando usar um banco de dados relacional para armazenar s√©ries temporais, em vez de solu√ß√µes especializadas <s>ClickHouse</s> para esse tipo de dados?  Porque, tendo como pano de fundo a experi√™ncia acumulada e as impress√µes de trabalhar com o PostgreSQL, n√£o queremos usar uma solu√ß√£o desconhecida como armazenamento principal. <br><br><blockquote>  Mudar para uma nova solu√ß√£o √© um risco. </blockquote><br>  Existem muitas solu√ß√µes especializadas para armazenar e processar dados de s√©ries temporais.  A documenta√ß√£o nem sempre √© suficiente, e uma grande variedade de solu√ß√µes nem sempre √© boa.  Parece que os desenvolvedores de cada novo produto querem escrever tudo do zero, porque algo n√£o foi agrad√°vel na solu√ß√£o anterior.  Para entender o que exatamente n√£o gostou, voc√™ precisa procurar informa√ß√µes, analisar e comparar.  Uma enorme variedade de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tops</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">classifica√ß√µes</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">compara√ß√µes s√£o</a> bastante assustadores do que motivadores para tentar algo.  Voc√™ precisar√° gastar muito tempo para experimentar todas as solu√ß√µes.  N√£o podemos nos dar ao luxo de adaptar apenas uma solu√ß√£o por v√°rios meses.  Essa √© uma tarefa dif√≠cil, e o tempo gasto nunca ser√° recompensado.  Portanto, escolhemos extens√µes para o PostgreSQL. <br><br>  Durante a fase de desenvolvimento da infraestrutura da Waliot, consideramos o InfluxDB o principal reposit√≥rio de telemetria.  Mas quando me deparei com o TimescaleDB e fiz testes, n√£o havia d√∫vidas sobre a escolha.  O PostgreSQL com a extens√£o TimescaleDB permite usar outras extens√µes no mesmo armazenamento PostGIS ou PipelineDB.  N√£o precisamos extrair dados, transformar, conduzir an√°lises e transferi-los pela rede.  Tudo est√° em um servidor ou em um sistema em cluster - os dados n√£o precisam ser arrastados.  Todos os c√°lculos s√£o realizados no mesmo n√≠vel. <br><br>  Recentemente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Nikolay Samokhvalov</a> , o autor da conta postgresmen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">publicou um link</a> para um artigo interessante sobre o uso do SQL para processamento de dados de streaming.  Cinco em cada seis autores do artigo participam do desenvolvimento de v√°rios produtos Apache e trabalham com o processamento de fluxo.  Portanto, o artigo menciona o Apache Spark, o Apache Flink, o Apache Beam, o Apache Calcite e o KSQL da Confluent. <br><br>  Mas n√£o o artigo em si √© interessante, mas o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">t√≥pico do Hacker News</a> , no qual √© discutido.  O autor do t√≥pico escreve que, com base no artigo, ele implementou quase todas as id√©ias baseadas no PostgreSQL 11. Ele usou extens√µes CitusDB para dimensionamento e sharding horizontal, PipelineDB para computa√ß√£o em fluxo e visualiza√ß√µes materializadas, TimescaleDB para armazenar dados e se√ß√µes de s√©ries temporais.  Ele tamb√©m usa v√°rios inv√≥lucros de dados estrangeiros. <br><br><blockquote>  Uma mistura maluca de PostgreSQL e suas extens√µes mais uma vez confirma que o PostgreSQL n√£o √© apenas um DBMS - √© uma plataforma. </blockquote><br>  E quando o armazenamento conect√°vel for entregue ... Ugh! <br><br>  Ironicamente, ao pesquisar as solu√ß√µes, encontramos o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Outflux</a> , o desenvolvimento da equipe do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">TimescaleDB</a> , que eles publicaram em 1¬∫ de abril.  O que voc√™ acha que ela faz?  Este √© um utilit√°rio para migrar do InfluxDB para o TimescaleDB em um comando ... <br><br><h3>  Hype do Postgres! </h3><br>  N√£o subestime o poder do hype!  Costumamos brincar que "o desenvolvimento √© impulsionado pelo hype", porque influencia nossas percep√ß√µes sobre os componentes de ajuste e infraestrutura.  No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HighLoad ++,</a> discutimos muito sobre o PostgreSQL, ClickHouse, Tarantool - esses s√£o desenvolvimentos exagerados.  S√≥ n√£o diga que isso n√£o afeta suas prefer√™ncias e a escolha de solu√ß√µes para a infraestrutura ... Claro, esse n√£o √© o principal fator, mas h√° algum efeito? <br><br>  Trabalho com PostgreSQL h√° 5 anos.  Eu gosto desta solu√ß√£o.  Ele resolve quase todas as minhas tarefas com um estrondo.  Toda vez que algo dava errado nessa base, minhas m√£os tortas eram culpadas.  Portanto, a escolha foi predeterminada. <br><br><h2>  TimescaleDB VS PipelineDB </h2><br>  Vamos seguir para as extens√µes TimescaleDB e PipelineDB.  O que seus criadores dizem sobre extens√µes? <br><br>  <b>O TimescaleDB √© um banco de dados de s√©ries temporais de</b> c√≥digo aberto otimizado para inser√ß√£o r√°pida e consultas complexas. <br><br>  <b>O PipelineDB</b> √© uma extens√£o de alto desempenho projetada para executar consultas SQL cont√≠nuas <b>para dados de s√©ries temporais</b> . <br><br>  Al√©m de trabalhar com dados de s√©ries temporais, eles t√™m uma hist√≥ria semelhante.  O Timescale foi fundado em 2015 e o Pipeline em 2013. As primeiras vers√µes de trabalho apareceram em 2017 e 2015, respectivamente.  Levou dois anos para as equipes liberarem a funcionalidade m√≠nima.  Os lan√ßamentos de produ√ß√£o de ambas as extens√µes ocorreram em outubro passado, com uma diferen√ßa de uma semana.  Aparentemente, com pressa um ap√≥s o outro. <br><br>  O GitHub tem um monte de estrelas e garfos, que, como sempre, n√£o s√£o um √∫nico commit.  √â assim que o c√≥digo aberto funciona, n√£o h√° nada a ser feito.  Mas h√° muitas estrelas: o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">TimescaleDB tem</a> mais que o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PipelineDB</a> e ainda mais que o pr√≥prio PostgreSQL. <br><br>  As extens√µes parecem ser semelhantes, mas se posicionam de maneira diferente. <br><br>  <b>O TimescaleDB</b> alega ter inserido milh√µes de registros por segundo e armazenado centenas de bilh√µes de linhas e dezenas de terabytes de dados.  A extens√£o √© mais r√°pida que o InfluxDB, Cassandra, MongoDB ou PostgreSQL de baunilha.  Suporta replica√ß√£o de streaming e ferramentas de backup.  O TimescaleDB √© uma extens√£o, n√£o um fork do PostgreSQL. <br><br>  <b>O PipelineDB</b> armazena apenas o resultado dos c√°lculos de streaming, sem a necessidade de armazenar dados brutos para seus c√°lculos.  A extens√£o √© capaz de agrega√ß√£o cont√≠nua em fluxos de dados em tempo real, combinando com tabelas convencionais para c√°lculos no contexto de um dom√≠nio de dom√≠nio.  O PipelineDB √© uma extens√£o, n√£o um garfo, mas inicialmente era um garfo. <br><br><h2>  Timescaledb </h2><br>  Agora em detalhes sobre as extens√µes.  Vamos come√ßar com o TimescaleDB.  Trabalho com ele h√° quase 2 anos.  Arrastou-o para produ√ß√£o antes da vers√£o de lan√ßamento.  Vejamos exemplos de como aplic√°-lo. <br><br>  <b>Armazenamento para m√©tricas de infraestrutura</b> .  Temos m√©tricas de consumo de recursos de cont√™iner do Docker, m√©tricas de confirma√ß√£o de tempo, identificador de cont√™iner e campos de consumo de recursos, por exemplo, mem√≥ria livre.  Precisamos exibir estat√≠sticas para todos os cont√™ineres com uma quantidade m√©dia de janelas de mem√≥ria livre por 10 segundos.  A consulta que voc√™ v√™ resolve esse problema e o TimescaleDB pode ser usado como um reposit√≥rio para m√©tricas de infraestrutura. <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> time_bucket(<span class="hljs-string"><span class="hljs-string">'10 seconds'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">period</span></span>, container_id, <span class="hljs-keyword"><span class="hljs-keyword">avg</span></span>(free_mem) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> metrics <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>() - <span class="hljs-built_in"><span class="hljs-built_in">interval</span></span> <span class="hljs-string"><span class="hljs-string">'10 minutes'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">period</span></span>, container_id <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">period</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>, container_id;</code> </pre> <br><pre> <code class="plaintext hljs">period | container_id | avg -----------------------+--------------+--- 2019-06-24 12:01:00+00 | 16 | 72202 2019-06-24 12:01:00+00 | 73 | 837725 2019-06-24 12:01:00+00 | 96 | 412237 2019-06-24 12:00:50+00 | 16 | 1173393 2019-06-24 12:00:50+00 | 73 | 90104 2019-06-24 12:00:50+00 | 96 | 784596</code> </pre> <br>  <b>Para c√°lculos</b> .  Precisamos calcular o n√∫mero de caminh√µes que deixaram Krasnodar e sua tonelagem total por dias. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> time_bucket(<span class="hljs-string"><span class="hljs-string">'1 day'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">day</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> trucks_exiting, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(weight) / <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> tonnage <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> vehicles <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> cities <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> cities.name = <span class="hljs-string"><span class="hljs-string">'Krasnodar'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> ST_Within(last_location, ST_Polygon(cities.geom, <span class="hljs-number"><span class="hljs-number">4326</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> ST_Within(current_location, ST_Polygon(cities.geom, <span class="hljs-number"><span class="hljs-number">4326</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">day</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">day</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre> <br>  Ele tamb√©m usa fun√ß√µes da extens√£o PostGIS para calcular o transporte que saiu da cidade, em vez de apenas se mover nela. <br><br>  <b>Monitoramento da taxa de c√¢mbio</b> .  O terceiro exemplo √© sobre criptomoedas.  A solicita√ß√£o permite exibir como o pre√ßo do Ethereum mudou em rela√ß√£o ao Bitcoin e ao d√≥lar americano nas √∫ltimas 2 semanas por dia. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> time_bucket(<span class="hljs-string"><span class="hljs-string">'14 days'</span></span>, c.time) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">period</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">last</span></span>(c.closing_price, c.time) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> closing_price_btc, <span class="hljs-keyword"><span class="hljs-keyword">last</span></span>(c.closing_price, c.time) * <span class="hljs-keyword"><span class="hljs-keyword">last</span></span>(b.closing_price, c.time) filter (<span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> b.currency_code = <span class="hljs-string"><span class="hljs-string">'USD'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> closing_price_usd <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> crypto_prices c <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> btc_prices b <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> time_bucket(<span class="hljs-string"><span class="hljs-string">'1 day'</span></span>, c.time) = time_bucket(<span class="hljs-string"><span class="hljs-string">'1 day'</span></span>, b.time) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c.currency_code = <span class="hljs-string"><span class="hljs-string">'ETH'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">period</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">period</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre> <br>  Tudo isso √© claro e conveniente para n√≥s, SQL. <br><br><h3>  O que h√° de t√£o legal no TimescaleDB? </h3><br>  Por que n√£o usar as ferramentas de particionamento de tabela internas?  E por que se preocupar em quebrar mesas?  A resposta √≥bvia √© a <b>velocidade de inser√ß√£o nesses bancos de dados</b> .  O gr√°fico mostra as medi√ß√µes reais da taxa de inser√ß√£o do n√∫mero de linhas por segundo entre a tabela convencional de baunilha PostgreSQL 10 sem se√ß√£o e a tabela de tabelas TimescaleDB. <br><br><img src="https://habrastorage.org/webt/gq/ln/xd/gqlnxdxeupbqkf_i-wdeihs0zlq.jpeg"><br><br>  Esse benchmark grava 1 bilh√£o de linhas em uma m√°quina, simulando um cen√°rio para coletar m√©tricas da infraestrutura.  O registro cont√©m tempo, o identificador do componente de infraestrutura e 10 m√©tricas.  O benchmark foi executado na VM do Azure com 8 n√∫cleos e 28 gigabytes de RAM, al√©m de unidades SSD de rede.  A inser√ß√£o foi realizada em lotes de 10 mil registros. <br><br>  De onde vem essa degrada√ß√£o do desempenho do PostgreSQL?  Porque quando voc√™ insere, voc√™ tamb√©m precisa atualizar os √≠ndices da tabela.  Quando eles n√£o se encaixam no cache, come√ßamos a carregar discos.  O particionamento resolve esse problema se os √≠ndices da se√ß√£o na qual inserimos os dados forem colocados na RAM. <br><br>  Vamos olhar para o gr√°fico a seguir.  Isso compara o sistema de particionamento declarativo embutido no PostgreSQL 10 e a hiper tabela TimescaleDB.  No eixo horizontal, o n√∫mero de se√ß√µes. <br><br><img src="https://habrastorage.org/webt/kd/dz/xd/kddzxdttzspi9peoiriem7sipms.jpeg"><br><br>  No TimescaleDB, a degrada√ß√£o √© insignificante com o aumento de se√ß√µes.  Os desenvolvedores de extens√µes afirmam que est√£o indo bem com 10.000 se√ß√µes em uma √∫nica inst√¢ncia do PostgreSQL. <br><br>  No PostgreSQL, a implementa√ß√£o nativa degrada significativamente ap√≥s 3.000. Em geral, o particionamento declarativo no PostgreSQL √© um grande passo √† frente, mas funciona apenas para tabelas com menos carga.  Por exemplo, para mercadorias, compradores e outras entidades de dom√≠nio que entram no sistema de maneira n√£o t√£o intensa quanto as m√©tricas. <br><br>  Nas vers√µes 11 e 12 do PostgreSQL, o suporte ao particionamento nativo ser√° exibido e voc√™ poder√° tentar executar testes comparativos para dados de s√©ries temporais com novas vers√µes.  Mas, parece-me que o TimescaleDB ainda √© melhor.  Todos os benchmarks do TimescaleDB podem ser encontrados no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github</a> e try. <br><br><h3>  Principais recursos </h3><br>  Espero que voc√™ j√° tenha interesse na extens√£o.  Vamos examinar os principais recursos do TimescaleDB para consolidar esse sentimento. <br><br>  <b>Particionando atrav√©s de tabelas de hipertens√£o</b> .  O TimescaleDB usa o termo "hipertabela" para tabelas √†s quais a fun√ß√£o create_hypertable () foi aplicada.  Depois disso, a tabela se tornar√° o pai de todas as se√ß√µes herdadas - peda√ßos.  A tabela pai em si n√£o conter√° nenhum dado, mas ser√° um ponto de entrada para todas as consultas e um modelo ao criar automaticamente novas se√ß√µes.  Todas as se√ß√µes s√£o armazenadas n√£o no esquema principal dos seus dados, mas em um esquema especial.  Isso √© conveniente porque n√£o vemos milhares dessas se√ß√µes no esquema de dados. <br><br>  <b>A extens√£o √© integrada ao agendador e ao executor de consultas</b> .  Por meio de ganchos especiais no PostgreSQL, o TimescaleDB entende quando acessa uma hipertabela.  O TimescaleDB analisa a consulta e redireciona as consultas apenas para as se√ß√µes necess√°rias com base nas condi√ß√µes especificadas na pr√≥pria chamada SQL.  Isso permite que voc√™ paralelize o trabalho com as se√ß√µes durante a extra√ß√£o de uma quantidade significativa de dados. <br><br>  <b>A extens√£o n√£o imp√µe restri√ß√µes ao SQL</b> .  Voc√™ pode usar livremente uni√µes, agregados, fun√ß√µes de janela, CTEs e √≠ndices adicionais.  Se voc√™ viu a lista de restri√ß√µes para o sistema de particionamento interno, isso deve agrad√°-lo. <br><br>  <b>Recursos √∫teis adicionais</b> espec√≠ficos para dados de s√©ries temporais: <br><br><ul><li>  "Time_bucket" - "date_trun" de uma pessoa saud√°vel; <br></li><li>  histogramas - preenchimento dos intervalos perdidos usando interpola√ß√£o ou o √∫ltimo valor conhecido; <br></li><li>  trabalhador em segundo plano - servi√ßos que permitem executar opera√ß√µes em segundo plano: limpeza de se√ß√µes antigas, reorganiza√ß√£o. <br></li></ul><br>  <b>O TimescaleDB permite que voc√™ fique no poderoso ecossistema PostgreSQL</b> .  Esta extens√£o n√£o quebra o PostgreSQL; portanto, todas as solu√ß√µes de alta disponibilidade, sistemas de backup e ferramentas de monitoramento continuar√£o funcionando.  O TimescaleDB √© amigo de Grafana, Periscope, Prometheus, Telegraf, Zabbix, Kubernetes, Kafka, Seeq, JackDB. <br><br>  <b>A Grafana</b> j√° possui suporte nativo ao <b>TimescaleDB</b> como fonte de dados.  A Grafana entende imediatamente que o PostscreSQL possui o TimescaleDB.  O construtor de solicita√ß√µes no Grafana nos pain√©is entende fun√ß√µes adicionais do TimescaleDB, como "time_bucket", "first", "last".  Voc√™ pode criar gr√°ficos diretamente do banco de dados relacional com essas fun√ß√µes de s√©ries temporais sem consultas gigantescas. <br><br>  <b>O Prometheus possui</b> um adaptador que permite mesclar dados dele e usar o TimescaleDB como um data warehouse confi√°vel.  Use um adaptador para n√£o armazenar dados no Prometheus por anos. <br><br>  H√° tamb√©m um <b>plug-in Telegraf</b> .  A solu√ß√£o permite remover completamente o Prometheus.  Os dados da infraestrutura s√£o imediatamente transferidos para o TimescaleDB e lidos pelo Telegraf. <br><br><h3>  Licen√ßas e Not√≠cias </h3><br>  N√£o faz muito tempo, a empresa mudou para um novo modelo de licenciamento.  A maior parte do c√≥digo √© licenciada sob o Apache 2.0.  Uma pequena por√ß√£o √© gratuita, mas √© licenciada sob TSL. <br><br>  Existe uma vers√£o Enterprise com uma licen√ßa comercial.  N√£o se preocupe, nem todos os presentes na vers√£o Enterprise.  Basicamente, existem automa√ß√µes, como a remo√ß√£o autom√°tica de partes obsoletas, que podem ser feitas atrav√©s de um "cron" simples e coisas semelhantes. <br><br>  Agora a empresa est√° trabalhando ativamente em uma solu√ß√£o de cluster.  Talvez ele caia na vers√£o Enterprise.  H√° tamb√©m uma vers√£o em nuvem para startups que desejam entrar no mercado antes que os investidores fiquem sem dinheiro. <br><br>  Das not√≠cias: <br><br><ul><li>  um milh√£o de downloads no √∫ltimo ano e meio; <br></li><li>  Investimento de US $ 31 milh√µes; <br></li><li>  Colabora√ß√£o ativa com o MS Azure em rela√ß√£o √†s solu√ß√µes de IoT. <br></li></ul><br><h3>  Resumir </h3><br><blockquote>  O TimescaleDB foi projetado para armazenar dados de s√©ries temporais.  Este √© um poderoso sistema de particionamento com restri√ß√µes m√≠nimas em compara√ß√£o com as nativas no PostgreSQL. </blockquote><br>  Infelizmente, a extens√£o ainda n√£o possui uma vers√£o multinode.  Se voc√™ deseja um multimaster ou shard, precisa brincar, por exemplo, com o CitusDB.  Se voc√™ deseja replica√ß√£o l√≥gica, isso vai doer.  Mas sempre d√≥i com ela. <br><br><h2>  Pipelinedb </h2><br>  Agora vamos falar sobre a segunda extens√£o.  Infelizmente, n√£o fomos capazes de test√°-lo adequadamente em batalha.  Agora est√° passando pelo est√°gio de adapta√ß√£o em nosso sistema.  √â verdade que h√° um problema que abordarei mais perto do fim. <br><br>  Como no caso anterior, come√ßamos com exemplos reais.  √â mais f√°cil entender os benef√≠cios da expans√£o e a motiva√ß√£o para us√°-la. <br><br>  <b>Coleta de estat√≠sticas</b> .  Imagine que coletamos estat√≠sticas sobre as visitas ao nosso site.  Precisamos de an√°lises das p√°ginas mais populares, do n√∫mero de usu√°rios √∫nicos e de alguma id√©ia de atrasos nos recursos.  Tudo isso deve ser atualizado em tempo real.  Mas n√£o queremos tocar na tabela de dados todas as vezes e criar uma consulta ou atualizar a exibi√ß√£o na parte superior da tabela. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> CONTINUOUS <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">url</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> total_count, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">DISTINCT</span></span> cookie::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> uniques, <span class="hljs-keyword"><span class="hljs-keyword">percentile_cont</span></span>(<span class="hljs-number"><span class="hljs-number">0.99</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WITHIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> latency::<span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> p99_latency <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> page_views <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">url</span></span>;</code> </pre> <br><pre> <code class="plaintext hljs">url | total_count | uniques | p99_latency -----------+-------------+---------+------------ some/url/0 | 633 | 51 | 178 some/url/1 | 688 | 37 | 139 some/url/2 | 508 | 88 | 121 some/url/3 | 848 | 36 | 59 some/url/4 | 126 | 64 | 159</code> </pre> <br>  O processamento de streaming e a extens√£o PipelineDB s√£o √∫teis.  A extens√£o adiciona a abstra√ß√£o CONTINUES VIEW.  Na vers√£o russa, isso pode parecer uma "apresenta√ß√£o cont√≠nua".  Essa visualiza√ß√£o √© atualizada automaticamente quando inserida na tabela com os registros de visitas, mas apenas com base em novos dados, sem a leitura j√° registrada previamente. <br><br>  <b>Fluxo de dados</b> .  O PipelineDB n√£o se limita apenas ao novo tipo de exibi√ß√£o.  Suponha que realizemos testes A / B e coletemos an√°lises em tempo real sobre a efic√°cia de uma nova solu√ß√£o de neg√≥cios.  Mas n√£o queremos armazenar os dados nas pr√≥prias a√ß√µes do usu√°rio.  Estamos interessados ‚Äã‚Äãapenas no resultado - qual grupo tem mais convers√µes. <br><br>  Para evitar o armazenamento direto de dados brutos para computa√ß√£o em fluxo, precisamos de uma abstra√ß√£o como <b>fluxos - fluxo de dados</b> .  O PipelineDB apresenta esse recurso.  Voc√™ pode criar fluxos como tabelas regulares.  Sob o cap√¥, ser√° "FOREIGN TABLE" baseado na fila ZeroMQ, que a extens√£o imperceptivelmente usa de n√≥s.  Os dados entram na fila interna do ZeroMQ e acionam uma atualiza√ß√£o para a exibi√ß√£o cont√≠nua. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> STREAM ab_event_stream ( <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, ab_group <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, event_type <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>), cookie <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> CONTINUOUS <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> ab_test_monitor <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, ab_group, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> WHENevent_type = <span class="hljs-string"><span class="hljs-string">'v'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> view_count, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> WHENevent_type = <span class="hljs-string"><span class="hljs-string">'c'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> conversion_count, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">DISTINCT</span></span> cookie) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> uniques <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ab_event_stream <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, ab_group;</code> </pre> <br>  Em seguida, criamos "VIS√ÉO CONT√çNUA" com base nos dados de um fluxo criado anteriormente.  Quando os dados chegarem no fluxo, a exibi√ß√£o ser√° atualizada com base nesses dados.  Depois disso, os dados ser√£o simplesmente descartados, n√£o sendo salvos em nenhum lugar e n√£o ocupando espa√ßo em disco.  Isso permite que voc√™ crie an√°lises em uma quantidade quase ilimitada de dados, carregando-os no fluxo de dados do PipelineDB e lendo o resultado do c√°lculo de uma exibi√ß√£o cont√≠nua. <br><br>  <b>Computa√ß√£o em fluxo</b>  Depois de criarmos o fluxo de dados e a visualiza√ß√£o cont√≠nua, podemos trabalhar com a computa√ß√£o em fluxo.  Parece assim. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> ab_event_stream (<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, ab_group, event_type, cookie) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">round</span></span>(random() * <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">round</span></span>(random() * <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ab_group, (<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> WHENrandom() &gt; <span class="hljs-number"><span class="hljs-number">0.4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'v'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-string"><span class="hljs-string">'c'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> event_type, <span class="hljs-keyword"><span class="hljs-keyword">md5</span></span>(random()::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> cookie <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">100000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ab_group, uniques <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ab_test_monitor; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ab_group, view_count * <span class="hljs-number"><span class="hljs-number">100</span></span> / (conversion_count + view_count) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> conversion_rate <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ab_test_monitor;</code> </pre> <br>  O primeiro "SELECT" fornece ao grupo "ab" e o n√∫mero de visitantes √∫nicos.  O segundo - fornece a propor√ß√£o entre os grupos - convers√£o.  Isso √© tudo o teste A / B em cinco chamadas SQL em um banco de dados relacional. <br><br>  A visualiza√ß√£o √© atualizada dinamicamente.  Voc√™ n√£o pode esperar pelo processamento de toda a matriz de dados, mas ler os resultados intermedi√°rios que j√° foram processados.  As visualiza√ß√µes s√£o lidas da mesma maneira que o PostgreSQL comum.  Voc√™ tamb√©m pode combinar uma visualiza√ß√£o com tabelas ou at√© outras visualiza√ß√µes.  N√£o h√° restri√ß√µes. <br><br><h3>  Topologia </h3><br>  O Kafka recebe telemetria, o t√≥pico no Kafka envia esses dados para o PostgreSQL e os agregamos ainda mais.  Por exemplo, combinamos com alguma tabela comum e redirecionamos os dados para o fluxo.  Al√©m disso, ele provoca a atualiza√ß√£o da apresenta√ß√£o cont√≠nua correspondente, a partir da qual os clientes do banco de dados j√° podem ler os dados finais. <br><br><img src="https://habrastorage.org/webt/0e/4p/zb/0e4pzbehsh35td5tdiillcaq82m.jpeg"><br><br>  <i>Um exemplo da topologia dos componentes do PipelineDB dentro do PostgreSQL.</i>  <i>O circuito √© emprestado de uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">apresenta√ß√£o de</a> Derek Nelson.</i> <br><br>  Al√©m de fluxos e visualiza√ß√µes, a extens√£o tamb√©m fornece uma abstra√ß√£o de "transforma√ß√£o" - conversores ou mutadores.  Essa visualiza√ß√£o, mas destinava-se a converter o fluxo de dados recebidos em uma sa√≠da modificada.  Usando esses mutadores, voc√™ pode alterar a apresenta√ß√£o dos dados ou filtr√°-los.  Do mutador, tudo cai na visualiza√ß√£o CONTINUOUS VIEW.  J√° fazemos consultas sobre neg√≥cios.  Qualquer pessoa familiarizada com programa√ß√£o funcional deve entender a ideia. <br><br>  No PipelineDB, podemos acionar nossos modos de exibi√ß√£o e executar a√ß√µes, por exemplo, "alerta".  Com todos esses c√°lculos, nunca armazenamos os dados brutos, com base nos quais todos os calculamos.  Estes podem ser terabytes, que s√£o carregados sequencialmente em um servidor com um disco de cem gigabytes.  Afinal, estamos interessados ‚Äã‚Äãapenas no resultado dos c√°lculos. <br><br><h3>  Principais recursos </h3><br>  A extens√£o PipelineDB √© mais dif√≠cil de aprender do que o TimescaleDB.  No TimescaleDB, criamos uma tabela, dizemos que ela √© uma hipertabela e aproveitamos a vida usando v√°rias fun√ß√µes adicionais que a extens√£o oferece. <br><br>  <b>O PipelineDB resolve o problema de streaming de computa√ß√£o em bancos de dados relacionais</b> .  A tarefa de transmitir o processamento de dados √© mais complicada do que o particionamento em termos de integra√ß√£o e uso.  No entanto, nem todo mundo tem dados enormes e bilh√µes de linhas.  Por que complicar a infraestrutura se houver o PipelineDB?  A extens√£o fornece suas pr√≥prias implementa√ß√µes de representa√ß√µes, fluxos, conversores e agregados para processamento de fluxo.  Tamb√©m √© <b>integrado ao planejador de consultas e o executor de consultas</b> permite implementar o conceito de computa√ß√£o em fluxo em um banco de dados relacional. <br><br>  Como o TimescaleDB, a extens√£o PipelineDB <b>n√£o imp√µe restri√ß√µes SQL no PostgreSQL</b> .  Existem v√°rios recursos, por exemplo, voc√™ n√£o pode combinar dois fluxos, mas isso n√£o √© necess√°rio. <br><br>  <b>Suporte para estruturas de dados probabil√≠sticas e algoritmos</b> .  A extens√£o usa o filtro Bloom para SELECT DISTINCT, HyperLogLog para COUNT (DISTINCT) e T-Digest para percentile_count () diretamente no SQL.  Isso melhora a produtividade. <br><br>  <b>Ecossistema</b>  A extens√£o permite que voc√™ trabalhe com as solu√ß√µes habituais de alta disponibilidade, ferramentas de monitoramento e tudo o mais familiar no PostgreSQL. <br><br>  Dadas as especificidades da computa√ß√£o em fluxo, o PipelineDB tem <b>integra√ß√µes com o Apache Kafka</b> e com o Amazon Kinesis, um servi√ßo de an√°lise em tempo real.  Como o PipelineDB n√£o √© mais um fork, mas uma extens√£o, a integra√ß√£o com o restante do zool√≥gico tamb√©m deve estar pronta para uso.  Um imperativo, mas n√£o vivemos em um mundo ideal, e vale a pena conferir tudo. <br><br><h3>  Licen√ßas e Not√≠cias </h3><br>  Todo o c√≥digo √© licenciado no Apache 2.0.  H√° uma assinatura paga para o suporte de diferentes galerias de tiro, bem como uma vers√£o em cluster com uma licen√ßa comercial.  Com base no PipelineDB, a empresa fornece o servi√ßo de an√°lise Stride. <br><br>  Antes de come√ßar a falar sobre a extens√£o, eu disse que existe um "mas".  √â hora de falar sobre ele.  Em 1 de maio de 2019, a equipe do PipelineDB anunciou que agora faz parte do Confluent.  Esta √© a empresa que desenvolve o KSQL - um mecanismo para transmitir dados no Kafka com sintaxe SQL.  Agora Victor Gamov, co-fundador do podcast Debriefing, est√° trabalhando l√°. <br><br>  O que se segue disso?  O PipelineDB congelou na vers√£o 1.0.0.  Al√©m de corrigir bugs cr√≠ticos, nada est√° planejado nele.  Devido √† aquisi√ß√£o, esperamos a integra√ß√£o do Uber do Kafka com o PostgreSQL.  Talvez seja Confluent baseado em armazenamento conect√°vel que fa√ßa algo legal. <br><br>  O que fazer  V√° para TimescaleDB.  Na vers√£o mais recente, eles fizeram sua ‚ÄúVIS√ÉO CONT√çNUA‚Äù com blackjack.  Obviamente, agora a funcionalidade n√£o √© t√£o legal quanto no PipelineDB, mas √© uma quest√£o de tempo. <br><br><h3>  Resumir </h3><br><blockquote>  O PipelineDB foi projetado para processamento de dados de streaming de alto desempenho.  Ele permite que voc√™ execute c√°lculos em grandes conjuntos de dados sem precisar salvar os dados em si. </blockquote><br>  Com o PipelineDB, quando enviamos um fluxo de dados para o PostgreSQL em um fluxo, os consideramos virtuais.  N√£o salvamos dados, mas agregamos, calculamos e descartamos.  Voc√™ pode criar um servidor de 200 gigabytes e eliminar terabytes de dados atrav√©s de fluxos.  Obteremos o resultado, mas os dados ser√£o descartados. <br><br>  Se, por algum motivo, a "VIS√ÉO CONT√çNUA" do TimescaleDB n√£o for suficiente para voc√™, tente o PipelineDB.  Este √© um projeto de c√≥digo aberto sob a licen√ßa Apache.  N√£o vai a lugar nenhum, embora n√£o esteja mais sendo desenvolvido ativamente.  Mas as coisas podem mudar, o Confluent ainda n√£o escreveu sobre planos de expans√£o. <br><br><h2>  Usando TimescaleDB e PipelineDB </h2><br>  Com o PostgreSQL e duas extens√µes, <b>podemos armazenar e processar grandes matrizes de dados de s√©ries temporais</b> .  Voc√™ pode pensar em muitos aplicativos.  Vejamos um exemplo da minha √°rea de assunto - monitoramento de ve√≠culos. <br><br><img src="https://habrastorage.org/webt/mx/_k/ru/mx_krumolcfgrlfrraktizshhem.jpeg"><br><br>  O equipamento de navega√ß√£o envia continuamente grava√ß√µes de telemetria para nossos servidores.  Eles analisam v√°rios protocolos de texto e bin√°rios em um formato comum e enviam dados para Kafka em um t√≥pico especial.  A partir da√≠, eles passam pela integra√ß√£o com o PipelineDB no fluxo de dados de telemetria no PostgreSQL.  Esse fluxo atualiza a exibi√ß√£o do estado atual dos ve√≠culos e da an√°lise geral da frota e, com base no gatilho, provoca o registro de registros de telemetria na hipertela TimescaleDB. <br><br>  Com extens√µes, temos tr√™s vantagens. <br><br><ul><li>  An√°lise em tempo real. <br></li><li>  Dados de s√©ries temporais de armazenamento. <br></li><li>  Diminui√ß√£o do volume de telemetria armazenada.  Usando o mutador PipelineDB, agregamos dados, por exemplo, por um minuto, calculando os valores m√©dios. <br></li></ul><br>  O Grafana possui suporte interno para os recursos do TimescaleDB.  Portanto, √© poss√≠vel criar gr√°ficos de acordo com as m√©tricas de neg√≥cios diretamente da caixa, at√© as trilhas no mapa por coordenadas.  O departamento de an√°lise ficar√° feliz. <br><br>  Para "tocar" tudo voc√™ mesmo, veja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a demonstra√ß√£o no GitHub</a> e execute a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">imagem</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Docker</a> - dentro da montagem, a partir do PostgreSQL, TimescaleDB e PipelineDB mais recentes. <br><br><h2>  Total </h2><br>  O PostgreSQL permite combinar v√°rias extens√µes, al√©m de adicionar seus pr√≥prios tipos de dados e fun√ß√µes para resolver problemas espec√≠ficos.  No nosso caso, o uso das extens√µes TimescaleDB e PostGIS cobre quase completamente as necessidades de armazenamento de dados de s√©ries temporais e c√°lculos geoespaciais.  Com a extens√£o PipelineDB, podemos realizar c√°lculos cont√≠nuos para v√°rias an√°lises e estat√≠sticas, e o uso de colunas JSONB nos permite armazenar dados fracamente estruturados em um banco de dados relacional.  As solu√ß√µes de c√≥digo aberto s√£o suficientes com a cabe√ßa - n√£o usamos solu√ß√µes comerciais. <br><br>  Essas extens√µes praticamente n√£o imp√µem restri√ß√µes ao ecossistema em torno do PostgreSQL, como solu√ß√µes de alta disponibilidade, sistemas de backup, ferramentas de monitoramento e an√°lise de logs.  N√£o precisamos do MongoDB se houver colunas JSONB e n√£o precisamos do InfluxDB se houver TimescaleDB. <br><br><blockquote>  Voc√™ gosta da hist√≥ria de Ivan e quer compartilhar algo semelhante?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Inscreva-se</a> antes de 7 de setembro no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HighLoad ++</a> em Moscou.  O programa est√° sendo preenchido gradualmente.    ,    ,  , ,  .    ,    ! </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt464303/">https://habr.com/ru/post/pt464303/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt464289/index.html">Como escrever pacotes Go</a></li>
<li><a href="../pt464291/index.html">As 10 linguagens de programa√ß√£o mais influentes dos √∫ltimos 50 anos e seus criadores</a></li>
<li><a href="../pt464293/index.html">Os ganchos s√£o substitu√≠dos no React Redux?</a></li>
<li><a href="../pt464295/index.html">Exemplos de uso de alguns novos recursos JavaScript</a></li>
<li><a href="../pt464299/index.html">0, 0, 1, 0, 2, 0, 2, 2, 1, 6, 0, 5, 0, 2, 6, 5, 4, 0, 5, 3, 0, 3, 2, 9, 0, 4, 9, 3, 6, 14, 0, 6, 3, 5, 15, 0, 5, 3, 5 ...</a></li>
<li><a href="../pt464305/index.html">Pequeno sim. Desembalagem do microvirtual Firecracker</a></li>
<li><a href="../pt464307/index.html">Teste de integra√ß√£o de microsservi√ßos no Scala</a></li>
<li><a href="../pt464309/index.html">Bot√£o de chamada DIY. Raspberry Pi, MajorDoMo, Freeswitch e Linphonec</a></li>
<li><a href="../pt464315/index.html">O filme em que havia solo. Pesquisa Yandex e um breve hist√≥rico de pesquisa por significado</a></li>
<li><a href="../pt464317/index.html">Projeto Konbanwa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>