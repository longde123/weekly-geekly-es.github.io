<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîå üåÅ üë¥üèø Apache Kafka + Spring Boot: Bonjour, microservices üíû üë©üèø‚Äçü§ù‚Äçüë©üèæ üôéüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Dans cet article, nous allons √©crire une application sur Spring Boot 2 √† l'aide d'Apache Kafka sous Linux, de l'installation du JRE √† u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apache Kafka + Spring Boot: Bonjour, microservices</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440400/"> Bonjour, Habr!  Dans cet article, nous allons √©crire une application sur Spring Boot 2 √† l'aide d'Apache Kafka sous Linux, de l'installation du JRE √† une application de microservice fonctionnelle. <br><br>  Des coll√®gues du d√©partement de d√©veloppement frontal qui ont vu l'article se plaignent que je n'explique pas ce que sont Apache Kafka et Spring Boot.  Je crois que quiconque a besoin de monter un projet fini en utilisant les technologies ci-dessus sait ce que c'est et pourquoi il en a besoin.  Si pour le lecteur la question n'est pas vide, voici d'excellents articles sur Habr, ce qu'est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Apache Kafka</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Spring Boot</a> . <br><br>  Nous pouvons nous passer de longues explications sur ce que sont Kafka, Spring Boot et Linux et, √† la place, ex√©cuter le serveur Kafka √† partir de z√©ro sur une machine Linux, √©crire deux microservices et faire en sorte que l'un d'eux envoie des messages √† l'autre - en g√©n√©ral, configurez architecture de microservice compl√®te. <br><br><img src="https://habrastorage.org/webt/5d/p3/ab/5dp3abjx-c62zmfmmtp5tjvbjci.jpeg"><br><br>  Le poste comprendra deux sections.  Dans le premier, nous configurons et ex√©cutons Apache Kafka sur une machine Linux, dans le second, nous √©crivons deux microservices en Java. <br><a name="habracut"></a><br>  Dans la startup, dans laquelle j'ai commenc√© ma carri√®re professionnelle en tant que programmeur, il y avait des microservices sur Kafka, et l'un de mes microservices a √©galement travaill√© avec d'autres via Kafka, mais je ne savais pas comment fonctionnait le serveur lui-m√™me, qu'il soit √©crit sous forme d'application ou est-il d√©j√† compl√®tement encadr√© produit.  Quelle a √©t√© ma surprise et ma d√©ception quand il s'est av√©r√© que Kafka √©tait encore un produit en bo√Æte, et ma t√¢che ne serait pas seulement d'√©crire un client en Java (ce que j'aime faire), ainsi que de d√©ployer et de configurer l'application finalis√©e en devOps (que je d√©teste faire).  Cependant, m√™me si je pouvais le faire sur le serveur virtuel Kafka en moins d'une journ√©e, c'est vraiment assez simple de le faire.  Alors. <br><br>  Notre application aura la structure d'interaction suivante: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wy/id/y5/wyidy5ttuw6eam5buszy6rb8z0m.jpeg"></div><br>  √Ä la fin du post, comme d'habitude, il y aura des liens vers git avec du code de travail. <br><br><h1>  D√©ployer Apache Kafka + Zookeeper sur une machine virtuelle </h1><br>  J'ai essay√© d'√©lever Kafka sur Linux local, sur un coquelicot et sur Linux distant.  Dans deux cas (Linux), j'ai r√©ussi assez rapidement.  Avec le pavot, il ne s'est rien pass√©.  Par cons√©quent, nous l√®verons Kafka sur Linux.  J'ai choisi Ubuntu 18.04. <br><br>  Pour que Kafka travaille, elle a besoin d'un gardien de zoo.  Pour ce faire, vous devez le t√©l√©charger et l'ex√©cuter avant de lancer Kafka. <br><br>  Alors. <br><br><h4>  0. Installez JRE </h4><br>  Cela se fait par les commandes suivantes: <br><br><pre><code class="bash hljs">sudo apt-get update sudo apt-get install default-jre</code> </pre> <br>  Si tout s'est bien pass√©, vous pouvez entrer la commande <br><br><pre> <code class="bash hljs">java -version</code> </pre> <br>  et assurez-vous que Java est install√©. <br><br><h4>  1. T√©l√©chargez Zookeeper </h4><br>  Je n'aime pas les √©quipes magiques sur Linux, surtout quand elles ne donnent que quelques commandes et que ce qu'elles font n'est pas clair.  Par cons√©quent, je d√©crirai chaque action - ce qu'elle fait exactement.  Nous devons donc t√©l√©charger Zookeeper et le d√©compresser dans un dossier pratique.  Il est conseill√© que toutes les applications soient stock√©es dans le dossier / opt, c'est-√†-dire, dans notre cas, ce sera / opt / zookeeper. <br><br>  J'ai utilis√© la commande ci-dessous.  Si vous connaissez d'autres commandes Linux qui, √† votre avis, vous permettront de le faire plus racialement correctement, utilisez-les.  Je suis un d√©veloppeur, pas un devoop, et je communique avec les serveurs au niveau de "la ch√®vre elle-m√™me".  Alors t√©l√©chargez l'application: <br><br><pre> <code class="bash hljs">wget -P /home/xpendence/downloads/ <span class="hljs-string"><span class="hljs-string">"http://apache-mirror.rbc.ru/pub/apache/zookeeper/zookeeper-3.4.12/zookeeper-3.4.12.tar.gz"</span></span></code> </pre> <br>  L'application est t√©l√©charg√©e dans le dossier que vous sp√©cifiez, j'ai cr√©√© le dossier / home / xpendence / Downloads pour y t√©l√©charger toutes les applications dont j'ai besoin. <br><br><h4>  2. D√©ballez Zookeeper </h4><br>  J'ai utilis√© la commande: <br><br><pre> <code class="bash hljs">tar -xvzf /home/xpendence/downloads/zookeeper-3.4.12.tar.gz</code> </pre> <br>  Cette commande d√©compresse l'archive dans le dossier dans lequel vous vous trouvez.  Vous devrez peut-√™tre ensuite transf√©rer l'application vers / opt / zookeeper.  Et vous pouvez imm√©diatement y acc√©der et √† partir de l√†, d√©compressez d√©j√† l'archive. <br><br><h4>  3. Modifier les param√®tres </h4><br>  Dans le dossier / zookeeper / conf / il y a un fichier zoo-sample.cfg, je propose de le renommer zoo.conf, c'est ce fichier que la JVM recherchera au d√©marrage.  Les √©l√©ments suivants doivent √™tre ajout√©s √† ce fichier √† la fin: <br><br><pre> <code class="bash hljs">tickTime=2000 dataDir=/var/zookeeper clientPort=2181</code> </pre> <br>  Cr√©ez √©galement le r√©pertoire / var / zookeeper. <br><br><h4>  4. Lancez Zookeeper </h4><br>  Acc√©dez au dossier / opt / zookeeper et d√©marrez le serveur avec la commande: <br><br><pre> <code class="bash hljs">bin/zkServer.sh start</code> </pre> <br>  ¬´COMMENC√â¬ª devrait appara√Ætre. <br><br>  Apr√®s quoi, je propose de v√©rifier que le serveur fonctionne.  Nous √©crivons: <br><br><pre> <code class="bash hljs">telnet localhost 2181</code> </pre> <br>  Un message doit appara√Ætre indiquant que la connexion a r√©ussi.  Si vous avez un serveur faible et que le message n'appara√Æt pas, essayez √† nouveau - m√™me lorsque STARTED appara√Æt, l'application commence √† √©couter le port beaucoup plus tard.  Quand j'ai essay√© tout cela sur un serveur faible, cela m'est arriv√© √† chaque fois.  Si tout est connect√©, entrez la commande <br><br><pre> <code class="bash hljs">ruok</code> </pre> <br>  Qu'est-ce que cela signifie: "√ätes-vous d'accord?"  Le serveur doit r√©pondre: <br><br><pre> <code class="bash hljs">imok ( !)</code> </pre> <br>  et d√©connectez-vous.  Donc, tout est conforme au plan.  Nous proc√©dons au lancement d'Apache Kafka. <br><br><h4>  5. Cr√©ez un utilisateur sous Kafka </h4><br>  Pour travailler avec Kafka, nous avons besoin d'un utilisateur distinct. <br><br><pre> <code class="bash hljs">sudo adduser --system --no-create-home --disabled-password --disabled-login kafka</code> </pre> <br><h4>  6. T√©l√©chargez Apache Kafka </h4><br>  Il existe deux distributions - binaire et sources.  Nous avons besoin d'un binaire.  En apparence, l'archive avec le binaire est de taille diff√©rente.  Le binaire p√®se 59 Mo et 6,5 Mo p√®sent. <br><br>  T√©l√©chargez le binaire dans le r√©pertoire, en utilisant le lien ci-dessous: <br><br><pre> <code class="bash hljs">wget -P /home/xpendence/downloads/ <span class="hljs-string"><span class="hljs-string">"http://mirror.linux-ia64.org/apache/kafka/2.1.0/kafka_2.11-2.1.0.tgz"</span></span></code> </pre> <br><h4>  7. D√©ballez Apache Kafka </h4><br>  La proc√©dure de d√©ballage n'est pas diff√©rente de la m√™me pour Zookeeper.  Nous d√©compressons √©galement l'archive dans le r√©pertoire / opt et la renommons en kafka afin que le chemin vers le dossier / bin soit / opt / kafka / bin <br><br><pre> <code class="bash hljs">tar -xvzf /home/xpendence/downloads/kafka_2.11-2.1.0.tgz</code> </pre> <br><h4>  8. Modifier les param√®tres </h4><br>  Les param√®tres se trouvent dans /opt/kafka/config/server.properties.  Ajoutez une ligne: <br><br><pre> <code class="bash hljs">delete.topic.enable = <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br>  Ce param√®tre semble √™tre facultatif, il fonctionne sans lui.  Ce param√®tre vous permet de supprimer des sujets.  Sinon, vous ne pouvez tout simplement pas supprimer des sujets via la ligne de commande. <br><br><h4>  9. Nous donnons acc√®s aux r√©pertoires utilisateur kafka Kafka </h4><br><pre> <code class="bash hljs">chown -R kafka:nogroup /opt/kafka chown -R kafka:nogroup /var/lib/kafka</code> </pre> <br><h4>  10. Le lancement tant attendu d'Apache Kafka </h4><br>  Nous entrons dans la commande, apr√®s quoi Kafka devrait commencer: <br><br><pre> <code class="bash hljs">/opt/kafka/bin/kafka-server-start.sh /opt/kafka/config/server.properties</code> </pre> <br>  Si les actions habituelles (Kafka est √©crit en Java et Scala) n'ont pas d√©bord√© dans le journal, alors tout a fonctionn√© et vous pouvez tester notre service. <br><br><h4>  10.1.  Probl√®mes de serveur faibles </h4><br>  Pour des exp√©riences sur Apache Kafka, j'ai pris un serveur faible avec un c≈ìur et 512 Mo de RAM (pour seulement 99 roubles), ce qui s'est av√©r√© √™tre plusieurs probl√®mes pour moi. <br><br>  Pas de m√©moire.  Bien s√ªr, vous ne pouvez pas overclocker avec 512 Mo et le serveur n'a pas pu d√©ployer Kafka en raison d'un manque de m√©moire.  Le fait est que par d√©faut, Kafka consomme 1 Go de m√©moire.  Pas √©tonnant qu'il ait disparu :) <br><br>  Nous allons √† kafka-server-start.sh, zookeeper-server-start.sh.  Il existe d√©j√† une ligne qui r√©gule la m√©moire: <br><br><pre> <code class="java hljs">export KAFKA_HEAP_OPTS=<span class="hljs-string"><span class="hljs-string">"-Xmx1G -Xms1G"</span></span></code> </pre> <br>  Changez-le en: <br><br><pre> <code class="java hljs">export KAFKA_HEAP_OPTS=<span class="hljs-string"><span class="hljs-string">"-Xmx256M -Xms128M"</span></span></code> </pre> <br>  Cela r√©duira l'app√©tit de Kafka et vous permettra de d√©marrer le serveur. <br><br>  Le deuxi√®me probl√®me avec un ordinateur faible est le manque de temps pour se connecter √† Zookeeper.  Par d√©faut, cela donne 6 secondes.  Si le fer est faible, ce n'est bien s√ªr pas suffisant.  Dans server.properties nous augmentons le temps de connexion au zukipper: <br><br><pre> <code class="bash hljs">zookeeper.connection.timeout.ms=30000</code> </pre> <br>  J'ai mis une demi-minute. <br><br><h4>  11. Testez le serveur Kafka </h4><br>  Pour ce faire, nous ouvrirons deux terminaux, l'un lancera le producteur, l'autre le consommateur. <br>  Dans la premi√®re console, entrez une ligne: <br><br><pre> <code class="bash hljs">/opt/kafka/bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> /opt/kafka/bin/kafka-console-producer.sh --broker-list localhost:9092 --topic <span class="hljs-built_in"><span class="hljs-built_in">test</span></span></code> </pre> <br>  Cette ic√¥ne devrait appara√Ætre, indiquant que le producteur est pr√™t √† envoyer des spams: <br><br><pre> <code class="bash hljs">&gt;</code> </pre> <br>  Dans la deuxi√®me console, entrez la commande: <br><br><pre> <code class="bash hljs">/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> --from-beginning</code> </pre> <br>  Maintenant, en tapant dans la console du producteur, lorsque vous appuyez sur Entr√©e, il appara√Ætra dans la console du consommateur. <br><br> <a href="" rel="nofollow"><img src="https://habrastorage.org/webt/k7/uu/kf/k7uukff1u2kyygrgetrnvjnqmmg.png"></a> <br><br>  Si vous voyez √† l'√©cran √† peu pr√®s la m√™me chose que moi - f√©licitations, le pire est pass√©! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n7/rg/lz/n7rglz4s3wvbqzg_chzjjooiazw.jpeg"></div><br>  Il ne nous reste plus qu'√† √©crire quelques clients sur Spring Boot qui communiqueront entre eux via Apache Kafka. <br><br><h1>  √âcrire une application sur Spring Boot </h1><br>  Nous √©crirons deux applications qui √©changeront des messages via Apache Kafka.  Le premier message sera appel√© kafka-server et contiendra √† la fois le producteur et le consommateur.  Le second sera appel√© kafka-tester, il est con√ßu de mani√®re √† disposer d'une architecture de microservice. <br><br><h3>  kafka-server </h3><br>  Pour nos projets cr√©√©s via Spring Initializr, nous avons besoin du module Kafka.  J'ai ajout√© Lombok et Web, mais c'est une question de go√ªt. <br><br>  Le client Kafka se compose de deux composants - le producteur (il envoie des messages au serveur Kafka) et le consommateur (il √©coute le serveur Kafka et en prend de nouveaux messages sur les sujets auxquels il est abonn√©).  Notre t√¢che est d'√©crire les deux composants et de les faire fonctionner. <br><br>  Consommateur: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KafkaConsumerConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Value</span></span>(<span class="hljs-string"><span class="hljs-string">"${kafka.server}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String kafkaServer; <span class="hljs-meta"><span class="hljs-meta">@Value</span></span>(<span class="hljs-string"><span class="hljs-string">"${kafka.group.id}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String kafkaGroupId; <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> KafkaListenerContainerFactory&lt;?&gt; batchFactory() { ConcurrentKafkaListenerContainerFactory&lt;Long, AbstractDto&gt; factory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentKafkaListenerContainerFactory&lt;&gt;(); factory.setConsumerFactory(consumerFactory()); factory.setBatchListener(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); factory.setMessageConverter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BatchMessagingMessageConverter(converter())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> factory; } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> KafkaListenerContainerFactory&lt;?&gt; singleFactory() { ConcurrentKafkaListenerContainerFactory&lt;Long, AbstractDto&gt; factory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentKafkaListenerContainerFactory&lt;&gt;(); factory.setConsumerFactory(consumerFactory()); factory.setBatchListener(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); factory.setMessageConverter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringJsonMessageConverter()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> factory; } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ConsumerFactory&lt;Long, AbstractDto&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consumerFactory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefaultKafkaConsumerFactory&lt;&gt;(consumerConfigs()); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> KafkaListenerContainerFactory&lt;?&gt; kafkaListenerContainerFactory() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentKafkaListenerContainerFactory&lt;&gt;(); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Map&lt;String, Object&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consumerConfigs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Map&lt;String, Object&gt; props = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaServer); props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, LongDeserializer.class); props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); props.put(ConsumerConfig.GROUP_ID_CONFIG, kafkaGroupId); props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> props; } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringJsonMessageConverter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">converter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringJsonMessageConverter(); } }</code> </pre> <br>  Nous avons besoin de 2 champs initialis√©s avec des donn√©es statiques de kafka.properties. <br><br><pre> <code class="java hljs">kafka.server=localhost:<span class="hljs-number"><span class="hljs-number">9092</span></span> kafka.group.id=server.broadcast</code> </pre> <br>  kafka.server est l'adresse √† laquelle notre serveur se bloque, dans ce cas, local.  Par d√©faut, Kafka √©coute sur le port 9092. <br><br>  kafka.group.id est un groupe de consommateurs, au sein duquel une instance du message est remise.  Par exemple, vous avez trois courriers dans un groupe et ils √©coutent tous le m√™me sujet.  D√®s qu'un nouveau message appara√Æt sur le serveur avec cette rubrique, il est remis √† un membre du groupe.  Les deux autres consommateurs ne re√ßoivent pas le message. <br><br>  Ensuite, nous cr√©ons une usine pour les consommateurs - ConsumerFactory. <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ConsumerFactory&lt;Long, AbstractDto&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consumerFactory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefaultKafkaConsumerFactory&lt;&gt;(consumerConfigs()); }</code> </pre> <br>  Initialis√© avec les propri√©t√©s dont nous avons besoin, il servira √† l'avenir d'usine standard aux consommateurs. <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Map&lt;String, Object&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consumerConfigs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Map&lt;String, Object&gt; props = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaServer); props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, LongDeserializer.class); props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); props.put(ConsumerConfig.GROUP_ID_CONFIG, kafkaGroupId); props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> props; }</code> </pre> <br>  consumerConfigs ne sont que des configurations de carte.  Nous fournissons l'adresse du serveur, le groupe et les d√©s√©rialiseurs. <br><br>  En outre, l'un des points les plus importants pour un consommateur.  Le consommateur peut recevoir √† la fois des objets uniques et des collections - par exemple, StarshipDto et List.  Et si nous obtenons StarshipDto en JSON, alors nous obtenons List en gros, en tant que tableau JSON.  Par cons√©quent, nous avons au moins deux fabriques de messages - pour les messages simples et pour les tableaux. <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> KafkaListenerContainerFactory&lt;?&gt; singleFactory() { ConcurrentKafkaListenerContainerFactory&lt;Long, AbstractDto&gt; factory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentKafkaListenerContainerFactory&lt;&gt;(); factory.setConsumerFactory(consumerFactory()); factory.setBatchListener(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); factory.setMessageConverter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringJsonMessageConverter()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> factory; }</code> </pre> <br>  Nous instancions ConcurrentKafkaListenerContainerFactory, tapons Long (cl√© de message) et AbstractDto (valeur de message abstraite), et initialisons ses champs avec des propri√©t√©s.  Bien s√ªr, nous initialisons l'usine avec notre usine standard (qui contient d√©j√† des configurations de carte), puis nous marquons que nous n'√©coutons pas les paquets (les m√™mes tableaux) et sp√©cifions un convertisseur JSON simple comme convertisseur. <br><br>  Lorsque nous cr√©ons une usine pour les packages / tableaux (batch), la principale diff√©rence (en dehors du fait que nous marquons que nous √©coutons les packages) est que nous sp√©cifions comme convertisseur un convertisseur de package sp√©cial qui convertira les packages compos√©s de √† partir de cha√Ænes JSON. <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> KafkaListenerContainerFactory&lt;?&gt; batchFactory() { ConcurrentKafkaListenerContainerFactory&lt;Long, AbstractDto&gt; factory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentKafkaListenerContainerFactory&lt;&gt;(); factory.setConsumerFactory(consumerFactory()); factory.setBatchListener(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); factory.setMessageConverter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BatchMessagingMessageConverter(converter())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> factory; } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringJsonMessageConverter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">converter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringJsonMessageConverter(); }</code> </pre> <br>  Et encore une chose.  Lors de l'initialisation des beans Spring, le bac sous le nom kafkaListenerContainerFactory peut ne pas √™tre compt√© et l'application sera ruin√©e.  Il y a s√ªrement des options plus √©l√©gantes pour r√©soudre le probl√®me, √©crivez √† leur sujet dans les commentaires, pour l'instant je viens de cr√©er un bac d√©charg√© avec des fonctionnalit√©s du m√™me nom: <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> KafkaListenerContainerFactory&lt;?&gt; kafkaListenerContainerFactory() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentKafkaListenerContainerFactory&lt;&gt;(); }</code> </pre> <br>  Le consommateur est install√©.  Nous passons au producteur. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KafkaProducerConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Value</span></span>(<span class="hljs-string"><span class="hljs-string">"${kafka.server}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String kafkaServer; <span class="hljs-meta"><span class="hljs-meta">@Value</span></span>(<span class="hljs-string"><span class="hljs-string">"${kafka.producer.id}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String kafkaProducerId; <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Map&lt;String, Object&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">producerConfigs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Map&lt;String, Object&gt; props = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaServer); props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, LongSerializer.class); props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class); props.put(ProducerConfig.CLIENT_ID_CONFIG, kafkaProducerId); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> props; } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ProducerFactory&lt;Long, StarshipDto&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">producerStarshipFactory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefaultKafkaProducerFactory&lt;&gt;(producerConfigs()); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> KafkaTemplate&lt;Long, StarshipDto&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kafkaTemplate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ KafkaTemplate&lt;Long, StarshipDto&gt; template = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KafkaTemplate&lt;&gt;(producerStarshipFactory()); template.setMessageConverter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringJsonMessageConverter()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> template; } }</code> </pre> <br>  Parmi les variables statiques, nous avons besoin de l'adresse du serveur kafka et de l'ID du producteur.  Il peut √™tre n'importe quoi. <br><br>  Dans les configs, comme on le voit, il n'y a rien de sp√©cial.  Presque la m√™me chose.  Mais en ce qui concerne les usines, il y a une diff√©rence significative.  Nous devons enregistrer un mod√®le pour chaque classe, dont nous enverrons les objets au serveur, ainsi qu'une usine pour celui-ci.  Nous en avons une, mais il peut y en avoir des dizaines. <br><br>  Dans le mod√®le, nous marquons que nous allons s√©rialiser des objets en JSON, et cela suffit peut-√™tre. <br><br>  Nous avons un consommateur et un producteur, il reste √† √©crire un service qui va envoyer et recevoir des messages. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-meta"><span class="hljs-meta">@Slf</span></span>4j <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StarshipServiceImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StarshipService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> KafkaTemplate&lt;Long, StarshipDto&gt; kafkaStarshipTemplate; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ObjectMapper objectMapper; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StarshipServiceImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(KafkaTemplate&lt;Long, StarshipDto&gt; kafkaStarshipTemplate, ObjectMapper objectMapper)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.kafkaStarshipTemplate = kafkaStarshipTemplate; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.objectMapper = objectMapper; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StarshipDto dto)</span></span></span><span class="hljs-function"> </span></span>{ kafkaStarshipTemplate.send(<span class="hljs-string"><span class="hljs-string">"server.starship"</span></span>, dto); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@KafkaListener</span></span>(id = <span class="hljs-string"><span class="hljs-string">"Starship"</span></span>, topics = {<span class="hljs-string"><span class="hljs-string">"server.starship"</span></span>}, containerFactory = <span class="hljs-string"><span class="hljs-string">"singleFactory"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StarshipDto dto)</span></span></span><span class="hljs-function"> </span></span>{ log.info(<span class="hljs-string"><span class="hljs-string">"=&gt; consumed {}"</span></span>, writeValueAsString(dto)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeValueAsString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StarshipDto dto)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> objectMapper.writeValueAsString(dto); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (JsonProcessingException e) { e.printStackTrace(); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"Writing value to JSON failed: "</span></span> + dto.toString()); } } }</code> </pre> <br>  Il n'y a que deux m√©thodes dans notre service, elles nous suffisent pour expliquer le travail du client.  Nous c√¢blons automatiquement les mod√®les dont nous avons besoin: <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> KafkaTemplate&lt;Long, StarshipDto&gt; kafkaStarshipTemplate;</code> </pre> <br>  M√©thode du producteur: <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StarshipDto dto)</span></span></span><span class="hljs-function"> </span></span>{ kafkaStarshipTemplate.send(<span class="hljs-string"><span class="hljs-string">"server.starship"</span></span>, dto); }</code> </pre> <br>  Pour envoyer un message au serveur, il suffit d'appeler la m√©thode d'envoi sur le mod√®le et d'y transf√©rer le sujet (sujet) et notre objet.  L'objet sera s√©rialis√© en JSON et volera vers le serveur sous la rubrique sp√©cifi√©e. <br><br>  La m√©thode d'√©coute ressemble √† ceci: <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@KafkaListener</span></span>(id = <span class="hljs-string"><span class="hljs-string">"Starship"</span></span>, topics = {<span class="hljs-string"><span class="hljs-string">"server.starship"</span></span>}, containerFactory = <span class="hljs-string"><span class="hljs-string">"singleFactory"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StarshipDto dto)</span></span></span><span class="hljs-function"> </span></span>{ log.info(<span class="hljs-string"><span class="hljs-string">"=&gt; consumed {}"</span></span>, writeValueAsString(dto)); }</code> </pre> <br>  Nous marquons cette m√©thode avec l'annotation @KafkaListener, o√π nous indiquons tout ID que nous aimons, les sujets √©cout√©s et une usine qui convertira le message re√ßu en ce dont nous avons besoin.  Dans ce cas, puisque nous acceptons un objet, nous avons besoin d'une seule usine.  Pour Liste &lt;?&gt;, Sp√©cifiez batchFactory.  En cons√©quence, nous envoyons l'objet au serveur kafka en utilisant la m√©thode send et l'obtenons en utilisant la m√©thode consume. <br><br>  Vous pouvez √©crire un test en 5 minutes qui montrera toute la force de Kafka, mais nous irons plus loin - passez 10 minutes et √©crivez une autre application qui enverra des messages au serveur que notre premi√®re application √©coutera. <br><br><h2>  testeur de kafka </h2><br>  Ayant l'exp√©rience d'√©crire la premi√®re application, nous pouvons facilement √©crire la seconde, surtout si nous copions la p√¢te et le package dto, enregistrons uniquement le producteur (nous n'enverrons que des messages) et ajouterons la seule m√©thode d'envoi au service.  En utilisant le lien ci-dessous, vous pouvez facilement t√©l√©charger le code du projet et vous assurer qu'il n'y a rien de compliqu√©. <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Scheduled</span></span>(initialDelay = <span class="hljs-number"><span class="hljs-number">10000</span></span>, fixedDelay = <span class="hljs-number"><span class="hljs-number">5000</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">produce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ StarshipDto dto = createDto(); log.info(<span class="hljs-string"><span class="hljs-string">"&lt;= sending {}"</span></span>, writeValueAsString(dto)); kafkaStarshipTemplate.send(<span class="hljs-string"><span class="hljs-string">"server.starship"</span></span>, dto); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> StarshipDto </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createDto</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StarshipDto(<span class="hljs-string"><span class="hljs-string">"Starship "</span></span> + (LocalTime.now().toNanoOfDay() / <span class="hljs-number"><span class="hljs-number">1000000</span></span>)); }</code> </pre> <br>  Apr√®s les 10 premi√®res secondes, le testeur de kafka commence √† envoyer des messages avec les noms des vaisseaux spatiaux au serveur Kafka toutes les 5 secondes (l'image est cliquable). <br><br> <a href="" rel="nofollow"><img src="https://habrastorage.org/webt/oo/ri/gk/oorigkqltxuntytvhzbarlninhk.png"></a> <br><br>  L√†, ils sont √©cout√©s et re√ßus par kafka-server (l'image est √©galement cliquable). <br><br> <a href="" rel="nofollow"><img src="https://habrastorage.org/webt/cs/w-/vc/csw-vcgajjpjymkdxcwibqllnoi.png"></a> <br><br>  J'esp√®re que ceux qui r√™vent de commencer √† √©crire des microservices chez Kafka r√©ussiront aussi facilement que moi.  Et voici les liens vers les projets: <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">serveur kafka</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">testeur de kafka</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr440400/">https://habr.com/ru/post/fr440400/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr440388/index.html">Intervalles: la prochaine √©volution C ++</a></li>
<li><a href="../fr440390/index.html">Le monde diversifi√© des syst√®mes embarqu√©s et la place d'Embox dans celui-ci</a></li>
<li><a href="../fr440392/index.html">WebRTC sur votre site - pas de bugs et pas de budget</a></li>
<li><a href="../fr440394/index.html">PostgreSQL el√©vation de privil√®ges - CVE-2018-10915 parsing</a></li>
<li><a href="../fr440398/index.html">Historique de la participation (et de la victoire) √† la Russian AI Cup 2018 - CodeBall</a></li>
<li><a href="../fr440402/index.html">D√©veloppeur SearchFace sur les fonctionnalit√©s de l'algorithme</a></li>
<li><a href="../fr440404/index.html">"Architecture de l'information": mitap dans OZON</a></li>
<li><a href="../fr440410/index.html">S√©lection, mise en cache et affichage de photos sur la carte</a></li>
<li><a href="../fr440412/index.html">Zimbra Collaboration Suite et MS Exchange sur le m√™me domaine</a></li>
<li><a href="../fr440414/index.html">√Ä propos de linter, de la qualit√© du code, de la qualit√© en g√©n√©ral et de la gestion de la qualit√©</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>