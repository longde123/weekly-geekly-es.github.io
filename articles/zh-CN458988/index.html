<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📨 👨🏾‍🤝‍👨🏻 🧑🏽‍🤝‍🧑🏼 纹理，或成为Surface Artist所需要了解的知识。 第4部分。模型，法线和扫描 🔥 👛 🤞🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="模型，法线和扫描 
 以我的拙见，纹理艺术家应该为作品的展开负责。 不是针对扫描本身（通常应由3D艺术家甚至个别UV专家完成），而是其样式。 它应根据要求在给定的情况下确定岛的位置，应如何旋转以及可以拉动多少岛。 

 是艺术家（根据纹理（以后，按表面））必须确定岛的比例（比例）（稍后会详细说明）。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>纹理，或成为Surface Artist所需要了解的知识。 第4部分。模型，法线和扫描</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458988/"><h2> 模型，法线和扫描 </h2><br> 以我的拙见，纹理艺术家应该为作品的展开负责。 不是针对扫描本身（通常应由3D艺术家甚至个别UV专家完成），而是其样式。 它应根据要求在给定的情况下确定岛的位置，应如何旋转以及可以拉动多少岛。 <br><br> 是艺术家（根据纹理（以后，按表面））必须确定岛的比例（比例）（稍后会详细说明）。 <br><br> 在这一部分中，我们研究模型，扫描和法线。 为第一个完整模型（虽然很简单）创建纹理，然后在虚幻引擎4中对其进行配置。 <br><br> 注意事项 假设此时您已经确定了法线贴图以及为什么需要它。 因为在本教程中，我们将经常谈论它。 <br><br>  <b>第1部分。像素</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a> 。 <br>  <b>第2部分。</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处的</a> <b>蒙版和纹理</b> 。 <br>  <b>第3部分。</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处的</a> <b>PBR和材料</b> 。 <br>  <b>第4部分。模型，法线和扫描</b> -您已阅读。 <br>  <b>第5部分。</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里的</a> <b>材料系统</b> 。 <br><a name="habracut"></a><br><h3> 型号和PBR。 练习 </h3><br> 我不会谈论如何创建模型或如何清理/构建网格。 可以从许多课程中获得此信息，这些课程都是在公共领域和付费领域。 现在，我们的任务是分析游戏模型结构的特定限制以及目前存在的解决方案。 <br><br> 但是首先，我们将对模型进行纹理处理，并首先看一下它的局限性。 我们将在这家商店工作： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f69/836/6f5/f698366f526f3ddfb79bad00947b28b6.jpg" alt="图片"><br><br> 为此，我们将需要下载网格物体本身以及为其预先准备的法线贴图（下面我将清楚解释为什么我们准备了它）。 链接<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">到这里</a> 。 <br><br> 我也想将其底座设为木制，将腿设为金属。 好吧，一点污垢传播了。 因此，我们需要2种材料： <br><br><ol><li> 那棵树 </li><li> 机加工金属。 </li></ol><br> 我们不会去除单独材料中的污垢，而是在Substance Painter中使用生成器并在程序内部创建污垢。 <br><br> 让我们开始练习并创建一个标准项目，指定工作台，纹理并运行它： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e15/86a/714/e1586a71474e80d115e811d25beec3a8.jpg" alt="图片"><br><br> 请注意，这一次我们需要指定法线贴图格式-OpenGL。 我已经在最后一部分中写道，不同程序对法线贴图的读取方式有所不同。 该卡是为使用OpenGL的程序生成的。 <br><br> 我们已经加载了9个纹理+主网格。 <br><br> 现在我们将不制作任何图层和文件夹，但让我们尽可能地靠近商店。 我们对对象的边缘特别感兴趣： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/727/af3/c70/727af3c704cedafec83900006c2256bf.jpg" alt="图片"><br><br> 例如，我突出显示了长凳的一侧。 现在她尽可能地完美。 就是说，两侧合而为一，形成了完美的角度。 不管我们将这个联合关系拉近多少，它始终都是完美的。 实际上，没有理想的角度，如果适当扩大，甚至剃刀的边缘也会变圆。 这就是为什么肋骨现在看起来不像电影的原因。 这样的模型看起来非常虚弱，当我们在游戏中看到它们时，即使我们没有直接在模型上注意到这些角度，我们也会立即感觉到视觉图像的所有弱点。 <br><br>  <b>这是该模型的第一个限制。</b> <br><br> 以前，当视频卡的资源不允许在一帧中处理数百万个顶点时，解决方案是使用普通卡的纹理。 他们指出应该如何开始反射光线，以便使这些边界具有圆角感。 专门针对此长凳，这样的法线图如下所示： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5cb/2fc/c42/5cb2fcc427286f1072b45110ec1d3f07.jpg" alt="图片"><br><br> 即使只是查看此地图形式的一组参数，您也可以感觉到法线地图将如何平滑各个角落。 <br><br> 现在，让我们将该法线贴图指示为主贴图（也就是说，它将始终附加到结果上，就像没有遮罩的最低图层一样）。 为此，我们需要打开对象主要纹理的设置，并在法线贴图的参数中指定我们的纹理： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c3a/2f5/c63/c3a2f5c6337fe9291804e6254216f445.jpg" alt="图片"><br><br> 并查看结果： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d08/cb9/a5a/d08cb9a5a29f0990d91a42a8bdfe20b1.jpg" alt="图片"><br><br> 这是处理尖锐边缘的第一种最著名且最常用的方法-烘烤法线贴图中的倒角。 也就是说，模型仍然很僵硬，但是其边缘的法线贴图开始使光线扭曲，从而产生了美丽的柔和斜角的错觉。 在Internet上，您可以找到有关如何执行此操作的大量信息。 对于像这样的工作台这样的简单对象，您不能创建高多边形模型（也不能相应地从中烘焙），而是会在程序中生成带有倒角的法线贴图。 例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Modo</a>程序可以执行此操作。 我们的工作台上有在Modo中生成的法线贴图。 <br><br> 但是我们省略了斜角烘烤的主题，并继续使工作台纹理化。 <br><br><div class="spoiler">  <b class="spoiler_title">如果法线是凹的</b> <div class="spoiler_text"> 如果倒角没有像我的倒角那样平滑，但是出现了低谷的错觉，那么在Substance Painter中创建项目时，您忘了将常规显示格式从DirectX更改为OpenGL。 </div></div><br> 现在，为图层创建2个文件夹，在每个图层上创建并传输1个图层，并将所有纹理贴图插入每个图层。 不要忘记命名，因此您不会感到困惑： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/672/6ba/82a/6726ba82a6369f58c1341ac2d089c043.jpg" alt="图片"><br><br> 现在，层的层次结构对我们而言并不重要，因为这些材料（金属和木材）不会彼此相交-我们不会遇到金属开始穿过树出现的情况，反之亦然。 但是我们仍然需要遮罩，因此现在我们需要限制不同岛上图层的可见性，因此现在要在两个文件夹中添加黑色遮罩： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a9b/5f3/b9d/a9b5f3b9d35349d26e5f3acf7840a78e.jpg" alt="图片"><br><br> 现在，我们将指示哪些扫描岛应屏蔽为白色，哪些应为黑色。 为此，选择遮罩并切换到孤岛选择模式： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/662/c0c/bbf/662c0cbbf97956bd3d2d53c6722bf465.jpg" alt="图片"><br><br> 单击主工作台上的模型（如果选择了树遮罩），将得到以下结果： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3bd/69f/df3/3bd69fdf36b0a85114b1c30bc01cc245.jpg" alt="图片"><br><br> 正如您在屏幕截图中看到的那样，蒙版已更新，现在它在岛上有一条巨大的白色条纹。 因此，我们在整个工作台周围绘制： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f5e/343/42d/f5e34342def3e7b82f902c8bea142f52.jpg" alt="图片"><br><br> 树木本身的材料并不是最成功的，但是我们现在的目标不是让每一件事都做得尽可能漂亮，而是要了解工作原理。 <br><br> 我们将对金属遮罩进行相同的操作，注意可见的区域带有腿部孤岛。 选择金属遮罩并指定对象的必要部分： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c3c/d23/30d/c3cd2330d1339b8dd9c8d64db51d4e7a.jpg" alt="图片"><br><br> 还必须进入交界处难以到达的地方并标记我们在那里需要木材和金属的岛屿： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c3b/e07/7d9/c3be077d95c7c558702b0d7569500f0e.jpg" alt="图片"><br><br> 如果仔细检查腿，您会注意到<b>模型</b>的<b>第二个局限性</b> 。 <br> 扫描未正确执行，并且腿两边之间的钢图案不一致-其纹理指向不同的方向，视觉上很醒目（方向由箭头标记）： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b7/f85/d23/8b7f85d2332ee1cc035c4790dc6d9f21.jpg" alt="图片"><br><br> 这正是一个限制，可以通过将岛平整并拉伸来克服。 现在，在其上绘制了向下箭头的岛看起来像这样（以橙色突出显示）： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/431/cdd/fc1/431cddfc156a2a123d627a1a0dab9965.jpg" alt="图片"><br><br> 为了解决此问题，必须将岛整齐地对齐成一行： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/24c/db2/d1c/24cdb2d1cce6fc886e0ec4222b48951e.jpg" alt="图片"><br><br> 然后，我们将解决此限制，但还会有另一个-拉： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/74f/984/0e6/74f9840e63c6a6cdf2b5e0e32ce9bb04.jpg" alt="图片"><br><br> 如果拉动不是很引人注目，或者拉动的纹理不能使它们显得不那么糟，那就不会太糟。 但是您需要对它们小心，有时您不得不忍受材料可能存在不一致的事实。 <br><br> 通常，对象中的接缝问题一直没有解决，直到最后。 将来，我们将考虑其他方法来消除接缝，甚至在下一部分中尝试使用非常酷的方法。 <br><br>  <b>板凳上的磨损</b> <br><br> 众所周知，油漆或材料碎片早晚会在万物的所有表面上产生裂纹。 大量的划痕和碎屑出现在此处： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bc2/196/cf0/bc2196cf08e525de6ccdeab05edbf780.jpg" alt="图片"><br><br> 因此，让我们创建一个遮罩，将来可以在其下显示相同的磨损，划痕和碎屑。 <br><br> 为此，请打开主纹理设置（我们在其中指示了法线贴图），然后在此处选择“ <b>烘焙网格图”</b> 。 <br><br> 在出现的窗口中，删除所有不必要的复选标记，仅保留“曲率”并通过单击“ <b>烘焙”（附加名称）“ Mesh Maps”</b>进行<b>烘焙</b> ： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/afa/54a/7a8/afa54a7a846d6c0a50a04a92e4cf9cf9.jpg" alt="图片"><br><br> 创建完纹理后，将在架子上的Project标签下提供该纹理： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/92d/05d/c1e/92d05dc1e4ed625363dec2463020edbe.jpg" alt="图片"><br><br> 而且此纹理将自动连接为纹理设置中的主要Curvature参数。 我们从那里删除它： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5d0/d62/075/5d0d620753afa7926d429a99b4c014a5.jpg" alt="图片"><br><br> 如果我们在层次结构的顶部创建一个新层并将结果纹理设置为“基础颜色”参数，我们将看到以下结果： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b6d/e4d/31f/b6de4d31f360c6586083eb9d4dc8701d.jpg" alt="图片"><br><br> 现在删除此层，因为我们仅出于理解需要。 <br><br> 接下来，创建一个文件夹，将其命名为Folder Dirt并将其放置在树层上方的树文件夹中。 在此文件夹中，创建一个名为LowLayer_Dirt的图层，并在该文件夹本身上创建一个黑色蒙版，以使该图层不与结果重叠： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a2b/e34/130/a2be34130bd13543b622fdb2484aec0b.jpg" alt="图片"><br><br> 我们将指出，泥面罩应包含“填充”效果以添加我们创建的纹理（曲率）和其他“色阶”效果。 <br><br> 为什么现在需要“色阶”效果？ 您可能注意到面罩太轻了？ 现在，我们将需要裁剪颜色，以便在边缘上留下浅白色斑点，而其余部分完全变成黑色。 <br><br> 最终结果应如下所示： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a69/027/375/a69027375f4a983b49a4a7315b823912.jpg" alt="图片"><br><br> 通过这种方式，我们为污垢创建了“ <b>边界线</b> ”。 现在我们需要限制污垢本身。 为此，请对LowLayer_Dirt图层本身应用黑色蒙版。 之后，添加Fill效果，并在其中指定Dirt4遮罩，该遮罩隐藏在Procedurals标记下： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/921/f36/e5f/921f36e5fa0f773c302ca0d31e0dc542.jpg" alt="图片"><br><br> 在屏幕截图的上方，圈出了Dirt 4蒙版的其他参数，事实是，这不是我们用来呈现它的格式的纹理。 根据某些规则，这是一个随机数生成器。 换句话说，一种程序纹理，其中像素具有生成的强度。 您可以使用诸如扭动“平衡”和“对比度”之类的参数来获得所需的结果，现在将“ LowLayer_Dirt”层中的“高度”参数更改为-0.35并查看结果： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1e9/a39/3ec/1e9a393ecfea54e41e0d129027363194.jpg" alt="图片"><br><br> 我再说一遍。 现在，我们的目标不是在长凳上完成完美的定性绘画，而是使用基础知识和使用口罩的培训。 <br><br>  <b>现在做作业</b> <br><br> 总体而言，我们现在研究了如何针对彼此不相交的特定材料快速应用蒙版。 您可能会猜到，要在树上应用清漆-我们需要在树的文件夹中创建一个图层。 但是现在我们不会这样做，任务本身仍然是家庭作业： <br><br><ul><li> 给树上漆 </li><li> 在清漆上产生划痕（这些划痕仅在一定角度下可见，因为它们会推动清漆，但不会损坏木材） </li><li> 在清漆下划痕 </li></ul><br> 将您的工艺品发表评论-有趣的是=） <br><br>  <b>合计</b> <br><br>  <b>我们已经介绍了如何使用蒙版对模型进行纹理化。</b>  <b>如何涂抹污垢，碎屑和划痕。</b> <br><br> 为了使您将来对这一切的工作方式有一个简单的了解，请记住规则-一种材料-一个用于处理它的文件夹。 因此，您可以更好地控制蒙版和图层。 例如，通过在带有材料的文件夹中放置一层污垢，您仍然可以在文件夹的遮罩级别上控制此材料的总可见性，现在还可以控制其上的灰尘（或其下一层）。 例如，实际上，另一个纹理可能位于纹理（材料）之下-塑料可能隐藏在金属涂层之下。 在这种情况下，金属是金属的主要层，塑料是金属下的附加层（尽管在上面的教程中，我们在芯片上方放置了一个带有切屑的层并放置在了树的上方，实际上这是层次结构中的下层。换句话说，这是一个错误）。 <br><br> 在开始创建纹理之前，必须先计算材料层及其层次结构。 这一点很重要，因为错误的图层布局最终会导致以下事实：您必须重新开始，并花费大量时间检查为什么纹理仅显示金属图层。 <br><br> 总的来说，在此我们关闭了如何在PBR框架内构造游戏对象的重要话题。 其他一切都是技术。 我的任务是告诉所有这些内容的本质，基础，以使您不再有其他问题，例如“粗糙度卡与金属贴图和法线贴图有什么区别？”  （我将一无所获地立即回答），然后出现问题-“如何改进？ 如何做得更好，更高效？” <br><br>  <b>我们研究了一些具有解决方案的局限性。</b> <br><br><ul><li> 倒角。 </li><li> 对岛屿位置的限制。 </li></ul><br> 可以以一种或另一种方式规避这两个限制。 在第一种情况下，我们创建了一个模拟弯曲的法线贴图，在第二种情况下，为了大图，我们绘制了孤岛并牺牲了细节（创建拉动）。 <br><br> 在第二种情况下，您还需要记住岛的方向-它们需要以协调的方式进行部署，就像材料中图案的方向一样。 否则，将出现上述困难。 <br><br><h3> 扫瞄 </h3><br> 暂时暂留物质画家。 不要关闭项目，稍后将纹理导出到虚幻引擎4时，它将很方便。 <br><br> 在这部分导师中，我们将检查物体的掠过度，岛屿的密度，最后研究纹素密度的现象。 <br> 从texel开始。 <br><br>  <b>特塞尔</b> <br><br> 纹素是纹理像素（ba-dum-s）。 <br><br>  <b>纹素和岛的密度</b> <br><br> 为了不使监视器像素（现实世界中的物理元素，始终为固定大小）与纹理像素（可视化的正方形，可以改变其大小在监视器屏幕上并且通常总体上会变形）相混淆，该纹理像素称为texel（纹理和像素）。 <br><br> 这里有关于这个主题的相当完整的文章。 翻译在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a> 。 <br><br> 但是，我们将再次考虑这种现象，因为在将来，如果我们不了解纹理像素的整体概念，那么我们将很难进一步开展工作。 甚至更多，要成为一名表面艺术家将非常困难。 <br><br> 从这一刻起，我们开始正确说话-像素和纹理像素。 像素是监视元素。  Texel是纹理元素。 <br><br> 因此，让我们重复过去，纹理像素是信息显示的虚构单位。 它仅存在于数字中（来自各个通道的数字数组），但是为了使我们更轻松地使用渲染参数，引入了纹理作为数字数组的视觉替代。 我想没有人会乐于用数字单独画一艘宇宙飞船，请牢记第8行和第453列中的纹素应比第284行和第112列中的纹素少1个想法。 在Photoshop中戳画笔更容易。 <br> 渲染器（可视化系统）读取这些数字并将其显示为正方形（纹理像素）。 以正方形形式显示纹理像素是有条件的事情。 这尤其取决于模型扫描岛的密度和张力。 <br><br> 稍后，我们将讨论席卷岛的密度，但现在我们将解决席卷岛的紧张局势。 <br><br> 想象一下一块布料（如果很难想象，拿一块可以拉伸的布料）。 在平静状态下，其上的图案（或材料图案）保持不变，如制造商所期望的那样。 但是，如果我们开始拉伸织物，那么图案也会开始拉伸。 当我们拉伸（或压缩）模型的扫描岛时，会产生相同的效果： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f80/705/a7d/f80705a7d35ed2a9dcfb195a0287ae98.jpg" alt="图片"><br><br> 左侧和右侧的扫描位置如下： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/804/b27/e58/804b27e58c57df8723355a0f181ababf.jpg" alt="图片"><br><br> 从示例中我们可以看到，在挤压左侧的表示形式（岛）之后，我们拉伸了纹理像素，以使它们现在以细长矩形棒的形式显示在立方体的左侧。 也就是说，对象上的纹理像素取决于该对象的展开方式。 通常，在对象的3D编辑器中，有机会跟踪扫描岛被压缩或拉伸的程度。 例如，在<b>Autodesk Maya中，</b>它看起来像这样： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/88b/7ed/eb7/88b7edeb730aefee4b0eecb0571b5704.jpg" alt="图片"><br><br> 红色表示强烈压缩，蓝色表示拉伸。 <br><br>  <b>岛屿密度</b> <br><br> 扫掠岛应该正确拉直而不会产生熨平板。 仍然应该在各个岛屿之间扩大规模。 即，该岛所占的面积必须与另一个岛的面积相对应。 否则，事实证明，一个实际面积为20平方厘米的岛将占据20％的纹理空间，而一个实际面积为100平方厘米的岛将占据5％的纹理空间。 从这里我们在显示岛上的纹素数量上存在分歧： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/570/f3e/b57/570f3eb57afa711d7e4b6cf26ade2221.jpg" alt="图片"><br><br> 立方体右侧的岛很小，只能显示25个像素。 在这方面，渲染根据岛的面积增加了纹理像素，并且我们看到了较大的正方形。 <br><br> 在左侧，该岛非常大-它覆盖了很大的纹理空间，并且能够容纳更多的纹理像素，这就是屏幕上发生的情况。 上侧具有平均大小。 <br><br> 也就是说，为了使模型正确地纹理化，您需要对齐所有岛的面积，以使它们彼此之间相等： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2b1/457/9af/2b14579af43e7cf3845f4bbc2147317d.jpg" alt="图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上图是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habrochanin Osmandos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的文章的图片</font><font style="vertical-align: inherit;">。他的文章在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。推荐阅读。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">纹理大小</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果返回到立方体，我们将看到其上的纹理像素（在此示例中为黑色和白色正方形）非常大（再次，有条件地。想象一下，在当前纹理中，正方形为纹理像素）。即使对齐所有孤岛，我们仍会在立方体的侧面看到黑色和白色正方形：</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/741/046/443/74104644386e47e3269121b082329066.jpg" alt="图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这表明我们当前的纹理尺寸质量不够高，因此可以看到纹理像素。但是是这样吗？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">想象一下，当前纹理（通常称为“检查器”（Checker）-用于检查正确的岛设置的纹理）的尺寸为63 x 63纹素。现在我们看到了纹理像素，因为该对象离我们的相机非常近，以至于一个纹理像素的大小（有条件地）占据了显示器的30x30像素区域。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果我们将立方体从相机上移开？</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/885/ace/1e8/885ace1e84d3225314f75d318067dbff.jpg" alt="图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在尝试在此立方体上制作纹理像素吗？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在1纹素的大小等于1像素（但这是不准确的）。这种纹理的大小是理想的，因为它可以显示所有纹理像素，并且不显示任何多余的东西，也不隐藏任何多余的东西。对于这样的距离，这是理想的尺寸。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也就是说，纹理的大小在很大程度上取决于模型扫描所占据的区域以及对象到相机的距离。如果物体距我们的距离足够大，则在指甲上给它提供8k的纹理是没有意义的。即使您为影片制作纹理，也没有人会在女孩的指甲上看到一条白色的条带，该女孩的手占据了屏幕面积的3％。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">总计</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重要的是要了解模型的比例以及模型相对于摄影机的位置，以便正确调整纹理的大小。我经常看到独立开发商的游戏忽略了这些简单的规则，结果导致它们的纹理质量不是最好的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">别忘了将岛彼此相对对齐-这很重要，并且会极大地影响感知。</font><font style="vertical-align: inherit;">例如，如果您打开游戏《辐射4（Fallout 4）》并与一些NPS进行对话，您会发现角色衣服上的纹理质量非常不理想，并且脸部具有最大的纹理尺寸：</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b0b/1a7/75e/b0b1a775e52247ca8946546f9092a96f.jpg" alt="图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值得记住的是，在游戏中通常会特别低估游戏中的纹理尺寸。性能。</font><font style="vertical-align: inherit;">当角色的脸上有如此有趣的疤痕时，谁看衣服？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大尺寸的纹理会占用很大的空间（在内存中，我的意思是）。</font><font style="vertical-align: inherit;">因此，许多开发者会做出艰难的决定-如果仅在PC /主机/电话上游戏不慢下来，该砍什么，该留下什么。</font><font style="vertical-align: inherit;">但是，我们将回到这个问题，并考虑可以避免此类麻烦的最新技术。</font></font><br><br><h3>   </h3><script type="text/javascript">function gtElInit() {var lib = new google.translate.TranslateService();lib.translatePage('ru', 'zh-CN', function () {});}</script><script type="text/javascript" src="https://translate.google.com/translate_a/element.js?cb=gtElInit&amp;client=wt"></script><br> 什么是纹理烘焙？ <br><br> 纹理烘焙是指用于创建纹理的程序包开始计算最终结果并将其保存在单独的文件中，然后借助该模型将模型绘制到游戏引擎中。 <br><br> 粗略地说，在Substance Painter中，我们通过蒙版和其他技巧逐层应用，以达到最终效果。 我们正在研究最终模型的外观，并混合了各种材料。 但是，如果您注意到-图层，蒙版和材质的组合越困难，处理对程序所做的更改就越困难。 事实是，Substance Painter（任何其他纹理处理程序）会检查您的每一次更改并实时计算您创建的所有图层和通道（我提醒您，您也可以将自己的通道添加到图层中以进行任何操作）落在texel上。 <br><br> 当我们对结果满意并准备将其上传到游戏引擎时，我们要求Substance Painter进行最后的计算，并创建一个具有每个像素颜色参数的纹理，以及3个具有Metallic，Roughness和Normal Map参数的附加纹理。 这将使我们不必在游戏中上载大量的蒙版和其他材料，而不是迫使引擎重新计算所有内容，而只是向其提供最终结果，它将转换为模型的纹理。 <br><br> 总的来说，我们找出了烘焙的质地。 但是，我们需要研究如何将参数卸载到纹理中，以便了解如何控制数据将进入纹理的哪个通道。 这很重要，因为图像标准中仍然只有4个通道。 而且我们需要能够选择参数将进入哪个通道，以便以后可以快速连接它们。 <br><br> 现在，我们回到项目中的Substance Painter，开始卸载纹理。 为此，请打开用于导出纹理的窗口（文件-导出纹理）： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d2d/9ad/036/d2d9ad036103cc213efd167def4b7fa2.jpg" alt="图片"><br><br> 从一开始就是这样。 如果扩展纹理集，我们将看到将导出导出的文件列表： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4fa/fe3/d4e/4fafe3d4e459411c87a292953d15d6a3.jpg" alt="图片"><br><br> 如您所见，与我们下载的9个文件相比，应导出4个纹理文件。 <br><br> 但是他们对我们不感兴趣，因为它们是标准设置，但是我们需要我们自己的设置（或根据您工作的工作室的标准）。 因此，我们将转到“ <b>配置”</b>窗口： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a30/c73/8db/a30c738db622da9ad5615ef6af6fd465.jpg" alt="图片"><br><br> 首先，创建新的预设并选择它们，以免破坏完成的预设： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5a4/7dc/353/5a47dc353614367c1874af2e2a994aaa.jpg" alt="图片"><br><br> 现在注意右侧的面板： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/52e/596/d99/52e596d992106e0ad66e8690f2f9afaa.jpg" alt="图片"><br><br>  <b>输入地图</b>是我们使用的通道列表。 它们中的大多数都有名称，因为它们用于特定目的的PBR。 有8个通道（0到7）是可编辑的，但是Substance Painter不知道您为什么需要它们，因此通道的标准名称为User0-User7。 <br><br>  <b>转换后</b>的贴图是取决于渲染类型的纹理列表。 例如，法线贴图取决于引擎。 而且我们需要知道引擎使用哪种API-DirectX或OpenGL，以便为其选择正确的法线贴图。 因此，Substance Painter会在单独的类别中选择这些卡，因为它们的最终结果将取决于您选择的内容。 <br><br>  <b>网格贴图</b> -随对象加载或在处理对象时生成的那些纹理。 我们下载了9个纹理。 其中有8个属于图层（材质），第9个斜角法线贴图已经与该对象直接相关。 除法线贴图外，我们还创建了一个曲率贴图以覆盖其上的切屑。 这些卡专门与对象有关，不能用作物料的基础，因此将它们放在单独的列表中。 <br><br> 现在考虑纹理创建面板： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f7e/ce7/f8c/f7ece7f8c70004995cdfd3ea59bc38d8.jpg" alt="图片"><br><br> 这些是按钮，通过单击可在其中创建1个纹理文件（更准确地说，为创建它准备一切）。 <br><br>  <b>灰色</b> -创建具有单个通道的纹理。 在此通道中，我们可以放置任何设置-粗糙度，金属，镜面反射，发光。 所有这些设置都可以在一个通道中使用。 <br><br>  <b>RGB-</b>创建具有3个连接通道的纹理。 也就是说，它用于诸如颜色（BaseColor），法线贴图的参数。 也就是说，对于使用3个通道来完全实现自己的所有参数。 <br><br>  <b>R + G + B-</b>创建具有3个未连接通道的纹理。 也就是说，我们有一个带有三个Gray通道的纹理。 我们可以在每个纹理通道中分别指定一个带有1个通道的参数。 这通常用于ORM-（遮挡-粗糙度-金属）。 也就是说，环境光遮挡存储在第一个通道中，粗糙度存储在第二个通道中，金属色存储在第三个通道中。 <br><br>  <b>RGB + A-</b>您猜对了-3个已连接通道和1个未连接通道。 <br><br>  <b>R + G + B + A-</b>四个未连接的通道。 <br><br> 现在，知道了这一点，考虑一下我们需要上传多少文件，有关该对象的最终纹理应如何显示的所有信息。 <br><br> 没错，至少3个纹理： <br><br><ol><li>  RGB-基色 </li><li>  R + G + B-ORM </li><li>  RGB-法线贴图 </li></ol><br> 单击您需要的纹理，然后得到以下列表： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e70/9d6/673/e709d6673ed3be2d90c065ceb31212f2.jpg" alt="图片"><br><br> 不要忘了正确命名纹理，否则我们将无法弄清楚什么在哪里以及如何使用。 <br><br> 现在我们需要指出哪些参数将存储在哪些通道中。 为此，只需将参数从“输入映射”传输到所需的通道。 由于UE4使用此普通读取格式，因此需要将普通地图迁移到DirectX。 <br><br> 结果，我们得到以下设置： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/567/aaa/078/567aaa07857405711eb92bfec2c9989b.jpg" alt="图片"><br><br> 现在切换回导出。 我们有： <br><br><ul><li> 我们指出保存的路径。 </li><li> 选择我们在“配置”选项中创建的预设。 </li><li> 选择纹理类型-Targa。 </li><li> 单击导出。 </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/807/2f7/27e/8072f727e92abb8b498ee328e5d1b512.jpg" alt="图片"><br><br> 瞧-纹理导出很成功。 在Photoshop中打开BC（BaseColor）纹理并查看它： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3b0/64b/cb6/3b064bcb6d06e64624e91cb1e27da4a2.jpg" alt="图片"><br><br> 您还记得我们如何在不同的图层中创建两种不同的材料吗？  Substance Painter折叠了所有图层，计算了将覆盖对象的纹理的最终版本的结果，并在完全遮盖它们时“烘焙”了所有纹理像素。 他对“法线贴图”，“粗糙度”和“金属”也做了相同的处理。 <br><br> 如果我们在Photoshop中打开ORM贴图，请转到通道显示模式并选择最后一个（蓝色），然后我们将看到烘焙的Metallic贴图： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2a4/cd2/7f0/2a4cd27f099f8b25c176a26af2ac7fec.jpg" alt="图片"><br><br> 从这张地图中，您可以想象岛应该在哪里，而不是金属。 <br><br>  <b>合计</b> <br><br> 我们学习了如何为游戏引擎创建现成的纹理。 <br><br> 这很重要。 现在，我们学习了如何烘焙纹理，并完成了在Substance Painter中创建这些纹理的整个过程。 也就是说，我们做了一切工作以获取现成的纹理，我们现在可以将其用于不同的引擎中（需要注意的是处理某些PBR参数）。 这种方法的缺点-如果需要从根本上更改某些内容-我们必须返回程序并重做纹理。 <br><br> 要计算如何正确显示纹理像素的颜色和光，视频卡需要对每个纹理像素进行计算。 而且，它不取决于显示器上有多少像素。 这将取决于纹理形成中使用了多少个纹理像素（我们在放样器中使用标准设置，这意味着我们使用1024 * 1024像素）。 也就是说，要正确显示纹理，画家需要计算每个像素，并考虑您在其中创建的所有层。 这是一项耗时的任务，因此较早（现在）的PBR纹理主要是在纹理程序中创建的。 <br><br><h3> 虚幻引擎4 </h3><br> 最后，在UE4中卸载我们的对象并查看我们的结果。 我将不介绍如何打开UE4，如何创建项目，完全如何安装它以及在此处按什么按钮。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">Flakky提供了</a>非常好的课程。 课程全部位于他的网站<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">uengine.ru上</a> 。 <br><br> 现在，我们将只考虑商店的导入和所产生的纹理，原始着色器的创建并进行总结。 <br><br> 首先，打开项目并在其中创建一个“ Bench”文件夹，将所有纹理和对象放入其中。 要导入所有纹理-只需将它们从浏览器传输到项目即可。 它们被导入而没有任何问题，并且不会要求其他设置。 至于对象，导入时，虚幻引擎会要求您指定一些设置。 通常，除了2个参数外，无需进行其他任何更改。 必须禁用它们： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0bd/322/550/0bd322550ad9a0a66bb0fa88b986bb6d.jpg" alt="图片"><br><br> 这些参数负责导入纹理，我们将它们分开存储。 <br><br> 结果，在我们的文件夹中有3个纹理和1个对象： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7d0/41c/057/7d041c057a1722892d1a8c9807584398.jpg" alt="图片"><br><br> 现在，在项目浏览器的任何可用空间中，单击“人民币”，然后选择“材质”： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/82a/c97/f78/82ac97f781092cd42b6cedcc0ef26b85.jpg" alt="图片"><br><br> 将其命名为M_Bench。 <br><br> 打开它，然后将所有纹理拖入其中。 我们得到以下图片： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/33c/6c7/e76/33c6c7e7688f83bc64afb1698dc37f37.jpg" alt="图片"><br><br> 这些是Node容器，可让您直观地查看设置，以便即使是新手也可以方便地使用它们（非常感谢Epic Games节点的成功实现。特别是没有Blueprints系统和节点，很多人可能会从数字和代码中抽头）。 纹理（左侧的节点）上的白色针脚（输出和输入）指示一次送入三个通道。 但是红色，绿色和蓝色-每个通道分开。 最后一个灰色的通道是Alpha通道，但它不在我们的纹理中，因此我们将不使用此引脚。 右侧是一个大型节点，它接受参数，对其进行汇总并创建完整的材料。 <br><br> 这里（以及在任何其他游戏引擎中）使用了Substance Painter中纹理工作的全部原理-您指出什么需要什么参数，然后程序给出结果。 在这种情况下，Substance Painter接管了大部分计算，而虚幻引擎只是简单地将Painter的最终结果加起来并创建可以放在工作台上的现成的着色器（材质）。 <br><br> 我们只需要正确连接引脚，并要求引擎为我们计算结果即可： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/251/58f/4cb/25158f4cb4ff278b7cb401a5ee5e0ab1.jpg" alt="图片"><br><br> 为什么我没有在“环境光遮挡”中从ORM纹理中粘贴红色通道？ 我已经提到过AO被认为是过时的，因为AO通常是实时计算的。 并且在材质节点中有一个“环境光遮挡”销钉，但是它不起作用。 甚至没有考虑到它。 由于某种原因离开了这里。 我想删除它需要大量的工作。 <br><br> 这样啊 我们已经准备好了最简单的着色器（材质），最后可以对我们的车间进行喷涂。 为此，请使用LMB单击两次以在UE4中打开商店。 并将材质从项目浏览器拖动到材质插槽中： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eeb/97d/a15/eeb97da159b888969a435eb7a7752e44.jpg" alt="图片"><br><br> 好吧 现在，您已收到第一个完成的对象。 <br><br> 您可以自己查看结果，但我仅作总结。 <br><br>  <b>合计</b> <br><br> 通过非常简单的形式，我们学习了如何在UE4引擎中创建第一个着色器。 您问-为什么将其称为“材质”而不是引擎本身中的着色器？ 解释这是哪种纹理构建格式更容易-这是叠加在对象上的材料，对象变得漂亮。 但是，着色器的功能比仅显示纹理要强大得多（数百倍）。 <br><br>  <b>台上</b>  <b>解决倒角问题</b> <br><br> 上面，我确定了倒角的问题以及解决方法。 但是还有第二种方法，这部分我们将不完全考虑-这是在模型上创建倒角并对齐法线，以便网格的表面产生漂亮的斜角的错觉。 通过对齐顶点的法线（切线）来创建这样的倒角。 而且此方法的性能甚至比使用法线贴图的方法更经济，并且相对于通常的倒角纹理，其美观程度极高。 这是一个立在我们的游戏项目（尚未宣布）中的门的示例： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8de/231/5fb/8de2315fbaa8ae9875629aba3c5a5179.jpg" alt="图片"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/76e/d12/0ff/76ed120fff2043d22b59fef7791cde46.jpg" alt="图片"><br><br> 我仅在英语资源上才遇到有关此主题的信息。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a> 。 <br><br> 这种方法的优点是我们可以创建漂亮的构面，而顶点的数量不会增加太多，因为硬边在一个点上始终是2个顶点，而软边是1个顶点，并且数量增加了绘制三角形： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f1d/019/a92/f1d019a928ef3031aaaab1e15585d3c1.jpg" alt="图片"><br><br> 值得记住的是，在99％的情况下，我们需要为对象创建法线贴图以创建倒角。 材料和某些个别元素的法线贴图是一个稍微不同的主题。 <br><br>  <b>合计</b> <br><br> 哦。 好吧，重要的是这一部分。 但是有必要完全涵盖标准纹理的主题。 在此我们可以停止。 <br><br> 好吧，事实是，我们已经从显示器上几乎看不见的像素元素变成了复杂的掩模方案，这些掩模确定了同样复杂的材料层的可见性。 最后，我们将单词pixel分为两个像素-texel和pixel。 我们学会了在游戏引擎中烘焙并连接所有这些内容。 在这一步，您可以画一条<b>长长的粗线，</b>并说我们已经成为真正的纹理艺术家。 其他一切-切碎物体的美感，视觉表现形式的摄影-这都是时间的积累和对学习新技术和方法的不断渴望。 <br><br> 您可以观看更多课程并提高技能。 例如，在Substance Designer中，有一个庞大的生成器砧，您可以将其创建为它们的图层生成器。 所有这些用于污垢的面罩，不再是手动创建的，而是在可以为您完成精美一切工作的功能级别实现的。 <br><br> 您应该永远记住，我们考虑的值范围是0到1。这很重要，因为标准纹理每个通道有8位，而HDR纹理具有更宽的通道（从16位或更多），这意味着数量范围很大大于0到255。但这仍然是0到1的范围。 <br><br> 一切似乎都是极限。 我们已经对如何创建纹理有了很高的了解。 您可以放下所有东西，然后为共享模型和纹理的任何公司作为纹理艺术家工作（例如，就像我们所做的那样）。 <br><br> 但是是这样吗？ 我们真的达到纹理化的极限了吗，它还会失败吗？ <br> 还是还有更多的增长空间？ <br><br> 是的 我们还剩下一名导师，这将使纹理化迈向新的技术飞跃，而我谦虚地认为，这将代表下一代纹理化。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN458988/">https://habr.com/ru/post/zh-CN458988/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN458972/index.html">本周新闻：Yandex和西方情报机构，FAS打击在线赌场，交通部监管BlaBlaCar</a></li>
<li><a href="../zh-CN458974/index.html">斯维尔特（Svelte）一生</a></li>
<li><a href="../zh-CN458982/index.html">Nginx食谱：从HTML和URL转换为PDF和PS</a></li>
<li><a href="../zh-CN458984/index.html">如何创建第一个交易所交易应用程序：3个初始步骤</a></li>
<li><a href="../zh-CN458986/index.html">PostgreSQL食谱：从HTML和URL转换为PDF和PS</a></li>
<li><a href="../zh-CN458990/index.html">不再热衷于代码中的注释</a></li>
<li><a href="../zh-CN458992/index.html">注意假装和在Keras中的实施</a></li>
<li><a href="../zh-CN458994/index.html">Raspberry Pi + CentOS = Wi-Fi热点（或Red Hat中的Raspberry Router）</a></li>
<li><a href="../zh-CN458996/index.html">用户Inyerface-如何不折磨用户</a></li>
<li><a href="../zh-CN459000/index.html">我如何尝试改善Halo 2，但几乎毁了它</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>