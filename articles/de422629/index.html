<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßóüèΩ üèß ü¶Ü H√∂r auf, die Holzf√§ller zu f√ºttern! Gib mehr Modifikatoren! Lazy Static Final Fields. Entwurf einer Feature-Skizze ‚ôüÔ∏è üèÇüèª üßíüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es reicht aus, dass in Java Logger zum Zeitpunkt der Initialisierung der Klasse initialisiert werden. Warum verunreinigen sie den gesamten Start? John...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>H√∂r auf, die Holzf√§ller zu f√ºttern! Gib mehr Modifikatoren! Lazy Static Final Fields. Entwurf einer Feature-Skizze</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/422629/"><p>  Es reicht aus, dass in Java Logger zum Zeitpunkt der Initialisierung der Klasse initialisiert werden. Warum verunreinigen sie den gesamten Start?  John Rose zur Rettung! </p><br><p>  So k√∂nnte es aussehen: </p><br><pre><code class="java hljs">lazy <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Logger LOGGER = Logger.getLogger(<span class="hljs-string"><span class="hljs-string">"com.foo.Bar"</span></span>);</code> </pre> <br><p>  Dieses Dokument erweitert das Verhalten der endg√ºltigen Variablen, sodass Sie optional die verz√∂gerte Ausf√ºhrung unterst√ºtzen k√∂nnen - sowohl in der Sprache selbst als auch in der JVM.  Es wird vorgeschlagen, das Verhalten der vorhandenen Mechanismen des Lazy Computing durch √Ñndern der Granularit√§t zu verbessern: Jetzt ist es nicht mehr klassengenau, sondern auf eine bestimmte Variable genau. </p><br><img src="https://habrastorage.org/webt/zf/6q/yz/zf6qyzherz5jt3ufyhfp9rz70t4.png"><a name="habracut"></a><br><h1 id="motivaciya">  Motivation </h1><br><p>  Java hat tief in Lazy Computing eingebaut.  Fast jede Verbindungsoperation kann faulen Code ziehen.  Beispiel: Ausf√ºhren der Methode <code>&lt;clinit&gt;</code> (Bytecode des Klasseninitialisierers) oder Verwenden der Bootstrap-Methode (f√ºr eine aufgerufene dynamische Aufrufsite oder <code>CONSTANT_Dynamic</code> Konstanten). </p><br><p>  Klasseninitialisierer sind im Vergleich zu Mechanismen, die Bootstrap-Methoden verwenden, in Bezug auf die Granularit√§t sehr unh√∂flich, da ihr Vertrag darin besteht, den <em>gesamten</em> Initialisierungscode f√ºr die Klasse als <em>Ganzes</em> auszuf√ºhren, anstatt sich auf die Initialisierung zu beschr√§nken, die sich auf ein bestimmtes Feld der Klasse bezieht.  Die Auswirkungen einer solchen Rohinitialisierung sind schwer vorherzusagen.  Es ist schwierig, die Nebenwirkungen der Verwendung <em>eines</em> statischen Felds einer Klasse zu isolieren, da die Berechnung eines Feldes zur Berechnung <em>aller</em> statischen Felder dieser Klasse f√ºhrt. </p><br><p>  Wenn Sie ein Feld ber√ºhren, wirken sich diese auf alle aus.  In AOT-Compilern ist es daher besonders schwierig, statische Feldreferenzen zu optimieren, selbst f√ºr Felder mit einem leicht zu analysierenden konstanten Wert.  Sobald mindestens <em>ein</em> neu gestaltetes statisches Feld zwischen den Feldern √ºberf√ºllt ist, ist es unm√∂glich, <em>alle</em> Felder dieser Klasse vollst√§ndig zu analysieren.  Ein √§hnliches Problem zeigt sich bei den zuvor vorgeschlagenen Mechanismen zur Implementierung der Faltung von Konstanten (w√§hrend des <em>Javac-</em> Betriebs) f√ºr konstante Felder mit komplexen Initialisierern. </p><br><p>  Ein Beispiel f√ºr eine neu gestaltete Feldinitialisierung, die in verschiedenen Projekten bei jedem Schritt in jeder Datei erfolgt, ist die Initialisierung des Loggers. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Logger LOGGER = Logger.getLogger(<span class="hljs-string"><span class="hljs-string">"com.foo.Bar"</span></span>);</code> </pre> <br><p>  Diese harmlos aussehende Initialisierung startet unter der Haube eine enorme Menge an Arbeit, die w√§hrend der Initialisierung der Klasse ausgef√ºhrt wird - und dennoch ist es √§u√üerst unwahrscheinlich, dass der Logger zum Zeitpunkt der Initialisierung der Klasse wirklich ben√∂tigt wird oder m√∂glicherweise √ºberhaupt nicht ben√∂tigt wird.  Die M√∂glichkeit, die Erstellung bis zur ersten tats√§chlichen Verwendung zu verschieben, vereinfacht die Initialisierung und hilft in einigen F√§llen, diese Initialisierung insgesamt zu vermeiden. </p><br><p>  Endvariablen sind sehr n√ºtzlich, sie sind der Hauptmechanismus der Java-API, um die Konstanz von Werten anzuzeigen.  Lazy Variablen funktionierten auch gut.  Ab Java 7 spielten sie eine immer wichtigere Rolle in den Interna des JDK und wurden mit der Annotation <code>@Stable</code> .  JIT kann sowohl endg√ºltige als auch stabile Variablen optimieren - viel besser als nur einige Variablen.  Durch das Hinzuf√ºgen von faulen Endvariablen wird dieses n√ºtzliche Verwendungsmuster h√§ufiger, sodass es an mehreren Stellen verwendet werden kann.  Durch die Verwendung von Lazy Final-Variablen k√∂nnen Bibliotheken wie das JDK die Abh√§ngigkeit von <code>&lt;clinit&gt;</code> -Code verringern, was wiederum die Startzeit verk√ºrzen und die Qualit√§t der AOT-Optimierungen verbessern sollte. </p><br><h1 id="opisanie">  Beschreibung </h1><br><p>  Das Feld kann mit dem neuen Modifikator " <code>lazy</code> deklariert werden. Hierbei handelt es sich um ein Kontextschl√ºsselwort, das ausschlie√ülich als Modifikator wahrgenommen wird.  Ein solches Feld wird als Lazy <em>Field</em> bezeichnet und muss auch <code>static</code> und <code>final</code> Modifikatoren enthalten. </p><br><p>  Ein Lazy Field muss einen Initialisierer haben.  Der Compiler und die Laufzeit vereinbaren, den Initialisierer genau dann zu starten, wenn die Variable zum ersten Mal verwendet wird, und nicht, wenn die Klasse initialisiert wird, zu der dieses Feld geh√∂rt. </p><br><p>  Jedes <code>lazy static final</code> Endfeld wird zur Kompilierungszeit einem konstanten Poolelement zugeordnet, das seinen Wert darstellt.  Da die Elemente des konstanten Pools selbst tr√§ge berechnet werden, reicht es aus, einfach den richtigen Wert f√ºr jede statische tr√§ge Endvariable zuzuweisen, die diesem Element zugeordnet ist.  (Sie k√∂nnen mehr als eine Lazy-Variable an ein Element binden, dies ist jedoch kaum eine n√ºtzliche oder aussagekr√§ftige Funktion.) Der Attributname lautet <code>LazyValue</code> und muss sich auf ein konstantes Gender-Element beziehen, das ldc-codiert werden kann und in einen Lazy-Field-Typ konvertierbar ist .  Es sind nur Casts <code>MethodHandle.invoke</code> , die bereits in <code>MethodHandle.invoke</code> . </p><br><p>  Daher kann ein verz√∂gertes statisches Feld als benannter Alias ‚Äã‚Äãf√ºr ein konstantes Poolelement innerhalb der Klasse betrachtet werden, die dieses Feld deklariert hat.  Tools wie Compiler versuchen m√∂glicherweise irgendwie, dieses Feld zu verwenden. </p><br><p>  Ein Lazy Field ist niemals eine konstante Variable (im Sinne von JLS 4.12.4) und wird ausdr√ºcklich von der Teilnahme an konstanten Ausdr√ºcken ausgeschlossen (im Sinne von JLS 15.28).  Daher wird das <code>ConstantValue</code> Attribut niemals erfasst, selbst wenn sein Initialisierer ein konstanter Ausdruck ist.  Stattdessen erfasst das Lazy-Feld eine neue Art von Klassendatei-Attribut namens <code>LazyValue</code> , das die JVM beim Verkn√ºpfen mit diesem bestimmten Feld konsultiert.  Das Format dieses neuen Attributs √§hnelt dem vorherigen, da es auch auf ein Element des konstanten Pools verweist, in diesem Fall auf das Element, das in den Feldwert aufgel√∂st wird. </p><br><p>  Wenn ein verz√∂gertes statisches Feld verkn√ºpft ist, sollte der normale Prozess der Ausf√ºhrung von Klasseninitialisierern <em>nicht</em> verschwinden.  Stattdessen wird jede deklarierende Klasse <code>&lt;clinit&gt;</code> -Methode gem√§√ü den in JVMS 5.5 definierten Regeln initialisiert.  Mit anderen Worten, der <code>getstatic</code> Bytecode f√ºr ein verz√∂gertes statisches Feld f√ºhrt die gleiche Verkn√ºpfung aus wie f√ºr <em>jedes</em> statische Feld.  Nach der Initialisierung (oder w√§hrend der bereits gestarteten Initialisierung des aktuellen Threads) l√∂st die JVM die dem Feld zugeordneten konstanten Poolelemente auf und speichert die aus dem konstanten Pool erhaltenen Werte in diesem Feld. </p><br><p>  Da Lazy Static Final nicht leer sein kann, k√∂nnen ihnen keine Werte zugewiesen werden - auch nicht in den wenigen Kontexten, in denen dies f√ºr leere Finalvariablen funktioniert. </p><br><p>  W√§hrend der Kompilierung werden alle verz√∂gerten statischen Felder unabh√§ngig von nicht verz√∂gerten statischen Feldern initialisiert, unabh√§ngig von ihrer Position im Quellcode.  Daher gelten Einschr√§nkungen f√ºr die Position statischer Felder nicht f√ºr verz√∂gerte statische Felder.  Der verz√∂gerte statische Feldinitialisierer kann jedes statische Feld derselben Klasse verwenden, unabh√§ngig von der Reihenfolge, in der sie in der Quelle angezeigt werden.  Der Initialisierer eines nicht statischen Felds oder der Klasseninitialisierer kann auf das Lazy-Feld zugreifen, unabh√§ngig davon, in welcher Reihenfolge in der Quelle sie relativ zueinander sind.  Normalerweise ist dies nicht die sinnvollste Idee, da die gesamte Bedeutung von Lazy-Werten verloren geht, sie kann jedoch m√∂glicherweise in bedingten Ausdr√ºcken oder im Kontrollfluss verwendet werden.  Faule statische Felder k√∂nnen daher eher wie Felder einer anderen Klasse behandelt werden - in dem Sinne, dass sie von jedem Teil der Klasse, in der sie deklariert sind, in beliebiger Reihenfolge referenziert werden k√∂nnen. </p><br><p>  Lazy Fields k√∂nnen mithilfe der Reflection-API mithilfe von zwei neuen API-Methoden in <code>java.lang.reflect.Field</code> erkannt werden.  Die neue <code>isLazy</code> Methode gibt <code>true</code> dann <code>true</code> zur√ºck <code>true</code> wenn das Feld einen <code>lazy</code> Modifikator enth√§lt.  Die neue <code>isAssigned</code> Methode gibt nur dann <code>false</code> wenn das Feld faul ist und zum Zeitpunkt des <code>isAssigned</code> noch nicht initialisiert <code>isAssigned</code> .  (Abh√§ngig vom Vorhandensein von Rennen kann es fast beim n√§chsten Aufruf im selben Thread true zur√ºckgeben.)  Es gibt keine andere M√∂glichkeit, herauszufinden, ob ein Feld initialisiert ist, als <code>isAssigned</code> . </p><br><p>  (Der Aufruf von <code>isAssigned</code> wird <code>isAssigned</code> ben√∂tigt, um bei seltenen Problemen im Zusammenhang mit der L√∂sung zirkul√§rer Abh√§ngigkeiten zu helfen. Vielleicht k√∂nnen wir auf die Implementierung dieser Methode verzichten. Allerdings m√∂chten <code>isAssigned</code> , die Code mit faulen Variablen schreiben, dies manchmal wissen ob der Wert auf eine solche Variable gesetzt ist oder noch nicht, √§hnlich wie Mutex-Benutzer manchmal anhand des Mutex herausfinden m√∂chten, ob er gesperrt ist oder nicht, aber sie m√∂chten nicht wirklich gesperrt werden. </p><br><p>  Es gibt eine ungew√∂hnliche Einschr√§nkung f√ºr verz√∂gerte Endfelder: Sie sollten niemals auf ihre Standardwerte initialisiert werden.  Das hei√üt, das verz√∂gerte Referenzfeld sollte nicht auf <code>null</code> initialisiert werden, und numerische Typen sollten keinen Nullwert haben.  Ein fauler boolescher Wert kann mit nur einem Wert initialisiert werden - <code>true</code> , da <code>false</code> der Standardwert ist.  Wenn der Initialisierer eines verz√∂gerten statischen Felds seinen Standardwert zur√ºckgibt, schl√§gt die Verkn√ºpfung dieses Felds mit dem entsprechenden Fehler fehl. </p><br><p>  Diese Einschr√§nkung wird daf√ºr eingef√ºhrt.  Damit JVM-Implementierungen Standardwerte als internen Watchdog-Wert reservieren k√∂nnen, der den Status eines nicht initialisierten Felds kennzeichnet.  Der Standardwert ist bereits im Anfangswert eines Feldes festgelegt, das zum Zeitpunkt der Vorbereitung festgelegt wurde (dies wird in JLS 5.4.2 beschrieben).  Dieser Wert existiert also nat√ºrlich bereits zu Beginn des Lebenszyklus eines Feldes und ist daher eine logische Wahl f√ºr die Verwendung als Watchdog-Wert, der den Status dieses Felds √ºberwacht.  Mit diesen Regeln k√∂nnen Sie niemals den urspr√ºnglichen Standardwert aus einem verz√∂gerten statischen Feld abrufen.  Hierzu kann die JVM beispielsweise ein Lazy Field als unver√§nderliche Verkn√ºpfung zum entsprechenden Konstantenpoolelement implementieren. </p><br><p>  Einschr√§nkungen der Standardwerte k√∂nnen umgangen werden, indem die Werte (die m√∂glicherweise den Standardwerten entsprechen) in Felder oder Container eines geeigneten Typs eingeschlossen werden.  Eine Nullzahl kann in eine Ganzzahlreferenz ungleich Null eingeschlossen werden.  Nicht-primitive Typen k√∂nnen in Optional eingeschlossen werden, das leer wird, wenn es auf null trifft. </p><br><p>  Um die Freiheit bei der Implementierung von Features zu wahren, werden die Anforderungen an die <code>isAssigned</code> Methode besonders untersch√§tzt.  Wenn die JVM nachweisen kann, dass eine verz√∂gerte statische Variable ohne beobachtbare externe Effekte initialisiert werden kann, kann sie diese Initialisierung jederzeit durchf√ºhren.  In diesem Fall gibt <code>isAssigned</code> <code>true</code> auch wenn <code>getfield</code> noch nie aufgerufen wurde.  Die einzige Anforderung, die an <code>isAssigned</code> wird, ist, dass bei der R√ºckgabe von <code>false</code> keine der Nebenwirkungen der Variableninitialisierung im aktuellen Thread beobachtet werden sollten.  Und wenn er <code>true</code> zur√ºckgibt, kann der aktuelle Thread in Zukunft die Nebenwirkungen der Initialisierung beobachten.  Ein solcher Vertrag erm√∂glicht es dem Compiler, <code>getstatic</code> f√ºr seine eigenen Felder durch <code>ldc</code> zu ersetzen, wodurch die JVM keine detaillierten Zust√§nde von <code>getstatic</code> √ºberwachen kann, die gemeinsame oder entartete Elemente im konstanten Pool haben. </p><br><p>  Mehrere Threads k√∂nnen in einen Race-Status wechseln, um ein faules Endfeld zu initialisieren.  Wie bereits bei <code>CONSTANT_Dynamic</code> w√§hlt die JVM einen beliebigen Gewinner dieses Rennens aus und stellt den Wert dieses Gewinners allen am Rennen teilnehmenden Threads zur Verf√ºgung und schreibt ihn f√ºr alle nachfolgenden Versuche, einen Wert zu erhalten.  Um das Rennen zu umgehen, versuchen bestimmte JVM-Implementierungen m√∂glicherweise, CAS-Operationen zu verwenden. Wenn die Plattform diese unterst√ºtzt, wird dem Gewinner des Rennens der vorherige Standardwert und den Verlierern der nicht standardm√§√üige Wert angezeigt, der das Rennen gewonnen hat. </p><br><p>  Somit funktionieren die bestehenden Regeln f√ºr die einmalige Zuweisung endg√ºltiger Variablen weiterhin und erfassen nun alle Schwierigkeiten des Lazy Computing. </p><br><p>  Die gleiche Logik gilt f√ºr das sichere Ver√∂ffentlichen mit endg√ºltigen Feldern - sie gilt sowohl f√ºr verz√∂gerte als auch f√ºr nicht verz√∂gerte Felder. </p><br><p>  Beachten Sie, dass eine Klasse ein statisches Feld in ein verz√∂gertes statisches Feld konvertieren kann, ohne die Bin√§rkompatibilit√§t zu beeintr√§chtigen.  Die <code>getstatic</code> client <code>getstatic</code> in beiden F√§llen identisch.  Wenn eine Variablendeklaration in Lazy <code>getstatic</code> , wird <code>getstatic</code> auf andere Weise verkn√ºpft. </p><br><h1 id="alternativnye-resheniya">  Alternative L√∂sungen </h1><br><p>  Sie k√∂nnen verschachtelte Klassen als Container f√ºr verz√∂gerte Variablen verwenden. </p><br><p>  Sie k√∂nnen so etwas wie eine Bibliotheks-API zum Verwalten von Lazy-Werten oder (allgemeiner) monotoner Daten definieren. </p><br><p>  Refactor, was sie faulen statischen Variablen machen wollten, so dass sie zu statischen Nullmethoden wurden und ihre K√∂rper in irgendeiner Weise unter Verwendung von ldc CONSTANT_Dynamic-Konstanten ver√∂ffentlicht wurden. </p><br><p>  (Hinweis: Die obigen Problemumgehungen bieten keine bin√§rkompatible M√∂glichkeit, vorhandene statische Konstanten evolution√§r von ihrer <code>&lt;clinit&gt;</code> zu entkoppeln.) </p><br><p>  Wenn wir √ºber die Bereitstellung <em>weiterer</em> Funktionen sprechen, k√∂nnen Sie zulassen, dass verz√∂gerte Felder nicht statisch oder nicht endg√ºltig sind, w√§hrend die aktuellen Entsprechungen und Analogien zwischen dem Verhalten statischer und nicht statischer Felder beibehalten werden.  Ein konstanter Pool kann kein Repository f√ºr nicht statische Felder sein, kann jedoch Bootstrap-Methoden enthalten (abh√§ngig von der aktuellen Instanz).  Gefrorene Arrays (falls implementiert) k√∂nnen eine verz√∂gerte Option erhalten.  Solche Studien sind eine gute Grundlage f√ºr zuk√ºnftige Projekte, die auf der Grundlage dieses Dokuments erstellt wurden.  √úbrigens machen solche M√∂glichkeiten unsere Entscheidung, Standardwerte zu verbieten, noch aussagekr√§ftiger. </p><br><p>  Lazy-Variablen m√ºssen mit ihren eigenen Initialisierungsausdr√ºcken initialisiert werden.  Manchmal scheint dies eine sehr unangenehme Einschr√§nkung zu sein, die uns in die Zeit der Erfindung leerer Endvariablen zur√ºckversetzt.  Denken Sie daran, dass diese leeren endg√ºltigen Variablen mit beliebigen Codebl√∂cken einschlie√ülich der Try-finally-Logik initialisiert werden k√∂nnen und nicht gleichzeitig, sondern in Gruppen initialisiert werden k√∂nnen.  In Zukunft wird es m√∂glich sein, die gleichen M√∂glichkeiten auf faule Endvariablen anzuwenden.  M√∂glicherweise k√∂nnen eine oder mehrere verz√∂gerte Variablen einem privaten Block von Initialisierungscode zugeordnet werden, dessen Aufgabe es ist, jede Variable genau einmal zuzuweisen, wie dies bei einem Klasseninitialisierer oder Objektkonstruktor der Fall ist.  Die Architektur eines solchen Merkmals kann nach dem Auftreten von Dekonstruktoren klarer werden, da sich die Aufgaben, die sie l√∂sen, in gewissem Sinne √ºberschneiden. </p><br><blockquote>  Minute der Werbung.  Die Joker 2018 Konferenz wird sehr bald stattfinden, wo es viele prominente Spezialisten f√ºr Java und JVM geben wird.  Die vollst√§ndige Liste der Redner und Berichte finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf der offiziellen Website</a> . </blockquote><br><h1 id="avtor">  Der Autor </h1><br><p>  <strong>John Rose</strong> ist JVM-Ingenieur und Architekt bei Oracle.  Leitender Ingenieur Da Vinci Machine Project (Teil von OpenJDK).  Der leitende Ingenieur JSR 292 (Unterst√ºtzung dynamisch typisierter Sprachen auf der Java-Plattform) ist auf dynamische Aufrufe und verwandte Themen wie Typprofilerstellung und erweiterte Compileroptimierungen spezialisiert.  Zuvor arbeitete er an inneren Klassen, erstellte den urspr√ºnglichen HotSpot-Port f√ºr SPARC, Unsafe API, und entwickelte viele dynamische, parallele und hybride Sprachen, einschlie√ülich Common Lisp, Scheme (‚Äûesh‚Äú) und dynamischer Ordner f√ºr C ++. </p><br><h1 id="perevodchik">  √úbersetzer </h1><br><p>  <strong>Oleg Chirukhin</strong> - <strong>Zum</strong> Zeitpunkt des Schreibens dieses Textes arbeitet er als Community Manager in der Firma JUG.ru Group und ist an der Popularisierung der Java-Plattform beteiligt.  Bevor er zu JRG kam, war er an der Entwicklung von Bank- und Regierungsinformationssystemen, einem √ñkosystem selbstgeschriebener Programmiersprachen und Online-Spielen beteiligt.  Aktuelle Forschungsinteressen umfassen virtuelle Maschinen, Compiler und Programmiersprachen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de422629/">https://habr.com/ru/post/de422629/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de422615/index.html">Die ganze Wahrheit √ºber RTOS. Artikel 9. Scheduler: Implementierung</a></li>
<li><a href="../de422617/index.html">Die ganze Wahrheit √ºber RTOS. Artikel 8. Nucleus SE: Internes Design und Bereitstellung</a></li>
<li><a href="../de422623/index.html">So sichern Sie C.</a></li>
<li><a href="../de422625/index.html">Wir haben mit Troy Miles gesprochen - dem Programmierer von "Neuromancer"</a></li>
<li><a href="../de422627/index.html">MongoDB und IT-Arbeitsmarktforschung</a></li>
<li><a href="../de422631/index.html">QIWI-Terminals. So holen Sie das Beste aus einfachen Technologien heraus</a></li>
<li><a href="../de422633/index.html">Wie wir die √úberwachung der Arbeit der Mitarbeiter des Tankstellennetzes des Bundes automatisiert haben</a></li>
<li><a href="../de422635/index.html">Sie haben das Wort "Hallo" noch nicht gesagt und wir wissen bereits, wer Sie sind</a></li>
<li><a href="../de422637/index.html">Geeks Geschenk: Auto-Alkash-Schutz</a></li>
<li><a href="../de422641/index.html">Polarnacht, Wasserpumpen und Smart Safe: 5 Studentenprojekte im Bereich IoT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>